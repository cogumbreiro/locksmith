/* Generated by CIL v. 1.3.2 */
/* print_CIL_Input is true */

#define __builtin_constant_p(X) 0

typedef unsigned int size_t;
typedef long long __quad_t;
typedef unsigned long long __u_quad_t;
typedef __u_quad_t __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef long __off_t;
typedef __quad_t __off64_t;
typedef int __pid_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef int __ssize_t;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef __builtin_va_list __gnuc_va_list;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[(int )(15U * sizeof(int ) - 2U * sizeof(void *))] ;
};
typedef __gnuc_va_list va_list;
typedef __mode_t mode_t;
typedef __ssize_t ssize_t;
typedef __time_t time_t;
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
struct _pthread_fastlock {
   long __status ;
   int __spinlock ;
};
struct _pthread_descr_struct;
typedef struct _pthread_descr_struct *_pthread_descr;
struct __anonstruct_pthread_mutex_t_16 {
   int __m_reserved ;
   int __m_count ;
   _pthread_descr __m_owner ;
   int __m_kind ;
   struct _pthread_fastlock __m_lock ;
};
typedef struct __anonstruct_pthread_mutex_t_16 pthread_mutex_t;
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
struct facstruct {
   char const   *name ;
   int code ;
};
typedef int __int32_t;
struct cfgoption {
   char const   *name ;
   int argtype ;
};
struct cfgstruct {
   char *optname ;
   char *strarg ;
   int numarg ;
   struct cfgstruct *nextarg ;
   struct cfgstruct *next ;
};
struct cl_cvd {
   char *time ;
   int version ;
   int sigs ;
   short fl ;
   char *md5 ;
   char *dsig ;
   char *builder ;
   int stime ;
};
typedef long __clock_t;
struct __anonstruct___sigset_t_12 {
   unsigned long __val[(int )(1024U / (8U * sizeof(unsigned long )))] ;
};
typedef struct __anonstruct___sigset_t_12 __sigset_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_22 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
struct __anonstruct__timer_23 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
struct __anonstruct__rt_24 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
struct __anonstruct__sigchld_25 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
struct __anonstruct__sigfault_26 {
   void *si_addr ;
};
struct __anonstruct__sigpoll_27 {
   long si_band ;
   int si_fd ;
};
union __anonunion__sifields_21 {
   int _pad[(int )(128U / sizeof(int ) - 3U)] ;
   struct __anonstruct__kill_22 _kill ;
   struct __anonstruct__timer_23 _timer ;
   struct __anonstruct__rt_24 _rt ;
   struct __anonstruct__sigchld_25 _sigchld ;
   struct __anonstruct__sigfault_26 _sigfault ;
   struct __anonstruct__sigpoll_27 _sigpoll ;
};
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_21 _sifields ;
};
typedef struct siginfo siginfo_t;
union __anonunion___sigaction_handler_39 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
struct sigaction {
   union __anonunion___sigaction_handler_39 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
struct optnode {
   char optchar ;
   char *optarg ;
   char *optname ;
   struct optnode *next ;
};
struct optstruct {
   struct optnode *optlist ;
   char *filename ;
};
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
typedef unsigned int __socklen_t;
typedef __socklen_t socklen_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
typedef uint16_t in_port_t;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[(int )(((sizeof(struct sockaddr ) - sizeof(unsigned short )) -
                                  sizeof(in_port_t )) - sizeof(struct in_addr ))] ;
};
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
typedef unsigned char __u_char;
typedef __u_char u_char;
struct __anonstruct_HEADER_22 {
   unsigned int id : 16 ;
   unsigned int rd : 1 ;
   unsigned int tc : 1 ;
   unsigned int aa : 1 ;
   unsigned int opcode : 4 ;
   unsigned int qr : 1 ;
   unsigned int rcode : 4 ;
   unsigned int cd : 1 ;
   unsigned int ad : 1 ;
   unsigned int unused : 1 ;
   unsigned int ra : 1 ;
   unsigned int qdcount : 16 ;
   unsigned int ancount : 16 ;
   unsigned int nscount : 16 ;
   unsigned int arcount : 16 ;
};
typedef struct __anonstruct_HEADER_22 HEADER;
typedef __pid_t pid_t;
struct cli_bm_patt {
   char *pattern ;
   char *virname ;
   char *offset ;
   char const   *viralias ;
   unsigned int length ;
   unsigned short target ;
   struct cli_bm_patt *next ;
};
struct cli_ac_patt {
   short *pattern ;
   unsigned int length ;
   unsigned int mindist ;
   unsigned int maxdist ;
   char *virname ;
   char *offset ;
   char const   *viralias ;
   unsigned short sigid ;
   unsigned short parts ;
   unsigned short partno ;
   unsigned short alt ;
   unsigned short *altn ;
   unsigned short type ;
   unsigned short target ;
   char **altc ;
   struct cli_ac_patt *next ;
};
struct cli_ac_node {
   char islast ;
   struct cli_ac_patt *list ;
   struct cli_ac_node *trans[256] ;
   struct cli_ac_node *fail ;
};
struct cli_md5_node {
   char *virname ;
   char *viralias ;
   unsigned char *md5 ;
   unsigned int size ;
   unsigned short fp ;
   struct cli_md5_node *next ;
};
struct cli_meta_node {
   int csize ;
   int size ;
   int method ;
   unsigned int crc32 ;
   unsigned int fileno ;
   unsigned int encrypted ;
   unsigned int maxdepth ;
   char *filename ;
   char *virname ;
   struct cli_meta_node *next ;
};
struct cl_node {
   unsigned int refcount ;
   unsigned int maxpatlen ;
   int *bm_shift ;
   struct cli_bm_patt **bm_suffix ;
   struct cli_ac_node *ac_root ;
   struct cli_ac_node **ac_nodetable ;
   unsigned int ac_partsigs ;
   unsigned int ac_nodes ;
   struct cli_md5_node **md5_hlist ;
   struct cli_meta_node *zip_mlist ;
   struct cli_meta_node *rar_mlist ;
};
struct nodelist {
   struct cli_ac_node *node ;
   struct nodelist *next ;
};
typedef unsigned long MD5_u32plus;
struct __anonstruct_MD5_CTX_22 {
   MD5_u32plus lo ;
   MD5_u32plus hi ;
   MD5_u32plus a ;
   MD5_u32plus b ;
   MD5_u32plus c ;
   MD5_u32plus d ;
   unsigned char buffer[64] ;
   MD5_u32plus block[16] ;
};
typedef struct __anonstruct_MD5_CTX_22 MD5_CTX;
struct SECTION {
   uint32_t rva ;
   uint32_t vsz ;
   uint32_t raw ;
   uint32_t rsz ;
};
struct cli_pe_info {
   uint32_t ep ;
   uint16_t nsections ;
   struct SECTION *section ;
};
typedef long __suseconds_t;
typedef int int32_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
typedef struct timezone * __restrict  __timezone_ptr_t;
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream;
typedef struct __dirstream DIR;
typedef __clock_t clock_t;
struct cl_stat {
   char *dir ;
   int no ;
   struct stat *stattab ;
   char **statdname ;
};
typedef void *voidp;
typedef voidp gzFile;
typedef __off_t off_t;
typedef unsigned char uint8_t;
struct mspack_file;
struct mspack_system {
   struct mspack_file *(*open)(struct mspack_system *this , char *filename , int mode ) ;
   struct mspack_file *(*dopen)(struct mspack_system *this , int desc , int mode ) ;
   void (*close)(struct mspack_file *file ) ;
   int (*read)(struct mspack_file *file , void *buffer , int bytes ) ;
   int (*write)(struct mspack_file *file , void *buffer , int bytes ) ;
   int (*seek)(struct mspack_file *file , off_t offset , int mode ) ;
   off_t (*tell)(struct mspack_file *file ) ;
   void (*message)(struct mspack_file *file , char *format  , ...) ;
   void *(*alloc)(struct mspack_system *this , size_t bytes ) ;
   void (*free)(void *ptr ) ;
   void (*copy)(void *src , void *dest , size_t bytes ) ;
   void *null_ptr ;
};
struct mspack_file {
   int dummy ;
};
struct mscab_decompressor;
struct mscabd_file;
struct mscabd_folder;
struct mscabd_cabinet {
   struct mscabd_cabinet *next ;
   char *filename ;
   int desc ;
   off_t base_offset ;
   unsigned int length ;
   struct mscabd_cabinet *prevcab ;
   struct mscabd_cabinet *nextcab ;
   char *prevname ;
   char *nextname ;
   char *previnfo ;
   char *nextinfo ;
   struct mscabd_file *files ;
   struct mscabd_folder *folders ;
   unsigned short set_id ;
   unsigned short set_index ;
   unsigned short header_resv ;
   int flags ;
};
struct mscabd_folder {
   struct mscabd_folder *next ;
   int comp_type ;
   unsigned int num_blocks ;
};
struct mscabd_file {
   struct mscabd_file *next ;
   char *filename ;
   unsigned int length ;
   int attribs ;
   char time_h ;
   char time_m ;
   char time_s ;
   char date_d ;
   char date_m ;
   int date_y ;
   struct mscabd_folder *folder ;
   unsigned int offset ;
};
struct mscab_decompressor {
   struct mscabd_cabinet *(*open)(struct mscab_decompressor *this , char *filename ) ;
   struct mscabd_cabinet *(*dopen)(struct mscab_decompressor *this , int desc ) ;
   void (*close)(struct mscab_decompressor *this , struct mscabd_cabinet *cab ) ;
   struct mscabd_cabinet *(*search)(struct mscab_decompressor *this , char *filename ) ;
   struct mscabd_cabinet *(*dsearch)(struct mscab_decompressor *this , int desc ) ;
   int (*append)(struct mscab_decompressor *this , struct mscabd_cabinet *cab , struct mscabd_cabinet *nextcab ) ;
   int (*prepend)(struct mscab_decompressor *this , struct mscabd_cabinet *cab , struct mscabd_cabinet *prevcab ) ;
   int (*extract)(struct mscab_decompressor *this , struct mscabd_file *file , char *filename ) ;
   int (*set_param)(struct mscab_decompressor *this , int param , int value ) ;
   int (*last_error)(struct mscab_decompressor * ) ;
};
struct _pthread_cleanup_buffer {
   void (*__routine)(void * ) ;
   void *__arg ;
   int __canceltype ;
   struct _pthread_cleanup_buffer *__prev ;
};
struct cl_limits {
   unsigned int maxreclevel ;
   unsigned int maxfiles ;
   unsigned int maxratio ;
   unsigned short archivememlim ;
   unsigned long maxfilesize ;
};
typedef unsigned char UBYTE;
typedef unsigned short UWORD;
typedef unsigned long UDWORD;
struct RAR20_archive_entry {
   char *Name ;
   UWORD NameSize ;
   UDWORD PackSize ;
   UDWORD UnpSize ;
   UBYTE HostOS ;
   UDWORD FileCRC ;
   UDWORD FileTime ;
   UBYTE UnpVer ;
   UBYTE Method ;
   UDWORD FileAttr ;
   UWORD Flags ;
};
struct archivelist {
   struct RAR20_archive_entry item ;
   struct archivelist *next ;
};
typedef struct archivelist ArchiveList_struct;
struct vba_project_tag {
   int count ;
   char **name ;
   uint32_t *offset ;
   uint32_t *length ;
   unsigned char *key ;
   char *dir ;
};
typedef struct vba_project_tag vba_project_t;
enum __anonenum_cli_file_t_36 {
    CL_TYPE_UNKNOWN_TEXT = 500,
    CL_TYPE_UNKNOWN_DATA = 501,
    CL_TYPE_MSEXE = 502,
    CL_TYPE_DATA = 503,
    CL_TYPE_POSIX_TAR = 504,
    CL_TYPE_OLD_TAR = 505,
    CL_TYPE_GZ = 506,
    CL_TYPE_ZIP = 507,
    CL_TYPE_BZ = 508,
    CL_TYPE_RAR = 509,
    CL_TYPE_MSSZDD = 510,
    CL_TYPE_MSOLE2 = 511,
    CL_TYPE_MSCAB = 512,
    CL_TYPE_MSCHM = 513,
    CL_TYPE_SCRENC = 514,
    CL_TYPE_GRAPHICS = 515,
    CL_TYPE_RIFF = 516,
    CL_TYPE_BINHEX = 517,
    CL_TYPE_TNEF = 518,
    CL_TYPE_HTML = 519,
    CL_TYPE_MAIL = 520
};
typedef enum __anonenum_cli_file_t_36 cli_file_t;
struct tag_arguments_tag {
   int count ;
   unsigned char **tag ;
   unsigned char **value ;
};
typedef struct tag_arguments_tag tag_arguments_t;
enum __anonenum_zzip_error_t_37 {
    ZZIP_NO_ERROR = 0,
    ZZIP_OUTOFMEM = -4116,
    ZZIP_DIR_OPEN = -4117,
    ZZIP_DIR_STAT = -4118,
    ZZIP_DIR_SEEK = -4119,
    ZZIP_DIR_READ = -4120,
    ZZIP_DIR_TOO_SHORT = -4121,
    ZZIP_DIR_EDH_MISSING = -4122,
    ZZIP_DIRSIZE = -4123,
    ZZIP_ENOENT = -4124,
    ZZIP_UNSUPP_COMPR = -4125,
    ZZIP_CORRUPTED = -4127,
    ZZIP_UNDEF = -4128
};
typedef enum __anonenum_zzip_error_t_37 zzip_error_t;
typedef char const   * const  zzip_strings_t;
typedef char const   zzip_char_t;
typedef off_t zzip_off_t;
typedef size_t zzip_size_t;
typedef ssize_t zzip_ssize_t;
struct zzip_dir;
typedef struct zzip_dir ZZIP_DIR;
struct zzip_file;
typedef struct zzip_file ZZIP_FILE;
struct zzip_dirent;
typedef struct zzip_dirent ZZIP_DIRENT;
struct zzip_dirent {
   int d_compr ;
   int d_csize ;
   int st_size ;
   unsigned short d_flags ;
   char *d_name ;
   int d_crc32 ;
};
struct zzip_plugin_io;
typedef struct zzip_plugin_io  const  *zzip_plugin_io_t;
struct zzip_plugin_io {
   int (*open)(zzip_char_t *name , int flags  , ...) ;
   int (*close)(int fd ) ;
   int (*read)(int fd , void *buf , unsigned int len ) ;
   zzip_off_t (*seeks)(int fd , zzip_off_t offset , int whence ) ;
   zzip_off_t (*filesize)(int fd ) ;
   long use_mmap ;
};
struct zzip_dir_hdr {
   uint32_t d_usize ;
   uint32_t d_csize ;
   uint32_t d_crc32 ;
   uint32_t d_off ;
   uint16_t d_reclen ;
   uint16_t d_namlen ;
   uint8_t d_compr ;
   uint16_t d_flags ;
   char d_name[1] ;
};
struct __anonstruct_cache_38 {
   struct zzip_file *fp ;
   char *buf32k ;
};
struct zzip_dir {
   int fd ;
   int errcode ;
   long refcount ;
   struct __anonstruct_cache_38 cache ;
   struct zzip_dir_hdr *hdr0 ;
   struct zzip_dir_hdr *hdr ;
   struct zzip_file *currentfp ;
   struct zzip_dirent dirent ;
   void *realdir ;
   char *realname ;
   zzip_strings_t *fileext ;
   zzip_plugin_io_t io ;
};
typedef void BZFILE;
struct cli_magic_s {
   int offset ;
   char const   *magic ;
   size_t length ;
   char const   *descr ;
   cli_file_t type ;
};
struct cli_smagic_s {
   char const   *sig ;
   char const   *descr ;
   cli_file_t type ;
};
typedef long DWORD;
typedef short BOOL;
struct MarkHeader {
   UBYTE Mark[7] ;
};
struct NewMainArchiveHeader {
   UWORD HeadCRC ;
   UBYTE HeadType ;
   UWORD Flags ;
   UWORD HeadSize ;
   UWORD Reserved ;
   UDWORD Reserved1 ;
};
struct NewFileHeader {
   UWORD HeadCRC ;
   UBYTE HeadType ;
   UWORD Flags ;
   UWORD HeadSize ;
   UDWORD PackSize ;
   UDWORD UnpSize ;
   UBYTE HostOS ;
   UDWORD FileCRC ;
   UDWORD FileTime ;
   UBYTE UnpVer ;
   UBYTE Method ;
   UWORD NameSize ;
   UDWORD FileAttr ;
};
struct BlockHeader {
   UWORD HeadCRC ;
   UBYTE HeadType ;
   UWORD Flags ;
   UWORD HeadSize ;
   UDWORD DataSize ;
};
struct Decode {
   unsigned int MaxNum ;
   unsigned int DecodeLen[16] ;
   unsigned int DecodePos[16] ;
   unsigned int DecodeNum[2] ;
};
struct AudioVariables {
   int K1 ;
   int K2 ;
   int K3 ;
   int K4 ;
   int K5 ;
   int D1 ;
   int D2 ;
   int D3 ;
   int D4 ;
   int LastDelta ;
   unsigned int Dif[11] ;
   unsigned int ByteCount ;
   int LastChar ;
};
struct LitDecode {
   unsigned int MaxNum ;
   unsigned int DecodeLen[16] ;
   unsigned int DecodePos[16] ;
   unsigned int DecodeNum[298] ;
};
struct DistDecode {
   unsigned int MaxNum ;
   unsigned int DecodeLen[16] ;
   unsigned int DecodePos[16] ;
   unsigned int DecodeNum[48] ;
};
struct RepDecode {
   unsigned int MaxNum ;
   unsigned int DecodeLen[16] ;
   unsigned int DecodePos[16] ;
   unsigned int DecodeNum[28] ;
};
struct MultDecode {
   unsigned int MaxNum ;
   unsigned int DecodeLen[16] ;
   unsigned int DecodePos[16] ;
   unsigned int DecodeNum[257] ;
};
struct BitDecode {
   unsigned int MaxNum ;
   unsigned int DecodeLen[16] ;
   unsigned int DecodePos[16] ;
   unsigned int DecodeNum[19] ;
};
typedef unsigned char Byte;
typedef unsigned int uInt;
typedef unsigned long uLong;
typedef Byte Bytef;
typedef void *voidpf;
struct internal_state;
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
typedef struct z_stream_s z_stream;
struct internal_state {
   int dummy ;
};
struct zzip_file {
   struct zzip_dir *dir ;
   int fd ;
   int method ;
   zzip_size_t restlen ;
   zzip_size_t crestlen ;
   zzip_size_t usize ;
   zzip_size_t csize ;
   zzip_off_t dataoffset ;
   char *buf32k ;
   zzip_off_t offset ;
   z_stream d_stream ;
   zzip_plugin_io_t io ;
};
struct errlistentry {
   int code ;
   char const   *mesg ;
};
struct errnolistentry {
   int code ;
   int e_no ;
};
typedef z_stream *z_streamp;
struct zzip_version {
   char version[1] ;
   char ostype[1] ;
} __attribute__((__packed__)) ;
struct zzip_dostime {
   char time[2] ;
   char date[2] ;
} __attribute__((__packed__)) ;
struct zzip_file_header {
   char z_magic[4] ;
   struct zzip_version z_extract ;
   char z_flags[2] ;
   char z_compr[2] ;
   struct zzip_dostime z_dostime ;
   char z_crc32[4] ;
   char z_csize[4] ;
   char z_usize[4] ;
   char z_namlen[2] ;
   char z_extras[2] ;
} __attribute__((__packed__)) ;
typedef struct zzip_dirent ZZIP_STAT;
struct zzip_root_dirent {
   char z_magic[4] ;
   struct zzip_version z_encoder ;
   struct zzip_version z_extract ;
   char z_flags[2] ;
   char z_compr[2] ;
   struct zzip_dostime z_dostime ;
   char z_crc32[4] ;
   char z_csize[4] ;
   char z_usize[4] ;
   char z_namlen[2] ;
   char z_extras[2] ;
   char z_comment[2] ;
   char z_diskstart[2] ;
   char z_filetype[2] ;
   char z_filemode[4] ;
   char z_off[4] ;
} __attribute__((__packed__)) ;
struct zzip_disk_trailer {
   char z_magic[4] ;
   char z_disk[2] ;
   char z_finaldisk[2] ;
   char z_entries[2] ;
   char z_finalentries[2] ;
   char z_rootsize[4] ;
   char z_rootseek[4] ;
   char z_comment[2] ;
} __attribute__((__packed__)) ;
struct blob {
   char *name ;
   unsigned char *data ;
   unsigned long len ;
   unsigned long size ;
   int isClosed ;
};
typedef struct blob blob;
struct fileblob {
   FILE *fp ;
   blob b ;
   int isNotEmpty ;
};
typedef struct fileblob fileblob;
typedef struct _IO_FILE _IO_FILE;
struct __sched_param {
   int __sched_priority ;
};
struct __pthread_attr_s {
   int __detachstate ;
   int __schedpolicy ;
   struct __sched_param __schedparam ;
   int __inheritsched ;
   int __scope ;
   size_t __guardsize ;
   int __stackaddr_set ;
   void *__stackaddr ;
   size_t __stacksize ;
};
typedef struct __pthread_attr_s pthread_attr_t;
typedef unsigned long pthread_t;
struct tableEntry {
   char *key ;
   int value ;
   struct tableEntry *next ;
};
typedef struct tableEntry tableEntry;
struct table {
   tableEntry *tableHead ;
   tableEntry *tableLast ;
};
typedef struct table table_t;
enum __anonenum_mime_type_31 {
    NOMIME = 0,
    APPLICATION = 1,
    AUDIO = 2,
    IMAGE = 3,
    MESSAGE = 4,
    MULTIPART = 5,
    TEXT = 6,
    VIDEO = 7,
    MEXTENSION = 8
};
typedef enum __anonenum_mime_type_31 mime_type;
enum __anonenum_encoding_type_32 {
    NOENCODING = 0,
    QUOTEDPRINTABLE = 1,
    BASE64 = 2,
    EIGHTBIT = 3,
    BINARY = 4,
    UUENCODE = 5,
    YENCODE = 6,
    EEXTENSION = 7,
    BINHEX = 8
};
typedef enum __anonenum_encoding_type_32 encoding_type;
typedef char line_t;
struct text {
   line_t *t_line ;
   struct text *t_next ;
};
typedef struct text text;
struct message {
   mime_type mimeType ;
   encoding_type *encodingTypes ;
   int numberOfEncTypes ;
   char *mimeSubtype ;
   int numberOfArguments ;
   char **mimeArguments ;
   char *mimeDispositionType ;
   text *body_first ;
   text *body_last ;
   char base64_1 ;
   char base64_2 ;
   char base64_3 ;
   int base64chars ;
   text const   *bounce ;
   text const   *binhex ;
   text const   *uuencode ;
   text const   *yenc ;
   text const   *encoding ;
   text const   *dedupedThisFar ;
};
typedef struct message message;
enum __anonenum_bool_35 {
    FALSE = 0,
    TRUE = 1
};
typedef enum __anonenum_bool_35 bool;
typedef void CURL;
struct curl_slist;
enum __anonenum_CURLcode_39 {
    CURLE_OK = 0,
    CURLE_UNSUPPORTED_PROTOCOL = 1,
    CURLE_FAILED_INIT = 2,
    CURLE_URL_MALFORMAT = 3,
    CURLE_URL_MALFORMAT_USER = 4,
    CURLE_COULDNT_RESOLVE_PROXY = 5,
    CURLE_COULDNT_RESOLVE_HOST = 6,
    CURLE_COULDNT_CONNECT = 7,
    CURLE_FTP_WEIRD_SERVER_REPLY = 8,
    CURLE_FTP_ACCESS_DENIED = 9,
    CURLE_FTP_USER_PASSWORD_INCORRECT = 10,
    CURLE_FTP_WEIRD_PASS_REPLY = 11,
    CURLE_FTP_WEIRD_USER_REPLY = 12,
    CURLE_FTP_WEIRD_PASV_REPLY = 13,
    CURLE_FTP_WEIRD_227_FORMAT = 14,
    CURLE_FTP_CANT_GET_HOST = 15,
    CURLE_FTP_CANT_RECONNECT = 16,
    CURLE_FTP_COULDNT_SET_BINARY = 17,
    CURLE_PARTIAL_FILE = 18,
    CURLE_FTP_COULDNT_RETR_FILE = 19,
    CURLE_FTP_WRITE_ERROR = 20,
    CURLE_FTP_QUOTE_ERROR = 21,
    CURLE_HTTP_RETURNED_ERROR = 22,
    CURLE_WRITE_ERROR = 23,
    CURLE_MALFORMAT_USER = 24,
    CURLE_FTP_COULDNT_STOR_FILE = 25,
    CURLE_READ_ERROR = 26,
    CURLE_OUT_OF_MEMORY = 27,
    CURLE_OPERATION_TIMEOUTED = 28,
    CURLE_FTP_COULDNT_SET_ASCII = 29,
    CURLE_FTP_PORT_FAILED = 30,
    CURLE_FTP_COULDNT_USE_REST = 31,
    CURLE_FTP_COULDNT_GET_SIZE = 32,
    CURLE_HTTP_RANGE_ERROR = 33,
    CURLE_HTTP_POST_ERROR = 34,
    CURLE_SSL_CONNECT_ERROR = 35,
    CURLE_BAD_DOWNLOAD_RESUME = 36,
    CURLE_FILE_COULDNT_READ_FILE = 37,
    CURLE_LDAP_CANNOT_BIND = 38,
    CURLE_LDAP_SEARCH_FAILED = 39,
    CURLE_LIBRARY_NOT_FOUND = 40,
    CURLE_FUNCTION_NOT_FOUND = 41,
    CURLE_ABORTED_BY_CALLBACK = 42,
    CURLE_BAD_FUNCTION_ARGUMENT = 43,
    CURLE_BAD_CALLING_ORDER = 44,
    CURLE_INTERFACE_FAILED = 45,
    CURLE_BAD_PASSWORD_ENTERED = 46,
    CURLE_TOO_MANY_REDIRECTS = 47,
    CURLE_UNKNOWN_TELNET_OPTION = 48,
    CURLE_TELNET_OPTION_SYNTAX = 49,
    CURLE_OBSOLETE = 50,
    CURLE_SSL_PEER_CERTIFICATE = 51,
    CURLE_GOT_NOTHING = 52,
    CURLE_SSL_ENGINE_NOTFOUND = 53,
    CURLE_SSL_ENGINE_SETFAILED = 54,
    CURLE_SEND_ERROR = 55,
    CURLE_RECV_ERROR = 56,
    CURLE_SHARE_IN_USE = 57,
    CURLE_SSL_CERTPROBLEM = 58,
    CURLE_SSL_CIPHER = 59,
    CURLE_SSL_CACERT = 60,
    CURLE_BAD_CONTENT_ENCODING = 61,
    CURLE_LDAP_INVALID_URL = 62,
    CURLE_FILESIZE_EXCEEDED = 63,
    CURLE_FTP_SSL_FAILED = 64,
    CURLE_SEND_FAIL_REWIND = 65,
    CURLE_SSL_ENGINE_INITFAILED = 66,
    CURLE_LOGIN_DENIED = 67,
    CURL_LAST = 68
};
typedef enum __anonenum_CURLcode_39 CURLcode;
enum __anonenum_CURLoption_43 {
    CURLOPT_FILE = 10001,
    CURLOPT_URL = 10002,
    CURLOPT_PORT = 3,
    CURLOPT_PROXY = 10004,
    CURLOPT_USERPWD = 10005,
    CURLOPT_PROXYUSERPWD = 10006,
    CURLOPT_RANGE = 10007,
    CURLOPT_INFILE = 10009,
    CURLOPT_ERRORBUFFER = 10010,
    CURLOPT_WRITEFUNCTION = 20011,
    CURLOPT_READFUNCTION = 20012,
    CURLOPT_TIMEOUT = 13,
    CURLOPT_INFILESIZE = 14,
    CURLOPT_POSTFIELDS = 10015,
    CURLOPT_REFERER = 10016,
    CURLOPT_FTPPORT = 10017,
    CURLOPT_USERAGENT = 10018,
    CURLOPT_LOW_SPEED_LIMIT = 19,
    CURLOPT_LOW_SPEED_TIME = 20,
    CURLOPT_RESUME_FROM = 21,
    CURLOPT_COOKIE = 10022,
    CURLOPT_HTTPHEADER = 10023,
    CURLOPT_HTTPPOST = 10024,
    CURLOPT_SSLCERT = 10025,
    CURLOPT_SSLCERTPASSWD = 10026,
    CURLOPT_SSLKEYPASSWD = 10026,
    CURLOPT_CRLF = 27,
    CURLOPT_QUOTE = 10028,
    CURLOPT_WRITEHEADER = 10029,
    CURLOPT_COOKIEFILE = 10031,
    CURLOPT_SSLVERSION = 32,
    CURLOPT_TIMECONDITION = 33,
    CURLOPT_TIMEVALUE = 34,
    CURLOPT_CUSTOMREQUEST = 10036,
    CURLOPT_STDERR = 10037,
    CURLOPT_POSTQUOTE = 10039,
    CURLOPT_WRITEINFO = 10040,
    CURLOPT_VERBOSE = 41,
    CURLOPT_HEADER = 42,
    CURLOPT_NOPROGRESS = 43,
    CURLOPT_NOBODY = 44,
    CURLOPT_FAILONERROR = 45,
    CURLOPT_UPLOAD = 46,
    CURLOPT_POST = 47,
    CURLOPT_FTPLISTONLY = 48,
    CURLOPT_FTPAPPEND = 50,
    CURLOPT_NETRC = 51,
    CURLOPT_FOLLOWLOCATION = 52,
    CURLOPT_TRANSFERTEXT = 53,
    CURLOPT_PUT = 54,
    CURLOPT_PROGRESSFUNCTION = 20056,
    CURLOPT_PROGRESSDATA = 10057,
    CURLOPT_AUTOREFERER = 58,
    CURLOPT_PROXYPORT = 59,
    CURLOPT_POSTFIELDSIZE = 60,
    CURLOPT_HTTPPROXYTUNNEL = 61,
    CURLOPT_INTERFACE = 10062,
    CURLOPT_KRB4LEVEL = 10063,
    CURLOPT_SSL_VERIFYPEER = 64,
    CURLOPT_CAINFO = 10065,
    CURLOPT_MAXREDIRS = 68,
    CURLOPT_FILETIME = 69,
    CURLOPT_TELNETOPTIONS = 10070,
    CURLOPT_MAXCONNECTS = 71,
    CURLOPT_CLOSEPOLICY = 72,
    CURLOPT_FRESH_CONNECT = 74,
    CURLOPT_FORBID_REUSE = 75,
    CURLOPT_RANDOM_FILE = 10076,
    CURLOPT_EGDSOCKET = 10077,
    CURLOPT_CONNECTTIMEOUT = 78,
    CURLOPT_HEADERFUNCTION = 20079,
    CURLOPT_HTTPGET = 80,
    CURLOPT_SSL_VERIFYHOST = 81,
    CURLOPT_COOKIEJAR = 10082,
    CURLOPT_SSL_CIPHER_LIST = 10083,
    CURLOPT_HTTP_VERSION = 84,
    CURLOPT_FTP_USE_EPSV = 85,
    CURLOPT_SSLCERTTYPE = 10086,
    CURLOPT_SSLKEY = 10087,
    CURLOPT_SSLKEYTYPE = 10088,
    CURLOPT_SSLENGINE = 10089,
    CURLOPT_SSLENGINE_DEFAULT = 90,
    CURLOPT_DNS_USE_GLOBAL_CACHE = 91,
    CURLOPT_DNS_CACHE_TIMEOUT = 92,
    CURLOPT_PREQUOTE = 10093,
    CURLOPT_DEBUGFUNCTION = 20094,
    CURLOPT_DEBUGDATA = 10095,
    CURLOPT_COOKIESESSION = 96,
    CURLOPT_CAPATH = 10097,
    CURLOPT_BUFFERSIZE = 98,
    CURLOPT_NOSIGNAL = 99,
    CURLOPT_SHARE = 10100,
    CURLOPT_PROXYTYPE = 101,
    CURLOPT_ENCODING = 10102,
    CURLOPT_PRIVATE = 10103,
    CURLOPT_HTTP200ALIASES = 10104,
    CURLOPT_UNRESTRICTED_AUTH = 105,
    CURLOPT_FTP_USE_EPRT = 106,
    CURLOPT_HTTPAUTH = 107,
    CURLOPT_SSL_CTX_FUNCTION = 20108,
    CURLOPT_SSL_CTX_DATA = 10109,
    CURLOPT_FTP_CREATE_MISSING_DIRS = 110,
    CURLOPT_PROXYAUTH = 111,
    CURLOPT_FTP_RESPONSE_TIMEOUT = 112,
    CURLOPT_IPRESOLVE = 113,
    CURLOPT_MAXFILESIZE = 114,
    CURLOPT_INFILESIZE_LARGE = 30115,
    CURLOPT_RESUME_FROM_LARGE = 30116,
    CURLOPT_MAXFILESIZE_LARGE = 30117,
    CURLOPT_NETRC_FILE = 10118,
    CURLOPT_FTP_SSL = 119,
    CURLOPT_POSTFIELDSIZE_LARGE = 30120,
    CURLOPT_TCP_NODELAY = 121,
    CURLOPT_SOURCE_USERPWD = 10123,
    CURLOPT_SOURCE_PREQUOTE = 10127,
    CURLOPT_SOURCE_POSTQUOTE = 10128,
    CURLOPT_FTPSSLAUTH = 129,
    CURLOPT_IOCTLFUNCTION = 20130,
    CURLOPT_IOCTLDATA = 10131,
    CURLOPT_SOURCE_URL = 10132,
    CURLOPT_SOURCE_QUOTE = 10133,
    CURLOPT_FTP_ACCOUNT = 10134,
    CURLOPT_LASTENTRY = 10135
};
typedef enum __anonenum_CURLoption_43 CURLoption;
struct curl_slist {
   char *data ;
   struct curl_slist *next ;
};
struct arg {
   char const   *url ;
   char const   *dir ;
   char *filename ;
};
struct tableinit {
   char const   *key ;
   int value ;
};
struct encoding_map {
   char const   *string ;
   encoding_type type ;
};
struct mime_map {
   char const   *string ;
   mime_type type ;
};
enum __anonenum_field_35 {
    LANGUAGE = 0,
    CHARSET = 1,
    CONTENTS = 2
};
struct pstr_list {
   char *d1 ;
   struct pstr_list *next ;
};
typedef struct pstr_list ELEMENT1;
typedef ELEMENT1 *LINK1;
typedef short int16_t;
struct ole2_header_tag {
   unsigned char magic[8]  __attribute__((__packed__)) ;
   unsigned char clsid[16]  __attribute__((__packed__)) ;
   uint16_t minor_version  __attribute__((__packed__)) ;
   uint16_t dll_version  __attribute__((__packed__)) ;
   int16_t byte_order  __attribute__((__packed__)) ;
   uint16_t log2_big_block_size  __attribute__((__packed__)) ;
   uint32_t log2_small_block_size  __attribute__((__packed__)) ;
   int32_t reserved[2]  __attribute__((__packed__)) ;
   int32_t bat_count  __attribute__((__packed__)) ;
   int32_t prop_start  __attribute__((__packed__)) ;
   uint32_t signature  __attribute__((__packed__)) ;
   uint32_t sbat_cutoff  __attribute__((__packed__)) ;
   int32_t sbat_start  __attribute__((__packed__)) ;
   int32_t sbat_block_count  __attribute__((__packed__)) ;
   int32_t xbat_start  __attribute__((__packed__)) ;
   int32_t xbat_count  __attribute__((__packed__)) ;
   int32_t bat_array[109]  __attribute__((__packed__)) ;
   int32_t sbat_root_start  __attribute__((__packed__)) ;
   unsigned char *m_area ;
   off_t m_length ;
};
typedef struct ole2_header_tag ole2_header_t;
struct property_tag {
   unsigned char name[64]  __attribute__((__packed__)) ;
   int16_t name_size  __attribute__((__packed__)) ;
   unsigned char type  __attribute__((__packed__)) ;
   unsigned char color  __attribute__((__packed__)) ;
   int32_t prev  __attribute__((__packed__)) ;
   int32_t next  __attribute__((__packed__)) ;
   int32_t child  __attribute__((__packed__)) ;
   unsigned char clsid[16]  __attribute__((__packed__)) ;
   uint32_t user_flags  __attribute__((__packed__)) ;
   uint32_t create_lowdate  __attribute__((__packed__)) ;
   uint32_t create_highdate  __attribute__((__packed__)) ;
   uint32_t mod_lowdate  __attribute__((__packed__)) ;
   uint32_t mod_highdate  __attribute__((__packed__)) ;
   int32_t start_block  __attribute__((__packed__)) ;
   int32_t size  __attribute__((__packed__)) ;
   unsigned char reserved[4]  __attribute__((__packed__)) ;
};
typedef struct property_tag property_t;
struct vba_version_tag {
   unsigned char signature[4] ;
   char const   *name ;
   int vba_version ;
   int is_mac ;
};
typedef struct vba_version_tag vba_version_t;
struct byte_array_tag {
   unsigned int length ;
   unsigned char *data ;
};
typedef struct byte_array_tag byte_array_t;
struct atom_header_tag {
   off_t foffset ;
   uint16_t ver_inst ;
   uint8_t version ;
   uint16_t instance ;
   uint16_t type ;
   uint32_t length ;
};
typedef struct atom_header_tag atom_header_t;
struct mso_fib_tag {
   uint16_t magic ;
   uint16_t version ;
   uint16_t product ;
   uint16_t lid ;
   uint16_t next ;
   uint16_t status ;
   uint32_t macro_offset ;
   uint32_t macro_len ;
};
typedef struct mso_fib_tag mso_fib_t;
struct macro_entry_tag {
   unsigned char version ;
   unsigned char key ;
   uint16_t intname_i ;
   uint16_t extname_i ;
   uint16_t xname_i ;
   uint32_t unknown ;
   uint32_t len ;
   uint32_t state ;
   uint32_t offset ;
};
typedef struct macro_entry_tag macro_entry_t;
struct macro_info_tag {
   uint16_t count ;
   struct macro_entry_tag *macro_entry ;
};
typedef struct macro_info_tag macro_info_t;
struct macro_extname_tag {
   uint8_t length ;
   unsigned char *extname ;
   uint16_t numref ;
};
typedef struct macro_extname_tag macro_extname_t;
struct macro_extnames_tag {
   uint16_t count ;
   struct macro_extname_tag *macro_extname ;
};
typedef struct macro_extnames_tag macro_extnames_t;
struct macro_intname_tag;
struct macro_intnames_tag {
   uint16_t count ;
   struct macro_intname_tag *macro_intname ;
};
typedef struct macro_intnames_tag macro_intnames_t;
struct macro_intname_tag {
   uint16_t id ;
   uint8_t length ;
   unsigned char *intname ;
};
typedef struct macro_intname_tag macro_intname_t;
struct menu_entry_tag {
   uint16_t context ;
   uint16_t menu ;
   uint16_t extname_i ;
   uint16_t unknown ;
   uint16_t intname_i ;
   uint16_t pos ;
};
typedef struct menu_entry_tag menu_entry_t;
struct menu_info_tag {
   uint16_t count ;
   struct menu_entry_tag *menu_entry ;
};
typedef struct menu_info_tag menu_info_t;
struct pe_image_file_hdr {
   uint32_t Magic ;
   uint16_t Machine ;
   uint16_t NumberOfSections ;
   uint32_t TimeDateStamp ;
   uint32_t PointerToSymbolTable ;
   uint32_t NumberOfSymbols ;
   uint16_t SizeOfOptionalHeader ;
   uint16_t Characteristics ;
};
struct pe_image_data_dir {
   uint32_t VirtualAddress ;
   uint32_t Size ;
};
struct pe_image_optional_hdr {
   uint16_t Magic ;
   uint8_t MajorLinkerVersion ;
   uint8_t MinorLinkerVersion ;
   uint32_t SizeOfCode ;
   uint32_t SizeOfInitializedData ;
   uint32_t SizeOfUninitializedData ;
   uint32_t AddressOfEntryPoint ;
   uint32_t BaseOfCode ;
   uint32_t BaseOfData ;
   uint32_t ImageBase ;
   uint32_t SectionAlignment ;
   uint32_t FileAlignment ;
   uint16_t MajorOperatingSystemVersion ;
   uint16_t MinorOperatingSystemVersion ;
   uint16_t MajorImageVersion ;
   uint16_t MinorImageVersion ;
   uint16_t MajorSubsystemVersion ;
   uint16_t MinorSubsystemVersion ;
   uint32_t Win32VersionValue ;
   uint32_t SizeOfImage ;
   uint32_t SizeOfHeaders ;
   uint32_t CheckSum ;
   uint16_t Subsystem ;
   uint16_t DllCharacteristics ;
   uint32_t SizeOfStackReserve ;
   uint32_t SizeOfStackCommit ;
   uint32_t SizeOfHeapReserve ;
   uint32_t SizeOfHeapCommit ;
   uint32_t LoaderFlags ;
   uint32_t NumberOfRvaAndSizes ;
   struct pe_image_data_dir DataDirectory[16] ;
};
struct pe_image_section_hdr {
   uint8_t Name[8] ;
   uint32_t VirtualSize ;
   uint32_t VirtualAddress ;
   uint32_t SizeOfRawData ;
   uint32_t PointerToRawData ;
   uint32_t PointerToRelocations ;
   uint32_t PointerToLinenumbers ;
   uint16_t NumberOfRelocations ;
   uint16_t NumberOfLinenumbers ;
   uint32_t Characteristics ;
};
struct mszipd_stream {
   struct mspack_system *sys ;
   struct mspack_file *input ;
   struct mspack_file *output ;
   unsigned int window_posn ;
   int (*flush_window)(struct mszipd_stream * , unsigned int  ) ;
   int error ;
   int repair_mode ;
   int bytes_output ;
   unsigned char *inbuf ;
   unsigned char *i_ptr ;
   unsigned char *i_end ;
   unsigned char *o_ptr ;
   unsigned char *o_end ;
   unsigned int bit_buffer ;
   unsigned int bits_left ;
   unsigned int inbuf_size ;
   unsigned char LITERAL_len[288] ;
   unsigned char DISTANCE_len[32] ;
   unsigned short LITERAL_table[1152] ;
   unsigned short DISTANCE_table[128] ;
   unsigned char window[32768] ;
};
struct qtmd_modelsym {
   unsigned short sym ;
   unsigned short cumfreq ;
};
struct qtmd_model {
   int shiftsleft ;
   int entries ;
   struct qtmd_modelsym *syms ;
};
struct qtmd_stream {
   struct mspack_system *sys ;
   struct mspack_file *input ;
   struct mspack_file *output ;
   unsigned char *window ;
   unsigned int window_size ;
   unsigned int window_posn ;
   unsigned int frame_start ;
   unsigned short H ;
   unsigned short L ;
   unsigned short C ;
   unsigned char header_read ;
   int error ;
   unsigned char *inbuf ;
   unsigned char *i_ptr ;
   unsigned char *i_end ;
   unsigned char *o_ptr ;
   unsigned char *o_end ;
   unsigned int bit_buffer ;
   unsigned int inbuf_size ;
   unsigned char bits_left ;
   struct qtmd_model model0 ;
   struct qtmd_model model1 ;
   struct qtmd_model model2 ;
   struct qtmd_model model3 ;
   struct qtmd_model model4 ;
   struct qtmd_model model5 ;
   struct qtmd_model model6 ;
   struct qtmd_model model6len ;
   struct qtmd_model model7 ;
   struct qtmd_modelsym m0sym[65] ;
   struct qtmd_modelsym m1sym[65] ;
   struct qtmd_modelsym m2sym[65] ;
   struct qtmd_modelsym m3sym[65] ;
   struct qtmd_modelsym m4sym[25] ;
   struct qtmd_modelsym m5sym[37] ;
   struct qtmd_modelsym m6sym[43] ;
   struct qtmd_modelsym m6lsym[28] ;
   struct qtmd_modelsym m7sym[8] ;
};
struct lzxd_stream {
   struct mspack_system *sys ;
   struct mspack_file *input ;
   struct mspack_file *output ;
   off_t offset ;
   off_t length ;
   unsigned char *window ;
   unsigned int window_size ;
   unsigned int window_posn ;
   unsigned int frame_posn ;
   unsigned int frame ;
   unsigned int reset_interval ;
   unsigned int R0 ;
   unsigned int R1 ;
   unsigned int R2 ;
   unsigned int block_length ;
   unsigned int block_remaining ;
   int intel_filesize ;
   int intel_curpos ;
   unsigned char intel_started ;
   unsigned char block_type ;
   unsigned char header_read ;
   unsigned char posn_slots ;
   unsigned char input_end ;
   int error ;
   unsigned char *inbuf ;
   unsigned char *i_ptr ;
   unsigned char *i_end ;
   unsigned char *o_ptr ;
   unsigned char *o_end ;
   unsigned int bit_buffer ;
   unsigned int bits_left ;
   unsigned int inbuf_size ;
   unsigned char PRETREE_len[84] ;
   unsigned char MAINTREE_len[720] ;
   unsigned char LENGTH_len[314] ;
   unsigned char ALIGNED_len[72] ;
   unsigned short PRETREE_table[104] ;
   unsigned short MAINTREE_table[5408] ;
   unsigned short LENGTH_table[4596] ;
   unsigned short ALIGNED_table[144] ;
   unsigned char e8_buf[32768] ;
};
struct mscabd_folder_p;
struct mscabd_folder_data;
struct mscabd_cabinet_p;
struct mscabd_decompress_state {
   struct mscabd_folder_p *folder ;
   struct mscabd_folder_data *data ;
   unsigned int offset ;
   unsigned int block ;
   struct mspack_system sys ;
   int comp_type ;
   int (*decompress)(void * , off_t  ) ;
   void *state ;
   struct mscabd_cabinet_p *incab ;
   struct mspack_file *infh ;
   struct mspack_file *outfh ;
   unsigned char *i_ptr ;
   unsigned char *i_end ;
   unsigned char input[38912] ;
};
struct mscab_decompressor_p {
   struct mscab_decompressor base ;
   struct mscabd_decompress_state *d ;
   struct mspack_system *system ;
   int param[3] ;
   int error ;
};
struct mscabd_cabinet_p {
   struct mscabd_cabinet base ;
   off_t blocks_off ;
   int block_resv ;
};
struct mscabd_folder_data {
   struct mscabd_folder_data *next ;
   struct mscabd_cabinet_p *cab ;
   off_t offset ;
};
struct mscabd_folder_p {
   struct mscabd_folder base ;
   struct mscabd_folder_data data ;
   struct mscabd_file *merge_prev ;
   struct mscabd_file *merge_next ;
};
struct noned_state;
struct noned_state {
   struct mspack_system *sys ;
   struct mspack_file *i ;
   struct mspack_file *o ;
   unsigned char *buf ;
   int bufsize ;
};
struct mspack_file_p {
   FILE *fh ;
   char const   *name ;
   int desc ;
};
enum __anonenum_html_state_22 {
    HTML_BAD_STATE = 0,
    HTML_NORM = 1,
    HTML_COMMENT = 2,
    HTML_CHAR_REF = 3,
    HTML_SKIP_WS = 4,
    HTML_TRIM_WS = 5,
    HTML_TAG = 6,
    HTML_TAG_ARG = 7,
    HTML_TAG_ARG_VAL = 8,
    HTML_TAG_ARG_EQUAL = 9,
    HTML_PROCESS_TAG = 10,
    HTML_CHAR_REF_DECODE = 11,
    HTML_SKIP_LENGTH = 12,
    HTML_JSDECODE = 13,
    HTML_JSDECODE_LENGTH = 14,
    HTML_JSDECODE_DECRYPT = 15,
    HTML_SPECIAL_CHAR = 16,
    HTML_RFC2397_TYPE = 17,
    HTML_RFC2397_INIT = 18,
    HTML_RFC2397_DATA = 19,
    HTML_RFC2397_FINISH = 20,
    HTML_RFC2397_ESC = 21,
    HTML_ESCAPE_CHAR = 22
};
typedef enum __anonenum_html_state_22 html_state;
enum __anonenum_quoted_state_23 {
    SINGLE_QUOTED = 0,
    DOUBLE_QUOTED = 1,
    NOT_QUOTED = 2
};
typedef enum __anonenum_quoted_state_23 quoted_state;
struct m_area_tag {
   unsigned char *buffer ;
   off_t length ;
   off_t offset ;
};
typedef struct m_area_tag m_area_t;
struct file_buff_tag {
   int fd ;
   unsigned char buffer[8192] ;
   int length ;
};
typedef struct file_buff_tag file_buff_t;
typedef unsigned long long uint64_t;
struct itsf_header_tag {
   unsigned char signature[4]  __attribute__((__packed__)) ;
   int32_t version  __attribute__((__packed__)) ;
   int32_t header_len  __attribute__((__packed__)) ;
   uint32_t unknown  __attribute__((__packed__)) ;
   uint32_t last_modified  __attribute__((__packed__)) ;
   uint32_t lang_id  __attribute__((__packed__)) ;
   unsigned char dir_clsid[16]  __attribute__((__packed__)) ;
   unsigned char stream_clsid[16]  __attribute__((__packed__)) ;
   uint64_t sec0_offset  __attribute__((__packed__)) ;
   uint64_t sec0_len  __attribute__((__packed__)) ;
   uint64_t dir_offset  __attribute__((__packed__)) ;
   uint64_t dir_len  __attribute__((__packed__)) ;
   uint64_t data_offset  __attribute__((__packed__)) ;
};
typedef struct itsf_header_tag itsf_header_t;
struct itsp_header_tag {
   unsigned char signature[4]  __attribute__((__packed__)) ;
   int32_t version  __attribute__((__packed__)) ;
   int32_t header_len  __attribute__((__packed__)) ;
   int32_t unknown1  __attribute__((__packed__)) ;
   uint32_t block_len  __attribute__((__packed__)) ;
   int32_t blockidx_intvl  __attribute__((__packed__)) ;
   int32_t index_depth  __attribute__((__packed__)) ;
   int32_t index_root  __attribute__((__packed__)) ;
   int32_t index_head  __attribute__((__packed__)) ;
   int32_t index_tail  __attribute__((__packed__)) ;
   int32_t unknown2  __attribute__((__packed__)) ;
   uint32_t num_blocks  __attribute__((__packed__)) ;
   uint32_t lang_id  __attribute__((__packed__)) ;
   unsigned char system_clsid[16]  __attribute__((__packed__)) ;
   unsigned char unknown4[16]  __attribute__((__packed__)) ;
};
typedef struct itsp_header_tag itsp_header_t;
struct chunk_header_tag {
   unsigned char signature[4]  __attribute__((__packed__)) ;
   uint32_t free_space  __attribute__((__packed__)) ;
   uint32_t unknown  __attribute__((__packed__)) ;
   int32_t block_prev  __attribute__((__packed__)) ;
   int32_t block_next  __attribute__((__packed__)) ;
   unsigned char *chunk_data ;
   uint16_t num_entries ;
};
typedef struct chunk_header_tag chunk_header_t;
struct file_list_tag {
   unsigned char *name ;
   uint64_t section ;
   uint64_t offset ;
   uint64_t length ;
   struct file_list_tag *next ;
};
typedef struct file_list_tag file_list_t;
struct lzx_control_tag {
   uint32_t length  __attribute__((__packed__)) ;
   unsigned char signature[4]  __attribute__((__packed__)) ;
   uint32_t version  __attribute__((__packed__)) ;
   uint32_t reset_interval  __attribute__((__packed__)) ;
   uint32_t window_size  __attribute__((__packed__)) ;
   uint32_t cache_size  __attribute__((__packed__)) ;
};
typedef struct lzx_control_tag lzx_control_t;
struct lzx_reset_table_tag {
   uint32_t num_entries  __attribute__((__packed__)) ;
   uint32_t entry_size  __attribute__((__packed__)) ;
   uint32_t table_offset  __attribute__((__packed__)) ;
   uint64_t uncom_len  __attribute__((__packed__)) ;
   uint64_t com_len  __attribute__((__packed__)) ;
   uint64_t frame_len  __attribute__((__packed__)) ;
   off_t rt_offset  __attribute__((__packed__)) ;
};
typedef struct lzx_reset_table_tag lzx_reset_table_t;
struct lzx_content_tag {
   uint64_t offset ;
   uint64_t length ;
};
typedef struct lzx_content_tag lzx_content_t;
struct IMAGE_PE_HEADER {
   uint32_t Signature ;
   uint16_t Machine ;
   uint16_t NumberOfSections ;
   uint32_t TimeDateStamp ;
   uint32_t PointerToSymbolTable ;
   uint32_t NumberOfSymbols ;
   uint16_t SizeOfOptionalHeader ;
   uint16_t Characteristics ;
   uint16_t Magic ;
   uint8_t MajorLinkerVersion ;
   uint8_t MinorLinkerVersion ;
   uint32_t SizeOfCode ;
   uint32_t SizeOfInitializedData ;
   uint32_t SizeOfUninitializedData ;
   uint32_t AddressOfEntryPoint ;
   uint32_t BaseOfCode ;
   uint32_t BaseOfData ;
   uint32_t ImageBase ;
   uint32_t SectionAlignment ;
   uint32_t FileAlignment ;
   uint16_t MajorOperatingSystemVersion ;
   uint16_t MinorOperatingSystemVersion ;
   uint16_t MajorImageVersion ;
   uint16_t MinorImageVersion ;
   uint16_t MajorSubsystemVersion ;
   uint16_t MinorSubsystemVersion ;
   uint32_t Win32VersionValue ;
   uint32_t SizeOfImage ;
   uint32_t SizeOfHeaders ;
   uint32_t CheckSum ;
   uint16_t Subsystem ;
   uint16_t DllCharacteristics ;
   uint32_t SizeOfStackReserve ;
   uint32_t SizeOfStackCommit ;
   uint32_t SizeOfHeapReserve ;
   uint32_t SizeOfHeapCommit ;
   uint32_t LoaderFlags ;
   uint32_t NumberOfRvaAndSizes ;
};
struct header {
   char name[100] ;
   char mode[8] ;
   char uid[8] ;
   char gid[8] ;
   char size[12] ;
   char mtime[12] ;
   char chksum[8] ;
   char linkflag ;
   char linkname[100] ;
   char magic[8] ;
   char uname[32] ;
   char gname[32] ;
   char devmajor[8] ;
   char devminor[8] ;
};
union record {
   char charptr[512] ;
   struct header header ;
};
#pragma merger(0,"/tmp/cil-a12wRbSX.i","-g -O2")
extern struct _IO_FILE *stdout ;
extern struct _IO_FILE *stderr ;
extern int fclose(FILE *__stream ) ;
extern int fflush(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format , va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              va_list __arg ) ;
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
//extern int __builtin_strchr() ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern int fcntl(int __fd , int __cmd  , ...) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
__inline static  __attribute__((__nothrow__)) int stat__extinline(char const   *__path ,
                                                                  struct stat *__statbuf ) ;
__inline static int stat__extinline(char const   *__path , struct stat *__statbuf ) 
{ int tmp ;

  {
  tmp = __xstat(3, __path, __statbuf);
  return (tmp);
}
}
extern void closelog(void) ;
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
int mdprintf(int desc , char const   *str  , ...) ;
int logg(char const   *str  , ...) ;
void logg_close(void) ;
short logg_verbose ;
short logg_lock ;
short logg_time ;
int logg_size ;
char const   *logg_file ;
short logg_syslog ;
int logg_facility(char const   *name ) ;
void mprintf(char const   *str  , ...) ;
short mprintf_disabled ;
short mprintf_verbose ;
short mprintf_quiet ;
short mprintf_stdout ;
void *mcalloc(size_t nmemb , size_t size ) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
struct __anonstruct_pthread_mutex_t_16 logg_mutex  =    {0, 0, (_pthread_descr )0, 0, {0L, 0}};
FILE *logg_fd  =    (FILE *)((void *)0);
short logg_verbose  =    (short)0;
short logg_lock  =    (short)0;
short logg_time  =    (short)0;
int logg_size  =    0;
char const   *logg_file  =    (char const   *)((void *)0);
short logg_syslog  =    (short)0;
short mprintf_disabled  =    (short)0;
short mprintf_verbose  =    (short)0;
short mprintf_quiet  =    (short)0;
short mprintf_stdout  =    (short)0;
int mdprintf(int desc , char const   *str  , ...) 
{ va_list args ;
  char buff[512] ;
  int bytes ;

  {
  __builtin_va_start(args, str);
  bytes = vsnprintf((char * __restrict  )(buff), 512U, (char const   * __restrict  )str,
                    args);
  __builtin_va_end(args);
  write(desc, (void const   *)(buff), (unsigned int )bytes);
  return (bytes);
}
}
void logg_close(void) 
{ 

  {
  pthread_mutex_lock(& logg_mutex);
  if (logg_fd) {
    fclose(logg_fd);
    logg_fd = (FILE *)((void *)0);
  }
  pthread_mutex_unlock(& logg_mutex);
  if (logg_syslog) {
    closelog();
  }
  return;
}
}
//extern int __builtin_strncpy() ;
int logg(char const   *str  , ...) 
{ va_list args ;
  va_list argscpy ;
  struct flock fl ;
  char *pt ;
  char *timestr ;
  char vbuff[1025] ;
  time_t currtime ;
  struct stat sb ;
  mode_t old_umask ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___8 ;

  {
  __builtin_va_start(args, str);
  __builtin_va_start(argscpy, str);
  if (logg_file) {
    pthread_mutex_lock(& logg_mutex);
    if (! logg_fd) {
      old_umask = umask(31U);
      logg_fd = fopen((char const   * __restrict  )logg_file, (char const   * __restrict  )"a");
      if ((unsigned int )logg_fd == (unsigned int )((void *)0)) {
        umask(old_umask);
        pthread_mutex_unlock(& logg_mutex);
        printf((char const   * __restrict  )"ERROR: Can\'t open %s in append mode (check permissions!).\n",
               logg_file);
        return (-1);
      } else {
        umask(old_umask);
      }
      if (logg_lock) {
        memset((void *)(& fl), 0, sizeof(fl));
        fl.l_type = (short)1;
        tmp = fileno(logg_fd);
        tmp___0 = fcntl(tmp, 6, & fl);
        if (tmp___0 == -1) {
          pthread_mutex_unlock(& logg_mutex);
          return (-1);
        }
      }
    }
    if (logg_time) {
      if ((int const   )(*str) != 42) {
        goto _L;
      } else {
        if (logg_verbose) {
          _L: /* CIL Label */ 
          time(& currtime);
          pt = ctime((time_t const   *)(& currtime));
          tmp___1 = strlen((char const   *)pt);
          timestr = (char *)mcalloc(tmp___1, sizeof(char ));
          tmp___2 = strlen((char const   *)pt);
          __builtin_strncpy(timestr, pt, tmp___2 - 1U);
          fprintf((FILE * __restrict  )logg_fd, (char const   * __restrict  )"%s -> ",
                  timestr);
          free((void *)timestr);
        }
      }
    }
    if (logg_size) {
      tmp___3 = stat__extinline(logg_file, & sb);
      if (tmp___3 != -1) {
        if (sb.st_size > (__off_t )logg_size) {
          logg_file = (char const   *)((void *)0);
          fprintf((FILE * __restrict  )logg_fd, (char const   * __restrict  )"Log size = %d, maximal = %d\n",
                  (int )sb.st_size, logg_size);
          fprintf((FILE * __restrict  )logg_fd, (char const   * __restrict  )"LOGGING DISABLED (Maximal log file size exceeded).\n");
          fclose(logg_fd);
          logg_fd = (FILE *)((void *)0);
          pthread_mutex_unlock(& logg_mutex);
          return (0);
        }
      }
    }
    if ((int const   )(*str) == 33) {
      fprintf((FILE * __restrict  )logg_fd, (char const   * __restrict  )"ERROR: ");
      vfprintf((FILE * __restrict  )logg_fd, (char const   * __restrict  )(str + 1),
               args);
    } else {
      if ((int const   )(*str) == 94) {
        fprintf((FILE * __restrict  )logg_fd, (char const   * __restrict  )"WARNING: ");
        vfprintf((FILE * __restrict  )logg_fd, (char const   * __restrict  )(str +
                                                                             1), args);
      } else {
        if ((int const   )(*str) == 42) {
          if (logg_verbose) {
            vfprintf((FILE * __restrict  )logg_fd, (char const   * __restrict  )(str +
                                                                                 1),
                     args);
          }
        } else {
          vfprintf((FILE * __restrict  )logg_fd, (char const   * __restrict  )str,
                   args);
        }
      }
    }
    fflush(logg_fd);
    pthread_mutex_unlock(& logg_mutex);
  }
  if (logg_syslog) {
    vsnprintf((char * __restrict  )(vbuff), 1024U, (char const   * __restrict  )str,
              argscpy);
    vbuff[1024] = (char)0;
    while (1) {
      tmp___8 = __builtin_constant_p((int )(vbuff));
      if (tmp___8) {
        pt = (char *)__builtin_strchr(vbuff, '%');
      } else {
        pt = (char *)__builtin_strchr(vbuff, '%');
      }
      if (! pt) {
        break;
      }
      (*pt) = (char )'_';
    }
    if ((int )vbuff[0] == 33) {
      syslog(3, (char const   *)(vbuff + 1));
    } else {
      if ((int )vbuff[0] == 94) {
        syslog(4, (char const   *)(vbuff + 1));
      } else {
        if ((int )vbuff[0] == 42) {
          if (logg_verbose) {
            syslog(7, (char const   *)(vbuff + 1));
          }
        } else {
          syslog(6, (char const   *)(vbuff));
        }
      }
    }
  }
  __builtin_va_end(args);
  __builtin_va_end(argscpy);
  return (0);
}
}
void mprintf(char const   *str  , ...) 
{ va_list args ;
  va_list argscpy ;
  FILE *fd ;
  char logbuf[512] ;

  {
  if (mprintf_disabled) {
    if ((int const   )(*str) == 64) {
      __builtin_va_start(args, str);
      str ++;
      vsnprintf((char * __restrict  )(logbuf), sizeof(logbuf), (char const   * __restrict  )str,
                args);
      __builtin_va_end(args);
      logg("ERROR: %s", logbuf);
    }
    return;
  }
  fd = stdout;
  __builtin_va_start(args, str);
  __builtin_va_start(argscpy, str);
  if ((int const   )(*str) == 33) {
    if (! mprintf_stdout) {
      fd = stderr;
    }
    fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"ERROR: ");
    str ++;
    vfprintf((FILE * __restrict  )fd, (char const   * __restrict  )str, args);
  } else {
    if ((int const   )(*str) == 64) {
      if (! mprintf_stdout) {
        fd = stderr;
      }
      fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"ERROR: ");
      str ++;
      vfprintf((FILE * __restrict  )fd, (char const   * __restrict  )str, args);
      vsnprintf((char * __restrict  )(logbuf), sizeof(logbuf), (char const   * __restrict  )str,
                argscpy);
      logg("ERROR: %s", logbuf);
    } else {
      if (! mprintf_quiet) {
        if ((int const   )(*str) == 94) {
          if (! mprintf_stdout) {
            fd = stderr;
          }
          fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"WARNING: ");
          str ++;
          vfprintf((FILE * __restrict  )fd, (char const   * __restrict  )str, args);
        } else {
          if ((int const   )(*str) == 42) {
            if (mprintf_verbose) {
              str ++;
              vfprintf((FILE * __restrict  )fd, (char const   * __restrict  )str,
                       args);
            }
          } else {
            vfprintf((FILE * __restrict  )fd, (char const   * __restrict  )str, args);
          }
        }
      }
    }
  }
  __builtin_va_end(args);
  __builtin_va_end(argscpy);
  if ((unsigned int )fd == (unsigned int )stdout) {
    fflush(stdout);
  }
  return;
}
}
static struct facstruct  const  facilitymap[22]  = 
  {      {"LOG_AUTH", 32}, 
        {"LOG_AUTHPRIV", 80}, 
        {"LOG_CRON", 72}, 
        {"LOG_DAEMON", 24}, 
        {"LOG_FTP", 88}, 
        {"LOG_KERN", 0}, 
        {"LOG_LPR", 48}, 
        {"LOG_MAIL", 16}, 
        {"LOG_NEWS", 56}, 
        {"LOG_AUTH", 32}, 
        {"LOG_SYSLOG", 40}, 
        {"LOG_USER", 8}, 
        {"LOG_UUCP", 64}, 
        {"LOG_LOCAL0", 128}, 
        {"LOG_LOCAL1", 136}, 
        {"LOG_LOCAL2", 144}, 
        {"LOG_LOCAL3", 152}, 
        {"LOG_LOCAL4", 160}, 
        {"LOG_LOCAL5", 168}, 
        {"LOG_LOCAL6", 176}, 
        {"LOG_LOCAL7", 184}, 
        {(char const   *)((void *)0), -1}};
//extern int __builtin_strcmp() ;
int logg_facility(char const   *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___53 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;

  {
  i = 0;
  while (facilitymap[i].name) {
    tmp___65 = __builtin_constant_p((int )facilitymap[i].name);
    if (tmp___65) {
      tmp___66 = __builtin_constant_p((int )name);
      if (tmp___66) {
        __s1_len = strlen(facilitymap[i].name);
        __s2_len = strlen(name);
        if (! ((unsigned int )((void const   *)(facilitymap[i].name + 1)) - (unsigned int )((void const   *)facilitymap[i].name) ==
               1U)) {
          goto _L___16;
        } else {
          if (__s1_len >= 4U) {
            _L___16: /* CIL Label */ 
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                   1U)) {
              tmp___67 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___67 = 1;
              } else {
                tmp___67 = 0;
              }
            }
          } else {
            tmp___67 = 0;
          }
        }
        if (tmp___67) {
          tmp___34 = __builtin_strcmp(facilitymap[i].name, name);
        } else {
          goto _L___18;
        }
      } else {
        goto _L___18;
      }
    } else {
      _L___18: /* CIL Label */ 
      tmp___64 = __builtin_constant_p((int )facilitymap[i].name);
      if (tmp___64) {
        if ((unsigned int )((void const   *)(facilitymap[i].name + 1)) - (unsigned int )((void const   *)facilitymap[i].name) ==
            1U) {
          __s1_len = strlen(facilitymap[i].name);
          if (__s1_len < 4U) {
            tmp___53 = __builtin_constant_p((int )name);
            if (tmp___53) {
              if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                  1U) {
                tmp___34 = __builtin_strcmp(facilitymap[i].name, name);
              } else {
                goto _L___11;
              }
            } else {
              _L___11: /* CIL Label */ 
              __s2___6 = (unsigned char const   *)name;
              __result___18 = (int )((int const   )(*((unsigned char const   *)facilitymap[i].name +
                                                      0)) - (int const   )(*(__s2___6 +
                                                                             0)));
              if (__s1_len > 0U) {
                if (__result___18 == 0) {
                  __result___18 = (int )((int const   )(*((unsigned char const   *)facilitymap[i].name +
                                                          1)) - (int const   )(*(__s2___6 +
                                                                                 1)));
                  if (__s1_len > 1U) {
                    if (__result___18 == 0) {
                      __result___18 = (int )((int const   )(*((unsigned char const   *)facilitymap[i].name +
                                                              2)) - (int const   )(*(__s2___6 +
                                                                                     2)));
                      if (__s1_len > 2U) {
                        if (__result___18 == 0) {
                          __result___18 = (int )((int const   )(*((unsigned char const   *)facilitymap[i].name +
                                                                  3)) - (int const   )(*(__s2___6 +
                                                                                         3)));
                        }
                      }
                    }
                  }
                }
              }
              tmp___34 = __result___18;
            }
          } else {
            goto _L___15;
          }
        } else {
          goto _L___15;
        }
      } else {
        _L___15: /* CIL Label */ 
        tmp___63 = __builtin_constant_p((int )name);
        if (tmp___63) {
          if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
              1U) {
            __s2_len = strlen(name);
            if (__s2_len < 4U) {
              tmp___62 = __builtin_constant_p((int )facilitymap[i].name);
              if (tmp___62) {
                if ((unsigned int )((void const   *)(facilitymap[i].name + 1)) - (unsigned int )((void const   *)facilitymap[i].name) ==
                    1U) {
                  tmp___34 = __builtin_strcmp(facilitymap[i].name, name);
                } else {
                  goto _L___13;
                }
              } else {
                _L___13: /* CIL Label */ 
                __s1___14 = (unsigned char const   *)facilitymap[i].name;
                __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)name +
                                                                                           0)));
                if (__s2_len > 0U) {
                  if (__result___22 == 0) {
                    __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)name +
                                                                                               1)));
                    if (__s2_len > 1U) {
                      if (__result___22 == 0) {
                        __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                               (int const   )(*((unsigned char const   *)name +
                                                                2)));
                        if (__s2_len > 2U) {
                          if (__result___22 == 0) {
                            __result___22 = (int )((int const   )(*(__s1___14 + 3)) -
                                                   (int const   )(*((unsigned char const   *)name +
                                                                    3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___34 = __result___22;
              }
            } else {
              tmp___34 = __builtin_strcmp(facilitymap[i].name, name);
            }
          } else {
            tmp___34 = __builtin_strcmp(facilitymap[i].name, name);
          }
        } else {
          tmp___34 = __builtin_strcmp(facilitymap[i].name, name);
        }
      }
    }
    if (! tmp___34) {
      return (facilitymap[i].code);
    }
    i ++;
  }
  return (-1);
}
}
#pragma merger(0,"/tmp/cil-6riQldgo.i","-g -O2")
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
__inline static  __attribute__((__nothrow__)) long strtol__extinline(char const   * __restrict  __nptr ,
                                                                     char ** __restrict  __endptr ,
                                                                     int __base ) ;
__inline static long strtol__extinline(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                       int __base ) 
{ long tmp ;

  {
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
  return (tmp);
}
}
__inline static  __attribute__((__nothrow__)) int atoi__extinline(char const   *__nptr ) ;
__inline static int atoi__extinline(char const   *__nptr ) 
{ int tmp ;

  {
  tmp = (int )strtol__extinline((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *__strdup(char const   *__string )  __attribute__((__malloc__)) ;
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
__inline static  __attribute__((__nothrow__)) int tolower__extinline(int __c ) ;
__inline static int tolower__extinline(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp___1 = __ctype_tolower_loc();
      tmp___0 = (*((*tmp___1) + __c));
    } else {
      tmp___0 = __c;
    }
  } else {
    tmp___0 = __c;
  }
  return (tmp___0);
}
}
struct cfgstruct *parsecfg(char const   *cfgfile , int messages ) ;
struct cfgstruct *regcfg(struct cfgstruct *copt , char *optname , char *strarg , int numarg ) ;
struct cfgstruct *cfgopt(struct cfgstruct  const  *copt , char const   *optname ) ;
void freecfg(struct cfgstruct *copt ) ;
char *cli_strtok(char const   *line , int fieldno , char const   *delim ) ;
void *mmalloc(size_t size ) ;
int isnumb(char const   *str ) ;
struct cfgstruct *parsecfg(char const   *cfgfile , int messages ) 
{ char buff[1024] ;
  char *name ;
  char *arg ;
  FILE *fs ;
  int line ;
  int i ;
  int found ;
  int ctype ;
  int calc ;
  struct cfgstruct *copt ;
  struct cfgoption *pt ;
  struct cfgoption cfg_options[74] ;
  int tmp___73 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___109 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___128 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  size_t tmp___144 ;
  int tmp___145 ;
  size_t tmp___146 ;
  size_t __len___2 ;
  size_t tmp___163 ;
  char *__retval___2 ;
  char *tmp___164 ;
  int tmp___166 ;
  int tmp___167 ;
  int tmp___168 ;
  int __res ;
  int __c ;
  size_t tmp___169 ;
  __int32_t const   **tmp___171 ;
  size_t tmp___172 ;
  size_t tmp___173 ;
  int tmp___174 ;
  __int32_t const   **tmp___175 ;
  size_t tmp___176 ;
  size_t tmp___177 ;
  char *cpy ;
  size_t tmp___178 ;
  char *tmp___179 ;
  size_t tmp___180 ;
  int tmp___181 ;
  int tmp___182 ;
  int tmp___183 ;
  int tmp___184 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___220 ;
  unsigned char const   *__s2___22 ;
  register int __result___66 ;
  int tmp___239 ;
  unsigned char const   *__s1___46 ;
  register int __result___70 ;
  int tmp___248 ;
  int tmp___249 ;
  int tmp___250 ;
  int tmp___251 ;
  int tmp___252 ;
  int tmp___253 ;
  char *tmp___254 ;

  {
  line = 0;
  copt = (struct cfgstruct *)((void *)0);
  cfg_options[0].name = "LogFile";
  cfg_options[0].argtype = 1;
  cfg_options[1].name = "LogFileUnlock";
  cfg_options[1].argtype = 4;
  cfg_options[2].name = "LogFileMaxSize";
  cfg_options[2].argtype = 3;
  cfg_options[3].name = "LogTime";
  cfg_options[3].argtype = 4;
  cfg_options[4].name = "LogClean";
  cfg_options[4].argtype = 4;
  cfg_options[5].name = "LogVerbose";
  cfg_options[5].argtype = 4;
  cfg_options[6].name = "LogSyslog";
  cfg_options[6].argtype = 4;
  cfg_options[7].name = "LogFacility";
  cfg_options[7].argtype = 1;
  cfg_options[8].name = "PidFile";
  cfg_options[8].argtype = 1;
  cfg_options[9].name = "TemporaryDirectory";
  cfg_options[9].argtype = 1;
  cfg_options[10].name = "DisableDefaultScanOptions";
  cfg_options[10].argtype = 4;
  cfg_options[11].name = "ScanPE";
  cfg_options[11].argtype = 4;
  cfg_options[12].name = "DetectBrokenExecutables";
  cfg_options[12].argtype = 4;
  cfg_options[13].name = "ScanMail";
  cfg_options[13].argtype = 4;
  cfg_options[14].name = "MailFollowURLs";
  cfg_options[14].argtype = 4;
  cfg_options[15].name = "ScanHTML";
  cfg_options[15].argtype = 4;
  cfg_options[16].name = "ScanOLE2";
  cfg_options[16].argtype = 4;
  cfg_options[17].name = "ScanArchive";
  cfg_options[17].argtype = 4;
  cfg_options[18].name = "ScanRAR";
  cfg_options[18].argtype = 4;
  cfg_options[19].name = "ArchiveMaxFileSize";
  cfg_options[19].argtype = 3;
  cfg_options[20].name = "ArchiveMaxRecursion";
  cfg_options[20].argtype = 2;
  cfg_options[21].name = "ArchiveMaxFiles";
  cfg_options[21].argtype = 2;
  cfg_options[22].name = "ArchiveMaxCompressionRatio";
  cfg_options[22].argtype = 2;
  cfg_options[23].name = "ArchiveLimitMemoryUsage";
  cfg_options[23].argtype = 4;
  cfg_options[24].name = "ArchiveBlockEncrypted";
  cfg_options[24].argtype = 4;
  cfg_options[25].name = "ArchiveBlockMax";
  cfg_options[25].argtype = 4;
  cfg_options[26].name = "DataDirectory";
  cfg_options[26].argtype = 1;
  cfg_options[27].name = "DatabaseDirectory";
  cfg_options[27].argtype = 1;
  cfg_options[28].name = "TCPAddr";
  cfg_options[28].argtype = 1;
  cfg_options[29].name = "TCPSocket";
  cfg_options[29].argtype = 2;
  cfg_options[30].name = "LocalSocket";
  cfg_options[30].argtype = 1;
  cfg_options[31].name = "MaxConnectionQueueLength";
  cfg_options[31].argtype = 2;
  cfg_options[32].name = "StreamMaxLength";
  cfg_options[32].argtype = 3;
  cfg_options[33].name = "StreamMinPort";
  cfg_options[33].argtype = 2;
  cfg_options[34].name = "StreamMaxPort";
  cfg_options[34].argtype = 2;
  cfg_options[35].name = "MaxThreads";
  cfg_options[35].argtype = 2;
  cfg_options[36].name = "ReadTimeout";
  cfg_options[36].argtype = 2;
  cfg_options[37].name = "IdleTimeout";
  cfg_options[37].argtype = 2;
  cfg_options[38].name = "MaxDirectoryRecursion";
  cfg_options[38].argtype = 2;
  cfg_options[39].name = "FollowDirectorySymlinks";
  cfg_options[39].argtype = 4;
  cfg_options[40].name = "FollowFileSymlinks";
  cfg_options[40].argtype = 4;
  cfg_options[41].name = "ExitOnOOM";
  cfg_options[41].argtype = 4;
  cfg_options[42].name = "Foreground";
  cfg_options[42].argtype = 4;
  cfg_options[43].name = "Debug";
  cfg_options[43].argtype = 4;
  cfg_options[44].name = "LeaveTemporaryFiles";
  cfg_options[44].argtype = 4;
  cfg_options[45].name = "FixStaleSocket";
  cfg_options[45].argtype = 4;
  cfg_options[46].name = "User";
  cfg_options[46].argtype = 1;
  cfg_options[47].name = "AllowSupplementaryGroups";
  cfg_options[47].argtype = 4;
  cfg_options[48].name = "SelfCheck";
  cfg_options[48].argtype = 2;
  cfg_options[49].name = "VirusEvent";
  cfg_options[49].argtype = 6;
  cfg_options[50].name = "ClamukoScanOnLine";
  cfg_options[50].argtype = 4;
  cfg_options[51].name = "ClamukoScanOnAccess";
  cfg_options[51].argtype = 4;
  cfg_options[52].name = "ClamukoScanOnOpen";
  cfg_options[52].argtype = 4;
  cfg_options[53].name = "ClamukoScanOnClose";
  cfg_options[53].argtype = 4;
  cfg_options[54].name = "ClamukoScanOnExec";
  cfg_options[54].argtype = 4;
  cfg_options[55].name = "ClamukoIncludePath";
  cfg_options[55].argtype = 1;
  cfg_options[56].name = "ClamukoExcludePath";
  cfg_options[56].argtype = 1;
  cfg_options[57].name = "ClamukoMaxFileSize";
  cfg_options[57].argtype = 3;
  cfg_options[58].name = "ClamukoScanArchive";
  cfg_options[58].argtype = 4;
  cfg_options[59].name = "DatabaseOwner";
  cfg_options[59].argtype = 1;
  cfg_options[60].name = "Checks";
  cfg_options[60].argtype = 2;
  cfg_options[61].name = "UpdateLogFile";
  cfg_options[61].argtype = 1;
  cfg_options[62].name = "DNSDatabaseInfo";
  cfg_options[62].argtype = 1;
  cfg_options[63].name = "DatabaseMirror";
  cfg_options[63].argtype = 1;
  cfg_options[64].name = "MaxAttempts";
  cfg_options[64].argtype = 2;
  cfg_options[65].name = "HTTPProxyServer";
  cfg_options[65].argtype = 1;
  cfg_options[66].name = "HTTPProxyPort";
  cfg_options[66].argtype = 2;
  cfg_options[67].name = "HTTPProxyUsername";
  cfg_options[67].argtype = 1;
  cfg_options[68].name = "HTTPProxyPassword";
  cfg_options[68].argtype = 1;
  cfg_options[69].name = "NotifyClamd";
  cfg_options[69].argtype = 5;
  cfg_options[70].name = "OnUpdateExecute";
  cfg_options[70].argtype = 6;
  cfg_options[71].name = "OnErrorExecute";
  cfg_options[71].argtype = 6;
  cfg_options[72].name = "LocalIPAddress";
  cfg_options[72].argtype = 1;
  cfg_options[73].name = (char const   *)0;
  cfg_options[73].argtype = 0;
  fs = fopen((char const   * __restrict  )cfgfile, (char const   * __restrict  )"r");
  if ((unsigned int )fs == (unsigned int )((void *)0)) {
    return ((struct cfgstruct *)((void *)0));
  }
  while (1) {
    tmp___254 = fgets((char * __restrict  )(buff), 1024, (FILE * __restrict  )fs);
    if (! tmp___254) {
      break;
    }
    line ++;
    if ((int )buff[0] == 35) {
      continue;
    }
    tmp___143 = __builtin_constant_p((int )"Example");
    if (tmp___143) {
      tmp___144 = strlen("Example");
      if (tmp___144 < 7U) {
        goto _L___39;
      } else {
        goto _L___40;
      }
    } else {
      _L___40: /* CIL Label */ 
      tmp___145 = __builtin_constant_p((int )(buff));
      if (tmp___145) {
        tmp___146 = strlen((char const   *)(buff));
        if (tmp___146 < 7U) {
          _L___39: /* CIL Label */ 
          tmp___140 = __builtin_constant_p((int )"Example");
          if (tmp___140) {
            tmp___141 = __builtin_constant_p((int )(buff));
            if (tmp___141) {
              __s1_len___0 = strlen("Example");
              __s2_len___0 = strlen((char const   *)(buff));
              if (! ((unsigned int )((void const   *)("Example" + 1)) - (unsigned int )((void const   *)"Example") ==
                     1U)) {
                goto _L___36;
              } else {
                if (__s1_len___0 >= 4U) {
                  _L___36: /* CIL Label */ 
                  if (! ((unsigned int )((void const   *)(buff + 1)) - (unsigned int )((void const   *)(buff)) ==
                         1U)) {
                    tmp___142 = 1;
                  } else {
                    if (__s2_len___0 >= 4U) {
                      tmp___142 = 1;
                    } else {
                      tmp___142 = 0;
                    }
                  }
                } else {
                  tmp___142 = 0;
                }
              }
              if (tmp___142) {
                tmp___109 = __builtin_strcmp("Example", buff);
              } else {
                goto _L___38;
              }
            } else {
              goto _L___38;
            }
          } else {
            _L___38: /* CIL Label */ 
            tmp___139 = __builtin_constant_p((int )"Example");
            if (tmp___139) {
              if ((unsigned int )((void const   *)("Example" + 1)) - (unsigned int )((void const   *)"Example") ==
                  1U) {
                __s1_len___0 = strlen("Example");
                if (__s1_len___0 < 4U) {
                  tmp___128 = __builtin_constant_p((int )(buff));
                  if (tmp___128) {
                    if ((unsigned int )((void const   *)(buff + 1)) - (unsigned int )((void const   *)(buff)) ==
                        1U) {
                      tmp___109 = __builtin_strcmp("Example", buff);
                    } else {
                      goto _L___31;
                    }
                  } else {
                    _L___31: /* CIL Label */ 
                    __s2___14 = (unsigned char const   *)((char const   *)(buff));
                    __result___42 = (int )((int const   )(*((unsigned char const   *)"Example" +
                                                            0)) - (int const   )(*(__s2___14 +
                                                                                   0)));
                    if (__s1_len___0 > 0U) {
                      if (__result___42 == 0) {
                        __result___42 = (int )((int const   )(*((unsigned char const   *)"Example" +
                                                                1)) - (int const   )(*(__s2___14 +
                                                                                       1)));
                        if (__s1_len___0 > 1U) {
                          if (__result___42 == 0) {
                            __result___42 = (int )((int const   )(*((unsigned char const   *)"Example" +
                                                                    2)) - (int const   )(*(__s2___14 +
                                                                                           2)));
                            if (__s1_len___0 > 2U) {
                              if (__result___42 == 0) {
                                __result___42 = (int )((int const   )(*((unsigned char const   *)"Example" +
                                                                        3)) - (int const   )(*(__s2___14 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___109 = __result___42;
                  }
                } else {
                  goto _L___35;
                }
              } else {
                goto _L___35;
              }
            } else {
              _L___35: /* CIL Label */ 
              tmp___138 = __builtin_constant_p((int )(buff));
              if (tmp___138) {
                if ((unsigned int )((void const   *)(buff + 1)) - (unsigned int )((void const   *)(buff)) ==
                    1U) {
                  __s2_len___0 = strlen((char const   *)(buff));
                  if (__s2_len___0 < 4U) {
                    tmp___137 = __builtin_constant_p((int )"Example");
                    if (tmp___137) {
                      if ((unsigned int )((void const   *)("Example" + 1)) - (unsigned int )((void const   *)"Example") ==
                          1U) {
                        tmp___109 = __builtin_strcmp("Example", buff);
                      } else {
                        goto _L___33;
                      }
                    } else {
                      _L___33: /* CIL Label */ 
                      __s1___30 = (unsigned char const   *)"Example";
                      __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)(buff)) +
                                                                                                 0)));
                      if (__s2_len___0 > 0U) {
                        if (__result___46 == 0) {
                          __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                 (int const   )(*((unsigned char const   *)((char const   *)(buff)) +
                                                                  1)));
                          if (__s2_len___0 > 1U) {
                            if (__result___46 == 0) {
                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                      2)) - (int const   )(*((unsigned char const   *)((char const   *)(buff)) +
                                                                                             2)));
                              if (__s2_len___0 > 2U) {
                                if (__result___46 == 0) {
                                  __result___46 = (int )((int const   )(*(__s1___30 +
                                                                          3)) - (int const   )(*((unsigned char const   *)((char const   *)(buff)) +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___109 = __result___46;
                    }
                  } else {
                    tmp___109 = __builtin_strcmp("Example", buff);
                  }
                } else {
                  tmp___109 = __builtin_strcmp("Example", buff);
                }
              } else {
                tmp___109 = __builtin_strcmp("Example", buff);
              }
            }
          }
          tmp___73 = tmp___109;
        } else {
          tmp___73 = strncmp("Example", (char const   *)(buff), 7U);
        }
      } else {
        tmp___73 = strncmp("Example", (char const   *)(buff), 7U);
      }
    }
    if (! tmp___73) {
      if (messages) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Please edit the example config file %s.\n",
                cfgfile);
      }
      fclose(fs);
      return ((struct cfgstruct *)((void *)0));
    }
    name = cli_strtok((char const   *)(buff), 0, " \r\n");
    if (name) {
      arg = cli_strtok((char const   *)(buff), 1, " \r\n");
      found = 0;
      i = 0;
      while (1) {
        pt = & cfg_options[i];
        if (pt->name) {
          tmp___251 = __builtin_constant_p((int )name);
          if (tmp___251) {
            tmp___252 = __builtin_constant_p((int )pt->name);
            if (tmp___252) {
              __s1_len___1 = strlen((char const   *)name);
              __s2_len___1 = strlen(pt->name);
              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                     1U)) {
                goto _L___60;
              } else {
                if (__s1_len___1 >= 4U) {
                  _L___60: /* CIL Label */ 
                  if (! ((unsigned int )((void const   *)(pt->name + 1)) - (unsigned int )((void const   *)pt->name) ==
                         1U)) {
                    tmp___253 = 1;
                  } else {
                    if (__s2_len___1 >= 4U) {
                      tmp___253 = 1;
                    } else {
                      tmp___253 = 0;
                    }
                  }
                } else {
                  tmp___253 = 0;
                }
              }
              if (tmp___253) {
                tmp___220 = __builtin_strcmp(name, pt->name);
              } else {
                goto _L___62;
              }
            } else {
              goto _L___62;
            }
          } else {
            _L___62: /* CIL Label */ 
            tmp___250 = __builtin_constant_p((int )name);
            if (tmp___250) {
              if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                  1U) {
                __s1_len___1 = strlen((char const   *)name);
                if (__s1_len___1 < 4U) {
                  tmp___239 = __builtin_constant_p((int )pt->name);
                  if (tmp___239) {
                    if ((unsigned int )((void const   *)(pt->name + 1)) - (unsigned int )((void const   *)pt->name) ==
                        1U) {
                      tmp___220 = __builtin_strcmp(name, pt->name);
                    } else {
                      goto _L___55;
                    }
                  } else {
                    _L___55: /* CIL Label */ 
                    __s2___22 = (unsigned char const   *)pt->name;
                    __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)name) +
                                                            0)) - (int const   )(*(__s2___22 +
                                                                                   0)));
                    if (__s1_len___1 > 0U) {
                      if (__result___66 == 0) {
                        __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                1)) - (int const   )(*(__s2___22 +
                                                                                       1)));
                        if (__s1_len___1 > 1U) {
                          if (__result___66 == 0) {
                            __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                    2)) - (int const   )(*(__s2___22 +
                                                                                           2)));
                            if (__s1_len___1 > 2U) {
                              if (__result___66 == 0) {
                                __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                        3)) - (int const   )(*(__s2___22 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___220 = __result___66;
                  }
                } else {
                  goto _L___59;
                }
              } else {
                goto _L___59;
              }
            } else {
              _L___59: /* CIL Label */ 
              tmp___249 = __builtin_constant_p((int )pt->name);
              if (tmp___249) {
                if ((unsigned int )((void const   *)(pt->name + 1)) - (unsigned int )((void const   *)pt->name) ==
                    1U) {
                  __s2_len___1 = strlen(pt->name);
                  if (__s2_len___1 < 4U) {
                    tmp___248 = __builtin_constant_p((int )name);
                    if (tmp___248) {
                      if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                          1U) {
                        tmp___220 = __builtin_strcmp(name, pt->name);
                      } else {
                        goto _L___57;
                      }
                    } else {
                      _L___57: /* CIL Label */ 
                      __s1___46 = (unsigned char const   *)((char const   *)name);
                      __result___70 = (int )((int const   )(*(__s1___46 + 0)) - (int const   )(*((unsigned char const   *)pt->name +
                                                                                                 0)));
                      if (__s2_len___1 > 0U) {
                        if (__result___70 == 0) {
                          __result___70 = (int )((int const   )(*(__s1___46 + 1)) -
                                                 (int const   )(*((unsigned char const   *)pt->name +
                                                                  1)));
                          if (__s2_len___1 > 1U) {
                            if (__result___70 == 0) {
                              __result___70 = (int )((int const   )(*(__s1___46 +
                                                                      2)) - (int const   )(*((unsigned char const   *)pt->name +
                                                                                             2)));
                              if (__s2_len___1 > 2U) {
                                if (__result___70 == 0) {
                                  __result___70 = (int )((int const   )(*(__s1___46 +
                                                                          3)) - (int const   )(*((unsigned char const   *)pt->name +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___220 = __result___70;
                    }
                  } else {
                    tmp___220 = __builtin_strcmp(name, pt->name);
                  }
                } else {
                  tmp___220 = __builtin_strcmp(name, pt->name);
                }
              } else {
                tmp___220 = __builtin_strcmp(name, pt->name);
              }
            }
          }
          if (! tmp___220) {
            found = 1;
            switch (pt->argtype) {
            case 1: ;
            if (! arg) {
              if (messages) {
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Parse error at line %d: Option %s requires string as argument.\n",
                        line, name);
              }
              fclose(fs);
              return ((struct cfgstruct *)((void *)0));
            }
            copt = regcfg(copt, name, arg, 0);
            break;
            case 6: ;
            if (! arg) {
              if (messages) {
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Parse error at line %d: Option %s requires string as argument.\n",
                        line, name);
              }
              fclose(fs);
              return ((struct cfgstruct *)((void *)0));
            }
            free((void *)arg);
            arg = strstr((char const   *)(buff), " ");
            arg ++;
            tmp___166 = __builtin_constant_p((int )arg);
            if (tmp___166) {
              arg ++;
              arg ++;
              if ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) ==
                  1U) {
                arg ++;
                if ((int const   )(*((char const   *)arg + 0)) == 0) {
                  arg = (char *)calloc(1U, 1U);
                } else {
                  arg ++;
                  tmp___163 = strlen((char const   *)arg);
                  __len___2 = tmp___163 + 1U;
                  tmp___164 = (char *)malloc(__len___2);
                  __retval___2 = tmp___164;
                  if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
                    arg ++;
                    __retval___2 = (char *)memcpy((void * __restrict  )__retval___2,
                                                  (void const   * __restrict  )arg,
                                                  __len___2);
                  }
                  arg = __retval___2;
                }
              } else {
                arg ++;
                arg = __strdup((char const   *)arg);
              }
            } else {
              arg ++;
              arg = __strdup((char const   *)arg);
            }
            copt = regcfg(copt, name, arg, 0);
            break;
            case 2: ;
            if (! arg) {
              goto _L___41;
            } else {
              tmp___167 = isnumb((char const   *)arg);
              if (! tmp___167) {
                _L___41: /* CIL Label */ 
                if (messages) {
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Parse error at line %d: Option %s requires numerical argument.\n",
                          line, name);
                }
                fclose(fs);
                return ((struct cfgstruct *)((void *)0));
              }
            }
            tmp___168 = atoi__extinline((char const   *)arg);
            copt = regcfg(copt, name, (char *)((void *)0), tmp___168);
            free((void *)arg);
            break;
            case 3: ;
            if (! arg) {
              if (messages) {
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Parse error at line %d: Option %s requires argument.\n",
                        line, name);
              }
              fclose(fs);
              return ((struct cfgstruct *)((void *)0));
            }
            if (sizeof((*(arg + (tmp___177 - 1U)))) > 1U) {
              tmp___173 = strlen((char const   *)arg);
              tmp___174 = __builtin_constant_p((int )(*(arg + (tmp___173 - 1U))));
              if (tmp___174) {
                tmp___169 = strlen((char const   *)arg);
                __c = (int )(*(arg + (tmp___169 - 1U)));
                if (__c < -128) {
                  __res = __c;
                } else {
                  if (__c > 255) {
                    __res = __c;
                  } else {
                    tmp___171 = __ctype_tolower_loc();
                    __res = (*((*tmp___171) + __c));
                  }
                }
              } else {
                tmp___172 = strlen((char const   *)arg);
                __res = tolower__extinline((int )(*(arg + (tmp___172 - 1U))));
              }
            } else {
              tmp___175 = __ctype_tolower_loc();
              tmp___176 = strlen((char const   *)arg);
              __res = (*((*tmp___175) + (int )(*(arg + (tmp___176 - 1U)))));
            }
            ctype = __res;
            if (ctype == 109) {
              goto _L___42;
            } else {
              if (ctype == 107) {
                _L___42: /* CIL Label */ 
                tmp___178 = strlen((char const   *)arg);
                tmp___179 = (char *)mcalloc(tmp___178, sizeof(char ));
                cpy = tmp___179;
                tmp___180 = strlen((char const   *)arg);
                __builtin_strncpy(cpy, arg, tmp___180 - 1U);
                tmp___181 = isnumb((char const   *)cpy);
                if (! tmp___181) {
                  if (messages) {
                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Parse error at line %d: Option %s requires numerical (raw/K/M) argument.\n",
                            line, name);
                  }
                  fclose(fs);
                  return ((struct cfgstruct *)((void *)0));
                }
                if (ctype == 109) {
                  tmp___182 = atoi__extinline((char const   *)cpy);
                  calc = (tmp___182 * 1024) * 1024;
                } else {
                  tmp___183 = atoi__extinline((char const   *)cpy);
                  calc = tmp___183 * 1024;
                }
                free((void *)cpy);
              } else {
                tmp___184 = isnumb((char const   *)arg);
                if (! tmp___184) {
                  if (messages) {
                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Parse error at line %d: Option %s requires numerical (raw/K/M) argument.\n",
                            line, name);
                  }
                  fclose(fs);
                  return ((struct cfgstruct *)((void *)0));
                }
                calc = atoi__extinline((char const   *)arg);
              }
            }
            copt = regcfg(copt, name, (char *)((void *)0), calc);
            free((void *)arg);
            break;
            case 4: ;
            if (arg) {
              if (messages) {
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Parse error at line %d: Option %s doesn\'t support arguments (got \'%s\').\n",
                        line, name, arg);
              }
              fclose(fs);
              return ((struct cfgstruct *)((void *)0));
            }
            copt = regcfg(copt, name, (char *)((void *)0), 0);
            break;
            case 5: 
            copt = regcfg(copt, name, arg, 0);
            break;
            default: ;
            if (messages) {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Parse error at line %d: Option %s is of unknown type %d\n",
                      line, name, pt->argtype);
            }
            free((void *)name);
            free((void *)arg);
            break;
            }
          }
        } else {
          break;
        }
        i ++;
      }
      if (! found) {
        if (messages) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Parse error at line %d: Unknown option %s.\n",
                  line, name);
        }
        fclose(fs);
        return ((struct cfgstruct *)((void *)0));
      }
    }
  }
  fclose(fs);
  return (copt);
}
}
void freecfg(struct cfgstruct *copt ) 
{ struct cfgstruct *handler ;
  struct cfgstruct *arg ;

  {
  while (copt) {
    arg = copt->nextarg;
    while (arg) {
      if (arg->strarg) {
        free((void *)arg->optname);
        free((void *)arg->strarg);
        handler = arg;
        arg = arg->nextarg;
        free((void *)handler);
      } else {
        arg = arg->nextarg;
      }
    }
    if (copt->optname) {
      free((void *)copt->optname);
    }
    if (copt->strarg) {
      free((void *)copt->strarg);
    }
    handler = copt;
    copt = copt->next;
    free((void *)handler);
  }
  return;
}
}
struct cfgstruct *regcfg(struct cfgstruct *copt , char *optname , char *strarg , int numarg ) 
{ struct cfgstruct *newnode ;
  struct cfgstruct *pt ;

  {
  newnode = (struct cfgstruct *)mmalloc(sizeof(struct cfgstruct ));
  newnode->optname = optname;
  newnode->nextarg = (struct cfgstruct *)((void *)0);
  newnode->next = (struct cfgstruct *)((void *)0);
  if (strarg) {
    newnode->strarg = strarg;
  } else {
    newnode->strarg = (char *)((void *)0);
    newnode->numarg = numarg;
  }
  pt = cfgopt((struct cfgstruct  const  *)copt, (char const   *)optname);
  if (pt) {
    while (pt->nextarg) {
      pt = pt->nextarg;
    }
    pt->nextarg = newnode;
    return (copt);
  } else {
    newnode->next = copt;
    return (newnode);
  }
}
}
struct cfgstruct *cfgopt(struct cfgstruct  const  *copt , char const   *optname ) 
{ struct cfgstruct *handler ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___53 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;

  {
  handler = (struct cfgstruct *)copt;
  while (1) {
    if (handler) {
      if (handler->optname) {
        tmp___65 = __builtin_constant_p((int )handler->optname);
        if (tmp___65) {
          tmp___66 = __builtin_constant_p((int )optname);
          if (tmp___66) {
            __s1_len = strlen((char const   *)handler->optname);
            __s2_len = strlen(optname);
            if (! ((unsigned int )((void const   *)(handler->optname + 1)) - (unsigned int )((void const   *)handler->optname) ==
                   1U)) {
              goto _L___16;
            } else {
              if (__s1_len >= 4U) {
                _L___16: /* CIL Label */ 
                if (! ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                       1U)) {
                  tmp___67 = 1;
                } else {
                  if (__s2_len >= 4U) {
                    tmp___67 = 1;
                  } else {
                    tmp___67 = 0;
                  }
                }
              } else {
                tmp___67 = 0;
              }
            }
            if (tmp___67) {
              tmp___34 = __builtin_strcmp(handler->optname, optname);
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: /* CIL Label */ 
          tmp___64 = __builtin_constant_p((int )handler->optname);
          if (tmp___64) {
            if ((unsigned int )((void const   *)(handler->optname + 1)) - (unsigned int )((void const   *)handler->optname) ==
                1U) {
              __s1_len = strlen((char const   *)handler->optname);
              if (__s1_len < 4U) {
                tmp___53 = __builtin_constant_p((int )optname);
                if (tmp___53) {
                  if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                      1U) {
                    tmp___34 = __builtin_strcmp(handler->optname, optname);
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: /* CIL Label */ 
                  __s2___6 = (unsigned char const   *)optname;
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
                  if (__s1_len > 0U) {
                    if (__result___18 == 0) {
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
                      if (__s1_len > 1U) {
                        if (__result___18 == 0) {
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
                          if (__s1_len > 2U) {
                            if (__result___18 == 0) {
                              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___34 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: /* CIL Label */ 
            tmp___63 = __builtin_constant_p((int )optname);
            if (tmp___63) {
              if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                  1U) {
                __s2_len = strlen(optname);
                if (__s2_len < 4U) {
                  tmp___62 = __builtin_constant_p((int )handler->optname);
                  if (tmp___62) {
                    if ((unsigned int )((void const   *)(handler->optname + 1)) -
                        (unsigned int )((void const   *)handler->optname) == 1U) {
                      tmp___34 = __builtin_strcmp(handler->optname, optname);
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: /* CIL Label */ 
                    __s1___14 = (unsigned char const   *)((char const   *)handler->optname);
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)optname +
                                                                                               0)));
                    if (__s2_len > 0U) {
                      if (__result___22 == 0) {
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)optname +
                                                                1)));
                        if (__s2_len > 1U) {
                          if (__result___22 == 0) {
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)optname +
                                                                    2)));
                            if (__s2_len > 2U) {
                              if (__result___22 == 0) {
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)optname +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___34 = __result___22;
                  }
                } else {
                  tmp___34 = __builtin_strcmp(handler->optname, optname);
                }
              } else {
                tmp___34 = __builtin_strcmp(handler->optname, optname);
              }
            } else {
              tmp___34 = __builtin_strcmp(handler->optname, optname);
            }
          }
        }
        if (! tmp___34) {
          return (handler);
        }
      }
    } else {
      break;
    }
    handler = handler->next;
  }
  return ((struct cfgstruct *)((void *)0));
}
}
#pragma merger(0,"/tmp/cil-DgTwRPLt.i","-g -O2")
#pragma merger(0,"/tmp/cil-ATHdr1O8.i","-g -O2")
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
void *mmalloc(size_t size ) 
{ void *alloc ;

  {
  alloc = malloc(size);
  if (! alloc) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"CRITICAL: Can\'t allocate memory (%ld bytes).\n",
            (long )size);
    _exit(71);
    return ((void *)0);
  } else {
    return (alloc);
  }
}
}
void *mcalloc(size_t nmemb , size_t size ) 
{ void *alloc ;

  {
  alloc = calloc(nmemb, size);
  if (! alloc) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"CRITICAL: Can\'t allocate memory (%ld bytes).\n",
            (unsigned long )((long )nmemb) * (unsigned long )size);
    _exit(70);
    return ((void *)0);
  } else {
    return (alloc);
  }
}
}
#pragma merger(0,"/tmp/cil-qT7iCRr1.i","-g -O2")
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
extern int close(int __fd ) ;
ssize_t read(int __fd , void *__buf , size_t __nbytes );
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
char const   *cl_retdbdir(void) ;
struct cl_cvd *cl_cvdhead(char const   *file ) ;
void cl_cvdfree(struct cl_cvd *cvd ) ;
char *freshdbdir(void) 
{ struct cl_cvd *d1 ;
  struct cl_cvd *d2 ;
  struct cfgstruct *copt ;
  struct cfgstruct *cpt ;
  char const   *dbdir ;
  char *retdir ;
  char *daily ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___37 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___56 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  size_t __len___2 ;
  size_t tmp___87 ;
  char *__retval___2 ;
  char *tmp___88 ;
  int tmp___90 ;

  {
  copt = (struct cfgstruct *)((void *)0);
  dbdir = cl_retdbdir();
  copt = parsecfg("/usr/local/etc/clamd.conf", 0);
  if (copt) {
    cpt = cfgopt((struct cfgstruct  const  *)copt, "DatabaseDirectory");
    if (cpt) {
      goto _L___19;
    } else {
      cpt = cfgopt((struct cfgstruct  const  *)copt, "DataDirectory");
      if (cpt) {
        _L___19: /* CIL Label */ 
        tmp___68 = __builtin_constant_p((int )dbdir);
        if (tmp___68) {
          tmp___69 = __builtin_constant_p((int )cpt->strarg);
          if (tmp___69) {
            __s1_len = strlen(dbdir);
            __s2_len = strlen((char const   *)cpt->strarg);
            if (! ((unsigned int )((void const   *)(dbdir + 1)) - (unsigned int )((void const   *)dbdir) ==
                   1U)) {
              goto _L___16;
            } else {
              if (__s1_len >= 4U) {
                _L___16: /* CIL Label */ 
                if (! ((unsigned int )((void const   *)(cpt->strarg + 1)) - (unsigned int )((void const   *)cpt->strarg) ==
                       1U)) {
                  tmp___70 = 1;
                } else {
                  if (__s2_len >= 4U) {
                    tmp___70 = 1;
                  } else {
                    tmp___70 = 0;
                  }
                }
              } else {
                tmp___70 = 0;
              }
            }
            if (tmp___70) {
              tmp___37 = __builtin_strcmp(dbdir, cpt->strarg);
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: /* CIL Label */ 
          tmp___67 = __builtin_constant_p((int )dbdir);
          if (tmp___67) {
            if ((unsigned int )((void const   *)(dbdir + 1)) - (unsigned int )((void const   *)dbdir) ==
                1U) {
              __s1_len = strlen(dbdir);
              if (__s1_len < 4U) {
                tmp___56 = __builtin_constant_p((int )cpt->strarg);
                if (tmp___56) {
                  if ((unsigned int )((void const   *)(cpt->strarg + 1)) - (unsigned int )((void const   *)cpt->strarg) ==
                      1U) {
                    tmp___37 = __builtin_strcmp(dbdir, cpt->strarg);
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: /* CIL Label */ 
                  __s2___6 = (unsigned char const   *)((char const   *)cpt->strarg);
                  __result___18 = (int )((int const   )(*((unsigned char const   *)dbdir +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
                  if (__s1_len > 0U) {
                    if (__result___18 == 0) {
                      __result___18 = (int )((int const   )(*((unsigned char const   *)dbdir +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
                      if (__s1_len > 1U) {
                        if (__result___18 == 0) {
                          __result___18 = (int )((int const   )(*((unsigned char const   *)dbdir +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
                          if (__s1_len > 2U) {
                            if (__result___18 == 0) {
                              __result___18 = (int )((int const   )(*((unsigned char const   *)dbdir +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___37 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: /* CIL Label */ 
            tmp___66 = __builtin_constant_p((int )cpt->strarg);
            if (tmp___66) {
              if ((unsigned int )((void const   *)(cpt->strarg + 1)) - (unsigned int )((void const   *)cpt->strarg) ==
                  1U) {
                __s2_len = strlen((char const   *)cpt->strarg);
                if (__s2_len < 4U) {
                  tmp___65 = __builtin_constant_p((int )dbdir);
                  if (tmp___65) {
                    if ((unsigned int )((void const   *)(dbdir + 1)) - (unsigned int )((void const   *)dbdir) ==
                        1U) {
                      tmp___37 = __builtin_strcmp(dbdir, cpt->strarg);
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: /* CIL Label */ 
                    __s1___14 = (unsigned char const   *)dbdir;
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)cpt->strarg) +
                                                                                               0)));
                    if (__s2_len > 0U) {
                      if (__result___22 == 0) {
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)((char const   *)cpt->strarg) +
                                                                1)));
                        if (__s2_len > 1U) {
                          if (__result___22 == 0) {
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)((char const   *)cpt->strarg) +
                                                                    2)));
                            if (__s2_len > 2U) {
                              if (__result___22 == 0) {
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)((char const   *)cpt->strarg) +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___37 = __result___22;
                  }
                } else {
                  tmp___37 = __builtin_strcmp(dbdir, cpt->strarg);
                }
              } else {
                tmp___37 = __builtin_strcmp(dbdir, cpt->strarg);
              }
            } else {
              tmp___37 = __builtin_strcmp(dbdir, cpt->strarg);
            }
          }
        }
        if (tmp___37) {
          tmp = strlen((char const   *)cpt->strarg);
          tmp___0 = strlen(dbdir);
          tmp___1 = (char *)mmalloc((tmp + tmp___0) + 15U);
          daily = tmp___1;
          sprintf((char * __restrict  )daily, (char const   * __restrict  )"%s/daily.cvd",
                  cpt->strarg);
          d1 = cl_cvdhead((char const   *)daily);
          if (d1) {
            sprintf((char * __restrict  )daily, (char const   * __restrict  )"%s/daily.cvd",
                    dbdir);
            d2 = cl_cvdhead((char const   *)daily);
            if (d2) {
              free((void *)daily);
              if (d1->version > d2->version) {
                dbdir = (char const   *)cpt->strarg;
              }
              cl_cvdfree(d2);
            } else {
              free((void *)daily);
              dbdir = (char const   *)cpt->strarg;
            }
            cl_cvdfree(d1);
          } else {
            free((void *)daily);
          }
        }
      }
    }
  }
  tmp___90 = __builtin_constant_p((int )dbdir);
  if (tmp___90) {
    if ((unsigned int )((void const   *)(dbdir + 1)) - (unsigned int )((void const   *)dbdir) ==
        1U) {
      if ((int const   )(*(dbdir + 0)) == 0) {
        retdir = (char *)calloc(1U, 1U);
      } else {
        tmp___87 = strlen(dbdir);
        __len___2 = tmp___87 + 1U;
        tmp___88 = (char *)malloc(__len___2);
        __retval___2 = tmp___88;
        if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
          __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )dbdir,
                                        __len___2);
        }
        retdir = __retval___2;
      }
    } else {
      retdir = __strdup(dbdir);
    }
  } else {
    retdir = __strdup(dbdir);
  }
  if (copt) {
    freecfg(copt);
  }
  return (retdir);
}
}
void print_version(void) 
{ char *dbdir ;
  char *path ;
  struct cl_cvd *daily ;
  size_t tmp ;
  time_t t ;
  char *tmp___0 ;

  {
  dbdir = freshdbdir();
  tmp = strlen((char const   *)dbdir);
  path = (char *)mmalloc(tmp + 11U);
  if (! path) {
    free((void *)dbdir);
    return;
  }
  sprintf((char * __restrict  )path, (char const   * __restrict  )"%s/daily.cvd",
          dbdir);
  free((void *)dbdir);
  daily = cl_cvdhead((char const   *)path);
  if (daily) {
    t = (long )daily->stime;
    tmp___0 = ctime((time_t const   *)(& t));
    printf((char const   * __restrict  )"ClamAV 0.85.1/%d/%s", daily->version, tmp___0);
    cl_cvdfree(daily);
  } else {
    printf((char const   * __restrict  )"ClamAV 0.85.1\n");
  }
  free((void *)path);
  return;
}
}
int filecopy(char const   *src , char const   *dest ) 
{ char buffer[8192] ;
  int s ;
  int d ;
  int bytes ;
  int tmp ;

  {
  s = open(src, 0);
  if (s == -1) {
    return (-1);
  }
  d = open(dest, 577);
  if (d == -1) {
    close(s);
    return (-1);
  }
  while (1) {
    bytes = read(s, (void *)(buffer), 8192U);
    if (! (bytes > 0)) {
      break;
    }
    write(d, (void const   *)(buffer), (unsigned int )bytes);
  }
  close(s);
  tmp = close(d);
  return (tmp);
}
}
extern int ( /* missing proto */  isdigit)() ;
int isnumb(char const   *str ) 
{ int tmp ;

  {
  while ((*str)) {
    tmp = isdigit((*str));
    if (! tmp) {
      return (0);
    }
    str ++;
  }
  return (1);
}
}
#pragma merger(0,"/tmp/cil-Ub5RB8cD.i","-g -O2")
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern int system(char const   *__command ) ;
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
extern unsigned int sleep(unsigned int __seconds ) ;
extern int pause(void) ;
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
extern struct passwd *getpwnam(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int setgroups(size_t __n , __gid_t const   *__groups ) ;
extern int initgroups(char const   * , __gid_t __group ) ;
extern void openlog(char const   *__ident , int __option , int __facility ) ;
int optc(struct optstruct  const  *opt , char ch ) ;
int optl(struct optstruct  const  *opt , char const   *optname ) ;
char *getargc(struct optstruct  const  *opt , char ch ) ;
char *getargl(struct optstruct  const  *opt , char const   *optname ) ;
void free_opt(struct optstruct *opt ) ;
void cl_debug(void) ;
int downloadmanager(struct cfgstruct  const  *copt , struct optstruct  const  *opt ,
                    char const   *hostname ) ;
void help(void) ;
void daemonize(void) ;
int download(struct cfgstruct  const  *copt , struct optstruct  const  *opt ) ;
void execute(char const   *type , char const   *text ) ;
static short terminate  =    (short)0;
int active_children ;
static void daemon_sighandler(int sig ) 
{ 

  {
  switch (sig) {
  case 17: 
  waitpid(-1, (int *)((void *)0), 1);
  active_children --;
  break;
  case 14: ;
  case 10: 
  terminate = (short)-1;
  break;
  case 1: 
  terminate = (short)-2;
  break;
  default: 
  terminate = (short)1;
  break;
  }
  return;
}
}
static void writepid(char *pidfile ) 
{ FILE *fd ;
  int old_umask ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;

  {
  old_umask = (int )umask(6U);
  fd = fopen((char const   * __restrict  )pidfile, (char const   * __restrict  )"w");
  if ((unsigned int )fd == (unsigned int )((void *)0)) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    logg("!Can\'t save PID to file %s: %s\n", pidfile, tmp___0);
  } else {
    tmp___1 = getpid();
    fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%d", tmp___1);
    fclose(fd);
  }
  umask((unsigned int )old_umask);
  return;
}
}
int freshclam(struct optstruct *opt ) 
{ int ret ;
  char *newdir ;
  char *cfgfile ;
  char *pidfile ;
  struct cfgstruct *copt ;
  struct cfgstruct *cpt ;
  struct sigaction sigact ;
  struct sigaction oldact ;
  char *unpuser ;
  struct passwd *user ;
  struct stat statbuf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct cfgstruct *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  struct cfgstruct *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  __uid_t tmp___10 ;
  int tmp___11 ;
  struct cfgstruct *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  struct cfgstruct *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int fac ;
  struct cfgstruct *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int bigsleep ;
  int checks ;
  time_t now ;
  time_t wakeup ;
  char const   *tmp___24 ;
  int tmp___25 ;
  struct cfgstruct *tmp___26 ;
  struct cfgstruct *tmp___27 ;
  int tmp___28 ;
  char const   *arg ;
  int tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int tmp___32 ;

  {
  ret = 52;
  pidfile = (char *)((void *)0);
  tmp = optc((struct optstruct  const  *)opt, (char )'h');
  if (tmp) {
    free_opt(opt);
    help();
  }
  cfgfile = getargl((struct optstruct  const  *)opt, "config-file");
  if (cfgfile) {
    copt = parsecfg((char const   *)cfgfile, 1);
  } else {
    cfgfile = (char *)"/usr/local/etc/freshclam.conf";
    copt = parsecfg((char const   *)cfgfile, 1);
    if ((unsigned int )copt == (unsigned int )((void *)0)) {
      cfgfile = (char *)"/usr/local/etc/clamd.conf";
      copt = parsecfg((char const   *)cfgfile, 1);
    }
  }
  if (! copt) {
    mprintf("!Can\'t parse the config file %s\n", cfgfile);
    return (56);
  }
  tmp___0 = optl((struct optstruct  const  *)opt, "http-proxy");
  if (tmp___0) {
    mprintf("WARNING: Proxy settings are now only configurable in the config file.\n");
  } else {
    tmp___1 = optl((struct optstruct  const  *)opt, "proxy-user");
    if (tmp___1) {
      mprintf("WARNING: Proxy settings are now only configurable in the config file.\n");
    }
  }
  tmp___3 = cfgopt((struct cfgstruct  const  *)copt, "HTTPProxyPassword");
  if (tmp___3) {
    tmp___2 = stat__extinline((char const   *)cfgfile, & statbuf);
    if (tmp___2 == -1) {
      mprintf("@Can\'t stat %s (critical error)\n", cfgfile);
      return (56);
    }
    if (statbuf.st_mode & 63U) {
      mprintf("@Insecure permissions (for HTTPProxyPassword): %s must have no more than 0700 permissions.\n",
              cfgfile);
      return (56);
    }
  }
  tmp___4 = optc((struct optstruct  const  *)opt, (char )'u');
  if (tmp___4) {
    unpuser = getargc((struct optstruct  const  *)opt, (char )'u');
  } else {
    cpt = cfgopt((struct cfgstruct  const  *)copt, "DatabaseOwner");
    if (cpt) {
      unpuser = cpt->strarg;
    } else {
      unpuser = (char *)"clamav";
    }
  }
  tmp___10 = geteuid();
  if (! tmp___10) {
    user = getpwnam((char const   *)unpuser);
    if ((unsigned int )user == (unsigned int )((void *)0)) {
      mprintf("@Can\'t get information about user %s.\n", unpuser);
      exit(60);
    }
    tmp___7 = cfgopt((struct cfgstruct  const  *)copt, "AllowSupplementaryGroups");
    if (tmp___7) {
      tmp___5 = initgroups((char const   *)unpuser, user->pw_gid);
      if (tmp___5) {
        mprintf("@initgroups() failed.\n");
        exit(61);
      }
    } else {
      tmp___6 = setgroups(1U, (__gid_t const   *)(& user->pw_gid));
      if (tmp___6) {
        mprintf("@setgroups() failed.\n");
        exit(61);
      }
    }
    tmp___8 = setgid(user->pw_gid);
    if (tmp___8) {
      mprintf("@setgid(%d) failed.\n", (int )user->pw_gid);
      exit(61);
    }
    tmp___9 = setuid(user->pw_uid);
    if (tmp___9) {
      mprintf("@setuid(%d) failed.\n", (int )user->pw_uid);
      exit(61);
    }
  }
  tmp___11 = optl((struct optstruct  const  *)opt, "debug");
  if (tmp___11) {
    cl_debug();
  } else {
    tmp___12 = cfgopt((struct cfgstruct  const  *)copt, "Debug");
    if (tmp___12) {
      cl_debug();
    }
  }
  tmp___13 = optc((struct optstruct  const  *)opt, (char )'v');
  if (tmp___13) {
    mprintf_verbose = (short)1;
  }
  tmp___14 = optl((struct optstruct  const  *)opt, "quiet");
  if (tmp___14) {
    mprintf_quiet = (short)1;
  }
  tmp___15 = optl((struct optstruct  const  *)opt, "stdout");
  if (tmp___15) {
    mprintf_stdout = (short)1;
  }
  tmp___16 = optc((struct optstruct  const  *)opt, (char )'V');
  if (tmp___16) {
    print_version();
    exit(0);
  }
  tmp___17 = cfgopt((struct cfgstruct  const  *)copt, "LogVerbose");
  if (tmp___17) {
    logg_verbose = (short)1;
  }
  tmp___20 = optc((struct optstruct  const  *)opt, (char )'l');
  if (tmp___20) {
    logg_file = getargc((struct optstruct  const  *)opt, (char )'l');
    tmp___18 = logg("--------------------------------------\n");
    if (tmp___18) {
      mprintf("!Problem with internal logger.\n");
      exit(62);
    }
  } else {
    cpt = cfgopt((struct cfgstruct  const  *)copt, "UpdateLogFile");
    if (cpt) {
      logg_file = (char const   *)cpt->strarg;
      tmp___19 = logg("--------------------------------------\n");
      if (tmp___19) {
        mprintf("!Problem with internal logger.\n");
        exit(62);
      }
    } else {
      logg_file = (char const   *)((void *)0);
    }
  }
  tmp___21 = cfgopt((struct cfgstruct  const  *)copt, "LogSyslog");
  if (tmp___21) {
    fac = 176;
    cpt = cfgopt((struct cfgstruct  const  *)copt, "LogFacility");
    if (cpt) {
      fac = logg_facility((char const   *)cpt->strarg);
      if (fac == -1) {
        mprintf("!LogFacility: %s: No such facility.\n", cpt->strarg);
        exit(62);
      }
    }
    openlog("freshclam", 1, fac);
    logg_syslog = (short)1;
    syslog(6, "Daemon started.\n");
  }
  tmp___22 = optl((struct optstruct  const  *)opt, "datadir");
  if (tmp___22) {
    newdir = getargl((struct optstruct  const  *)opt, "datadir");
  } else {
    cpt = cfgopt((struct cfgstruct  const  *)copt, "DatabaseDirectory");
    if (cpt) {
      newdir = cpt->strarg;
    } else {
      newdir = (char *)"/usr/local/share/clamav";
    }
  }
  tmp___23 = chdir((char const   *)newdir);
  if (tmp___23) {
    mprintf("Can\'t change dir to %s\n", newdir);
    exit(50);
  } else {
    mprintf("*Current working dir is %s\n", newdir);
  }
  tmp___30 = optc((struct optstruct  const  *)opt, (char )'d');
  if (tmp___30) {
    memset((void *)(& sigact), 0, sizeof(struct sigaction ));
    sigact.__sigaction_handler.sa_handler = & daemon_sighandler;
    tmp___25 = optc((struct optstruct  const  *)opt, (char )'c');
    if (tmp___25) {
      tmp___24 = getargc((struct optstruct  const  *)opt, (char )'c');
      checks = atoi__extinline(tmp___24);
    } else {
      cpt = cfgopt((struct cfgstruct  const  *)copt, "Checks");
      if (cpt) {
        checks = cpt->numarg;
      } else {
        checks = 12;
      }
    }
    if (checks <= 0) {
      mprintf("@Number of checks must be a positive integer.\n");
      exit(41);
    }
    tmp___26 = cfgopt((struct cfgstruct  const  *)copt, "DNSDatabaseInfo");
    if (! tmp___26) {
      if (checks > 50) {
        mprintf("@Number of checks must be between 1 and 50.\n");
        exit(41);
      }
    }
    bigsleep = 86400 / checks;
    tmp___27 = cfgopt((struct cfgstruct  const  *)copt, "Foreground");
    if (! tmp___27) {
      daemonize();
    }
    tmp___28 = optc((struct optstruct  const  *)opt, (char )'p');
    if (tmp___28) {
      pidfile = getargc((struct optstruct  const  *)opt, (char )'p');
    } else {
      cpt = cfgopt((struct cfgstruct  const  *)copt, "PidFile");
      if (cpt) {
        pidfile = cpt->strarg;
      }
    }
    if (pidfile) {
      writepid(pidfile);
    }
    active_children = 0;
    logg("freshclam daemon 0.85.1 (OS: linux-gnu, ARCH: i386, CPU: i686)\n");
    sigaction(15, (struct sigaction  const  * __restrict  )(& sigact), (struct sigaction * __restrict  )((void *)0));
    sigaction(1, (struct sigaction  const  * __restrict  )(& sigact), (struct sigaction * __restrict  )((void *)0));
    sigaction(2, (struct sigaction  const  * __restrict  )(& sigact), (struct sigaction * __restrict  )((void *)0));
    sigaction(17, (struct sigaction  const  * __restrict  )(& sigact), (struct sigaction * __restrict  )((void *)0));
    while (! terminate) {
      ret = download((struct cfgstruct  const  *)copt, (struct optstruct  const  *)opt);
      if (ret > 1) {
        arg = (char const   *)((void *)0);
        tmp___29 = optl((struct optstruct  const  *)opt, "on-error-execute");
        if (tmp___29) {
          arg = getargl((struct optstruct  const  *)opt, "on-error-execute");
        } else {
          cpt = cfgopt((struct cfgstruct  const  *)copt, "OnErrorExecute");
          if (cpt) {
            arg = (char const   *)cpt->strarg;
          }
        }
        if (arg) {
          execute("OnErrorExecute", arg);
        }
      }
      logg("--------------------------------------\n");
      sigaction(14, (struct sigaction  const  * __restrict  )(& sigact), (struct sigaction * __restrict  )(& oldact));
      sigaction(10, (struct sigaction  const  * __restrict  )(& sigact), (struct sigaction * __restrict  )(& oldact));
      time(& wakeup);
      wakeup += (time_t )bigsleep;
      alarm((unsigned int )bigsleep);
      while (1) {
        pause();
        time(& now);
        if (! terminate) {
          if (! (now < wakeup)) {
            break;
          }
        } else {
          break;
        }
      }
      if ((int )terminate == -1) {
        logg("Received signal: wake up\n");
        terminate = (short)0;
      } else {
        if ((int )terminate == -2) {
          logg("Received signal: re-opening log file\n");
          terminate = (short)0;
          logg_close();
        }
      }
      sigaction(14, (struct sigaction  const  * __restrict  )(& oldact), (struct sigaction * __restrict  )((void *)0));
      sigaction(10, (struct sigaction  const  * __restrict  )(& oldact), (struct sigaction * __restrict  )((void *)0));
    }
  } else {
    ret = download((struct cfgstruct  const  *)copt, (struct optstruct  const  *)opt);
  }
  tmp___32 = optl((struct optstruct  const  *)opt, "on-error-execute");
  if (tmp___32) {
    if (ret > 1) {
      tmp___31 = getargl((struct optstruct  const  *)opt, "on-error-execute");
      system(tmp___31);
    }
  } else {
    cpt = cfgopt((struct cfgstruct  const  *)copt, "OnErrorExecute");
    if (cpt) {
      if (ret > 1) {
        system((char const   *)cpt->strarg);
      }
    }
  }
  if (pidfile) {
    unlink((char const   *)pidfile);
  }
  return (ret);
}
}
int download(struct cfgstruct  const  *copt , struct optstruct  const  *opt ) 
{ int ret ;
  int try ;
  int maxattempts ;
  struct cfgstruct *cpt ;

  {
  ret = 0;
  try = 0;
  maxattempts = 0;
  cpt = cfgopt(copt, "MaxAttempts");
  if (cpt) {
    maxattempts = cpt->numarg;
  } else {
    maxattempts = 3;
  }
  mprintf("*Max retries == %d\n", maxattempts);
  cpt = cfgopt(copt, "DatabaseMirror");
  if ((unsigned int )cpt == (unsigned int )((void *)0)) {
    mprintf("@You must specify at least one database mirror.\n");
    return (56);
  } else {
    while (cpt) {
      ret = downloadmanager(copt, opt, (char const   *)cpt->strarg);
      alarm(0U);
      if (ret == 52) {
        goto _L;
      } else {
        if (ret == 54) {
          goto _L;
        } else {
          if (ret == 58) {
            goto _L;
          } else {
            if (ret == 59) {
              _L: /* CIL Label */ 
              if (try < maxattempts - 1) {
                mprintf("Trying again in 5 secs...\n");
                logg("Trying again in 5 secs...\n");
                try ++;
                sleep(5U);
                continue;
              } else {
                mprintf("Giving up on %s...\n", cpt->strarg);
                logg("Giving up on %s...\n", cpt->strarg);
                cpt = cpt->nextarg;
                if (! cpt) {
                  mprintf("@Update failed. Your network may be down or none of the mirrors listed in freshclam.conf is working.\n");
                  logg("ERROR: Update failed. Your network may be down or none of the mirrors listed in freshclam.conf is working.\n");
                }
                try = 0;
              }
            } else {
              return (ret);
            }
          }
        }
      }
    }
  }
  return (ret);
}
}
void daemonize(void) 
{ int i ;
  __pid_t tmp ;

  {
  i = 0;
  while (i < 3) {
    close(i);
    i ++;
  }
  umask(0U);
  tmp = fork();
  if (tmp) {
    exit(0);
  }
  setsid();
  mprintf_disabled = (short)1;
  return;
}
}
void help(void) 
{ 

  {
  mprintf_stdout = (short)1;
  mprintf("\n");
  mprintf("                   Clam AntiVirus: freshclam  0.85.1\n");
  mprintf("    (C) 2002 - 2005 ClamAV Team - http://www.clamav.net/team.html\n\n");
  mprintf("    --help               -h              show help\n");
  mprintf("    --version            -V              print version number and exit\n");
  mprintf("    --verbose            -v              be verbose\n");
  mprintf("    --debug                              enable debug messages\n");
  mprintf("    --quiet                              only output error messages\n");
  mprintf("    --stdout                             write to stdout instead of stderr\n");
  mprintf("\n");
  mprintf("    --config-file=FILE                   read configuration from FILE.\n");
  mprintf("    --log=FILE           -l FILE         log into FILE\n");
  mprintf("    --daemon             -d              run in daemon mode\n");
  mprintf("    --foreground         -f              run daemon in foreground\n");
  mprintf("    --pid=FILE           -p FILE         save daemon\'s pid in FILE\n");
  mprintf("    --user=USER          -u USER         run as USER\n");
  mprintf("    --no-dns                             force old non-DNS verification method\n");
  mprintf("    --checks=#n          -c #n           number of checks per day, 1 <= n <= 50\n");
  mprintf("    --datadir=DIRECTORY                  download new databases into DIRECTORY\n");
  mprintf("    --daemon-notify[=/path/clamd.conf]   send RELOAD command to clamd\n");
  mprintf("    --local-address=IP   -a IP           bind to IP for HTTP downloads\n");
  mprintf("    --on-update-execute=COMMAND          execute COMMAND after successful update\n");
  mprintf("    --on-error-execute=COMMAND           execute COMMAND if errors occured\n");
  mprintf("\n");
  exit(0);
}
}
#pragma merger(0,"/tmp/cil-Q6UttwAE.i","-g -O2")
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
extern void *__rawmemchr(void const   *__s , int __c ) ;
extern char *optarg ;
extern int optind ;
extern int getopt_long(int __argc , char * const  *__argv , char const   *__shortopts ,
                       struct option  const  *__longopts , int *__longind ) ;
static void register_char_opt(struct optstruct *opt , char ch , struct option *longopts ) ;
static void register_long_opt(struct optstruct *opt , char const   *optname , struct option *longopts ) ;
int main(int argc , char **argv ) ;
static struct option long_options[22]  = 
  {      {"help", 0, (int *)0, 'h'}, 
        {"quiet", 0, (int *)0, 0}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"debug", 0, (int *)0, 0}, 
        {"version", 0, (int *)0, 'V'}, 
        {"datadir", 1, (int *)0, 0}, 
        {"log", 1, (int *)0, 'l'}, 
        {"log-verbose", 0, (int *)0, 0}, 
        {"stdout", 0, (int *)0, 0}, 
        {"daemon", 0, (int *)0, 'd'}, 
        {"pid", 1, (int *)0, 'p'}, 
        {"user", 1, (int *)0, 'u'}, 
        {"config-file", 1, (int *)0, 0}, 
        {"no-dns", 0, (int *)0, 0}, 
        {"checks", 1, (int *)0, 'c'}, 
        {"http-proxy", 1, (int *)0, 0}, 
        {"client-address", 1, (int *)0, 'a'}, 
        {"proxy-user", 1, (int *)0, 0}, 
        {"daemon-notify", 2, (int *)0, 0}, 
        {"on-update-execute", 1, (int *)0, 0}, 
        {"on-error-execute", 1, (int *)0, 0}, 
        {(char const   *)0, 0, (int *)0, 0}};
//extern int __builtin_strncat() ;
int main(int argc , char **argv ) 
{ int ret ;
  int opt_index ;
  int i ;
  int len ;
  struct optstruct *opt ;
  char const   *getopt_parameters ;
  char *tmp___4 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___10 ;

  {
  getopt_parameters = "hvdp:Vl:c:u:a:";
  opt = (struct optstruct *)mcalloc(1U, sizeof(struct optstruct ));
  opt->optlist = (struct optnode *)((void *)0);
  while (1) {
    opt_index = 0;
    ret = getopt_long(argc, (char * const  *)argv, getopt_parameters, (struct option  const  *)(long_options),
                      & opt_index);
    if (ret == -1) {
      break;
    }
    switch (ret) {
    case 0: 
    register_long_opt(opt, long_options[opt_index].name, long_options);
    break;
    default: 
    tmp___6 = __builtin_constant_p(ret);
    if (tmp___6) {
      tmp___7 = __builtin_constant_p((int )getopt_parameters);
      if (tmp___7) {
        tmp___4 = (char *)__builtin_strchr(getopt_parameters, ret);
      } else {
        if (ret == 0) {
          tmp___4 = (char *)__rawmemchr((void const   *)getopt_parameters, ret);
        } else {
          tmp___4 = (char *)__builtin_strchr(getopt_parameters, ret);
        }
      }
    } else {
      tmp___4 = (char *)__builtin_strchr(getopt_parameters, ret);
    }
    if (tmp___4) {
      register_char_opt(opt, (char )ret, long_options);
    } else {
      mprintf("!Unknown option passed.\n");
      free_opt(opt);
      exit(40);
    }
    }
  }
  if (optind < argc) {
    len = 0;
    i = optind;
    while (i < argc) {
      tmp___8 = strlen((char const   *)(*(argv + i)));
      len = (int )((size_t )len + tmp___8);
      i ++;
    }
    len = ((len + argc) - optind) - 1;
    opt->filename = (char *)mcalloc((unsigned int )(len + 256), sizeof(char ));
    i = optind;
    while (i < argc) {
      tmp___10 = strlen((char const   *)(*(argv + i)));
      __builtin_strncat(opt->filename, (*(argv + i)), tmp___10);
      if (i != argc - 1) {
        __builtin_strncat(opt->filename, " ", 1);
      }
      i ++;
    }
  }
  ret = freshclam(opt);
  free_opt(opt);
  return (ret);
}
}
static struct option *find_char_opt(char optchar , struct option *longopts ) 
{ int i ;

  {
  i = 0;
  while ((longopts + i)->name) {
    if ((int )((char )(longopts + i)->val) == (int )optchar) {
      return (longopts + i);
    }
    i ++;
  }
  return ((struct option *)((void *)0));
}
}
static void register_char_opt(struct optstruct *opt , char ch , struct option *longopts ) 
{ struct optnode *newnode ;
  struct option *longopt ;
  struct option *tmp ;
  size_t tmp___1 ;
  size_t __len___2 ;
  size_t tmp___19 ;
  char *__retval___2 ;
  char *tmp___20 ;
  int tmp___22 ;

  {
  tmp = find_char_opt(ch, longopts);
  longopt = tmp;
  newnode = (struct optnode *)mmalloc(sizeof(struct optnode ));
  newnode->optchar = ch;
  if ((unsigned int )optarg != (unsigned int )((void *)0)) {
    tmp___1 = strlen((char const   *)optarg);
    newnode->optarg = (char *)mcalloc(tmp___1 + 1U, sizeof(char ));
    strcpy((char * __restrict  )newnode->optarg, (char const   * __restrict  )optarg);
  } else {
    newnode->optarg = (char *)((void *)0);
  }
  if (longopt) {
    tmp___22 = __builtin_constant_p((int )longopt->name);
    if (tmp___22) {
      if ((unsigned int )((void const   *)(longopt->name + 1)) - (unsigned int )((void const   *)longopt->name) ==
          1U) {
        if ((int const   )(*(longopt->name + 0)) == 0) {
          newnode->optname = (char *)calloc(1U, 1U);
        } else {
          tmp___19 = strlen(longopt->name);
          __len___2 = tmp___19 + 1U;
          tmp___20 = (char *)malloc(__len___2);
          __retval___2 = tmp___20;
          if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
            __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )longopt->name,
                                          __len___2);
          }
          newnode->optname = __retval___2;
        }
      } else {
        newnode->optname = __strdup(longopt->name);
      }
    } else {
      newnode->optname = __strdup(longopt->name);
    }
  } else {
    newnode->optname = (char *)((void *)0);
  }
  newnode->next = opt->optlist;
  opt->optlist = newnode;
  return;
}
}
static struct option *find_long_opt(char const   *optname , struct option *longopts ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___53 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;

  {
  i = 0;
  while ((longopts + i)->name) {
    tmp___65 = __builtin_constant_p((int )(longopts + i)->name);
    if (tmp___65) {
      tmp___66 = __builtin_constant_p((int )optname);
      if (tmp___66) {
        __s1_len = strlen((longopts + i)->name);
        __s2_len = strlen(optname);
        if (! ((unsigned int )((void const   *)((longopts + i)->name + 1)) - (unsigned int )((void const   *)(longopts +
                                                                                                              i)->name) ==
               1U)) {
          goto _L___16;
        } else {
          if (__s1_len >= 4U) {
            _L___16: /* CIL Label */ 
            if (! ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                   1U)) {
              tmp___67 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___67 = 1;
              } else {
                tmp___67 = 0;
              }
            }
          } else {
            tmp___67 = 0;
          }
        }
        if (tmp___67) {
          tmp___34 = __builtin_strcmp((longopts + i)->name, optname);
        } else {
          goto _L___18;
        }
      } else {
        goto _L___18;
      }
    } else {
      _L___18: /* CIL Label */ 
      tmp___64 = __builtin_constant_p((int )(longopts + i)->name);
      if (tmp___64) {
        if ((unsigned int )((void const   *)((longopts + i)->name + 1)) - (unsigned int )((void const   *)(longopts +
                                                                                                           i)->name) ==
            1U) {
          __s1_len = strlen((longopts + i)->name);
          if (__s1_len < 4U) {
            tmp___53 = __builtin_constant_p((int )optname);
            if (tmp___53) {
              if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                  1U) {
                tmp___34 = __builtin_strcmp((longopts + i)->name, optname);
              } else {
                goto _L___11;
              }
            } else {
              _L___11: /* CIL Label */ 
              __s2___6 = (unsigned char const   *)optname;
              __result___18 = (int )((int const   )(*((unsigned char const   *)(longopts +
                                                                                i)->name +
                                                      0)) - (int const   )(*(__s2___6 +
                                                                             0)));
              if (__s1_len > 0U) {
                if (__result___18 == 0) {
                  __result___18 = (int )((int const   )(*((unsigned char const   *)(longopts +
                                                                                    i)->name +
                                                          1)) - (int const   )(*(__s2___6 +
                                                                                 1)));
                  if (__s1_len > 1U) {
                    if (__result___18 == 0) {
                      __result___18 = (int )((int const   )(*((unsigned char const   *)(longopts +
                                                                                        i)->name +
                                                              2)) - (int const   )(*(__s2___6 +
                                                                                     2)));
                      if (__s1_len > 2U) {
                        if (__result___18 == 0) {
                          __result___18 = (int )((int const   )(*((unsigned char const   *)(longopts +
                                                                                            i)->name +
                                                                  3)) - (int const   )(*(__s2___6 +
                                                                                         3)));
                        }
                      }
                    }
                  }
                }
              }
              tmp___34 = __result___18;
            }
          } else {
            goto _L___15;
          }
        } else {
          goto _L___15;
        }
      } else {
        _L___15: /* CIL Label */ 
        tmp___63 = __builtin_constant_p((int )optname);
        if (tmp___63) {
          if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
              1U) {
            __s2_len = strlen(optname);
            if (__s2_len < 4U) {
              tmp___62 = __builtin_constant_p((int )(longopts + i)->name);
              if (tmp___62) {
                if ((unsigned int )((void const   *)((longopts + i)->name + 1)) -
                    (unsigned int )((void const   *)(longopts + i)->name) == 1U) {
                  tmp___34 = __builtin_strcmp((longopts + i)->name, optname);
                } else {
                  goto _L___13;
                }
              } else {
                _L___13: /* CIL Label */ 
                __s1___14 = (unsigned char const   *)(longopts + i)->name;
                __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)optname +
                                                                                           0)));
                if (__s2_len > 0U) {
                  if (__result___22 == 0) {
                    __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)optname +
                                                                                               1)));
                    if (__s2_len > 1U) {
                      if (__result___22 == 0) {
                        __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                               (int const   )(*((unsigned char const   *)optname +
                                                                2)));
                        if (__s2_len > 2U) {
                          if (__result___22 == 0) {
                            __result___22 = (int )((int const   )(*(__s1___14 + 3)) -
                                                   (int const   )(*((unsigned char const   *)optname +
                                                                    3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___34 = __result___22;
              }
            } else {
              tmp___34 = __builtin_strcmp((longopts + i)->name, optname);
            }
          } else {
            tmp___34 = __builtin_strcmp((longopts + i)->name, optname);
          }
        } else {
          tmp___34 = __builtin_strcmp((longopts + i)->name, optname);
        }
      }
    }
    if (tmp___34 == 0) {
      return (longopts + i);
    }
    i ++;
  }
  return ((struct option *)((void *)0));
}
}
static void register_long_opt(struct optstruct *opt , char const   *optname , struct option *longopts ) 
{ struct optnode *newnode ;
  struct option *longopt ;
  struct option *tmp ;
  size_t tmp___1 ;
  size_t tmp___3 ;

  {
  tmp = find_long_opt(optname, longopts);
  longopt = tmp;
  newnode = (struct optnode *)mmalloc(sizeof(struct optnode ));
  if (longopt) {
    newnode->optchar = (char )longopt->val;
  } else {
    newnode->optchar = (char)0;
  }
  if ((unsigned int )optarg != (unsigned int )((void *)0)) {
    tmp___1 = strlen((char const   *)optarg);
    newnode->optarg = (char *)mcalloc(tmp___1 + 1U, sizeof(char ));
    strcpy((char * __restrict  )newnode->optarg, (char const   * __restrict  )optarg);
  } else {
    newnode->optarg = (char *)((void *)0);
  }
  tmp___3 = strlen(optname);
  newnode->optname = (char *)mcalloc(tmp___3 + 1U, sizeof(char ));
  strcpy((char * __restrict  )newnode->optname, (char const   * __restrict  )optname);
  newnode->next = opt->optlist;
  opt->optlist = newnode;
  return;
}
}
int optc(struct optstruct  const  *opt , char ch ) 
{ struct optnode *handler ;

  {
  handler = opt->optlist;
  while (1) {
    if (handler) {
      if ((int )handler->optchar == (int )ch) {
        return (1);
      }
    } else {
      break;
    }
    handler = handler->next;
  }
  return (0);
}
}
int optl(struct optstruct  const  *opt , char const   *optname ) 
{ struct optnode *handler ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___53 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;

  {
  handler = opt->optlist;
  while (1) {
    if (handler) {
      if (handler->optname) {
        tmp___65 = __builtin_constant_p((int )handler->optname);
        if (tmp___65) {
          tmp___66 = __builtin_constant_p((int )optname);
          if (tmp___66) {
            __s1_len = strlen((char const   *)handler->optname);
            __s2_len = strlen(optname);
            if (! ((unsigned int )((void const   *)(handler->optname + 1)) - (unsigned int )((void const   *)handler->optname) ==
                   1U)) {
              goto _L___16;
            } else {
              if (__s1_len >= 4U) {
                _L___16: /* CIL Label */ 
                if (! ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                       1U)) {
                  tmp___67 = 1;
                } else {
                  if (__s2_len >= 4U) {
                    tmp___67 = 1;
                  } else {
                    tmp___67 = 0;
                  }
                }
              } else {
                tmp___67 = 0;
              }
            }
            if (tmp___67) {
              tmp___34 = __builtin_strcmp(handler->optname, optname);
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: /* CIL Label */ 
          tmp___64 = __builtin_constant_p((int )handler->optname);
          if (tmp___64) {
            if ((unsigned int )((void const   *)(handler->optname + 1)) - (unsigned int )((void const   *)handler->optname) ==
                1U) {
              __s1_len = strlen((char const   *)handler->optname);
              if (__s1_len < 4U) {
                tmp___53 = __builtin_constant_p((int )optname);
                if (tmp___53) {
                  if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                      1U) {
                    tmp___34 = __builtin_strcmp(handler->optname, optname);
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: /* CIL Label */ 
                  __s2___6 = (unsigned char const   *)optname;
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
                  if (__s1_len > 0U) {
                    if (__result___18 == 0) {
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
                      if (__s1_len > 1U) {
                        if (__result___18 == 0) {
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
                          if (__s1_len > 2U) {
                            if (__result___18 == 0) {
                              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___34 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: /* CIL Label */ 
            tmp___63 = __builtin_constant_p((int )optname);
            if (tmp___63) {
              if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                  1U) {
                __s2_len = strlen(optname);
                if (__s2_len < 4U) {
                  tmp___62 = __builtin_constant_p((int )handler->optname);
                  if (tmp___62) {
                    if ((unsigned int )((void const   *)(handler->optname + 1)) -
                        (unsigned int )((void const   *)handler->optname) == 1U) {
                      tmp___34 = __builtin_strcmp(handler->optname, optname);
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: /* CIL Label */ 
                    __s1___14 = (unsigned char const   *)((char const   *)handler->optname);
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)optname +
                                                                                               0)));
                    if (__s2_len > 0U) {
                      if (__result___22 == 0) {
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)optname +
                                                                1)));
                        if (__s2_len > 1U) {
                          if (__result___22 == 0) {
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)optname +
                                                                    2)));
                            if (__s2_len > 2U) {
                              if (__result___22 == 0) {
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)optname +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___34 = __result___22;
                  }
                } else {
                  tmp___34 = __builtin_strcmp(handler->optname, optname);
                }
              } else {
                tmp___34 = __builtin_strcmp(handler->optname, optname);
              }
            } else {
              tmp___34 = __builtin_strcmp(handler->optname, optname);
            }
          }
        }
        if (! tmp___34) {
          return (1);
        }
      }
    } else {
      break;
    }
    handler = handler->next;
  }
  return (0);
}
}
char *getargc(struct optstruct  const  *opt , char ch ) 
{ struct optnode *handler ;

  {
  handler = opt->optlist;
  while (1) {
    if (handler) {
      if ((int )handler->optchar == (int )ch) {
        return (handler->optarg);
      }
    } else {
      break;
    }
    handler = handler->next;
  }
  return ((char *)((void *)0));
}
}
char *getargl(struct optstruct  const  *opt , char const   *optname ) 
{ struct optnode *handler ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___53 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;

  {
  handler = opt->optlist;
  while (1) {
    if (handler) {
      if (handler->optname) {
        tmp___65 = __builtin_constant_p((int )handler->optname);
        if (tmp___65) {
          tmp___66 = __builtin_constant_p((int )optname);
          if (tmp___66) {
            __s1_len = strlen((char const   *)handler->optname);
            __s2_len = strlen(optname);
            if (! ((unsigned int )((void const   *)(handler->optname + 1)) - (unsigned int )((void const   *)handler->optname) ==
                   1U)) {
              goto _L___16;
            } else {
              if (__s1_len >= 4U) {
                _L___16: /* CIL Label */ 
                if (! ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                       1U)) {
                  tmp___67 = 1;
                } else {
                  if (__s2_len >= 4U) {
                    tmp___67 = 1;
                  } else {
                    tmp___67 = 0;
                  }
                }
              } else {
                tmp___67 = 0;
              }
            }
            if (tmp___67) {
              tmp___34 = __builtin_strcmp(handler->optname, optname);
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: /* CIL Label */ 
          tmp___64 = __builtin_constant_p((int )handler->optname);
          if (tmp___64) {
            if ((unsigned int )((void const   *)(handler->optname + 1)) - (unsigned int )((void const   *)handler->optname) ==
                1U) {
              __s1_len = strlen((char const   *)handler->optname);
              if (__s1_len < 4U) {
                tmp___53 = __builtin_constant_p((int )optname);
                if (tmp___53) {
                  if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                      1U) {
                    tmp___34 = __builtin_strcmp(handler->optname, optname);
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: /* CIL Label */ 
                  __s2___6 = (unsigned char const   *)optname;
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
                  if (__s1_len > 0U) {
                    if (__result___18 == 0) {
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
                      if (__s1_len > 1U) {
                        if (__result___18 == 0) {
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
                          if (__s1_len > 2U) {
                            if (__result___18 == 0) {
                              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___34 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: /* CIL Label */ 
            tmp___63 = __builtin_constant_p((int )optname);
            if (tmp___63) {
              if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                  1U) {
                __s2_len = strlen(optname);
                if (__s2_len < 4U) {
                  tmp___62 = __builtin_constant_p((int )handler->optname);
                  if (tmp___62) {
                    if ((unsigned int )((void const   *)(handler->optname + 1)) -
                        (unsigned int )((void const   *)handler->optname) == 1U) {
                      tmp___34 = __builtin_strcmp(handler->optname, optname);
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: /* CIL Label */ 
                    __s1___14 = (unsigned char const   *)((char const   *)handler->optname);
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)optname +
                                                                                               0)));
                    if (__s2_len > 0U) {
                      if (__result___22 == 0) {
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)optname +
                                                                1)));
                        if (__s2_len > 1U) {
                          if (__result___22 == 0) {
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)optname +
                                                                    2)));
                            if (__s2_len > 2U) {
                              if (__result___22 == 0) {
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)optname +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___34 = __result___22;
                  }
                } else {
                  tmp___34 = __builtin_strcmp(handler->optname, optname);
                }
              } else {
                tmp___34 = __builtin_strcmp(handler->optname, optname);
              }
            } else {
              tmp___34 = __builtin_strcmp(handler->optname, optname);
            }
          }
        }
        if (! tmp___34) {
          return (handler->optarg);
        }
      }
    } else {
      break;
    }
    handler = handler->next;
  }
  return ((char *)((void *)0));
}
}
void free_opt(struct optstruct *opt ) 
{ struct optnode *handler ;
  struct optnode *prev ;

  {
  if (! opt) {
    return;
  }
  mprintf("*Freeing option list...");
  handler = opt->optlist;
  while ((unsigned int )handler != (unsigned int )((void *)0)) {
    handler->optchar = (char)0;
    if (handler->optarg) {
      free((void *)handler->optarg);
    }
    if (handler->optname) {
      free((void *)handler->optname);
    }
    prev = handler;
    handler = handler->next;
    free((void *)prev);
  }
  if (opt->filename) {
    free((void *)opt->filename);
  }
  free((void *)opt);
  mprintf("*done\n");
  return;
}
}
#pragma merger(0,"/tmp/cil-awSdciXU.i","-g -O2")
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
extern  __attribute__((__nothrow__)) int *__h_errno_location(void)  __attribute__((__const__)) ;
extern struct hostent *gethostbyname(char const   *__name ) ;
extern void endservent(void) ;
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t const   *__timer ) ;
int cl_retflevel(void) ;
char const   *cl_retver(void) ;
struct cl_cvd *cl_cvdparse(char const   *head ) ;
int cl_cvdverify(char const   *file ) ;
char const   *cl_strerror(int clerror ) ;
int downloaddb(char const   *localname , char const   *remotename , char const   *hostname ,
               char *ip , int *signo , struct cfgstruct  const  *copt , char const   *dnsreply ,
               char *localip ) ;
int wwwconnect(char const   *server , char const   *proxy , int pport , char *ip ,
               char *localip ) ;
struct cl_cvd *remote_cvdhead(char const   *file , int socketfd , char const   *hostname ,
                              char const   *proxy , char const   *user , char const   *pass ,
                              int *ims ) ;
int get_database(char const   *dbfile , int socketfd , char const   *file , char const   *hostname ,
                 char const   *proxy , char const   *user , char const   *pass ) ;
unsigned int fmt_base64(char *dest , char const   *src , unsigned int len ) ;
int notify(char const   *cfgfile ) ;
char *cli_gentemp(char const   *dir ) ;
char *txtquery(char const   *domain , unsigned int *ttl ) ;
int downloadmanager(struct cfgstruct  const  *copt , struct optstruct  const  *opt ,
                    char const   *hostname ) 
{ time_t currtime ;
  int ret ;
  int updated ;
  int signo ;
  int ttl ;
  char ipaddr[16] ;
  char *dnsreply ;
  char *pt ;
  struct cfgstruct *cpt ;
  char *localip ;
  char const   *arg ;
  char const   *dnsdbinfo ;
  char *tmp ;
  char *tmp___0 ;
  int rt ;
  time_t ct ;
  int vwarning ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___115 ;
  char const   *tmp___116 ;
  char const   *tmp___176 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  char const   *tmp___177 ;
  char const   *tmp___178 ;
  char const   *tmp___179 ;
  char const   *tmp___180 ;
  int tmp___181 ;
  char const   *tmp___206 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___208 ;
  int tmp___209 ;
  char const   *tmp___210 ;
  char const   *tmp___211 ;
  char const   *tmp___212 ;
  int tmp___213 ;
  int tmp___214 ;
  int tmp___215 ;
  char const   *tmp___216 ;
  char const   *tmp___217 ;
  char const   *tmp___218 ;
  int tmp___219 ;
  int tmp___220 ;
  int tmp___221 ;
  char const   *tmp___222 ;
  char const   *tmp___223 ;
  char const   *tmp___224 ;
  int tmp___225 ;
  char const   *tmp___226 ;
  char *tmp___227 ;
  char const   *tmp___228 ;
  char *tmp___229 ;
  int tmp___230 ;
  int tmp___231 ;
  struct cfgstruct *tmp___232 ;
  char const   *clamav_conf ;
  char const   *tmp___233 ;
  char const   *clamav_conf___0 ;
  int tmp___234 ;
  int tmp___235 ;
  int tmp___236 ;

  {
  updated = 0;
  signo = 0;
  ttl = -1;
  dnsreply = (char *)((void *)0);
  localip = (char *)((void *)0);
  arg = (char const   *)((void *)0);
  time(& currtime);
  tmp = ctime((time_t const   *)(& currtime));
  mprintf("ClamAV update process started at %s", tmp);
  tmp___0 = ctime((time_t const   *)(& currtime));
  logg("ClamAV update process started at %s", tmp___0);
  mprintf("SECURITY WARNING: NO SUPPORT FOR DIGITAL SIGNATURES\n");
  mprintf("See the FAQ at http://www.clamav.net/faq.html for an explanation.\n");
  logg("SECURITY WARNING: NO SUPPORT FOR DIGITAL SIGNATURES\n");
  logg("See the FAQ at http://www.clamav.net/faq.html for an explanation.\n");
  cpt = cfgopt(copt, "DNSDatabaseInfo");
  if (cpt) {
    dnsdbinfo = (char const   *)cpt->strarg;
  } else {
    dnsdbinfo = "current.cvd.clamav.net";
  }
  tmp___230 = optl(opt, "no-dns");
  if (tmp___230) {
    dnsreply = (char *)((void *)0);
  } else {
    dnsreply = txtquery(dnsdbinfo, (unsigned int *)(& ttl));
    if (dnsreply) {
      mprintf("*TTL: %d\n", ttl);
      pt = cli_strtok((char const   *)dnsreply, 3, ":");
      if (pt) {
        rt = atoi__extinline((char const   *)pt);
        free((void *)pt);
        time(& ct);
        if ((int )ct - rt > 10800) {
          mprintf("WARNING: DNS record is older than 3 hours.\n");
          logg("WARNING: DNS record is older than 3 hours.\n");
          free((void *)dnsreply);
          dnsreply = (char *)((void *)0);
        }
      } else {
        free((void *)dnsreply);
        dnsreply = (char *)((void *)0);
      }
      if (dnsreply) {
        vwarning = 1;
        pt = cli_strtok((char const   *)dnsreply, 4, ":");
        if (pt) {
          if ((int )(*pt) == 48) {
            vwarning = 0;
          }
          free((void *)pt);
        }
        pt = cli_strtok((char const   *)dnsreply, 0, ":");
        if (pt) {
          mprintf("*Software version from DNS: %s\n", pt);
          if (vwarning) {
            tmp___226 = cl_retver();
            tmp___227 = strstr(tmp___226, "devel");
            if (! tmp___227) {
              tmp___228 = cl_retver();
              tmp___229 = strstr(tmp___228, "rc");
              if (! tmp___229) {
                tmp___219 = (int )cl_retver();
                tmp___220 = __builtin_constant_p(tmp___219);
                if (tmp___220) {
                  tmp___221 = __builtin_constant_p((int )pt);
                  if (tmp___221) {
                    tmp___222 = cl_retver();
                    __s1_len = strlen(tmp___222);
                    __s2_len = strlen((char const   *)pt);
                    tmp___223 = cl_retver();
                    tmp___224 = cl_retver();
                    if ((unsigned int )((void const   *)(tmp___223 + 1)) - (unsigned int )((void const   *)tmp___224) ==
                        1U) {
                      if (__s1_len >= 4U) {
                        _L___16: /* CIL Label */ 
                        if (! ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                               1U)) {
                          tmp___225 = 1;
                        } else {
                          if (__s2_len >= 4U) {
                            tmp___225 = 1;
                          } else {
                            tmp___225 = 0;
                          }
                        }
                      } else {
                        tmp___225 = 0;
                      }
                    } else {
                      goto _L___16;
                    }
                    if (tmp___225) {
                      tmp___116 = cl_retver();
                      tmp___115 = __builtin_strcmp(tmp___116, pt);
                    } else {
                      goto _L___18;
                    }
                  } else {
                    goto _L___18;
                  }
                } else {
                  _L___18: /* CIL Label */ 
                  tmp___214 = (int )cl_retver();
                  tmp___215 = __builtin_constant_p(tmp___214);
                  if (tmp___215) {
                    tmp___216 = cl_retver();
                    tmp___217 = cl_retver();
                    if ((unsigned int )((void const   *)(tmp___216 + 1)) - (unsigned int )((void const   *)tmp___217) ==
                        1U) {
                      tmp___218 = cl_retver();
                      __s1_len = strlen(tmp___218);
                      if (__s1_len < 4U) {
                        tmp___181 = __builtin_constant_p((int )pt);
                        if (tmp___181) {
                          if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                              1U) {
                            tmp___176 = cl_retver();
                            tmp___115 = __builtin_strcmp(tmp___176, pt);
                          } else {
                            goto _L___11;
                          }
                        } else {
                          _L___11: /* CIL Label */ 
                          __s2___6 = (unsigned char const   *)((char const   *)pt);
                          tmp___177 = cl_retver();
                          __result___18 = (int )((int const   )(*((unsigned char const   *)tmp___177 +
                                                                  0)) - (int const   )(*(__s2___6 +
                                                                                         0)));
                          if (__s1_len > 0U) {
                            if (__result___18 == 0) {
                              tmp___178 = cl_retver();
                              __result___18 = (int )((int const   )(*((unsigned char const   *)tmp___178 +
                                                                      1)) - (int const   )(*(__s2___6 +
                                                                                             1)));
                              if (__s1_len > 1U) {
                                if (__result___18 == 0) {
                                  tmp___179 = cl_retver();
                                  __result___18 = (int )((int const   )(*((unsigned char const   *)tmp___179 +
                                                                          2)) - (int const   )(*(__s2___6 +
                                                                                                 2)));
                                  if (__s1_len > 2U) {
                                    if (__result___18 == 0) {
                                      tmp___180 = cl_retver();
                                      __result___18 = (int )((int const   )(*((unsigned char const   *)tmp___180 +
                                                                              3)) -
                                                             (int const   )(*(__s2___6 +
                                                                              3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
                          tmp___115 = __result___18;
                        }
                      } else {
                        goto _L___15;
                      }
                    } else {
                      goto _L___15;
                    }
                  } else {
                    _L___15: /* CIL Label */ 
                    tmp___213 = __builtin_constant_p((int )pt);
                    if (tmp___213) {
                      if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                          1U) {
                        __s2_len = strlen((char const   *)pt);
                        if (__s2_len < 4U) {
                          tmp___208 = (int )cl_retver();
                          tmp___209 = __builtin_constant_p(tmp___208);
                          if (tmp___209) {
                            tmp___210 = cl_retver();
                            tmp___211 = cl_retver();
                            if ((unsigned int )((void const   *)(tmp___210 + 1)) -
                                (unsigned int )((void const   *)tmp___211) == 1U) {
                              tmp___206 = cl_retver();
                              tmp___115 = __builtin_strcmp(tmp___206, pt);
                            } else {
                              goto _L___13;
                            }
                          } else {
                            _L___13: /* CIL Label */ 
                            __s1___14 = (unsigned char const   *)cl_retver();
                            __result___22 = (int )((int const   )(*(__s1___14 + 0)) -
                                                   (int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                    0)));
                            if (__s2_len > 0U) {
                              if (__result___22 == 0) {
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        1)) - (int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                                               1)));
                                if (__s2_len > 1U) {
                                  if (__result___22 == 0) {
                                    __result___22 = (int )((int const   )(*(__s1___14 +
                                                                            2)) -
                                                           (int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                            2)));
                                    if (__s2_len > 2U) {
                                      if (__result___22 == 0) {
                                        __result___22 = (int )((int const   )(*(__s1___14 +
                                                                                3)) -
                                                               (int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                                3)));
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            tmp___115 = __result___22;
                          }
                        } else {
                          tmp___212 = cl_retver();
                          tmp___115 = __builtin_strcmp(tmp___212, pt);
                        }
                      } else {
                        tmp___212 = cl_retver();
                        tmp___115 = __builtin_strcmp(tmp___212, pt);
                      }
                    } else {
                      tmp___212 = cl_retver();
                      tmp___115 = __builtin_strcmp(tmp___212, pt);
                    }
                  }
                }
                if (tmp___115) {
                  mprintf("WARNING: Your ClamAV installation is OUTDATED!\n");
                  tmp___1 = cl_retver();
                  mprintf("WARNING: Local version: %s Recommended version: %s\n",
                          tmp___1, pt);
                  mprintf("DON\'T PANIC! Read http://www.clamav.net/faq.html\n");
                  logg("WARNING: Your ClamAV installation is OUTDATED!\n");
                  tmp___2 = cl_retver();
                  logg("WARNING: Local version: %s Recommended version: %s\n", tmp___2,
                       pt);
                  logg("DON\'T PANIC! Read http://www.clamav.net/faq.html\n");
                }
              }
            }
          }
          free((void *)pt);
        }
      } else {
        if (dnsreply) {
          free((void *)dnsreply);
          dnsreply = (char *)((void *)0);
        }
      }
    }
    if (! dnsreply) {
      mprintf("WARNING: Invalid DNS reply. Falling back to HTTP mode.\n");
      logg("WARNING: Invalid DNS reply. Falling back to HTTP mode.\n");
    }
  }
  tmp___231 = optl(opt, "localip");
  if (tmp___231) {
    localip = getargl(opt, "localip");
  } else {
    cpt = cfgopt(copt, "LocalIPAddress");
    if (cpt) {
      localip = cpt->strarg;
    }
  }
  memset((void *)(ipaddr), 0, sizeof(ipaddr));
  ret = downloaddb("main.cvd", "main.cvd", hostname, ipaddr, & signo, copt, (char const   *)dnsreply,
                   localip);
  if (ret > 50) {
    if (dnsreply) {
      free((void *)dnsreply);
    }
    return (ret);
  } else {
    if (ret == 0) {
      updated = 1;
    }
  }
  ret = downloaddb("daily.cvd", "daily.cvd", hostname, ipaddr, & signo, copt, (char const   *)dnsreply,
                   localip);
  if (ret > 50) {
    if (dnsreply) {
      free((void *)dnsreply);
    }
    return (ret);
  } else {
    if (ret == 0) {
      updated = 1;
    }
  }
  if (dnsreply) {
    free((void *)dnsreply);
  }
  if (updated) {
    tmp___232 = cfgopt(copt, "HTTPProxyServer");
    if (tmp___232) {
      mprintf("Database updated (%d signatures) from %s\n", signo, hostname);
      logg("Database updated (%d signatures) from %s\n", signo, hostname);
    } else {
      mprintf("Database updated (%d signatures) from %s (IP: %s)\n", signo, hostname,
              ipaddr);
      logg("Database updated (%d signatures) from %s (IP: %s)\n", signo, hostname,
           ipaddr);
    }
    tmp___234 = optl(opt, "daemon-notify");
    if (tmp___234) {
      tmp___233 = getargl(opt, "daemon-notify");
      clamav_conf = tmp___233;
      if (! clamav_conf) {
        clamav_conf = "/usr/local/etc/clamd.conf";
      }
      notify(clamav_conf);
    } else {
      cpt = cfgopt(copt, "NotifyClamd");
      if (cpt) {
        clamav_conf___0 = (char const   *)cpt->strarg;
        if (! clamav_conf___0) {
          clamav_conf___0 = "/usr/local/etc/clamd.conf";
        }
        notify(clamav_conf___0);
      }
    }
    tmp___235 = optl(opt, "on-update-execute");
    if (tmp___235) {
      arg = getargl(opt, "on-update-execute");
    } else {
      cpt = cfgopt(copt, "OnUpdateExecute");
      if (cpt) {
        arg = (char const   *)cpt->strarg;
      }
    }
    if (arg) {
      tmp___236 = optc(opt, (char )'d');
      if (tmp___236) {
        execute("OnUpdateExecute", arg);
      } else {
        system(arg);
      }
    }
    return (0);
  } else {
    return (1);
  }
}
}
int downloaddb(char const   *localname , char const   *remotename , char const   *hostname ,
               char *ip , int *signo , struct cfgstruct  const  *copt , char const   *dnsreply ,
               char *localip ) 
{ struct cl_cvd *current ;
  struct cl_cvd *remote ;
  struct cfgstruct *cpt ;
  int hostfd ;
  int nodb ;
  int dbver ;
  int ret ;
  int port ;
  int ims ;
  char *tempname ;
  char ipaddr[16] ;
  char *pt ;
  char const   *proxy ;
  char const   *user ;
  char const   *pass ;
  int flevel ;
  int tmp ;
  int field ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___35 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___54 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___104 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___123 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___132 ;
  int tmp___133 ;
  int tmp___134 ;
  int tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  char const   *tmp___140 ;
  int *tmp___141 ;
  char *tmp___142 ;
  int *tmp___143 ;
  char *tmp___144 ;
  int tmp___145 ;
  int *tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;

  {
  nodb = 0;
  dbver = -1;
  port = 0;
  ims = -1;
  proxy = (char const   *)((void *)0);
  user = (char const   *)((void *)0);
  pass = (char const   *)((void *)0);
  tmp = cl_retflevel();
  flevel = tmp;
  current = cl_cvdhead(localname);
  if ((unsigned int )current == (unsigned int )((void *)0)) {
    nodb = 1;
  }
  if (! nodb) {
    if (dnsreply) {
      field = 0;
      tmp___135 = __builtin_constant_p((int )remotename);
      if (tmp___135) {
        tmp___136 = __builtin_constant_p((int )"main.cvd");
        if (tmp___136) {
          __s1_len___0 = strlen(remotename);
          __s2_len___0 = strlen("main.cvd");
          if (! ((unsigned int )((void const   *)(remotename + 1)) - (unsigned int )((void const   *)remotename) ==
                 1U)) {
            goto _L___36;
          } else {
            if (__s1_len___0 >= 4U) {
              _L___36: /* CIL Label */ 
              if (! ((unsigned int )((void const   *)("main.cvd" + 1)) - (unsigned int )((void const   *)"main.cvd") ==
                     1U)) {
                tmp___137 = 1;
              } else {
                if (__s2_len___0 >= 4U) {
                  tmp___137 = 1;
                } else {
                  tmp___137 = 0;
                }
              }
            } else {
              tmp___137 = 0;
            }
          }
          if (tmp___137) {
            tmp___104 = __builtin_strcmp(remotename, "main.cvd");
          } else {
            goto _L___38;
          }
        } else {
          goto _L___38;
        }
      } else {
        _L___38: /* CIL Label */ 
        tmp___134 = __builtin_constant_p((int )remotename);
        if (tmp___134) {
          if ((unsigned int )((void const   *)(remotename + 1)) - (unsigned int )((void const   *)remotename) ==
              1U) {
            __s1_len___0 = strlen(remotename);
            if (__s1_len___0 < 4U) {
              tmp___123 = __builtin_constant_p((int )"main.cvd");
              if (tmp___123) {
                if ((unsigned int )((void const   *)("main.cvd" + 1)) - (unsigned int )((void const   *)"main.cvd") ==
                    1U) {
                  tmp___104 = __builtin_strcmp(remotename, "main.cvd");
                } else {
                  goto _L___31;
                }
              } else {
                _L___31: /* CIL Label */ 
                __s2___14 = (unsigned char const   *)"main.cvd";
                __result___42 = (int )((int const   )(*((unsigned char const   *)remotename +
                                                        0)) - (int const   )(*(__s2___14 +
                                                                               0)));
                if (__s1_len___0 > 0U) {
                  if (__result___42 == 0) {
                    __result___42 = (int )((int const   )(*((unsigned char const   *)remotename +
                                                            1)) - (int const   )(*(__s2___14 +
                                                                                   1)));
                    if (__s1_len___0 > 1U) {
                      if (__result___42 == 0) {
                        __result___42 = (int )((int const   )(*((unsigned char const   *)remotename +
                                                                2)) - (int const   )(*(__s2___14 +
                                                                                       2)));
                        if (__s1_len___0 > 2U) {
                          if (__result___42 == 0) {
                            __result___42 = (int )((int const   )(*((unsigned char const   *)remotename +
                                                                    3)) - (int const   )(*(__s2___14 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___104 = __result___42;
              }
            } else {
              goto _L___35;
            }
          } else {
            goto _L___35;
          }
        } else {
          _L___35: /* CIL Label */ 
          tmp___133 = __builtin_constant_p((int )"main.cvd");
          if (tmp___133) {
            if ((unsigned int )((void const   *)("main.cvd" + 1)) - (unsigned int )((void const   *)"main.cvd") ==
                1U) {
              __s2_len___0 = strlen("main.cvd");
              if (__s2_len___0 < 4U) {
                tmp___132 = __builtin_constant_p((int )remotename);
                if (tmp___132) {
                  if ((unsigned int )((void const   *)(remotename + 1)) - (unsigned int )((void const   *)remotename) ==
                      1U) {
                    tmp___104 = __builtin_strcmp(remotename, "main.cvd");
                  } else {
                    goto _L___33;
                  }
                } else {
                  _L___33: /* CIL Label */ 
                  __s1___30 = (unsigned char const   *)remotename;
                  __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)"main.cvd" +
                                                                                             0)));
                  if (__s2_len___0 > 0U) {
                    if (__result___46 == 0) {
                      __result___46 = (int )((int const   )(*(__s1___30 + 1)) - (int const   )(*((unsigned char const   *)"main.cvd" +
                                                                                                 1)));
                      if (__s2_len___0 > 1U) {
                        if (__result___46 == 0) {
                          __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"main.cvd" +
                                                                  2)));
                          if (__s2_len___0 > 2U) {
                            if (__result___46 == 0) {
                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"main.cvd" +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___104 = __result___46;
                }
              } else {
                tmp___104 = __builtin_strcmp(remotename, "main.cvd");
              }
            } else {
              tmp___104 = __builtin_strcmp(remotename, "main.cvd");
            }
          } else {
            tmp___104 = __builtin_strcmp(remotename, "main.cvd");
          }
        }
      }
      if (tmp___104) {
        tmp___66 = __builtin_constant_p((int )remotename);
        if (tmp___66) {
          tmp___67 = __builtin_constant_p((int )"daily.cvd");
          if (tmp___67) {
            __s1_len = strlen(remotename);
            __s2_len = strlen("daily.cvd");
            if (! ((unsigned int )((void const   *)(remotename + 1)) - (unsigned int )((void const   *)remotename) ==
                   1U)) {
              goto _L___16;
            } else {
              if (__s1_len >= 4U) {
                _L___16: /* CIL Label */ 
                if (! ((unsigned int )((void const   *)("daily.cvd" + 1)) - (unsigned int )((void const   *)"daily.cvd") ==
                       1U)) {
                  tmp___68 = 1;
                } else {
                  if (__s2_len >= 4U) {
                    tmp___68 = 1;
                  } else {
                    tmp___68 = 0;
                  }
                }
              } else {
                tmp___68 = 0;
              }
            }
            if (tmp___68) {
              tmp___35 = __builtin_strcmp(remotename, "daily.cvd");
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: /* CIL Label */ 
          tmp___65 = __builtin_constant_p((int )remotename);
          if (tmp___65) {
            if ((unsigned int )((void const   *)(remotename + 1)) - (unsigned int )((void const   *)remotename) ==
                1U) {
              __s1_len = strlen(remotename);
              if (__s1_len < 4U) {
                tmp___54 = __builtin_constant_p((int )"daily.cvd");
                if (tmp___54) {
                  if ((unsigned int )((void const   *)("daily.cvd" + 1)) - (unsigned int )((void const   *)"daily.cvd") ==
                      1U) {
                    tmp___35 = __builtin_strcmp(remotename, "daily.cvd");
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: /* CIL Label */ 
                  __s2___6 = (unsigned char const   *)"daily.cvd";
                  __result___18 = (int )((int const   )(*((unsigned char const   *)remotename +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
                  if (__s1_len > 0U) {
                    if (__result___18 == 0) {
                      __result___18 = (int )((int const   )(*((unsigned char const   *)remotename +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
                      if (__s1_len > 1U) {
                        if (__result___18 == 0) {
                          __result___18 = (int )((int const   )(*((unsigned char const   *)remotename +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
                          if (__s1_len > 2U) {
                            if (__result___18 == 0) {
                              __result___18 = (int )((int const   )(*((unsigned char const   *)remotename +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___35 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: /* CIL Label */ 
            tmp___64 = __builtin_constant_p((int )"daily.cvd");
            if (tmp___64) {
              if ((unsigned int )((void const   *)("daily.cvd" + 1)) - (unsigned int )((void const   *)"daily.cvd") ==
                  1U) {
                __s2_len = strlen("daily.cvd");
                if (__s2_len < 4U) {
                  tmp___63 = __builtin_constant_p((int )remotename);
                  if (tmp___63) {
                    if ((unsigned int )((void const   *)(remotename + 1)) - (unsigned int )((void const   *)remotename) ==
                        1U) {
                      tmp___35 = __builtin_strcmp(remotename, "daily.cvd");
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: /* CIL Label */ 
                    __s1___14 = (unsigned char const   *)remotename;
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"daily.cvd" +
                                                                                               0)));
                    if (__s2_len > 0U) {
                      if (__result___22 == 0) {
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)"daily.cvd" +
                                                                1)));
                        if (__s2_len > 1U) {
                          if (__result___22 == 0) {
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)"daily.cvd" +
                                                                    2)));
                            if (__s2_len > 2U) {
                              if (__result___22 == 0) {
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)"daily.cvd" +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___35 = __result___22;
                  }
                } else {
                  tmp___35 = __builtin_strcmp(remotename, "daily.cvd");
                }
              } else {
                tmp___35 = __builtin_strcmp(remotename, "daily.cvd");
              }
            } else {
              tmp___35 = __builtin_strcmp(remotename, "daily.cvd");
            }
          }
        }
        if (tmp___35) {
          mprintf("WARNING: Unknown database name (%s) passed.\n", remotename);
          logg("WARNING: Unknown database name (%s) passed.\n", remotename);
        } else {
          field = 2;
        }
      } else {
        field = 1;
      }
      if (field) {
        pt = cli_strtok(dnsreply, field, ":");
        if (pt) {
          tmp___138 = isnumb((char const   *)pt);
          if (tmp___138) {
            dbver = atoi__extinline((char const   *)pt);
            mprintf("*%s version from DNS: %d\n", remotename, dbver);
          } else {
            mprintf("WARNING: Broken database version in TXT record.\n");
            logg("WARNING: Broken database version in TXT record.\n");
          }
          free((void *)pt);
        } else {
          mprintf("WARNING: Invalid DNS reply. Falling back to HTTP mode.\n");
          logg("WARNING: Invalid DNS reply. Falling back to HTTP mode.\n");
        }
      } else {
        mprintf("WARNING: Invalid DNS reply. Falling back to HTTP mode.\n");
        logg("WARNING: Invalid DNS reply. Falling back to HTTP mode.\n");
      }
    }
  }
  cpt = cfgopt(copt, "HTTPProxyServer");
  if (cpt) {
    proxy = (char const   *)cpt->strarg;
    tmp___139 = strncasecmp(proxy, "http://", 7U);
    if (tmp___139 == 0) {
      proxy += 7;
    }
    cpt = cfgopt(copt, "HTTPProxyUsername");
    if (cpt) {
      user = (char const   *)cpt->strarg;
      cpt = cfgopt(copt, "HTTPProxyPassword");
      if (cpt) {
        pass = (char const   *)cpt->strarg;
      } else {
        mprintf("HTTPProxyUsername requires HTTPProxyPassword\n");
        if (current) {
          cl_cvdfree(current);
        }
        return (56);
      }
    }
    cpt = cfgopt(copt, "HTTPProxyPort");
    if (cpt) {
      port = cpt->numarg;
    }
    mprintf("Connecting via %s\n", proxy);
  }
  memset((void *)(ipaddr), 0, sizeof(ipaddr));
  if (! nodb) {
    if (dbver == -1) {
      if ((*(ip + 0))) {
        hostfd = wwwconnect((char const   *)ip, proxy, port, ipaddr, localip);
      } else {
        hostfd = wwwconnect(hostname, proxy, port, ipaddr, localip);
      }
      if (hostfd < 0) {
        mprintf("@No servers could be reached. Giving up\n");
        if (current) {
          cl_cvdfree(current);
        }
        return (52);
      } else {
        mprintf("*Connected to %s (IP: %s).\n", hostname, ipaddr);
        mprintf("*Trying to retrieve http://%s/%s\n", hostname, remotename);
      }
      if (! (*(ip + 0))) {
        strcpy((char * __restrict  )ip, (char const   * __restrict  )(ipaddr));
      }
      remote = remote_cvdhead(remotename, hostfd, hostname, proxy, user, pass, & ims);
      if (! nodb) {
        if (! ims) {
          mprintf("%s is up to date (version: %d, sigs: %d, f-level: %d, builder: %s)\n",
                  localname, current->version, current->sigs, current->fl, current->builder);
          logg("%s is up to date (version: %d, sigs: %d, f-level: %d, builder: %s)\n",
               localname, current->version, current->sigs, current->fl, current->builder);
          (*signo) += current->sigs;
          close(hostfd);
          cl_cvdfree(current);
          return (1);
        }
      }
      if (! remote) {
        mprintf("@Can\'t read %s header from %s (IP: %s)\n", remotename, hostname,
                ipaddr);
        close(hostfd);
        if (current) {
          cl_cvdfree(current);
        }
        return (58);
      }
      dbver = remote->version;
      cl_cvdfree(remote);
      close(hostfd);
    }
  }
  if (! nodb) {
    if (current->version >= dbver) {
      mprintf("%s is up to date (version: %d, sigs: %d, f-level: %d, builder: %s)\n",
              localname, current->version, current->sigs, current->fl, current->builder);
      logg("%s is up to date (version: %d, sigs: %d, f-level: %d, builder: %s)\n",
           localname, current->version, current->sigs, current->fl, current->builder);
      if (flevel < (int )current->fl) {
        mprintf("WARNING: Your ClamAV installation is OUTDATED!\n");
        mprintf("WARNING: Current functionality level = %d, recommended = %d\n", flevel,
                current->fl);
        mprintf("DON\'T PANIC! Read http://www.clamav.net/faq.html\n");
        logg("WARNING: Your ClamAV installation is OUTDATED!\n");
        logg("WARNING: Current functionality level = %d, recommended = %d\n", flevel,
             current->fl);
        logg("DON\'T PANIC! Read http://www.clamav.net/faq.html\n");
      }
      (*signo) += current->sigs;
      cl_cvdfree(current);
      return (1);
    }
  }
  if (current) {
    cl_cvdfree(current);
  }
  if (ipaddr[0]) {
    hostfd = wwwconnect((char const   *)(ipaddr), proxy, port, (char *)((void *)0),
                        localip);
  } else {
    hostfd = wwwconnect(hostname, proxy, port, ipaddr, localip);
    if (! (*(ip + 0))) {
      strcpy((char * __restrict  )ip, (char const   * __restrict  )(ipaddr));
    }
  }
  if (hostfd < 0) {
    if (ipaddr[0]) {
      mprintf("Connection with %s (IP: %s) failed.\n", hostname, ipaddr);
    } else {
      mprintf("Connection with %s failed.\n", hostname);
    }
    return (52);
  }
  tempname = cli_gentemp(".");
  mprintf("*Retrieving http://%s/%s\n", hostname, remotename);
  ret = get_database(remotename, hostfd, (char const   *)tempname, hostname, proxy,
                     user, pass);
  if (ret) {
    mprintf("@Can\'t download %s from %s (IP: %s)\n", remotename, hostname, ipaddr);
    unlink((char const   *)tempname);
    free((void *)tempname);
    close(hostfd);
    return (ret);
  }
  close(hostfd);
  ret = cl_cvdverify((char const   *)tempname);
  if (ret) {
    tmp___140 = cl_strerror(ret);
    mprintf("@Verification: %s\n", tmp___140);
    unlink((char const   *)tempname);
    free((void *)tempname);
    return (54);
  }
  current = cl_cvdhead((char const   *)tempname);
  if ((unsigned int )current == (unsigned int )((void *)0)) {
    mprintf("@Can\'t read CVD header of new %s database.\n", localname);
    unlink((char const   *)tempname);
    free((void *)tempname);
    return (54);
  }
  if (current->version < dbver) {
    mprintf("@Mirrors are not fully synchronized. Please try again later.\n");
    cl_cvdfree(current);
    unlink((char const   *)tempname);
    free((void *)tempname);
    return (59);
  }
  if (! nodb) {
    tmp___148 = unlink(localname);
    if (tmp___148) {
      mprintf("@Can\'t unlink %s. Please fix it and try again.\n", localname);
      cl_cvdfree(current);
      unlink((char const   *)tempname);
      free((void *)tempname);
      return (53);
    } else {
      goto _L___39;
    }
  } else {
    _L___39: /* CIL Label */ 
    tmp___147 = rename((char const   *)tempname, localname);
    if (tmp___147 == -1) {
      tmp___141 = __errno_location();
      tmp___142 = strerror((*tmp___141));
      mprintf("@Can\'t rename %s to %s: %s\n", tempname, localname, tmp___142);
      tmp___146 = __errno_location();
      if ((*tmp___146) == 17) {
        unlink(localname);
        tmp___145 = rename((char const   *)tempname, localname);
        if (tmp___145 == -1) {
          tmp___143 = __errno_location();
          tmp___144 = strerror((*tmp___143));
          mprintf("@All attempts to rename the temporary file failed: %s\n", tmp___144);
        }
      }
    }
  }
  mprintf("%s updated (version: %d, sigs: %d, f-level: %d, builder: %s)\n", localname,
          current->version, current->sigs, current->fl, current->builder);
  logg("%s updated (version: %d, sigs: %d, f-level: %d, builder: %s)\n", localname,
       current->version, current->sigs, current->fl, current->builder);
  if (flevel < (int )current->fl) {
    mprintf("WARNING: Your ClamAV installation is OUTDATED!\n");
    mprintf("WARNING: Current functionality level = %d, recommended = %d\n", flevel,
            current->fl);
    mprintf("DON\'T PANIC! Read http://www.clamav.net/faq.html\n");
    logg("WARNING: Your ClamAV installation is OUTDATED!\n");
    logg("WARNING: Current functionality level = %d, recommended = %d\n", flevel,
         current->fl);
    logg("DON\'T PANIC! Read http://www.clamav.net/faq.html\n");
  }
  (*signo) += current->sigs;
  cl_cvdfree(current);
  free((void *)tempname);
  return (0);
}
}
int wwwconnect(char const   *server , char const   *proxy , int pport , char *ip ,
               char *localip ) 
{ int socketfd ;
  int port ;
  int i ;
  struct sockaddr_in name ;
  struct hostent *host ;
  char ipaddr[16] ;
  unsigned char *ia ;
  char const   *hostpt ;
  struct hostent *he ;
  char *herr ;
  int *tmp ;
  struct sockaddr_in client ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct servent  const  *webcache ;
  struct servent  const  *tmp___3 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int tmp___4 ;
  char *herr___0 ;
  int *tmp___5 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  socketfd = -1;
  he = (struct hostent *)((void *)0);
  if (ip) {
    strcpy((char * __restrict  )ip, (char const   * __restrict  )"???");
  }
  name.sin_family = (unsigned short)2;
  if (localip) {
    he = gethostbyname((char const   *)localip);
    if ((unsigned int )he == (unsigned int )((void *)0)) {
      tmp = __h_errno_location();
      switch ((*tmp)) {
      case 1: 
      herr = (char *)"Host not found";
      break;
      case 4: 
      herr = (char *)"No IP address";
      break;
      case 3: 
      herr = (char *)"Unrecoverable DNS error";
      break;
      case 2: 
      herr = (char *)"Temporary DNS error";
      break;
      default: 
      herr = (char *)"Unknown error";
      break;
      }
      mprintf("!Could not resolve local ip address \'%s\': %s\n", localip, herr);
      mprintf("^Using standard local ip address and port for fetching.\n");
    } else {
      memset((void *)((char *)(& client)), 0, sizeof(struct sockaddr_in ));
      client.sin_family = (unsigned short)2;
      client.sin_addr = (*((struct in_addr *)(*(he->h_addr_list + 0))));
      tmp___2 = bind(socketfd, (struct sockaddr  const  *)((struct sockaddr *)(& client)),
                     sizeof(struct sockaddr_in ));
      if (tmp___2 != 0) {
        tmp___0 = __errno_location();
        tmp___1 = strerror((*tmp___0));
        mprintf("!Could not bind to local ip address \'%s\': %s\n", localip, tmp___1);
        mprintf("^Using default client ip.\n");
      } else {
        ia = (unsigned char *)(*(he->h_addr_list + 0));
        sprintf((char * __restrict  )(ipaddr), (char const   * __restrict  )"%u.%u.%u.%u",
                (*(ia + 0)), (*(ia + 1)), (*(ia + 2)), (*(ia + 3)));
        mprintf("*Using ip \'%s\' for fetching.\n", ipaddr);
      }
    }
  }
  if (proxy) {
    hostpt = proxy;
    port = pport;
    if (! port) {
      tmp___3 = getservbyname("webcache", "TCP");
      webcache = tmp___3;
      if (webcache) {
        __x = (unsigned short )webcache->s_port;
        tmp___4 = __builtin_constant_p((int )__x);
        if (tmp___4) {
          __v = (unsigned short )((((int )__x >> 8) & 255) | (((int )__x & 255) <<
                                                              8));
        } else {
          __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
        }
        port = (int )__v;
      } else {
        port = 8080;
      }
      endservent();
    }
  } else {
    hostpt = server;
    port = 80;
  }
  host = gethostbyname(hostpt);
  if ((unsigned int )host == (unsigned int )((void *)0)) {
    tmp___5 = __h_errno_location();
    switch ((*tmp___5)) {
    case 1: 
    herr___0 = (char *)"Host not found";
    break;
    case 4: 
    herr___0 = (char *)"No IP address";
    break;
    case 3: 
    herr___0 = (char *)"Unrecoverable DNS error";
    break;
    case 2: 
    herr___0 = (char *)"Temporary DNS error";
    break;
    default: 
    herr___0 = (char *)"Unknown error";
    break;
    }
    mprintf("@Can\'t get information about %s: %s\n", hostpt, herr___0);
    return (-1);
  }
  i = 0;
  while ((unsigned int )(*(host->h_addr_list + i)) != (unsigned int )((char *)0)) {
    ia = (unsigned char *)(*(host->h_addr_list + i));
    sprintf((char * __restrict  )(ipaddr), (char const   * __restrict  )"%u.%u.%u.%u",
            (*(ia + 0)), (*(ia + 1)), (*(ia + 2)), (*(ia + 3)));
    if (ip) {
      strcpy((char * __restrict  )ip, (char const   * __restrict  )(ipaddr));
    }
    if (i > 0) {
      mprintf("Trying host %s (%s)...\n", hostpt, ipaddr);
    }
    name.sin_addr = (*((struct in_addr *)(*(host->h_addr_list + i))));
    __x___0 = (unsigned short )port;
    tmp___6 = __builtin_constant_p((int )__x___0);
    if (tmp___6) {
      __v___0 = (unsigned short )((((int )__x___0 >> 8) & 255) | (((int )__x___0 &
                                                                   255) << 8));
    } else {
      __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
    }
    name.sin_port = __v___0;
    socketfd = socket(2, 1, 0);
    tmp___7 = connect(socketfd, (struct sockaddr  const  *)((struct sockaddr *)(& name)),
                      sizeof(struct sockaddr_in ));
    if (tmp___7 == -1) {
      mprintf("Can\'t connect to port %d of host %s (IP: %s)\n", port, hostpt, ipaddr);
      close(socketfd);
      goto __Cont;
    }
    return (socketfd);
    __Cont: /* CIL Label */ 
    i ++;
  }
  return (-2);
}
}
int Rfc2822DateTime(char *buf , time_t mtime ) 
{ struct tm *time___0 ;
  int tmp ;

  {
  time___0 = gmtime((time_t const   *)(& mtime));
  tmp = (int )strftime((char * __restrict  )buf, 36U, (char const   * __restrict  )"%a, %d %b %Y %X GMT",
                       (struct tm  const  * __restrict  )time___0);
  return (tmp);
}
}
struct cl_cvd *remote_cvdhead(char const   *file , int socketfd , char const   *hostname ,
                              char const   *proxy , char const   *user , char const   *pass ,
                              int *ims ) 
{ char cmd[512] ;
  char head[513] ;
  char buffer[8192] ;
  char *ch ;
  char *tmp ;
  int i ;
  int j ;
  int bread ;
  int cnt ;
  char *remotename ;
  char *authorization ;
  struct cl_cvd *cvd ;
  char last_modified[36] ;
  struct stat sb ;
  size_t tmp___0 ;
  int len ;
  char *buf ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *userpass ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  unsigned int tmp___7 ;
  size_t tmp___8 ;
  time_t mtime ;
  int tmp___9 ;
  time_t tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  unsigned short const   **tmp___18 ;

  {
  remotename = (char *)((void *)0);
  authorization = (char *)((void *)0);
  if (proxy) {
    tmp___0 = strlen(hostname);
    remotename = (char *)mmalloc(tmp___0 + 8U);
    sprintf((char * __restrict  )remotename, (char const   * __restrict  )"http://%s",
            hostname);
    if (user) {
      tmp___1 = strlen(pass);
      tmp___2 = strlen(user);
      tmp___3 = (char *)mmalloc((tmp___1 + tmp___2) * 2U + 4U);
      buf = tmp___3;
      tmp___4 = strlen(user);
      tmp___5 = strlen(pass);
      tmp___6 = (char *)mmalloc((tmp___4 + tmp___5) + 2U);
      userpass = tmp___6;
      sprintf((char * __restrict  )userpass, (char const   * __restrict  )"%s:%s",
              user, pass);
      tmp___7 = strlen((char const   *)userpass);
      len = (int )fmt_base64(buf, (char const   *)userpass, tmp___7);
      free((void *)userpass);
      (*(buf + len)) = (char )'\000';
      tmp___8 = strlen((char const   *)buf);
      authorization = (char *)mmalloc(tmp___8 + 30U);
      sprintf((char * __restrict  )authorization, (char const   * __restrict  )"Proxy-Authorization: Basic %s\r\n",
              buf);
      free((void *)buf);
    }
  }
  tmp___9 = stat__extinline(file, & sb);
  if (tmp___9 != -1) {
    tmp___10 = time((time_t *)((void *)0));
    if (sb.st_mtim.tv_sec < tmp___10) {
      Rfc2822DateTime(last_modified, sb.st_mtim.tv_sec);
    } else {
      mtime = (time_t )1104119530;
      Rfc2822DateTime(last_modified, mtime);
      mprintf("*Assuming modification time in the past\n");
    }
  } else {
    mtime = (time_t )1104119530;
    Rfc2822DateTime(last_modified, mtime);
    mprintf("*Assuming modification time in the past\n");
  }
  mprintf("*If-Modified-Since: %s\n", last_modified);
  mprintf("Reading CVD header (%s): ", file);
  if ((unsigned int )authorization != (unsigned int )((void *)0)) {
    tmp___11 = (char const   *)authorization;
  } else {
    tmp___11 = "";
  }
  if ((unsigned int )remotename != (unsigned int )((void *)0)) {
    tmp___12 = (char const   *)remotename;
  } else {
    tmp___12 = "";
  }
  snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"GET %s/%s HTTP/1.1\r\nHost: %s\r\n%sUser-Agent: clamav/0.85.1\r\nConnection: close\r\nRange: bytes=0-511\r\nIf-Modified-Since: %s\r\n\r\n",
           tmp___12, file, hostname, tmp___11, last_modified);
  tmp___13 = strlen((char const   *)(cmd));
  write(socketfd, (void const   *)(cmd), tmp___13);
  free((void *)remotename);
  free((void *)authorization);
  tmp = buffer;
  cnt = 8192;
  while (1) {
    bread = recv(socketfd, (void *)tmp, (unsigned int )cnt, 0);
    if (! (bread > 0)) {
      break;
    }
    tmp += bread;
    cnt -= bread;
    if (cnt <= 0) {
      break;
    }
  }
  if (bread == -1) {
    mprintf("@Error while reading CVD header of database from %s\n", hostname);
    return ((struct cl_cvd *)((void *)0));
  }
  tmp___14 = strstr((char const   *)(buffer), "HTTP/1.1 404");
  if ((unsigned int )tmp___14 != (unsigned int )((void *)0)) {
    mprintf("@CVD file not found on remote server\n");
    return ((struct cl_cvd *)((void *)0));
  } else {
    tmp___15 = strstr((char const   *)(buffer), "HTTP/1.0 404");
    if ((unsigned int )tmp___15 != (unsigned int )((void *)0)) {
      mprintf("@CVD file not found on remote server\n");
      return ((struct cl_cvd *)((void *)0));
    }
  }
  tmp___16 = strstr((char const   *)(buffer), "HTTP/1.1 304");
  if ((unsigned int )tmp___16 != (unsigned int )((void *)0)) {
    (*ims) = 0;
    mprintf("OK (IMS)\n");
    return ((struct cl_cvd *)((void *)0));
  } else {
    tmp___17 = strstr((char const   *)(buffer), "HTTP/1.0 304");
    if ((unsigned int )tmp___17 != (unsigned int )((void *)0)) {
      (*ims) = 0;
      mprintf("OK (IMS)\n");
      return ((struct cl_cvd *)((void *)0));
    } else {
      (*ims) = 1;
    }
  }
  ch = buffer;
  i = 0;
  while (1) {
    if ((int )(*ch) == 10) {
      if ((int )(*(ch - 1)) == 13) {
        if ((int )(*(ch - 2)) == 10) {
          if ((int )(*(ch - 3)) == 13) {
            ch ++;
            i ++;
            break;
          }
        }
      }
    }
    ch ++;
    i ++;
  }
  memset((void *)(head), 0, sizeof(head));
  j = 0;
  while (j < 512) {
    if (! ch) {
      mprintf("@Malformed CVD header detected.\n");
      return ((struct cl_cvd *)((void *)0));
    } else {
      if (ch) {
        if (! (*ch)) {
          mprintf("@Malformed CVD header detected.\n");
          return ((struct cl_cvd *)((void *)0));
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        if (ch) {
          tmp___18 = __ctype_b_loc();
          if (! ((int const   )(*((*tmp___18) + (int )(*(ch + j)))) & 16384)) {
            mprintf("@Malformed CVD header detected.\n");
            return ((struct cl_cvd *)((void *)0));
          }
        }
      }
    }
    head[j] = (*(ch + j));
    j ++;
  }
  cvd = cl_cvdparse((char const   *)(head));
  if ((unsigned int )cvd == (unsigned int )((void *)0)) {
    mprintf("@Broken CVD header.\n");
  } else {
    mprintf("OK\n");
  }
  return (cvd);
}
}
int get_database(char const   *dbfile , int socketfd , char const   *file , char const   *hostname ,
                 char const   *proxy , char const   *user , char const   *pass ) 
{ char cmd[512] ;
  char buffer[8192] ;
  char *ch ;
  int bread ;
  int fd ;
  int i ;
  int rot ;
  char *remotename ;
  char *authorization ;
  char const   *rotation ;
  size_t tmp ;
  int len ;
  char *buf ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *userpass ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  unsigned int tmp___6 ;
  size_t tmp___7 ;
  char currdir[512] ;
  __gid_t tmp___8 ;
  __uid_t tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  size_t tmp___12 ;
  ssize_t tmp___13 ;
  char *tmp___14 ;

  {
  rot = 0;
  remotename = (char *)((void *)0);
  authorization = (char *)((void *)0);
  rotation = "|/-\\";
  if (proxy) {
    tmp = strlen(hostname);
    remotename = (char *)mmalloc(tmp + 8U);
    sprintf((char * __restrict  )remotename, (char const   * __restrict  )"http://%s",
            hostname);
    if (user) {
      tmp___0 = strlen(pass);
      tmp___1 = strlen(user);
      tmp___2 = (char *)mmalloc((tmp___0 + tmp___1) * 2U + 4U);
      buf = tmp___2;
      tmp___3 = strlen(user);
      tmp___4 = strlen(pass);
      tmp___5 = (char *)mmalloc((tmp___3 + tmp___4) + 2U);
      userpass = tmp___5;
      sprintf((char * __restrict  )userpass, (char const   * __restrict  )"%s:%s",
              user, pass);
      tmp___6 = strlen((char const   *)userpass);
      len = (int )fmt_base64(buf, (char const   *)userpass, tmp___6);
      free((void *)userpass);
      (*(buf + len)) = (char )'\000';
      tmp___7 = strlen((char const   *)buf);
      authorization = (char *)mmalloc(tmp___7 + 30U);
      sprintf((char * __restrict  )authorization, (char const   * __restrict  )"Proxy-Authorization: Basic %s\r\n",
              buf);
      free((void *)buf);
    }
  }
  fd = open(file, 193, 420);
  if (fd == -1) {
    getcwd(currdir, sizeof(currdir));
    mprintf("@Can\'t create new file %s in %s\n", file, currdir);
    tmp___8 = getgid();
    tmp___9 = getuid();
    mprintf("@The database directory must be writable for UID %d or GID %d\n", tmp___9,
            tmp___8);
    return (57);
  }
  if ((unsigned int )authorization != (unsigned int )((void *)0)) {
    tmp___10 = (char const   *)authorization;
  } else {
    tmp___10 = "";
  }
  if ((unsigned int )remotename != (unsigned int )((void *)0)) {
    tmp___11 = (char const   *)remotename;
  } else {
    tmp___11 = "";
  }
  snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"GET %s/%s HTTP/1.1\r\nHost: %s\r\n%sUser-Agent: clamav/0.85.1\r\nCache-Control: no-cache\r\nConnection: close\r\n\r\n",
           tmp___11, dbfile, hostname, tmp___10);
  tmp___12 = strlen((char const   *)(cmd));
  write(socketfd, (void const   *)(cmd), tmp___12);
  free((void *)remotename);
  free((void *)authorization);
  ch = buffer;
  i = 0;
  while (1) {
    tmp___13 = recv(socketfd, (void *)(buffer + i), 1U, 0);
    if (tmp___13 == -1) {
      mprintf("@Error while reading database from %s\n", hostname);
      close(fd);
      unlink(file);
      return (52);
    }
    if (i > 2) {
      if ((int )(*ch) == 10) {
        if ((int )(*(ch - 1)) == 13) {
          if ((int )(*(ch - 2)) == 10) {
            if ((int )(*(ch - 3)) == 13) {
              i ++;
              break;
            }
          }
        }
      }
    }
    ch ++;
    i ++;
  }
  buffer[i] = (char)0;
  tmp___14 = strstr((char const   *)(buffer), "HTTP/1.1 404");
  if ((unsigned int )tmp___14 != (unsigned int )((void *)0)) {
    mprintf("@%s not found on remote server\n", dbfile);
    close(fd);
    unlink(file);
    return (58);
  }
  while (1) {
    bread = read(socketfd, (void *)(buffer), 8192U);
    if (! bread) {
      break;
    }
    write(fd, (void const   *)(buffer), (unsigned int )bread);
    mprintf("Downloading %s [%c]\r", dbfile, (*(rotation + rot)));
    fflush(stdout);
    rot ++;
    rot %= 4;
  }
  mprintf("Downloading %s [*]\n", dbfile);
  close(fd);
  return (0);
}
}
char const   base64[66]  = 
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'=',      (char const   )'\000'};
unsigned int fmt_base64(char *dest , char const   *src , unsigned int len ) 
{ register unsigned char const   *s ;
  unsigned short bits ;
  unsigned short temp ;
  unsigned long written ;
  unsigned long i ;

  {
  s = (unsigned char const   *)src;
  bits = (unsigned short)0;
  temp = (unsigned short)0;
  written = 0UL;
  i = 0UL;
  while (i < (unsigned long )len) {
    temp = (unsigned short )((int )temp << 8);
    temp = (unsigned short )((int )temp + (int )(*(s + i)));
    bits = (unsigned short )((int )bits + 8);
    while ((int )bits > 6) {
      if (dest) {
        (*(dest + written)) = (char )base64[((int )temp >> ((int )bits - 6)) & 63];
      }
      written ++;
      bits = (unsigned short )((int )bits - 6);
    }
    i ++;
  }
  if (bits) {
    temp = (unsigned short )((int )temp << (6 - (int )bits));
    if (dest) {
      (*(dest + written)) = (char )base64[(int )temp & 63];
    }
    written ++;
  }
  while (written & 3UL) {
    if (dest) {
      (*(dest + written)) = (char )'=';
    }
    written ++;
  }
  return ((unsigned int )written);
}
}
#pragma merger(0,"/tmp/cil-47kY3hLX.i","-g -O2")
extern void perror(char const   *__s ) ;
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
int notify(char const   *cfgfile ) 
{ char buff[20] ;
  struct sockaddr_un server ;
  struct sockaddr_in server2 ;
  struct hostent *he ;
  struct cfgstruct *copt ;
  struct cfgstruct *cpt ;
  int sockd ;
  int bread ;
  char *socktype ;
  int tmp ;
  register unsigned short __v ;
  register unsigned short __x ;
  int tmp___0 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  struct cfgstruct *tmp___4 ;
  struct cfgstruct *tmp___5 ;
  ssize_t tmp___6 ;
  char *tmp___7 ;

  {
  copt = parsecfg(cfgfile, 1);
  if ((unsigned int )copt == (unsigned int )((void *)0)) {
    mprintf("@Clamd was NOT notified: Can\'t find or parse configuration file %s\n",
            cfgfile);
    return (1);
  }
  tmp___4 = cfgopt((struct cfgstruct  const  *)copt, "TCPSocket");
  if (tmp___4) {
    tmp___5 = cfgopt((struct cfgstruct  const  *)copt, "LocalSocket");
    if (tmp___5) {
      mprintf("@Clamd was NOT notified: Both socket types (TCP and local) declared in %s\n",
              cfgfile);
      return (1);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    cpt = cfgopt((struct cfgstruct  const  *)copt, "LocalSocket");
    if (cpt) {
      socktype = (char *)"UNIX";
      server.sun_family = (unsigned short)1;
      __builtin_strncpy(server.sun_path, cpt->strarg, sizeof(server.sun_path));
      sockd = socket(1, 1, 0);
      if (sockd < 0) {
        mprintf("@Clamd was NOT notified: Can\'t create socket endpoint for %s\n",
                cpt->strarg);
        perror("socket()");
        return (1);
      }
      tmp = connect(sockd, (struct sockaddr  const  *)((struct sockaddr *)(& server)),
                    sizeof(struct sockaddr_un ));
      if (tmp < 0) {
        close(sockd);
        mprintf("@Clamd was NOT notified: Can\'t connect to clamd through %s\n", cpt->strarg);
        perror("connect()");
        return (1);
      }
    } else {
      cpt = cfgopt((struct cfgstruct  const  *)copt, "TCPSocket");
      if (cpt) {
        socktype = (char *)"TCP";
        sockd = socket(2, 1, 0);
        if (sockd < 0) {
          mprintf("@Clamd was NOT notified: Can\'t create TCP socket\n");
          perror("socket()");
          return (1);
        }
        server2.sin_family = (unsigned short)2;
        __x = (unsigned short )cpt->numarg;
        tmp___0 = __builtin_constant_p((int )__x);
        if (tmp___0) {
          __v = (unsigned short )((((int )__x >> 8) & 255) | (((int )__x & 255) <<
                                                              8));
        } else {
          __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
        }
        server2.sin_port = __v;
        cpt = cfgopt((struct cfgstruct  const  *)copt, "TCPAddr");
        if (cpt) {
          he = gethostbyname((char const   *)cpt->strarg);
          if ((unsigned int )he == (unsigned int )((struct hostent *)0)) {
            perror("gethostbyname()");
            mprintf("@Clamd was NOT notified: Can\'t resolve hostname \'%s\'\n", cpt->strarg);
            return (1);
          }
          server2.sin_addr = (*((struct in_addr *)(*(he->h_addr_list + 0))));
        } else {
          server2.sin_addr.s_addr = inet_addr("127.0.0.1");
        }
        tmp___3 = connect(sockd, (struct sockaddr  const  *)((struct sockaddr *)(& server2)),
                          sizeof(struct sockaddr_in ));
        if (tmp___3 < 0) {
          close(sockd);
          __x___0 = server2.sin_port;
          tmp___1 = __builtin_constant_p((int )__x___0);
          if (tmp___1) {
            __v___0 = (unsigned short )((((int )__x___0 >> 8) & 255) | (((int )__x___0 &
                                                                         255) << 8));
          } else {
            __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
          }
          tmp___2 = inet_ntoa(server2.sin_addr);
          mprintf("@Clamd was NOT notified: Can\'t connect to clamd on %s:%d\n", tmp___2,
                  __v___0);
          perror("connect()");
          return (1);
        }
      } else {
        mprintf("@Clamd was NOT notified: No socket specified in %s\n", cfgfile);
        return (1);
      }
    }
  }
  tmp___6 = write(sockd, (void const   *)"RELOAD", 6U);
  if (tmp___6 < 0) {
    mprintf("@Clamd was NOT notified: Could not write to %s socket\n", socktype);
    perror("write()");
    close(sockd);
    return (1);
  }
  memset((void *)(buff), 0, sizeof(buff));
  bread = read(sockd, (void *)(buff), sizeof(buff));
  if (bread > 0) {
    tmp___7 = strstr((char const   *)(buff), "RELOADING");
    if (! tmp___7) {
      mprintf("@Clamd was NOT notified: Unknown answer from clamd: \'%s\'\n", buff);
      close(sockd);
      return (1);
    }
  }
  close(sockd);
  mprintf("Clamd successfully notified about the update.\n");
  logg("Clamd successfully notified about the update.\n");
  return (0);
}
}
#pragma merger(0,"/tmp/cil-f5tqxiQZ.i","-g -O2")
extern  __attribute__((__nothrow__)) int __res_init(void) ;
extern  __attribute__((__nothrow__)) int __res_query(char const   * , int  , int  ,
                                                     u_char * , int  ) ;
extern  __attribute__((__nothrow__)) int __dn_expand(u_char const   * , u_char const   * ,
                                                     u_char const   * , char * , int  ) ;
char *txtquery(char const   *domain , unsigned int *ttl ) 
{ unsigned char answer[512] ;
  unsigned char host[128] ;
  unsigned char *pt ;
  unsigned char *txt ;
  int len ;
  int exp ;
  int cttl ;
  int size ;
  int txtlen ;
  int type ;
  int tmp ;
  register u_char *t_cp ;
  register u_char *t_cp___0 ;
  register u_char *t_cp___1 ;
  register u_char *t_cp___2 ;

  {
  tmp = __res_init();
  if (tmp < 0) {
    mprintf("@res_init failed\n");
    return ((char *)((void *)0));
  }
  mprintf("*Querying %s\n", domain);
  memset((void *)(answer), 0, 512U);
  len = __res_query(domain, 1, 16, answer, 512);
  if (len < 0) {
    mprintf("@Can\'t query %s\n", domain);
    return ((char *)((void *)0));
  }
  pt = answer + sizeof(HEADER );
  exp = __dn_expand((u_char const   *)(answer), (u_char const   *)(answer + len),
                    (u_char const   *)pt, (char *)(host), (int )sizeof(host));
  if (exp < 0) {
    mprintf("@dn_expand failed\n");
    return ((char *)((void *)0));
  }
  pt += exp;
  while (1) {
    t_cp = pt;
    type = ((int )((unsigned short )(*(t_cp + 0))) << 8) | (int )((unsigned short )(*(t_cp +
                                                                                      1)));
    pt += 2;
    break;
  }
  if (type != 16) {
    mprintf("@Broken DNS reply.\n");
    return ((char *)((void *)0));
  }
  pt += 2;
  exp = __dn_expand((u_char const   *)(answer), (u_char const   *)(answer + len),
                    (u_char const   *)pt, (char *)(host), (int )sizeof(host));
  if (exp < 0) {
    mprintf("@second dn_expand failed\n");
    return ((char *)((void *)0));
  }
  pt += exp;
  while (1) {
    t_cp___0 = pt;
    type = ((int )((unsigned short )(*(t_cp___0 + 0))) << 8) | (int )((unsigned short )(*(t_cp___0 +
                                                                                          1)));
    pt += 2;
    break;
  }
  if (type != 16) {
    mprintf("@Not a TXT record\n");
    return ((char *)((void *)0));
  }
  pt += 2;
  while (1) {
    t_cp___1 = pt;
    cttl = (int )(((((unsigned int )(*(t_cp___1 + 0)) << 24) | ((unsigned int )(*(t_cp___1 +
                                                                                  1)) <<
                                                                16)) | ((unsigned int )(*(t_cp___1 +
                                                                                          2)) <<
                                                                        8)) | (unsigned int )(*(t_cp___1 +
                                                                                                3)));
    pt += 4;
    break;
  }
  (*ttl) = (unsigned int )cttl;
  while (1) {
    t_cp___2 = pt;
    size = ((int )((unsigned short )(*(t_cp___2 + 0))) << 8) | (int )((unsigned short )(*(t_cp___2 +
                                                                                          1)));
    pt += 2;
    break;
  }
  txtlen = (int )(*pt);
  if (txtlen >= size) {
    mprintf("@Broken TXT record (txtlen = %d, size = %d)\n", txtlen, size);
    return ((char *)((void *)0));
  } else {
    if (! txtlen) {
      mprintf("@Broken TXT record (txtlen = %d, size = %d)\n", txtlen, size);
      return ((char *)((void *)0));
    }
  }
  txt = (unsigned char *)mmalloc((unsigned int )(txtlen + 1));
  if (! txt) {
    return ((char *)((void *)0));
  }
  pt ++;
  __builtin_strncpy(txt, pt, txtlen);
  (*(txt + txtlen)) = (unsigned char)0;
  return ((char *)txt);
}
}
#pragma merger(0,"/tmp/cil-z4EnTufJ.i","-g -O2")
int active_children  ;
void execute(char const   *type , char const   *text ) 
{ pid_t pid ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  if (active_children < 5) {
    pid = fork();
    switch (pid) {
    case 0: 
    tmp = system(text);
    if (-1 == tmp) {
      mprintf("@%s: couldn\'t execute \"%s\".\n", type, text);
    }
    exit(0);
    case -1: 
    tmp___0 = __errno_location();
    tmp___1 = strerror((*tmp___0));
    mprintf("@%s::fork() failed, %s.\n", type, tmp___1);
    break;
    default: 
    active_children = active_children + 1;
    }
  } else {
    mprintf("@%s: already %d processes active.\n", type, active_children);
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-39hsQXnz.i","-g -O2 -fPIC")
void cli_dbgmsg(char const   *str  , ...) ;
void *cli_calloc(size_t nmemb , size_t size ) ;
void *cli_realloc(void *ptr , size_t size ) ;
int cli_validatesig(unsigned short target , unsigned short ftype , char const   *offstr ,
                    unsigned long fileoff , int desc , char const   *virname ) ;
int cli_ac_addpatt(struct cl_node *root , struct cli_ac_patt *pattern ) ;
int cli_ac_scanbuff(char const   *buffer , unsigned int length , char const   **virname ,
                    struct cl_node  const  *root , int *partcnt , short otfrec , unsigned long offset ,
                    unsigned long *partoff , unsigned short ftype , int fd ) ;
int cli_ac_buildtrie(struct cl_node *root ) ;
void cli_ac_free(struct cl_node *root ) ;
int cli_addtypesigs(struct cl_node *root ) ;
int cli_ac_addpatt(struct cl_node *root , struct cli_ac_patt *pattern ) 
{ struct cli_ac_node *pos ;
  struct cli_ac_node *next ;
  int i ;

  {
  if (pattern->length < 2U) {
    return (-6);
  }
  pos = root->ac_root;
  i = 0;
  while (i < 2) {
    next = pos->trans[(int )((unsigned char )(*(pattern->pattern + i))) & 255];
    if (! next) {
      next = (struct cli_ac_node *)cli_calloc(1U, sizeof(struct cli_ac_node ));
      if (! next) {
        cli_dbgmsg("Unable to allocate pattern node (%d)\n", sizeof(struct cl_node ));
        return (-3);
      }
      root->ac_nodes ++;
      root->ac_nodetable = (struct cli_ac_node **)cli_realloc((void *)root->ac_nodetable,
                                                              root->ac_nodes * sizeof(struct cli_ac_node *));
      if ((unsigned int )root->ac_nodetable == (unsigned int )((void *)0)) {
        cli_dbgmsg("Unable to realloc nodetable (%d)\n", root->ac_nodes * sizeof(struct cl_node *));
        return (-3);
      }
      (*(root->ac_nodetable + (root->ac_nodes - 1U))) = next;
      pos->trans[(int )((unsigned char )(*(pattern->pattern + i))) & 255] = next;
    }
    pos = next;
    i ++;
  }
  pos->islast = (char)1;
  pattern->next = pos->list;
  pos->list = pattern;
  return (0);
}
}
static int cli_enqueue(struct nodelist **bfs , struct cli_ac_node *n ) 
{ struct nodelist *new ;

  {
  new = (struct nodelist *)cli_calloc(1U, sizeof(struct nodelist ));
  if ((unsigned int )new == (unsigned int )((void *)0)) {
    cli_dbgmsg("Unable to allocate node list (%d)\n", sizeof(struct nodelist ));
    return (-3);
  }
  new->next = (*bfs);
  new->node = n;
  (*bfs) = new;
  return (0);
}
}
static struct cli_ac_node *cli_dequeue(struct nodelist **bfs ) 
{ struct nodelist *handler ;
  struct nodelist *prev ;
  struct cli_ac_node *pt ;

  {
  prev = (struct nodelist *)((void *)0);
  handler = (*bfs);
  while (1) {
    if (handler) {
      if (! handler->next) {
        break;
      }
    } else {
      break;
    }
    prev = handler;
    handler = handler->next;
  }
  if (! handler) {
    return ((struct cli_ac_node *)((void *)0));
  } else {
    pt = handler->node;
    free((void *)handler);
    if (prev) {
      prev->next = (struct nodelist *)((void *)0);
    } else {
      (*bfs) = (struct nodelist *)((void *)0);
    }
    return (pt);
  }
}
}
static int cli_maketrans(struct cl_node *root ) 
{ struct nodelist *bfs ;
  struct cli_ac_node *ac_root ;
  struct cli_ac_node *child ;
  struct cli_ac_node *node ;
  int i ;
  int ret ;

  {
  bfs = (struct nodelist *)((void *)0);
  ac_root = root->ac_root;
  ac_root->fail = (struct cli_ac_node *)((void *)0);
  ret = cli_enqueue(& bfs, ac_root);
  if (ret != 0) {
    return (ret);
  }
  while (1) {
    node = cli_dequeue(& bfs);
    if (! node) {
      break;
    }
    if (node->islast) {
      continue;
    }
    i = 0;
    while (i < 256) {
      child = node->trans[i];
      if (! child) {
        if (node->fail) {
          node->trans[i] = (node->fail)->trans[i];
        } else {
          node->trans[i] = ac_root;
        }
      } else {
        if (node->fail) {
          child->fail = (node->fail)->trans[i];
        } else {
          child->fail = ac_root;
        }
        ret = cli_enqueue(& bfs, child);
        if (ret != 0) {
          return (ret);
        }
      }
      i ++;
    }
  }
  return (0);
}
}
int cli_ac_buildtrie(struct cl_node *root ) 
{ int ret ;
  int tmp ;

  {
  if (! root) {
    return (-5);
  }
  if (! root->ac_root) {
    cli_dbgmsg("Pattern matcher not initialised\n");
    return (0);
  }
  ret = cli_addtypesigs(root);
  if (ret) {
    return (ret);
  }
  tmp = cli_maketrans(root);
  return (tmp);
}
}
static void cli_freepatt(struct cli_ac_patt *list ) 
{ struct cli_ac_patt *handler ;
  struct cli_ac_patt *prev ;
  int i ;

  {
  handler = list;
  while (handler) {
    free((void *)handler->pattern);
    free((void *)handler->virname);
    if (handler->offset) {
      if (! handler->sigid) {
        free((void *)handler->offset);
      } else {
        if ((int )handler->partno == 1) {
          free((void *)handler->offset);
        }
      }
    }
    if (handler->alt) {
      free((void *)handler->altn);
      i = 0;
      while (i < (int )handler->alt) {
        free((void *)(*(handler->altc + i)));
        i ++;
      }
      free((void *)handler->altc);
    }
    prev = handler;
    handler = handler->next;
    free((void *)prev);
  }
  return;
}
}
void cli_ac_free(struct cl_node *root ) 
{ unsigned int i ;

  {
  i = 0U;
  while (i < root->ac_nodes) {
    cli_freepatt(((*(root->ac_nodetable + i)))->list);
    free((void *)(*(root->ac_nodetable + i)));
    i ++;
  }
  if (root->ac_nodetable) {
    free((void *)root->ac_nodetable);
  }
  if (root->ac_root) {
    free((void *)root->ac_root);
  }
  return;
}
}
__inline static int cli_findpos(char const   *buffer , int offset , int length , struct cli_ac_patt  const  *pattern ) 
{ int bufferpos ;
  int postfixend ;
  unsigned int i ;
  unsigned int j ;
  unsigned int alt ;
  unsigned int found ;

  {
  bufferpos = offset + 2;
  postfixend = offset + length;
  alt = 0U;
  found = 0U;
  if (bufferpos >= length) {
    bufferpos %= length;
  }
  i = 2U;
  while (i < pattern->length) {
    if (bufferpos == postfixend) {
      return (0);
    }
    if ((int )(*(pattern->pattern + i)) == -201) {
      j = 0U;
      while (j < (unsigned int )(*(pattern->altn + alt))) {
        if ((int )(*((*(pattern->altc + alt)) + j)) == (int )(*(buffer + bufferpos))) {
          found = 1U;
        }
        j ++;
      }
      if (! found) {
        return (0);
      }
      alt ++;
    } else {
      if ((int )(*(pattern->pattern + i)) != -200) {
        if ((int )((char )(*(pattern->pattern + i))) != (int )(*(buffer + bufferpos))) {
          return (0);
        }
      }
    }
    bufferpos ++;
    if (bufferpos == length) {
      bufferpos = 0;
    }
    i ++;
  }
  return (1);
}
}
int cli_ac_scanbuff(char const   *buffer , unsigned int length , char const   **virname ,
                    struct cl_node  const  *root , int *partcnt , short otfrec , unsigned long offset ,
                    unsigned long *partoff , unsigned short ftype , int fd ) 
{ struct cli_ac_node *current ;
  struct cli_ac_patt *pt ;
  int position ;
  int type ;
  int dist ;
  int t ;
  unsigned int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  type = 0;
  if (! root->ac_root) {
    return (0);
  }
  if (! partcnt) {
    cli_dbgmsg("cli_ac_scanbuff(): partcnt == NULL || partoff == NULL\n");
    return (300);
  } else {
    if (! partoff) {
      cli_dbgmsg("cli_ac_scanbuff(): partcnt == NULL || partoff == NULL\n");
      return (300);
    }
  }
  current = root->ac_root;
  i = 0U;
  while (i < length) {
    current = current->trans[(int )((unsigned char )(*(buffer + i))) & 255];
    if (current->islast) {
      position = (int )((i - 2U) + 1U);
      pt = current->list;
      while (pt) {
        tmp___0 = cli_findpos(buffer, position, (int )length, (struct cli_ac_patt  const  *)pt);
        if (tmp___0) {
          if (pt->offset) {
            goto _L___1;
          } else {
            if (pt->target) {
              _L___1: 
              if (! pt->sigid) {
                goto _L___0;
              } else {
                if ((int )pt->partno == 1) {
                  _L___0: 
                  if ((int )ftype == 500) {
                    t = type;
                  } else {
                    t = (int )ftype;
                  }
                  if (fd == -1) {
                    if (! t) {
                      pt = pt->next;
                      continue;
                    } else {
                      goto _L;
                    }
                  } else {
                    _L: 
                    tmp = cli_validatesig(pt->target, (unsigned short )t, (char const   *)pt->offset,
                                          offset + (unsigned long )position, fd, (char const   *)pt->virname);
                    if (! tmp) {
                      pt = pt->next;
                      continue;
                    }
                  }
                }
              }
            }
          }
          if (pt->sigid) {
            if ((*(partcnt + (int )pt->sigid)) + 1 == (int )pt->partno) {
              dist = 1;
              if (pt->maxdist) {
                if ((offset + (unsigned long )i) - (*(partoff + (int )pt->sigid)) >
                    (unsigned long )pt->maxdist) {
                  dist = 0;
                }
              }
              if (dist) {
                if (pt->mindist) {
                  if ((offset + (unsigned long )i) - (*(partoff + (int )pt->sigid)) <
                      (unsigned long )pt->mindist) {
                    dist = 0;
                  }
                }
              }
              if (dist) {
                (*(partoff + (int )pt->sigid)) = (offset + (unsigned long )i) + (unsigned long )pt->length;
                (*(partcnt + (int )pt->sigid)) = (*(partcnt + (int )pt->sigid)) +
                                                 1;
                if ((*(partcnt + (int )pt->sigid)) == (int )pt->parts) {
                  if (pt->type) {
                    if (otfrec) {
                      if ((int )pt->type > type) {
                        cli_dbgmsg("Matched signature for file type: %s\n", pt->virname);
                        type = (int )pt->type;
                      }
                    }
                  } else {
                    if (virname) {
                      (*virname) = (char const   *)pt->virname;
                    }
                    return (1);
                  }
                }
              }
            }
          } else {
            if (pt->type) {
              if (otfrec) {
                if ((int )pt->type > type) {
                  cli_dbgmsg("Matched signature for file type: %s\n", pt->virname);
                  type = (int )pt->type;
                }
              }
            } else {
              if (virname) {
                (*virname) = (char const   *)pt->virname;
              }
              return (1);
            }
          }
        }
        pt = pt->next;
      }
      current = current->fail;
    }
    i ++;
  }
  if (otfrec) {
    tmp___1 = type;
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
#pragma merger(0,"/tmp/cil-x4TWP8ug.i","-g -O2 -fPIC")
void cli_errmsg(char const   *str  , ...) ;
void *cli_malloc(size_t size ) ;
int cli_bm_addpatt(struct cl_node *root , struct cli_bm_patt *pattern ) 
{ int i ;
  uint16_t idx ;
  char const   *pt ;
  struct cli_bm_patt *prev ;
  struct cli_bm_patt *next ;

  {
  pt = (char const   *)pattern->pattern;
  next = (struct cli_bm_patt *)((void *)0);
  if (pattern->length < 3U) {
    cli_errmsg("Signature for %s is too short\n", pattern->virname);
    return (-6);
  }
  i = 0;
  while (i >= 0) {
    idx = (unsigned short )((211 * (int )((unsigned char )(*(pt + i))) + 37 * (int )((unsigned char )(*(pt +
                                                                                                        (i +
                                                                                                         1))))) +
                            (int )((unsigned char )(*(pt + (i + 2)))));
    if ((*(root->bm_shift + (int )idx)) < 0 - i) {
      (*(root->bm_shift + (int )idx)) = (*(root->bm_shift + (int )idx));
    } else {
      (*(root->bm_shift + (int )idx)) = 0 - i;
    }
    i --;
  }
  i = 0;
  idx = (unsigned short )((211 * (int )((unsigned char )(*(pt + i))) + 37 * (int )((unsigned char )(*(pt +
                                                                                                      (i +
                                                                                                       1))))) +
                          (int )((unsigned char )(*(pt + (i + 2)))));
  next = (*(root->bm_suffix + (int )idx));
  prev = next;
  while (next) {
    if ((int const   )(*(pt + 0)) >= (int const   )(*(next->pattern + 0))) {
      break;
    }
    prev = next;
    next = next->next;
  }
  if ((unsigned int )next == (unsigned int )(*(root->bm_suffix + (int )idx))) {
    pattern->next = (*(root->bm_suffix + (int )idx));
    (*(root->bm_suffix + (int )idx)) = pattern;
  } else {
    pattern->next = prev->next;
    prev->next = pattern;
  }
  return (0);
}
}
int cli_bm_init(struct cl_node *root ) 
{ unsigned int i ;
  unsigned int size ;

  {
  size = 63744U;
  cli_dbgmsg("in cli_bm_init()\n");
  cli_dbgmsg("BM: Number of indexes = %d\n", size);
  root->bm_shift = (int *)cli_malloc(size * sizeof(int ));
  if (! root->bm_shift) {
    return (-3);
  }
  root->bm_suffix = (struct cli_bm_patt **)cli_calloc(size, sizeof(struct cli_bm_patt *));
  if (! root->bm_suffix) {
    free((void *)root->bm_shift);
    return (-3);
  }
  i = 0U;
  while (i < size) {
    (*(root->bm_shift + i)) = 1;
    i ++;
  }
  return (0);
}
}
void cli_bm_free(struct cl_node *root ) 
{ struct cli_bm_patt *b1 ;
  struct cli_bm_patt *b2 ;
  unsigned int i ;
  unsigned int size ;

  {
  size = 63744U;
  if (root->bm_shift) {
    free((void *)root->bm_shift);
  }
  if (root->bm_suffix) {
    i = 0U;
    while (i < size) {
      b1 = (*(root->bm_suffix + i));
      while (b1) {
        b2 = b1;
        b1 = b1->next;
        if (b2->virname) {
          free((void *)b2->virname);
        }
        if (b2->offset) {
          free((void *)b2->offset);
        }
        if (b2->pattern) {
          free((void *)b2->pattern);
        }
        free((void *)b2);
      }
      i ++;
    }
    free((void *)root->bm_suffix);
  }
  return;
}
}
int cli_bm_scanbuff(char const   *buffer , unsigned int length , char const   **virname ,
                    struct cl_node  const  *root , unsigned long offset , unsigned short ftype ,
                    int fd ) 
{ unsigned int i ;
  unsigned int j ;
  unsigned int shift ;
  unsigned int off ;
  unsigned int found ;
  uint16_t idx ;
  struct cli_bm_patt *p ;
  char const   *bp ;
  char prefix ;
  int tmp ;

  {
  found = 0U;
  if (! root->bm_shift) {
    return (0);
  }
  if (length < 3U) {
    return (0);
  }
  i = 0U;
  while (i < (length - 3U) + 1U) {
    idx = (unsigned short )((211 * (int )((unsigned char )(*(buffer + i))) + 37 *
                                                                             (int )((unsigned char )(*(buffer +
                                                                                                       (i +
                                                                                                        1U))))) +
                            (int )((unsigned char )(*(buffer + (i + 2U)))));
    shift = (unsigned int )(*(root->bm_shift + (int )idx));
    if (shift == 0U) {
      prefix = (char )(*(buffer + ((i - 3U) + 3U)));
      p = (*(root->bm_suffix + (int )idx));
      while (1) {
        if (p) {
          if (! ((int )(*(p->pattern + 0)) != (int )prefix)) {
            break;
          }
        } else {
          break;
        }
        p = p->next;
      }
      while (1) {
        if (p) {
          if (! ((int )(*(p->pattern + 0)) == (int )prefix)) {
            break;
          }
        } else {
          break;
        }
        off = (i - 3U) + 3U;
        bp = buffer + off;
        found = 1U;
        j = 0U;
        while (1) {
          if (j < p->length) {
            if (! (off < length)) {
              break;
            }
          } else {
            break;
          }
          if ((int const   )(*(bp + j)) != (int const   )(*(p->pattern + j))) {
            found = 0U;
            break;
          }
          j ++;
          off ++;
        }
        if (found) {
          if (p->length == j) {
            if (p->target) {
              goto _L___0;
            } else {
              if (p->offset) {
                _L___0: 
                off = (unsigned int )(((offset + (unsigned long )i) - 3UL) + 3UL);
                if (fd == -1) {
                  if (! ftype) {
                    p = p->next;
                    continue;
                  } else {
                    goto _L;
                  }
                } else {
                  _L: 
                  tmp = cli_validatesig(p->target, ftype, (char const   *)p->offset,
                                        (unsigned long )off, fd, (char const   *)p->virname);
                  if (! tmp) {
                    p = p->next;
                    continue;
                  }
                }
              }
            }
            if (virname) {
              (*virname) = (char const   *)p->virname;
            }
            return (1);
          }
        }
        p = p->next;
      }
      shift = 1U;
    }
    i += shift;
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-T9yrNQ4L.i","-g -O2 -fPIC")
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
__inline static  __attribute__((__nothrow__)) int fstat__extinline(int __fd , struct stat *__statbuf ) ;
__inline static  __attribute__((__nothrow__)) int fstat__extinline(int __fd , struct stat *__statbuf ) ;
__inline static int fstat__extinline(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
  tmp = __fxstat(3, __fd, __statbuf);
  return (tmp);
}
}
__off_t lseek(int __fd , __off_t __offset , int __whence );
int cl_scanbuff(char const   *buffer , unsigned int length , char const   **virname ,
                struct cl_node  const  *root ) ;
struct cl_node *cl_dup(struct cl_node *root ) ;
int cl_build(struct cl_node *root ) ;
void cl_free(struct cl_node *root ) ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
__inline static  __attribute__((__nothrow__)) long strtol__extinline(char const   * __restrict  __nptr ,
                                                                     char ** __restrict  __endptr ,
                                                                     int __base ) ;
__inline static  __attribute__((__nothrow__)) int atoi__extinline(char const   *__nptr ) ;
void cli_warnmsg(char const   *str  , ...) ;
unsigned char *cli_md5digest(int desc ) ;
int cli_scandesc(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                 short otfrec , unsigned short ftype ) ;
int cli_scanbuff(char const   *buffer , unsigned int length , char const   **virname ,
                 struct cl_node  const  *root , unsigned short ftype ) ;
int cli_checkfp(int fd , struct cl_node  const  *root ) ;
void MD5_Init(MD5_CTX *ctx ) ;
void MD5_Update(MD5_CTX *ctx , void *data , unsigned long size ) ;
void MD5_Final(unsigned char *result , MD5_CTX *ctx ) ;
int cli_peheader(int desc , struct cli_pe_info *peinfo ) ;
static int targettab[6]  = {      0,      502,      511,      519, 
        520,      515};
short cli_debug_flag ;
struct __anonstruct_pthread_mutex_t_16 cli_ref_mutex  =    {0, 0, (struct _pthread_descr_struct *)0, 0, {0L, 0}};
int cli_scanbuff(char const   *buffer , unsigned int length , char const   **virname ,
                 struct cl_node  const  *root , unsigned short ftype ) 
{ int ret ;
  int *partcnt ;
  unsigned long *partoff ;

  {
  partcnt = (int *)cli_calloc(root->ac_partsigs + 1U, sizeof(int ));
  if ((unsigned int )partcnt == (unsigned int )((void *)0)) {
    cli_dbgmsg("cl_scanbuff(): unable to cli_calloc(%d, %d)\n", root->ac_partsigs +
                                                                1U, sizeof(int ));
    return (-3);
  }
  partoff = (unsigned long *)cli_calloc(root->ac_partsigs + 1U, sizeof(unsigned long ));
  if ((unsigned int )partoff == (unsigned int )((void *)0)) {
    cli_dbgmsg("cl_scanbuff(): unable to cli_calloc(%d, %d)\n", root->ac_partsigs +
                                                                1U, sizeof(unsigned long ));
    free((void *)partcnt);
    return (-3);
  }
  ret = cli_bm_scanbuff(buffer, length, virname, root, 0UL, ftype, -1);
  if (ret != 1) {
    ret = cli_ac_scanbuff(buffer, length, virname, root, partcnt, (short)0, 0UL, partoff,
                          ftype, -1);
  }
  free((void *)partcnt);
  free((void *)partoff);
  return (ret);
}
}
int cl_scanbuff(char const   *buffer , unsigned int length , char const   **virname ,
                struct cl_node  const  *root ) 
{ int tmp ;

  {
  tmp = cli_scanbuff(buffer, length, virname, root, (unsigned short)0);
  return (tmp);
}
}
static struct cli_md5_node *cli_vermd5(unsigned char const   *md5 , struct cl_node  const  *root ) 
{ struct cli_md5_node *pt ;
  int tmp ;

  {
  pt = (*(root->md5_hlist + ((int const   )(*(md5 + 0)) & 255)));
  if (! pt) {
    return ((struct cli_md5_node *)((void *)0));
  }
  while (pt) {
    tmp = memcmp((void const   *)pt->md5, (void const   *)md5, 16U);
    if (! tmp) {
      return (pt);
    }
    pt = pt->next;
  }
  return ((struct cli_md5_node *)((void *)0));
}
}
static long cli_caloff(char const   *offstr , int fd ) 
{ struct cli_pe_info peinfo ;
  long offset ;
  int n ;
  long tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___80 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___116 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___135 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  size_t tmp___151 ;
  int tmp___152 ;
  size_t tmp___153 ;
  struct stat sb ;
  int tmp___154 ;
  int tmp___155 ;
  int tmp___230 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___266 ;
  unsigned char const   *__s2___30 ;
  register int __result___90 ;
  int tmp___285 ;
  unsigned char const   *__s1___62 ;
  register int __result___94 ;
  int tmp___294 ;
  int tmp___295 ;
  int tmp___296 ;
  int tmp___297 ;
  int tmp___298 ;
  int tmp___299 ;
  int tmp___300 ;
  size_t tmp___301 ;
  int tmp___302 ;
  size_t tmp___303 ;
  int tmp___378 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___414 ;
  unsigned char const   *__s2___46 ;
  register int __result___138 ;
  int tmp___433 ;
  unsigned char const   *__s1___94 ;
  register int __result___142 ;
  int tmp___442 ;
  int tmp___443 ;
  int tmp___444 ;
  int tmp___445 ;
  int tmp___446 ;
  int tmp___447 ;
  int tmp___448 ;
  size_t tmp___449 ;
  int tmp___450 ;
  size_t tmp___451 ;

  {
  offset = -1L;
  tmp___0 = __ctype_b_loc();
  if ((int const   )(*((*tmp___0) + (int )(*(offstr + 0)))) & 2048) {
    tmp = (long )atoi__extinline(offstr);
    return (tmp);
  }
  tmp___448 = __builtin_constant_p((int )offstr);
  if (tmp___448) {
    tmp___449 = strlen(offstr);
    if (tmp___449 < 3U) {
      goto _L___123;
    } else {
      goto _L___124;
    }
  } else {
    _L___124: 
    tmp___450 = __builtin_constant_p((int )"EP+");
    if (tmp___450) {
      tmp___451 = strlen("EP+");
      if (tmp___451 < 3U) {
        _L___123: 
        tmp___445 = __builtin_constant_p((int )offstr);
        if (tmp___445) {
          tmp___446 = __builtin_constant_p((int )"EP+");
          if (tmp___446) {
            __s1_len___4 = strlen(offstr);
            __s2_len___4 = strlen("EP+");
            if (! ((unsigned int )((void const   *)(offstr + 1)) - (unsigned int )((void const   *)offstr) ==
                   1U)) {
              goto _L___120;
            } else {
              if (__s1_len___4 >= 4U) {
                _L___120: 
                if (! ((unsigned int )((void const   *)("EP+" + 1)) - (unsigned int )((void const   *)"EP+") ==
                       1U)) {
                  tmp___447 = 1;
                } else {
                  if (__s2_len___4 >= 4U) {
                    tmp___447 = 1;
                  } else {
                    tmp___447 = 0;
                  }
                }
              } else {
                tmp___447 = 0;
              }
            }
            if (tmp___447) {
              tmp___414 = __builtin_strcmp(offstr, "EP+");
            } else {
              goto _L___122;
            }
          } else {
            goto _L___122;
          }
        } else {
          _L___122: 
          tmp___444 = __builtin_constant_p((int )offstr);
          if (tmp___444) {
            if ((unsigned int )((void const   *)(offstr + 1)) - (unsigned int )((void const   *)offstr) ==
                1U) {
              __s1_len___4 = strlen(offstr);
              if (__s1_len___4 < 4U) {
                tmp___433 = __builtin_constant_p((int )"EP+");
                if (tmp___433) {
                  if ((unsigned int )((void const   *)("EP+" + 1)) - (unsigned int )((void const   *)"EP+") ==
                      1U) {
                    tmp___414 = __builtin_strcmp(offstr, "EP+");
                  } else {
                    goto _L___115;
                  }
                } else {
                  _L___115: 
                  __s2___46 = (unsigned char const   *)"EP+";
                  __result___138 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                           0)) - (int const   )(*(__s2___46 +
                                                                                  0)));
                  if (__s1_len___4 > 0U) {
                    if (__result___138 == 0) {
                      __result___138 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                               1)) - (int const   )(*(__s2___46 +
                                                                                      1)));
                      if (__s1_len___4 > 1U) {
                        if (__result___138 == 0) {
                          __result___138 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                                   2)) - (int const   )(*(__s2___46 +
                                                                                          2)));
                          if (__s1_len___4 > 2U) {
                            if (__result___138 == 0) {
                              __result___138 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                                       3)) - (int const   )(*(__s2___46 +
                                                                                              3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___414 = __result___138;
                }
              } else {
                goto _L___119;
              }
            } else {
              goto _L___119;
            }
          } else {
            _L___119: 
            tmp___443 = __builtin_constant_p((int )"EP+");
            if (tmp___443) {
              if ((unsigned int )((void const   *)("EP+" + 1)) - (unsigned int )((void const   *)"EP+") ==
                  1U) {
                __s2_len___4 = strlen("EP+");
                if (__s2_len___4 < 4U) {
                  tmp___442 = __builtin_constant_p((int )offstr);
                  if (tmp___442) {
                    if ((unsigned int )((void const   *)(offstr + 1)) - (unsigned int )((void const   *)offstr) ==
                        1U) {
                      tmp___414 = __builtin_strcmp(offstr, "EP+");
                    } else {
                      goto _L___117;
                    }
                  } else {
                    _L___117: 
                    __s1___94 = (unsigned char const   *)offstr;
                    __result___142 = (int )((int const   )(*(__s1___94 + 0)) - (int const   )(*((unsigned char const   *)"EP+" +
                                                                                                0)));
                    if (__s2_len___4 > 0U) {
                      if (__result___142 == 0) {
                        __result___142 = (int )((int const   )(*(__s1___94 + 1)) -
                                                (int const   )(*((unsigned char const   *)"EP+" +
                                                                 1)));
                        if (__s2_len___4 > 1U) {
                          if (__result___142 == 0) {
                            __result___142 = (int )((int const   )(*(__s1___94 + 2)) -
                                                    (int const   )(*((unsigned char const   *)"EP+" +
                                                                     2)));
                            if (__s2_len___4 > 2U) {
                              if (__result___142 == 0) {
                                __result___142 = (int )((int const   )(*(__s1___94 +
                                                                         3)) - (int const   )(*((unsigned char const   *)"EP+" +
                                                                                                3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___414 = __result___142;
                  }
                } else {
                  tmp___414 = __builtin_strcmp(offstr, "EP+");
                }
              } else {
                tmp___414 = __builtin_strcmp(offstr, "EP+");
              }
            } else {
              tmp___414 = __builtin_strcmp(offstr, "EP+");
            }
          }
        }
        tmp___378 = tmp___414;
      } else {
        tmp___378 = strncmp(offstr, "EP+", 3U);
      }
    } else {
      tmp___378 = strncmp(offstr, "EP+", 3U);
    }
  }
  if (tmp___378) {
    if ((int const   )(*(offstr + 0)) == 83) {
      n = (int )lseek(fd, 0L, 1);
      if (n == -1) {
        cli_dbgmsg("Invalid descriptor\n");
        return (-1L);
      }
      lseek(fd, 0L, 0);
      tmp___3 = cli_peheader(fd, & peinfo);
      if (tmp___3) {
        lseek(fd, (long )n, 0);
        return (-1L);
      }
      lseek(fd, (long )n, 0);
      tmp___150 = __builtin_constant_p((int )offstr);
      if (tmp___150) {
        tmp___151 = strlen(offstr);
        if (tmp___151 < 2U) {
          goto _L___39;
        } else {
          goto _L___40;
        }
      } else {
        _L___40: 
        tmp___152 = __builtin_constant_p((int )"SL");
        if (tmp___152) {
          tmp___153 = strlen("SL");
          if (tmp___153 < 2U) {
            _L___39: 
            tmp___147 = __builtin_constant_p((int )offstr);
            if (tmp___147) {
              tmp___148 = __builtin_constant_p((int )"SL");
              if (tmp___148) {
                __s1_len___0 = strlen(offstr);
                __s2_len___0 = strlen("SL");
                if (! ((unsigned int )((void const   *)(offstr + 1)) - (unsigned int )((void const   *)offstr) ==
                       1U)) {
                  goto _L___36;
                } else {
                  if (__s1_len___0 >= 4U) {
                    _L___36: 
                    if (! ((unsigned int )((void const   *)("SL" + 1)) - (unsigned int )((void const   *)"SL") ==
                           1U)) {
                      tmp___149 = 1;
                    } else {
                      if (__s2_len___0 >= 4U) {
                        tmp___149 = 1;
                      } else {
                        tmp___149 = 0;
                      }
                    }
                  } else {
                    tmp___149 = 0;
                  }
                }
                if (tmp___149) {
                  tmp___116 = __builtin_strcmp(offstr, "SL");
                } else {
                  goto _L___38;
                }
              } else {
                goto _L___38;
              }
            } else {
              _L___38: 
              tmp___146 = __builtin_constant_p((int )offstr);
              if (tmp___146) {
                if ((unsigned int )((void const   *)(offstr + 1)) - (unsigned int )((void const   *)offstr) ==
                    1U) {
                  __s1_len___0 = strlen(offstr);
                  if (__s1_len___0 < 4U) {
                    tmp___135 = __builtin_constant_p((int )"SL");
                    if (tmp___135) {
                      if ((unsigned int )((void const   *)("SL" + 1)) - (unsigned int )((void const   *)"SL") ==
                          1U) {
                        tmp___116 = __builtin_strcmp(offstr, "SL");
                      } else {
                        goto _L___31;
                      }
                    } else {
                      _L___31: 
                      __s2___14 = (unsigned char const   *)"SL";
                      __result___42 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                              0)) - (int const   )(*(__s2___14 +
                                                                                     0)));
                      if (__s1_len___0 > 0U) {
                        if (__result___42 == 0) {
                          __result___42 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                                  1)) - (int const   )(*(__s2___14 +
                                                                                         1)));
                          if (__s1_len___0 > 1U) {
                            if (__result___42 == 0) {
                              __result___42 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                                      2)) - (int const   )(*(__s2___14 +
                                                                                             2)));
                              if (__s1_len___0 > 2U) {
                                if (__result___42 == 0) {
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                                          3)) - (int const   )(*(__s2___14 +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___116 = __result___42;
                    }
                  } else {
                    goto _L___35;
                  }
                } else {
                  goto _L___35;
                }
              } else {
                _L___35: 
                tmp___145 = __builtin_constant_p((int )"SL");
                if (tmp___145) {
                  if ((unsigned int )((void const   *)("SL" + 1)) - (unsigned int )((void const   *)"SL") ==
                      1U) {
                    __s2_len___0 = strlen("SL");
                    if (__s2_len___0 < 4U) {
                      tmp___144 = __builtin_constant_p((int )offstr);
                      if (tmp___144) {
                        if ((unsigned int )((void const   *)(offstr + 1)) - (unsigned int )((void const   *)offstr) ==
                            1U) {
                          tmp___116 = __builtin_strcmp(offstr, "SL");
                        } else {
                          goto _L___33;
                        }
                      } else {
                        _L___33: 
                        __s1___30 = (unsigned char const   *)offstr;
                        __result___46 = (int )((int const   )(*(__s1___30 + 0)) -
                                               (int const   )(*((unsigned char const   *)"SL" +
                                                                0)));
                        if (__s2_len___0 > 0U) {
                          if (__result___46 == 0) {
                            __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                   (int const   )(*((unsigned char const   *)"SL" +
                                                                    1)));
                            if (__s2_len___0 > 1U) {
                              if (__result___46 == 0) {
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        2)) - (int const   )(*((unsigned char const   *)"SL" +
                                                                                               2)));
                                if (__s2_len___0 > 2U) {
                                  if (__result___46 == 0) {
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            3)) -
                                                           (int const   )(*((unsigned char const   *)"SL" +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
                        tmp___116 = __result___46;
                      }
                    } else {
                      tmp___116 = __builtin_strcmp(offstr, "SL");
                    }
                  } else {
                    tmp___116 = __builtin_strcmp(offstr, "SL");
                  }
                } else {
                  tmp___116 = __builtin_strcmp(offstr, "SL");
                }
              }
            }
            tmp___80 = tmp___116;
          } else {
            tmp___80 = strncmp(offstr, "SL", 2U);
          }
        } else {
          tmp___80 = strncmp(offstr, "SL", 2U);
        }
      }
      if (tmp___80) {
        tmp___5 = sscanf((char const   * __restrict  )offstr, (char const   * __restrict  )"S%d+%ld",
                         & n, & offset);
        if (tmp___5 != 2) {
          free((void *)peinfo.section);
          return (-1L);
        }
        if (n >= (int )peinfo.nsections) {
          free((void *)peinfo.section);
          return (-1L);
        }
        offset = (long )((unsigned long )offset + (unsigned long )(peinfo.section +
                                                                   n)->raw);
      } else {
        tmp___4 = sscanf((char const   * __restrict  )offstr, (char const   * __restrict  )"SL+%ld",
                         & offset);
        if (tmp___4 != 1) {
          free((void *)peinfo.section);
          return (-1L);
        }
        offset = (long )((unsigned long )offset + (unsigned long )(peinfo.section +
                                                                   ((int )peinfo.nsections -
                                                                    1))->raw);
      }
      free((void *)peinfo.section);
      return (offset);
    } else {
      tmp___300 = __builtin_constant_p((int )offstr);
      if (tmp___300) {
        tmp___301 = strlen(offstr);
        if (tmp___301 < 4U) {
          goto _L___81;
        } else {
          goto _L___82;
        }
      } else {
        _L___82: 
        tmp___302 = __builtin_constant_p((int )"EOF-");
        if (tmp___302) {
          tmp___303 = strlen("EOF-");
          if (tmp___303 < 4U) {
            _L___81: 
            tmp___297 = __builtin_constant_p((int )offstr);
            if (tmp___297) {
              tmp___298 = __builtin_constant_p((int )"EOF-");
              if (tmp___298) {
                __s1_len___2 = strlen(offstr);
                __s2_len___2 = strlen("EOF-");
                if (! ((unsigned int )((void const   *)(offstr + 1)) - (unsigned int )((void const   *)offstr) ==
                       1U)) {
                  goto _L___78;
                } else {
                  if (__s1_len___2 >= 4U) {
                    _L___78: 
                    if (! ((unsigned int )((void const   *)("EOF-" + 1)) - (unsigned int )((void const   *)"EOF-") ==
                           1U)) {
                      tmp___299 = 1;
                    } else {
                      if (__s2_len___2 >= 4U) {
                        tmp___299 = 1;
                      } else {
                        tmp___299 = 0;
                      }
                    }
                  } else {
                    tmp___299 = 0;
                  }
                }
                if (tmp___299) {
                  tmp___266 = __builtin_strcmp(offstr, "EOF-");
                } else {
                  goto _L___80;
                }
              } else {
                goto _L___80;
              }
            } else {
              _L___80: 
              tmp___296 = __builtin_constant_p((int )offstr);
              if (tmp___296) {
                if ((unsigned int )((void const   *)(offstr + 1)) - (unsigned int )((void const   *)offstr) ==
                    1U) {
                  __s1_len___2 = strlen(offstr);
                  if (__s1_len___2 < 4U) {
                    tmp___285 = __builtin_constant_p((int )"EOF-");
                    if (tmp___285) {
                      if ((unsigned int )((void const   *)("EOF-" + 1)) - (unsigned int )((void const   *)"EOF-") ==
                          1U) {
                        tmp___266 = __builtin_strcmp(offstr, "EOF-");
                      } else {
                        goto _L___73;
                      }
                    } else {
                      _L___73: 
                      __s2___30 = (unsigned char const   *)"EOF-";
                      __result___90 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                              0)) - (int const   )(*(__s2___30 +
                                                                                     0)));
                      if (__s1_len___2 > 0U) {
                        if (__result___90 == 0) {
                          __result___90 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                                  1)) - (int const   )(*(__s2___30 +
                                                                                         1)));
                          if (__s1_len___2 > 1U) {
                            if (__result___90 == 0) {
                              __result___90 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                                      2)) - (int const   )(*(__s2___30 +
                                                                                             2)));
                              if (__s1_len___2 > 2U) {
                                if (__result___90 == 0) {
                                  __result___90 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                                          3)) - (int const   )(*(__s2___30 +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___266 = __result___90;
                    }
                  } else {
                    goto _L___77;
                  }
                } else {
                  goto _L___77;
                }
              } else {
                _L___77: 
                tmp___295 = __builtin_constant_p((int )"EOF-");
                if (tmp___295) {
                  if ((unsigned int )((void const   *)("EOF-" + 1)) - (unsigned int )((void const   *)"EOF-") ==
                      1U) {
                    __s2_len___2 = strlen("EOF-");
                    if (__s2_len___2 < 4U) {
                      tmp___294 = __builtin_constant_p((int )offstr);
                      if (tmp___294) {
                        if ((unsigned int )((void const   *)(offstr + 1)) - (unsigned int )((void const   *)offstr) ==
                            1U) {
                          tmp___266 = __builtin_strcmp(offstr, "EOF-");
                        } else {
                          goto _L___75;
                        }
                      } else {
                        _L___75: 
                        __s1___62 = (unsigned char const   *)offstr;
                        __result___94 = (int )((int const   )(*(__s1___62 + 0)) -
                                               (int const   )(*((unsigned char const   *)"EOF-" +
                                                                0)));
                        if (__s2_len___2 > 0U) {
                          if (__result___94 == 0) {
                            __result___94 = (int )((int const   )(*(__s1___62 + 1)) -
                                                   (int const   )(*((unsigned char const   *)"EOF-" +
                                                                    1)));
                            if (__s2_len___2 > 1U) {
                              if (__result___94 == 0) {
                                __result___94 = (int )((int const   )(*(__s1___62 +
                                                                        2)) - (int const   )(*((unsigned char const   *)"EOF-" +
                                                                                               2)));
                                if (__s2_len___2 > 2U) {
                                  if (__result___94 == 0) {
                                    __result___94 = (int )((int const   )(*(__s1___62 +
                                                                            3)) -
                                                           (int const   )(*((unsigned char const   *)"EOF-" +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
                        tmp___266 = __result___94;
                      }
                    } else {
                      tmp___266 = __builtin_strcmp(offstr, "EOF-");
                    }
                  } else {
                    tmp___266 = __builtin_strcmp(offstr, "EOF-");
                  }
                } else {
                  tmp___266 = __builtin_strcmp(offstr, "EOF-");
                }
              }
            }
            tmp___230 = tmp___266;
          } else {
            tmp___230 = strncmp(offstr, "EOF-", 4U);
          }
        } else {
          tmp___230 = strncmp(offstr, "EOF-", 4U);
        }
      }
      if (! tmp___230) {
        tmp___154 = fstat__extinline(fd, & sb);
        if (tmp___154 == -1) {
          return (-1L);
        }
        tmp___155 = atoi__extinline(offstr + 4);
        return (sb.st_size - (long )tmp___155);
      }
    }
  } else {
    n = (int )lseek(fd, 0L, 1);
    if (n == -1) {
      cli_dbgmsg("Invalid descriptor\n");
      return (-1L);
    }
    lseek(fd, 0L, 0);
    tmp___1 = cli_peheader(fd, & peinfo);
    if (tmp___1) {
      lseek(fd, (long )n, 0);
      return (-1L);
    }
    free((void *)peinfo.section);
    lseek(fd, (long )n, 0);
    tmp___2 = atoi__extinline(offstr + 3);
    return ((long )(peinfo.ep + (unsigned int )tmp___2));
  }
  return (-1L);
}
}
int cli_checkfp(int fd , struct cl_node  const  *root ) 
{ struct cli_md5_node *md5_node ;
  char *digest ;
  struct stat sb ;
  int tmp ;

  {
  if (root->md5_hlist) {
    digest = (char *)cli_md5digest(fd);
    if (! digest) {
      cli_errmsg("cli_checkfp(): Can\'t generate MD5 checksum\n");
      return (0);
    }
    md5_node = cli_vermd5((unsigned char const   *)digest, root);
    if (md5_node) {
      if (md5_node->fp) {
        tmp = fstat__extinline(fd, & sb);
        if (tmp) {
          return (-12);
        }
        if ((unsigned int )sb.st_size != md5_node->size) {
          cli_warnmsg("Detected false positive MD5 match. Please report.\n");
        } else {
          cli_dbgmsg("Eliminated false positive match (fp sig: %s)\n", md5_node->virname);
          free((void *)digest);
          return (1);
        }
      }
    }
    free((void *)digest);
  }
  return (0);
}
}
int cli_validatesig(unsigned short target , unsigned short ftype , char const   *offstr ,
                    unsigned long fileoff , int desc , char const   *virname ) 
{ long off ;
  long tmp ;

  {
  if (target) {
    if ((int )target >= 6) {
      cli_errmsg("Bad target in signature (%s)\n", virname);
      return (0);
    } else {
      if (targettab[target] != (int )ftype) {
        cli_dbgmsg("Type: %d, expected: %d (%s)\n", ftype, targettab[target], virname);
        return (0);
      }
    }
  }
  if (offstr) {
    if (desc != -1) {
      tmp = cli_caloff(offstr, desc);
      off = tmp;
      if (off == -1L) {
        cli_dbgmsg("Bad offset in signature (%s)\n", virname);
        return (0);
      }
      if (fileoff != (unsigned long )off) {
        cli_dbgmsg("Virus offset: %d, expected: %d (%s)\n", fileoff, off, virname);
        return (0);
      }
    }
  }
  return (1);
}
}
int cli_scandesc(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                 short otfrec , unsigned short ftype ) 
{ char *buffer ;
  char *buff ;
  char *endbl ;
  char *pt ;
  int bytes ;
  int buffsize ;
  int length ;
  int ret ;
  int *partcnt ;
  int type ;
  unsigned long *partoff ;
  unsigned long offset ;
  MD5_CTX ctx ;
  unsigned char digest[16] ;
  struct cli_md5_node *md5_node ;
  int tmp___2 ;
  int tmp___3 ;
  char md5str[33] ;
  int i ;
  struct stat sb ;
  int tmp___4 ;
  int tmp___5 ;

  {
  type = 0;
  offset = 0UL;
  if (! root) {
    cli_errmsg("cli_scandesc: root == NULL\n");
    return (300);
  }
  buffsize = (int )(root->maxpatlen + 131072U);
  buffer = (char *)cli_calloc((unsigned int )buffsize, sizeof(char ));
  if (! buffer) {
    cli_dbgmsg("cli_scandesc(): unable to cli_calloc(%d)\n", buffsize);
    return (-3);
  }
  partcnt = (int *)cli_calloc(root->ac_partsigs + 1U, sizeof(int ));
  if ((unsigned int )partcnt == (unsigned int )((void *)0)) {
    cli_dbgmsg("cli_scandesc(): unable to cli_calloc(%d, %d)\n", root->ac_partsigs +
                                                                 1U, sizeof(int ));
    free((void *)buffer);
    return (-3);
  }
  partoff = (unsigned long *)cli_calloc(root->ac_partsigs + 1U, sizeof(unsigned long ));
  if ((unsigned int )partoff == (unsigned int )((void *)0)) {
    cli_dbgmsg("cli_scandesc(): unable to cli_calloc(%d, %d)\n", root->ac_partsigs +
                                                                 1U, sizeof(unsigned long ));
    free((void *)buffer);
    free((void *)partcnt);
    return (-3);
  }
  if (root->md5_hlist) {
    MD5_Init(& ctx);
  }
  buff = buffer;
  buff += root->maxpatlen;
  endbl = (buff + 131072) - root->maxpatlen;
  pt = buff;
  length = 131072;
  while (1) {
    bytes = read(desc, (void *)buff, 131072U);
    if (! (bytes > 0)) {
      break;
    }
    if (scanned) {
      (*scanned) += (long )(bytes / 4096);
    }
    if (bytes < 131072) {
      length -= 131072 - bytes;
    }
    tmp___3 = cli_bm_scanbuff((char const   *)pt, (unsigned int )length, virname,
                              root, offset, ftype, desc);
    if (tmp___3 == 1) {
      goto _L;
    } else {
      ret = cli_ac_scanbuff((char const   *)pt, (unsigned int )length, virname, root,
                            partcnt, otfrec, offset, partoff, ftype, desc);
      if (ret == 1) {
        _L: 
        free((void *)buffer);
        free((void *)partcnt);
        free((void *)partoff);
        lseek(desc, 0L, 0);
        tmp___2 = cli_checkfp(desc, root);
        if (tmp___2) {
          return (0);
        } else {
          return (1);
        }
      } else {
        if (otfrec) {
          if (ret >= 500) {
            if (ret >= type) {
              type = ret;
            }
          }
        }
      }
    }
    if (bytes == 131072) {
      memmove((void *)buffer, (void const   *)endbl, root->maxpatlen);
      if ((unsigned int )pt == (unsigned int )buffer) {
        offset += 131072UL;
      } else {
        offset += (unsigned long )(131072U - root->maxpatlen);
        pt = buffer;
        length = buffsize;
      }
    }
    if (root->md5_hlist) {
      MD5_Update(& ctx, (void *)buff, (unsigned long )bytes);
    }
  }
  free((void *)buffer);
  free((void *)partcnt);
  free((void *)partoff);
  if (root->md5_hlist) {
    MD5_Final(digest, & ctx);
    if (cli_debug_flag) {
      pt = md5str;
      i = 0;
      while (i < 16) {
        sprintf((char * __restrict  )pt, (char const   * __restrict  )"%02x", digest[i]);
        pt += 2;
        i ++;
      }
      md5str[32] = (char)0;
      cli_dbgmsg("Calculated MD5 checksum: %s\n", md5str);
    }
    md5_node = cli_vermd5((unsigned char const   *)(digest), root);
    if (md5_node) {
      if (! md5_node->fp) {
        tmp___4 = fstat__extinline(desc, & sb);
        if (tmp___4) {
          return (-12);
        }
        if ((unsigned int )sb.st_size != md5_node->size) {
          cli_warnmsg("Detected false positive MD5 match. Please report.\n");
        } else {
          if (virname) {
            (*virname) = (char const   *)md5_node->virname;
          }
          return (1);
        }
      }
    }
  }
  if (otfrec) {
    tmp___5 = type;
  } else {
    tmp___5 = 0;
  }
  return (tmp___5);
}
}
int cl_build(struct cl_node *root ) 
{ int tmp ;

  {
  tmp = cli_ac_buildtrie(root);
  return (tmp);
}
}
struct cl_node *cl_dup(struct cl_node *root ) 
{ 

  {
  if (! root) {
    cli_errmsg("cl_dup: root == NULL\n");
    return ((struct cl_node *)((void *)0));
  }
  pthread_mutex_lock(& cli_ref_mutex);
  root->refcount = root->refcount + 1U;
  pthread_mutex_unlock(& cli_ref_mutex);
  return (root);
}
}
void cl_free(struct cl_node *root ) 
{ int i ;
  struct cli_md5_node *md5pt ;
  struct cli_md5_node *md5h ;
  struct cli_meta_node *metapt ;
  struct cli_meta_node *metah ;

  {
  if (! root) {
    cli_errmsg("cl_free: root == NULL\n");
    return;
  }
  pthread_mutex_lock(& cli_ref_mutex);
  root->refcount = root->refcount - 1U;
  if (root->refcount) {
    pthread_mutex_unlock(& cli_ref_mutex);
    return;
  }
  pthread_mutex_unlock(& cli_ref_mutex);
  cli_ac_free(root);
  cli_bm_free(root);
  if (root->md5_hlist) {
    i = 0;
    while (i < 256) {
      md5pt = (*(root->md5_hlist + i));
      while (md5pt) {
        md5h = md5pt;
        md5pt = md5pt->next;
        free((void *)md5h->md5);
        free((void *)md5h->virname);
        if (md5h->viralias) {
          free((void *)md5h->viralias);
        }
        free((void *)md5h);
      }
      i ++;
    }
    free((void *)root->md5_hlist);
  }
  metapt = root->zip_mlist;
  while (metapt) {
    metah = metapt;
    metapt = metapt->next;
    free((void *)metah->virname);
    if (metah->filename) {
      free((void *)metah->filename);
    }
    free((void *)metah);
  }
  metapt = root->rar_mlist;
  while (metapt) {
    metah = metapt;
    metapt = metapt->next;
    free((void *)metah->virname);
    if (metah->filename) {
      free((void *)metah->filename);
    }
    free((void *)metah);
  }
  free((void *)root);
  return;
}
}
int cl_buildtrie(struct cl_node *root ) 
{ int tmp ;

  {
  tmp = cl_build(root);
  return (tmp);
}
}
void cl_freetrie(struct cl_node *root ) 
{ 

  {
  cl_free(root);
  return;
}
}
#pragma merger(0,"/tmp/cil-dLi3voFN.i","-g -O2 -fPIC")
static void *body(MD5_CTX *ctx , void *data , unsigned long size ) 
{ unsigned char *ptr ;
  MD5_u32plus a ;
  MD5_u32plus b ;
  MD5_u32plus c ;
  MD5_u32plus d ;
  MD5_u32plus saved_a ;
  MD5_u32plus saved_b ;
  MD5_u32plus saved_c ;
  MD5_u32plus saved_d ;

  {
  ptr = (unsigned char *)data;
  a = ctx->a;
  b = ctx->b;
  c = ctx->c;
  d = ctx->d;
  while (1) {
    saved_a = a;
    saved_b = b;
    saved_c = c;
    saved_d = d;
    a += ((d ^ (b & (c ^ d))) + (*((MD5_u32plus *)(ptr + 0)))) + 3614090360UL;
    a = (a << 7) | ((a & 4294967295UL) >> 25);
    a += b;
    d += ((c ^ (a & (b ^ c))) + (*((MD5_u32plus *)(ptr + 4)))) + 3905402710UL;
    d = (d << 12) | ((d & 4294967295UL) >> 20);
    d += a;
    c += ((b ^ (d & (a ^ b))) + (*((MD5_u32plus *)(ptr + 8)))) + 606105819UL;
    c = (c << 17) | ((c & 4294967295UL) >> 15);
    c += d;
    b += ((a ^ (c & (d ^ a))) + (*((MD5_u32plus *)(ptr + 12)))) + 3250441966UL;
    b = (b << 22) | ((b & 4294967295UL) >> 10);
    b += c;
    a += ((d ^ (b & (c ^ d))) + (*((MD5_u32plus *)(ptr + 16)))) + 4118548399UL;
    a = (a << 7) | ((a & 4294967295UL) >> 25);
    a += b;
    d += ((c ^ (a & (b ^ c))) + (*((MD5_u32plus *)(ptr + 20)))) + 1200080426UL;
    d = (d << 12) | ((d & 4294967295UL) >> 20);
    d += a;
    c += ((b ^ (d & (a ^ b))) + (*((MD5_u32plus *)(ptr + 24)))) + 2821735955UL;
    c = (c << 17) | ((c & 4294967295UL) >> 15);
    c += d;
    b += ((a ^ (c & (d ^ a))) + (*((MD5_u32plus *)(ptr + 28)))) + 4249261313UL;
    b = (b << 22) | ((b & 4294967295UL) >> 10);
    b += c;
    a += ((d ^ (b & (c ^ d))) + (*((MD5_u32plus *)(ptr + 32)))) + 1770035416UL;
    a = (a << 7) | ((a & 4294967295UL) >> 25);
    a += b;
    d += ((c ^ (a & (b ^ c))) + (*((MD5_u32plus *)(ptr + 36)))) + 2336552879UL;
    d = (d << 12) | ((d & 4294967295UL) >> 20);
    d += a;
    c += ((b ^ (d & (a ^ b))) + (*((MD5_u32plus *)(ptr + 40)))) + 4294925233UL;
    c = (c << 17) | ((c & 4294967295UL) >> 15);
    c += d;
    b += ((a ^ (c & (d ^ a))) + (*((MD5_u32plus *)(ptr + 44)))) + 2304563134UL;
    b = (b << 22) | ((b & 4294967295UL) >> 10);
    b += c;
    a += ((d ^ (b & (c ^ d))) + (*((MD5_u32plus *)(ptr + 48)))) + 1804603682UL;
    a = (a << 7) | ((a & 4294967295UL) >> 25);
    a += b;
    d += ((c ^ (a & (b ^ c))) + (*((MD5_u32plus *)(ptr + 52)))) + 4254626195UL;
    d = (d << 12) | ((d & 4294967295UL) >> 20);
    d += a;
    c += ((b ^ (d & (a ^ b))) + (*((MD5_u32plus *)(ptr + 56)))) + 2792965006UL;
    c = (c << 17) | ((c & 4294967295UL) >> 15);
    c += d;
    b += ((a ^ (c & (d ^ a))) + (*((MD5_u32plus *)(ptr + 60)))) + 1236535329UL;
    b = (b << 22) | ((b & 4294967295UL) >> 10);
    b += c;
    a += ((c ^ (d & (b ^ c))) + (*((MD5_u32plus *)(ptr + 4)))) + 4129170786UL;
    a = (a << 5) | ((a & 4294967295UL) >> 27);
    a += b;
    d += ((b ^ (c & (a ^ b))) + (*((MD5_u32plus *)(ptr + 24)))) + 3225465664UL;
    d = (d << 9) | ((d & 4294967295UL) >> 23);
    d += a;
    c += ((a ^ (b & (d ^ a))) + (*((MD5_u32plus *)(ptr + 44)))) + 643717713UL;
    c = (c << 14) | ((c & 4294967295UL) >> 18);
    c += d;
    b += ((d ^ (a & (c ^ d))) + (*((MD5_u32plus *)(ptr + 0)))) + 3921069994UL;
    b = (b << 20) | ((b & 4294967295UL) >> 12);
    b += c;
    a += ((c ^ (d & (b ^ c))) + (*((MD5_u32plus *)(ptr + 20)))) + 3593408605UL;
    a = (a << 5) | ((a & 4294967295UL) >> 27);
    a += b;
    d += ((b ^ (c & (a ^ b))) + (*((MD5_u32plus *)(ptr + 40)))) + 38016083UL;
    d = (d << 9) | ((d & 4294967295UL) >> 23);
    d += a;
    c += ((a ^ (b & (d ^ a))) + (*((MD5_u32plus *)(ptr + 60)))) + 3634488961UL;
    c = (c << 14) | ((c & 4294967295UL) >> 18);
    c += d;
    b += ((d ^ (a & (c ^ d))) + (*((MD5_u32plus *)(ptr + 16)))) + 3889429448UL;
    b = (b << 20) | ((b & 4294967295UL) >> 12);
    b += c;
    a += ((c ^ (d & (b ^ c))) + (*((MD5_u32plus *)(ptr + 36)))) + 568446438UL;
    a = (a << 5) | ((a & 4294967295UL) >> 27);
    a += b;
    d += ((b ^ (c & (a ^ b))) + (*((MD5_u32plus *)(ptr + 56)))) + 3275163606UL;
    d = (d << 9) | ((d & 4294967295UL) >> 23);
    d += a;
    c += ((a ^ (b & (d ^ a))) + (*((MD5_u32plus *)(ptr + 12)))) + 4107603335UL;
    c = (c << 14) | ((c & 4294967295UL) >> 18);
    c += d;
    b += ((d ^ (a & (c ^ d))) + (*((MD5_u32plus *)(ptr + 32)))) + 1163531501UL;
    b = (b << 20) | ((b & 4294967295UL) >> 12);
    b += c;
    a += ((c ^ (d & (b ^ c))) + (*((MD5_u32plus *)(ptr + 52)))) + 2850285829UL;
    a = (a << 5) | ((a & 4294967295UL) >> 27);
    a += b;
    d += ((b ^ (c & (a ^ b))) + (*((MD5_u32plus *)(ptr + 8)))) + 4243563512UL;
    d = (d << 9) | ((d & 4294967295UL) >> 23);
    d += a;
    c += ((a ^ (b & (d ^ a))) + (*((MD5_u32plus *)(ptr + 28)))) + 1735328473UL;
    c = (c << 14) | ((c & 4294967295UL) >> 18);
    c += d;
    b += ((d ^ (a & (c ^ d))) + (*((MD5_u32plus *)(ptr + 48)))) + 2368359562UL;
    b = (b << 20) | ((b & 4294967295UL) >> 12);
    b += c;
    a += (((b ^ c) ^ d) + (*((MD5_u32plus *)(ptr + 20)))) + 4294588738UL;
    a = (a << 4) | ((a & 4294967295UL) >> 28);
    a += b;
    d += (((a ^ b) ^ c) + (*((MD5_u32plus *)(ptr + 32)))) + 2272392833UL;
    d = (d << 11) | ((d & 4294967295UL) >> 21);
    d += a;
    c += (((d ^ a) ^ b) + (*((MD5_u32plus *)(ptr + 44)))) + 1839030562UL;
    c = (c << 16) | ((c & 4294967295UL) >> 16);
    c += d;
    b += (((c ^ d) ^ a) + (*((MD5_u32plus *)(ptr + 56)))) + 4259657740UL;
    b = (b << 23) | ((b & 4294967295UL) >> 9);
    b += c;
    a += (((b ^ c) ^ d) + (*((MD5_u32plus *)(ptr + 4)))) + 2763975236UL;
    a = (a << 4) | ((a & 4294967295UL) >> 28);
    a += b;
    d += (((a ^ b) ^ c) + (*((MD5_u32plus *)(ptr + 16)))) + 1272893353UL;
    d = (d << 11) | ((d & 4294967295UL) >> 21);
    d += a;
    c += (((d ^ a) ^ b) + (*((MD5_u32plus *)(ptr + 28)))) + 4139469664UL;
    c = (c << 16) | ((c & 4294967295UL) >> 16);
    c += d;
    b += (((c ^ d) ^ a) + (*((MD5_u32plus *)(ptr + 40)))) + 3200236656UL;
    b = (b << 23) | ((b & 4294967295UL) >> 9);
    b += c;
    a += (((b ^ c) ^ d) + (*((MD5_u32plus *)(ptr + 52)))) + 681279174UL;
    a = (a << 4) | ((a & 4294967295UL) >> 28);
    a += b;
    d += (((a ^ b) ^ c) + (*((MD5_u32plus *)(ptr + 0)))) + 3936430074UL;
    d = (d << 11) | ((d & 4294967295UL) >> 21);
    d += a;
    c += (((d ^ a) ^ b) + (*((MD5_u32plus *)(ptr + 12)))) + 3572445317UL;
    c = (c << 16) | ((c & 4294967295UL) >> 16);
    c += d;
    b += (((c ^ d) ^ a) + (*((MD5_u32plus *)(ptr + 24)))) + 76029189UL;
    b = (b << 23) | ((b & 4294967295UL) >> 9);
    b += c;
    a += (((b ^ c) ^ d) + (*((MD5_u32plus *)(ptr + 36)))) + 3654602809UL;
    a = (a << 4) | ((a & 4294967295UL) >> 28);
    a += b;
    d += (((a ^ b) ^ c) + (*((MD5_u32plus *)(ptr + 48)))) + 3873151461UL;
    d = (d << 11) | ((d & 4294967295UL) >> 21);
    d += a;
    c += (((d ^ a) ^ b) + (*((MD5_u32plus *)(ptr + 60)))) + 530742520UL;
    c = (c << 16) | ((c & 4294967295UL) >> 16);
    c += d;
    b += (((c ^ d) ^ a) + (*((MD5_u32plus *)(ptr + 8)))) + 3299628645UL;
    b = (b << 23) | ((b & 4294967295UL) >> 9);
    b += c;
    a += ((c ^ (b | ~ d)) + (*((MD5_u32plus *)(ptr + 0)))) + 4096336452UL;
    a = (a << 6) | ((a & 4294967295UL) >> 26);
    a += b;
    d += ((b ^ (a | ~ c)) + (*((MD5_u32plus *)(ptr + 28)))) + 1126891415UL;
    d = (d << 10) | ((d & 4294967295UL) >> 22);
    d += a;
    c += ((a ^ (d | ~ b)) + (*((MD5_u32plus *)(ptr + 56)))) + 2878612391UL;
    c = (c << 15) | ((c & 4294967295UL) >> 17);
    c += d;
    b += ((d ^ (c | ~ a)) + (*((MD5_u32plus *)(ptr + 20)))) + 4237533241UL;
    b = (b << 21) | ((b & 4294967295UL) >> 11);
    b += c;
    a += ((c ^ (b | ~ d)) + (*((MD5_u32plus *)(ptr + 48)))) + 1700485571UL;
    a = (a << 6) | ((a & 4294967295UL) >> 26);
    a += b;
    d += ((b ^ (a | ~ c)) + (*((MD5_u32plus *)(ptr + 12)))) + 2399980690UL;
    d = (d << 10) | ((d & 4294967295UL) >> 22);
    d += a;
    c += ((a ^ (d | ~ b)) + (*((MD5_u32plus *)(ptr + 40)))) + 4293915773UL;
    c = (c << 15) | ((c & 4294967295UL) >> 17);
    c += d;
    b += ((d ^ (c | ~ a)) + (*((MD5_u32plus *)(ptr + 4)))) + 2240044497UL;
    b = (b << 21) | ((b & 4294967295UL) >> 11);
    b += c;
    a += ((c ^ (b | ~ d)) + (*((MD5_u32plus *)(ptr + 32)))) + 1873313359UL;
    a = (a << 6) | ((a & 4294967295UL) >> 26);
    a += b;
    d += ((b ^ (a | ~ c)) + (*((MD5_u32plus *)(ptr + 60)))) + 4264355552UL;
    d = (d << 10) | ((d & 4294967295UL) >> 22);
    d += a;
    c += ((a ^ (d | ~ b)) + (*((MD5_u32plus *)(ptr + 24)))) + 2734768916UL;
    c = (c << 15) | ((c & 4294967295UL) >> 17);
    c += d;
    b += ((d ^ (c | ~ a)) + (*((MD5_u32plus *)(ptr + 52)))) + 1309151649UL;
    b = (b << 21) | ((b & 4294967295UL) >> 11);
    b += c;
    a += ((c ^ (b | ~ d)) + (*((MD5_u32plus *)(ptr + 16)))) + 4149444226UL;
    a = (a << 6) | ((a & 4294967295UL) >> 26);
    a += b;
    d += ((b ^ (a | ~ c)) + (*((MD5_u32plus *)(ptr + 44)))) + 3174756917UL;
    d = (d << 10) | ((d & 4294967295UL) >> 22);
    d += a;
    c += ((a ^ (d | ~ b)) + (*((MD5_u32plus *)(ptr + 8)))) + 718787259UL;
    c = (c << 15) | ((c & 4294967295UL) >> 17);
    c += d;
    b += ((d ^ (c | ~ a)) + (*((MD5_u32plus *)(ptr + 36)))) + 3951481745UL;
    b = (b << 21) | ((b & 4294967295UL) >> 11);
    b += c;
    a += saved_a;
    b += saved_b;
    c += saved_c;
    d += saved_d;
    ptr += 64;
    size -= 64UL;
    if (! size) {
      break;
    }
  }
  ctx->a = a;
  ctx->b = b;
  ctx->c = c;
  ctx->d = d;
  return ((void *)ptr);
}
}
void MD5_Init(MD5_CTX *ctx ) 
{ 

  {
  ctx->a = 1732584193UL;
  ctx->b = 4023233417UL;
  ctx->c = 2562383102UL;
  ctx->d = 271733878UL;
  ctx->lo = 0UL;
  ctx->hi = 0UL;
  return;
}
}
void MD5_Update(MD5_CTX *ctx , void *data , unsigned long size ) 
{ MD5_u32plus saved_lo ;
  unsigned long used ;
  unsigned long free___0 ;

  {
  saved_lo = ctx->lo;
  ctx->lo = (saved_lo + size) & 536870911UL;
  if (ctx->lo < saved_lo) {
    ctx->hi = ctx->hi + 1UL;
  }
  ctx->hi = ctx->hi + (size >> 29);
  used = saved_lo & 63UL;
  if (used) {
    free___0 = 64UL - used;
    if (size < free___0) {
      memcpy((void * __restrict  )(& ctx->buffer[used]), (void const   * __restrict  )data,
             (unsigned int )size);
      return;
    }
    memcpy((void * __restrict  )(& ctx->buffer[used]), (void const   * __restrict  )data,
           (unsigned int )free___0);
    data = (void *)((unsigned char *)data + free___0);
    size -= free___0;
    body(ctx, (void *)(ctx->buffer), 64UL);
  }
  if (size >= 64UL) {
    data = body(ctx, data, size & 4294967232UL);
    size &= 63UL;
  }
  memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )data, (unsigned int )size);
  return;
}
}
void MD5_Final(unsigned char *result , MD5_CTX *ctx ) 
{ unsigned long used ;
  unsigned long free___0 ;
  unsigned long tmp ;

  {
  used = ctx->lo & 63UL;
  tmp = used;
  used ++;
  ctx->buffer[tmp] = (unsigned char)128;
  free___0 = 64UL - used;
  if (free___0 < 8UL) {
    memset((void *)(& ctx->buffer[used]), 0, (unsigned int )free___0);
    body(ctx, (void *)(ctx->buffer), 64UL);
    used = 0UL;
    free___0 = 64UL;
  }
  memset((void *)(& ctx->buffer[used]), 0, (unsigned int )(free___0 - 8UL));
  ctx->lo = ctx->lo << 3;
  ctx->buffer[56] = (unsigned char )ctx->lo;
  ctx->buffer[57] = (unsigned char )(ctx->lo >> 8);
  ctx->buffer[58] = (unsigned char )(ctx->lo >> 16);
  ctx->buffer[59] = (unsigned char )(ctx->lo >> 24);
  ctx->buffer[60] = (unsigned char )ctx->hi;
  ctx->buffer[61] = (unsigned char )(ctx->hi >> 8);
  ctx->buffer[62] = (unsigned char )(ctx->hi >> 16);
  ctx->buffer[63] = (unsigned char )(ctx->hi >> 24);
  body(ctx, (void *)(ctx->buffer), 64UL);
  (*(result + 0)) = (unsigned char )ctx->a;
  (*(result + 1)) = (unsigned char )(ctx->a >> 8);
  (*(result + 2)) = (unsigned char )(ctx->a >> 16);
  (*(result + 3)) = (unsigned char )(ctx->a >> 24);
  (*(result + 4)) = (unsigned char )ctx->b;
  (*(result + 5)) = (unsigned char )(ctx->b >> 8);
  (*(result + 6)) = (unsigned char )(ctx->b >> 16);
  (*(result + 7)) = (unsigned char )(ctx->b >> 24);
  (*(result + 8)) = (unsigned char )ctx->c;
  (*(result + 9)) = (unsigned char )(ctx->c >> 8);
  (*(result + 10)) = (unsigned char )(ctx->c >> 16);
  (*(result + 11)) = (unsigned char )(ctx->c >> 24);
  (*(result + 12)) = (unsigned char )ctx->d;
  (*(result + 13)) = (unsigned char )(ctx->d >> 8);
  (*(result + 14)) = (unsigned char )(ctx->d >> 16);
  (*(result + 15)) = (unsigned char )(ctx->d >> 24);
  memset((void *)ctx, 0, sizeof((*ctx)));
  return;
}
}
#pragma merger(0,"/tmp/cil-fhHHk4Tl.i","-g -O2 -fPIC")
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) int rand(void) ;
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int putenv(char *__string )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
__inline static  __attribute__((__nothrow__)) int stat__extinline(char const   *__path ,
                                                                  struct stat *__statbuf ) ;
__inline static  __attribute__((__nothrow__)) int lstat__extinline(char const   *__path ,
                                                                   struct stat *__statbuf ) ;
__inline static  __attribute__((__nothrow__)) int lstat__extinline(char const   *__path ,
                                                                   struct stat *__statbuf ) ;
__inline static int lstat__extinline(char const   *__path , struct stat *__statbuf ) 
{ int tmp ;

  {
  tmp = __lxstat(3, __path, __statbuf);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz ) ;
extern DIR *opendir(char const   *__name ) ;
extern int closedir(DIR *__dirp ) ;
extern struct dirent *readdir(DIR *__dirp ) ;
extern  __attribute__((__nothrow__)) void rewinddir(DIR *__dirp ) ;
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
struct __anonstruct_pthread_mutex_t_16 cli_gentemp_mutex  =    {0, 0, (struct _pthread_descr_struct *)0, 0, {0L, 0}};
void cl_settempdir(char const   *dir , short leavetemps ) ;
char const   *cl_perror(int clerror ) ;
int cli_rmdirs(char const   *dirname ) ;
char *cli_md5stream(FILE *fs , unsigned char *digcpy ) ;
char *cli_md5file(char const   *filename ) ;
int cli_readn(int fd , void *buff , unsigned int count ) ;
int cli_writen(int fd , void *buff , unsigned int count ) ;
int32_t cli_readint32(char const   *buff ) ;
void cli_writeint32(char *offset , uint32_t value ) ;
unsigned int cli_rndnum(unsigned int max ) ;
int cli_filecopy(char const   *src , char const   *dest ) ;
short cli_debug_flag  =    (short)0;
short cli_leavetemps_flag  =    (short)0;
static unsigned char oldmd5buff[16]  = 
  {      (unsigned char)16,      (unsigned char)38,      (unsigned char)97,      (unsigned char)12, 
        (unsigned char)8,      (unsigned char)4,      (unsigned char)72,      (unsigned char)196, 
        (unsigned char)217,      (unsigned char)144,      (unsigned char)33,      (unsigned char)124, 
        (unsigned char)18,      (unsigned char)11,      (unsigned char)17,      (unsigned char)253};
void cli_warnmsg(char const   *str  , ...) 
{ va_list args ;

  {
  __builtin_va_start(args, str);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"LibClamAV Warning: ");
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )str, args);
  __builtin_va_end(args);
  return;
}
}
void cli_errmsg(char const   *str  , ...) 
{ va_list args ;

  {
  __builtin_va_start(args, str);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"LibClamAV Error: ");
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )str, args);
  __builtin_va_end(args);
  return;
}
}
void cli_dbgmsg(char const   *str  , ...) 
{ va_list args ;

  {
  if (cli_debug_flag) {
    __builtin_va_start(args, str);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"LibClamAV debug: ");
    vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )str, args);
    __builtin_va_end(args);
  } else {
    return;
  }
  return;
}
}
void cl_debug(void) 
{ 

  {
  cli_debug_flag = (short)1;
  return;
}
}
int cl_retflevel(void) 
{ 

  {
  return (5);
}
}
char const   *cl_retver(void) 
{ 

  {
  return ("0.85.1");
}
}
char const   *cl_strerror(int clerror ) 
{ 

  {
  switch (clerror) {
  case 0: ;
  return ("No viruses detected");
  case 1: ;
  return ("Virus(es) detected");
  case 10: ;
  return ("Recursion limit exceeded");
  case 11: ;
  return ("File size limit exceeded");
  case 12: ;
  return ("Files number limit exceeded");
  case 100: ;
  return ("RAR module failure");
  case 101: ;
  return ("Zip module failure");
  case 102: ;
  return ("Malformed Zip detected");
  case 103: ;
  return ("GZip module failure");
  case 106: ;
  return ("MS Expand module failure");
  case 107: ;
  return ("MS CAB module failure");
  case 105: ;
  return ("OLE2 module failure");
  case -1: ;
  return ("Unable to create temporary file");
  case -7: ;
  return ("Unable to create temporary directory");
  case -2: ;
  return ("Unable to synchronize file <-> disk");
  case -3: ;
  return ("Unable to allocate memory");
  case -4: ;
  return ("Unable to open file or directory");
  case -5: ;
  return ("Malformed database");
  case -6: ;
  return ("Too short pattern detected");
  case -8: ;
  return ("Broken or not a CVD file");
  case -9: ;
  return ("CVD extraction failure");
  case -10: ;
  return ("MD5 verification error");
  case -11: ;
  return ("Digital signature verification error");
  case 300: ;
  return ("Null argument passed while initialized is required");
  case -12: ;
  return ("Input/Output error");
  case -13: ;
  return ("Bad format or broken data");
  default: ;
  return ("Unknown error code");
  }
}
}
char const   *cl_perror(int clerror ) 
{ char const   *tmp ;

  {
  tmp = cl_strerror(clerror);
  return (tmp);
}
}
unsigned char *cli_md5digest(int desc ) 
{ unsigned char *digest ;
  char buff[8192] ;
  MD5_CTX ctx ;
  int bytes ;

  {
  digest = (unsigned char *)cli_malloc(16U);
  if (! digest) {
    return ((unsigned char *)((void *)0));
  }
  MD5_Init(& ctx);
  while (1) {
    bytes = cli_readn(desc, (void *)(buff), 8192U);
    if (! bytes) {
      break;
    }
    MD5_Update(& ctx, (void *)(buff), (unsigned long )bytes);
  }
  MD5_Final(digest, & ctx);
  return (digest);
}
}
char *cli_md5stream(FILE *fs , unsigned char *digcpy ) 
{ unsigned char digest[16] ;
  char buff[8192] ;
  MD5_CTX ctx ;
  char *md5str ;
  char *pt ;
  int i ;
  int bytes ;

  {
  MD5_Init(& ctx);
  while (1) {
    bytes = (int )fread((void * __restrict  )(buff), 1U, 8192U, (FILE * __restrict  )fs);
    if (! bytes) {
      break;
    }
    MD5_Update(& ctx, (void *)(buff), (unsigned long )bytes);
  }
  MD5_Final(digest, & ctx);
  md5str = (char *)cli_calloc(33U, sizeof(char ));
  if (! md5str) {
    return ((char *)((void *)0));
  }
  pt = md5str;
  i = 0;
  while (i < 16) {
    sprintf((char * __restrict  )pt, (char const   * __restrict  )"%02x", digest[i]);
    pt += 2;
    i ++;
  }
  if (digcpy) {
    memcpy((void * __restrict  )digcpy, (void const   * __restrict  )(digest), 16U);
  }
  return (md5str);
}
}
char *cli_md5file(char const   *filename ) 
{ FILE *fs ;
  char *md5str ;

  {
  fs = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"rb");
  if ((unsigned int )fs == (unsigned int )((void *)0)) {
    cli_errmsg("cli_md5file(): Can\'t read file %s\n", filename);
    return ((char *)((void *)0));
  }
  md5str = cli_md5stream(fs, (unsigned char *)((void *)0));
  fclose(fs);
  return (md5str);
}
}
static char *cli_md5buff(char const   *buffer , unsigned int len ) 
{ unsigned char digest[16] ;
  char *md5str ;
  char *pt ;
  MD5_CTX ctx ;
  int i ;

  {
  MD5_Init(& ctx);
  MD5_Update(& ctx, (void *)((unsigned char *)buffer), (unsigned long )len);
  MD5_Final(digest, & ctx);
  memcpy((void * __restrict  )(oldmd5buff), (void const   * __restrict  )(digest),
         16U);
  md5str = (char *)cli_calloc(33U, sizeof(char ));
  if (! md5str) {
    return ((char *)((void *)0));
  }
  pt = md5str;
  i = 0;
  while (i < 16) {
    sprintf((char * __restrict  )pt, (char const   * __restrict  )"%02x", digest[i]);
    pt += 2;
    i ++;
  }
  return (md5str);
}
}
void *cli_malloc(size_t size ) 
{ void *alloc ;

  {
  if (size > 134217728U) {
    cli_errmsg("Attempt to allocate %d bytes. Please report to bugs@clamav.net\n",
               size);
    return ((void *)0);
  }
  alloc = malloc(size);
  if (! alloc) {
    cli_errmsg("cli_malloc(): Can\'t allocate memory (%d bytes).\n", size);
    perror("malloc_problem");
    return ((void *)0);
  } else {
    return (alloc);
  }
}
}
void *cli_calloc(size_t nmemb , size_t size ) 
{ void *alloc ;

  {
  if (size > 134217728U) {
    cli_errmsg("Attempt to allocate %d bytes. Please report to bugs@clamav.net\n",
               size);
    return ((void *)0);
  }
  alloc = calloc(nmemb, size);
  if (! alloc) {
    cli_errmsg("cli_calloc(): Can\'t allocate memory (%d bytes).\n", nmemb * size);
    perror("calloc_problem");
    return ((void *)0);
  } else {
    return (alloc);
  }
}
}
void *cli_realloc(void *ptr , size_t size ) 
{ void *alloc ;

  {
  alloc = realloc(ptr, size);
  if (! alloc) {
    cli_errmsg("cli_realloc(): Can\'t re-allocate memory to %d byte.\n", size);
    perror("realloc_problem");
    return ((void *)0);
  } else {
    return (alloc);
  }
}
}
unsigned int cli_rndnum(unsigned int max ) 
{ struct timeval tv ;
  clock_t tmp ;
  int tmp___0 ;

  {
  gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((struct timezone *)0));
  tmp = clock();
  srand((unsigned int )(tv.tv_usec + tmp));
  tmp___0 = rand();
  return ((unsigned int )tmp___0 % max);
}
}
void cl_settempdir(char const   *dir , short leavetemps ) 
{ char *var ;
  size_t tmp ;
  int tmp___1 ;

  {
  if (dir) {
    tmp = strlen(dir);
    var = (char *)cli_malloc(8U + tmp);
    sprintf((char * __restrict  )var, (char const   * __restrict  )"TMPDIR=%s", dir);
    tmp___1 = putenv(var);
    if (tmp___1) {
      cli_warnmsg("Can\'t set TMPDIR variable - insufficient space in the environment.\n");
    } else {
      cli_dbgmsg("Setting %s as global temporary directory\n", dir);
    }
  }
  cli_leavetemps_flag = leavetemps;
  return;
}
}
char *cli_gentemp(char const   *dir ) 
{ char *name ;
  char *tmp ;
  char const   *mdir ;
  unsigned char salt[48] ;
  int i ;
  struct stat foo ;
  size_t tmp___0 ;
  int tmp___2 ;

  {
  if (! dir) {
    mdir = getenv("TMPDIR");
    if ((unsigned int )mdir == (unsigned int )((void *)0)) {
      mdir = "/tmp";
    }
  } else {
    mdir = dir;
  }
  tmp___0 = strlen(mdir);
  name = (char *)cli_calloc((((tmp___0 + 1U) + 16U) + 1U) + 7U, sizeof(char ));
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    cli_dbgmsg("cli_gentemp(\'%s\'): out of memory\n", dir);
    return ((char *)((void *)0));
  }
  pthread_mutex_lock(& cli_gentemp_mutex);
  memcpy((void * __restrict  )(salt), (void const   * __restrict  )(oldmd5buff), 16U);
  while (1) {
    i = 16;
    while (i < 48) {
      salt[i] = (unsigned char )cli_rndnum(255U);
      i ++;
    }
    tmp = cli_md5buff((char const   *)((char *)(salt)), 48U);
    sprintf((char * __restrict  )name, (char const   * __restrict  )"%s/clamav-",
            mdir);
    __builtin_strncat(name, tmp, 16);
    free((void *)tmp);
    tmp___2 = stat__extinline((char const   *)name, & foo);
    if (! (tmp___2 != -1)) {
      break;
    }
  }
  pthread_mutex_unlock(& cli_gentemp_mutex);
  return (name);
}
}
int cli_rmdirs(char const   *dirname ) 
{ DIR *dd ;
  struct dirent *dent ;
  struct stat maind ;
  struct stat statbuf ;
  char *fname ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___40 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___59 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___109 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___128 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;

  {
  chmod(dirname, 448U);
  dd = opendir(dirname);
  if ((unsigned int )dd != (unsigned int )((void *)0)) {
    while (1) {
      tmp___143 = stat__extinline(dirname, & maind);
      if (! (tmp___143 != -1)) {
        break;
      }
      tmp = rmdir(dirname);
      if (! tmp) {
        break;
      }
      while (1) {
        dent = readdir(dd);
        if (! dent) {
          break;
        }
        if (dent->d_ino) {
          tmp___71 = __builtin_constant_p((int )(dent->d_name));
          if (tmp___71) {
            tmp___72 = __builtin_constant_p((int )".");
            if (tmp___72) {
              __s1_len = strlen((char const   *)(dent->d_name));
              __s2_len = strlen(".");
              if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                     1U)) {
                goto _L___16;
              } else {
                if (__s1_len >= 4U) {
                  _L___16: 
                  if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                         1U)) {
                    tmp___73 = 1;
                  } else {
                    if (__s2_len >= 4U) {
                      tmp___73 = 1;
                    } else {
                      tmp___73 = 0;
                    }
                  }
                } else {
                  tmp___73 = 0;
                }
              }
              if (tmp___73) {
                tmp___40 = __builtin_strcmp(dent->d_name, ".");
              } else {
                goto _L___18;
              }
            } else {
              goto _L___18;
            }
          } else {
            _L___18: 
            tmp___70 = __builtin_constant_p((int )(dent->d_name));
            if (tmp___70) {
              if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                  1U) {
                __s1_len = strlen((char const   *)(dent->d_name));
                if (__s1_len < 4U) {
                  tmp___59 = __builtin_constant_p((int )".");
                  if (tmp___59) {
                    if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                        1U) {
                      tmp___40 = __builtin_strcmp(dent->d_name, ".");
                    } else {
                      goto _L___11;
                    }
                  } else {
                    _L___11: 
                    __s2___6 = (unsigned char const   *)".";
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                            0)) - (int const   )(*(__s2___6 +
                                                                                   0)));
                    if (__s1_len > 0U) {
                      if (__result___18 == 0) {
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                1)) - (int const   )(*(__s2___6 +
                                                                                       1)));
                        if (__s1_len > 1U) {
                          if (__result___18 == 0) {
                            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                    2)) - (int const   )(*(__s2___6 +
                                                                                           2)));
                            if (__s1_len > 2U) {
                              if (__result___18 == 0) {
                                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                        3)) - (int const   )(*(__s2___6 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___40 = __result___18;
                  }
                } else {
                  goto _L___15;
                }
              } else {
                goto _L___15;
              }
            } else {
              _L___15: 
              tmp___69 = __builtin_constant_p((int )".");
              if (tmp___69) {
                if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                    1U) {
                  __s2_len = strlen(".");
                  if (__s2_len < 4U) {
                    tmp___68 = __builtin_constant_p((int )(dent->d_name));
                    if (tmp___68) {
                      if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                          1U) {
                        tmp___40 = __builtin_strcmp(dent->d_name, ".");
                      } else {
                        goto _L___13;
                      }
                    } else {
                      _L___13: 
                      __s1___14 = (unsigned char const   *)((char const   *)(dent->d_name));
                      __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"." +
                                                                                                 0)));
                      if (__s2_len > 0U) {
                        if (__result___22 == 0) {
                          __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                                 (int const   )(*((unsigned char const   *)"." +
                                                                  1)));
                          if (__s2_len > 1U) {
                            if (__result___22 == 0) {
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      2)) - (int const   )(*((unsigned char const   *)"." +
                                                                                             2)));
                              if (__s2_len > 2U) {
                                if (__result___22 == 0) {
                                  __result___22 = (int )((int const   )(*(__s1___14 +
                                                                          3)) - (int const   )(*((unsigned char const   *)"." +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___40 = __result___22;
                    }
                  } else {
                    tmp___40 = __builtin_strcmp(dent->d_name, ".");
                  }
                } else {
                  tmp___40 = __builtin_strcmp(dent->d_name, ".");
                }
              } else {
                tmp___40 = __builtin_strcmp(dent->d_name, ".");
              }
            }
          }
          if (tmp___40) {
            tmp___140 = __builtin_constant_p((int )(dent->d_name));
            if (tmp___140) {
              tmp___141 = __builtin_constant_p((int )"..");
              if (tmp___141) {
                __s1_len___0 = strlen((char const   *)(dent->d_name));
                __s2_len___0 = strlen("..");
                if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                       1U)) {
                  goto _L___36;
                } else {
                  if (__s1_len___0 >= 4U) {
                    _L___36: 
                    if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                           1U)) {
                      tmp___142 = 1;
                    } else {
                      if (__s2_len___0 >= 4U) {
                        tmp___142 = 1;
                      } else {
                        tmp___142 = 0;
                      }
                    }
                  } else {
                    tmp___142 = 0;
                  }
                }
                if (tmp___142) {
                  tmp___109 = __builtin_strcmp(dent->d_name, "..");
                } else {
                  goto _L___38;
                }
              } else {
                goto _L___38;
              }
            } else {
              _L___38: 
              tmp___139 = __builtin_constant_p((int )(dent->d_name));
              if (tmp___139) {
                if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                    1U) {
                  __s1_len___0 = strlen((char const   *)(dent->d_name));
                  if (__s1_len___0 < 4U) {
                    tmp___128 = __builtin_constant_p((int )"..");
                    if (tmp___128) {
                      if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                          1U) {
                        tmp___109 = __builtin_strcmp(dent->d_name, "..");
                      } else {
                        goto _L___31;
                      }
                    } else {
                      _L___31: 
                      __s2___14 = (unsigned char const   *)"..";
                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                              0)) - (int const   )(*(__s2___14 +
                                                                                     0)));
                      if (__s1_len___0 > 0U) {
                        if (__result___42 == 0) {
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                  1)) - (int const   )(*(__s2___14 +
                                                                                         1)));
                          if (__s1_len___0 > 1U) {
                            if (__result___42 == 0) {
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                      2)) - (int const   )(*(__s2___14 +
                                                                                             2)));
                              if (__s1_len___0 > 2U) {
                                if (__result___42 == 0) {
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                          3)) - (int const   )(*(__s2___14 +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___109 = __result___42;
                    }
                  } else {
                    goto _L___35;
                  }
                } else {
                  goto _L___35;
                }
              } else {
                _L___35: 
                tmp___138 = __builtin_constant_p((int )"..");
                if (tmp___138) {
                  if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                      1U) {
                    __s2_len___0 = strlen("..");
                    if (__s2_len___0 < 4U) {
                      tmp___137 = __builtin_constant_p((int )(dent->d_name));
                      if (tmp___137) {
                        if ((unsigned int )((void const   *)(dent->d_name + 1)) -
                            (unsigned int )((void const   *)(dent->d_name)) == 1U) {
                          tmp___109 = __builtin_strcmp(dent->d_name, "..");
                        } else {
                          goto _L___33;
                        }
                      } else {
                        _L___33: 
                        __s1___30 = (unsigned char const   *)((char const   *)(dent->d_name));
                        __result___46 = (int )((int const   )(*(__s1___30 + 0)) -
                                               (int const   )(*((unsigned char const   *)".." +
                                                                0)));
                        if (__s2_len___0 > 0U) {
                          if (__result___46 == 0) {
                            __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                   (int const   )(*((unsigned char const   *)".." +
                                                                    1)));
                            if (__s2_len___0 > 1U) {
                              if (__result___46 == 0) {
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        2)) - (int const   )(*((unsigned char const   *)".." +
                                                                                               2)));
                                if (__s2_len___0 > 2U) {
                                  if (__result___46 == 0) {
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            3)) -
                                                           (int const   )(*((unsigned char const   *)".." +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
                        tmp___109 = __result___46;
                      }
                    } else {
                      tmp___109 = __builtin_strcmp(dent->d_name, "..");
                    }
                  } else {
                    tmp___109 = __builtin_strcmp(dent->d_name, "..");
                  }
                } else {
                  tmp___109 = __builtin_strcmp(dent->d_name, "..");
                }
              }
            }
            if (tmp___109) {
              tmp___0 = strlen(dirname);
              tmp___1 = strlen((char const   *)(dent->d_name));
              fname = (char *)cli_calloc((tmp___0 + tmp___1) + 2U, sizeof(char ));
              sprintf((char * __restrict  )fname, (char const   * __restrict  )"%s/%s",
                      dirname, dent->d_name);
              tmp___4 = lstat__extinline((char const   *)fname, & statbuf);
              if (tmp___4 != -1) {
                if ((statbuf.st_mode & 61440U) == 16384U) {
                  if (! ((statbuf.st_mode & 61440U) == 40960U)) {
                    tmp___3 = rmdir((char const   *)fname);
                    if (tmp___3 == -1) {
                      tmp___2 = __errno_location();
                      if ((*tmp___2) == 13) {
                        cli_errmsg("Can\'t remove some temporary directories due to access problem.\n");
                        closedir(dd);
                        free((void *)fname);
                        return (0);
                      }
                      cli_rmdirs((char const   *)fname);
                    }
                  } else {
                    unlink((char const   *)fname);
                  }
                } else {
                  unlink((char const   *)fname);
                }
              }
              free((void *)fname);
            }
          }
        }
      }
      rewinddir(dd);
    }
  } else {
    return (53);
  }
  closedir(dd);
  return (0);
}
}
int cli_readn(int fd , void *buff , unsigned int count ) 
{ int retval ;
  unsigned int todo ;
  unsigned char *current ;
  int *tmp ;

  {
  todo = count;
  current = (unsigned char *)buff;
  while (1) {
    retval = read(fd, (void *)current, todo);
    if (retval == 0) {
      return ((int )(count - todo));
    }
    if (retval < 0) {
      tmp = __errno_location();
      if ((*tmp) == 4) {
        goto __Cont;
      }
      return (-1);
    }
    todo -= (unsigned int )retval;
    current += retval;
    __Cont: 
    if (! (todo > 0U)) {
      break;
    }
  }
  return ((int )count);
}
}
int cli_writen(int fd , void *buff , unsigned int count ) 
{ int retval ;
  unsigned int todo ;
  unsigned char *current ;
  int *tmp ;

  {
  todo = count;
  current = (unsigned char *)buff;
  while (1) {
    retval = write(fd, (void const   *)current, todo);
    if (retval < 0) {
      tmp = __errno_location();
      if ((*tmp) == 4) {
        goto __Cont;
      }
      return (-1);
    }
    todo -= (unsigned int )retval;
    current += retval;
    __Cont: 
    if (! (todo > 0U)) {
      break;
    }
  }
  return ((int )count);
}
}
int32_t cli_readint32(char const   *buff ) 
{ int32_t ret ;

  {
  ret = (int )((int const   )(*(buff + 0)) & 255);
  ret |= (int )(((int const   )(*(buff + 1)) & 255) << 8);
  ret |= (int )(((int const   )(*(buff + 2)) & 255) << 16);
  ret |= (int )(((int const   )(*(buff + 3)) & 255) << 24);
  return (ret);
}
}
void cli_writeint32(char *offset , uint32_t value ) 
{ 

  {
  (*(offset + 0)) = (char )(value & 255U);
  (*(offset + 1)) = (char )((value & 65280U) >> 8);
  (*(offset + 2)) = (char )((value & 16711680U) >> 16);
  (*(offset + 3)) = (char )((value & 4278190080U) >> 24);
  return;
}
}
int cli_filecopy(char const   *src , char const   *dest ) 
{ char *buffer ;
  int s ;
  int d ;
  int bytes ;
  int tmp ;

  {
  s = open(src, 0);
  if (s == -1) {
    return (-1);
  }
  d = open(dest, 577);
  if (d == -1) {
    close(s);
    return (-1);
  }
  buffer = (char *)cli_malloc(8192U);
  if (! buffer) {
    return (-1);
  }
  while (1) {
    bytes = cli_readn(s, (void *)buffer, 8192U);
    if (! (bytes > 0)) {
      break;
    }
    cli_writen(d, (void *)buffer, (unsigned int )bytes);
  }
  free((void *)buffer);
  close(s);
  tmp = close(d);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-qnyPwq5y.i","-g -O2 -fPIC")
extern  __attribute__((__nothrow__)) char *strcat(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
__inline static char *__strpbrk_c2__extinline(char const   *__s , int __accept1 ,
                                              int __accept2 ) 
{ char *tmp ;

  {
  while (1) {
    if ((int const   )(*__s) != 0) {
      if ((int const   )(*__s) != (int const   )__accept1) {
        if (! ((int const   )(*__s) != (int const   )__accept2)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    __s ++;
  }
  if ((int const   )(*__s) == 0) {
    tmp = (char *)((void *)0);
  } else {
    tmp = (char *)((unsigned int )__s);
  }
  return (tmp);
}
}
__inline static char *__strpbrk_c3__extinline(char const   *__s , int __accept1 ,
                                              int __accept2 , int __accept3 ) 
{ char *tmp ;

  {
  while (1) {
    if ((int const   )(*__s) != 0) {
      if ((int const   )(*__s) != (int const   )__accept1) {
        if ((int const   )(*__s) != (int const   )__accept2) {
          if (! ((int const   )(*__s) != (int const   )__accept3)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    __s ++;
  }
  if ((int const   )(*__s) == 0) {
    tmp = (char *)((void *)0);
  } else {
    tmp = (char *)((unsigned int )__s);
  }
  return (tmp);
}
}
int cl_loaddb(char const   *filename , struct cl_node **root , unsigned int *signo ) ;
int cl_loaddbdir(char const   *dirname , struct cl_node **root , unsigned int *signo ) ;
int cl_statinidir(char const   *dirname , struct cl_stat *dbstat ) ;
int cl_statchkdir(struct cl_stat  const  *dbstat ) ;
int cl_statfree(struct cl_stat *dbstat ) ;
int cli_cvdload(FILE *fd , struct cl_node **root , unsigned int *signo , short warn ) ;
int cli_strbcasestr(char const   *haystack , char const   *needle ) ;
int cli_chomp(char *string ) ;
short *cli_hex2si(char const   *hex___0 ) ;
char *cli_hex2str(char const   *hex___0 ) ;
int cli_hex2num(char const   *hex___0 ) ;
static int cli_ac_addsig(struct cl_node *root , char const   *virname , char const   *hexsig ,
                         int sigid , int parts , int partno , unsigned short type ,
                         unsigned int mindist , unsigned int maxdist , char *offset ,
                         unsigned short target ) 
{ struct cli_ac_patt *new ;
  char *pt ;
  char *hex___0 ;
  int virlen ;
  int ret ;
  int error ;
  unsigned int i ;
  char *hexcpy ;
  char *hexnew ;
  char *start ;
  char *h ;
  char *c ;
  size_t __len___2 ;
  size_t tmp___16 ;
  char *__retval___2 ;
  char *tmp___17 ;
  int tmp___19 ;
  size_t tmp___20 ;
  char *tmp___22 ;
  int tmp___27 ;
  char *tmp___28 ;
  size_t tmp___31 ;
  int tmp___37 ;
  char *tmp___41 ;
  int tmp___43 ;
  size_t tmp___44 ;
  size_t tmp___45 ;
  size_t tmp___46 ;

  {
  error = 0;
  new = (struct cli_ac_patt *)cli_calloc(1U, sizeof(struct cli_ac_patt ));
  if ((unsigned int )new == (unsigned int )((void *)0)) {
    return (-3);
  }
  new->type = type;
  new->sigid = (unsigned short )sigid;
  new->parts = (unsigned short )parts;
  new->partno = (unsigned short )partno;
  new->mindist = mindist;
  new->maxdist = maxdist;
  new->target = target;
  new->offset = offset;
  tmp___43 = __builtin_constant_p((int )hexsig);
  if (tmp___43) {
    tmp___41 = (char *)__builtin_strchr(hexsig, '(');
  } else {
    tmp___41 = (char *)__builtin_strchr(hexsig, '(');
  }
  if (tmp___41) {
    tmp___19 = __builtin_constant_p((int )hexsig);
    if (tmp___19) {
      if ((unsigned int )((void const   *)(hexsig + 1)) - (unsigned int )((void const   *)hexsig) ==
          1U) {
        if ((int const   )(*(hexsig + 0)) == 0) {
          hexcpy = (char *)calloc(1U, 1U);
        } else {
          tmp___16 = strlen(hexsig);
          __len___2 = tmp___16 + 1U;
          tmp___17 = (char *)malloc(__len___2);
          __retval___2 = tmp___17;
          if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
            __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )hexsig,
                                          __len___2);
          }
          hexcpy = __retval___2;
        }
      } else {
        hexcpy = __strdup(hexsig);
      }
    } else {
      hexcpy = __strdup(hexsig);
    }
    if (! hexcpy) {
      free((void *)new);
      return (-3);
    }
    tmp___20 = strlen(hexsig);
    hexnew = (char *)cli_calloc(tmp___20 + 1U, 1U);
    if (! hexnew) {
      free((void *)hexcpy);
      free((void *)new);
      return (-3);
    }
    pt = hexcpy;
    start = pt;
    while (1) {
      tmp___37 = __builtin_constant_p((int )start);
      if (tmp___37) {
        pt = (char *)__builtin_strchr(start, '(');
      } else {
        pt = (char *)__builtin_strchr(start, '(');
      }
      if (! pt) {
        break;
      }
      tmp___22 = pt;
      pt ++;
      (*tmp___22) = (char)0;
      if (! start) {
        error = 1;
        break;
      }
      strcat((char * __restrict  )hexnew, (char const   * __restrict  )start);
      strcat((char * __restrict  )hexnew, (char const   * __restrict  )"@@");
      tmp___27 = __builtin_constant_p((int )pt);
      if (tmp___27) {
        start = (char *)__builtin_strchr(pt, ')');
      } else {
        start = (char *)__builtin_strchr(pt, ')');
      }
      if (! start) {
        error = 1;
        break;
      }
      tmp___28 = start;
      start ++;
      (*tmp___28) = (char)0;
      new->alt = (unsigned short )((int )new->alt + 1);
      new->altn = (unsigned short *)realloc((void *)new->altn, (unsigned int )new->alt *
                                                               sizeof(unsigned short ));
      (*(new->altn + ((int )new->alt - 1))) = (unsigned short)0;
      new->altc = (char **)realloc((void *)new->altc, (unsigned int )new->alt * sizeof(char *));
      (*(new->altc + ((int )new->alt - 1))) = (char *)((void *)0);
      i = 0U;
      while (1) {
        tmp___31 = strlen((char const   *)pt);
        if (! (i < tmp___31)) {
          break;
        }
        if ((int )(*(pt + i)) == 124) {
          (*(new->altn + ((int )new->alt - 1))) = (unsigned short )((int )(*(new->altn +
                                                                             ((int )new->alt -
                                                                              1))) +
                                                                    1);
        }
        i ++;
      }
      if (! (*(new->altn + ((int )new->alt - 1)))) {
        error = 1;
        break;
      } else {
        (*(new->altn + ((int )new->alt - 1))) = (unsigned short )((int )(*(new->altn +
                                                                           ((int )new->alt -
                                                                            1))) +
                                                                  1);
      }
      (*(new->altc + ((int )new->alt - 1))) = (char *)cli_calloc((unsigned int )(*(new->altn +
                                                                                   ((int )new->alt -
                                                                                    1))),
                                                                 1U);
      if (! (*(new->altc + ((int )new->alt - 1)))) {
        error = 1;
        break;
      }
      i = 0U;
      while (i < (unsigned int )(*(new->altn + ((int )new->alt - 1)))) {
        h = cli_strtok((char const   *)pt, (int )i, "|");
        if ((unsigned int )h == (unsigned int )((void *)0)) {
          error = 1;
          break;
        }
        c = cli_hex2str((char const   *)h);
        if ((unsigned int )c == (unsigned int )((void *)0)) {
          free((void *)h);
          error = 1;
          break;
        }
        (*((*(new->altc + ((int )new->alt - 1))) + i)) = (*c);
        free((void *)c);
        free((void *)h);
        i ++;
      }
      if (error) {
        break;
      }
    }
    if (start) {
      strcat((char * __restrict  )hexnew, (char const   * __restrict  )start);
    }
    hex___0 = hexnew;
    free((void *)hexcpy);
    if (error) {
      free((void *)hexnew);
      if (new->alt) {
        free((void *)new->altn);
        i = 0U;
        while (i < (unsigned int )new->alt) {
          if ((*(new->altc + i))) {
            free((void *)(*(new->altc + i)));
          }
          i ++;
        }
        free((void *)new->altc);
      }
      free((void *)new);
      return (-5);
    }
  } else {
    hex___0 = (char *)hexsig;
  }
  tmp___44 = strlen((char const   *)hex___0);
  new->length = tmp___44 / 2U;
  if (new->length > root->maxpatlen) {
    root->maxpatlen = new->length;
  }
  new->pattern = cli_hex2si((char const   *)hex___0);
  if ((unsigned int )new->pattern == (unsigned int )((void *)0)) {
    if (new->alt) {
      free((void *)new->altn);
      i = 0U;
      while (i < (unsigned int )new->alt) {
        free((void *)(*(new->altc + i)));
        i ++;
      }
      free((void *)new->altc);
      free((void *)hex___0);
    }
    free((void *)new);
    return (-5);
  }
  pt = strstr(virname, "(Clam)");
  if (pt) {
    tmp___45 = strlen(virname);
    tmp___46 = strlen((char const   *)pt);
    virlen = (int )((tmp___45 - tmp___46) - 1U);
  } else {
    virlen = (int )strlen(virname);
  }
  if (virlen <= 0) {
    free((void *)new->pattern);
    if (new->alt) {
      free((void *)new->altn);
      i = 0U;
      while (i < (unsigned int )new->alt) {
        free((void *)(*(new->altc + i)));
        i ++;
      }
      free((void *)new->altc);
      free((void *)hex___0);
    }
    free((void *)new);
    return (-5);
  }
  new->virname = (char *)cli_calloc((unsigned int )(virlen + 1), sizeof(char ));
  if ((unsigned int )new->virname == (unsigned int )((void *)0)) {
    free((void *)new->pattern);
    if (new->alt) {
      free((void *)new->altn);
      i = 0U;
      while (i < (unsigned int )new->alt) {
        free((void *)(*(new->altc + i)));
        i ++;
      }
      free((void *)new->altc);
      free((void *)hex___0);
    }
    free((void *)new);
    return (-3);
  }
  __builtin_strncpy(new->virname, virname, virlen);
  ret = cli_ac_addpatt(root, new);
  if (ret) {
    free((void *)new->pattern);
    free((void *)new->virname);
    if (new->alt) {
      free((void *)new->altn);
      i = 0U;
      while (i < (unsigned int )new->alt) {
        free((void *)(*(new->altc + i)));
        i ++;
      }
      free((void *)new->altc);
      free((void *)hex___0);
    }
    free((void *)new);
    return (ret);
  }
  if (new->alt) {
    free((void *)hex___0);
  }
  return (0);
}
}
//extern int __builtin_strpbrk() ;
int cli_parse_add(struct cl_node *root , char const   *virname , char const   *hexsig ,
                  unsigned short type , char *offset , unsigned short target ) 
{ struct cli_bm_patt *bm_new ;
  char *pt ;
  char *hexcpy ;
  char *start ;
  char *n ;
  int ret ;
  int virlen ;
  int asterisk ;
  unsigned int i ;
  unsigned int j ;
  unsigned int len ;
  unsigned int parts ;
  int mindist ;
  int maxdist ;
  int error ;
  size_t __len___2 ;
  size_t tmp___15 ;
  char *__retval___2 ;
  char *tmp___16 ;
  int tmp___18 ;
  size_t tmp___19 ;
  char *tmp___20 ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___30 ;
  int tmp___32 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___36 ;
  char __a0 ;
  char __a1 ;
  char __a2 ;
  char *tmp___102 ;
  int tmp___164 ;
  int tmp___165 ;
  char *tmp___169 ;
  int tmp___171 ;
  char *tmp___175 ;
  int tmp___177 ;

  {
  asterisk = 0;
  parts = 0U;
  mindist = 0;
  maxdist = 0;
  error = 0;
  tmp___177 = __builtin_constant_p((int )hexsig);
  if (tmp___177) {
    tmp___175 = (char *)__builtin_strchr(hexsig, '{');
  } else {
    tmp___175 = (char *)__builtin_strchr(hexsig, '{');
  }
  if (tmp___175) {
    root->ac_partsigs = root->ac_partsigs + 1U;
    tmp___18 = __builtin_constant_p((int )hexsig);
    if (tmp___18) {
      if ((unsigned int )((void const   *)(hexsig + 1)) - (unsigned int )((void const   *)hexsig) ==
          1U) {
        if ((int const   )(*(hexsig + 0)) == 0) {
          hexcpy = (char *)calloc(1U, 1U);
        } else {
          tmp___15 = strlen(hexsig);
          __len___2 = tmp___15 + 1U;
          tmp___16 = (char *)malloc(__len___2);
          __retval___2 = tmp___16;
          if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
            __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )hexsig,
                                          __len___2);
          }
          hexcpy = __retval___2;
        }
      } else {
        hexcpy = __strdup(hexsig);
      }
    } else {
      hexcpy = __strdup(hexsig);
    }
    if (! hexcpy) {
      return (-3);
    }
    len = strlen(hexsig);
    i = 0U;
    while (i < len) {
      if ((int const   )(*(hexsig + i)) == 123) {
        parts ++;
      } else {
        if ((int const   )(*(hexsig + i)) == 42) {
          parts ++;
        }
      }
      i ++;
    }
    if (parts) {
      parts ++;
    }
    pt = hexcpy;
    start = pt;
    i = 1U;
    while (i <= parts) {
      if (i != parts) {
        j = 0U;
        while (1) {
          tmp___19 = strlen((char const   *)start);
          if (! (j < tmp___19)) {
            break;
          }
          if ((int )(*(start + j)) == 123) {
            asterisk = 0;
            pt = start + j;
            break;
          }
          if ((int )(*(start + j)) == 42) {
            asterisk = 1;
            pt = start + j;
            break;
          }
          j ++;
        }
        tmp___20 = pt;
        pt ++;
        (*tmp___20) = (char)0;
      }
      ret = cli_ac_addsig(root, virname, (char const   *)start, (int )root->ac_partsigs,
                          (int )parts, (int )i, type, (unsigned int )mindist, (unsigned int )maxdist,
                          offset, target);
      if (ret) {
        cli_errmsg("cli_parse_add(): Problem adding signature (1).\n");
        error = 1;
        break;
      }
      if (i == parts) {
        break;
      }
      maxdist = 0;
      mindist = maxdist;
      if (asterisk) {
        start = pt;
        goto __Cont;
      }
      tmp___25 = __builtin_constant_p((int )pt);
      if (tmp___25) {
        start = (char *)__builtin_strchr(pt, '}');
      } else {
        start = (char *)__builtin_strchr(pt, '}');
      }
      if (! start) {
        error = 1;
        break;
      }
      tmp___26 = start;
      start ++;
      (*tmp___26) = (char)0;
      if (! pt) {
        error = 1;
        break;
      }
      tmp___32 = __builtin_constant_p((int )pt);
      if (tmp___32) {
        tmp___30 = (char *)__builtin_strchr(pt, '-');
      } else {
        tmp___30 = (char *)__builtin_strchr(pt, '-');
      }
      if (tmp___30) {
        n = cli_strtok((char const   *)pt, 0, "-");
        if (n) {
          mindist = atoi__extinline((char const   *)n);
          if (mindist < 0) {
            error = 1;
            free((void *)n);
            break;
          }
          free((void *)n);
        }
        n = cli_strtok((char const   *)pt, 1, "-");
        if (n) {
          maxdist = atoi__extinline((char const   *)n);
          if (maxdist < 0) {
            error = 1;
            free((void *)n);
            break;
          }
          free((void *)n);
        }
      } else {
        maxdist = atoi__extinline((char const   *)pt);
        mindist = maxdist;
        if (mindist < 0) {
          error = 1;
          break;
        }
      }
      __Cont: 
      i ++;
    }
    free((void *)hexcpy);
    if (error) {
      return (-5);
    }
  } else {
    tmp___171 = __builtin_constant_p((int )hexsig);
    if (tmp___171) {
      tmp___169 = (char *)__builtin_strchr(hexsig, '*');
    } else {
      tmp___169 = (char *)__builtin_strchr(hexsig, '*');
    }
    if (tmp___169) {
      root->ac_partsigs = root->ac_partsigs + 1U;
      len = strlen(hexsig);
      i = 0U;
      while (i < len) {
        if ((int const   )(*(hexsig + i)) == 42) {
          parts ++;
        }
        i ++;
      }
      if (parts) {
        parts ++;
      }
      i = 1U;
      while (i <= parts) {
        pt = cli_strtok(hexsig, (int )(i - 1U), "*");
        if ((unsigned int )pt == (unsigned int )((void *)0)) {
          cli_errmsg("Can\'t extract part %d of partial signature.\n", i + 1U);
          return (-5);
        }
        ret = cli_ac_addsig(root, virname, (char const   *)pt, (int )root->ac_partsigs,
                            (int )parts, (int )i, type, 0U, 0U, offset, target);
        if (ret) {
          cli_errmsg("cli_parse_add(): Problem adding signature (2).\n");
          free((void *)pt);
          return (ret);
        }
        free((void *)pt);
        i ++;
      }
    } else {
      tmp___165 = __builtin_constant_p((int )"?(");
      if (tmp___165) {
        if ((unsigned int )((void const   *)("?(" + 1)) - (unsigned int )((void const   *)"?(") ==
            1U) {
          tmp___164 = __builtin_constant_p((int )hexsig);
          if (tmp___164) {
            if ((unsigned int )((void const   *)(hexsig + 1)) - (unsigned int )((void const   *)hexsig) ==
                1U) {
              tmp___102 = (char *)__builtin_strpbrk(hexsig, "?(");
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
            __a0 = (char )(*("?(" + 0));
            if ((int )__a0 == 0) {
              tmp___102 = (char *)((void *)0);
            } else {
              __a1 = (char )(*("?(" + 1));
              if ((int )__a1 == 0) {
                tmp___102 = (char *)__builtin_strchr(hexsig, __a0);
              } else {
                __a2 = (char )(*("?(" + 2));
                if ((int )__a2 == 0) {
                  tmp___102 = __strpbrk_c2__extinline(hexsig, (int )__a0, (int )__a1);
                } else {
                  if ((int const   )(*("?(" + 3)) == 0) {
                    tmp___102 = __strpbrk_c3__extinline(hexsig, (int )__a0, (int )__a1,
                                                        (int )__a2);
                  } else {
                    tmp___102 = (char *)__builtin_strpbrk(hexsig, "?(");
                  }
                }
              }
            }
          }
        } else {
          tmp___102 = (char *)__builtin_strpbrk(hexsig, "?(");
        }
      } else {
        tmp___102 = (char *)__builtin_strpbrk(hexsig, "?(");
      }
      if (tmp___102) {
        goto _L___1;
      } else {
        if (type) {
          _L___1: 
          ret = cli_ac_addsig(root, virname, hexsig, 0, 0, 0, type, 0U, 0U, offset,
                              target);
          if (ret) {
            cli_errmsg("cli_parse_add(): Problem adding signature (3).\n");
            return (ret);
          }
        } else {
          bm_new = (struct cli_bm_patt *)calloc(1U, sizeof(struct cli_bm_patt ));
          if (! bm_new) {
            return (-3);
          }
          bm_new->pattern = cli_hex2str(hexsig);
          if (! bm_new->pattern) {
            free((void *)bm_new);
            return (-5);
          }
          tmp___34 = strlen(hexsig);
          bm_new->length = tmp___34 / 2U;
          pt = strstr(virname, "(Clam)");
          if (pt) {
            tmp___35 = strlen(virname);
            tmp___36 = strlen((char const   *)pt);
            virlen = (int )((tmp___35 - tmp___36) - 1U);
          } else {
            virlen = (int )strlen(virname);
          }
          if (virlen <= 0) {
            free((void *)bm_new->pattern);
            free((void *)bm_new);
            return (-5);
          }
          bm_new->virname = (char *)cli_calloc((unsigned int )(virlen + 1), sizeof(char ));
          if ((unsigned int )bm_new->virname == (unsigned int )((void *)0)) {
            free((void *)bm_new->pattern);
            free((void *)bm_new);
            return (-3);
          }
          __builtin_strncpy(bm_new->virname, virname, virlen);
          bm_new->offset = offset;
          bm_new->target = target;
          if (bm_new->length > root->maxpatlen) {
            root->maxpatlen = bm_new->length;
          }
          ret = cli_bm_addpatt(root, bm_new);
          if (ret) {
            cli_errmsg("cli_parse_add(): Problem adding signature (4).\n");
            free((void *)bm_new->pattern);
            free((void *)bm_new->virname);
            free((void *)bm_new);
            return (ret);
          }
        }
      }
    }
  }
  return (0);
}
}
static int cli_loaddb(FILE *fd , struct cl_node **root , unsigned int *signo ) 
{ char buffer[8192] ;
  char *pt ;
  char *start ;
  int line ;
  int ret ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  line = 0;
  ret = 0;
  if (! (*root)) {
    cli_dbgmsg("Initializing main node\n");
    (*root) = (struct cl_node *)cli_calloc(1U, sizeof(struct cl_node ));
    if (! (*root)) {
      return (-3);
    }
    ((*root))->refcount = 1U;
  }
  if (! ((*root))->ac_root) {
    cli_dbgmsg("Initializing trie\n");
    ((*root))->ac_root = (struct cli_ac_node *)cli_calloc(1U, sizeof(struct cli_ac_node ));
    if (! ((*root))->ac_root) {
      free((void *)(*root));
      cli_errmsg("Can\'t initialise AC pattern matcher\n");
      return (-3);
    }
  }
  if (! ((*root))->bm_shift) {
    cli_dbgmsg("Initializing BM tables\n");
    ret = cli_bm_init((*root));
    if (ret) {
      cli_errmsg("Can\'t initialise BM pattern matcher\n");
      return (ret);
    }
  }
  while (1) {
    tmp___7 = fgets((char * __restrict  )(buffer), 8192, (FILE * __restrict  )fd);
    if (! tmp___7) {
      break;
    }
    line ++;
    cli_chomp(buffer);
    tmp___5 = __builtin_constant_p((int )(buffer));
    if (tmp___5) {
      pt = (char *)__builtin_strchr(buffer, '=');
    } else {
      pt = (char *)__builtin_strchr(buffer, '=');
    }
    if (! pt) {
      cli_errmsg("Malformed pattern line %d\n", line);
      ret = -5;
      break;
    }
    start = buffer;
    tmp___6 = pt;
    pt ++;
    (*tmp___6) = (char)0;
    if ((int )(*pt) == 61) {
      continue;
    }
    ret = cli_parse_add((*root), (char const   *)start, (char const   *)pt, (unsigned short)0,
                        (char *)((void *)0), (unsigned short)0);
    if (ret) {
      cli_errmsg("Problem parsing signature at line %d\n", line);
      ret = -5;
      break;
    }
  }
  if (! line) {
    cli_errmsg("Empty database file\n");
    cl_free((*root));
    return (-5);
  }
  if (ret) {
    cli_errmsg("Problem parsing database at line %d\n", line);
    cl_free((*root));
    return (ret);
  }
  if (signo) {
    (*signo) += (unsigned int )line;
  }
  return (0);
}
}
static int cli_loadndb(FILE *fd , struct cl_node **root , unsigned int *signo ) 
{ char buffer[8192] ;
  char *sig ;
  char *virname ;
  char *offset ;
  char *pt ;
  int line ;
  int sigs ;
  int ret ;
  unsigned short target ;
  int tmp___75 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___111 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___130 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  size_t tmp___146 ;
  int tmp___147 ;
  size_t tmp___148 ;
  unsigned short const   **tmp___149 ;
  int tmp___150 ;
  int tmp___151 ;
  unsigned short const   **tmp___152 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___189 ;
  unsigned char const   *__s2___22 ;
  register int __result___66 ;
  int tmp___208 ;
  unsigned char const   *__s1___46 ;
  register int __result___70 ;
  int tmp___217 ;
  int tmp___218 ;
  int tmp___219 ;
  int tmp___220 ;
  int tmp___221 ;
  int tmp___222 ;
  char *tmp___223 ;

  {
  line = 0;
  sigs = 0;
  ret = 0;
  if (! (*root)) {
    cli_dbgmsg("Initializing main node\n");
    (*root) = (struct cl_node *)cli_calloc(1U, sizeof(struct cl_node ));
    if (! (*root)) {
      return (-3);
    }
    ((*root))->refcount = 1U;
  }
  if (! ((*root))->ac_root) {
    cli_dbgmsg("Initializing trie\n");
    ((*root))->ac_root = (struct cli_ac_node *)cli_calloc(1U, sizeof(struct cli_ac_node ));
    if (! ((*root))->ac_root) {
      free((void *)(*root));
      cli_errmsg("Can\'t initialise AC pattern matcher\n");
      return (-3);
    }
  }
  if (! ((*root))->bm_shift) {
    cli_dbgmsg("Initializing BM tables\n");
    ret = cli_bm_init((*root));
    if (ret) {
      cli_errmsg("Can\'t initialise BM pattern matcher\n");
      return (ret);
    }
  }
  while (1) {
    tmp___223 = fgets((char * __restrict  )(buffer), 8192, (FILE * __restrict  )fd);
    if (! tmp___223) {
      break;
    }
    line ++;
    tmp___145 = __builtin_constant_p((int )(buffer));
    if (tmp___145) {
      tmp___146 = strlen((char const   *)(buffer));
      if (tmp___146 < 20U) {
        goto _L___39;
      } else {
        goto _L___40;
      }
    } else {
      _L___40: 
      tmp___147 = __builtin_constant_p((int )"Exploit.JPEG.Comment");
      if (tmp___147) {
        tmp___148 = strlen("Exploit.JPEG.Comment");
        if (tmp___148 < 20U) {
          _L___39: 
          tmp___142 = __builtin_constant_p((int )(buffer));
          if (tmp___142) {
            tmp___143 = __builtin_constant_p((int )"Exploit.JPEG.Comment");
            if (tmp___143) {
              __s1_len___0 = strlen((char const   *)(buffer));
              __s2_len___0 = strlen("Exploit.JPEG.Comment");
              if (! ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                     1U)) {
                goto _L___36;
              } else {
                if (__s1_len___0 >= 4U) {
                  _L___36: 
                  if (! ((unsigned int )((void const   *)("Exploit.JPEG.Comment" +
                                                          1)) - (unsigned int )((void const   *)"Exploit.JPEG.Comment") ==
                         1U)) {
                    tmp___144 = 1;
                  } else {
                    if (__s2_len___0 >= 4U) {
                      tmp___144 = 1;
                    } else {
                      tmp___144 = 0;
                    }
                  }
                } else {
                  tmp___144 = 0;
                }
              }
              if (tmp___144) {
                tmp___111 = __builtin_strcmp(buffer, "Exploit.JPEG.Comment");
              } else {
                goto _L___38;
              }
            } else {
              goto _L___38;
            }
          } else {
            _L___38: 
            tmp___141 = __builtin_constant_p((int )(buffer));
            if (tmp___141) {
              if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                  1U) {
                __s1_len___0 = strlen((char const   *)(buffer));
                if (__s1_len___0 < 4U) {
                  tmp___130 = __builtin_constant_p((int )"Exploit.JPEG.Comment");
                  if (tmp___130) {
                    if ((unsigned int )((void const   *)("Exploit.JPEG.Comment" +
                                                         1)) - (unsigned int )((void const   *)"Exploit.JPEG.Comment") ==
                        1U) {
                      tmp___111 = __builtin_strcmp(buffer, "Exploit.JPEG.Comment");
                    } else {
                      goto _L___31;
                    }
                  } else {
                    _L___31: 
                    __s2___14 = (unsigned char const   *)"Exploit.JPEG.Comment";
                    __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                            0)) - (int const   )(*(__s2___14 +
                                                                                   0)));
                    if (__s1_len___0 > 0U) {
                      if (__result___42 == 0) {
                        __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                1)) - (int const   )(*(__s2___14 +
                                                                                       1)));
                        if (__s1_len___0 > 1U) {
                          if (__result___42 == 0) {
                            __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                    2)) - (int const   )(*(__s2___14 +
                                                                                           2)));
                            if (__s1_len___0 > 2U) {
                              if (__result___42 == 0) {
                                __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                        3)) - (int const   )(*(__s2___14 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___111 = __result___42;
                  }
                } else {
                  goto _L___35;
                }
              } else {
                goto _L___35;
              }
            } else {
              _L___35: 
              tmp___140 = __builtin_constant_p((int )"Exploit.JPEG.Comment");
              if (tmp___140) {
                if ((unsigned int )((void const   *)("Exploit.JPEG.Comment" + 1)) -
                    (unsigned int )((void const   *)"Exploit.JPEG.Comment") == 1U) {
                  __s2_len___0 = strlen("Exploit.JPEG.Comment");
                  if (__s2_len___0 < 4U) {
                    tmp___139 = __builtin_constant_p((int )(buffer));
                    if (tmp___139) {
                      if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                          1U) {
                        tmp___111 = __builtin_strcmp(buffer, "Exploit.JPEG.Comment");
                      } else {
                        goto _L___33;
                      }
                    } else {
                      _L___33: 
                      __s1___30 = (unsigned char const   *)((char const   *)(buffer));
                      __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)"Exploit.JPEG.Comment" +
                                                                                                 0)));
                      if (__s2_len___0 > 0U) {
                        if (__result___46 == 0) {
                          __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                 (int const   )(*((unsigned char const   *)"Exploit.JPEG.Comment" +
                                                                  1)));
                          if (__s2_len___0 > 1U) {
                            if (__result___46 == 0) {
                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                      2)) - (int const   )(*((unsigned char const   *)"Exploit.JPEG.Comment" +
                                                                                             2)));
                              if (__s2_len___0 > 2U) {
                                if (__result___46 == 0) {
                                  __result___46 = (int )((int const   )(*(__s1___30 +
                                                                          3)) - (int const   )(*((unsigned char const   *)"Exploit.JPEG.Comment" +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___111 = __result___46;
                    }
                  } else {
                    tmp___111 = __builtin_strcmp(buffer, "Exploit.JPEG.Comment");
                  }
                } else {
                  tmp___111 = __builtin_strcmp(buffer, "Exploit.JPEG.Comment");
                }
              } else {
                tmp___111 = __builtin_strcmp(buffer, "Exploit.JPEG.Comment");
              }
            }
          }
          tmp___75 = tmp___111;
        } else {
          tmp___75 = strncmp((char const   *)(buffer), "Exploit.JPEG.Comment", 20U);
        }
      } else {
        tmp___75 = strncmp((char const   *)(buffer), "Exploit.JPEG.Comment", 20U);
      }
    }
    if (! tmp___75) {
      continue;
    }
    sigs ++;
    cli_chomp(buffer);
    virname = cli_strtok((char const   *)(buffer), 0, ":");
    if (! virname) {
      ret = -5;
      break;
    }
    pt = cli_strtok((char const   *)(buffer), 4, ":");
    if (pt) {
      tmp___149 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___149) + (int )(*pt))) & 2048)) {
        free((void *)virname);
        free((void *)pt);
        ret = -5;
        break;
      }
      tmp___150 = atoi__extinline((char const   *)pt);
      tmp___151 = cl_retflevel();
      if (tmp___150 > tmp___151) {
        cli_warnmsg("Signature for %s requires new ClamAV version. Please update!\n",
                    virname);
        sigs --;
        free((void *)virname);
        free((void *)pt);
        continue;
      }
      free((void *)pt);
    }
    pt = cli_strtok((char const   *)(buffer), 1, ":");
    if (pt) {
      tmp___152 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___152) + (int )(*pt))) & 2048)) {
        _L___41: 
        free((void *)virname);
        if (pt) {
          free((void *)pt);
        }
        ret = -5;
        break;
      }
    } else {
      goto _L___41;
    }
    target = (unsigned short )atoi__extinline((char const   *)pt);
    free((void *)pt);
    offset = cli_strtok((char const   *)(buffer), 2, ":");
    if (offset) {
      tmp___220 = __builtin_constant_p((int )offset);
      if (tmp___220) {
        tmp___221 = __builtin_constant_p((int )"*");
        if (tmp___221) {
          __s1_len___1 = strlen((char const   *)offset);
          __s2_len___1 = strlen("*");
          if (! ((unsigned int )((void const   *)(offset + 1)) - (unsigned int )((void const   *)offset) ==
                 1U)) {
            goto _L___59;
          } else {
            if (__s1_len___1 >= 4U) {
              _L___59: 
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                     1U)) {
                tmp___222 = 1;
              } else {
                if (__s2_len___1 >= 4U) {
                  tmp___222 = 1;
                } else {
                  tmp___222 = 0;
                }
              }
            } else {
              tmp___222 = 0;
            }
          }
          if (tmp___222) {
            tmp___189 = __builtin_strcmp(offset, "*");
          } else {
            goto _L___61;
          }
        } else {
          goto _L___61;
        }
      } else {
        _L___61: 
        tmp___219 = __builtin_constant_p((int )offset);
        if (tmp___219) {
          if ((unsigned int )((void const   *)(offset + 1)) - (unsigned int )((void const   *)offset) ==
              1U) {
            __s1_len___1 = strlen((char const   *)offset);
            if (__s1_len___1 < 4U) {
              tmp___208 = __builtin_constant_p((int )"*");
              if (tmp___208) {
                if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                    1U) {
                  tmp___189 = __builtin_strcmp(offset, "*");
                } else {
                  goto _L___54;
                }
              } else {
                _L___54: 
                __s2___22 = (unsigned char const   *)"*";
                __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)offset) +
                                                        0)) - (int const   )(*(__s2___22 +
                                                                               0)));
                if (__s1_len___1 > 0U) {
                  if (__result___66 == 0) {
                    __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)offset) +
                                                            1)) - (int const   )(*(__s2___22 +
                                                                                   1)));
                    if (__s1_len___1 > 1U) {
                      if (__result___66 == 0) {
                        __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)offset) +
                                                                2)) - (int const   )(*(__s2___22 +
                                                                                       2)));
                        if (__s1_len___1 > 2U) {
                          if (__result___66 == 0) {
                            __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)offset) +
                                                                    3)) - (int const   )(*(__s2___22 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___189 = __result___66;
              }
            } else {
              goto _L___58;
            }
          } else {
            goto _L___58;
          }
        } else {
          _L___58: 
          tmp___218 = __builtin_constant_p((int )"*");
          if (tmp___218) {
            if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                1U) {
              __s2_len___1 = strlen("*");
              if (__s2_len___1 < 4U) {
                tmp___217 = __builtin_constant_p((int )offset);
                if (tmp___217) {
                  if ((unsigned int )((void const   *)(offset + 1)) - (unsigned int )((void const   *)offset) ==
                      1U) {
                    tmp___189 = __builtin_strcmp(offset, "*");
                  } else {
                    goto _L___56;
                  }
                } else {
                  _L___56: 
                  __s1___46 = (unsigned char const   *)((char const   *)offset);
                  __result___70 = (int )((int const   )(*(__s1___46 + 0)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             0)));
                  if (__s2_len___1 > 0U) {
                    if (__result___70 == 0) {
                      __result___70 = (int )((int const   )(*(__s1___46 + 1)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                                 1)));
                      if (__s2_len___1 > 1U) {
                        if (__result___70 == 0) {
                          __result___70 = (int )((int const   )(*(__s1___46 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"*" +
                                                                  2)));
                          if (__s2_len___1 > 2U) {
                            if (__result___70 == 0) {
                              __result___70 = (int )((int const   )(*(__s1___46 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___189 = __result___70;
                }
              } else {
                tmp___189 = __builtin_strcmp(offset, "*");
              }
            } else {
              tmp___189 = __builtin_strcmp(offset, "*");
            }
          } else {
            tmp___189 = __builtin_strcmp(offset, "*");
          }
        }
      }
      if (! tmp___189) {
        free((void *)offset);
        offset = (char *)((void *)0);
      }
    } else {
      free((void *)virname);
      ret = -5;
      break;
    }
    sig = cli_strtok((char const   *)(buffer), 3, ":");
    if (! sig) {
      free((void *)virname);
      free((void *)offset);
      ret = -5;
      break;
    }
    ret = cli_parse_add((*root), (char const   *)virname, (char const   *)sig, (unsigned short)0,
                        offset, target);
    if (ret) {
      cli_errmsg("Problem parsing signature at line %d\n", line);
      free((void *)virname);
      free((void *)offset);
      free((void *)sig);
      ret = -5;
      break;
    }
    free((void *)virname);
    free((void *)sig);
  }
  if (! line) {
    cli_errmsg("Empty database file\n");
    cl_free((*root));
    return (-5);
  }
  if (ret) {
    cli_errmsg("Problem parsing database at line %d\n", line);
    cl_free((*root));
    return (ret);
  }
  if (signo) {
    (*signo) += (unsigned int )sigs;
  }
  return (0);
}
}
static int cli_loadhdb(FILE *fd , struct cl_node **root , unsigned int *signo , unsigned short fp ) 
{ char buffer[8192] ;
  char *pt ;
  int line ;
  int ret ;
  struct cli_md5_node *new ;
  char *tmp___3 ;

  {
  line = 0;
  ret = 0;
  if (! (*root)) {
    cli_dbgmsg("Initializing main node\n");
    (*root) = (struct cl_node *)cli_calloc(1U, sizeof(struct cl_node ));
    if (! (*root)) {
      return (-3);
    }
    ((*root))->refcount = 1U;
  }
  while (1) {
    tmp___3 = fgets((char * __restrict  )(buffer), 8192, (FILE * __restrict  )fd);
    if (! tmp___3) {
      break;
    }
    line ++;
    cli_chomp(buffer);
    new = (struct cli_md5_node *)cli_calloc(1U, sizeof(struct cli_md5_node ));
    if (! new) {
      ret = -3;
      break;
    }
    new->fp = fp;
    pt = cli_strtok((char const   *)(buffer), 0, ":");
    if (! pt) {
      free((void *)new);
      ret = -5;
      break;
    }
    new->md5 = (unsigned char *)cli_hex2str((char const   *)pt);
    if (! new->md5) {
      cli_errmsg("Malformed MD5 string at line %d\n", line);
      free((void *)pt);
      free((void *)new);
      ret = -5;
      break;
    }
    free((void *)pt);
    pt = cli_strtok((char const   *)(buffer), 1, ":");
    if (! pt) {
      free((void *)new->md5);
      free((void *)new);
      ret = -5;
      break;
    }
    new->size = (unsigned int )atoi__extinline((char const   *)pt);
    free((void *)pt);
    new->virname = cli_strtok((char const   *)(buffer), 2, ":");
    if (! new->virname) {
      free((void *)new->md5);
      free((void *)new);
      ret = -5;
      break;
    }
    new->viralias = cli_strtok((char const   *)(buffer), 3, ":");
    if (! ((*root))->md5_hlist) {
      cli_dbgmsg("Initializing md5 list structure\n");
      ((*root))->md5_hlist = (struct cli_md5_node **)cli_calloc(256U, sizeof(struct cli_md5_node *));
      if (! ((*root))->md5_hlist) {
        ret = -3;
        break;
      }
    }
    new->next = (*(((*root))->md5_hlist + ((int )(*(new->md5 + 0)) & 255)));
    (*(((*root))->md5_hlist + ((int )(*(new->md5 + 0)) & 255))) = new;
  }
  if (! line) {
    cli_errmsg("Empty database file\n");
    cl_free((*root));
    return (-5);
  }
  if (ret) {
    cli_errmsg("Problem parsing database at line %d\n", line);
    cl_free((*root));
    return (ret);
  }
  if (signo) {
    (*signo) += (unsigned int )line;
  }
  return (0);
}
}
static int cli_loadmd(FILE *fd , struct cl_node **root , unsigned int *signo , int type ) 
{ char buffer[8192] ;
  char *pt ;
  int line ;
  int comments ;
  int ret ;
  struct cli_meta_node *new ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___36 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___55 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___105 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___124 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___133 ;
  int tmp___134 ;
  int tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___174 ;
  unsigned char const   *__s2___22 ;
  register int __result___66 ;
  int tmp___193 ;
  unsigned char const   *__s1___46 ;
  register int __result___70 ;
  int tmp___202 ;
  int tmp___203 ;
  int tmp___204 ;
  int tmp___205 ;
  int tmp___206 ;
  int tmp___207 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___243 ;
  unsigned char const   *__s2___30 ;
  register int __result___90 ;
  int tmp___262 ;
  unsigned char const   *__s1___62 ;
  register int __result___94 ;
  int tmp___271 ;
  int tmp___272 ;
  int tmp___273 ;
  int tmp___274 ;
  int tmp___275 ;
  int tmp___276 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___312 ;
  unsigned char const   *__s2___38 ;
  register int __result___114 ;
  int tmp___331 ;
  unsigned char const   *__s1___78 ;
  register int __result___118 ;
  int tmp___340 ;
  int tmp___341 ;
  int tmp___342 ;
  int tmp___343 ;
  int tmp___344 ;
  int tmp___345 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___381 ;
  unsigned char const   *__s2___46 ;
  register int __result___138 ;
  int tmp___400 ;
  unsigned char const   *__s1___94 ;
  register int __result___142 ;
  int tmp___409 ;
  int tmp___410 ;
  int tmp___411 ;
  int tmp___412 ;
  int tmp___413 ;
  int tmp___414 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___450 ;
  unsigned char const   *__s2___54 ;
  register int __result___162 ;
  int tmp___469 ;
  unsigned char const   *__s1___110 ;
  register int __result___166 ;
  int tmp___478 ;
  int tmp___479 ;
  int tmp___480 ;
  int tmp___481 ;
  int tmp___482 ;
  int tmp___483 ;
  char *tmp___484 ;

  {
  line = 0;
  comments = 0;
  ret = 0;
  if (! (*root)) {
    cli_dbgmsg("Initializing main node\n");
    (*root) = (struct cl_node *)cli_calloc(1U, sizeof(struct cl_node ));
    if (! (*root)) {
      return (-3);
    }
    ((*root))->refcount = 1U;
  }
  while (1) {
    tmp___484 = fgets((char * __restrict  )(buffer), 8192, (FILE * __restrict  )fd);
    if (! tmp___484) {
      break;
    }
    line ++;
    if ((int )buffer[0] == 35) {
      comments ++;
      continue;
    }
    cli_chomp(buffer);
    new = (struct cli_meta_node *)cli_calloc(1U, sizeof(struct cli_meta_node ));
    if (! new) {
      ret = -3;
      break;
    }
    new->virname = cli_strtok((char const   *)(buffer), 0, ":");
    if (! new->virname) {
      free((void *)new);
      ret = -5;
      break;
    }
    pt = cli_strtok((char const   *)(buffer), 1, ":");
    if (pt) {
      new->encrypted = (unsigned int )atoi__extinline((char const   *)pt);
      free((void *)pt);
    } else {
      free((void *)new->virname);
      free((void *)new);
      ret = -5;
      break;
    }
    new->filename = cli_strtok((char const   *)(buffer), 2, ":");
    if (new->filename) {
      tmp___67 = __builtin_constant_p((int )new->filename);
      if (tmp___67) {
        tmp___68 = __builtin_constant_p((int )"*");
        if (tmp___68) {
          __s1_len = strlen((char const   *)new->filename);
          __s2_len = strlen("*");
          if (! ((unsigned int )((void const   *)(new->filename + 1)) - (unsigned int )((void const   *)new->filename) ==
                 1U)) {
            goto _L___16;
          } else {
            if (__s1_len >= 4U) {
              _L___16: 
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                     1U)) {
                tmp___69 = 1;
              } else {
                if (__s2_len >= 4U) {
                  tmp___69 = 1;
                } else {
                  tmp___69 = 0;
                }
              }
            } else {
              tmp___69 = 0;
            }
          }
          if (tmp___69) {
            tmp___36 = __builtin_strcmp(new->filename, "*");
          } else {
            goto _L___18;
          }
        } else {
          goto _L___18;
        }
      } else {
        _L___18: 
        tmp___66 = __builtin_constant_p((int )new->filename);
        if (tmp___66) {
          if ((unsigned int )((void const   *)(new->filename + 1)) - (unsigned int )((void const   *)new->filename) ==
              1U) {
            __s1_len = strlen((char const   *)new->filename);
            if (__s1_len < 4U) {
              tmp___55 = __builtin_constant_p((int )"*");
              if (tmp___55) {
                if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                    1U) {
                  tmp___36 = __builtin_strcmp(new->filename, "*");
                } else {
                  goto _L___11;
                }
              } else {
                _L___11: 
                __s2___6 = (unsigned char const   *)"*";
                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)new->filename) +
                                                        0)) - (int const   )(*(__s2___6 +
                                                                               0)));
                if (__s1_len > 0U) {
                  if (__result___18 == 0) {
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)new->filename) +
                                                            1)) - (int const   )(*(__s2___6 +
                                                                                   1)));
                    if (__s1_len > 1U) {
                      if (__result___18 == 0) {
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)new->filename) +
                                                                2)) - (int const   )(*(__s2___6 +
                                                                                       2)));
                        if (__s1_len > 2U) {
                          if (__result___18 == 0) {
                            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)new->filename) +
                                                                    3)) - (int const   )(*(__s2___6 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___36 = __result___18;
              }
            } else {
              goto _L___15;
            }
          } else {
            goto _L___15;
          }
        } else {
          _L___15: 
          tmp___65 = __builtin_constant_p((int )"*");
          if (tmp___65) {
            if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                1U) {
              __s2_len = strlen("*");
              if (__s2_len < 4U) {
                tmp___64 = __builtin_constant_p((int )new->filename);
                if (tmp___64) {
                  if ((unsigned int )((void const   *)(new->filename + 1)) - (unsigned int )((void const   *)new->filename) ==
                      1U) {
                    tmp___36 = __builtin_strcmp(new->filename, "*");
                  } else {
                    goto _L___13;
                  }
                } else {
                  _L___13: 
                  __s1___14 = (unsigned char const   *)((char const   *)new->filename);
                  __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             0)));
                  if (__s2_len > 0U) {
                    if (__result___22 == 0) {
                      __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                                 1)));
                      if (__s2_len > 1U) {
                        if (__result___22 == 0) {
                          __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"*" +
                                                                  2)));
                          if (__s2_len > 2U) {
                            if (__result___22 == 0) {
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___36 = __result___22;
                }
              } else {
                tmp___36 = __builtin_strcmp(new->filename, "*");
              }
            } else {
              tmp___36 = __builtin_strcmp(new->filename, "*");
            }
          } else {
            tmp___36 = __builtin_strcmp(new->filename, "*");
          }
        }
      }
      if (! tmp___36) {
        free((void *)new->filename);
        new->filename = (char *)((void *)0);
      }
    } else {
      free((void *)new->virname);
      free((void *)new);
      ret = -5;
      break;
    }
    pt = cli_strtok((char const   *)(buffer), 3, ":");
    if (pt) {
      tmp___136 = __builtin_constant_p((int )pt);
      if (tmp___136) {
        tmp___137 = __builtin_constant_p((int )"*");
        if (tmp___137) {
          __s1_len___0 = strlen((char const   *)pt);
          __s2_len___0 = strlen("*");
          if (! ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                 1U)) {
            goto _L___36;
          } else {
            if (__s1_len___0 >= 4U) {
              _L___36: 
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                     1U)) {
                tmp___138 = 1;
              } else {
                if (__s2_len___0 >= 4U) {
                  tmp___138 = 1;
                } else {
                  tmp___138 = 0;
                }
              }
            } else {
              tmp___138 = 0;
            }
          }
          if (tmp___138) {
            tmp___105 = __builtin_strcmp(pt, "*");
          } else {
            goto _L___38;
          }
        } else {
          goto _L___38;
        }
      } else {
        _L___38: 
        tmp___135 = __builtin_constant_p((int )pt);
        if (tmp___135) {
          if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
              1U) {
            __s1_len___0 = strlen((char const   *)pt);
            if (__s1_len___0 < 4U) {
              tmp___124 = __builtin_constant_p((int )"*");
              if (tmp___124) {
                if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                    1U) {
                  tmp___105 = __builtin_strcmp(pt, "*");
                } else {
                  goto _L___31;
                }
              } else {
                _L___31: 
                __s2___14 = (unsigned char const   *)"*";
                __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                        0)) - (int const   )(*(__s2___14 +
                                                                               0)));
                if (__s1_len___0 > 0U) {
                  if (__result___42 == 0) {
                    __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                            1)) - (int const   )(*(__s2___14 +
                                                                                   1)));
                    if (__s1_len___0 > 1U) {
                      if (__result___42 == 0) {
                        __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                2)) - (int const   )(*(__s2___14 +
                                                                                       2)));
                        if (__s1_len___0 > 2U) {
                          if (__result___42 == 0) {
                            __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                    3)) - (int const   )(*(__s2___14 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___105 = __result___42;
              }
            } else {
              goto _L___35;
            }
          } else {
            goto _L___35;
          }
        } else {
          _L___35: 
          tmp___134 = __builtin_constant_p((int )"*");
          if (tmp___134) {
            if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                1U) {
              __s2_len___0 = strlen("*");
              if (__s2_len___0 < 4U) {
                tmp___133 = __builtin_constant_p((int )pt);
                if (tmp___133) {
                  if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                      1U) {
                    tmp___105 = __builtin_strcmp(pt, "*");
                  } else {
                    goto _L___33;
                  }
                } else {
                  _L___33: 
                  __s1___30 = (unsigned char const   *)((char const   *)pt);
                  __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             0)));
                  if (__s2_len___0 > 0U) {
                    if (__result___46 == 0) {
                      __result___46 = (int )((int const   )(*(__s1___30 + 1)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                                 1)));
                      if (__s2_len___0 > 1U) {
                        if (__result___46 == 0) {
                          __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"*" +
                                                                  2)));
                          if (__s2_len___0 > 2U) {
                            if (__result___46 == 0) {
                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___105 = __result___46;
                }
              } else {
                tmp___105 = __builtin_strcmp(pt, "*");
              }
            } else {
              tmp___105 = __builtin_strcmp(pt, "*");
            }
          } else {
            tmp___105 = __builtin_strcmp(pt, "*");
          }
        }
      }
      if (tmp___105) {
        new->size = atoi__extinline((char const   *)pt);
      } else {
        new->size = -1;
      }
      free((void *)pt);
    } else {
      free((void *)new->filename);
      free((void *)new->virname);
      free((void *)new);
      ret = -5;
      break;
    }
    pt = cli_strtok((char const   *)(buffer), 4, ":");
    if (pt) {
      tmp___205 = __builtin_constant_p((int )pt);
      if (tmp___205) {
        tmp___206 = __builtin_constant_p((int )"*");
        if (tmp___206) {
          __s1_len___1 = strlen((char const   *)pt);
          __s2_len___1 = strlen("*");
          if (! ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                 1U)) {
            goto _L___56;
          } else {
            if (__s1_len___1 >= 4U) {
              _L___56: 
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                     1U)) {
                tmp___207 = 1;
              } else {
                if (__s2_len___1 >= 4U) {
                  tmp___207 = 1;
                } else {
                  tmp___207 = 0;
                }
              }
            } else {
              tmp___207 = 0;
            }
          }
          if (tmp___207) {
            tmp___174 = __builtin_strcmp(pt, "*");
          } else {
            goto _L___58;
          }
        } else {
          goto _L___58;
        }
      } else {
        _L___58: 
        tmp___204 = __builtin_constant_p((int )pt);
        if (tmp___204) {
          if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
              1U) {
            __s1_len___1 = strlen((char const   *)pt);
            if (__s1_len___1 < 4U) {
              tmp___193 = __builtin_constant_p((int )"*");
              if (tmp___193) {
                if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                    1U) {
                  tmp___174 = __builtin_strcmp(pt, "*");
                } else {
                  goto _L___51;
                }
              } else {
                _L___51: 
                __s2___22 = (unsigned char const   *)"*";
                __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                        0)) - (int const   )(*(__s2___22 +
                                                                               0)));
                if (__s1_len___1 > 0U) {
                  if (__result___66 == 0) {
                    __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                            1)) - (int const   )(*(__s2___22 +
                                                                                   1)));
                    if (__s1_len___1 > 1U) {
                      if (__result___66 == 0) {
                        __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                2)) - (int const   )(*(__s2___22 +
                                                                                       2)));
                        if (__s1_len___1 > 2U) {
                          if (__result___66 == 0) {
                            __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                    3)) - (int const   )(*(__s2___22 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___174 = __result___66;
              }
            } else {
              goto _L___55;
            }
          } else {
            goto _L___55;
          }
        } else {
          _L___55: 
          tmp___203 = __builtin_constant_p((int )"*");
          if (tmp___203) {
            if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                1U) {
              __s2_len___1 = strlen("*");
              if (__s2_len___1 < 4U) {
                tmp___202 = __builtin_constant_p((int )pt);
                if (tmp___202) {
                  if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                      1U) {
                    tmp___174 = __builtin_strcmp(pt, "*");
                  } else {
                    goto _L___53;
                  }
                } else {
                  _L___53: 
                  __s1___46 = (unsigned char const   *)((char const   *)pt);
                  __result___70 = (int )((int const   )(*(__s1___46 + 0)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             0)));
                  if (__s2_len___1 > 0U) {
                    if (__result___70 == 0) {
                      __result___70 = (int )((int const   )(*(__s1___46 + 1)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                                 1)));
                      if (__s2_len___1 > 1U) {
                        if (__result___70 == 0) {
                          __result___70 = (int )((int const   )(*(__s1___46 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"*" +
                                                                  2)));
                          if (__s2_len___1 > 2U) {
                            if (__result___70 == 0) {
                              __result___70 = (int )((int const   )(*(__s1___46 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___174 = __result___70;
                }
              } else {
                tmp___174 = __builtin_strcmp(pt, "*");
              }
            } else {
              tmp___174 = __builtin_strcmp(pt, "*");
            }
          } else {
            tmp___174 = __builtin_strcmp(pt, "*");
          }
        }
      }
      if (tmp___174) {
        new->csize = atoi__extinline((char const   *)pt);
      } else {
        new->csize = -1;
      }
      free((void *)pt);
    } else {
      free((void *)new->filename);
      free((void *)new->virname);
      free((void *)new);
      ret = -5;
      break;
    }
    pt = cli_strtok((char const   *)(buffer), 5, ":");
    if (pt) {
      tmp___274 = __builtin_constant_p((int )pt);
      if (tmp___274) {
        tmp___275 = __builtin_constant_p((int )"*");
        if (tmp___275) {
          __s1_len___2 = strlen((char const   *)pt);
          __s2_len___2 = strlen("*");
          if (! ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                 1U)) {
            goto _L___76;
          } else {
            if (__s1_len___2 >= 4U) {
              _L___76: 
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                     1U)) {
                tmp___276 = 1;
              } else {
                if (__s2_len___2 >= 4U) {
                  tmp___276 = 1;
                } else {
                  tmp___276 = 0;
                }
              }
            } else {
              tmp___276 = 0;
            }
          }
          if (tmp___276) {
            tmp___243 = __builtin_strcmp(pt, "*");
          } else {
            goto _L___78;
          }
        } else {
          goto _L___78;
        }
      } else {
        _L___78: 
        tmp___273 = __builtin_constant_p((int )pt);
        if (tmp___273) {
          if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
              1U) {
            __s1_len___2 = strlen((char const   *)pt);
            if (__s1_len___2 < 4U) {
              tmp___262 = __builtin_constant_p((int )"*");
              if (tmp___262) {
                if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                    1U) {
                  tmp___243 = __builtin_strcmp(pt, "*");
                } else {
                  goto _L___71;
                }
              } else {
                _L___71: 
                __s2___30 = (unsigned char const   *)"*";
                __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                        0)) - (int const   )(*(__s2___30 +
                                                                               0)));
                if (__s1_len___2 > 0U) {
                  if (__result___90 == 0) {
                    __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                            1)) - (int const   )(*(__s2___30 +
                                                                                   1)));
                    if (__s1_len___2 > 1U) {
                      if (__result___90 == 0) {
                        __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                2)) - (int const   )(*(__s2___30 +
                                                                                       2)));
                        if (__s1_len___2 > 2U) {
                          if (__result___90 == 0) {
                            __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                    3)) - (int const   )(*(__s2___30 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___243 = __result___90;
              }
            } else {
              goto _L___75;
            }
          } else {
            goto _L___75;
          }
        } else {
          _L___75: 
          tmp___272 = __builtin_constant_p((int )"*");
          if (tmp___272) {
            if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                1U) {
              __s2_len___2 = strlen("*");
              if (__s2_len___2 < 4U) {
                tmp___271 = __builtin_constant_p((int )pt);
                if (tmp___271) {
                  if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                      1U) {
                    tmp___243 = __builtin_strcmp(pt, "*");
                  } else {
                    goto _L___73;
                  }
                } else {
                  _L___73: 
                  __s1___62 = (unsigned char const   *)((char const   *)pt);
                  __result___94 = (int )((int const   )(*(__s1___62 + 0)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             0)));
                  if (__s2_len___2 > 0U) {
                    if (__result___94 == 0) {
                      __result___94 = (int )((int const   )(*(__s1___62 + 1)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                                 1)));
                      if (__s2_len___2 > 1U) {
                        if (__result___94 == 0) {
                          __result___94 = (int )((int const   )(*(__s1___62 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"*" +
                                                                  2)));
                          if (__s2_len___2 > 2U) {
                            if (__result___94 == 0) {
                              __result___94 = (int )((int const   )(*(__s1___62 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___243 = __result___94;
                }
              } else {
                tmp___243 = __builtin_strcmp(pt, "*");
              }
            } else {
              tmp___243 = __builtin_strcmp(pt, "*");
            }
          } else {
            tmp___243 = __builtin_strcmp(pt, "*");
          }
        }
      }
      if (tmp___243) {
        new->crc32 = (unsigned int )cli_hex2num((char const   *)pt);
        if (new->crc32 == 4294967295U) {
          ret = -5;
          break;
        }
      } else {
        new->crc32 = 0U;
      }
      free((void *)pt);
    } else {
      free((void *)new->filename);
      free((void *)new->virname);
      free((void *)new);
      ret = -5;
      break;
    }
    pt = cli_strtok((char const   *)(buffer), 6, ":");
    if (pt) {
      tmp___343 = __builtin_constant_p((int )pt);
      if (tmp___343) {
        tmp___344 = __builtin_constant_p((int )"*");
        if (tmp___344) {
          __s1_len___3 = strlen((char const   *)pt);
          __s2_len___3 = strlen("*");
          if (! ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                 1U)) {
            goto _L___96;
          } else {
            if (__s1_len___3 >= 4U) {
              _L___96: 
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                     1U)) {
                tmp___345 = 1;
              } else {
                if (__s2_len___3 >= 4U) {
                  tmp___345 = 1;
                } else {
                  tmp___345 = 0;
                }
              }
            } else {
              tmp___345 = 0;
            }
          }
          if (tmp___345) {
            tmp___312 = __builtin_strcmp(pt, "*");
          } else {
            goto _L___98;
          }
        } else {
          goto _L___98;
        }
      } else {
        _L___98: 
        tmp___342 = __builtin_constant_p((int )pt);
        if (tmp___342) {
          if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
              1U) {
            __s1_len___3 = strlen((char const   *)pt);
            if (__s1_len___3 < 4U) {
              tmp___331 = __builtin_constant_p((int )"*");
              if (tmp___331) {
                if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                    1U) {
                  tmp___312 = __builtin_strcmp(pt, "*");
                } else {
                  goto _L___91;
                }
              } else {
                _L___91: 
                __s2___38 = (unsigned char const   *)"*";
                __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                         0)) - (int const   )(*(__s2___38 +
                                                                                0)));
                if (__s1_len___3 > 0U) {
                  if (__result___114 == 0) {
                    __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                             1)) - (int const   )(*(__s2___38 +
                                                                                    1)));
                    if (__s1_len___3 > 1U) {
                      if (__result___114 == 0) {
                        __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                 2)) - (int const   )(*(__s2___38 +
                                                                                        2)));
                        if (__s1_len___3 > 2U) {
                          if (__result___114 == 0) {
                            __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                     3)) - (int const   )(*(__s2___38 +
                                                                                            3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___312 = __result___114;
              }
            } else {
              goto _L___95;
            }
          } else {
            goto _L___95;
          }
        } else {
          _L___95: 
          tmp___341 = __builtin_constant_p((int )"*");
          if (tmp___341) {
            if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                1U) {
              __s2_len___3 = strlen("*");
              if (__s2_len___3 < 4U) {
                tmp___340 = __builtin_constant_p((int )pt);
                if (tmp___340) {
                  if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                      1U) {
                    tmp___312 = __builtin_strcmp(pt, "*");
                  } else {
                    goto _L___93;
                  }
                } else {
                  _L___93: 
                  __s1___78 = (unsigned char const   *)((char const   *)pt);
                  __result___118 = (int )((int const   )(*(__s1___78 + 0)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                              0)));
                  if (__s2_len___3 > 0U) {
                    if (__result___118 == 0) {
                      __result___118 = (int )((int const   )(*(__s1___78 + 1)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                                  1)));
                      if (__s2_len___3 > 1U) {
                        if (__result___118 == 0) {
                          __result___118 = (int )((int const   )(*(__s1___78 + 2)) -
                                                  (int const   )(*((unsigned char const   *)"*" +
                                                                   2)));
                          if (__s2_len___3 > 2U) {
                            if (__result___118 == 0) {
                              __result___118 = (int )((int const   )(*(__s1___78 +
                                                                       3)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                              3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___312 = __result___118;
                }
              } else {
                tmp___312 = __builtin_strcmp(pt, "*");
              }
            } else {
              tmp___312 = __builtin_strcmp(pt, "*");
            }
          } else {
            tmp___312 = __builtin_strcmp(pt, "*");
          }
        }
      }
      if (tmp___312) {
        new->method = atoi__extinline((char const   *)pt);
      } else {
        new->method = -1;
      }
      free((void *)pt);
    } else {
      free((void *)new->filename);
      free((void *)new->virname);
      free((void *)new);
      ret = -5;
      break;
    }
    pt = cli_strtok((char const   *)(buffer), 7, ":");
    if (pt) {
      tmp___412 = __builtin_constant_p((int )pt);
      if (tmp___412) {
        tmp___413 = __builtin_constant_p((int )"*");
        if (tmp___413) {
          __s1_len___4 = strlen((char const   *)pt);
          __s2_len___4 = strlen("*");
          if (! ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                 1U)) {
            goto _L___116;
          } else {
            if (__s1_len___4 >= 4U) {
              _L___116: 
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                     1U)) {
                tmp___414 = 1;
              } else {
                if (__s2_len___4 >= 4U) {
                  tmp___414 = 1;
                } else {
                  tmp___414 = 0;
                }
              }
            } else {
              tmp___414 = 0;
            }
          }
          if (tmp___414) {
            tmp___381 = __builtin_strcmp(pt, "*");
          } else {
            goto _L___118;
          }
        } else {
          goto _L___118;
        }
      } else {
        _L___118: 
        tmp___411 = __builtin_constant_p((int )pt);
        if (tmp___411) {
          if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
              1U) {
            __s1_len___4 = strlen((char const   *)pt);
            if (__s1_len___4 < 4U) {
              tmp___400 = __builtin_constant_p((int )"*");
              if (tmp___400) {
                if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                    1U) {
                  tmp___381 = __builtin_strcmp(pt, "*");
                } else {
                  goto _L___111;
                }
              } else {
                _L___111: 
                __s2___46 = (unsigned char const   *)"*";
                __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                         0)) - (int const   )(*(__s2___46 +
                                                                                0)));
                if (__s1_len___4 > 0U) {
                  if (__result___138 == 0) {
                    __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                             1)) - (int const   )(*(__s2___46 +
                                                                                    1)));
                    if (__s1_len___4 > 1U) {
                      if (__result___138 == 0) {
                        __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                 2)) - (int const   )(*(__s2___46 +
                                                                                        2)));
                        if (__s1_len___4 > 2U) {
                          if (__result___138 == 0) {
                            __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                     3)) - (int const   )(*(__s2___46 +
                                                                                            3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___381 = __result___138;
              }
            } else {
              goto _L___115;
            }
          } else {
            goto _L___115;
          }
        } else {
          _L___115: 
          tmp___410 = __builtin_constant_p((int )"*");
          if (tmp___410) {
            if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                1U) {
              __s2_len___4 = strlen("*");
              if (__s2_len___4 < 4U) {
                tmp___409 = __builtin_constant_p((int )pt);
                if (tmp___409) {
                  if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                      1U) {
                    tmp___381 = __builtin_strcmp(pt, "*");
                  } else {
                    goto _L___113;
                  }
                } else {
                  _L___113: 
                  __s1___94 = (unsigned char const   *)((char const   *)pt);
                  __result___142 = (int )((int const   )(*(__s1___94 + 0)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                              0)));
                  if (__s2_len___4 > 0U) {
                    if (__result___142 == 0) {
                      __result___142 = (int )((int const   )(*(__s1___94 + 1)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                                  1)));
                      if (__s2_len___4 > 1U) {
                        if (__result___142 == 0) {
                          __result___142 = (int )((int const   )(*(__s1___94 + 2)) -
                                                  (int const   )(*((unsigned char const   *)"*" +
                                                                   2)));
                          if (__s2_len___4 > 2U) {
                            if (__result___142 == 0) {
                              __result___142 = (int )((int const   )(*(__s1___94 +
                                                                       3)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                              3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___381 = __result___142;
                }
              } else {
                tmp___381 = __builtin_strcmp(pt, "*");
              }
            } else {
              tmp___381 = __builtin_strcmp(pt, "*");
            }
          } else {
            tmp___381 = __builtin_strcmp(pt, "*");
          }
        }
      }
      if (tmp___381) {
        new->fileno = (unsigned int )atoi__extinline((char const   *)pt);
      } else {
        new->fileno = 0U;
      }
      free((void *)pt);
    } else {
      free((void *)new->filename);
      free((void *)new->virname);
      free((void *)new);
      ret = -5;
      break;
    }
    pt = cli_strtok((char const   *)(buffer), 8, ":");
    if (pt) {
      tmp___481 = __builtin_constant_p((int )pt);
      if (tmp___481) {
        tmp___482 = __builtin_constant_p((int )"*");
        if (tmp___482) {
          __s1_len___5 = strlen((char const   *)pt);
          __s2_len___5 = strlen("*");
          if (! ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                 1U)) {
            goto _L___136;
          } else {
            if (__s1_len___5 >= 4U) {
              _L___136: 
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                     1U)) {
                tmp___483 = 1;
              } else {
                if (__s2_len___5 >= 4U) {
                  tmp___483 = 1;
                } else {
                  tmp___483 = 0;
                }
              }
            } else {
              tmp___483 = 0;
            }
          }
          if (tmp___483) {
            tmp___450 = __builtin_strcmp(pt, "*");
          } else {
            goto _L___138;
          }
        } else {
          goto _L___138;
        }
      } else {
        _L___138: 
        tmp___480 = __builtin_constant_p((int )pt);
        if (tmp___480) {
          if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
              1U) {
            __s1_len___5 = strlen((char const   *)pt);
            if (__s1_len___5 < 4U) {
              tmp___469 = __builtin_constant_p((int )"*");
              if (tmp___469) {
                if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                    1U) {
                  tmp___450 = __builtin_strcmp(pt, "*");
                } else {
                  goto _L___131;
                }
              } else {
                _L___131: 
                __s2___54 = (unsigned char const   *)"*";
                __result___162 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                         0)) - (int const   )(*(__s2___54 +
                                                                                0)));
                if (__s1_len___5 > 0U) {
                  if (__result___162 == 0) {
                    __result___162 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                             1)) - (int const   )(*(__s2___54 +
                                                                                    1)));
                    if (__s1_len___5 > 1U) {
                      if (__result___162 == 0) {
                        __result___162 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                 2)) - (int const   )(*(__s2___54 +
                                                                                        2)));
                        if (__s1_len___5 > 2U) {
                          if (__result___162 == 0) {
                            __result___162 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                     3)) - (int const   )(*(__s2___54 +
                                                                                            3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___450 = __result___162;
              }
            } else {
              goto _L___135;
            }
          } else {
            goto _L___135;
          }
        } else {
          _L___135: 
          tmp___479 = __builtin_constant_p((int )"*");
          if (tmp___479) {
            if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                1U) {
              __s2_len___5 = strlen("*");
              if (__s2_len___5 < 4U) {
                tmp___478 = __builtin_constant_p((int )pt);
                if (tmp___478) {
                  if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                      1U) {
                    tmp___450 = __builtin_strcmp(pt, "*");
                  } else {
                    goto _L___133;
                  }
                } else {
                  _L___133: 
                  __s1___110 = (unsigned char const   *)((char const   *)pt);
                  __result___166 = (int )((int const   )(*(__s1___110 + 0)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                               0)));
                  if (__s2_len___5 > 0U) {
                    if (__result___166 == 0) {
                      __result___166 = (int )((int const   )(*(__s1___110 + 1)) -
                                              (int const   )(*((unsigned char const   *)"*" +
                                                               1)));
                      if (__s2_len___5 > 1U) {
                        if (__result___166 == 0) {
                          __result___166 = (int )((int const   )(*(__s1___110 + 2)) -
                                                  (int const   )(*((unsigned char const   *)"*" +
                                                                   2)));
                          if (__s2_len___5 > 2U) {
                            if (__result___166 == 0) {
                              __result___166 = (int )((int const   )(*(__s1___110 +
                                                                       3)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                              3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___450 = __result___166;
                }
              } else {
                tmp___450 = __builtin_strcmp(pt, "*");
              }
            } else {
              tmp___450 = __builtin_strcmp(pt, "*");
            }
          } else {
            tmp___450 = __builtin_strcmp(pt, "*");
          }
        }
      }
      if (tmp___450) {
        new->maxdepth = (unsigned int )atoi__extinline((char const   *)pt);
      } else {
        new->maxdepth = 0U;
      }
      free((void *)pt);
    } else {
      free((void *)new->filename);
      free((void *)new->virname);
      free((void *)new);
      ret = -5;
      break;
    }
    if (type == 1) {
      new->next = ((*root))->zip_mlist;
      ((*root))->zip_mlist = new;
    } else {
      new->next = ((*root))->rar_mlist;
      ((*root))->rar_mlist = new;
    }
  }
  if (! line) {
    cli_errmsg("Empty database file\n");
    cl_free((*root));
    return (-5);
  }
  if (ret) {
    cli_errmsg("Problem parsing database at line %d\n", line);
    cl_free((*root));
    return (ret);
  }
  if (signo) {
    (*signo) += (unsigned int )(line - comments);
  }
  return (0);
}
}
int cl_loaddb(char const   *filename , struct cl_node **root , unsigned int *signo ) 
{ FILE *fd ;
  int ret ;
  int warn ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___53 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  char const   *tmp___77 ;

  {
  fd = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"rb");
  if ((unsigned int )fd == (unsigned int )((void *)0)) {
    cli_errmsg("cl_loaddb(): Can\'t open file %s\n", filename);
    return (-4);
  }
  cli_dbgmsg("Loading %s\n", filename);
  tmp___74 = cli_strbcasestr(filename, ".db");
  if (tmp___74) {
    ret = cli_loaddb(fd, root, signo);
  } else {
    tmp___75 = cli_strbcasestr(filename, ".db2");
    if (tmp___75) {
      ret = cli_loaddb(fd, root, signo);
    } else {
      tmp___76 = cli_strbcasestr(filename, ".db3");
      if (tmp___76) {
        ret = cli_loaddb(fd, root, signo);
      } else {
        tmp___73 = cli_strbcasestr(filename, ".cvd");
        if (tmp___73) {
          warn = 0;
          tmp___65 = __builtin_constant_p((int )filename);
          if (tmp___65) {
            tmp___66 = __builtin_constant_p((int )"daily.cvd");
            if (tmp___66) {
              __s1_len = strlen(filename);
              __s2_len = strlen("daily.cvd");
              if (! ((unsigned int )((void const   *)(filename + 1)) - (unsigned int )((void const   *)filename) ==
                     1U)) {
                goto _L___16;
              } else {
                if (__s1_len >= 4U) {
                  _L___16: 
                  if (! ((unsigned int )((void const   *)("daily.cvd" + 1)) - (unsigned int )((void const   *)"daily.cvd") ==
                         1U)) {
                    tmp___67 = 1;
                  } else {
                    if (__s2_len >= 4U) {
                      tmp___67 = 1;
                    } else {
                      tmp___67 = 0;
                    }
                  }
                } else {
                  tmp___67 = 0;
                }
              }
              if (tmp___67) {
                tmp___34 = __builtin_strcmp(filename, "daily.cvd");
              } else {
                goto _L___18;
              }
            } else {
              goto _L___18;
            }
          } else {
            _L___18: 
            tmp___64 = __builtin_constant_p((int )filename);
            if (tmp___64) {
              if ((unsigned int )((void const   *)(filename + 1)) - (unsigned int )((void const   *)filename) ==
                  1U) {
                __s1_len = strlen(filename);
                if (__s1_len < 4U) {
                  tmp___53 = __builtin_constant_p((int )"daily.cvd");
                  if (tmp___53) {
                    if ((unsigned int )((void const   *)("daily.cvd" + 1)) - (unsigned int )((void const   *)"daily.cvd") ==
                        1U) {
                      tmp___34 = __builtin_strcmp(filename, "daily.cvd");
                    } else {
                      goto _L___11;
                    }
                  } else {
                    _L___11: 
                    __s2___6 = (unsigned char const   *)"daily.cvd";
                    __result___18 = (int )((int const   )(*((unsigned char const   *)filename +
                                                            0)) - (int const   )(*(__s2___6 +
                                                                                   0)));
                    if (__s1_len > 0U) {
                      if (__result___18 == 0) {
                        __result___18 = (int )((int const   )(*((unsigned char const   *)filename +
                                                                1)) - (int const   )(*(__s2___6 +
                                                                                       1)));
                        if (__s1_len > 1U) {
                          if (__result___18 == 0) {
                            __result___18 = (int )((int const   )(*((unsigned char const   *)filename +
                                                                    2)) - (int const   )(*(__s2___6 +
                                                                                           2)));
                            if (__s1_len > 2U) {
                              if (__result___18 == 0) {
                                __result___18 = (int )((int const   )(*((unsigned char const   *)filename +
                                                                        3)) - (int const   )(*(__s2___6 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___34 = __result___18;
                  }
                } else {
                  goto _L___15;
                }
              } else {
                goto _L___15;
              }
            } else {
              _L___15: 
              tmp___63 = __builtin_constant_p((int )"daily.cvd");
              if (tmp___63) {
                if ((unsigned int )((void const   *)("daily.cvd" + 1)) - (unsigned int )((void const   *)"daily.cvd") ==
                    1U) {
                  __s2_len = strlen("daily.cvd");
                  if (__s2_len < 4U) {
                    tmp___62 = __builtin_constant_p((int )filename);
                    if (tmp___62) {
                      if ((unsigned int )((void const   *)(filename + 1)) - (unsigned int )((void const   *)filename) ==
                          1U) {
                        tmp___34 = __builtin_strcmp(filename, "daily.cvd");
                      } else {
                        goto _L___13;
                      }
                    } else {
                      _L___13: 
                      __s1___14 = (unsigned char const   *)filename;
                      __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"daily.cvd" +
                                                                                                 0)));
                      if (__s2_len > 0U) {
                        if (__result___22 == 0) {
                          __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                                 (int const   )(*((unsigned char const   *)"daily.cvd" +
                                                                  1)));
                          if (__s2_len > 1U) {
                            if (__result___22 == 0) {
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      2)) - (int const   )(*((unsigned char const   *)"daily.cvd" +
                                                                                             2)));
                              if (__s2_len > 2U) {
                                if (__result___22 == 0) {
                                  __result___22 = (int )((int const   )(*(__s1___14 +
                                                                          3)) - (int const   )(*((unsigned char const   *)"daily.cvd" +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___34 = __result___22;
                    }
                  } else {
                    tmp___34 = __builtin_strcmp(filename, "daily.cvd");
                  }
                } else {
                  tmp___34 = __builtin_strcmp(filename, "daily.cvd");
                }
              } else {
                tmp___34 = __builtin_strcmp(filename, "daily.cvd");
              }
            }
          }
          if (! tmp___34) {
            warn = 1;
          }
          ret = cli_cvdload(fd, root, signo, (short )warn);
        } else {
          tmp___72 = cli_strbcasestr(filename, ".hdb");
          if (tmp___72) {
            ret = cli_loadhdb(fd, root, signo, (unsigned short)0);
          } else {
            tmp___71 = cli_strbcasestr(filename, ".fp");
            if (tmp___71) {
              ret = cli_loadhdb(fd, root, signo, (unsigned short)1);
            } else {
              tmp___70 = cli_strbcasestr(filename, ".ndb");
              if (tmp___70) {
                ret = cli_loadndb(fd, root, signo);
              } else {
                tmp___69 = cli_strbcasestr(filename, ".zmd");
                if (tmp___69) {
                  ret = cli_loadmd(fd, root, signo, 1);
                } else {
                  tmp___68 = cli_strbcasestr(filename, ".rmd");
                  if (tmp___68) {
                    ret = cli_loadmd(fd, root, signo, 2);
                  } else {
                    cli_dbgmsg("cl_loaddb: unknown extension - assuming old database format\n");
                    ret = cli_loaddb(fd, root, signo);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (ret) {
    tmp___77 = cl_strerror(ret);
    cli_errmsg("Can\'t load %s: %s\n", filename, tmp___77);
  }
  fclose(fd);
  return (ret);
}
}
int cl_loaddbdir(char const   *dirname , struct cl_node **root , unsigned int *signo ) 
{ DIR *dd ;
  struct dirent *dent ;
  char *dbfile ;
  int ret ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___37 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___56 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___106 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___125 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___134 ;
  int tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;

  {
  dd = opendir(dirname);
  if ((unsigned int )dd == (unsigned int )((void *)0)) {
    cli_errmsg("cl_loaddbdir(): Can\'t open directory %s\n", dirname);
    return (-4);
  }
  cli_dbgmsg("Loading databases from %s\n", dirname);
  while (1) {
    dent = readdir(dd);
    if (! dent) {
      break;
    }
    if (dent->d_ino) {
      tmp___68 = __builtin_constant_p((int )(dent->d_name));
      if (tmp___68) {
        tmp___69 = __builtin_constant_p((int )".");
        if (tmp___69) {
          __s1_len = strlen((char const   *)(dent->d_name));
          __s2_len = strlen(".");
          if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                 1U)) {
            goto _L___16;
          } else {
            if (__s1_len >= 4U) {
              _L___16: 
              if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                     1U)) {
                tmp___70 = 1;
              } else {
                if (__s2_len >= 4U) {
                  tmp___70 = 1;
                } else {
                  tmp___70 = 0;
                }
              }
            } else {
              tmp___70 = 0;
            }
          }
          if (tmp___70) {
            tmp___37 = __builtin_strcmp(dent->d_name, ".");
          } else {
            goto _L___18;
          }
        } else {
          goto _L___18;
        }
      } else {
        _L___18: 
        tmp___67 = __builtin_constant_p((int )(dent->d_name));
        if (tmp___67) {
          if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
              1U) {
            __s1_len = strlen((char const   *)(dent->d_name));
            if (__s1_len < 4U) {
              tmp___56 = __builtin_constant_p((int )".");
              if (tmp___56) {
                if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                    1U) {
                  tmp___37 = __builtin_strcmp(dent->d_name, ".");
                } else {
                  goto _L___11;
                }
              } else {
                _L___11: 
                __s2___6 = (unsigned char const   *)".";
                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                        0)) - (int const   )(*(__s2___6 +
                                                                               0)));
                if (__s1_len > 0U) {
                  if (__result___18 == 0) {
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                            1)) - (int const   )(*(__s2___6 +
                                                                                   1)));
                    if (__s1_len > 1U) {
                      if (__result___18 == 0) {
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                2)) - (int const   )(*(__s2___6 +
                                                                                       2)));
                        if (__s1_len > 2U) {
                          if (__result___18 == 0) {
                            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                    3)) - (int const   )(*(__s2___6 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___37 = __result___18;
              }
            } else {
              goto _L___15;
            }
          } else {
            goto _L___15;
          }
        } else {
          _L___15: 
          tmp___66 = __builtin_constant_p((int )".");
          if (tmp___66) {
            if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                1U) {
              __s2_len = strlen(".");
              if (__s2_len < 4U) {
                tmp___65 = __builtin_constant_p((int )(dent->d_name));
                if (tmp___65) {
                  if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                      1U) {
                    tmp___37 = __builtin_strcmp(dent->d_name, ".");
                  } else {
                    goto _L___13;
                  }
                } else {
                  _L___13: 
                  __s1___14 = (unsigned char const   *)((char const   *)(dent->d_name));
                  __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"." +
                                                                                             0)));
                  if (__s2_len > 0U) {
                    if (__result___22 == 0) {
                      __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)"." +
                                                                                                 1)));
                      if (__s2_len > 1U) {
                        if (__result___22 == 0) {
                          __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"." +
                                                                  2)));
                          if (__s2_len > 2U) {
                            if (__result___22 == 0) {
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"." +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___37 = __result___22;
                }
              } else {
                tmp___37 = __builtin_strcmp(dent->d_name, ".");
              }
            } else {
              tmp___37 = __builtin_strcmp(dent->d_name, ".");
            }
          } else {
            tmp___37 = __builtin_strcmp(dent->d_name, ".");
          }
        }
      }
      if (tmp___37) {
        tmp___137 = __builtin_constant_p((int )(dent->d_name));
        if (tmp___137) {
          tmp___138 = __builtin_constant_p((int )"..");
          if (tmp___138) {
            __s1_len___0 = strlen((char const   *)(dent->d_name));
            __s2_len___0 = strlen("..");
            if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                   1U)) {
              goto _L___36;
            } else {
              if (__s1_len___0 >= 4U) {
                _L___36: 
                if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                       1U)) {
                  tmp___139 = 1;
                } else {
                  if (__s2_len___0 >= 4U) {
                    tmp___139 = 1;
                  } else {
                    tmp___139 = 0;
                  }
                }
              } else {
                tmp___139 = 0;
              }
            }
            if (tmp___139) {
              tmp___106 = __builtin_strcmp(dent->d_name, "..");
            } else {
              goto _L___38;
            }
          } else {
            goto _L___38;
          }
        } else {
          _L___38: 
          tmp___136 = __builtin_constant_p((int )(dent->d_name));
          if (tmp___136) {
            if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                1U) {
              __s1_len___0 = strlen((char const   *)(dent->d_name));
              if (__s1_len___0 < 4U) {
                tmp___125 = __builtin_constant_p((int )"..");
                if (tmp___125) {
                  if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                      1U) {
                    tmp___106 = __builtin_strcmp(dent->d_name, "..");
                  } else {
                    goto _L___31;
                  }
                } else {
                  _L___31: 
                  __s2___14 = (unsigned char const   *)"..";
                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                          0)) - (int const   )(*(__s2___14 +
                                                                                 0)));
                  if (__s1_len___0 > 0U) {
                    if (__result___42 == 0) {
                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                              1)) - (int const   )(*(__s2___14 +
                                                                                     1)));
                      if (__s1_len___0 > 1U) {
                        if (__result___42 == 0) {
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                  2)) - (int const   )(*(__s2___14 +
                                                                                         2)));
                          if (__s1_len___0 > 2U) {
                            if (__result___42 == 0) {
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                      3)) - (int const   )(*(__s2___14 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___106 = __result___42;
                }
              } else {
                goto _L___35;
              }
            } else {
              goto _L___35;
            }
          } else {
            _L___35: 
            tmp___135 = __builtin_constant_p((int )"..");
            if (tmp___135) {
              if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                  1U) {
                __s2_len___0 = strlen("..");
                if (__s2_len___0 < 4U) {
                  tmp___134 = __builtin_constant_p((int )(dent->d_name));
                  if (tmp___134) {
                    if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                        1U) {
                      tmp___106 = __builtin_strcmp(dent->d_name, "..");
                    } else {
                      goto _L___33;
                    }
                  } else {
                    _L___33: 
                    __s1___30 = (unsigned char const   *)((char const   *)(dent->d_name));
                    __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)".." +
                                                                                               0)));
                    if (__s2_len___0 > 0U) {
                      if (__result___46 == 0) {
                        __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                               (int const   )(*((unsigned char const   *)".." +
                                                                1)));
                        if (__s2_len___0 > 1U) {
                          if (__result___46 == 0) {
                            __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                   (int const   )(*((unsigned char const   *)".." +
                                                                    2)));
                            if (__s2_len___0 > 2U) {
                              if (__result___46 == 0) {
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        3)) - (int const   )(*((unsigned char const   *)".." +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___106 = __result___46;
                  }
                } else {
                  tmp___106 = __builtin_strcmp(dent->d_name, "..");
                }
              } else {
                tmp___106 = __builtin_strcmp(dent->d_name, "..");
              }
            } else {
              tmp___106 = __builtin_strcmp(dent->d_name, "..");
            }
          }
        }
        if (tmp___106) {
          tmp___140 = cli_strbcasestr((char const   *)(dent->d_name), ".db");
          if (tmp___140) {
            goto _L___39;
          } else {
            tmp___141 = cli_strbcasestr((char const   *)(dent->d_name), ".db2");
            if (tmp___141) {
              goto _L___39;
            } else {
              tmp___142 = cli_strbcasestr((char const   *)(dent->d_name), ".db3");
              if (tmp___142) {
                goto _L___39;
              } else {
                tmp___143 = cli_strbcasestr((char const   *)(dent->d_name), ".hdb");
                if (tmp___143) {
                  goto _L___39;
                } else {
                  tmp___144 = cli_strbcasestr((char const   *)(dent->d_name), ".fp");
                  if (tmp___144) {
                    goto _L___39;
                  } else {
                    tmp___145 = cli_strbcasestr((char const   *)(dent->d_name), ".ndb");
                    if (tmp___145) {
                      goto _L___39;
                    } else {
                      tmp___146 = cli_strbcasestr((char const   *)(dent->d_name),
                                                  ".zmd");
                      if (tmp___146) {
                        goto _L___39;
                      } else {
                        tmp___147 = cli_strbcasestr((char const   *)(dent->d_name),
                                                    ".rmd");
                        if (tmp___147) {
                          goto _L___39;
                        } else {
                          tmp___148 = cli_strbcasestr((char const   *)(dent->d_name),
                                                      ".cvd");
                          if (tmp___148) {
                            _L___39: 
                            tmp = strlen((char const   *)(dent->d_name));
                            tmp___0 = strlen(dirname);
                            dbfile = (char *)cli_calloc((tmp + tmp___0) + 2U, sizeof(char ));
                            if (! dbfile) {
                              cli_dbgmsg("cl_loaddbdir(): dbfile == NULL\n");
                              closedir(dd);
                              return (-3);
                            }
                            sprintf((char * __restrict  )dbfile, (char const   * __restrict  )"%s/%s",
                                    dirname, dent->d_name);
                            ret = cl_loaddb((char const   *)dbfile, root, signo);
                            if (ret) {
                              cli_dbgmsg("cl_loaddbdir(): error loading database %s\n",
                                         dbfile);
                              free((void *)dbfile);
                              closedir(dd);
                              return (ret);
                            }
                            free((void *)dbfile);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  closedir(dd);
  return (0);
}
}
char const   *cl_retdbdir(void) 
{ 

  {
  return ("/usr/local/share/clamav");
}
}
int cl_statinidir(char const   *dirname , struct cl_stat *dbstat ) 
{ DIR *dd ;
  struct dirent  const  *dent ;
  char *fname ;
  size_t __len___2 ;
  size_t tmp___15 ;
  char *__retval___2 ;
  char *tmp___16 ;
  int tmp___18 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___57 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___76 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___126 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___145 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___154 ;
  int tmp___155 ;
  int tmp___156 ;
  int tmp___157 ;
  int tmp___158 ;
  int tmp___159 ;
  int tmp___160 ;
  int tmp___161 ;
  int tmp___162 ;
  int tmp___163 ;
  int tmp___164 ;
  int tmp___165 ;
  int tmp___166 ;
  int tmp___167 ;
  int tmp___168 ;

  {
  if (dbstat) {
    dbstat->no = 0;
    dbstat->stattab = (struct stat *)((void *)0);
    dbstat->statdname = (char **)((void *)0);
    tmp___18 = __builtin_constant_p((int )dirname);
    if (tmp___18) {
      if ((unsigned int )((void const   *)(dirname + 1)) - (unsigned int )((void const   *)dirname) ==
          1U) {
        if ((int const   )(*(dirname + 0)) == 0) {
          dbstat->dir = (char *)calloc(1U, 1U);
        } else {
          tmp___15 = strlen(dirname);
          __len___2 = tmp___15 + 1U;
          tmp___16 = (char *)malloc(__len___2);
          __retval___2 = tmp___16;
          if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
            __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )dirname,
                                          __len___2);
          }
          dbstat->dir = __retval___2;
        }
      } else {
        dbstat->dir = __strdup(dirname);
      }
    } else {
      dbstat->dir = __strdup(dirname);
    }
  } else {
    cli_errmsg("cl_statdbdir(): Null argument passed.\n");
    return (300);
  }
  dd = opendir(dirname);
  if ((unsigned int )dd == (unsigned int )((void *)0)) {
    cli_errmsg("cl_statdbdir(): Can\'t open directory %s\n", dirname);
    return (-4);
  }
  cli_dbgmsg("Stat()ing files in %s\n", dirname);
  while (1) {
    dent = readdir(dd);
    if (! dent) {
      break;
    }
    if (dent->d_ino) {
      tmp___88 = __builtin_constant_p((int )(dent->d_name));
      if (tmp___88) {
        tmp___89 = __builtin_constant_p((int )".");
        if (tmp___89) {
          __s1_len = strlen((char const   *)(dent->d_name));
          __s2_len = strlen(".");
          if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                 1U)) {
            goto _L___16;
          } else {
            if (__s1_len >= 4U) {
              _L___16: 
              if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                     1U)) {
                tmp___90 = 1;
              } else {
                if (__s2_len >= 4U) {
                  tmp___90 = 1;
                } else {
                  tmp___90 = 0;
                }
              }
            } else {
              tmp___90 = 0;
            }
          }
          if (tmp___90) {
            tmp___57 = __builtin_strcmp(dent->d_name, ".");
          } else {
            goto _L___18;
          }
        } else {
          goto _L___18;
        }
      } else {
        _L___18: 
        tmp___87 = __builtin_constant_p((int )(dent->d_name));
        if (tmp___87) {
          if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
              1U) {
            __s1_len = strlen((char const   *)(dent->d_name));
            if (__s1_len < 4U) {
              tmp___76 = __builtin_constant_p((int )".");
              if (tmp___76) {
                if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                    1U) {
                  tmp___57 = __builtin_strcmp(dent->d_name, ".");
                } else {
                  goto _L___11;
                }
              } else {
                _L___11: 
                __s2___6 = (unsigned char const   *)".";
                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                        0)) - (int const   )(*(__s2___6 +
                                                                               0)));
                if (__s1_len > 0U) {
                  if (__result___18 == 0) {
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                            1)) - (int const   )(*(__s2___6 +
                                                                                   1)));
                    if (__s1_len > 1U) {
                      if (__result___18 == 0) {
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                2)) - (int const   )(*(__s2___6 +
                                                                                       2)));
                        if (__s1_len > 2U) {
                          if (__result___18 == 0) {
                            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                    3)) - (int const   )(*(__s2___6 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___57 = __result___18;
              }
            } else {
              goto _L___15;
            }
          } else {
            goto _L___15;
          }
        } else {
          _L___15: 
          tmp___86 = __builtin_constant_p((int )".");
          if (tmp___86) {
            if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                1U) {
              __s2_len = strlen(".");
              if (__s2_len < 4U) {
                tmp___85 = __builtin_constant_p((int )(dent->d_name));
                if (tmp___85) {
                  if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                      1U) {
                    tmp___57 = __builtin_strcmp(dent->d_name, ".");
                  } else {
                    goto _L___13;
                  }
                } else {
                  _L___13: 
                  __s1___14 = (unsigned char const   *)((char const   *)(dent->d_name));
                  __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"." +
                                                                                             0)));
                  if (__s2_len > 0U) {
                    if (__result___22 == 0) {
                      __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)"." +
                                                                                                 1)));
                      if (__s2_len > 1U) {
                        if (__result___22 == 0) {
                          __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"." +
                                                                  2)));
                          if (__s2_len > 2U) {
                            if (__result___22 == 0) {
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"." +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___57 = __result___22;
                }
              } else {
                tmp___57 = __builtin_strcmp(dent->d_name, ".");
              }
            } else {
              tmp___57 = __builtin_strcmp(dent->d_name, ".");
            }
          } else {
            tmp___57 = __builtin_strcmp(dent->d_name, ".");
          }
        }
      }
      if (tmp___57) {
        tmp___157 = __builtin_constant_p((int )(dent->d_name));
        if (tmp___157) {
          tmp___158 = __builtin_constant_p((int )"..");
          if (tmp___158) {
            __s1_len___0 = strlen((char const   *)(dent->d_name));
            __s2_len___0 = strlen("..");
            if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                   1U)) {
              goto _L___36;
            } else {
              if (__s1_len___0 >= 4U) {
                _L___36: 
                if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                       1U)) {
                  tmp___159 = 1;
                } else {
                  if (__s2_len___0 >= 4U) {
                    tmp___159 = 1;
                  } else {
                    tmp___159 = 0;
                  }
                }
              } else {
                tmp___159 = 0;
              }
            }
            if (tmp___159) {
              tmp___126 = __builtin_strcmp(dent->d_name, "..");
            } else {
              goto _L___38;
            }
          } else {
            goto _L___38;
          }
        } else {
          _L___38: 
          tmp___156 = __builtin_constant_p((int )(dent->d_name));
          if (tmp___156) {
            if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                1U) {
              __s1_len___0 = strlen((char const   *)(dent->d_name));
              if (__s1_len___0 < 4U) {
                tmp___145 = __builtin_constant_p((int )"..");
                if (tmp___145) {
                  if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                      1U) {
                    tmp___126 = __builtin_strcmp(dent->d_name, "..");
                  } else {
                    goto _L___31;
                  }
                } else {
                  _L___31: 
                  __s2___14 = (unsigned char const   *)"..";
                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                          0)) - (int const   )(*(__s2___14 +
                                                                                 0)));
                  if (__s1_len___0 > 0U) {
                    if (__result___42 == 0) {
                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                              1)) - (int const   )(*(__s2___14 +
                                                                                     1)));
                      if (__s1_len___0 > 1U) {
                        if (__result___42 == 0) {
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                  2)) - (int const   )(*(__s2___14 +
                                                                                         2)));
                          if (__s1_len___0 > 2U) {
                            if (__result___42 == 0) {
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                      3)) - (int const   )(*(__s2___14 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___126 = __result___42;
                }
              } else {
                goto _L___35;
              }
            } else {
              goto _L___35;
            }
          } else {
            _L___35: 
            tmp___155 = __builtin_constant_p((int )"..");
            if (tmp___155) {
              if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                  1U) {
                __s2_len___0 = strlen("..");
                if (__s2_len___0 < 4U) {
                  tmp___154 = __builtin_constant_p((int )(dent->d_name));
                  if (tmp___154) {
                    if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                        1U) {
                      tmp___126 = __builtin_strcmp(dent->d_name, "..");
                    } else {
                      goto _L___33;
                    }
                  } else {
                    _L___33: 
                    __s1___30 = (unsigned char const   *)((char const   *)(dent->d_name));
                    __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)".." +
                                                                                               0)));
                    if (__s2_len___0 > 0U) {
                      if (__result___46 == 0) {
                        __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                               (int const   )(*((unsigned char const   *)".." +
                                                                1)));
                        if (__s2_len___0 > 1U) {
                          if (__result___46 == 0) {
                            __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                   (int const   )(*((unsigned char const   *)".." +
                                                                    2)));
                            if (__s2_len___0 > 2U) {
                              if (__result___46 == 0) {
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        3)) - (int const   )(*((unsigned char const   *)".." +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___126 = __result___46;
                  }
                } else {
                  tmp___126 = __builtin_strcmp(dent->d_name, "..");
                }
              } else {
                tmp___126 = __builtin_strcmp(dent->d_name, "..");
              }
            } else {
              tmp___126 = __builtin_strcmp(dent->d_name, "..");
            }
          }
        }
        if (tmp___126) {
          tmp___160 = cli_strbcasestr((char const   *)(dent->d_name), ".db");
          if (tmp___160) {
            goto _L___39;
          } else {
            tmp___161 = cli_strbcasestr((char const   *)(dent->d_name), ".db2");
            if (tmp___161) {
              goto _L___39;
            } else {
              tmp___162 = cli_strbcasestr((char const   *)(dent->d_name), ".db3");
              if (tmp___162) {
                goto _L___39;
              } else {
                tmp___163 = cli_strbcasestr((char const   *)(dent->d_name), ".hdb");
                if (tmp___163) {
                  goto _L___39;
                } else {
                  tmp___164 = cli_strbcasestr((char const   *)(dent->d_name), ".fp");
                  if (tmp___164) {
                    goto _L___39;
                  } else {
                    tmp___165 = cli_strbcasestr((char const   *)(dent->d_name), ".ndb");
                    if (tmp___165) {
                      goto _L___39;
                    } else {
                      tmp___166 = cli_strbcasestr((char const   *)(dent->d_name),
                                                  ".zmd");
                      if (tmp___166) {
                        goto _L___39;
                      } else {
                        tmp___167 = cli_strbcasestr((char const   *)(dent->d_name),
                                                    ".rmd");
                        if (tmp___167) {
                          goto _L___39;
                        } else {
                          tmp___168 = cli_strbcasestr((char const   *)(dent->d_name),
                                                      ".cvd");
                          if (tmp___168) {
                            _L___39: 
                            dbstat->no ++;
                            dbstat->stattab = (struct stat *)realloc((void *)dbstat->stattab,
                                                                     (unsigned int )dbstat->no *
                                                                     sizeof(struct stat ));
                            tmp___20 = strlen(dirname);
                            tmp___21 = strlen((char const   *)(dent->d_name));
                            fname = (char *)cli_calloc((tmp___20 + tmp___21) + 2U,
                                                       sizeof(char ));
                            sprintf((char * __restrict  )fname, (char const   * __restrict  )"%s/%s",
                                    dirname, dent->d_name);
                            stat__extinline((char const   *)fname, dbstat->stattab +
                                                                   (dbstat->no - 1));
                            free((void *)fname);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  closedir(dd);
  return (0);
}
}
int cl_statchkdir(struct cl_stat  const  *dbstat ) 
{ DIR *dd ;
  struct dirent *dent ;
  struct stat sb ;
  int i ;
  int found ;
  char *fname ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___36 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___55 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___105 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___124 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___133 ;
  int tmp___134 ;
  int tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;

  {
  if (! dbstat) {
    cli_errmsg("cl_statdbdir(): Null argument passed.\n");
    return (300);
  } else {
    if (! dbstat->dir) {
      cli_errmsg("cl_statdbdir(): Null argument passed.\n");
      return (300);
    }
  }
  dd = opendir((char const   *)dbstat->dir);
  if ((unsigned int )dd == (unsigned int )((void *)0)) {
    cli_errmsg("cl_statdbdir(): Can\'t open directory %s\n", dbstat->dir);
    return (-4);
  }
  cli_dbgmsg("Stat()ing files in %s\n", dbstat->dir);
  while (1) {
    dent = readdir(dd);
    if (! dent) {
      break;
    }
    if (dent->d_ino) {
      tmp___67 = __builtin_constant_p((int )(dent->d_name));
      if (tmp___67) {
        tmp___68 = __builtin_constant_p((int )".");
        if (tmp___68) {
          __s1_len = strlen((char const   *)(dent->d_name));
          __s2_len = strlen(".");
          if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                 1U)) {
            goto _L___16;
          } else {
            if (__s1_len >= 4U) {
              _L___16: 
              if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                     1U)) {
                tmp___69 = 1;
              } else {
                if (__s2_len >= 4U) {
                  tmp___69 = 1;
                } else {
                  tmp___69 = 0;
                }
              }
            } else {
              tmp___69 = 0;
            }
          }
          if (tmp___69) {
            tmp___36 = __builtin_strcmp(dent->d_name, ".");
          } else {
            goto _L___18;
          }
        } else {
          goto _L___18;
        }
      } else {
        _L___18: 
        tmp___66 = __builtin_constant_p((int )(dent->d_name));
        if (tmp___66) {
          if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
              1U) {
            __s1_len = strlen((char const   *)(dent->d_name));
            if (__s1_len < 4U) {
              tmp___55 = __builtin_constant_p((int )".");
              if (tmp___55) {
                if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                    1U) {
                  tmp___36 = __builtin_strcmp(dent->d_name, ".");
                } else {
                  goto _L___11;
                }
              } else {
                _L___11: 
                __s2___6 = (unsigned char const   *)".";
                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                        0)) - (int const   )(*(__s2___6 +
                                                                               0)));
                if (__s1_len > 0U) {
                  if (__result___18 == 0) {
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                            1)) - (int const   )(*(__s2___6 +
                                                                                   1)));
                    if (__s1_len > 1U) {
                      if (__result___18 == 0) {
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                2)) - (int const   )(*(__s2___6 +
                                                                                       2)));
                        if (__s1_len > 2U) {
                          if (__result___18 == 0) {
                            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                    3)) - (int const   )(*(__s2___6 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___36 = __result___18;
              }
            } else {
              goto _L___15;
            }
          } else {
            goto _L___15;
          }
        } else {
          _L___15: 
          tmp___65 = __builtin_constant_p((int )".");
          if (tmp___65) {
            if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                1U) {
              __s2_len = strlen(".");
              if (__s2_len < 4U) {
                tmp___64 = __builtin_constant_p((int )(dent->d_name));
                if (tmp___64) {
                  if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                      1U) {
                    tmp___36 = __builtin_strcmp(dent->d_name, ".");
                  } else {
                    goto _L___13;
                  }
                } else {
                  _L___13: 
                  __s1___14 = (unsigned char const   *)((char const   *)(dent->d_name));
                  __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"." +
                                                                                             0)));
                  if (__s2_len > 0U) {
                    if (__result___22 == 0) {
                      __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)"." +
                                                                                                 1)));
                      if (__s2_len > 1U) {
                        if (__result___22 == 0) {
                          __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"." +
                                                                  2)));
                          if (__s2_len > 2U) {
                            if (__result___22 == 0) {
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"." +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___36 = __result___22;
                }
              } else {
                tmp___36 = __builtin_strcmp(dent->d_name, ".");
              }
            } else {
              tmp___36 = __builtin_strcmp(dent->d_name, ".");
            }
          } else {
            tmp___36 = __builtin_strcmp(dent->d_name, ".");
          }
        }
      }
      if (tmp___36) {
        tmp___136 = __builtin_constant_p((int )(dent->d_name));
        if (tmp___136) {
          tmp___137 = __builtin_constant_p((int )"..");
          if (tmp___137) {
            __s1_len___0 = strlen((char const   *)(dent->d_name));
            __s2_len___0 = strlen("..");
            if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                   1U)) {
              goto _L___36;
            } else {
              if (__s1_len___0 >= 4U) {
                _L___36: 
                if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                       1U)) {
                  tmp___138 = 1;
                } else {
                  if (__s2_len___0 >= 4U) {
                    tmp___138 = 1;
                  } else {
                    tmp___138 = 0;
                  }
                }
              } else {
                tmp___138 = 0;
              }
            }
            if (tmp___138) {
              tmp___105 = __builtin_strcmp(dent->d_name, "..");
            } else {
              goto _L___38;
            }
          } else {
            goto _L___38;
          }
        } else {
          _L___38: 
          tmp___135 = __builtin_constant_p((int )(dent->d_name));
          if (tmp___135) {
            if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                1U) {
              __s1_len___0 = strlen((char const   *)(dent->d_name));
              if (__s1_len___0 < 4U) {
                tmp___124 = __builtin_constant_p((int )"..");
                if (tmp___124) {
                  if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                      1U) {
                    tmp___105 = __builtin_strcmp(dent->d_name, "..");
                  } else {
                    goto _L___31;
                  }
                } else {
                  _L___31: 
                  __s2___14 = (unsigned char const   *)"..";
                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                          0)) - (int const   )(*(__s2___14 +
                                                                                 0)));
                  if (__s1_len___0 > 0U) {
                    if (__result___42 == 0) {
                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                              1)) - (int const   )(*(__s2___14 +
                                                                                     1)));
                      if (__s1_len___0 > 1U) {
                        if (__result___42 == 0) {
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                  2)) - (int const   )(*(__s2___14 +
                                                                                         2)));
                          if (__s1_len___0 > 2U) {
                            if (__result___42 == 0) {
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                      3)) - (int const   )(*(__s2___14 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___105 = __result___42;
                }
              } else {
                goto _L___35;
              }
            } else {
              goto _L___35;
            }
          } else {
            _L___35: 
            tmp___134 = __builtin_constant_p((int )"..");
            if (tmp___134) {
              if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                  1U) {
                __s2_len___0 = strlen("..");
                if (__s2_len___0 < 4U) {
                  tmp___133 = __builtin_constant_p((int )(dent->d_name));
                  if (tmp___133) {
                    if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                        1U) {
                      tmp___105 = __builtin_strcmp(dent->d_name, "..");
                    } else {
                      goto _L___33;
                    }
                  } else {
                    _L___33: 
                    __s1___30 = (unsigned char const   *)((char const   *)(dent->d_name));
                    __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)".." +
                                                                                               0)));
                    if (__s2_len___0 > 0U) {
                      if (__result___46 == 0) {
                        __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                               (int const   )(*((unsigned char const   *)".." +
                                                                1)));
                        if (__s2_len___0 > 1U) {
                          if (__result___46 == 0) {
                            __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                   (int const   )(*((unsigned char const   *)".." +
                                                                    2)));
                            if (__s2_len___0 > 2U) {
                              if (__result___46 == 0) {
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        3)) - (int const   )(*((unsigned char const   *)".." +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___105 = __result___46;
                  }
                } else {
                  tmp___105 = __builtin_strcmp(dent->d_name, "..");
                }
              } else {
                tmp___105 = __builtin_strcmp(dent->d_name, "..");
              }
            } else {
              tmp___105 = __builtin_strcmp(dent->d_name, "..");
            }
          }
        }
        if (tmp___105) {
          tmp___139 = cli_strbcasestr((char const   *)(dent->d_name), ".db");
          if (tmp___139) {
            goto _L___39;
          } else {
            tmp___140 = cli_strbcasestr((char const   *)(dent->d_name), ".db2");
            if (tmp___140) {
              goto _L___39;
            } else {
              tmp___141 = cli_strbcasestr((char const   *)(dent->d_name), ".db3");
              if (tmp___141) {
                goto _L___39;
              } else {
                tmp___142 = cli_strbcasestr((char const   *)(dent->d_name), ".hdb");
                if (tmp___142) {
                  goto _L___39;
                } else {
                  tmp___143 = cli_strbcasestr((char const   *)(dent->d_name), ".fp");
                  if (tmp___143) {
                    goto _L___39;
                  } else {
                    tmp___144 = cli_strbcasestr((char const   *)(dent->d_name), ".ndb");
                    if (tmp___144) {
                      goto _L___39;
                    } else {
                      tmp___145 = cli_strbcasestr((char const   *)(dent->d_name),
                                                  ".zmd");
                      if (tmp___145) {
                        goto _L___39;
                      } else {
                        tmp___146 = cli_strbcasestr((char const   *)(dent->d_name),
                                                    ".rmd");
                        if (tmp___146) {
                          goto _L___39;
                        } else {
                          tmp___147 = cli_strbcasestr((char const   *)(dent->d_name),
                                                      ".cvd");
                          if (tmp___147) {
                            _L___39: 
                            tmp = strlen((char const   *)dbstat->dir);
                            tmp___0 = strlen((char const   *)(dent->d_name));
                            fname = (char *)cli_calloc((tmp + tmp___0) + 2U, sizeof(char ));
                            sprintf((char * __restrict  )fname, (char const   * __restrict  )"%s/%s",
                                    dbstat->dir, dent->d_name);
                            stat__extinline((char const   *)fname, & sb);
                            free((void *)fname);
                            found = 0;
                            i = 0;
                            while (i < dbstat->no) {
                              if ((dbstat->stattab + i)->st_ino == sb.st_ino) {
                                found = 1;
                                if ((dbstat->stattab + i)->st_mtim.tv_sec != sb.st_mtim.tv_sec) {
                                  closedir(dd);
                                  return (1);
                                }
                              }
                              i ++;
                            }
                            if (! found) {
                              closedir(dd);
                              return (1);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  closedir(dd);
  return (0);
}
}
int cl_statfree(struct cl_stat *dbstat ) 
{ 

  {
  if (dbstat) {
    free((void *)dbstat->stattab);
    dbstat->stattab = (struct stat *)((void *)0);
    dbstat->no = 0;
    if (dbstat->dir) {
      free((void *)dbstat->dir);
      dbstat->dir = (char *)((void *)0);
    }
  } else {
    cli_errmsg("cl_statfree(): Null argument passed\n");
    return (300);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-qsYy7dyq.i","-g -O2 -fPIC")
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
extern int fseek(FILE *__stream , long __off , int __whence ) ;
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
extern gzFile gzdopen(int fd , char const   *mode ) ;
extern int gzread(gzFile file , voidp buf , unsigned int len ) ;
extern int gzclose(gzFile file ) ;
int cli_untgz(int fd , char const   *destdir ) 
{ char *fullname ;
  char osize[13] ;
  char name[101] ;
  char type ;
  char block[512] ;
  int nbytes ;
  int nread ;
  int nwritten ;
  int in_block ;
  unsigned int size ;
  FILE *outfile ;
  gzFile *infile ;
  size_t tmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
  in_block = 0;
  outfile = (FILE *)((void *)0);
  cli_dbgmsg("in cli_untgz()\n");
  infile = (gzFile *)gzdopen(fd, "rb");
  if ((unsigned int )infile == (unsigned int )((void *)0)) {
    cli_errmsg("Can\'t gzdopen() descriptor %d\n", fd);
    return (-1);
  }
  tmp = strlen(destdir);
  fullname = (char *)calloc(sizeof(char ), (tmp + 100U) + 5U);
  while (1) {
    nread = gzread((void *)infile, (void *)(block), 512U);
    if (! in_block) {
      if (nread == 0) {
        break;
      }
    }
    if (nread != 512) {
      cli_errmsg("Incomplete block read.\n");
      free((void *)fullname);
      gzclose((void *)infile);
      return (-1);
    }
    if (! in_block) {
      if ((int )block[0] == 0) {
        break;
      }
      __builtin_strncpy(name, block, 100);
      name[100] = (char )'\000';
      strcpy((char * __restrict  )fullname, (char const   * __restrict  )destdir);
      strcat((char * __restrict  )fullname, (char const   * __restrict  )"/");
      strcat((char * __restrict  )fullname, (char const   * __restrict  )(name));
      cli_dbgmsg("Unpacking %s\n", fullname);
      type = block[156];
      switch ((int )type) {
      case 48: ;
      case 0: ;
      break;
      case 53: 
      cli_errmsg("Directories in CVD are not supported.\n");
      free((void *)fullname);
      gzclose((void *)infile);
      return (-1);
      default: 
      cli_errmsg("Unknown type flag %c.\n", type);
      free((void *)fullname);
      gzclose((void *)infile);
      return (-1);
      }
      in_block = 1;
      if (outfile) {
        tmp___1 = fclose(outfile);
        if (tmp___1) {
          cli_errmsg("Cannot close file %s.\n", fullname);
          free((void *)fullname);
          gzclose((void *)infile);
          return (-1);
        }
        outfile = (FILE *)((void *)0);
      }
      outfile = fopen((char const   * __restrict  )fullname, (char const   * __restrict  )"wb");
      if (! outfile) {
        cli_errmsg("Cannot create file %s.\n", fullname);
        free((void *)fullname);
        gzclose((void *)infile);
        return (-1);
      }
      __builtin_strncpy(osize, block + 124, 12);
      osize[12] = (char )'\000';
      tmp___2 = sscanf((char const   * __restrict  )(osize), (char const   * __restrict  )"%o",
                       & size);
      if (tmp___2 == 0) {
        cli_errmsg("Invalid size in header.\n");
        free((void *)fullname);
        gzclose((void *)infile);
        fclose(outfile);
        return (-1);
      }
    } else {
      if (size > 512U) {
        nbytes = 512;
      } else {
        nbytes = (int )size;
      }
      nwritten = (int )fwrite((void const   * __restrict  )(block), 1U, (unsigned int )nbytes,
                              (FILE * __restrict  )outfile);
      if (nwritten != nbytes) {
        cli_errmsg("Wrote %d instead of %d (%s).\n", nwritten, nbytes, fullname);
        free((void *)fullname);
        gzclose((void *)infile);
        return (-1);
      }
      size -= (unsigned int )nbytes;
      if (size == 0U) {
        in_block = 0;
      }
    }
  }
  if (outfile) {
    fclose(outfile);
  }
  gzclose((void *)infile);
  free((void *)fullname);
  return (0);
}
}
struct cl_cvd *cl_cvdparse(char const   *head ) 
{ char *pt ;
  struct cl_cvd *cvd ;
  int tmp___73 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___109 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___128 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  size_t tmp___144 ;
  int tmp___145 ;
  size_t tmp___146 ;

  {
  tmp___143 = __builtin_constant_p((int )head);
  if (tmp___143) {
    tmp___144 = strlen(head);
    if (tmp___144 < 11U) {
      goto _L___39;
    } else {
      goto _L___40;
    }
  } else {
    _L___40: 
    tmp___145 = __builtin_constant_p((int )"ClamAV-VDB:");
    if (tmp___145) {
      tmp___146 = strlen("ClamAV-VDB:");
      if (tmp___146 < 11U) {
        _L___39: 
        tmp___140 = __builtin_constant_p((int )head);
        if (tmp___140) {
          tmp___141 = __builtin_constant_p((int )"ClamAV-VDB:");
          if (tmp___141) {
            __s1_len___0 = strlen(head);
            __s2_len___0 = strlen("ClamAV-VDB:");
            if (! ((unsigned int )((void const   *)(head + 1)) - (unsigned int )((void const   *)head) ==
                   1U)) {
              goto _L___36;
            } else {
              if (__s1_len___0 >= 4U) {
                _L___36: 
                if (! ((unsigned int )((void const   *)("ClamAV-VDB:" + 1)) - (unsigned int )((void const   *)"ClamAV-VDB:") ==
                       1U)) {
                  tmp___142 = 1;
                } else {
                  if (__s2_len___0 >= 4U) {
                    tmp___142 = 1;
                  } else {
                    tmp___142 = 0;
                  }
                }
              } else {
                tmp___142 = 0;
              }
            }
            if (tmp___142) {
              tmp___109 = __builtin_strcmp(head, "ClamAV-VDB:");
            } else {
              goto _L___38;
            }
          } else {
            goto _L___38;
          }
        } else {
          _L___38: 
          tmp___139 = __builtin_constant_p((int )head);
          if (tmp___139) {
            if ((unsigned int )((void const   *)(head + 1)) - (unsigned int )((void const   *)head) ==
                1U) {
              __s1_len___0 = strlen(head);
              if (__s1_len___0 < 4U) {
                tmp___128 = __builtin_constant_p((int )"ClamAV-VDB:");
                if (tmp___128) {
                  if ((unsigned int )((void const   *)("ClamAV-VDB:" + 1)) - (unsigned int )((void const   *)"ClamAV-VDB:") ==
                      1U) {
                    tmp___109 = __builtin_strcmp(head, "ClamAV-VDB:");
                  } else {
                    goto _L___31;
                  }
                } else {
                  _L___31: 
                  __s2___14 = (unsigned char const   *)"ClamAV-VDB:";
                  __result___42 = (int )((int const   )(*((unsigned char const   *)head +
                                                          0)) - (int const   )(*(__s2___14 +
                                                                                 0)));
                  if (__s1_len___0 > 0U) {
                    if (__result___42 == 0) {
                      __result___42 = (int )((int const   )(*((unsigned char const   *)head +
                                                              1)) - (int const   )(*(__s2___14 +
                                                                                     1)));
                      if (__s1_len___0 > 1U) {
                        if (__result___42 == 0) {
                          __result___42 = (int )((int const   )(*((unsigned char const   *)head +
                                                                  2)) - (int const   )(*(__s2___14 +
                                                                                         2)));
                          if (__s1_len___0 > 2U) {
                            if (__result___42 == 0) {
                              __result___42 = (int )((int const   )(*((unsigned char const   *)head +
                                                                      3)) - (int const   )(*(__s2___14 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___109 = __result___42;
                }
              } else {
                goto _L___35;
              }
            } else {
              goto _L___35;
            }
          } else {
            _L___35: 
            tmp___138 = __builtin_constant_p((int )"ClamAV-VDB:");
            if (tmp___138) {
              if ((unsigned int )((void const   *)("ClamAV-VDB:" + 1)) - (unsigned int )((void const   *)"ClamAV-VDB:") ==
                  1U) {
                __s2_len___0 = strlen("ClamAV-VDB:");
                if (__s2_len___0 < 4U) {
                  tmp___137 = __builtin_constant_p((int )head);
                  if (tmp___137) {
                    if ((unsigned int )((void const   *)(head + 1)) - (unsigned int )((void const   *)head) ==
                        1U) {
                      tmp___109 = __builtin_strcmp(head, "ClamAV-VDB:");
                    } else {
                      goto _L___33;
                    }
                  } else {
                    _L___33: 
                    __s1___30 = (unsigned char const   *)head;
                    __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)"ClamAV-VDB:" +
                                                                                               0)));
                    if (__s2_len___0 > 0U) {
                      if (__result___46 == 0) {
                        __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                               (int const   )(*((unsigned char const   *)"ClamAV-VDB:" +
                                                                1)));
                        if (__s2_len___0 > 1U) {
                          if (__result___46 == 0) {
                            __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                   (int const   )(*((unsigned char const   *)"ClamAV-VDB:" +
                                                                    2)));
                            if (__s2_len___0 > 2U) {
                              if (__result___46 == 0) {
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        3)) - (int const   )(*((unsigned char const   *)"ClamAV-VDB:" +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___109 = __result___46;
                  }
                } else {
                  tmp___109 = __builtin_strcmp(head, "ClamAV-VDB:");
                }
              } else {
                tmp___109 = __builtin_strcmp(head, "ClamAV-VDB:");
              }
            } else {
              tmp___109 = __builtin_strcmp(head, "ClamAV-VDB:");
            }
          }
        }
        tmp___73 = tmp___109;
      } else {
        tmp___73 = strncmp(head, "ClamAV-VDB:", 11U);
      }
    } else {
      tmp___73 = strncmp(head, "ClamAV-VDB:", 11U);
    }
  }
  if (tmp___73) {
    cli_dbgmsg("Not a CVD head.\n");
    return ((struct cl_cvd *)((void *)0));
  }
  cvd = (struct cl_cvd *)cli_calloc(1U, sizeof(struct cl_cvd ));
  cvd->time = cli_strtok(head, 1, ":");
  if (! cvd->time) {
    cli_errmsg("CVD -> Can\'t extract time from header.\n");
    free((void *)cvd);
    return ((struct cl_cvd *)((void *)0));
  }
  pt = cli_strtok(head, 2, ":");
  if (! pt) {
    cli_errmsg("CVD -> Can\'t extract version from header.\n");
    free((void *)cvd->time);
    free((void *)cvd);
    return ((struct cl_cvd *)((void *)0));
  }
  cvd->version = atoi__extinline((char const   *)pt);
  free((void *)pt);
  pt = cli_strtok(head, 3, ":");
  if (! pt) {
    cli_errmsg("CVD -> Can\'t extract signature number from header.\n");
    free((void *)cvd->time);
    free((void *)cvd);
    return ((struct cl_cvd *)((void *)0));
  }
  cvd->sigs = atoi__extinline((char const   *)pt);
  free((void *)pt);
  pt = cli_strtok(head, 4, ":");
  if (! pt) {
    cli_errmsg("CVD -> Can\'t extract functionality level from header.\n");
    free((void *)cvd->time);
    free((void *)cvd);
    return ((struct cl_cvd *)((void *)0));
  }
  cvd->fl = (short )atoi__extinline((char const   *)pt);
  free((void *)pt);
  cvd->md5 = cli_strtok(head, 5, ":");
  if (! cvd->md5) {
    cli_errmsg("CVD -> Can\'t extract MD5 checksum from header.\n");
    free((void *)cvd->time);
    free((void *)cvd);
    return ((struct cl_cvd *)((void *)0));
  }
  cvd->dsig = cli_strtok(head, 6, ":");
  if (! cvd->dsig) {
    cli_errmsg("CVD -> Can\'t extract digital signature from header.\n");
    free((void *)cvd->time);
    free((void *)cvd->md5);
    free((void *)cvd);
    return ((struct cl_cvd *)((void *)0));
  }
  cvd->builder = cli_strtok(head, 7, ":");
  if (! cvd->builder) {
    cli_errmsg("CVD -> Can\'t extract builder name from header.\n");
    free((void *)cvd->time);
    free((void *)cvd->md5);
    free((void *)cvd->dsig);
    free((void *)cvd);
    return ((struct cl_cvd *)((void *)0));
  }
  pt = cli_strtok(head, 8, ":");
  if (pt) {
    cvd->stime = atoi__extinline((char const   *)pt);
    free((void *)pt);
  } else {
    cli_dbgmsg("CVD -> No creation time in seconds (old file format)\n");
  }
  return (cvd);
}
}
struct cl_cvd *cl_cvdhead(char const   *file ) 
{ FILE *fd ;
  char head[513] ;
  int i ;
  struct cl_cvd *tmp ;

  {
  fd = fopen((char const   * __restrict  )file, (char const   * __restrict  )"rb");
  if ((unsigned int )fd == (unsigned int )((void *)0)) {
    cli_dbgmsg("Can\'t open CVD file %s\n", file);
    return ((struct cl_cvd *)((void *)0));
  }
  i = (int )fread((void * __restrict  )(head), 1U, 512U, (FILE * __restrict  )fd);
  if (i != 512) {
    cli_dbgmsg("Short read (%d) while reading CVD head from %s\n", i, file);
    fclose(fd);
    return ((struct cl_cvd *)((void *)0));
  }
  fclose(fd);
  head[512] = (char)0;
  i = 511;
  while (1) {
    if (i > 0) {
      if (! ((int )head[i] == 32)) {
        if (! ((int )head[i] == 10)) {
          break;
        }
      }
    } else {
      break;
    }
    head[i] = (char)0;
    i --;
  }
  tmp = cl_cvdparse((char const   *)(head));
  return (tmp);
}
}
void cl_cvdfree(struct cl_cvd *cvd ) 
{ 

  {
  free((void *)cvd->time);
  free((void *)cvd->md5);
  free((void *)cvd->dsig);
  free((void *)cvd->builder);
  free((void *)cvd);
  return;
}
}
int cli_cvdverify(FILE *fd , struct cl_cvd *cvdpt ) 
{ struct cl_cvd *cvd ;
  char *md5 ;
  char head[513] ;
  int i ;
  size_t tmp ;
  int tmp___74 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___110 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___129 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  size_t tmp___145 ;
  int tmp___146 ;
  size_t tmp___147 ;

  {
  fseek(fd, 0L, 0);
  tmp = fread((void * __restrict  )(head), 1U, 512U, (FILE * __restrict  )fd);
  if (tmp != 512U) {
    cli_dbgmsg("Can\'t read CVD head from stream\n");
    return (-8);
  }
  head[512] = (char)0;
  i = 511;
  while (1) {
    if (i > 0) {
      if (! ((int )head[i] == 32)) {
        if (! ((int )head[i] == 10)) {
          break;
        }
      }
    } else {
      break;
    }
    head[i] = (char)0;
    i --;
  }
  cvd = cl_cvdparse((char const   *)(head));
  if ((unsigned int )cvd == (unsigned int )((void *)0)) {
    return (-8);
  }
  if (cvdpt) {
    memcpy((void * __restrict  )cvdpt, (void const   * __restrict  )cvd, sizeof(struct cl_cvd ));
  }
  md5 = cli_md5stream(fd, (unsigned char *)((void *)0));
  cli_dbgmsg("MD5(.tar.gz) = %s\n", md5);
  tmp___144 = __builtin_constant_p((int )md5);
  if (tmp___144) {
    tmp___145 = strlen((char const   *)md5);
    if (tmp___145 < 32U) {
      goto _L___39;
    } else {
      goto _L___40;
    }
  } else {
    _L___40: 
    tmp___146 = __builtin_constant_p((int )cvd->md5);
    if (tmp___146) {
      tmp___147 = strlen((char const   *)cvd->md5);
      if (tmp___147 < 32U) {
        _L___39: 
        tmp___141 = __builtin_constant_p((int )md5);
        if (tmp___141) {
          tmp___142 = __builtin_constant_p((int )cvd->md5);
          if (tmp___142) {
            __s1_len___0 = strlen((char const   *)md5);
            __s2_len___0 = strlen((char const   *)cvd->md5);
            if (! ((unsigned int )((void const   *)(md5 + 1)) - (unsigned int )((void const   *)md5) ==
                   1U)) {
              goto _L___36;
            } else {
              if (__s1_len___0 >= 4U) {
                _L___36: 
                if (! ((unsigned int )((void const   *)(cvd->md5 + 1)) - (unsigned int )((void const   *)cvd->md5) ==
                       1U)) {
                  tmp___143 = 1;
                } else {
                  if (__s2_len___0 >= 4U) {
                    tmp___143 = 1;
                  } else {
                    tmp___143 = 0;
                  }
                }
              } else {
                tmp___143 = 0;
              }
            }
            if (tmp___143) {
              tmp___110 = __builtin_strcmp(md5, cvd->md5);
            } else {
              goto _L___38;
            }
          } else {
            goto _L___38;
          }
        } else {
          _L___38: 
          tmp___140 = __builtin_constant_p((int )md5);
          if (tmp___140) {
            if ((unsigned int )((void const   *)(md5 + 1)) - (unsigned int )((void const   *)md5) ==
                1U) {
              __s1_len___0 = strlen((char const   *)md5);
              if (__s1_len___0 < 4U) {
                tmp___129 = __builtin_constant_p((int )cvd->md5);
                if (tmp___129) {
                  if ((unsigned int )((void const   *)(cvd->md5 + 1)) - (unsigned int )((void const   *)cvd->md5) ==
                      1U) {
                    tmp___110 = __builtin_strcmp(md5, cvd->md5);
                  } else {
                    goto _L___31;
                  }
                } else {
                  _L___31: 
                  __s2___14 = (unsigned char const   *)((char const   *)cvd->md5);
                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)md5) +
                                                          0)) - (int const   )(*(__s2___14 +
                                                                                 0)));
                  if (__s1_len___0 > 0U) {
                    if (__result___42 == 0) {
                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)md5) +
                                                              1)) - (int const   )(*(__s2___14 +
                                                                                     1)));
                      if (__s1_len___0 > 1U) {
                        if (__result___42 == 0) {
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)md5) +
                                                                  2)) - (int const   )(*(__s2___14 +
                                                                                         2)));
                          if (__s1_len___0 > 2U) {
                            if (__result___42 == 0) {
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)md5) +
                                                                      3)) - (int const   )(*(__s2___14 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___110 = __result___42;
                }
              } else {
                goto _L___35;
              }
            } else {
              goto _L___35;
            }
          } else {
            _L___35: 
            tmp___139 = __builtin_constant_p((int )cvd->md5);
            if (tmp___139) {
              if ((unsigned int )((void const   *)(cvd->md5 + 1)) - (unsigned int )((void const   *)cvd->md5) ==
                  1U) {
                __s2_len___0 = strlen((char const   *)cvd->md5);
                if (__s2_len___0 < 4U) {
                  tmp___138 = __builtin_constant_p((int )md5);
                  if (tmp___138) {
                    if ((unsigned int )((void const   *)(md5 + 1)) - (unsigned int )((void const   *)md5) ==
                        1U) {
                      tmp___110 = __builtin_strcmp(md5, cvd->md5);
                    } else {
                      goto _L___33;
                    }
                  } else {
                    _L___33: 
                    __s1___30 = (unsigned char const   *)((char const   *)md5);
                    __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)cvd->md5) +
                                                                                               0)));
                    if (__s2_len___0 > 0U) {
                      if (__result___46 == 0) {
                        __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                               (int const   )(*((unsigned char const   *)((char const   *)cvd->md5) +
                                                                1)));
                        if (__s2_len___0 > 1U) {
                          if (__result___46 == 0) {
                            __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                   (int const   )(*((unsigned char const   *)((char const   *)cvd->md5) +
                                                                    2)));
                            if (__s2_len___0 > 2U) {
                              if (__result___46 == 0) {
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        3)) - (int const   )(*((unsigned char const   *)((char const   *)cvd->md5) +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___110 = __result___46;
                  }
                } else {
                  tmp___110 = __builtin_strcmp(md5, cvd->md5);
                }
              } else {
                tmp___110 = __builtin_strcmp(md5, cvd->md5);
              }
            } else {
              tmp___110 = __builtin_strcmp(md5, cvd->md5);
            }
          }
        }
        tmp___74 = tmp___110;
      } else {
        tmp___74 = strncmp((char const   *)md5, (char const   *)cvd->md5, 32U);
      }
    } else {
      tmp___74 = strncmp((char const   *)md5, (char const   *)cvd->md5, 32U);
    }
  }
  if (tmp___74) {
    cli_dbgmsg("MD5 verification error.\n");
    free((void *)md5);
    cl_cvdfree(cvd);
    return (-10);
  }
  free((void *)md5);
  cl_cvdfree(cvd);
  return (0);
}
}
int cl_cvdverify(char const   *file ) 
{ FILE *fd ;
  int ret ;

  {
  fd = fopen((char const   * __restrict  )file, (char const   * __restrict  )"rb");
  if ((unsigned int )fd == (unsigned int )((void *)0)) {
    cli_errmsg("Can\'t open CVD file %s\n", file);
    return (-4);
  }
  ret = cli_cvdverify(fd, (struct cl_cvd *)((void *)0));
  fclose(fd);
  return (ret);
}
}
int cli_cvdload(FILE *fd , struct cl_node **root , unsigned int *signo , short warn ) 
{ char *dir ;
  char *tmp ;
  char *buffer ;
  struct cl_cvd cvd ;
  int bytes ;
  int ret ;
  FILE *tmpd ;
  time_t stime___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  cli_dbgmsg("in cli_cvdload()\n");
  ret = cli_cvdverify(fd, & cvd);
  if (ret) {
    return (ret);
  }
  if (cvd.stime) {
    if (warn) {
      time(& stime___0);
      if ((int )stime___0 - cvd.stime > 604800) {
        cli_warnmsg("**************************************************\n");
        cli_warnmsg("***  The virus database is older than 7 days.  ***\n");
        cli_warnmsg("***        Please update it IMMEDIATELY!       ***\n");
        cli_warnmsg("**************************************************\n");
      }
    }
  }
  tmp___0 = cl_retflevel();
  if ((int )cvd.fl > tmp___0) {
    cli_warnmsg("********************************************************\n");
    cli_warnmsg("***  This version of the ClamAV engine is outdated.  ***\n");
    cli_warnmsg("*** DON\'T PANIC! Read http://www.clamav.net/faq.html ***\n");
    cli_warnmsg("********************************************************\n");
  }
  fseek(fd, 512L, 0);
  dir = cli_gentemp((char const   *)((void *)0));
  tmp___1 = mkdir((char const   *)dir, 448U);
  if (tmp___1) {
    cli_errmsg("cli_cvdload():  Can\'t create temporary directory %s\n", dir);
    return (-7);
  }
  tmp = cli_gentemp((char const   *)((void *)0));
  tmpd = fopen((char const   * __restrict  )tmp, (char const   * __restrict  )"wb+");
  if ((unsigned int )tmpd == (unsigned int )((void *)0)) {
    cli_errmsg("Can\'t create temporary file %s\n", tmp);
    free((void *)dir);
    free((void *)tmp);
    return (-1);
  }
  buffer = (char *)cli_malloc(8192U);
  if (! buffer) {
    free((void *)dir);
    free((void *)tmp);
    fclose(tmpd);
    return (-3);
  }
  while (1) {
    bytes = (int )fread((void * __restrict  )buffer, 1U, 8192U, (FILE * __restrict  )fd);
    if (! (bytes > 0)) {
      break;
    }
    fwrite((void const   * __restrict  )buffer, 1U, (unsigned int )bytes, (FILE * __restrict  )tmpd);
  }
  free((void *)buffer);
  fflush(tmpd);
  fseek(tmpd, 0L, 0);
  tmp___3 = fileno(tmpd);
  tmp___4 = cli_untgz(tmp___3, (char const   *)dir);
  if (tmp___4) {
    perror("cli_untgz");
    cli_errmsg("cli_cvdload(): Can\'t unpack CVD file.\n");
    cli_rmdirs((char const   *)dir);
    free((void *)dir);
    fclose(tmpd);
    unlink((char const   *)tmp);
    free((void *)tmp);
    return (-9);
  }
  fclose(tmpd);
  unlink((char const   *)tmp);
  free((void *)tmp);
  cl_loaddbdir((char const   *)dir, root, signo);
  cli_rmdirs((char const   *)dir);
  free((void *)dir);
  return (0);
}
}
#pragma merger(0,"/tmp/cil-zn97rWTG.i","-g -O2 -fPIC")
#pragma merger(0,"/tmp/cil-YxYgX37I.i","-g -O2 -fPIC")
char *cli_str2hex(char const   *string , unsigned int len ) ;
char *cli_strtokbuf(char const   *input , int fieldno , char const   *delim , char *output ) ;
char const   *cli_memstr(char const   *haystack , int hs , char const   *needle ,
                         int ns ) ;
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__,
__nonnull__(1))) ;
 __attribute__((__nothrow__)) int strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
__inline static  __attribute__((__nothrow__)) int tolower__extinline(int __c ) ;
static int cli_hex2int(int c ) 
{ int l ;
  int __res ;
  int __c ;
  __int32_t const   **tmp___0 ;
  int tmp___1 ;
  __int32_t const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  if (sizeof(c) > 1U) {
    tmp___1 = __builtin_constant_p(c);
    if (tmp___1) {
      __c = c;
      if (__c < -128) {
        __res = __c;
      } else {
        if (__c > 255) {
          __res = __c;
        } else {
          tmp___0 = __ctype_tolower_loc();
          __res = (*((*tmp___0) + __c));
        }
      }
    } else {
      __res = tolower__extinline(c);
    }
  } else {
    tmp___2 = __ctype_tolower_loc();
    __res = (*((*tmp___2) + c));
  }
  l = __res;
  if (! ((l & -128) == 0)) {
    return (-1);
  }
  tmp___3 = __ctype_b_loc();
  if ((int const   )(*((*tmp___3) + l)) & 2048) {
    return (l - 48);
  }
  if (l >= 97) {
    if (l <= 102) {
      return ((l + 10) - 97);
    }
  }
  cli_errmsg("hex2int() translation problem (%d)\n", l);
  return (-1);
}
}
short *cli_hex2si(char const   *hex___0 ) 
{ short *str ;
  short *ptr ;
  short val ;
  short c ;
  int i ;
  int len ;
  short *tmp ;

  {
  len = (int )strlen(hex___0);
  if (len % 2 != 0) {
    cli_errmsg("cli_hex2si(): Malformed hexstring: %s (length: %d)\n", hex___0, len);
    return ((short *)((void *)0));
  }
  str = (short *)cli_calloc((unsigned int )(len / 2 + 1), sizeof(short ));
  if (! str) {
    return ((short *)((void *)0));
  }
  ptr = str;
  i = 0;
  while (i < len) {
    if ((int const   )(*(hex___0 + i)) == 63) {
      val = (short)-200;
    } else {
      if ((int const   )(*(hex___0 + i)) == 64) {
        val = (short)-201;
      } else {
        c = (short )cli_hex2int((int )(*(hex___0 + i)));
        if ((int )c >= 0) {
          val = c;
          c = (short )cli_hex2int((int )(*(hex___0 + (i + 1))));
          if ((int )c >= 0) {
            val = (short )(((int )val << 4) + (int )c);
          } else {
            free((void *)str);
            return ((short *)((void *)0));
          }
        } else {
          free((void *)str);
          return ((short *)((void *)0));
        }
      }
    }
    tmp = ptr;
    ptr ++;
    (*tmp) = val;
    i += 2;
  }
  return (str);
}
}
char *cli_hex2str(char const   *hex___0 ) 
{ char *str ;
  char *ptr ;
  char val ;
  char c ;
  int i ;
  int len ;
  char *tmp ;

  {
  len = (int )strlen(hex___0);
  if (len % 2 != 0) {
    cli_errmsg("cli_hex2str(): Malformed hexstring: %s (length: %d)\n", hex___0, len);
    return ((char *)((void *)0));
  }
  str = (char *)cli_calloc((unsigned int )(len / 2 + 1), sizeof(char ));
  if (! str) {
    return ((char *)((void *)0));
  }
  ptr = str;
  i = 0;
  while (i < len) {
    c = (char )cli_hex2int((int )(*(hex___0 + i)));
    if ((int )c >= 0) {
      val = c;
      c = (char )cli_hex2int((int )(*(hex___0 + (i + 1))));
      if ((int )c >= 0) {
        val = (char )(((int )val << 4) + (int )c);
      } else {
        free((void *)str);
        return ((char *)((void *)0));
      }
    } else {
      free((void *)str);
      return ((char *)((void *)0));
    }
    tmp = ptr;
    ptr ++;
    (*tmp) = val;
    i += 2;
  }
  return (str);
}
}
int cli_hex2num(char const   *hex___0 ) 
{ int hexval ;
  int ret ;
  int len ;
  int i ;

  {
  ret = 0;
  len = (int )strlen(hex___0);
  if (len % 2 != 0) {
    cli_errmsg("cli_hex2num(): Malformed hexstring: %s (length: %d)\n", hex___0, len);
    return (-1);
  }
  i = 0;
  while (i < len) {
    hexval = cli_hex2int((int )(*(hex___0 + i)));
    if (hexval < 0) {
      break;
    }
    ret = (ret << 4) | hexval;
    i ++;
  }
  return (ret);
}
}
char *cli_str2hex(char const   *string , unsigned int len ) 
{ char *hexstr ;
  char HEX[16] ;
  unsigned int i ;
  unsigned int j ;

  {
  HEX[0] = (char )'0';
  HEX[1] = (char )'1';
  HEX[2] = (char )'2';
  HEX[3] = (char )'3';
  HEX[4] = (char )'4';
  HEX[5] = (char )'5';
  HEX[6] = (char )'6';
  HEX[7] = (char )'7';
  HEX[8] = (char )'8';
  HEX[9] = (char )'9';
  HEX[10] = (char )'a';
  HEX[11] = (char )'b';
  HEX[12] = (char )'c';
  HEX[13] = (char )'d';
  HEX[14] = (char )'e';
  HEX[15] = (char )'f';
  hexstr = (char *)cli_calloc(2U * len + 1U, sizeof(char ));
  if ((unsigned int )hexstr == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  }
  i = 0U;
  j = 0U;
  while (i < len) {
    (*(hexstr + j)) = HEX[((int const   )(*(string + i)) >> 4) & 15];
    (*(hexstr + (j + 1U))) = HEX[(int const   )(*(string + i)) & 15];
    i ++;
    j += 2U;
  }
  return (hexstr);
}
}
int cli_strbcasestr(char const   *haystack , char const   *needle ) 
{ char *pt ;
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;

  {
  pt = (char *)haystack;
  i = (int )strlen(haystack);
  j = (int )strlen(needle);
  if (i < j) {
    return (0);
  }
  pt += i - j;
  tmp = strcasecmp((char const   *)pt, needle);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return (tmp___0);
}
}
int cli_chomp(char *string ) 
{ int l ;
  int tmp ;

  {
  if ((unsigned int )string == (unsigned int )((void *)0)) {
    return (-1);
  }
  l = (int )strlen((char const   *)string);
  if (l == 0) {
    return (0);
  }
  l --;
  while (1) {
    if (l >= 0) {
      if (! ((int )(*(string + l)) == 10)) {
        if (! ((int )(*(string + l)) == 13)) {
          break;
        }
      }
    } else {
      break;
    }
    tmp = l;
    l --;
    (*(string + tmp)) = (char )'\000';
  }
  return (l + 1);
}
}
char *cli_strtok(char const   *line , int fieldno , char const   *delim ) 
{ int counter ;
  int i ;
  int j ;
  char *buffer ;
  char *tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___11 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___19 ;
  int tmp___21 ;
  int tmp___22 ;

  {
  counter = 0;
  buffer = (char *)((void *)0);
  i = 0;
  while (1) {
    if ((*(line + i))) {
      if (! (counter != fieldno)) {
        break;
      }
    } else {
      break;
    }
    tmp___13 = __builtin_constant_p((int )(*(line + i)));
    if (tmp___13) {
      tmp___14 = __builtin_constant_p((int )delim);
      if (tmp___14) {
        tmp___11 = (char *)__builtin_strchr(delim, (*(line + i)));
      } else {
        if ((int const   )(*(line + i)) == 0) {
          tmp___11 = (char *)__rawmemchr((void const   *)delim, (int )(*(line + i)));
        } else {
          tmp___11 = (char *)__builtin_strchr(delim, (*(line + i)));
        }
      }
    } else {
      tmp___11 = (char *)__builtin_strchr(delim, (*(line + i)));
    }
    if (tmp___11) {
      counter ++;
      while (1) {
        if ((*(line + (i + 1)))) {
          tmp___5 = __builtin_constant_p((int )(*(line + (i + 1))));
          if (tmp___5) {
            tmp___6 = __builtin_constant_p((int )delim);
            if (tmp___6) {
              tmp___3 = (char *)__builtin_strchr(delim, (*(line + (i + 1))));
            } else {
              if ((int const   )(*(line + (i + 1))) == 0) {
                tmp___3 = (char *)__rawmemchr((void const   *)delim, (int )(*(line +
                                                                              (i +
                                                                               1))));
              } else {
                tmp___3 = (char *)__builtin_strchr(delim, (*(line + (i + 1))));
              }
            }
          } else {
            tmp___3 = (char *)__builtin_strchr(delim, (*(line + (i + 1))));
          }
          if (! tmp___3) {
            break;
          }
        } else {
          break;
        }
        i ++;
      }
    }
    i ++;
  }
  if (! (*(line + i))) {
    return ((char *)((void *)0));
  }
  j = i;
  while ((*(line + j))) {
    tmp___21 = __builtin_constant_p((int )(*(line + j)));
    if (tmp___21) {
      tmp___22 = __builtin_constant_p((int )delim);
      if (tmp___22) {
        tmp___19 = (char *)__builtin_strchr(delim, (*(line + j)));
      } else {
        if ((int const   )(*(line + j)) == 0) {
          tmp___19 = (char *)__rawmemchr((void const   *)delim, (int )(*(line + j)));
        } else {
          tmp___19 = (char *)__builtin_strchr(delim, (*(line + j)));
        }
      }
    } else {
      tmp___19 = (char *)__builtin_strchr(delim, (*(line + j)));
    }
    if (tmp___19) {
      break;
    }
    j ++;
  }
  if (i == j) {
    return ((char *)((void *)0));
  }
  buffer = (char *)malloc((unsigned int )((j - i) + 1));
  if (! buffer) {
    return ((char *)((void *)0));
  }
  __builtin_strncpy(buffer, line + i, j - i);
  (*(buffer + (j - i))) = (char )'\000';
  return (buffer);
}
}
char *cli_strtokbuf(char const   *input , int fieldno , char const   *delim , char *output ) 
{ int counter ;
  int i ;
  int j ;
  char *tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___11 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___19 ;
  int tmp___21 ;
  int tmp___22 ;

  {
  counter = 0;
  i = 0;
  while (1) {
    if ((*(input + i))) {
      if (! (counter != fieldno)) {
        break;
      }
    } else {
      break;
    }
    tmp___13 = __builtin_constant_p((int )(*(input + i)));
    if (tmp___13) {
      tmp___14 = __builtin_constant_p((int )delim);
      if (tmp___14) {
        tmp___11 = (char *)__builtin_strchr(delim, (*(input + i)));
      } else {
        if ((int const   )(*(input + i)) == 0) {
          tmp___11 = (char *)__rawmemchr((void const   *)delim, (int )(*(input + i)));
        } else {
          tmp___11 = (char *)__builtin_strchr(delim, (*(input + i)));
        }
      }
    } else {
      tmp___11 = (char *)__builtin_strchr(delim, (*(input + i)));
    }
    if (tmp___11) {
      counter ++;
      while (1) {
        if ((*(input + (i + 1)))) {
          tmp___5 = __builtin_constant_p((int )(*(input + (i + 1))));
          if (tmp___5) {
            tmp___6 = __builtin_constant_p((int )delim);
            if (tmp___6) {
              tmp___3 = (char *)__builtin_strchr(delim, (*(input + (i + 1))));
            } else {
              if ((int const   )(*(input + (i + 1))) == 0) {
                tmp___3 = (char *)__rawmemchr((void const   *)delim, (int )(*(input +
                                                                              (i +
                                                                               1))));
              } else {
                tmp___3 = (char *)__builtin_strchr(delim, (*(input + (i + 1))));
              }
            }
          } else {
            tmp___3 = (char *)__builtin_strchr(delim, (*(input + (i + 1))));
          }
          if (! tmp___3) {
            break;
          }
        } else {
          break;
        }
        i ++;
      }
    }
    i ++;
  }
  if ((int const   )(*(input + i)) == 0) {
    return ((char *)((void *)0));
  }
  j = i;
  while ((*(input + j))) {
    tmp___21 = __builtin_constant_p((int )(*(input + j)));
    if (tmp___21) {
      tmp___22 = __builtin_constant_p((int )delim);
      if (tmp___22) {
        tmp___19 = (char *)__builtin_strchr(delim, (*(input + j)));
      } else {
        if ((int const   )(*(input + j)) == 0) {
          tmp___19 = (char *)__rawmemchr((void const   *)delim, (int )(*(input + j)));
        } else {
          tmp___19 = (char *)__builtin_strchr(delim, (*(input + j)));
        }
      }
    } else {
      tmp___19 = (char *)__builtin_strchr(delim, (*(input + j)));
    }
    if (tmp___19) {
      break;
    }
    j ++;
  }
  if (i == j) {
    return ((char *)((void *)0));
  }
  __builtin_strncpy(output, input + i, j - i);
  (*(output + (j - i))) = (char )'\000';
  return (output);
}
}
char const   *cli_memstr(char const   *haystack , int hs , char const   *needle ,
                         int ns ) 
{ char const   *pt ;
  char const   *hay ;
  int n ;
  int tmp ;
  int tmp___0 ;

  {
  if (hs < ns) {
    return ((char const   *)((void *)0));
  }
  if ((unsigned int )haystack == (unsigned int )needle) {
    return (haystack);
  }
  tmp = memcmp((void const   *)haystack, (void const   *)needle, (unsigned int )ns);
  if (! tmp) {
    return (haystack);
  }
  hay = haystack;
  pt = hay;
  n = hs;
  while (1) {
    pt = (char const   *)memchr((void const   *)hay, (int )(*(needle + 0)), (unsigned int )n);
    if (! ((unsigned int )pt != (unsigned int )((void *)0))) {
      break;
    }
    n -= pt - hay;
    if (n < ns) {
      break;
    }
    tmp___0 = memcmp((void const   *)pt, (void const   *)needle, (unsigned int )ns);
    if (! tmp___0) {
      return (pt);
    }
    if ((unsigned int )hay == (unsigned int )pt) {
      n --;
      hay ++;
    } else {
      hay = pt;
    }
  }
  return ((char const   *)((void *)0));
}
}
#pragma merger(0,"/tmp/cil-e2Oc3xD8.i","-g -O2 -fPIC")
extern FILE *tmpfile(void) ;
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
extern int fsync(int __fd ) ;
struct mscab_decompressor *mspack_create_cab_decompressor(struct mspack_system *sys ) ;
void mspack_destroy_cab_decompressor(struct mscab_decompressor *base ) ;
extern  __attribute__((__nothrow__)) void _pthread_cleanup_push(struct _pthread_cleanup_buffer *__buffer ,
                                                                void (*__routine)(void * ) ,
                                                                void *__arg ) ;
extern  __attribute__((__nothrow__)) void _pthread_cleanup_pop(struct _pthread_cleanup_buffer *__buffer ,
                                                               int __execute ) ;
struct __anonstruct_pthread_mutex_t_16 cli_scanrar_mutex  =    {0, 0, (struct _pthread_descr_struct *)0, 0, {0L, 0}};
int cli_scanrar_inuse  =    0;
int cli_mbox(char const   *dir , int desc , unsigned int options ) ;
int cl_scandesc(int desc , char const   **virname , unsigned long *scanned , struct cl_node  const  *root ,
                struct cl_limits  const  *limits , unsigned int options ) ;
int cl_scanfile(char const   *filename , char const   **virname , unsigned long *scanned ,
                struct cl_node  const  *root , struct cl_limits  const  *limits ,
                unsigned int options ) ;
int cli_magic_scandesc(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                       struct cl_limits  const  *limits , unsigned int options , unsigned int arec ,
                       unsigned int mrec ) ;
int urarlib_get(void *output , unsigned long *size , char *filename , int desc , char *libpassword ) ;
int urarlib_list(int desc , ArchiveList_struct *list ) ;
void urarlib_freelist(ArchiveList_struct *list ) ;
int cli_ole2_extract(int fd , char const   *dirname , struct cl_limits  const  *limits ) ;
vba_project_t *vba56_dir_read(char const   *dir ) ;
unsigned char *vba_decompress(int fd , uint32_t offset , int *size ) ;
char *ppt_vba_read(char const   *dir ) ;
vba_project_t *wm_dir_read(char const   *dir ) ;
unsigned char *wm_decrypt_macro(int fd , uint32_t offset , uint32_t len , unsigned char key ) ;
int cli_msexpand(FILE *in , FILE *out ) ;
int chm_unpack(int fd , char const   *dirname ) ;
int cli_scanpe(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
               struct cl_limits  const  *limits , unsigned int options , unsigned int arec ,
               unsigned int mrec ) ;
cli_file_t cli_filetype2(int desc ) ;
int html_normalise_fd(int fd , char const   *dirname , tag_arguments_t *hrefs ) ;
int html_screnc_decode(int fd , char const   *dirname ) ;
int cli_untar(char const   *dir , int desc , unsigned int posix ) ;
int cli_check_mydoom_log(int desc , char const   **virname ) ;
int cli_check_jpeg_exploit(int fd ) ;
int cli_check_riff_exploit(int fd ) ;
int cli_binhex(char const   *dir , int desc ) ;
ZZIP_DIR *zzip_dir_fdopen(int fd , zzip_error_t *errcode_p ) ;
int zzip_dir_close(ZZIP_DIR *dir ) ;
int zzip_dir_read(ZZIP_DIR *dir , ZZIP_DIRENT *d ) ;
ZZIP_FILE *zzip_file_open(ZZIP_DIR *dir , zzip_char_t *name , int o_mode ) ;
int zzip_file_close(ZZIP_FILE *fp ) ;
zzip_ssize_t zzip_file_read(ZZIP_FILE *fp , char *buf , zzip_size_t len ) ;
extern BZFILE *BZ2_bzReadOpen(int *bzerror , FILE *f , int verbosity , int small ,
                              void *unused , int nUnused ) ;
extern void BZ2_bzReadClose(int *bzerror , BZFILE *b ) ;
extern int BZ2_bzRead(int *bzerror , BZFILE *b , void *buf , int len ) ;
static int cli_scanfile(char const   *filename , char const   **virname , unsigned long *scanned ,
                        struct cl_node  const  *root , struct cl_limits  const  *limits ,
                        unsigned int options , unsigned int arec , unsigned int mrec ) ;
static void cli_unlock_mutex(void *mtx ) 
{ 

  {
  cli_dbgmsg("Pthread cancelled. Unlocking mutex.\n");
  pthread_mutex_unlock((pthread_mutex_t *)mtx);
  return;
}
}
static int cli_scanrar(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                       struct cl_limits  const  *limits , unsigned int options , unsigned int arec ,
                       unsigned int mrec ) 
{ FILE *tmp ;
  int fd ;
  int ret ;
  unsigned int files ;
  unsigned int encrypted ;
  unsigned int afiles ;
  ArchiveList_struct *rarlist ;
  ArchiveList_struct *rarlist_head ;
  char *rar_data_ptr ;
  unsigned long rar_data_size ;
  struct cli_meta_node *mdata ;
  struct _pthread_cleanup_buffer _buffer ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___37 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___56 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  size_t tmp___71 ;
  int *tmp___72 ;
  char *tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;

  {
  tmp = (FILE *)((void *)0);
  ret = 0;
  files = 0U;
  rarlist = (ArchiveList_struct *)((void *)0);
  rarlist_head = (ArchiveList_struct *)((void *)0);
  cli_dbgmsg("in scanrar()\n");
  _pthread_cleanup_push(& _buffer, & cli_unlock_mutex, (void *)(& cli_scanrar_mutex));
  pthread_mutex_lock(& cli_scanrar_mutex);
  cli_scanrar_inuse = 1;
  afiles = (unsigned int )urarlib_list(desc, (ArchiveList_struct *)(& rarlist));
  if (! afiles) {
    pthread_mutex_unlock(& cli_scanrar_mutex);
    cli_scanrar_inuse = 0;
    return (100);
  }
  cli_dbgmsg("RAR: Number of archived files: %d\n", afiles);
  rarlist_head = rarlist;
  while (rarlist) {
    files ++;
    encrypted = (unsigned int )((int )rarlist->item.Flags & 4);
    if (limits) {
      tmp___0 = limits->maxratio;
    } else {
      tmp___0 = 0U;
    }
    if (rarlist->item.PackSize) {
      tmp___1 = (unsigned int )rarlist->item.UnpSize / (unsigned int )rarlist->item.PackSize;
    } else {
      tmp___1 = 0U;
    }
    cli_dbgmsg("RAR: %s, crc32: 0x%x, encrypted: %d, compressed: %u, normal: %u, method: %d, ratio: %d (max: %d)\n",
               rarlist->item.Name, rarlist->item.FileCRC, encrypted, rarlist->item.PackSize,
               rarlist->item.UnpSize, rarlist->item.Method, tmp___1, tmp___0);
    mdata = root->rar_mlist;
    if (mdata) {
      while (1) {
        if (mdata->encrypted != encrypted) {
          goto __Cont;
        }
        if (mdata->crc32) {
          if ((unsigned long )mdata->crc32 != rarlist->item.FileCRC) {
            goto __Cont;
          }
        }
        if (mdata->csize > 0) {
          if ((unsigned long )((unsigned int )mdata->csize) != rarlist->item.PackSize) {
            goto __Cont;
          }
        }
        if (mdata->size >= 0) {
          if ((unsigned long )((unsigned int )mdata->size) != rarlist->item.UnpSize) {
            goto __Cont;
          }
        }
        if (mdata->method >= 0) {
          if (mdata->method != (int )rarlist->item.Method) {
            goto __Cont;
          }
        }
        if (mdata->fileno) {
          if (mdata->fileno != files) {
            goto __Cont;
          }
        }
        if (mdata->maxdepth) {
          if (arec > mdata->maxdepth) {
            goto __Cont;
          }
        }
        if (mdata->filename) {
          tmp___68 = __builtin_constant_p((int )rarlist->item.Name);
          if (tmp___68) {
            tmp___69 = __builtin_constant_p((int )mdata->filename);
            if (tmp___69) {
              __s1_len = strlen((char const   *)rarlist->item.Name);
              __s2_len = strlen((char const   *)mdata->filename);
              if (! ((unsigned int )((void const   *)(rarlist->item.Name + 1)) - (unsigned int )((void const   *)rarlist->item.Name) ==
                     1U)) {
                goto _L___16;
              } else {
                if (__s1_len >= 4U) {
                  _L___16: 
                  if (! ((unsigned int )((void const   *)(mdata->filename + 1)) -
                         (unsigned int )((void const   *)mdata->filename) == 1U)) {
                    tmp___70 = 1;
                  } else {
                    if (__s2_len >= 4U) {
                      tmp___70 = 1;
                    } else {
                      tmp___70 = 0;
                    }
                  }
                } else {
                  tmp___70 = 0;
                }
              }
              if (tmp___70) {
                tmp___37 = __builtin_strcmp(rarlist->item.Name, mdata->filename);
              } else {
                goto _L___18;
              }
            } else {
              goto _L___18;
            }
          } else {
            _L___18: 
            tmp___67 = __builtin_constant_p((int )rarlist->item.Name);
            if (tmp___67) {
              if ((unsigned int )((void const   *)(rarlist->item.Name + 1)) - (unsigned int )((void const   *)rarlist->item.Name) ==
                  1U) {
                __s1_len = strlen((char const   *)rarlist->item.Name);
                if (__s1_len < 4U) {
                  tmp___56 = __builtin_constant_p((int )mdata->filename);
                  if (tmp___56) {
                    if ((unsigned int )((void const   *)(mdata->filename + 1)) - (unsigned int )((void const   *)mdata->filename) ==
                        1U) {
                      tmp___37 = __builtin_strcmp(rarlist->item.Name, mdata->filename);
                    } else {
                      goto _L___11;
                    }
                  } else {
                    _L___11: 
                    __s2___6 = (unsigned char const   *)((char const   *)mdata->filename);
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)rarlist->item.Name) +
                                                            0)) - (int const   )(*(__s2___6 +
                                                                                   0)));
                    if (__s1_len > 0U) {
                      if (__result___18 == 0) {
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)rarlist->item.Name) +
                                                                1)) - (int const   )(*(__s2___6 +
                                                                                       1)));
                        if (__s1_len > 1U) {
                          if (__result___18 == 0) {
                            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)rarlist->item.Name) +
                                                                    2)) - (int const   )(*(__s2___6 +
                                                                                           2)));
                            if (__s1_len > 2U) {
                              if (__result___18 == 0) {
                                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)rarlist->item.Name) +
                                                                        3)) - (int const   )(*(__s2___6 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___37 = __result___18;
                  }
                } else {
                  goto _L___15;
                }
              } else {
                goto _L___15;
              }
            } else {
              _L___15: 
              tmp___66 = __builtin_constant_p((int )mdata->filename);
              if (tmp___66) {
                if ((unsigned int )((void const   *)(mdata->filename + 1)) - (unsigned int )((void const   *)mdata->filename) ==
                    1U) {
                  __s2_len = strlen((char const   *)mdata->filename);
                  if (__s2_len < 4U) {
                    tmp___65 = __builtin_constant_p((int )rarlist->item.Name);
                    if (tmp___65) {
                      if ((unsigned int )((void const   *)(rarlist->item.Name + 1)) -
                          (unsigned int )((void const   *)rarlist->item.Name) == 1U) {
                        tmp___37 = __builtin_strcmp(rarlist->item.Name, mdata->filename);
                      } else {
                        goto _L___13;
                      }
                    } else {
                      _L___13: 
                      __s1___14 = (unsigned char const   *)((char const   *)rarlist->item.Name);
                      __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)mdata->filename) +
                                                                                                 0)));
                      if (__s2_len > 0U) {
                        if (__result___22 == 0) {
                          __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                                 (int const   )(*((unsigned char const   *)((char const   *)mdata->filename) +
                                                                  1)));
                          if (__s2_len > 1U) {
                            if (__result___22 == 0) {
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      2)) - (int const   )(*((unsigned char const   *)((char const   *)mdata->filename) +
                                                                                             2)));
                              if (__s2_len > 2U) {
                                if (__result___22 == 0) {
                                  __result___22 = (int )((int const   )(*(__s1___14 +
                                                                          3)) - (int const   )(*((unsigned char const   *)((char const   *)mdata->filename) +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___37 = __result___22;
                    }
                  } else {
                    tmp___37 = __builtin_strcmp(rarlist->item.Name, mdata->filename);
                  }
                } else {
                  tmp___37 = __builtin_strcmp(rarlist->item.Name, mdata->filename);
                }
              } else {
                tmp___37 = __builtin_strcmp(rarlist->item.Name, mdata->filename);
              }
            }
          }
          if (tmp___37) {
            goto __Cont;
          }
        }
        break;
        __Cont: 
        mdata = mdata->next;
        if (! mdata) {
          break;
        }
      }
    }
    if (mdata) {
      (*virname) = (char const   *)mdata->virname;
      ret = 1;
      break;
    }
    if (options & 16U) {
      if ((int )rarlist->item.Flags & 4) {
        cli_dbgmsg("RAR: Encrypted files found in archive.\n");
        lseek(desc, 0L, 0);
        ret = cli_scandesc(desc, virname, scanned, root, (short)0, (unsigned short)0);
        if (ret < 0) {
          break;
        } else {
          if (ret != 1) {
            (*virname) = "Encrypted.RAR";
            ret = 1;
          }
        }
        break;
      }
    }
    if (((int )rarlist->item.Flags & 3) != 0) {
      cli_dbgmsg("RAR: Skipping %s (splitted)\n", rarlist->item.Name);
      rarlist = rarlist->next;
      continue;
    }
    if (limits) {
      if (limits->maxratio) {
        if (rarlist->item.UnpSize) {
          if (rarlist->item.PackSize) {
            if ((unsigned int )rarlist->item.UnpSize / (unsigned int )rarlist->item.PackSize >=
                limits->maxratio) {
              cli_dbgmsg("RAR: Max ratio reached (normal: %d, compressed: %d, max: %ld)\n",
                         (int )rarlist->item.UnpSize, (int )rarlist->item.PackSize,
                         limits->maxratio);
              (*virname) = "Oversized.RAR";
              ret = 1;
              break;
            }
          }
        }
      }
      if (limits->maxfilesize) {
        if (rarlist->item.UnpSize > (unsigned long )((unsigned int )limits->maxfilesize)) {
          cli_dbgmsg("RAR: %s: Size exceeded (%u, max: %lu)\n", rarlist->item.Name,
                     (unsigned int )rarlist->item.UnpSize, limits->maxfilesize);
          rarlist = rarlist->next;
          if (options & 512U) {
            (*virname) = "RAR.ExceededFileSize";
            ret = 1;
            break;
          }
          continue;
        }
      }
      if (limits->maxfiles) {
        if (files > limits->maxfiles) {
          cli_dbgmsg("RAR: Files limit reached (max: %d)\n", limits->maxfiles);
          if (options & 512U) {
            (*virname) = "RAR.ExceededFilesLimit";
            ret = 1;
            break;
          }
          break;
        }
      }
    }
    if (rarlist->item.FileAttr & 16400UL) {
      rarlist = rarlist->next;
      continue;
    }
    tmp = tmpfile();
    if ((unsigned int )tmp == (unsigned int )((void *)0)) {
      cli_dbgmsg("RAR: Can\'t generate temporary file.\n");
      pthread_mutex_unlock(& cli_scanrar_mutex);
      cli_scanrar_inuse = 0;
      return (-1);
    }
    fd = fileno(tmp);
    tmp___75 = urarlib_get((void *)(& rar_data_ptr), & rar_data_size, rarlist->item.Name,
                           desc, (char *)"clam");
    if (tmp___75) {
      cli_dbgmsg("RAR: Extracted: %s, size: %lu\n", rarlist->item.Name, rar_data_size);
      tmp___71 = fwrite((void const   * __restrict  )rar_data_ptr, 1U, (unsigned int )rar_data_size,
                        (FILE * __restrict  )tmp);
      if ((unsigned long )tmp___71 != rar_data_size) {
        cli_dbgmsg("RAR: Can\'t write to file.\n");
        fclose(tmp);
        tmp = (FILE *)((void *)0);
        ret = 100;
        if (rar_data_ptr) {
          free((void *)rar_data_ptr);
          rar_data_ptr = (char *)((void *)0);
        }
        break;
      }
      if (rar_data_ptr) {
        free((void *)rar_data_ptr);
        rar_data_ptr = (char *)((void *)0);
      }
      tmp___74 = fflush(tmp);
      if (tmp___74 != 0) {
        tmp___72 = __errno_location();
        tmp___73 = strerror((*tmp___72));
        cli_dbgmsg("RAR: fflush() failed: %s\n", tmp___73);
        fclose(tmp);
        urarlib_freelist(rarlist_head);
        pthread_mutex_unlock(& cli_scanrar_mutex);
        cli_scanrar_inuse = 0;
        return (-2);
      }
      lseek(fd, 0L, 0);
      ret = cli_magic_scandesc(fd, virname, scanned, root, limits, options, arec,
                               mrec);
      if (ret == 1) {
        cli_dbgmsg("RAR: Infected with %s\n", (*virname));
        fclose(tmp);
        urarlib_freelist(rarlist);
        pthread_mutex_unlock(& cli_scanrar_mutex);
        cli_scanrar_inuse = 0;
        return (ret);
      }
    } else {
      cli_dbgmsg("RAR: Can\'t decompress file %s\n", rarlist->item.Name);
      fclose(tmp);
      tmp = (FILE *)((void *)0);
      ret = 100;
      break;
    }
    fclose(tmp);
    tmp = (FILE *)((void *)0);
    rarlist = rarlist->next;
  }
  urarlib_freelist(rarlist_head);
  pthread_mutex_unlock(& cli_scanrar_mutex);
  cli_scanrar_inuse = 0;
  _pthread_cleanup_pop(& _buffer, 0);
  cli_dbgmsg("RAR: Exit code: %d\n", ret);
  return (ret);
}
}
static int cli_scanzip(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                       struct cl_limits  const  *limits , unsigned int options , unsigned int arec ,
                       unsigned int mrec ) 
{ ZZIP_DIR *zdir ;
  ZZIP_DIRENT zdirent ;
  ZZIP_FILE *zfp ;
  FILE *tmp ;
  char *buff ;
  int fd ;
  int bytes ;
  int ret ;
  unsigned long size ;
  unsigned int files ;
  unsigned int encrypted ;
  struct stat source ;
  struct cli_meta_node *mdata ;
  zzip_error_t err ;
  int tmp___0 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___41 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___60 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  size_t tmp___75 ;
  size_t tmp___76 ;
  int *tmp___77 ;
  char *tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;

  {
  tmp = (FILE *)((void *)0);
  ret = 0;
  size = 0UL;
  files = 0U;
  cli_dbgmsg("in scanzip()\n");
  tmp___0 = dup(desc);
  zdir = zzip_dir_fdopen(tmp___0, & err);
  if ((unsigned int )zdir == (unsigned int )((void *)0)) {
    cli_dbgmsg("Zip: Not supported file format ?.\n");
    cli_dbgmsg("Zip: zzip_dir_fdopen() return code: %d\n", err);
    return (0);
  }
  fstat__extinline(desc, & source);
  buff = (char *)cli_malloc(8192U);
  if (! buff) {
    cli_dbgmsg("Zip: unable to malloc(%d)\n", 8192);
    zzip_dir_close(zdir);
    return (-3);
  }
  while (1) {
    tmp___80 = zzip_dir_read(zdir, & zdirent);
    if (! tmp___80) {
      break;
    }
    files ++;
    if (! zdirent.d_name) {
      tmp___2 = strlen((char const   *)zdirent.d_name);
      cli_dbgmsg("Zip: strlen(zdirent.d_name) == %d\n", tmp___2);
      (*virname) = "Suspect.Zip";
      ret = 1;
      break;
    } else {
      tmp___3 = strlen((char const   *)zdirent.d_name);
      if (! tmp___3) {
        tmp___2 = strlen((char const   *)zdirent.d_name);
        cli_dbgmsg("Zip: strlen(zdirent.d_name) == %d\n", tmp___2);
        (*virname) = "Suspect.Zip";
        ret = 1;
        break;
      }
    }
    encrypted = (unsigned int )((int )zdirent.d_flags & 1);
    if (limits) {
      tmp___4 = limits->maxratio;
    } else {
      tmp___4 = 0U;
    }
    if (zdirent.d_csize) {
      tmp___5 = zdirent.st_size / zdirent.d_csize;
    } else {
      tmp___5 = 0;
    }
    cli_dbgmsg("Zip: %s, crc32: 0x%x, encrypted: %d, compressed: %u, normal: %u, method: %d, ratio: %d (max: %d)\n",
               zdirent.d_name, zdirent.d_crc32, encrypted, zdirent.d_csize, zdirent.st_size,
               zdirent.d_compr, tmp___5, tmp___4);
    if (! zdirent.st_size) {
      if (zdirent.d_crc32) {
        cli_dbgmsg("Zip: Broken file or modified information in local header part of archive\n");
        (*virname) = "Exploit.Zip.ModifiedHeaders";
        ret = 1;
        break;
      }
      continue;
    }
    mdata = root->zip_mlist;
    if (mdata) {
      while (1) {
        if (mdata->encrypted != encrypted) {
          goto __Cont;
        }
        if (mdata->crc32) {
          if (mdata->crc32 != (unsigned int )zdirent.d_crc32) {
            goto __Cont;
          }
        }
        if (mdata->csize > 0) {
          if (mdata->csize != zdirent.d_csize) {
            goto __Cont;
          }
        }
        if (mdata->size >= 0) {
          if (mdata->size != zdirent.st_size) {
            goto __Cont;
          }
        }
        if (mdata->method >= 0) {
          if ((unsigned int )mdata->method != (unsigned int )zdirent.d_compr) {
            goto __Cont;
          }
        }
        if (mdata->fileno) {
          if (mdata->fileno != files) {
            goto __Cont;
          }
        }
        if (mdata->maxdepth) {
          if (arec > mdata->maxdepth) {
            goto __Cont;
          }
        }
        if (mdata->filename) {
          tmp___72 = __builtin_constant_p((int )zdirent.d_name);
          if (tmp___72) {
            tmp___73 = __builtin_constant_p((int )mdata->filename);
            if (tmp___73) {
              __s1_len = strlen((char const   *)zdirent.d_name);
              __s2_len = strlen((char const   *)mdata->filename);
              if (! ((unsigned int )((void const   *)(zdirent.d_name + 1)) - (unsigned int )((void const   *)zdirent.d_name) ==
                     1U)) {
                goto _L___16;
              } else {
                if (__s1_len >= 4U) {
                  _L___16: 
                  if (! ((unsigned int )((void const   *)(mdata->filename + 1)) -
                         (unsigned int )((void const   *)mdata->filename) == 1U)) {
                    tmp___74 = 1;
                  } else {
                    if (__s2_len >= 4U) {
                      tmp___74 = 1;
                    } else {
                      tmp___74 = 0;
                    }
                  }
                } else {
                  tmp___74 = 0;
                }
              }
              if (tmp___74) {
                tmp___41 = __builtin_strcmp(zdirent.d_name, mdata->filename);
              } else {
                goto _L___18;
              }
            } else {
              goto _L___18;
            }
          } else {
            _L___18: 
            tmp___71 = __builtin_constant_p((int )zdirent.d_name);
            if (tmp___71) {
              if ((unsigned int )((void const   *)(zdirent.d_name + 1)) - (unsigned int )((void const   *)zdirent.d_name) ==
                  1U) {
                __s1_len = strlen((char const   *)zdirent.d_name);
                if (__s1_len < 4U) {
                  tmp___60 = __builtin_constant_p((int )mdata->filename);
                  if (tmp___60) {
                    if ((unsigned int )((void const   *)(mdata->filename + 1)) - (unsigned int )((void const   *)mdata->filename) ==
                        1U) {
                      tmp___41 = __builtin_strcmp(zdirent.d_name, mdata->filename);
                    } else {
                      goto _L___11;
                    }
                  } else {
                    _L___11: 
                    __s2___6 = (unsigned char const   *)((char const   *)mdata->filename);
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)zdirent.d_name) +
                                                            0)) - (int const   )(*(__s2___6 +
                                                                                   0)));
                    if (__s1_len > 0U) {
                      if (__result___18 == 0) {
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)zdirent.d_name) +
                                                                1)) - (int const   )(*(__s2___6 +
                                                                                       1)));
                        if (__s1_len > 1U) {
                          if (__result___18 == 0) {
                            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)zdirent.d_name) +
                                                                    2)) - (int const   )(*(__s2___6 +
                                                                                           2)));
                            if (__s1_len > 2U) {
                              if (__result___18 == 0) {
                                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)zdirent.d_name) +
                                                                        3)) - (int const   )(*(__s2___6 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___41 = __result___18;
                  }
                } else {
                  goto _L___15;
                }
              } else {
                goto _L___15;
              }
            } else {
              _L___15: 
              tmp___70 = __builtin_constant_p((int )mdata->filename);
              if (tmp___70) {
                if ((unsigned int )((void const   *)(mdata->filename + 1)) - (unsigned int )((void const   *)mdata->filename) ==
                    1U) {
                  __s2_len = strlen((char const   *)mdata->filename);
                  if (__s2_len < 4U) {
                    tmp___69 = __builtin_constant_p((int )zdirent.d_name);
                    if (tmp___69) {
                      if ((unsigned int )((void const   *)(zdirent.d_name + 1)) -
                          (unsigned int )((void const   *)zdirent.d_name) == 1U) {
                        tmp___41 = __builtin_strcmp(zdirent.d_name, mdata->filename);
                      } else {
                        goto _L___13;
                      }
                    } else {
                      _L___13: 
                      __s1___14 = (unsigned char const   *)((char const   *)zdirent.d_name);
                      __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)mdata->filename) +
                                                                                                 0)));
                      if (__s2_len > 0U) {
                        if (__result___22 == 0) {
                          __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                                 (int const   )(*((unsigned char const   *)((char const   *)mdata->filename) +
                                                                  1)));
                          if (__s2_len > 1U) {
                            if (__result___22 == 0) {
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      2)) - (int const   )(*((unsigned char const   *)((char const   *)mdata->filename) +
                                                                                             2)));
                              if (__s2_len > 2U) {
                                if (__result___22 == 0) {
                                  __result___22 = (int )((int const   )(*(__s1___14 +
                                                                          3)) - (int const   )(*((unsigned char const   *)((char const   *)mdata->filename) +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___41 = __result___22;
                    }
                  } else {
                    tmp___41 = __builtin_strcmp(zdirent.d_name, mdata->filename);
                  }
                } else {
                  tmp___41 = __builtin_strcmp(zdirent.d_name, mdata->filename);
                }
              } else {
                tmp___41 = __builtin_strcmp(zdirent.d_name, mdata->filename);
              }
            }
          }
          if (tmp___41) {
            goto __Cont;
          }
        }
        break;
        __Cont: 
        mdata = mdata->next;
        if (! mdata) {
          break;
        }
      }
    }
    if (mdata) {
      (*virname) = (char const   *)mdata->virname;
      ret = 1;
      break;
    }
    tmp___75 = strlen((char const   *)zdirent.d_name);
    if ((int )(*(zdirent.d_name + (tmp___75 - 1U))) == 47) {
      cli_dbgmsg("Zip: Directory entry with st_size != 0\n");
      continue;
    }
    if (zdirent.d_csize <= 0) {
      cli_dbgmsg("Zip: Malformed archive detected.\n");
      (*virname) = "Suspect.Zip";
      ret = 1;
      break;
    } else {
      if (zdirent.st_size < 0) {
        cli_dbgmsg("Zip: Malformed archive detected.\n");
        (*virname) = "Suspect.Zip";
        ret = 1;
        break;
      }
    }
    if (limits) {
      if (limits->maxratio > 0U) {
        if ((unsigned int )zdirent.st_size / (unsigned int )zdirent.d_csize >= limits->maxratio) {
          (*virname) = "Oversized.Zip";
          ret = 1;
          break;
        }
      }
    }
    if (options & 16U) {
      if (encrypted) {
        cli_dbgmsg("Zip: Encrypted files found in archive.\n");
        lseek(desc, 0L, 0);
        ret = cli_scandesc(desc, virname, scanned, root, (short)0, (unsigned short)0);
        if (ret < 0) {
          break;
        } else {
          if (ret != 1) {
            (*virname) = "Encrypted.Zip";
            ret = 1;
          }
        }
        break;
      }
    }
    if (limits) {
      if (limits->maxfilesize) {
        if ((unsigned long )((unsigned int )zdirent.st_size) > limits->maxfilesize) {
          cli_dbgmsg("Zip: %s: Size exceeded (%d, max: %ld)\n", zdirent.d_name, zdirent.st_size,
                     limits->maxfilesize);
          if (options & 512U) {
            (*virname) = "Zip.ExceededFileSize";
            ret = 1;
            break;
          }
          continue;
        }
      }
      if (limits->maxfiles) {
        if (files > limits->maxfiles) {
          cli_dbgmsg("Zip: Files limit reached (max: %d)\n", limits->maxfiles);
          if (options & 512U) {
            (*virname) = "Zip.ExceededFilesLimit";
            ret = 1;
            break;
          }
          break;
        }
      }
    }
    zfp = zzip_file_open(zdir, (zzip_char_t *)zdirent.d_name, 0);
    if ((unsigned int )zfp == (unsigned int )((void *)0)) {
      cli_dbgmsg("Zip: Can\'t open file %s\n", zdirent.d_name);
      ret = 101;
      break;
    }
    tmp = tmpfile();
    if ((unsigned int )tmp == (unsigned int )((void *)0)) {
      cli_dbgmsg("Zip: Can\'t generate tmpfile().\n");
      zzip_file_close(zfp);
      ret = -1;
      break;
    }
    size = 0UL;
    while (1) {
      bytes = zzip_file_read(zfp, buff, 8192U);
      if (! (bytes > 0)) {
        break;
      }
      size += (unsigned long )bytes;
      tmp___76 = fwrite((void const   * __restrict  )buff, 1U, (unsigned int )bytes,
                        (FILE * __restrict  )tmp);
      if (tmp___76 != (unsigned int )bytes) {
        cli_dbgmsg("Zip: Can\'t write to file.\n");
        zzip_file_close(zfp);
        zzip_dir_close(zdir);
        fclose(tmp);
        free((void *)buff);
        return (-12);
      }
    }
    zzip_file_close(zfp);
    if (! encrypted) {
      if (size != (unsigned long )zdirent.st_size) {
        cli_dbgmsg("Zip: Incorrectly decompressed (%d != %d)\n", size, zdirent.st_size);
        ret = 101;
        break;
      }
    }
    tmp___79 = fflush(tmp);
    if (tmp___79 != 0) {
      tmp___77 = __errno_location();
      tmp___78 = strerror((*tmp___77));
      cli_dbgmsg("Zip: fflush() failed: %s\n", tmp___78);
      ret = -2;
      break;
    }
    fd = fileno(tmp);
    lseek(fd, 0L, 0);
    ret = cli_magic_scandesc(fd, virname, scanned, root, limits, options, arec, mrec);
    if (ret == 1) {
      cli_dbgmsg("Zip: Infected with %s\n", (*virname));
      ret = 1;
      break;
    } else {
      if (ret == 102) {
        cli_dbgmsg("Zip: Malformed Zip file, scanning stopped.\n");
        (*virname) = "Suspect.Zip";
        ret = 1;
        break;
      }
    }
    if (tmp) {
      fclose(tmp);
      tmp = (FILE *)((void *)0);
    }
  }
  zzip_dir_close(zdir);
  if (tmp) {
    fclose(tmp);
    tmp = (FILE *)((void *)0);
  }
  free((void *)buff);
  return (ret);
}
}
static int cli_scangzip(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                        struct cl_limits  const  *limits , unsigned int options ,
                        unsigned int arec , unsigned int mrec ) 
{ int fd ;
  int bytes ;
  int ret ;
  unsigned long size ;
  char *buff ;
  FILE *tmp ;
  gzFile gd ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  ret = 0;
  size = 0UL;
  tmp = (FILE *)((void *)0);
  cli_dbgmsg("in cli_scangzip()\n");
  tmp___0 = dup(desc);
  gd = gzdopen(tmp___0, "rb");
  if ((unsigned int )gd == (unsigned int )((void *)0)) {
    cli_dbgmsg("GZip: Can\'t open descriptor %d\n", desc);
    return (103);
  }
  tmp = tmpfile();
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
    cli_dbgmsg("GZip: Can\'t generate temporary file.\n");
    gzclose(gd);
    return (-1);
  }
  fd = fileno(tmp);
  buff = (char *)cli_malloc(8192U);
  if (! buff) {
    cli_dbgmsg("GZip: Unable to malloc %d bytes.\n", 8192);
    gzclose(gd);
    return (-3);
  }
  while (1) {
    bytes = gzread(gd, (void *)buff, 8192U);
    if (! (bytes > 0)) {
      break;
    }
    size += (unsigned long )bytes;
    if (limits) {
      if (limits->maxfilesize) {
        if (size + 8192UL > limits->maxfilesize) {
          cli_dbgmsg("GZip: Size exceeded (stopped at %ld, max: %ld)\n", size, limits->maxfilesize);
          if (options & 512U) {
            (*virname) = "GZip.ExceededFileSize";
            ret = 1;
          }
          break;
        }
      }
    }
    tmp___2 = cli_writen(fd, (void *)buff, (unsigned int )bytes);
    if (tmp___2 != bytes) {
      cli_dbgmsg("GZip: Can\'t write to file.\n");
      fclose(tmp);
      gzclose(gd);
      free((void *)buff);
      return (103);
    }
  }
  free((void *)buff);
  gzclose(gd);
  if (ret == 1) {
    fclose(tmp);
    return (ret);
  }
  tmp___3 = fsync(fd);
  if (tmp___3 == -1) {
    cli_dbgmsg("GZip: Can\'t synchronise descriptor %d\n", fd);
    fclose(tmp);
    return (-2);
  }
  lseek(fd, 0L, 0);
  ret = cli_magic_scandesc(fd, virname, scanned, root, limits, options, arec, mrec);
  if (ret == 1) {
    cli_dbgmsg("GZip: Infected with %s\n", (*virname));
    fclose(tmp);
    return (1);
  }
  fclose(tmp);
  return (ret);
}
}
static int cli_scanbzip(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                        struct cl_limits  const  *limits , unsigned int options ,
                        unsigned int arec , unsigned int mrec ) 
{ int fd ;
  int bytes ;
  int ret ;
  int bzerror ;
  short memlim ;
  unsigned long size ;
  char *buff ;
  FILE *fs ;
  FILE *tmp ;
  BZFILE *bfd ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  ret = 0;
  bzerror = 0;
  memlim = (short)0;
  size = 0UL;
  tmp = (FILE *)((void *)0);
  tmp___0 = dup(desc);
  fs = fdopen(tmp___0, "rb");
  if ((unsigned int )fs == (unsigned int )((void *)0)) {
    cli_dbgmsg("Bzip: Can\'t open descriptor %d.\n", desc);
    return (104);
  }
  if (limits) {
    if (limits->archivememlim) {
      memlim = (short)1;
    }
  }
  bfd = BZ2_bzReadOpen(& bzerror, fs, 0, (int )memlim, (void *)0, 0);
  if ((unsigned int )bfd == (unsigned int )((void *)0)) {
    cli_dbgmsg("Bzip: Can\'t initialize bzip2 library (descriptor: %d).\n", desc);
    fclose(fs);
    return (104);
  }
  tmp = tmpfile();
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
    cli_dbgmsg("Bzip: Can\'t generate temporary file.\n");
    BZ2_bzReadClose(& bzerror, bfd);
    fclose(fs);
    return (-1);
  }
  fd = fileno(tmp);
  buff = (char *)malloc(8192U);
  if (! buff) {
    cli_dbgmsg("Bzip: Unable to malloc %d bytes.\n", 8192);
    fclose(tmp);
    fclose(fs);
    BZ2_bzReadClose(& bzerror, bfd);
    return (-3);
  }
  while (1) {
    bytes = BZ2_bzRead(& bzerror, bfd, (void *)buff, 8192);
    if (! (bytes > 0)) {
      break;
    }
    size += (unsigned long )bytes;
    if (limits) {
      if (limits->maxfilesize) {
        if (size + 8192UL > limits->maxfilesize) {
          cli_dbgmsg("Bzip: Size exceeded (stopped at %ld, max: %ld)\n", size, limits->maxfilesize);
          if (options & 512U) {
            (*virname) = "BZip.ExceededFileSize";
            ret = 1;
          }
          break;
        }
      }
    }
    tmp___2 = cli_writen(fd, (void *)buff, (unsigned int )bytes);
    if (tmp___2 != bytes) {
      cli_dbgmsg("Bzip: Can\'t write to file.\n");
      BZ2_bzReadClose(& bzerror, bfd);
      fclose(tmp);
      free((void *)buff);
      fclose(fs);
      return (103);
    }
  }
  free((void *)buff);
  BZ2_bzReadClose(& bzerror, bfd);
  if (ret == 1) {
    fclose(tmp);
    fclose(fs);
    return (ret);
  }
  tmp___3 = fsync(fd);
  if (tmp___3 == -1) {
    cli_dbgmsg("Bzip: Synchronisation failed for descriptor %d\n", fd);
    fclose(tmp);
    fclose(fs);
    return (-2);
  }
  lseek(fd, 0L, 0);
  ret = cli_magic_scandesc(fd, virname, scanned, root, limits, options, arec, mrec);
  if (ret == 1) {
    cli_dbgmsg("Bzip: Infected with %s\n", (*virname));
  }
  fclose(tmp);
  fclose(fs);
  return (ret);
}
}
static int cli_scanszdd(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                        struct cl_limits  const  *limits , unsigned int options ,
                        unsigned int arec , unsigned int mrec ) 
{ int fd ;
  int ret ;
  FILE *tmp ;
  FILE *in ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  ret = 0;
  tmp = (FILE *)((void *)0);
  cli_dbgmsg("in cli_scanmscomp()\n");
  tmp___0 = dup(desc);
  in = fdopen(tmp___0, "rb");
  if ((unsigned int )in == (unsigned int )((void *)0)) {
    cli_dbgmsg("SZDD: Can\'t open descriptor %d\n", desc);
    return (106);
  }
  tmp = tmpfile();
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
    cli_dbgmsg("SZDD: Can\'t generate temporary file.\n");
    fclose(in);
    return (-1);
  }
  tmp___1 = cli_msexpand(in, tmp);
  if (tmp___1 == -1) {
    cli_dbgmsg("SZDD: msexpand failed.\n");
    return (106);
  }
  fclose(in);
  tmp___2 = fflush(tmp);
  if (tmp___2) {
    cli_dbgmsg("SZDD: fflush() failed.\n");
    fclose(tmp);
    return (-2);
  }
  fd = fileno(tmp);
  lseek(fd, 0L, 0);
  ret = cli_magic_scandesc(fd, virname, scanned, root, limits, options, arec, mrec);
  if (ret == 1) {
    cli_dbgmsg("SZDD: Infected with %s\n", (*virname));
    fclose(tmp);
    return (1);
  }
  fclose(tmp);
  return (ret);
}
}
static int cli_scanmscab(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                         struct cl_limits  const  *limits , unsigned int options ,
                         unsigned int arec , unsigned int mrec ) 
{ struct mscab_decompressor *cabd ;
  struct mscabd_cabinet *base ;
  struct mscabd_cabinet *cab ;
  struct mscabd_file *file ;
  char *tempname ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  cabd = (struct mscab_decompressor *)((void *)0);
  ret = 0;
  cli_dbgmsg("in cli_scanmscab()\n");
  cabd = mspack_create_cab_decompressor(0);
  if ((unsigned int )cabd == (unsigned int )((void *)0)) {
    cli_dbgmsg("MSCAB: Can\'t create libmspack CAB decompressor\n");
    return (107);
  }
  tmp = dup(desc);
  base = ((*(cabd->dsearch)))(cabd, tmp);
  if ((unsigned int )base == (unsigned int )((void *)0)) {
    cli_dbgmsg("MSCAB: I/O error or no valid cabinets found\n");
    mspack_destroy_cab_decompressor(cabd);
    return (107);
  }
  cab = base;
  while (cab) {
    file = cab->files;
    while (file) {
      if (limits) {
        if (limits->maxfilesize) {
          if (file->length > (unsigned int )limits->maxfilesize) {
            cli_dbgmsg("MSCAB: %s: Size exceeded (%u, max: %lu)\n", file->filename,
                       file->length, limits->maxfilesize);
            if (options & 512U) {
              (*virname) = "MSCAB.ExceededFileSize";
              ((*(cabd->close)))(cabd, base);
              mspack_destroy_cab_decompressor(cabd);
              return (1);
            }
            goto __Cont;
          }
        }
      }
      tempname = cli_gentemp((char const   *)((void *)0));
      cli_dbgmsg("MSCAB: Extracting data to %s\n", tempname);
      tmp___1 = ((*(cabd->extract)))(cabd, file, tempname);
      if (tmp___1) {
        tmp___0 = ((*(cabd->last_error)))(cabd);
        cli_dbgmsg("MSCAB: libmscab error code: %d\n", tmp___0);
      } else {
        ret = cli_scanfile((char const   *)tempname, virname, (unsigned long *)scanned,
                           root, limits, options, arec, mrec);
      }
      if (! cli_leavetemps_flag) {
        unlink((char const   *)tempname);
      }
      free((void *)tempname);
      if (ret == 1) {
        break;
      }
      __Cont: 
      file = file->next;
    }
    if (ret == 1) {
      break;
    }
    cab = cab->next;
  }
  ((*(cabd->close)))(cabd, base);
  mspack_destroy_cab_decompressor(cabd);
  return (ret);
}
}
static int cli_scandir(char const   *dirname , char const   **virname , long *scanned ,
                       struct cl_node  const  *root , struct cl_limits  const  *limits ,
                       unsigned int options , unsigned int arec , unsigned int mrec ) 
{ DIR *dd ;
  struct dirent *dent ;
  struct stat statbuf ;
  char *fname ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___39 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___58 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___108 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___127 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;

  {
  dd = opendir(dirname);
  if ((unsigned int )dd != (unsigned int )((void *)0)) {
    while (1) {
      dent = readdir(dd);
      if (! dent) {
        break;
      }
      if (dent->d_ino) {
        tmp___70 = __builtin_constant_p((int )(dent->d_name));
        if (tmp___70) {
          tmp___71 = __builtin_constant_p((int )".");
          if (tmp___71) {
            __s1_len = strlen((char const   *)(dent->d_name));
            __s2_len = strlen(".");
            if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                   1U)) {
              goto _L___17;
            } else {
              if (__s1_len >= 4U) {
                _L___17: 
                if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                       1U)) {
                  tmp___72 = 1;
                } else {
                  if (__s2_len >= 4U) {
                    tmp___72 = 1;
                  } else {
                    tmp___72 = 0;
                  }
                }
              } else {
                tmp___72 = 0;
              }
            }
            if (tmp___72) {
              tmp___39 = __builtin_strcmp(dent->d_name, ".");
            } else {
              goto _L___19;
            }
          } else {
            goto _L___19;
          }
        } else {
          _L___19: 
          tmp___69 = __builtin_constant_p((int )(dent->d_name));
          if (tmp___69) {
            if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                1U) {
              __s1_len = strlen((char const   *)(dent->d_name));
              if (__s1_len < 4U) {
                tmp___58 = __builtin_constant_p((int )".");
                if (tmp___58) {
                  if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                      1U) {
                    tmp___39 = __builtin_strcmp(dent->d_name, ".");
                  } else {
                    goto _L___12;
                  }
                } else {
                  _L___12: 
                  __s2___6 = (unsigned char const   *)".";
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
                  if (__s1_len > 0U) {
                    if (__result___18 == 0) {
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
                      if (__s1_len > 1U) {
                        if (__result___18 == 0) {
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
                          if (__s1_len > 2U) {
                            if (__result___18 == 0) {
                              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___39 = __result___18;
                }
              } else {
                goto _L___16;
              }
            } else {
              goto _L___16;
            }
          } else {
            _L___16: 
            tmp___68 = __builtin_constant_p((int )".");
            if (tmp___68) {
              if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                  1U) {
                __s2_len = strlen(".");
                if (__s2_len < 4U) {
                  tmp___67 = __builtin_constant_p((int )(dent->d_name));
                  if (tmp___67) {
                    if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                        1U) {
                      tmp___39 = __builtin_strcmp(dent->d_name, ".");
                    } else {
                      goto _L___14;
                    }
                  } else {
                    _L___14: 
                    __s1___14 = (unsigned char const   *)((char const   *)(dent->d_name));
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"." +
                                                                                               0)));
                    if (__s2_len > 0U) {
                      if (__result___22 == 0) {
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)"." +
                                                                1)));
                        if (__s2_len > 1U) {
                          if (__result___22 == 0) {
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)"." +
                                                                    2)));
                            if (__s2_len > 2U) {
                              if (__result___22 == 0) {
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)"." +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___39 = __result___22;
                  }
                } else {
                  tmp___39 = __builtin_strcmp(dent->d_name, ".");
                }
              } else {
                tmp___39 = __builtin_strcmp(dent->d_name, ".");
              }
            } else {
              tmp___39 = __builtin_strcmp(dent->d_name, ".");
            }
          }
        }
        if (tmp___39) {
          tmp___139 = __builtin_constant_p((int )(dent->d_name));
          if (tmp___139) {
            tmp___140 = __builtin_constant_p((int )"..");
            if (tmp___140) {
              __s1_len___0 = strlen((char const   *)(dent->d_name));
              __s2_len___0 = strlen("..");
              if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                     1U)) {
                goto _L___37;
              } else {
                if (__s1_len___0 >= 4U) {
                  _L___37: 
                  if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                         1U)) {
                    tmp___141 = 1;
                  } else {
                    if (__s2_len___0 >= 4U) {
                      tmp___141 = 1;
                    } else {
                      tmp___141 = 0;
                    }
                  }
                } else {
                  tmp___141 = 0;
                }
              }
              if (tmp___141) {
                tmp___108 = __builtin_strcmp(dent->d_name, "..");
              } else {
                goto _L___39;
              }
            } else {
              goto _L___39;
            }
          } else {
            _L___39: 
            tmp___138 = __builtin_constant_p((int )(dent->d_name));
            if (tmp___138) {
              if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                  1U) {
                __s1_len___0 = strlen((char const   *)(dent->d_name));
                if (__s1_len___0 < 4U) {
                  tmp___127 = __builtin_constant_p((int )"..");
                  if (tmp___127) {
                    if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                        1U) {
                      tmp___108 = __builtin_strcmp(dent->d_name, "..");
                    } else {
                      goto _L___32;
                    }
                  } else {
                    _L___32: 
                    __s2___14 = (unsigned char const   *)"..";
                    __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                            0)) - (int const   )(*(__s2___14 +
                                                                                   0)));
                    if (__s1_len___0 > 0U) {
                      if (__result___42 == 0) {
                        __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                1)) - (int const   )(*(__s2___14 +
                                                                                       1)));
                        if (__s1_len___0 > 1U) {
                          if (__result___42 == 0) {
                            __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                    2)) - (int const   )(*(__s2___14 +
                                                                                           2)));
                            if (__s1_len___0 > 2U) {
                              if (__result___42 == 0) {
                                __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                        3)) - (int const   )(*(__s2___14 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___108 = __result___42;
                  }
                } else {
                  goto _L___36;
                }
              } else {
                goto _L___36;
              }
            } else {
              _L___36: 
              tmp___137 = __builtin_constant_p((int )"..");
              if (tmp___137) {
                if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                    1U) {
                  __s2_len___0 = strlen("..");
                  if (__s2_len___0 < 4U) {
                    tmp___136 = __builtin_constant_p((int )(dent->d_name));
                    if (tmp___136) {
                      if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                          1U) {
                        tmp___108 = __builtin_strcmp(dent->d_name, "..");
                      } else {
                        goto _L___34;
                      }
                    } else {
                      _L___34: 
                      __s1___30 = (unsigned char const   *)((char const   *)(dent->d_name));
                      __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)".." +
                                                                                                 0)));
                      if (__s2_len___0 > 0U) {
                        if (__result___46 == 0) {
                          __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                 (int const   )(*((unsigned char const   *)".." +
                                                                  1)));
                          if (__s2_len___0 > 1U) {
                            if (__result___46 == 0) {
                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                      2)) - (int const   )(*((unsigned char const   *)".." +
                                                                                             2)));
                              if (__s2_len___0 > 2U) {
                                if (__result___46 == 0) {
                                  __result___46 = (int )((int const   )(*(__s1___30 +
                                                                          3)) - (int const   )(*((unsigned char const   *)".." +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___108 = __result___46;
                    }
                  } else {
                    tmp___108 = __builtin_strcmp(dent->d_name, "..");
                  }
                } else {
                  tmp___108 = __builtin_strcmp(dent->d_name, "..");
                }
              } else {
                tmp___108 = __builtin_strcmp(dent->d_name, "..");
              }
            }
          }
          if (tmp___108) {
            tmp = strlen(dirname);
            tmp___0 = strlen((char const   *)(dent->d_name));
            fname = (char *)cli_calloc((tmp + tmp___0) + 2U, sizeof(char ));
            sprintf((char * __restrict  )fname, (char const   * __restrict  )"%s/%s",
                    dirname, dent->d_name);
            tmp___3 = lstat__extinline((char const   *)fname, & statbuf);
            if (tmp___3 != -1) {
              if ((statbuf.st_mode & 61440U) == 16384U) {
                if (! ((statbuf.st_mode & 61440U) == 40960U)) {
                  tmp___1 = cli_scandir((char const   *)fname, virname, scanned, root,
                                        limits, options, arec, mrec);
                  if (tmp___1 == 1) {
                    free((void *)fname);
                    closedir(dd);
                    return (1);
                  }
                } else {
                  goto _L;
                }
              } else {
                _L: 
                if ((statbuf.st_mode & 61440U) == 32768U) {
                  tmp___2 = cli_scanfile((char const   *)fname, virname, (unsigned long *)scanned,
                                         root, limits, options, arec, mrec);
                  if (tmp___2 == 1) {
                    free((void *)fname);
                    closedir(dd);
                    return (1);
                  }
                }
              }
            }
            free((void *)fname);
          }
        }
      }
    }
  } else {
    cli_dbgmsg("ScanDir: Can\'t open directory %s.\n", dirname);
    return (-4);
  }
  closedir(dd);
  return (0);
}
}
static int cli_vba_scandir(char const   *dirname , char const   **virname , long *scanned ,
                           struct cl_node  const  *root , struct cl_limits  const  *limits ,
                           unsigned int options , unsigned int arec , unsigned int mrec ) 
{ int ret ;
  int i ;
  int fd ;
  int data_len ;
  vba_project_t *vba_project ;
  DIR *dd ;
  struct dirent *dent ;
  struct stat statbuf ;
  char *fname ;
  char *fullname ;
  unsigned char *data ;
  size_t tmp ;
  size_t tmp___0 ;
  unsigned char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  unsigned char *tmp___8 ;
  int tmp___9 ;
  vba_project_t *tmp___10 ;
  vba_project_t *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___51 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___70 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___120 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___139 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  int tmp___151 ;
  int tmp___152 ;
  int tmp___153 ;

  {
  ret = 0;
  cli_dbgmsg("VBADir: %s\n", dirname);
  tmp___11 = vba56_dir_read(dirname);
  vba_project = tmp___11;
  if (vba_project) {
    i = 0;
    while (i < vba_project->count) {
      tmp = strlen((char const   *)vba_project->dir);
      tmp___0 = strlen((char const   *)(*(vba_project->name + i)));
      fullname = (char *)cli_malloc((tmp + tmp___0) + 2U);
      sprintf((char * __restrict  )fullname, (char const   * __restrict  )"%s/%s",
              vba_project->dir, (*(vba_project->name + i)));
      fd = open((char const   *)fullname, 0);
      if (fd == -1) {
        cli_dbgmsg("VBADir: Can\'t open file %s\n", fullname);
        free((void *)fullname);
        ret = -4;
        break;
      }
      free((void *)fullname);
      cli_dbgmsg("VBADir: Decompress VBA project \'%s\'\n", (*(vba_project->name +
                                                               i)));
      tmp___2 = vba_decompress(fd, (*(vba_project->offset + i)), & data_len);
      data = tmp___2;
      close(fd);
      if (! data) {
        cli_dbgmsg("VBADir: WARNING: VBA project \'%s\' decompressed to NULL\n", (*(vba_project->name +
                                                                                    i)));
      } else {
        if (scanned) {
          (*scanned) += (long )(data_len / 4096);
        }
        tmp___3 = cli_scanbuff((char const   *)data, (unsigned int )data_len, virname,
                               root, (unsigned short)511);
        if (tmp___3 == 1) {
          free((void *)data);
          ret = 1;
          break;
        }
        free((void *)data);
      }
      i ++;
    }
    i = 0;
    while (i < vba_project->count) {
      free((void *)(*(vba_project->name + i)));
      i ++;
    }
    free((void *)vba_project->name);
    free((void *)vba_project->dir);
    free((void *)vba_project->offset);
    free((void *)vba_project);
  } else {
    fullname = ppt_vba_read(dirname);
    if (fullname) {
      tmp___4 = cli_scandir((char const   *)fullname, virname, scanned, root, limits,
                            options, arec, mrec);
      if (tmp___4 == 1) {
        ret = 1;
      }
      if (! cli_leavetemps_flag) {
        cli_rmdirs((char const   *)fullname);
      }
      free((void *)fullname);
    } else {
      tmp___10 = wm_dir_read(dirname);
      vba_project = tmp___10;
      if (vba_project) {
        i = 0;
        while (i < vba_project->count) {
          tmp___5 = strlen((char const   *)vba_project->dir);
          tmp___6 = strlen((char const   *)(*(vba_project->name + i)));
          fullname = (char *)cli_malloc((tmp___5 + tmp___6) + 2U);
          sprintf((char * __restrict  )fullname, (char const   * __restrict  )"%s/%s",
                  vba_project->dir, (*(vba_project->name + i)));
          fd = open((char const   *)fullname, 0);
          if (fd == -1) {
            cli_dbgmsg("VBADir: Can\'t open file %s\n", fullname);
            free((void *)fullname);
            ret = -4;
            break;
          }
          free((void *)fullname);
          cli_dbgmsg("VBADir: Decompress WM project \'%s\' macro:%d key:%d\n", (*(vba_project->name +
                                                                                  i)),
                     i, (*(vba_project->key + i)));
          tmp___8 = wm_decrypt_macro(fd, (*(vba_project->offset + i)), (*(vba_project->length +
                                                                          i)), (*(vba_project->key +
                                                                                  i)));
          data = tmp___8;
          close(fd);
          if (! data) {
            cli_dbgmsg("VBADir: WARNING: WM project \'%s\' macro %d decrypted to NULL\n",
                       (*(vba_project->name + i)), i);
          } else {
            if (scanned) {
              (*scanned) = (long )((unsigned long )(*scanned) + (unsigned long )((*(vba_project->length +
                                                                                    i)) /
                                                                                 4096U));
            }
            tmp___9 = cli_scanbuff((char const   *)data, (*(vba_project->length +
                                                            i)), virname, root, (unsigned short)511);
            if (tmp___9 == 1) {
              free((void *)data);
              ret = 1;
              break;
            }
            free((void *)data);
          }
          i ++;
        }
        i = 0;
        while (i < vba_project->count) {
          free((void *)(*(vba_project->name + i)));
          i ++;
        }
        free((void *)vba_project->key);
        free((void *)vba_project->length);
        free((void *)vba_project->offset);
        free((void *)vba_project->name);
        free((void *)vba_project->dir);
        free((void *)vba_project);
      }
    }
  }
  if (ret != 0) {
    return (ret);
  }
  dd = opendir(dirname);
  if ((unsigned int )dd != (unsigned int )((void *)0)) {
    while (1) {
      dent = readdir(dd);
      if (! dent) {
        break;
      }
      if (dent->d_ino) {
        tmp___82 = __builtin_constant_p((int )(dent->d_name));
        if (tmp___82) {
          tmp___83 = __builtin_constant_p((int )".");
          if (tmp___83) {
            __s1_len = strlen((char const   *)(dent->d_name));
            __s2_len = strlen(".");
            if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                   1U)) {
              goto _L___16;
            } else {
              if (__s1_len >= 4U) {
                _L___16: 
                if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                       1U)) {
                  tmp___84 = 1;
                } else {
                  if (__s2_len >= 4U) {
                    tmp___84 = 1;
                  } else {
                    tmp___84 = 0;
                  }
                }
              } else {
                tmp___84 = 0;
              }
            }
            if (tmp___84) {
              tmp___51 = __builtin_strcmp(dent->d_name, ".");
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: 
          tmp___81 = __builtin_constant_p((int )(dent->d_name));
          if (tmp___81) {
            if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                1U) {
              __s1_len = strlen((char const   *)(dent->d_name));
              if (__s1_len < 4U) {
                tmp___70 = __builtin_constant_p((int )".");
                if (tmp___70) {
                  if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                      1U) {
                    tmp___51 = __builtin_strcmp(dent->d_name, ".");
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: 
                  __s2___6 = (unsigned char const   *)".";
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
                  if (__s1_len > 0U) {
                    if (__result___18 == 0) {
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
                      if (__s1_len > 1U) {
                        if (__result___18 == 0) {
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
                          if (__s1_len > 2U) {
                            if (__result___18 == 0) {
                              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___51 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: 
            tmp___80 = __builtin_constant_p((int )".");
            if (tmp___80) {
              if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                  1U) {
                __s2_len = strlen(".");
                if (__s2_len < 4U) {
                  tmp___79 = __builtin_constant_p((int )(dent->d_name));
                  if (tmp___79) {
                    if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                        1U) {
                      tmp___51 = __builtin_strcmp(dent->d_name, ".");
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: 
                    __s1___14 = (unsigned char const   *)((char const   *)(dent->d_name));
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"." +
                                                                                               0)));
                    if (__s2_len > 0U) {
                      if (__result___22 == 0) {
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)"." +
                                                                1)));
                        if (__s2_len > 1U) {
                          if (__result___22 == 0) {
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)"." +
                                                                    2)));
                            if (__s2_len > 2U) {
                              if (__result___22 == 0) {
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)"." +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___51 = __result___22;
                  }
                } else {
                  tmp___51 = __builtin_strcmp(dent->d_name, ".");
                }
              } else {
                tmp___51 = __builtin_strcmp(dent->d_name, ".");
              }
            } else {
              tmp___51 = __builtin_strcmp(dent->d_name, ".");
            }
          }
        }
        if (tmp___51) {
          tmp___151 = __builtin_constant_p((int )(dent->d_name));
          if (tmp___151) {
            tmp___152 = __builtin_constant_p((int )"..");
            if (tmp___152) {
              __s1_len___0 = strlen((char const   *)(dent->d_name));
              __s2_len___0 = strlen("..");
              if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                     1U)) {
                goto _L___36;
              } else {
                if (__s1_len___0 >= 4U) {
                  _L___36: 
                  if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                         1U)) {
                    tmp___153 = 1;
                  } else {
                    if (__s2_len___0 >= 4U) {
                      tmp___153 = 1;
                    } else {
                      tmp___153 = 0;
                    }
                  }
                } else {
                  tmp___153 = 0;
                }
              }
              if (tmp___153) {
                tmp___120 = __builtin_strcmp(dent->d_name, "..");
              } else {
                goto _L___38;
              }
            } else {
              goto _L___38;
            }
          } else {
            _L___38: 
            tmp___150 = __builtin_constant_p((int )(dent->d_name));
            if (tmp___150) {
              if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                  1U) {
                __s1_len___0 = strlen((char const   *)(dent->d_name));
                if (__s1_len___0 < 4U) {
                  tmp___139 = __builtin_constant_p((int )"..");
                  if (tmp___139) {
                    if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                        1U) {
                      tmp___120 = __builtin_strcmp(dent->d_name, "..");
                    } else {
                      goto _L___31;
                    }
                  } else {
                    _L___31: 
                    __s2___14 = (unsigned char const   *)"..";
                    __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                            0)) - (int const   )(*(__s2___14 +
                                                                                   0)));
                    if (__s1_len___0 > 0U) {
                      if (__result___42 == 0) {
                        __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                1)) - (int const   )(*(__s2___14 +
                                                                                       1)));
                        if (__s1_len___0 > 1U) {
                          if (__result___42 == 0) {
                            __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                    2)) - (int const   )(*(__s2___14 +
                                                                                           2)));
                            if (__s1_len___0 > 2U) {
                              if (__result___42 == 0) {
                                __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                        3)) - (int const   )(*(__s2___14 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___120 = __result___42;
                  }
                } else {
                  goto _L___35;
                }
              } else {
                goto _L___35;
              }
            } else {
              _L___35: 
              tmp___149 = __builtin_constant_p((int )"..");
              if (tmp___149) {
                if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                    1U) {
                  __s2_len___0 = strlen("..");
                  if (__s2_len___0 < 4U) {
                    tmp___148 = __builtin_constant_p((int )(dent->d_name));
                    if (tmp___148) {
                      if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                          1U) {
                        tmp___120 = __builtin_strcmp(dent->d_name, "..");
                      } else {
                        goto _L___33;
                      }
                    } else {
                      _L___33: 
                      __s1___30 = (unsigned char const   *)((char const   *)(dent->d_name));
                      __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)".." +
                                                                                                 0)));
                      if (__s2_len___0 > 0U) {
                        if (__result___46 == 0) {
                          __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                 (int const   )(*((unsigned char const   *)".." +
                                                                  1)));
                          if (__s2_len___0 > 1U) {
                            if (__result___46 == 0) {
                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                      2)) - (int const   )(*((unsigned char const   *)".." +
                                                                                             2)));
                              if (__s2_len___0 > 2U) {
                                if (__result___46 == 0) {
                                  __result___46 = (int )((int const   )(*(__s1___30 +
                                                                          3)) - (int const   )(*((unsigned char const   *)".." +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___120 = __result___46;
                    }
                  } else {
                    tmp___120 = __builtin_strcmp(dent->d_name, "..");
                  }
                } else {
                  tmp___120 = __builtin_strcmp(dent->d_name, "..");
                }
              } else {
                tmp___120 = __builtin_strcmp(dent->d_name, "..");
              }
            }
          }
          if (tmp___120) {
            tmp___12 = strlen(dirname);
            tmp___13 = strlen((char const   *)(dent->d_name));
            fname = (char *)cli_calloc((tmp___12 + tmp___13) + 2U, sizeof(char ));
            sprintf((char * __restrict  )fname, (char const   * __restrict  )"%s/%s",
                    dirname, dent->d_name);
            tmp___15 = lstat__extinline((char const   *)fname, & statbuf);
            if (tmp___15 != -1) {
              if ((statbuf.st_mode & 61440U) == 16384U) {
                if (! ((statbuf.st_mode & 61440U) == 40960U)) {
                  tmp___14 = cli_vba_scandir((char const   *)fname, virname, scanned,
                                             root, limits, options, arec, mrec);
                  if (tmp___14 == 1) {
                    ret = 1;
                    free((void *)fname);
                    break;
                  }
                }
              }
            }
            free((void *)fname);
          }
        }
      }
    }
  } else {
    cli_dbgmsg("VBADir: Can\'t open directory %s.\n", dirname);
    return (-4);
  }
  closedir(dd);
  return (ret);
}
}
static int cli_scanhtml(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                        struct cl_limits  const  *limits , unsigned int options ,
                        unsigned int arec , unsigned int mrec ) 
{ char *tempname ;
  char fullname[1024] ;
  int ret ;
  int fd ;
  int tmp ;

  {
  ret = 0;
  cli_dbgmsg("in cli_scanhtml()\n");
  tempname = cli_gentemp((char const   *)((void *)0));
  tmp = mkdir((char const   *)tempname, 448U);
  if (tmp) {
    cli_dbgmsg("ScanHTML -> Can\'t create temporary directory %s\n", tempname);
    free((void *)tempname);
    return (-7);
  }
  html_normalise_fd(desc, (char const   *)tempname, (tag_arguments_t *)((void *)0));
  snprintf((char * __restrict  )(fullname), 1024U, (char const   * __restrict  )"%s/comment.html",
           tempname);
  fd = open((char const   *)(fullname), 0);
  if (fd >= 0) {
    ret = cli_scandesc(fd, virname, scanned, root, (short)0, (unsigned short)519);
    close(fd);
  }
  if (ret < 0) {
    goto _L;
  } else {
    if (ret == 1) {
      _L: 
      if (! cli_leavetemps_flag) {
        cli_rmdirs((char const   *)tempname);
      }
      free((void *)tempname);
      return (ret);
    }
  }
  if (ret == 0) {
    snprintf((char * __restrict  )(fullname), 1024U, (char const   * __restrict  )"%s/nocomment.html",
             tempname);
    fd = open((char const   *)(fullname), 0);
    if (fd >= 0) {
      ret = cli_scandesc(fd, virname, scanned, root, (short)0, (unsigned short)519);
      close(fd);
    }
  }
  if (ret < 0) {
    goto _L___0;
  } else {
    if (ret == 1) {
      _L___0: 
      if (! cli_leavetemps_flag) {
        cli_rmdirs((char const   *)tempname);
      }
      free((void *)tempname);
      return (ret);
    }
  }
  if (ret == 0) {
    snprintf((char * __restrict  )(fullname), 1024U, (char const   * __restrict  )"%s/script.html",
             tempname);
    fd = open((char const   *)(fullname), 0);
    if (fd >= 0) {
      ret = cli_scandesc(fd, virname, scanned, root, (short)0, (unsigned short)519);
      close(fd);
    }
  }
  if (ret < 0) {
    goto _L___1;
  } else {
    if (ret == 1) {
      _L___1: 
      if (! cli_leavetemps_flag) {
        cli_rmdirs((char const   *)tempname);
      }
      free((void *)tempname);
      return (ret);
    }
  }
  if (ret == 0) {
    snprintf((char * __restrict  )(fullname), 1024U, (char const   * __restrict  )"%s/rfc2397",
             tempname);
    ret = cli_scandir((char const   *)(fullname), virname, scanned, root, limits,
                      options, arec, mrec);
  }
  if (! cli_leavetemps_flag) {
    cli_rmdirs((char const   *)tempname);
  }
  free((void *)tempname);
  return (ret);
}
}
static int cli_scanole2(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                        struct cl_limits  const  *limits , unsigned int options ,
                        unsigned int arec , unsigned int mrec ) 
{ char *dir ;
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  ret = 0;
  cli_dbgmsg("in cli_scanole2()\n");
  dir = cli_gentemp((char const   *)((void *)0));
  tmp = mkdir((char const   *)dir, 448U);
  if (tmp) {
    cli_dbgmsg("OLE2: Can\'t create temporary directory %s\n", dir);
    free((void *)dir);
    return (-7);
  }
  ret = cli_ole2_extract(desc, (char const   *)dir, limits);
  if (ret) {
    tmp___0 = cl_strerror(ret);
    cli_dbgmsg("OLE2: %s\n", tmp___0);
    if (! cli_leavetemps_flag) {
      cli_rmdirs((char const   *)dir);
    }
    free((void *)dir);
    return (ret);
  }
  ret = cli_vba_scandir((char const   *)dir, virname, scanned, root, limits, options,
                        arec, mrec);
  if (ret != 1) {
    tmp___1 = cli_scandir((char const   *)dir, virname, scanned, root, limits, options,
                          arec, mrec);
    if (tmp___1 == 1) {
      ret = 1;
    }
  }
  if (! cli_leavetemps_flag) {
    cli_rmdirs((char const   *)dir);
  }
  free((void *)dir);
  return (ret);
}
}
static int cli_scantar(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                       struct cl_limits  const  *limits , unsigned int options , unsigned int arec ,
                       unsigned int mrec , unsigned int posix ) 
{ char *dir ;
  int ret ;
  int tmp ;
  char const   *tmp___0 ;

  {
  ret = 0;
  cli_dbgmsg("in cli_scantar()\n");
  dir = cli_gentemp((char const   *)((void *)0));
  tmp = mkdir((char const   *)dir, 448U);
  if (tmp) {
    cli_errmsg("Tar: Can\'t create temporary directory %s\n", dir);
    free((void *)dir);
    return (-7);
  }
  ret = cli_untar((char const   *)dir, desc, posix);
  if (ret) {
    tmp___0 = cl_strerror(ret);
    cli_dbgmsg("Tar: %s\n", tmp___0);
  } else {
    ret = cli_scandir((char const   *)dir, virname, scanned, root, limits, options,
                      arec, mrec);
  }
  if (! cli_leavetemps_flag) {
    cli_rmdirs((char const   *)dir);
  }
  free((void *)dir);
  return (ret);
}
}
static int cli_scanbinhex(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                          struct cl_limits  const  *limits , unsigned int options ,
                          unsigned int arec , unsigned int mrec ) 
{ char *dir ;
  int ret ;
  int tmp ;
  char const   *tmp___0 ;

  {
  ret = 0;
  cli_dbgmsg("in cli_scanbinhex()\n");
  dir = cli_gentemp((char const   *)((void *)0));
  tmp = mkdir((char const   *)dir, 448U);
  if (tmp) {
    cli_errmsg("Binhex: Can\'t create temporary directory %s\n", dir);
    free((void *)dir);
    return (-7);
  }
  ret = cli_binhex((char const   *)dir, desc);
  if (ret) {
    tmp___0 = cl_strerror(ret);
    cli_dbgmsg("Binhex: %s\n", tmp___0);
  } else {
    ret = cli_scandir((char const   *)dir, virname, scanned, root, limits, options,
                      arec, mrec);
  }
  if (! cli_leavetemps_flag) {
    cli_rmdirs((char const   *)dir);
  }
  free((void *)dir);
  return (ret);
}
}
static int cli_scanmschm(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                         struct cl_limits  const  *limits , unsigned int options ,
                         unsigned int arec , unsigned int mrec ) 
{ char *tempname ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  ret = 0;
  cli_dbgmsg("in cli_scanmschm()\n");
  tempname = cli_gentemp((char const   *)((void *)0));
  tmp = mkdir((char const   *)tempname, 448U);
  if (tmp) {
    cli_dbgmsg("CHM: Can\'t create temporary directory %s\n", tempname);
    free((void *)tempname);
    return (-7);
  }
  tmp___0 = chm_unpack(desc, (char const   *)tempname);
  if (tmp___0) {
    ret = cli_scandir((char const   *)tempname, virname, scanned, root, limits, options,
                      arec, mrec);
  }
  if (! cli_leavetemps_flag) {
    cli_rmdirs((char const   *)tempname);
  }
  free((void *)tempname);
  return (ret);
}
}
static int cli_scanscrenc(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                          struct cl_limits  const  *limits , unsigned int options ,
                          unsigned int arec , unsigned int mrec ) 
{ char *tempname ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  ret = 0;
  cli_dbgmsg("in cli_scanscrenc()\n");
  tempname = cli_gentemp((char const   *)((void *)0));
  tmp = mkdir((char const   *)tempname, 448U);
  if (tmp) {
    cli_dbgmsg("CHM: Can\'t create temporary directory %s\n", tempname);
    free((void *)tempname);
    return (-7);
  }
  tmp___0 = html_screnc_decode(desc, (char const   *)tempname);
  if (tmp___0) {
    ret = cli_scandir((char const   *)tempname, virname, scanned, root, limits, options,
                      arec, mrec);
  }
  if (! cli_leavetemps_flag) {
    cli_rmdirs((char const   *)tempname);
  }
  free((void *)tempname);
  return (ret);
}
}
static int cli_scanriff(int desc , char const   **virname ) 
{ int ret ;
  int tmp ;

  {
  ret = 0;
  tmp = cli_check_riff_exploit(desc);
  if (tmp == 2) {
    ret = 1;
    (*virname) = "Exploit.W32.MS05-002";
  }
  return (ret);
}
}
static int cli_scanjpeg(int desc , char const   **virname ) 
{ int ret ;
  int tmp ;

  {
  ret = 0;
  tmp = cli_check_jpeg_exploit(desc);
  if (tmp == 1) {
    ret = 1;
    (*virname) = "Exploit.W32.MS04-028";
  }
  return (ret);
}
}
int cli_tnef(char const   *dir , int desc ) ;
static int cli_scantnef(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                        struct cl_limits  const  *limits , unsigned int options ,
                        unsigned int arec , unsigned int mrec ) 
{ int ret ;
  char *dir ;
  char *tmp ;
  int tmp___0 ;

  {
  tmp = cli_gentemp((char const   *)((void *)0));
  dir = tmp;
  tmp___0 = mkdir((char const   *)dir, 448U);
  if (tmp___0) {
    cli_dbgmsg("Can\'t create temporary directory for tnef file %s\n", dir);
    free((void *)dir);
    return (-7);
  }
  ret = cli_tnef((char const   *)dir, desc);
  if (ret == 0) {
    ret = cli_scandir((char const   *)dir, virname, scanned, root, limits, options,
                      arec, mrec);
  }
  if (! cli_leavetemps_flag) {
    cli_rmdirs((char const   *)dir);
  }
  free((void *)dir);
  return (ret);
}
}
static int cli_scanmail(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                        struct cl_limits  const  *limits , unsigned int options ,
                        unsigned int arec , unsigned int mrec ) 
{ char *dir ;
  int ret ;
  int tmp ;

  {
  cli_dbgmsg("Starting cli_scanmail(), mrec == %d, arec == %d\n", mrec, arec);
  dir = cli_gentemp((char const   *)((void *)0));
  tmp = mkdir((char const   *)dir, 448U);
  if (tmp) {
    cli_dbgmsg("Mail: Can\'t create temporary directory %s\n", dir);
    free((void *)dir);
    return (-7);
  }
  ret = cli_mbox((char const   *)dir, desc, options);
  if (ret) {
    if (! cli_leavetemps_flag) {
      cli_rmdirs((char const   *)dir);
    }
    free((void *)dir);
    return (ret);
  }
  ret = cli_scandir((char const   *)dir, virname, scanned, root, limits, options,
                    arec, mrec);
  if (! cli_leavetemps_flag) {
    cli_rmdirs((char const   *)dir);
  }
  free((void *)dir);
  return (ret);
}
}
int cli_magic_scandesc(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                       struct cl_limits  const  *limits , unsigned int options , unsigned int arec ,
                       unsigned int mrec ) 
{ int ret ;
  int nret ;
  int bread ;
  cli_file_t type ;
  struct stat sb ;
  int tmp ;
  int tmp___0 ;
  struct stat s ;
  int tmp___1 ;
  int typerec ;
  __off_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
  ret = 0;
  bread = 0;
  tmp = fstat__extinline(desc, & sb);
  if (tmp == -1) {
    cli_errmsg("Can\'s fstat descriptor %d\n", desc);
    return (-12);
  }
  if (sb.st_size <= 5L) {
    cli_dbgmsg("Small data (%d bytes)\n", sb.st_size);
    return (0);
  }
  if (! root) {
    cli_errmsg("CRITICAL: root == NULL\n");
    return (-5);
  }
  if (! options) {
    cli_dbgmsg("Raw mode: No support for special files\n");
    tmp___0 = cli_scandesc(desc, virname, scanned, root, (short)0, (unsigned short)0);
    ret = tmp___0 == 1;
    if (ret) {
      cli_dbgmsg("%s found in descriptor %d\n", (*virname), desc);
    }
    return (ret);
  }
  if (options & 1U) {
    if (limits) {
      if (limits->maxreclevel) {
        if (arec > limits->maxreclevel) {
          cli_dbgmsg("Archive recursion limit exceeded (arec == %d).\n", arec);
          if (options & 512U) {
            (*virname) = "Archive.ExceededRecursionLimit";
            return (1);
          }
          return (0);
        }
      }
    }
  }
  if (options & 2U) {
    if (mrec > 15U) {
      cli_dbgmsg("Mail recursion level exceeded (mrec == %d).\n", mrec);
      return (0);
    }
  }
  lseek(desc, 0L, 0);
  type = cli_filetype2(desc);
  lseek(desc, 0L, 0);
  if ((int )type == 520) {
    mrec ++;
  } else {
    arec ++;
  }
  switch ((int )type) {
  case 509: ;
  if (! (options & 4U)) {
    if (options & 1U) {
      if (! cli_scanrar_inuse) {
        ret = cli_scanrar(desc, virname, scanned, root, limits, options, arec, mrec);
      }
    }
  }
  break;
  case 507: ;
  if (options & 1U) {
    ret = cli_scanzip(desc, virname, scanned, root, limits, options, arec, mrec);
  }
  break;
  case 506: ;
  if (options & 1U) {
    ret = cli_scangzip(desc, virname, scanned, root, limits, options, arec, mrec);
  }
  break;
  case 508: ;
  if (options & 1U) {
    ret = cli_scanbzip(desc, virname, scanned, root, limits, options, arec, mrec);
  }
  break;
  case 510: ;
  if (options & 1U) {
    ret = cli_scanszdd(desc, virname, scanned, root, limits, options, arec, mrec);
  }
  break;
  case 512: ;
  if (options & 1U) {
    ret = cli_scanmscab(desc, virname, scanned, root, limits, options, arec, mrec);
  }
  break;
  case 520: ;
  if (options & 2U) {
    ret = cli_scanmail(desc, virname, scanned, root, limits, options, arec, mrec);
  }
  break;
  case 518: ;
  if (options & 2U) {
    ret = cli_scantnef(desc, virname, scanned, root, limits, options, arec, mrec);
  }
  break;
  case 513: ;
  if (options & 1U) {
    ret = cli_scanmschm(desc, virname, scanned, root, limits, options, arec, mrec);
  }
  break;
  case 511: ;
  if (options & 8U) {
    ret = cli_scanole2(desc, virname, scanned, root, limits, options, arec, mrec);
  }
  break;
  case 504: ;
  if (options & 1U) {
    ret = cli_scantar(desc, virname, scanned, root, limits, options, arec, mrec, 1U);
  }
  break;
  case 505: ;
  if (options & 1U) {
    ret = cli_scantar(desc, virname, scanned, root, limits, options, arec, mrec, 0U);
  }
  break;
  case 517: ;
  if (options & 1U) {
    ret = cli_scanbinhex(desc, virname, scanned, root, limits, options, arec, mrec);
  }
  break;
  case 514: 
  ret = cli_scanscrenc(desc, virname, scanned, root, limits, options, arec, mrec);
  break;
  case 516: 
  ret = cli_scanriff(desc, virname);
  break;
  case 515: 
  ret = cli_scanjpeg(desc, virname);
  break;
  case 503: 
  tmp___1 = fstat__extinline(desc, & s);
  if (tmp___1 == 0) {
    if ((s.st_mode & 61440U) == 32768U) {
      if (s.st_size < 65536L) {
        type = (enum __anonenum_cli_file_t_36 )501;
      }
    }
  }
  case 501: 
  ret = cli_check_mydoom_log(desc, virname);
  break;
  default: ;
  break;
  }
  if ((int )type == 520) {
    mrec --;
  } else {
    arec --;
  }
  if ((int )type != 503) {
    if (ret != 1) {
      if ((int )type == 500) {
        typerec = 1;
      } else {
        typerec = 0;
      }
      tmp___2 = lseek(desc, 0L, 0);
      if (tmp___2 < 0L) {
        cli_errmsg("lseek() failed, trying to continue anyway...\n");
      }
      nret = cli_scandesc(desc, virname, scanned, root, (short )typerec, (unsigned short )type);
      if (nret == 1) {
        cli_dbgmsg("%s found in descriptor %d.\n", (*virname), desc);
        return (1);
      } else {
        if (nret < 0) {
          return (nret);
        } else {
          if (nret >= 500) {
            lseek(desc, 0L, 0);
            if (nret == 520) {
              mrec ++;
            } else {
              arec ++;
            }
            switch (nret) {
            case 519: ;
            if (options & 32U) {
              tmp___3 = cli_scanhtml(desc, virname, scanned, root, limits, options,
                                     arec, mrec);
              if (tmp___3 == 1) {
                return (1);
              }
            }
            break;
            case 520: ;
            if (options & 2U) {
              tmp___4 = cli_scanmail(desc, virname, scanned, root, limits, options,
                                     arec, mrec);
              if (tmp___4 == 1) {
                return (1);
              }
            }
            break;
            }
            if (nret == 520) {
              mrec --;
            } else {
              arec --;
            }
          }
        }
      }
    }
  }
  arec ++;
  lseek(desc, 0L, 0);
  switch ((int )type) {
  case 502: ;
  if (options & 64U) {
    ret = cli_scanpe(desc, virname, scanned, root, limits, options, arec, mrec);
  }
  break;
  default: ;
  break;
  }
  arec --;
  if (ret == -13) {
    tmp___5 = cl_strerror(-13);
    cli_dbgmsg("Descriptor[%d]: %s\n", desc, tmp___5);
    return (0);
  } else {
    return (ret);
  }
}
}
int cl_scandesc(int desc , char const   **virname , unsigned long *scanned , struct cl_node  const  *root ,
                struct cl_limits  const  *limits , unsigned int options ) 
{ int tmp ;

  {
  tmp = cli_magic_scandesc(desc, virname, (long *)scanned, root, limits, options,
                           0U, 0U);
  return (tmp);
}
}
static int cli_scanfile(char const   *filename , char const   **virname , unsigned long *scanned ,
                        struct cl_node  const  *root , struct cl_limits  const  *limits ,
                        unsigned int options , unsigned int arec , unsigned int mrec ) 
{ int fd ;
  int ret ;

  {
  fd = open(filename, 0);
  if (fd == -1) {
    return (-4);
  }
  ret = cli_magic_scandesc(fd, virname, (long *)scanned, root, limits, options, arec,
                           mrec);
  close(fd);
  return (ret);
}
}
int cl_scanfile(char const   *filename , char const   **virname , unsigned long *scanned ,
                struct cl_node  const  *root , struct cl_limits  const  *limits ,
                unsigned int options ) 
{ int fd ;
  int ret ;

  {
  fd = open(filename, 0);
  if (fd == -1) {
    return (-4);
  }
  ret = cl_scandesc(fd, virname, scanned, root, limits, options);
  close(fd);
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-tACYxtrw.i","-g -O2 -fPIC")
cli_file_t cli_filetype(char const   *buf , size_t buflen ) ;
static struct cli_magic_s  const  cli_magic[57]  = 
  {      {0, "MZ", 2U, "DOS/W32 executable/library/driver", (cli_file_t )502}, 
        {0, "Rar!", 4U, "RAR", (cli_file_t )509}, 
        {0, "PK\003\004", 4U, "ZIP", (cli_file_t )507}, 
        {0, "PK00PK\003\004", 8U, "ZIP", (cli_file_t )507}, 
        {0, "\037\213", 2U, "GZip", (cli_file_t )506}, 
        {0, "BZh", 3U, "BZip", (cli_file_t )508}, 
        {0, "SZDD", 4U, "compress.exe\'d", (cli_file_t )510}, 
        {0, "MSCF", 4U, "MS CAB", (cli_file_t )512}, 
        {0, "ITSF", 4U, "MS CHM", (cli_file_t )513}, 
        {0, "#@~^", 4U, "SCRENC", (cli_file_t )514}, 
        {0, "(This file must be converted with BinHex 4.0)", 45U, "BinHex", (cli_file_t )517}, 
        {0,
      "From ", 5U, "MBox", (cli_file_t )520}, 
        {0, "Received: ", 10U, "Raw mail", (cli_file_t )520}, 
        {0, "Return-Path: ", 13U, "Maildir", (cli_file_t )520}, 
        {0, "Return-path: ", 13U, "Maildir", (cli_file_t )520}, 
        {0, "Delivered-To: ", 14U, "Mail", (cli_file_t )520}, 
        {0, "X-UIDL: ", 8U, "Mail", (cli_file_t )520}, 
        {0, "X-Apparently-To: ", 17U, "Mail", (cli_file_t )520}, 
        {0, "X-Envelope-From: ", 17U, "Mail", (cli_file_t )520}, 
        {0, "X-Original-To: ", 15U, "Mail", (cli_file_t )520}, 
        {0, "X-Symantec-", 11U, "Symantec", (cli_file_t )520}, 
        {0, "X-EVS", 5U, "EVS mail", (cli_file_t )520}, 
        {0, "X-Real-To: ", 11U, "Mail", (cli_file_t )520}, 
        {0, "X-Sieve: ", 9U, "Mail", (cli_file_t )520}, 
        {0, ">From ", 6U, "Mail", (cli_file_t )520}, 
        {0, "Date: ", 6U, "Mail", (cli_file_t )520}, 
        {0, "Message-Id: ", 12U, "Mail", (cli_file_t )520}, 
        {0, "Message-ID: ", 12U, "Mail", (cli_file_t )520}, 
        {0, "Envelope-to: ", 13U, "Mail", (cli_file_t )520}, 
        {0, "Delivery-date: ", 15U, "Mail", (cli_file_t )520}, 
        {0, "To: ", 4U, "Mail", (cli_file_t )520}, 
        {0, "Subject: ", 9U, "Mail", (cli_file_t )520}, 
        {0, "For: ", 5U, "Eserv mail", (cli_file_t )520}, 
        {0, "From: ", 6U, "Exim mail", (cli_file_t )520}, 
        {0, "v:\r\nReceived: ", 14U, "VPOP3 Mail (DOS)", (cli_file_t )520}, 
        {0, "v:\nReceived: ", 13U, "VPOP3 Mail (UNIX)", (cli_file_t )520}, 
        {0, "Hi. This is the qmail-send", 26U, "Qmail bounce", (cli_file_t )520}, 
        {0, "x\237>\"", 4U, "TNEF", (cli_file_t )518}, 
        {0, "\320\317\021\340\241\261\032\341", 8U, "OLE2 container", (cli_file_t )511}, 
        {0,
      "GIF", 3U, "GIF", (cli_file_t )515}, 
        {0, "BM", 2U, "BMP", (cli_file_t )515}, 
        {0, "\377\330\377", 3U, "JPEG", (cli_file_t )515}, 
        {6, "JFIF", 4U, "JPEG", (cli_file_t )515}, 
        {6, "Exif", 4U, "JPEG", (cli_file_t )515}, 
        {0, "\211PNG", 4U, "PNG", (cli_file_t )515}, 
        {0, "RIFF", 4U, "RIFF", (cli_file_t )516}, 
        {0, "RIFX", 4U, "RIFX", (cli_file_t )516}, 
        {0, "\000\000\001\263", 4U, "MPEG video stream", (cli_file_t )503}, 
        {0, "\000\000\001\272", 4U, "MPEG sys stream", (cli_file_t )503}, 
        {0, "OggS", 4U, "Ogg Stream", (cli_file_t )503}, 
        {0, "ID3", 3U, "MP3", (cli_file_t )503}, 
        {0, "\377\373\220", 3U, "MP3", (cli_file_t )503}, 
        {0, "%PDF-", 5U, "PDF document", (cli_file_t )503}, 
        {0, "%!PS-Adobe-", 11U, "PostScript", (cli_file_t )503}, 
        {0, "0&\262u\216f\317", 7U, "WMA/WMV/ASF", (cli_file_t )503}, 
        {0, ".RMF", 4U, "Real Media File", (cli_file_t )503}, 
        {-1, (char const   *)((void *)0), 0U, (char const   *)((void *)0), (cli_file_t )501}};
static struct cli_smagic_s  const  cli_smagic[33]  = 
  {      {"0a46726f6d3a20{-2048}0a436f6e74656e742d547970653a20", "Mail file", (cli_file_t )520}, 
        {"0a52656365697665643a20{-2048}0a436f6e74656e742d547970653a20",
      "Mail file", (cli_file_t )520}, 
        {"0a52656365697665643a20{-2048}0a436f6e74656e742d747970653a20", "Mail file",
      (cli_file_t )520}, 
        {"4d494d452d56657273696f6e3a20{-2048}0a436f6e74656e742d547970653a20", "Mail file",
      (cli_file_t )520}, 
        {"3c62723e", "HTML data", (cli_file_t )519}, 
        {"3c42723e", "HTML data", (cli_file_t )519}, 
        {"3c42523e", "HTML data", (cli_file_t )519}, 
        {"3c703e", "HTML data", (cli_file_t )519}, 
        {"3c503e", "HTML data", (cli_file_t )519}, 
        {"68726566", "HTML data", (cli_file_t )519}, 
        {"48726566", "HTML data", (cli_file_t )519}, 
        {"48524546", "HTML data", (cli_file_t )519}, 
        {"3c68746d6c3e", "HTML data", (cli_file_t )519}, 
        {"3c48544d4c3e", "HTML data", (cli_file_t )519}, 
        {"3c48746d6c3e", "HTML data", (cli_file_t )519}, 
        {"3c686561643e", "HTML data", (cli_file_t )519}, 
        {"3c484541443e", "HTML data", (cli_file_t )519}, 
        {"3c486561643e", "HTML data", (cli_file_t )519}, 
        {"3c666f6e74", "HTML data", (cli_file_t )519}, 
        {"3c466f6e74", "HTML data", (cli_file_t )519}, 
        {"3c464f4e54", "HTML data", (cli_file_t )519}, 
        {"3c696d67", "HTML data", (cli_file_t )519}, 
        {"3c494d47", "HTML data", (cli_file_t )519}, 
        {"3c496d67", "HTML data", (cli_file_t )519}, 
        {"3c736372697074", "HTML data", (cli_file_t )519}, 
        {"3c536372697074", "HTML data", (cli_file_t )519}, 
        {"3c534352495054", "HTML data", (cli_file_t )519}, 
        {"3c6f626a656374", "HTML data", (cli_file_t )519}, 
        {"3c4f626a656374", "HTML data", (cli_file_t )519}, 
        {"3c4f424a454354", "HTML data", (cli_file_t )519}, 
        {"3c696672616d65", "HTML data", (cli_file_t )519}, 
        {"3c494652414d45", "HTML data", (cli_file_t )519}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (cli_file_t )501}};
static char internat[256]  = 
  {      (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)1, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)0, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1};
cli_file_t cli_filetype(char const   *buf , size_t buflen ) 
{ int i ;
  int ascii ;
  int len ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;

  {
  ascii = 1;
  i = 0;
  while (cli_magic[i].magic) {
    if (buflen >= (unsigned int )cli_magic[i].offset + cli_magic[i].length) {
      tmp = memcmp((void const   *)(buf + cli_magic[i].offset), (void const   *)cli_magic[i].magic,
                   cli_magic[i].length);
      if (tmp == 0) {
        cli_dbgmsg("Recognized %s file\n", cli_magic[i].descr);
        return (cli_magic[i].type);
      }
    }
    i ++;
  }
  if (buflen < 25U) {
    len = (int )buflen;
  } else {
    len = 25;
  }
  i = 0;
  while (i < len) {
    tmp___0 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___0) + (int )(*(buf + i)))) & 2)) {
      tmp___1 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___1) + (int )(*(buf + i)))) & 16384)) {
        if (! internat[(int const   )(*(buf + i)) & 255]) {
          ascii = 0;
          break;
        }
      }
    }
    i ++;
  }
  if (ascii) {
    tmp___2 = 500;
  } else {
    tmp___2 = 501;
  }
  return ((enum __anonenum_cli_file_t_36 )tmp___2);
}
}
int is_tar(unsigned char *buf , int nbytes ) ;
cli_file_t cli_filetype2(int desc ) 
{ char smallbuff[51] ;
  unsigned char *bigbuff ;
  int bread ;
  cli_file_t ret ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  ret = (enum __anonenum_cli_file_t_36 )501;
  memset((void *)(smallbuff), 0, sizeof(smallbuff));
  bread = read(desc, (void *)(smallbuff), 50U);
  if (bread > 0) {
    ret = cli_filetype((char const   *)(smallbuff), (unsigned int )bread);
  }
  if ((int )ret == 501) {
    goto _L___0;
  } else {
    if ((int )ret == 500) {
      _L___0: 
      bigbuff = (unsigned char *)cli_calloc(37639U, sizeof(unsigned char ));
      if (! bigbuff) {
        return (ret);
      }
      lseek(desc, 0L, 0);
      bread = read(desc, (void *)bigbuff, 37638U);
      if (bread > 0) {
        (*(bigbuff + bread)) = (unsigned char)0;
        tmp___0 = is_tar(bigbuff, bread);
        switch (tmp___0) {
        case 1: 
        ret = (enum __anonenum_cli_file_t_36 )505;
        cli_dbgmsg("Recognized old fashioned tar file\n");
        break;
        case 2: 
        ret = (enum __anonenum_cli_file_t_36 )504;
        cli_dbgmsg("Recognized POSIX tar file\n");
        break;
        }
      }
      if ((int )ret == 501) {
        goto _L;
      } else {
        if ((int )ret == 500) {
          _L: 
          tmp___2 = memcmp((void const   *)(bigbuff + 32769), (void const   *)"CD001",
                           5U);
          if (tmp___2) {
            tmp___3 = memcmp((void const   *)(bigbuff + 37633), (void const   *)"CD001",
                             5U);
            if (tmp___3) {
              tmp___1 = memcmp((void const   *)(bigbuff + 32776), (void const   *)"CDROM",
                               5U);
              if (! tmp___1) {
                cli_dbgmsg("Recognized High Sierra CD-ROM data\n");
                ret = (enum __anonenum_cli_file_t_36 )503;
              }
            } else {
              cli_dbgmsg("Recognized ISO 9660 CD-ROM data\n");
              ret = (enum __anonenum_cli_file_t_36 )503;
            }
          } else {
            cli_dbgmsg("Recognized ISO 9660 CD-ROM data\n");
            ret = (enum __anonenum_cli_file_t_36 )503;
          }
        }
      }
      free((void *)bigbuff);
    }
  }
  return (ret);
}
}
int cli_addtypesigs(struct cl_node *root ) 
{ int i ;
  int ret ;

  {
  i = 0;
  while (cli_smagic[i].sig) {
    ret = cli_parse_add(root, cli_smagic[i].descr, cli_smagic[i].sig, (unsigned short )cli_smagic[i].type,
                        (char *)((void *)0), (unsigned short)0);
    if (ret) {
      cli_errmsg("cli_addtypesigs(): Problem adding signature for %s\n", cli_smagic[i].descr);
      return (ret);
    }
    i ++;
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-NiGKGYfs.i","-g -O2 -fPIC")
extern long ftell(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
extern __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline static  __attribute__((__nothrow__)) int toupper__extinline(int __c ) ;
__inline static  __attribute__((__nothrow__)) int toupper__extinline(int __c ) ;
__inline static int toupper__extinline(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp___1 = __ctype_toupper_loc();
      tmp___0 = (*((*tmp___1) + __c));
    } else {
      tmp___0 = __c;
    }
  } else {
    tmp___0 = __c;
  }
  return (tmp___0);
}
}
static struct MarkHeader MarkHead  ;
static struct NewMainArchiveHeader NewMhd  ;
static struct NewFileHeader NewLhd  ;
static struct BlockHeader BlockHead  ;
static UBYTE *TempMemory  =    (UBYTE *)((void *)0);
static char *CommMemory  =    (char *)((void *)0);
static UBYTE *UnpMemory  =    (UBYTE *)((void *)0);
static char ArgName[260]  ;
static char ArcFileName[260]  ;
static FILE *ArcPtr  ;
static char Password[255]  ;
static unsigned char *temp_output_buffer  ;
static unsigned long *temp_output_buffer_offset  ;
static int MainHeadSize  ;
static long CurBlockPos  ;
static long NextBlockPos  ;
static unsigned long CurUnpRead  ;
static long UnpPackedSize  ;
static long DestUnpSize  ;
static UDWORD HeaderCRC  ;
static int Encryption  ;
static unsigned int UnpPtr  ;
static unsigned int WrPtr  ;
static unsigned char PN1  ;
static unsigned char PN2  ;
static unsigned char PN3  ;
static unsigned short OldKey[4]  ;
static int ReadHeader(int BlockType ) ;
static BOOL ExtrFile(int desc ) ;
static int tread(void *stream , void *buf , unsigned int len ) ;
static int tseek(void *stream , long offset , int fromwhere ) ;
static int IsArchive(void) ;
static int ReadBlock(int BlockType ) ;
static unsigned int UnpRead(unsigned char *Addr , unsigned int Count ) ;
static void UnpInitData(void) ;
static void Unpack(unsigned char *UnpAddr , BOOL FileFound ) ;
static UBYTE DecodeAudio(int Delta ) ;
static void DecodeNumber(struct Decode *Deco ) ;
static void UpdKeys(UBYTE *Buf ) ;
static void SetCryptKeys(char *NewPassword ) ;
static void SetOldKeys(char *NewPassword ) ;
static void DecryptBlock(unsigned char *Buf ) ;
static void InitCRC(void) ;
static UDWORD CalcCRC32(UDWORD StartCRC , UBYTE *Addr , UDWORD Size ) ;
static void UnpReadBuf(int FirstBuf ) ;
static void ReadTables(void) ;
static void ReadLastTables(void) ;
static void MakeDecodeTables(unsigned char *LenTab , struct Decode *Dec , int Size ) ;
static int stricomp(char *Str1 , char *Str2 ) ;
int urarlib_get(void *output , unsigned long *size , char *filename , int desc , char *libpassword ) 
{ BOOL retcode ;

  {
  retcode = (short)0;
  InitCRC();
  strcpy((char * __restrict  )(ArgName), (char const   * __restrict  )filename);
  if ((unsigned int )libpassword != (unsigned int )((void *)0)) {
    strcpy((char * __restrict  )(Password), (char const   * __restrict  )libpassword);
  }
  temp_output_buffer = (unsigned char *)((void *)0);
  temp_output_buffer_offset = size;
  retcode = ExtrFile(desc);
  memset((void *)(Password), 0, sizeof(Password));
  if ((unsigned int )ArcPtr != (unsigned int )((void *)0)) {
    cli_dbgmsg("%s:%d NOT Close ArcPtr from fd %d\n", "unrarlib.c", 418, desc);
  }
  if (UnpMemory) {
    free((void *)UnpMemory);
  }
  if (TempMemory) {
    free((void *)TempMemory);
  }
  if (CommMemory) {
    free((void *)CommMemory);
  }
  UnpMemory = (UBYTE *)((void *)0);
  TempMemory = (UBYTE *)((void *)0);
  CommMemory = (char *)((void *)0);
  if ((int )retcode == 0) {
    if (temp_output_buffer) {
      free((void *)temp_output_buffer);
    }
    temp_output_buffer = (unsigned char *)((void *)0);
    (*((DWORD *)output)) = 0L;
    (*size) = 0UL;
  }
  (*((DWORD *)output)) = (long )temp_output_buffer;
  return ((int )retcode);
}
}
int urarlib_list(int desc , ArchiveList_struct *list ) 
{ ArchiveList_struct *tmp_List ;
  int NoOfFilesInArchive ;
  int newdesc ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int ReadBlockResult ;

  {
  tmp_List = (ArchiveList_struct *)((void *)0);
  NoOfFilesInArchive = 0;
  InitCRC();
  newdesc = dup(desc);
  cli_dbgmsg("ExtrFile(): dup(%d) = %d\n", desc, newdesc);
  ArcPtr = fdopen(newdesc, "r");
  if ((unsigned int )ArcPtr != (unsigned int )((void *)0)) {
    tmp = IsArchive();
    if (! tmp) {
      cli_dbgmsg("urarlib_list(): Not a valid archive.");
      cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 507, "Not a RAR file");
      fclose(ArcPtr);
      lseek(desc, 0L, 0);
      ArcPtr = (FILE *)((void *)0);
      return (NoOfFilesInArchive);
    }
  } else {
    tmp___0 = __errno_location();
    tmp___1 = strerror((*tmp___0));
    cli_dbgmsg("urarlib_list(): Error opening file: %s", tmp___1);
    cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 516, "Error opening file.");
    cli_dbgmsg("%s:%d Close fd %d\n", "unrarlib.c", 517, newdesc);
    close(newdesc);
    return (NoOfFilesInArchive);
  }
  UnpMemory = (UBYTE *)malloc(1048576U);
  if ((unsigned int )UnpMemory == (unsigned int )((void *)0)) {
    cli_dbgmsg("urarlib_list(): out of memory.");
    cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 526, "Can\'t allocate memory for decompression!");
    fclose(ArcPtr);
    return (NoOfFilesInArchive);
  }
  tseek((void *)ArcPtr, (long )((int )NewMhd.HeadSize - MainHeadSize), 1);
  (*((DWORD *)list)) = (long )((void *)0);
  while (1) {
    ReadBlockResult = ReadBlock(32884);
    if (ReadBlockResult <= 0) {
      cli_dbgmsg("Couldn\'t read next filename from archive (I/O error): %d\n", ReadBlockResult);
      break;
    }
    if ((int )BlockHead.HeadType == 119) {
      cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 548, "Sorry, sub-headers not supported.");
      NoOfFilesInArchive = 0;
      break;
    }
    if ((unsigned int )((void *)(*((DWORD *)list))) == (unsigned int )((void *)0)) {
      tmp_List = (ArchiveList_struct *)malloc(sizeof(ArchiveList_struct ));
      tmp_List->next = (struct archivelist *)((void *)0);
      (*((DWORD *)list)) = (long )tmp_List;
    } else {
      tmp_List->next = (struct archivelist *)malloc(sizeof(ArchiveList_struct ));
      tmp_List = tmp_List->next;
      tmp_List->next = (struct archivelist *)((void *)0);
    }
    tmp_List->item.Name = (char *)malloc((unsigned int )((int )NewLhd.NameSize + 1));
    strcpy((char * __restrict  )tmp_List->item.Name, (char const   * __restrict  )(ArcFileName));
    tmp_List->item.NameSize = NewLhd.NameSize;
    tmp_List->item.PackSize = NewLhd.PackSize;
    tmp_List->item.UnpSize = NewLhd.UnpSize;
    tmp_List->item.HostOS = NewLhd.HostOS;
    tmp_List->item.FileCRC = NewLhd.FileCRC;
    tmp_List->item.FileTime = NewLhd.FileTime;
    tmp_List->item.UnpVer = NewLhd.UnpVer;
    tmp_List->item.Method = NewLhd.Method;
    tmp_List->item.FileAttr = NewLhd.FileAttr;
    tmp_List->item.Flags = NewLhd.Flags;
    NoOfFilesInArchive ++;
    if ((unsigned int )ArcPtr != (unsigned int )((void *)0)) {
      tseek((void *)ArcPtr, NextBlockPos, 0);
    }
  }
  memset((void *)(Password), 0, sizeof(Password));
  if ((unsigned int )ArcPtr != (unsigned int )((void *)0)) {
    fclose(ArcPtr);
    ArcPtr = (FILE *)((void *)0);
    lseek(desc, 0L, 0);
  }
  if (UnpMemory) {
    free((void *)UnpMemory);
  }
  if (TempMemory) {
    free((void *)TempMemory);
  }
  if (CommMemory) {
    free((void *)CommMemory);
  }
  UnpMemory = (UBYTE *)((void *)0);
  TempMemory = (UBYTE *)((void *)0);
  CommMemory = (char *)((void *)0);
  return (NoOfFilesInArchive);
}
}
void urarlib_freelist(ArchiveList_struct *list ) 
{ ArchiveList_struct *tmp ;

  {
  tmp = list;
  while (list) {
    tmp = list->next;
    free((void *)list->item.Name);
    free((void *)list);
    list = tmp;
  }
  return;
}
}
static int LastBlock  ;
static int ReadBlock(int BlockType ) 
{ struct NewFileHeader SaveFileHead ;
  int Size ;
  int ReadSubBlock ;

  {
  Size = 0;
  ReadSubBlock = 0;
  memcpy((void * __restrict  )(& SaveFileHead), (void const   * __restrict  )(& NewLhd),
         sizeof(SaveFileHead));
  if (BlockType & 32768) {
    ReadSubBlock = 1;
    BlockType &= 255;
  }
  while (1) {
    CurBlockPos = ftell(ArcPtr);
    Size = ReadHeader(116);
    if (Size != 0) {
      if ((int )NewLhd.HeadSize < 7) {
        return (0);
      }
      NextBlockPos = CurBlockPos + (long )NewLhd.HeadSize;
      if ((int )NewLhd.Flags & 32768) {
        NextBlockPos = (long )((unsigned long )NextBlockPos + NewLhd.PackSize);
      }
      if (NextBlockPos <= CurBlockPos) {
        return (0);
      }
    }
    if (Size > 0) {
      if (BlockType != 119) {
        LastBlock = BlockType;
      }
    }
    if (Size == 0) {
      break;
    } else {
      if (BlockType == 0) {
        break;
      } else {
        if ((int )NewLhd.HeadType == BlockType) {
          break;
        } else {
          if ((int )NewLhd.HeadType == 119) {
            if (ReadSubBlock) {
              if (LastBlock == BlockType) {
                break;
              }
            }
          }
        }
      }
    }
    tseek((void *)ArcPtr, NextBlockPos, 0);
  }
  BlockHead.HeadCRC = NewLhd.HeadCRC;
  BlockHead.HeadType = NewLhd.HeadType;
  BlockHead.Flags = NewLhd.Flags;
  BlockHead.HeadSize = NewLhd.HeadSize;
  BlockHead.DataSize = NewLhd.PackSize;
  if (BlockType != (int )NewLhd.HeadType) {
    BlockType = 0;
  }
  if (116 == BlockType) {
    if (Size > 0) {
      if ((unsigned int )NewLhd.NameSize < sizeof(ArcFileName) - 1U) {
        NewLhd.NameSize = NewLhd.NameSize;
      } else {
        NewLhd.NameSize = (unsigned short )(sizeof(ArcFileName) - 1U);
      }
      tread((void *)ArcPtr, (void *)(ArcFileName), (unsigned int )NewLhd.NameSize);
      ArcFileName[NewLhd.NameSize] = (char)0;
      Size += (int )NewLhd.NameSize;
    } else {
      memcpy((void * __restrict  )(& NewLhd), (void const   * __restrict  )(& SaveFileHead),
             sizeof(NewLhd));
      tseek((void *)ArcPtr, CurBlockPos, 0);
    }
  } else {
    memcpy((void * __restrict  )(& NewLhd), (void const   * __restrict  )(& SaveFileHead),
           sizeof(NewLhd));
    tseek((void *)ArcPtr, CurBlockPos, 0);
  }
  return (Size);
}
}
static int ReadHeader(int BlockType ) 
{ int Size ;
  unsigned char Header[64] ;

  {
  Size = 0;
  memset((void *)(Header), 0, sizeof(Header));
  switch (BlockType) {
  case 115: 
  Size = tread((void *)ArcPtr, (void *)(Header), 13U);
  NewMhd.HeadCRC = (unsigned short )((int )Header[0] + ((int )((unsigned short )Header[1]) <<
                                                        8));
  NewMhd.HeadType = Header[2];
  NewMhd.Flags = (unsigned short )((int )Header[3] + ((int )((unsigned short )Header[4]) <<
                                                      8));
  NewMhd.HeadSize = (unsigned short )((int )Header[5] + ((int )((unsigned short )Header[6]) <<
                                                         8));
  NewMhd.Reserved = (unsigned short )((int )Header[7] + ((int )((unsigned short )Header[8]) <<
                                                         8));
  NewMhd.Reserved1 = ((unsigned long )((int )Header[9] + ((int )((unsigned short )Header[10]) <<
                                                          8)) + ((unsigned long )Header[11] <<
                                                                 16)) + ((unsigned long )Header[12] <<
                                                                         24);
  HeaderCRC = CalcCRC32(4294967295UL, & Header[2], 11UL);
  break;
  case 116: 
  Size = tread((void *)ArcPtr, (void *)(Header), 32U);
  NewLhd.HeadCRC = (unsigned short )((int )Header[0] + ((int )((unsigned short )Header[1]) <<
                                                        8));
  NewLhd.HeadType = Header[2];
  NewLhd.Flags = (unsigned short )((int )Header[3] + ((int )((unsigned short )Header[4]) <<
                                                      8));
  NewLhd.HeadSize = (unsigned short )((int )Header[5] + ((int )((unsigned short )Header[6]) <<
                                                         8));
  NewLhd.PackSize = ((unsigned long )((int )Header[7] + ((int )((unsigned short )Header[8]) <<
                                                         8)) + ((unsigned long )Header[9] <<
                                                                16)) + ((unsigned long )Header[10] <<
                                                                        24);
  NewLhd.UnpSize = ((unsigned long )((int )Header[11] + ((int )((unsigned short )Header[12]) <<
                                                         8)) + ((unsigned long )Header[13] <<
                                                                16)) + ((unsigned long )Header[14] <<
                                                                        24);
  NewLhd.HostOS = Header[15];
  NewLhd.FileCRC = ((unsigned long )((int )Header[16] + ((int )((unsigned short )Header[17]) <<
                                                         8)) + ((unsigned long )Header[18] <<
                                                                16)) + ((unsigned long )Header[19] <<
                                                                        24);
  NewLhd.FileTime = ((unsigned long )((int )Header[20] + ((int )((unsigned short )Header[21]) <<
                                                          8)) + ((unsigned long )Header[22] <<
                                                                 16)) + ((unsigned long )Header[23] <<
                                                                         24);
  NewLhd.UnpVer = Header[24];
  NewLhd.Method = Header[25];
  NewLhd.NameSize = (unsigned short )((int )Header[26] + ((int )((unsigned short )Header[27]) <<
                                                          8));
  NewLhd.FileAttr = ((unsigned long )((int )Header[28] + ((int )((unsigned short )Header[29]) <<
                                                          8)) + ((unsigned long )Header[30] <<
                                                                 16)) + ((unsigned long )Header[31] <<
                                                                         24);
  HeaderCRC = CalcCRC32(4294967295UL, Header + 2, 30UL);
  break;
  default: ;
  break;
  }
  return (Size);
}
}
static int IsArchive(void) 
{ int tmp ;
  int tmp___0 ;

  {
  tmp = tread((void *)ArcPtr, (void *)(MarkHead.Mark), 7U);
  if (tmp != 7) {
    cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 884, "IsArchive(): short read: FALSE");
    return (0);
  }
  if ((int )MarkHead.Mark[0] == 82) {
    if ((int )MarkHead.Mark[1] == 69) {
      if ((int )MarkHead.Mark[2] == 126) {
        if ((int )MarkHead.Mark[3] == 94) {
          cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 892, "Attention: format as OLD detected! Can\'t handle archive!");
        } else {
          goto _L___8;
        }
      } else {
        goto _L___8;
      }
    } else {
      goto _L___8;
    }
  } else {
    _L___8: 
    if ((int )MarkHead.Mark[0] == 82) {
      if ((int )MarkHead.Mark[1] == 97) {
        if ((int )MarkHead.Mark[2] == 114) {
          if ((int )MarkHead.Mark[3] == 33) {
            if ((int )MarkHead.Mark[4] == 26) {
              if ((int )MarkHead.Mark[5] == 7) {
                if ((int )MarkHead.Mark[6] == 0) {
                  goto _L;
                } else {
                  goto _L___5;
                }
              } else {
                goto _L___5;
              }
            } else {
              goto _L___5;
            }
          } else {
            goto _L___5;
          }
        } else {
          goto _L___5;
        }
      } else {
        goto _L___5;
      }
    } else {
      _L___5: 
      if ((int )MarkHead.Mark[0] == 85) {
        if ((int )MarkHead.Mark[1] == 110) {
          if ((int )MarkHead.Mark[2] == 105) {
            if ((int )MarkHead.Mark[3] == 113) {
              if ((int )MarkHead.Mark[4] == 117) {
                if ((int )MarkHead.Mark[5] == 69) {
                  if ((int )MarkHead.Mark[6] == 33) {
                    _L: 
                    tmp___0 = ReadHeader(115);
                    if (tmp___0 != 13) {
                      cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 908, "IsArchive(): ReadHeader() failed");
                      return (0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  MainHeadSize = 13;
  return (1);
}
}
static BOOL ExtrFile(int desc ) 
{ BOOL ReturnCode ;
  BOOL FileFound ;
  int newdesc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  UDWORD tmp___2 ;
  int tmp___3 ;

  {
  ReturnCode = (short)1;
  FileFound = (short)0;
  newdesc = dup(desc);
  cli_dbgmsg("ExtrFile(): dup(%d) = %d\n", desc, newdesc);
  ArcPtr = fdopen(newdesc, "r");
  if ((unsigned int )ArcPtr != (unsigned int )((void *)0)) {
    tmp = IsArchive();
    if (! tmp) {
      cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 958, "Not a RAR file");
      fclose(ArcPtr);
      ArcPtr = (FILE *)((void *)0);
      return ((short)0);
    }
  } else {
    cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 965, "Error opening file.");
    return ((short)0);
  }
  UnpMemory = (UBYTE *)malloc(1048576U);
  if ((unsigned int )UnpMemory == (unsigned int )((void *)0)) {
    cli_dbgmsg("unrarlib: Can\'t allocate memory for decompression!");
    return ((short)0);
  } else {
    cli_dbgmsg("unrarlib: Allocated %d bytes.\n", 1048576);
  }
  tseek((void *)ArcPtr, (long )((int )NewMhd.HeadSize - MainHeadSize), 1);
  while (1) {
    tmp___0 = ReadBlock(32884);
    if (tmp___0 <= 0) {
      ReturnCode = (short)0;
      break;
    }
    if ((int )BlockHead.HeadType == 119) {
      cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 1005, "Sorry, sub-headers not supported.");
      ReturnCode = (short)0;
      break;
    }
    tmp___1 = stricomp(ArgName, ArcFileName);
    FileFound = (short )(tmp___1 == 0);
    if (1 == (int )FileFound) {
      cli_dbgmsg("unrarlib: Allocating %d bytes\n", NewLhd.UnpSize);
      temp_output_buffer = (unsigned char *)malloc((unsigned int )NewLhd.UnpSize);
      if ((unsigned int )temp_output_buffer == (unsigned int )((void *)0)) {
        cli_errmsg("unrarlib: Can\'t malloc %d bytes\n", NewLhd.UnpSize);
        ReturnCode = (short)0;
        break;
      }
      (*temp_output_buffer_offset) = 0UL;
    }
    if ((int )NewMhd.Flags & 8) {
      goto _L;
    } else {
      if (FileFound) {
        _L: 
        if ((int )NewLhd.UnpVer < 13) {
          cli_dbgmsg("unknown compression method: %d  (min=13 max=%d)\n", NewLhd.UnpVer,
                     20);
          ReturnCode = (short)0;
          break;
        } else {
          if ((int )NewLhd.UnpVer > 20) {
            cli_dbgmsg("unknown compression method: %d  (min=13 max=%d)\n", NewLhd.UnpVer,
                       20);
            ReturnCode = (short)0;
            break;
          }
        }
        CurUnpRead = 0UL;
        if ((int )Password[0] != 0) {
          if ((int )NewLhd.Flags & 4) {
            Encryption = (int )NewLhd.UnpVer;
          } else {
            Encryption = 0;
          }
        } else {
          Encryption = 0;
        }
        if (Encryption) {
          SetCryptKeys(Password);
        }
        UnpPackedSize = (long )NewLhd.PackSize;
        DestUnpSize = (long )NewLhd.UnpSize;
        if ((int )NewLhd.Method == 48) {
          cli_dbgmsg("unrarlib: Unstore method temporarily not supported\n");
          ReturnCode = (short)0;
          break;
        } else {
          cli_dbgmsg("unrarlib: Unpack()\n");
          Unpack(UnpMemory, FileFound);
        }
        if ((unsigned int )temp_output_buffer != (unsigned int )((void *)0)) {
          tmp___2 = CalcCRC32(4294967295UL, temp_output_buffer, NewLhd.UnpSize);
          if (NewLhd.FileCRC != ~ tmp___2) {
            cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 1070, "CRC32 error - file couldn\'t be decompressed correctly!");
            ReturnCode = (short)0;
            break;
          }
        }
      }
    }
    if ((unsigned int )ArcPtr != (unsigned int )((void *)0)) {
      tseek((void *)ArcPtr, NextBlockPos, 0);
    }
    tmp___3 = stricomp(ArgName, ArcFileName);
    if (! (tmp___3 != 0)) {
      break;
    }
  }
  if (UnpMemory) {
    free((void *)UnpMemory);
  }
  UnpMemory = (UBYTE *)((void *)0);
  if ((unsigned int )ArcPtr != (unsigned int )((void *)0)) {
    fclose(ArcPtr);
    lseek(desc, 0L, 0);
    ArcPtr = (FILE *)((void *)0);
  }
  return (ReturnCode);
}
}
static int tread(void *stream , void *buf , unsigned int len ) 
{ int tmp ;

  {
  tmp = (int )fread((void * __restrict  )buf, 1U, len, (FILE * __restrict  )((FILE *)stream));
  return (tmp);
}
}
static int tseek(void *stream , long offset , int fromwhere ) 
{ int tmp ;

  {
  tmp = fseek((FILE *)stream, offset, fromwhere);
  return (tmp);
}
}
static char *strupper(char *Str ) 
{ char *ChPtr ;
  int __res ;
  int __c ;
  __int32_t const   **tmp___0 ;
  int tmp___1 ;
  __int32_t const   **tmp___2 ;

  {
  ChPtr = Str;
  while ((*ChPtr)) {
    if (sizeof((*ChPtr)) > 1U) {
      tmp___1 = __builtin_constant_p((int )(*ChPtr));
      if (tmp___1) {
        __c = (int )(*ChPtr);
        if (__c < -128) {
          __res = __c;
        } else {
          if (__c > 255) {
            __res = __c;
          } else {
            tmp___0 = __ctype_toupper_loc();
            __res = (*((*tmp___0) + __c));
          }
        }
      } else {
        __res = toupper__extinline((int )(*ChPtr));
      }
    } else {
      tmp___2 = __ctype_toupper_loc();
      __res = (*((*tmp___2) + (int )(*ChPtr)));
    }
    (*ChPtr) = (char )__res;
    ChPtr ++;
  }
  return (Str);
}
}
static int stricomp(char *Str1 , char *Str2 ) 
{ char S1[512] ;
  char S2[512] ;
  char *chptr ;
  int tmp___3 ;
  int tmp___8 ;
  int tmp___13 ;
  int tmp___18 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___216 ;
  char *tmp___217 ;
  char *tmp___218 ;
  char *tmp___323 ;
  char *tmp___324 ;
  unsigned char const   *__s2___6 ;
  char const   *tmp___325 ;
  register int __result___18 ;
  char *tmp___326 ;
  char *tmp___327 ;
  char *tmp___328 ;
  char *tmp___329 ;
  int tmp___330 ;
  int tmp___331 ;
  char *tmp___332 ;
  char *tmp___333 ;
  char *tmp___378 ;
  char *tmp___379 ;
  unsigned char const   *__s1___14 ;
  char const   *tmp___380 ;
  register int __result___22 ;
  char *tmp___381 ;
  char *tmp___382 ;
  char *tmp___383 ;
  char *tmp___384 ;
  int tmp___385 ;
  int tmp___386 ;
  char *tmp___387 ;
  char *tmp___388 ;
  char *tmp___389 ;
  char *tmp___390 ;
  int tmp___391 ;
  int tmp___392 ;
  char *tmp___393 ;
  char *tmp___394 ;
  char const   *tmp___395 ;
  int tmp___396 ;
  int tmp___397 ;
  char *tmp___398 ;
  char *tmp___399 ;
  char const   *tmp___400 ;
  int tmp___401 ;
  int tmp___402 ;
  int tmp___403 ;
  int tmp___404 ;
  char const   *tmp___405 ;
  char const   *tmp___406 ;
  char *tmp___407 ;
  char *tmp___408 ;
  char *tmp___409 ;
  char *tmp___410 ;
  int tmp___411 ;

  {
  __builtin_strncpy(S1, Str1, sizeof(S1));
  __builtin_strncpy(S2, Str2, sizeof(S2));
  while (1) {
    tmp___3 = __builtin_constant_p((int )(S1));
    if (tmp___3) {
      chptr = (char *)__builtin_strchr(S1, '\\');
    } else {
      chptr = (char *)__builtin_strchr(S1, '\\');
    }
    if (! ((unsigned int )chptr != (unsigned int )((void *)0))) {
      break;
    }
    (*chptr) = (char )'_';
  }
  while (1) {
    tmp___8 = __builtin_constant_p((int )(S2));
    if (tmp___8) {
      chptr = (char *)__builtin_strchr(S2, '\\');
    } else {
      chptr = (char *)__builtin_strchr(S2, '\\');
    }
    if (! ((unsigned int )chptr != (unsigned int )((void *)0))) {
      break;
    }
    (*chptr) = (char )'_';
  }
  while (1) {
    tmp___13 = __builtin_constant_p((int )(S1));
    if (tmp___13) {
      chptr = (char *)__builtin_strchr(S1, '/');
    } else {
      chptr = (char *)__builtin_strchr(S1, '/');
    }
    if (! ((unsigned int )chptr != (unsigned int )((void *)0))) {
      break;
    }
    (*chptr) = (char )'_';
  }
  while (1) {
    tmp___18 = __builtin_constant_p((int )(S2));
    if (tmp___18) {
      chptr = (char *)__builtin_strchr(S2, '/');
    } else {
      chptr = (char *)__builtin_strchr(S2, '/');
    }
    if (! ((unsigned int )chptr != (unsigned int )((void *)0))) {
      break;
    }
    (*chptr) = (char )'_';
  }
  tmp___401 = (int )strupper(S1);
  tmp___402 = __builtin_constant_p(tmp___401);
  if (tmp___402) {
    tmp___403 = (int )strupper(S2);
    tmp___404 = __builtin_constant_p(tmp___403);
    if (tmp___404) {
      tmp___405 = strupper(S1);
      __s1_len = strlen(tmp___405);
      tmp___406 = strupper(S2);
      __s2_len = strlen(tmp___406);
      tmp___407 = strupper(S1);
      tmp___408 = strupper(S1);
      if ((unsigned int )((void const   *)(tmp___407 + 1)) - (unsigned int )((void const   *)tmp___408) ==
          1U) {
        if (__s1_len >= 4U) {
          _L___16: 
          tmp___409 = strupper(S2);
          tmp___410 = strupper(S2);
          if ((unsigned int )((void const   *)(tmp___409 + 1)) - (unsigned int )((void const   *)tmp___410) ==
              1U) {
            if (__s2_len >= 4U) {
              tmp___411 = 1;
            } else {
              tmp___411 = 0;
            }
          } else {
            tmp___411 = 1;
          }
        } else {
          tmp___411 = 0;
        }
      } else {
        goto _L___16;
      }
      if (tmp___411) {
        tmp___217 = strupper(S2);
        tmp___218 = strupper(S1);
        tmp___216 = __builtin_strcmp(tmp___218, tmp___217);
      } else {
        goto _L___18;
      }
    } else {
      goto _L___18;
    }
  } else {
    _L___18: 
    tmp___396 = (int )strupper(S1);
    tmp___397 = __builtin_constant_p(tmp___396);
    if (tmp___397) {
      tmp___398 = strupper(S1);
      tmp___399 = strupper(S1);
      if ((unsigned int )((void const   *)(tmp___398 + 1)) - (unsigned int )((void const   *)tmp___399) ==
          1U) {
        tmp___400 = strupper(S1);
        __s1_len = strlen(tmp___400);
        if (__s1_len < 4U) {
          tmp___330 = (int )strupper(S2);
          tmp___331 = __builtin_constant_p(tmp___330);
          if (tmp___331) {
            tmp___332 = strupper(S2);
            tmp___333 = strupper(S2);
            if ((unsigned int )((void const   *)(tmp___332 + 1)) - (unsigned int )((void const   *)tmp___333) ==
                1U) {
              tmp___323 = strupper(S2);
              tmp___324 = strupper(S1);
              tmp___216 = __builtin_strcmp(tmp___324, tmp___323);
            } else {
              goto _L___11;
            }
          } else {
            _L___11: 
            tmp___325 = strupper(S2);
            __s2___6 = (unsigned char const   *)tmp___325;
            tmp___326 = strupper(S1);
            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)tmp___326) +
                                                    0)) - (int const   )(*(__s2___6 +
                                                                           0)));
            if (__s1_len > 0U) {
              if (__result___18 == 0) {
                tmp___327 = strupper(S1);
                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)tmp___327) +
                                                        1)) - (int const   )(*(__s2___6 +
                                                                               1)));
                if (__s1_len > 1U) {
                  if (__result___18 == 0) {
                    tmp___328 = strupper(S1);
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)tmp___328) +
                                                            2)) - (int const   )(*(__s2___6 +
                                                                                   2)));
                    if (__s1_len > 2U) {
                      if (__result___18 == 0) {
                        tmp___329 = strupper(S1);
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)tmp___329) +
                                                                3)) - (int const   )(*(__s2___6 +
                                                                                       3)));
                      }
                    }
                  }
                }
              }
            }
            tmp___216 = __result___18;
          }
        } else {
          goto _L___15;
        }
      } else {
        goto _L___15;
      }
    } else {
      _L___15: 
      tmp___391 = (int )strupper(S2);
      tmp___392 = __builtin_constant_p(tmp___391);
      if (tmp___392) {
        tmp___393 = strupper(S2);
        tmp___394 = strupper(S2);
        if ((unsigned int )((void const   *)(tmp___393 + 1)) - (unsigned int )((void const   *)tmp___394) ==
            1U) {
          tmp___395 = strupper(S2);
          __s2_len = strlen(tmp___395);
          if (__s2_len < 4U) {
            tmp___385 = (int )strupper(S1);
            tmp___386 = __builtin_constant_p(tmp___385);
            if (tmp___386) {
              tmp___387 = strupper(S1);
              tmp___388 = strupper(S1);
              if ((unsigned int )((void const   *)(tmp___387 + 1)) - (unsigned int )((void const   *)tmp___388) ==
                  1U) {
                tmp___378 = strupper(S2);
                tmp___379 = strupper(S1);
                tmp___216 = __builtin_strcmp(tmp___379, tmp___378);
              } else {
                goto _L___13;
              }
            } else {
              _L___13: 
              tmp___380 = strupper(S1);
              __s1___14 = (unsigned char const   *)tmp___380;
              tmp___381 = strupper(S2);
              __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)tmp___381) +
                                                                                         0)));
              if (__s2_len > 0U) {
                if (__result___22 == 0) {
                  tmp___382 = strupper(S2);
                  __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)((char const   *)tmp___382) +
                                                                                             1)));
                  if (__s2_len > 1U) {
                    if (__result___22 == 0) {
                      tmp___383 = strupper(S2);
                      __result___22 = (int )((int const   )(*(__s1___14 + 2)) - (int const   )(*((unsigned char const   *)((char const   *)tmp___383) +
                                                                                                 2)));
                      if (__s2_len > 2U) {
                        if (__result___22 == 0) {
                          tmp___384 = strupper(S2);
                          __result___22 = (int )((int const   )(*(__s1___14 + 3)) -
                                                 (int const   )(*((unsigned char const   *)((char const   *)tmp___384) +
                                                                  3)));
                        }
                      }
                    }
                  }
                }
              }
              tmp___216 = __result___22;
            }
          } else {
            tmp___389 = strupper(S2);
            tmp___390 = strupper(S1);
            tmp___216 = __builtin_strcmp(tmp___390, tmp___389);
          }
        } else {
          tmp___389 = strupper(S2);
          tmp___390 = strupper(S1);
          tmp___216 = __builtin_strcmp(tmp___390, tmp___389);
        }
      } else {
        tmp___389 = strupper(S2);
        tmp___390 = strupper(S1);
        tmp___216 = __builtin_strcmp(tmp___390, tmp___389);
      }
    }
  }
  return (tmp___216);
}
}
static struct AudioVariables AudV[4]  ;
static unsigned char *UnpBuf  ;
static unsigned int BitField  ;
static unsigned int Number  ;
static unsigned char InBuf[8192]  ;
static unsigned char UnpOldTable[1028]  ;
static unsigned int InAddr  ;
static unsigned int InBit  ;
static unsigned int ReadTop  ;
static unsigned int LastDist  ;
static unsigned int LastLength  ;
static unsigned int Length  ;
static unsigned int Distance  ;
static unsigned int OldDist[4]  ;
static unsigned int OldDistPtr  ;
static struct LitDecode LD  ;
static struct DistDecode DD  ;
static struct RepDecode RD  ;
static struct MultDecode MD[4]  ;
static struct BitDecode BD  ;
static struct MultDecode *MDPtr[4]  = {      MD,      & MD[1],      & MD[2],      & MD[3]};
static int UnpAudioBlock  ;
static int UnpChannels  ;
static int CurChannel  ;
static int ChannelDelta  ;
static unsigned char LDecode[28]  = 
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)8,      (unsigned char)10,      (unsigned char)12,      (unsigned char)14, 
        (unsigned char)16,      (unsigned char)20,      (unsigned char)24,      (unsigned char)28, 
        (unsigned char)32,      (unsigned char)40,      (unsigned char)48,      (unsigned char)56, 
        (unsigned char)64,      (unsigned char)80,      (unsigned char)96,      (unsigned char)112, 
        (unsigned char)128,      (unsigned char)160,      (unsigned char)192,      (unsigned char)224};
static unsigned char LBits[28]  = 
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)3,      (unsigned char)3,      (unsigned char)3,      (unsigned char)3, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5};
static int DDecode[48]  = 
  {      0,      1,      2,      3, 
        4,      6,      8,      12, 
        16,      24,      32,      48, 
        64,      96,      128,      192, 
        256,      384,      512,      768, 
        1024,      1536,      2048,      3072, 
        4096,      6144,      8192,      12288, 
        16384,      24576,      32768,      49152, 
        65536,      98304,      131072,      196608, 
        262144,      327680,      393216,      458752, 
        524288,      589824,      655360,      720896, 
        786432,      851968,      917504,      983040};
static unsigned char DBits[48]  = 
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)3,      (unsigned char)3,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)6,      (unsigned char)6, 
        (unsigned char)7,      (unsigned char)7,      (unsigned char)8,      (unsigned char)8, 
        (unsigned char)9,      (unsigned char)9,      (unsigned char)10,      (unsigned char)10, 
        (unsigned char)11,      (unsigned char)11,      (unsigned char)12,      (unsigned char)12, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)14,      (unsigned char)14, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)16,      (unsigned char)16, 
        (unsigned char)16,      (unsigned char)16,      (unsigned char)16,      (unsigned char)16, 
        (unsigned char)16,      (unsigned char)16,      (unsigned char)16,      (unsigned char)16, 
        (unsigned char)16,      (unsigned char)16,      (unsigned char)16,      (unsigned char)16};
static unsigned char SDDecode[8]  = 
  {      (unsigned char)0,      (unsigned char)4,      (unsigned char)8,      (unsigned char)16, 
        (unsigned char)32,      (unsigned char)64,      (unsigned char)128,      (unsigned char)192};
static unsigned char SDBits[8]  = 
  {      (unsigned char)2,      (unsigned char)2,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)6};
static void Unpack(unsigned char *UnpAddr , BOOL FileFound ) 
{ unsigned int Bits ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;

  {
  UnpBuf = UnpAddr;
  UnpInitData();
  UnpReadBuf(1);
  if (! ((int )NewLhd.Flags & 16)) {
    ReadTables();
  }
  DestUnpSize --;
  while (DestUnpSize >= 0L) {
    UnpPtr &= 1048575U;
    if (InAddr > sizeof(InBuf) - 30U) {
      UnpReadBuf(0);
    }
    if (((WrPtr - UnpPtr) & 1048575U) < 270U) {
      if (WrPtr != UnpPtr) {
        if (FileFound) {
          if (UnpPtr < WrPtr) {
            if (((*temp_output_buffer_offset) + (unsigned long )((0U - WrPtr) & 1048575U)) +
                (unsigned long )UnpPtr > NewLhd.UnpSize) {
              cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 1417, "Fatal! Buffer overrun during decompression!");
              DestUnpSize = -1L;
            } else {
              memcpy((void * __restrict  )(temp_output_buffer + (*temp_output_buffer_offset)),
                     (void const   * __restrict  )(UnpBuf + WrPtr), (0U - WrPtr) &
                                                                    1048575U);
              (*temp_output_buffer_offset) += (unsigned long )((0U - WrPtr) & 1048575U);
              memcpy((void * __restrict  )(temp_output_buffer + (*temp_output_buffer_offset)),
                     (void const   * __restrict  )UnpBuf, UnpPtr);
              (*temp_output_buffer_offset) += (unsigned long )UnpPtr;
            }
          } else {
            if ((*temp_output_buffer_offset) + (unsigned long )(UnpPtr - WrPtr) >
                NewLhd.UnpSize) {
              cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 1437, "Fatal! Buffer overrun during decompression!");
              DestUnpSize = -1L;
            } else {
              memcpy((void * __restrict  )(temp_output_buffer + (*temp_output_buffer_offset)),
                     (void const   * __restrict  )(UnpBuf + WrPtr), UnpPtr - WrPtr);
              (*temp_output_buffer_offset) += (unsigned long )(UnpPtr - WrPtr);
            }
          }
        }
        WrPtr = UnpPtr;
      }
    }
    if (UnpAudioBlock) {
      DecodeNumber((struct Decode *)MDPtr[CurChannel]);
      if (Number == 256U) {
        ReadTables();
        continue;
      }
      tmp = UnpPtr;
      UnpPtr ++;
      (*(UnpBuf + tmp)) = DecodeAudio((int )Number);
      CurChannel ++;
      if (CurChannel == UnpChannels) {
        CurChannel = 0;
      }
      DestUnpSize --;
      continue;
    }
    DecodeNumber((struct Decode *)(& LD));
    if (Number < 256U) {
      tmp___0 = UnpPtr;
      UnpPtr ++;
      (*(UnpBuf + tmp___0)) = (unsigned char )Number;
      DestUnpSize --;
      continue;
    }
    if (Number > 269U) {
      Number -= 270U;
      Length = (unsigned int )((int )LDecode[Number] + 3);
      Bits = (unsigned int )LBits[Number];
      if (Bits > 0U) {
        BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                             1U]) <<
                                                                                               8)) |
                                     (unsigned long )InBuf[InAddr + 2U]) >> (8U -
                                                                             InBit)) &
                                   65535UL);
        Length += BitField >> (16U - Bits);
        InAddr += (InBit + Bits) >> 3;
        InBit = (InBit + Bits) & 7U;
      }
      DecodeNumber((struct Decode *)(& DD));
      Distance = (unsigned int )(DDecode[Number] + 1);
      Bits = (unsigned int )DBits[Number];
      if (Bits > 0U) {
        BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                             1U]) <<
                                                                                               8)) |
                                     (unsigned long )InBuf[InAddr + 2U]) >> (8U -
                                                                             InBit)) &
                                   65535UL);
        Distance += BitField >> (16U - Bits);
        InAddr += (InBit + Bits) >> 3;
        InBit = (InBit + Bits) & 7U;
      }
      if ((unsigned long )Distance >= 262144UL) {
        Length ++;
      }
      if (Distance >= 8192U) {
        Length ++;
      }
      tmp___1 = OldDistPtr;
      OldDistPtr ++;
      OldDist[tmp___1 & 3U] = Distance;
      LastDist = OldDist[tmp___1 & 3U];
      LastLength = Length;
      DestUnpSize = (long )((unsigned long )DestUnpSize - (unsigned long )LastLength);
      while (1) {
        tmp___2 = Length;
        Length --;
        if (! tmp___2) {
          break;
        }
        (*(UnpBuf + UnpPtr)) = (*(UnpBuf + ((UnpPtr - Distance) & 1048575U)));
        UnpPtr = (UnpPtr + 1U) & 1048575U;
      }
      continue;
    }
    if (Number == 269U) {
      ReadTables();
      continue;
    }
    if (Number == 256U) {
      Length = LastLength;
      Distance = LastDist;
      tmp___3 = OldDistPtr;
      OldDistPtr ++;
      OldDist[tmp___3 & 3U] = Distance;
      LastDist = OldDist[tmp___3 & 3U];
      LastLength = Length;
      DestUnpSize = (long )((unsigned long )DestUnpSize - (unsigned long )LastLength);
      while (1) {
        tmp___4 = Length;
        Length --;
        if (! tmp___4) {
          break;
        }
        (*(UnpBuf + UnpPtr)) = (*(UnpBuf + ((UnpPtr - Distance) & 1048575U)));
        UnpPtr = (UnpPtr + 1U) & 1048575U;
      }
      continue;
    }
    if (Number < 261U) {
      Distance = OldDist[(OldDistPtr - (Number - 256U)) & 3U];
      DecodeNumber((struct Decode *)(& RD));
      Length = (unsigned int )((int )LDecode[Number] + 2);
      Bits = (unsigned int )LBits[Number];
      if (Bits > 0U) {
        BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                             1U]) <<
                                                                                               8)) |
                                     (unsigned long )InBuf[InAddr + 2U]) >> (8U -
                                                                             InBit)) &
                                   65535UL);
        Length += BitField >> (16U - Bits);
        InAddr += (InBit + Bits) >> 3;
        InBit = (InBit + Bits) & 7U;
      }
      if (Distance >= 262144U) {
        Length ++;
      }
      if (Distance >= 8192U) {
        Length ++;
      }
      if (Distance >= 257U) {
        Length ++;
      }
      tmp___5 = OldDistPtr;
      OldDistPtr ++;
      OldDist[tmp___5 & 3U] = Distance;
      LastDist = OldDist[tmp___5 & 3U];
      LastLength = Length;
      DestUnpSize = (long )((unsigned long )DestUnpSize - (unsigned long )LastLength);
      while (1) {
        tmp___6 = Length;
        Length --;
        if (! tmp___6) {
          break;
        }
        (*(UnpBuf + UnpPtr)) = (*(UnpBuf + ((UnpPtr - Distance) & 1048575U)));
        UnpPtr = (UnpPtr + 1U) & 1048575U;
      }
      continue;
    }
    if (Number < 270U) {
      Number -= 261U;
      Distance = (unsigned int )((int )SDDecode[Number] + 1);
      Bits = (unsigned int )SDBits[Number];
      if (Bits > 0U) {
        BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                             1U]) <<
                                                                                               8)) |
                                     (unsigned long )InBuf[InAddr + 2U]) >> (8U -
                                                                             InBit)) &
                                   65535UL);
        Distance += BitField >> (16U - Bits);
        InAddr += (InBit + Bits) >> 3;
        InBit = (InBit + Bits) & 7U;
      }
      Length = 2U;
      tmp___7 = OldDistPtr;
      OldDistPtr ++;
      OldDist[tmp___7 & 3U] = Distance;
      LastDist = OldDist[tmp___7 & 3U];
      LastLength = Length;
      DestUnpSize = (long )((unsigned long )DestUnpSize - (unsigned long )LastLength);
      while (1) {
        tmp___8 = Length;
        Length --;
        if (! tmp___8) {
          break;
        }
        (*(UnpBuf + UnpPtr)) = (*(UnpBuf + ((UnpPtr - Distance) & 1048575U)));
        UnpPtr = (UnpPtr + 1U) & 1048575U;
      }
      continue;
    }
  }
  ReadLastTables();
  if (FileFound) {
    if (UnpPtr < WrPtr) {
      if (((*temp_output_buffer_offset) + (unsigned long )((0U - WrPtr) & 1048575U)) +
          (unsigned long )UnpPtr > NewLhd.UnpSize) {
        cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 1583, "Fatal! Buffer overrun during decompression!");
        DestUnpSize = -1L;
      } else {
        memcpy((void * __restrict  )(temp_output_buffer + (*temp_output_buffer_offset)),
               (void const   * __restrict  )(UnpBuf + WrPtr), (0U - WrPtr) & 1048575U);
        (*temp_output_buffer_offset) += (unsigned long )((0U - WrPtr) & 1048575U);
        memcpy((void * __restrict  )(temp_output_buffer + (*temp_output_buffer_offset)),
               (void const   * __restrict  )UnpBuf, UnpPtr);
        (*temp_output_buffer_offset) += (unsigned long )UnpPtr;
      }
    } else {
      if ((*temp_output_buffer_offset) + (unsigned long )(UnpPtr - WrPtr) > NewLhd.UnpSize) {
        cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 1601, "Fatal! Buffer overrun during decompression!");
        DestUnpSize = -1L;
      } else {
        memcpy((void * __restrict  )(temp_output_buffer + (*temp_output_buffer_offset)),
               (void const   * __restrict  )(UnpBuf + WrPtr), UnpPtr - WrPtr);
        (*temp_output_buffer_offset) += (unsigned long )(UnpPtr - WrPtr);
      }
    }
  }
  WrPtr = UnpPtr;
  return;
}
}
static unsigned int UnpRead(unsigned char *Addr , unsigned int Count ) 
{ int RetCode ;
  unsigned int I ;
  unsigned int ReadSize ;
  unsigned int TotalRead ;
  unsigned char *ReadAddr ;
  unsigned long tmp ;

  {
  RetCode = 0;
  TotalRead = 0U;
  ReadAddr = Addr;
  while (Count > 0U) {
    if ((unsigned long )Count > (unsigned long )UnpPackedSize) {
      tmp = (unsigned long )UnpPackedSize;
    } else {
      tmp = (unsigned long )Count;
    }
    ReadSize = (unsigned int )tmp;
    if ((unsigned int )ArcPtr == (unsigned int )((void *)0)) {
      return (0U);
    }
    RetCode = tread((void *)ArcPtr, (void *)ReadAddr, ReadSize);
    CurUnpRead += (unsigned long )RetCode;
    ReadAddr += RetCode;
    TotalRead += (unsigned int )RetCode;
    Count -= (unsigned int )RetCode;
    UnpPackedSize -= (long )RetCode;
    break;
  }
  cli_dbgmsg("CurUnpRead == %d, TotalRead == %d, Count == %d, UnpPackedSize == %d\n",
             CurUnpRead, TotalRead, Count, UnpPackedSize);
  if (RetCode != -1) {
    RetCode = (int )TotalRead;
    if (Encryption) {
      if (Encryption < 20) {
        cli_dbgmsg("unrarlib: Old Crypt() not supported!");
      } else {
        I = 0U;
        while (I < (unsigned int )RetCode) {
          DecryptBlock(Addr + I);
          I += 16U;
        }
      }
    }
  }
  return ((unsigned int )RetCode);
}
}
static void UnpReadBuf(int FirstBuf ) 
{ int RetCode ;

  {
  if (FirstBuf) {
    ReadTop = UnpRead(InBuf, sizeof(InBuf));
    InAddr = 0U;
  } else {
    memcpy((void * __restrict  )(InBuf), (void const   * __restrict  )(& InBuf[sizeof(InBuf) -
                                                                               32U]),
           32U);
    InAddr &= 31U;
    RetCode = (int )UnpRead(& InBuf[32], sizeof(InBuf) - 32U);
    if (RetCode > 0) {
      ReadTop = (unsigned int )(RetCode + 32);
    } else {
      ReadTop = InAddr;
    }
  }
  return;
}
}
static void ReadTables(void) 
{ UBYTE BitLength[19] ;
  unsigned char Table[1028] ;
  int TableSize ;
  int N ;
  int I ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (InAddr > sizeof(InBuf) - 25U) {
    UnpReadBuf(0);
  }
  BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                       1U]) <<
                                                                                         8)) |
                               (unsigned long )InBuf[InAddr + 2U]) >> (8U - InBit)) &
                             65535UL);
  UnpAudioBlock = (int )(BitField & 32768U);
  if (! (BitField & 16384U)) {
    memset((void *)(UnpOldTable), 0, sizeof(UnpOldTable));
  }
  InAddr += (InBit + 2U) >> 3;
  InBit = (InBit + 2U) & 7U;
  if (UnpAudioBlock) {
    UnpChannels = (int )(((BitField >> 12) & 3U) + 1U);
    if (CurChannel >= UnpChannels) {
      CurChannel = 0;
    }
    InAddr += (InBit + 2U) >> 3;
    InBit = (InBit + 2U) & 7U;
    TableSize = 257 * UnpChannels;
  } else {
    TableSize = 374;
  }
  I = 0;
  while (I < 19) {
    BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                         1U]) <<
                                                                                           8)) |
                                 (unsigned long )InBuf[InAddr + 2U]) >> (8U - InBit)) &
                               65535UL);
    BitLength[I] = (unsigned char )(BitField >> 12);
    InAddr += (InBit + 4U) >> 3;
    InBit = (InBit + 4U) & 7U;
    I ++;
  }
  MakeDecodeTables(BitLength, (struct Decode *)(& BD), 19);
  I = 0;
  while (I < TableSize) {
    if (InAddr > sizeof(InBuf) - 5U) {
      UnpReadBuf(0);
    }
    DecodeNumber((struct Decode *)(& BD));
    if (Number < 16U) {
      Table[I] = (unsigned char )((Number + (unsigned int )UnpOldTable[I]) & 15U);
      I ++;
    } else {
      if (Number == 16U) {
        BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                             1U]) <<
                                                                                               8)) |
                                     (unsigned long )InBuf[InAddr + 2U]) >> (8U -
                                                                             InBit)) &
                                   65535UL);
        N = (int )((BitField >> 14) + 3U);
        InAddr += (InBit + 2U) >> 3;
        InBit = (InBit + 2U) & 7U;
        while (1) {
          tmp = N;
          N --;
          if (tmp > 0) {
            if (! (I < TableSize)) {
              break;
            }
          } else {
            break;
          }
          Table[I] = Table[I - 1];
          I ++;
        }
      } else {
        if (Number == 17U) {
          BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                               1U]) <<
                                                                                                 8)) |
                                       (unsigned long )InBuf[InAddr + 2U]) >> (8U -
                                                                               InBit)) &
                                     65535UL);
          N = (int )((BitField >> 13) + 3U);
          InAddr += (InBit + 3U) >> 3;
          InBit = (InBit + 3U) & 7U;
        } else {
          BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                               1U]) <<
                                                                                                 8)) |
                                       (unsigned long )InBuf[InAddr + 2U]) >> (8U -
                                                                               InBit)) &
                                     65535UL);
          N = (int )((BitField >> 9) + 11U);
          InAddr += (InBit + 7U) >> 3;
          InBit = (InBit + 7U) & 7U;
        }
        while (1) {
          tmp___1 = N;
          N --;
          if (tmp___1 > 0) {
            if (! (I < TableSize)) {
              break;
            }
          } else {
            break;
          }
          tmp___0 = I;
          I ++;
          Table[tmp___0] = (unsigned char)0;
        }
      }
    }
  }
  if (UnpAudioBlock) {
    I = 0;
    while (I < UnpChannels) {
      MakeDecodeTables(& Table[I * 257], (struct Decode *)MDPtr[I], 257);
      I ++;
    }
  } else {
    MakeDecodeTables(Table, (struct Decode *)(& LD), 298);
    MakeDecodeTables(& Table[298], (struct Decode *)(& DD), 48);
    MakeDecodeTables(& Table[346], (struct Decode *)(& RD), 28);
  }
  memcpy((void * __restrict  )(UnpOldTable), (void const   * __restrict  )(Table),
         sizeof(UnpOldTable));
  return;
}
}
static void ReadLastTables(void) 
{ 

  {
  if (ReadTop >= InAddr + 5U) {
    if (UnpAudioBlock) {
      DecodeNumber((struct Decode *)MDPtr[CurChannel]);
      if (Number == 256U) {
        ReadTables();
      }
    } else {
      DecodeNumber((struct Decode *)(& LD));
      if (Number == 269U) {
        ReadTables();
      }
    }
  }
  return;
}
}
static void MakeDecodeTables(unsigned char *LenTab , struct Decode *Dec , int Size ) 
{ int LenCount[16] ;
  int TmpPos[16] ;
  int I ;
  long M ;
  long N ;
  int tmp ;

  {
  memset((void *)(LenCount), 0, sizeof(LenCount));
  I = 0;
  while (I < Size) {
    LenCount[(int )(*(LenTab + I)) & 15] = LenCount[(int )(*(LenTab + I)) & 15] +
                                           1;
    I ++;
  }
  LenCount[0] = 0;
  Dec->DecodeLen[0] = 0U;
  Dec->DecodePos[0] = Dec->DecodeLen[0];
  TmpPos[0] = (int )Dec->DecodePos[0];
  N = 0L;
  I = 1;
  while (I < 16) {
    N = 2L * (N + (long )LenCount[I]);
    M = N << (15 - I);
    if (M > 65535L) {
      M = 65535L;
    }
    Dec->DecodeLen[I] = (unsigned int )M;
    Dec->DecodePos[I] = Dec->DecodePos[I - 1] + (unsigned int )LenCount[I - 1];
    TmpPos[I] = (int )Dec->DecodePos[I];
    I ++;
  }
  I = 0;
  while (I < Size) {
    if ((int )(*(LenTab + I)) != 0) {
      tmp = TmpPos[(int )(*(LenTab + I)) & 15];
      TmpPos[(int )(*(LenTab + I)) & 15] = TmpPos[(int )(*(LenTab + I)) & 15] + 1;
      Dec->DecodeNum[tmp] = (unsigned int )I;
    }
    I ++;
  }
  Dec->MaxNum = (unsigned int )Size;
  return;
}
}
static void DecodeNumber(struct Decode *Deco ) 
{ unsigned int I ;
  register unsigned int N ;

  {
  BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                       1U]) <<
                                                                                         8)) |
                               (unsigned long )InBuf[InAddr + 2U]) >> (8U - InBit)) &
                             65535UL);
  N = BitField & 65534U;
  if (N < Deco->DecodeLen[8]) {
    if (N < Deco->DecodeLen[4]) {
      if (N < Deco->DecodeLen[2]) {
        if (N < Deco->DecodeLen[1]) {
          I = 1U;
        } else {
          I = 2U;
        }
      } else {
        if (N < Deco->DecodeLen[3]) {
          I = 3U;
        } else {
          I = 4U;
        }
      }
    } else {
      if (N < Deco->DecodeLen[6]) {
        if (N < Deco->DecodeLen[5]) {
          I = 5U;
        } else {
          I = 6U;
        }
      } else {
        if (N < Deco->DecodeLen[7]) {
          I = 7U;
        } else {
          I = 8U;
        }
      }
    }
  } else {
    if (N < Deco->DecodeLen[12]) {
      if (N < Deco->DecodeLen[10]) {
        if (N < Deco->DecodeLen[9]) {
          I = 9U;
        } else {
          I = 10U;
        }
      } else {
        if (N < Deco->DecodeLen[11]) {
          I = 11U;
        } else {
          I = 12U;
        }
      }
    } else {
      if (N < Deco->DecodeLen[14]) {
        if (N < Deco->DecodeLen[13]) {
          I = 13U;
        } else {
          I = 14U;
        }
      } else {
        I = 15U;
      }
    }
  }
  InAddr += (InBit + I) >> 3;
  InBit = (InBit + I) & 7U;
  N = Deco->DecodePos[I] + ((N - Deco->DecodeLen[I - 1U]) >> (16U - I));
  if (N >= Deco->MaxNum) {
    N = 0U;
  }
  Number = Deco->DecodeNum[N];
  return;
}
}
static void UnpInitData(void) 
{ 

  {
  InBit = 0U;
  InAddr = InBit;
  if (! ((int )NewLhd.Flags & 16)) {
    CurChannel = 0;
    ChannelDelta = CurChannel;
    memset((void *)(AudV), 0, sizeof(AudV));
    memset((void *)(OldDist), 0, sizeof(OldDist));
    OldDistPtr = 0U;
    LastLength = 0U;
    LastDist = LastLength;
    memset((void *)UnpBuf, 0, 1048576U);
    memset((void *)(UnpOldTable), 0, sizeof(UnpOldTable));
    WrPtr = 0U;
    UnpPtr = WrPtr;
  }
  return;
}
}
static UBYTE DecodeAudio(int Delta ) 
{ struct AudioVariables *V ;
  unsigned int Ch ;
  unsigned int NumMinDif ;
  unsigned int MinDif ;
  int PCh ;
  int I ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  V = & AudV[CurChannel];
  V->ByteCount ++;
  V->D4 = V->D3;
  V->D3 = V->D2;
  V->D2 = V->LastDelta - V->D1;
  V->D1 = V->LastDelta;
  PCh = ((((8 * V->LastChar + V->K1 * V->D1) + V->K2 * V->D2) + V->K3 * V->D3) + V->K4 *
                                                                                 V->D4) +
        V->K5 * ChannelDelta;
  PCh = (PCh >> 3) & 255;
  Ch = (unsigned int )(PCh - Delta);
  I = (int )((signed char )Delta) << 3;
  tmp = abs(I);
  V->Dif[0] += (unsigned int )tmp;
  tmp___0 = abs(I - V->D1);
  V->Dif[1] += (unsigned int )tmp___0;
  tmp___1 = abs(I + V->D1);
  V->Dif[2] += (unsigned int )tmp___1;
  tmp___2 = abs(I - V->D2);
  V->Dif[3] += (unsigned int )tmp___2;
  tmp___3 = abs(I + V->D2);
  V->Dif[4] += (unsigned int )tmp___3;
  tmp___4 = abs(I - V->D3);
  V->Dif[5] += (unsigned int )tmp___4;
  tmp___5 = abs(I + V->D3);
  V->Dif[6] += (unsigned int )tmp___5;
  tmp___6 = abs(I - V->D4);
  V->Dif[7] += (unsigned int )tmp___6;
  tmp___7 = abs(I + V->D4);
  V->Dif[8] += (unsigned int )tmp___7;
  tmp___8 = abs(I - ChannelDelta);
  V->Dif[9] += (unsigned int )tmp___8;
  tmp___9 = abs(I + ChannelDelta);
  V->Dif[10] += (unsigned int )tmp___9;
  V->LastDelta = (int )((signed char )(Ch - (unsigned int )V->LastChar));
  ChannelDelta = V->LastDelta;
  V->LastChar = (int )Ch;
  if ((V->ByteCount & 31U) == 0U) {
    MinDif = V->Dif[0];
    NumMinDif = 0U;
    V->Dif[0] = 0U;
    I = 1;
    while ((unsigned int )I < sizeof(V->Dif) / sizeof(V->Dif[0])) {
      if (V->Dif[I] < MinDif) {
        MinDif = V->Dif[I];
        NumMinDif = (unsigned int )I;
      }
      V->Dif[I] = 0U;
      I ++;
    }
    switch ((int )NumMinDif) {
    case 1: ;
    if (V->K1 >= -16) {
      V->K1 --;
    }
    break;
    case 2: ;
    if (V->K1 < 16) {
      V->K1 ++;
    }
    break;
    case 3: ;
    if (V->K2 >= -16) {
      V->K2 --;
    }
    break;
    case 4: ;
    if (V->K2 < 16) {
      V->K2 ++;
    }
    break;
    case 5: ;
    if (V->K3 >= -16) {
      V->K3 --;
    }
    break;
    case 6: ;
    if (V->K3 < 16) {
      V->K3 ++;
    }
    break;
    case 7: ;
    if (V->K4 >= -16) {
      V->K4 --;
    }
    break;
    case 8: ;
    if (V->K4 < 16) {
      V->K4 ++;
    }
    break;
    case 9: ;
    if (V->K5 >= -16) {
      V->K5 --;
    }
    break;
    case 10: ;
    if (V->K5 < 16) {
      V->K5 ++;
    }
    break;
    }
  }
  return ((unsigned char )Ch);
}
}
static UDWORD CRCTab[256]  ;
static UBYTE SubstTable[256]  ;
static UBYTE const   InitSubstTable[256]  = 
  {      (UBYTE const   )(unsigned char)215,      (UBYTE const   )(unsigned char)19,      (UBYTE const   )(unsigned char)149,      (UBYTE const   )(unsigned char)35, 
        (UBYTE const   )(unsigned char)73,      (UBYTE const   )(unsigned char)197,      (UBYTE const   )(unsigned char)192,      (UBYTE const   )(unsigned char)205, 
        (UBYTE const   )(unsigned char)249,      (UBYTE const   )(unsigned char)28,      (UBYTE const   )(unsigned char)16,      (UBYTE const   )(unsigned char)119, 
        (UBYTE const   )(unsigned char)48,      (UBYTE const   )(unsigned char)221,      (UBYTE const   )(unsigned char)2,      (UBYTE const   )(unsigned char)42, 
        (UBYTE const   )(unsigned char)232,      (UBYTE const   )(unsigned char)1,      (UBYTE const   )(unsigned char)177,      (UBYTE const   )(unsigned char)233, 
        (UBYTE const   )(unsigned char)14,      (UBYTE const   )(unsigned char)88,      (UBYTE const   )(unsigned char)219,      (UBYTE const   )(unsigned char)25, 
        (UBYTE const   )(unsigned char)223,      (UBYTE const   )(unsigned char)195,      (UBYTE const   )(unsigned char)244,      (UBYTE const   )(unsigned char)90, 
        (UBYTE const   )(unsigned char)87,      (UBYTE const   )(unsigned char)239,      (UBYTE const   )(unsigned char)153,      (UBYTE const   )(unsigned char)137, 
        (UBYTE const   )(unsigned char)255,      (UBYTE const   )(unsigned char)199,      (UBYTE const   )(unsigned char)147,      (UBYTE const   )(unsigned char)70, 
        (UBYTE const   )(unsigned char)92,      (UBYTE const   )(unsigned char)66,      (UBYTE const   )(unsigned char)246,      (UBYTE const   )(unsigned char)13, 
        (UBYTE const   )(unsigned char)216,      (UBYTE const   )(unsigned char)40,      (UBYTE const   )(unsigned char)62,      (UBYTE const   )(unsigned char)29, 
        (UBYTE const   )(unsigned char)217,      (UBYTE const   )(unsigned char)230,      (UBYTE const   )(unsigned char)86,      (UBYTE const   )(unsigned char)6, 
        (UBYTE const   )(unsigned char)71,      (UBYTE const   )(unsigned char)24,      (UBYTE const   )(unsigned char)171,      (UBYTE const   )(unsigned char)196, 
        (UBYTE const   )(unsigned char)101,      (UBYTE const   )(unsigned char)113,      (UBYTE const   )(unsigned char)218,      (UBYTE const   )(unsigned char)123, 
        (UBYTE const   )(unsigned char)93,      (UBYTE const   )(unsigned char)91,      (UBYTE const   )(unsigned char)163,      (UBYTE const   )(unsigned char)178, 
        (UBYTE const   )(unsigned char)202,      (UBYTE const   )(unsigned char)67,      (UBYTE const   )(unsigned char)44,      (UBYTE const   )(unsigned char)235, 
        (UBYTE const   )(unsigned char)107,      (UBYTE const   )(unsigned char)250,      (UBYTE const   )(unsigned char)75,      (UBYTE const   )(unsigned char)234, 
        (UBYTE const   )(unsigned char)49,      (UBYTE const   )(unsigned char)167,      (UBYTE const   )(unsigned char)125,      (UBYTE const   )(unsigned char)211, 
        (UBYTE const   )(unsigned char)83,      (UBYTE const   )(unsigned char)114,      (UBYTE const   )(unsigned char)157,      (UBYTE const   )(unsigned char)144, 
        (UBYTE const   )(unsigned char)32,      (UBYTE const   )(unsigned char)193,      (UBYTE const   )(unsigned char)143,      (UBYTE const   )(unsigned char)36, 
        (UBYTE const   )(unsigned char)158,      (UBYTE const   )(unsigned char)124,      (UBYTE const   )(unsigned char)247,      (UBYTE const   )(unsigned char)187, 
        (UBYTE const   )(unsigned char)89,      (UBYTE const   )(unsigned char)214,      (UBYTE const   )(unsigned char)141,      (UBYTE const   )(unsigned char)47, 
        (UBYTE const   )(unsigned char)121,      (UBYTE const   )(unsigned char)228,      (UBYTE const   )(unsigned char)61,      (UBYTE const   )(unsigned char)130, 
        (UBYTE const   )(unsigned char)213,      (UBYTE const   )(unsigned char)194,      (UBYTE const   )(unsigned char)174,      (UBYTE const   )(unsigned char)251, 
        (UBYTE const   )(unsigned char)97,      (UBYTE const   )(unsigned char)110,      (UBYTE const   )(unsigned char)54,      (UBYTE const   )(unsigned char)229, 
        (UBYTE const   )(unsigned char)115,      (UBYTE const   )(unsigned char)57,      (UBYTE const   )(unsigned char)152,      (UBYTE const   )(unsigned char)94, 
        (UBYTE const   )(unsigned char)105,      (UBYTE const   )(unsigned char)243,      (UBYTE const   )(unsigned char)212,      (UBYTE const   )(unsigned char)55, 
        (UBYTE const   )(unsigned char)209,      (UBYTE const   )(unsigned char)245,      (UBYTE const   )(unsigned char)63,      (UBYTE const   )(unsigned char)11, 
        (UBYTE const   )(unsigned char)164,      (UBYTE const   )(unsigned char)200,      (UBYTE const   )(unsigned char)31,      (UBYTE const   )(unsigned char)156, 
        (UBYTE const   )(unsigned char)81,      (UBYTE const   )(unsigned char)176,      (UBYTE const   )(unsigned char)227,      (UBYTE const   )(unsigned char)21, 
        (UBYTE const   )(unsigned char)76,      (UBYTE const   )(unsigned char)99,      (UBYTE const   )(unsigned char)139,      (UBYTE const   )(unsigned char)188, 
        (UBYTE const   )(unsigned char)127,      (UBYTE const   )(unsigned char)17,      (UBYTE const   )(unsigned char)248,      (UBYTE const   )(unsigned char)51, 
        (UBYTE const   )(unsigned char)207,      (UBYTE const   )(unsigned char)120,      (UBYTE const   )(unsigned char)189,      (UBYTE const   )(unsigned char)210, 
        (UBYTE const   )(unsigned char)8,      (UBYTE const   )(unsigned char)226,      (UBYTE const   )(unsigned char)41,      (UBYTE const   )(unsigned char)72, 
        (UBYTE const   )(unsigned char)183,      (UBYTE const   )(unsigned char)203,      (UBYTE const   )(unsigned char)135,      (UBYTE const   )(unsigned char)165, 
        (UBYTE const   )(unsigned char)166,      (UBYTE const   )(unsigned char)60,      (UBYTE const   )(unsigned char)98,      (UBYTE const   )(unsigned char)7, 
        (UBYTE const   )(unsigned char)122,      (UBYTE const   )(unsigned char)38,      (UBYTE const   )(unsigned char)155,      (UBYTE const   )(unsigned char)170, 
        (UBYTE const   )(unsigned char)69,      (UBYTE const   )(unsigned char)172,      (UBYTE const   )(unsigned char)252,      (UBYTE const   )(unsigned char)238, 
        (UBYTE const   )(unsigned char)39,      (UBYTE const   )(unsigned char)134,      (UBYTE const   )(unsigned char)59,      (UBYTE const   )(unsigned char)128, 
        (UBYTE const   )(unsigned char)236,      (UBYTE const   )(unsigned char)27,      (UBYTE const   )(unsigned char)240,      (UBYTE const   )(unsigned char)80, 
        (UBYTE const   )(unsigned char)131,      (UBYTE const   )(unsigned char)3,      (UBYTE const   )(unsigned char)85,      (UBYTE const   )(unsigned char)206, 
        (UBYTE const   )(unsigned char)145,      (UBYTE const   )(unsigned char)79,      (UBYTE const   )(unsigned char)154,      (UBYTE const   )(unsigned char)142, 
        (UBYTE const   )(unsigned char)159,      (UBYTE const   )(unsigned char)220,      (UBYTE const   )(unsigned char)201,      (UBYTE const   )(unsigned char)133, 
        (UBYTE const   )(unsigned char)74,      (UBYTE const   )(unsigned char)64,      (UBYTE const   )(unsigned char)20,      (UBYTE const   )(unsigned char)129, 
        (UBYTE const   )(unsigned char)224,      (UBYTE const   )(unsigned char)185,      (UBYTE const   )(unsigned char)138,      (UBYTE const   )(unsigned char)103, 
        (UBYTE const   )(unsigned char)173,      (UBYTE const   )(unsigned char)182,      (UBYTE const   )(unsigned char)43,      (UBYTE const   )(unsigned char)34, 
        (UBYTE const   )(unsigned char)254,      (UBYTE const   )(unsigned char)82,      (UBYTE const   )(unsigned char)198,      (UBYTE const   )(unsigned char)151, 
        (UBYTE const   )(unsigned char)231,      (UBYTE const   )(unsigned char)180,      (UBYTE const   )(unsigned char)58,      (UBYTE const   )(unsigned char)10, 
        (UBYTE const   )(unsigned char)118,      (UBYTE const   )(unsigned char)26,      (UBYTE const   )(unsigned char)102,      (UBYTE const   )(unsigned char)12, 
        (UBYTE const   )(unsigned char)50,      (UBYTE const   )(unsigned char)132,      (UBYTE const   )(unsigned char)22,      (UBYTE const   )(unsigned char)191, 
        (UBYTE const   )(unsigned char)136,      (UBYTE const   )(unsigned char)111,      (UBYTE const   )(unsigned char)162,      (UBYTE const   )(unsigned char)179, 
        (UBYTE const   )(unsigned char)45,      (UBYTE const   )(unsigned char)4,      (UBYTE const   )(unsigned char)148,      (UBYTE const   )(unsigned char)108, 
        (UBYTE const   )(unsigned char)161,      (UBYTE const   )(unsigned char)56,      (UBYTE const   )(unsigned char)78,      (UBYTE const   )(unsigned char)126, 
        (UBYTE const   )(unsigned char)242,      (UBYTE const   )(unsigned char)222,      (UBYTE const   )(unsigned char)15,      (UBYTE const   )(unsigned char)175, 
        (UBYTE const   )(unsigned char)146,      (UBYTE const   )(unsigned char)23,      (UBYTE const   )(unsigned char)33,      (UBYTE const   )(unsigned char)241, 
        (UBYTE const   )(unsigned char)181,      (UBYTE const   )(unsigned char)190,      (UBYTE const   )(unsigned char)77,      (UBYTE const   )(unsigned char)225, 
        (UBYTE const   )(unsigned char)0,      (UBYTE const   )(unsigned char)46,      (UBYTE const   )(unsigned char)169,      (UBYTE const   )(unsigned char)186, 
        (UBYTE const   )(unsigned char)68,      (UBYTE const   )(unsigned char)95,      (UBYTE const   )(unsigned char)237,      (UBYTE const   )(unsigned char)65, 
        (UBYTE const   )(unsigned char)53,      (UBYTE const   )(unsigned char)208,      (UBYTE const   )(unsigned char)253,      (UBYTE const   )(unsigned char)168, 
        (UBYTE const   )(unsigned char)9,      (UBYTE const   )(unsigned char)18,      (UBYTE const   )(unsigned char)100,      (UBYTE const   )(unsigned char)52, 
        (UBYTE const   )(unsigned char)116,      (UBYTE const   )(unsigned char)184,      (UBYTE const   )(unsigned char)160,      (UBYTE const   )(unsigned char)96, 
        (UBYTE const   )(unsigned char)109,      (UBYTE const   )(unsigned char)37,      (UBYTE const   )(unsigned char)30,      (UBYTE const   )(unsigned char)106, 
        (UBYTE const   )(unsigned char)140,      (UBYTE const   )(unsigned char)104,      (UBYTE const   )(unsigned char)150,      (UBYTE const   )(unsigned char)5, 
        (UBYTE const   )(unsigned char)204,      (UBYTE const   )(unsigned char)117,      (UBYTE const   )(unsigned char)112,      (UBYTE const   )(unsigned char)84};
static UDWORD Key[4]  ;
static void EncryptBlock(UBYTE *Buf ) 
{ int I ;
  UDWORD A ;
  UDWORD B ;
  UDWORD C ;
  UDWORD D ;
  UDWORD T ;
  UDWORD TA ;
  UDWORD TB ;
  UDWORD *BufPtr ;

  {
  BufPtr = (UDWORD *)Buf;
  A = (*(BufPtr + 0)) ^ Key[0];
  B = (*(BufPtr + 1)) ^ Key[1];
  C = (*(BufPtr + 2)) ^ Key[2];
  D = (*(BufPtr + 3)) ^ Key[3];
  I = 0;
  while (I < 32) {
    T = (C + ((D << 11) | (D >> (8U * sizeof(D) - 11U)))) ^ Key[I & 3];
    TA = A ^ ((((unsigned long )SubstTable[(int )T & 255] | ((unsigned long )SubstTable[(int )(T >>
                                                                                               8) &
                                                                                        255] <<
                                                             8)) | ((unsigned long )SubstTable[(int )(T >>
                                                                                                      16) &
                                                                                               255] <<
                                                                    16)) | ((unsigned long )SubstTable[(int )(T >>
                                                                                                              24) &
                                                                                                       255] <<
                                                                            24));
    T = (D ^ ((C << 17) | (C >> (8U * sizeof(C) - 17U)))) + Key[I & 3];
    TB = B ^ ((((unsigned long )SubstTable[(int )T & 255] | ((unsigned long )SubstTable[(int )(T >>
                                                                                               8) &
                                                                                        255] <<
                                                             8)) | ((unsigned long )SubstTable[(int )(T >>
                                                                                                      16) &
                                                                                               255] <<
                                                                    16)) | ((unsigned long )SubstTable[(int )(T >>
                                                                                                              24) &
                                                                                                       255] <<
                                                                            24));
    A = C;
    B = D;
    C = TA;
    D = TB;
    I ++;
  }
  (*(BufPtr + 0)) = C ^ Key[0];
  (*(BufPtr + 1)) = D ^ Key[1];
  (*(BufPtr + 2)) = A ^ Key[2];
  (*(BufPtr + 3)) = B ^ Key[3];
  UpdKeys(Buf);
  return;
}
}
static void DecryptBlock(unsigned char *Buf ) 
{ int I ;
  UBYTE InBuf___0[16] ;
  UDWORD A ;
  UDWORD B ;
  UDWORD C ;
  UDWORD D ;
  UDWORD T ;
  UDWORD TA ;
  UDWORD TB ;
  UDWORD *BufPtr ;

  {
  BufPtr = (UDWORD *)Buf;
  A = (*(BufPtr + 0)) ^ Key[0];
  B = (*(BufPtr + 1)) ^ Key[1];
  C = (*(BufPtr + 2)) ^ Key[2];
  D = (*(BufPtr + 3)) ^ Key[3];
  memcpy((void * __restrict  )(InBuf___0), (void const   * __restrict  )Buf, sizeof(InBuf___0));
  I = 31;
  while (I >= 0) {
    T = (C + ((D << 11) | (D >> (8U * sizeof(D) - 11U)))) ^ Key[I & 3];
    TA = A ^ ((((unsigned long )SubstTable[(int )T & 255] | ((unsigned long )SubstTable[(int )(T >>
                                                                                               8) &
                                                                                        255] <<
                                                             8)) | ((unsigned long )SubstTable[(int )(T >>
                                                                                                      16) &
                                                                                               255] <<
                                                                    16)) | ((unsigned long )SubstTable[(int )(T >>
                                                                                                              24) &
                                                                                                       255] <<
                                                                            24));
    T = (D ^ ((C << 17) | (C >> (8U * sizeof(C) - 17U)))) + Key[I & 3];
    TB = B ^ ((((unsigned long )SubstTable[(int )T & 255] | ((unsigned long )SubstTable[(int )(T >>
                                                                                               8) &
                                                                                        255] <<
                                                             8)) | ((unsigned long )SubstTable[(int )(T >>
                                                                                                      16) &
                                                                                               255] <<
                                                                    16)) | ((unsigned long )SubstTable[(int )(T >>
                                                                                                              24) &
                                                                                                       255] <<
                                                                            24));
    A = C;
    B = D;
    C = TA;
    D = TB;
    I --;
  }
  (*(BufPtr + 0)) = C ^ Key[0];
  (*(BufPtr + 1)) = D ^ Key[1];
  (*(BufPtr + 2)) = A ^ Key[2];
  (*(BufPtr + 3)) = B ^ Key[3];
  UpdKeys(InBuf___0);
  return;
}
}
static void UpdKeys(UBYTE *Buf ) 
{ int I ;

  {
  I = 0;
  while (I < 16) {
    Key[0] ^= CRCTab[(*(Buf + I))];
    Key[1] ^= CRCTab[(*(Buf + (I + 1)))];
    Key[2] ^= CRCTab[(*(Buf + (I + 2)))];
    Key[3] ^= CRCTab[(*(Buf + (I + 3)))];
    I += 4;
  }
  return;
}
}
static void SetCryptKeys(char *NewPassword ) 
{ unsigned int I ;
  unsigned int J ;
  unsigned int K ;
  unsigned int PswLength ;
  unsigned char N1 ;
  unsigned char N2 ;
  unsigned char Psw[256] ;
  UBYTE Ch ;

  {
  SetOldKeys(NewPassword);
  Key[0] = 3550722169UL;
  Key[1] = 1064112887UL;
  Key[2] = 1964352053UL;
  Key[3] = 2766663971UL;
  memset((void *)(Psw), 0, sizeof(Psw));
  strcpy((char * __restrict  )((char *)(Psw)), (char const   * __restrict  )NewPassword);
  PswLength = strlen((char const   *)NewPassword);
  memcpy((void * __restrict  )(SubstTable), (void const   * __restrict  )(InitSubstTable),
         sizeof(SubstTable));
  J = 0U;
  while (J < 256U) {
    I = 0U;
    while (I < PswLength) {
      N2 = (unsigned char )CRCTab[((unsigned int )Psw[I + 1U] + J) & 255U];
      K = 1U;
      N1 = (unsigned char )CRCTab[((unsigned int )Psw[I] - J) & 255U];
      while ((int )N1 != (int )N2) {
        Ch = SubstTable[N1];
        SubstTable[N1] = SubstTable[(((unsigned int )N1 + I) + K) & 255U];
        SubstTable[(((unsigned int )N1 + I) + K) & 255U] = Ch;
        N1 = (unsigned char )((int )N1 + 1);
        K ++;
      }
      I += 2U;
    }
    J ++;
  }
  I = 0U;
  while (I < PswLength) {
    EncryptBlock(& Psw[I]);
    I += 16U;
  }
  return;
}
}
static void SetOldKeys(char *NewPassword ) 
{ UDWORD PswCRC ;
  UBYTE Ch ;
  UDWORD tmp ;

  {
  tmp = (UDWORD )strlen((char const   *)NewPassword);
  PswCRC = CalcCRC32(4294967295UL, (UBYTE *)NewPassword, tmp);
  OldKey[0] = (unsigned short )PswCRC;
  OldKey[1] = (unsigned short )(PswCRC >> 16);
  OldKey[3] = (unsigned short)0;
  OldKey[2] = OldKey[3];
  PN3 = (unsigned char)0;
  PN2 = PN3;
  PN1 = PN2;
  while (1) {
    Ch = (unsigned char )(*NewPassword);
    if (! ((int )Ch != 0)) {
      break;
    }
    PN1 = (unsigned char )((int )PN1 + (int )Ch);
    PN2 = (unsigned char )((int )PN2 ^ (int )Ch);
    PN3 = (unsigned char )((int )PN3 + (int )Ch);
    PN3 = (unsigned char )(((int )PN3 << 1) | ((int )PN3 >> (8U * sizeof(PN3) - 1U)));
    OldKey[2] = (unsigned short )((int )OldKey[2] ^ (int )((unsigned short )((unsigned long )Ch ^
                                                                             CRCTab[Ch])));
    OldKey[3] = (unsigned short )((int )OldKey[3] + (int )((unsigned short )((unsigned long )Ch +
                                                                             (CRCTab[Ch] >>
                                                                              16))));
    NewPassword ++;
  }
  return;
}
}
static short crcInitialized  =    (short)0;
static void InitCRC(void) 
{ int I ;
  int J ;
  UDWORD C ;

  {
  if (crcInitialized) {
    return;
  }
  cli_dbgmsg("%s:%d:%s Initialize CRC table\n", "unrarlib.c", 2652, "InitCRC");
  I = 0;
  while (I < 256) {
    C = (unsigned long )I;
    J = 0;
    while (J < 8) {
      if (C & 1UL) {
        C = (C >> 1) ^ 3988292384UL;
      } else {
        C = C >> 1;
      }
      J ++;
    }
    CRCTab[I] = C;
    I ++;
  }
  crcInitialized = (short)1;
  return;
}
}
static UDWORD CalcCRC32(UDWORD StartCRC , UBYTE *Addr , UDWORD Size ) 
{ unsigned int I ;

  {
  I = 0U;
  while ((unsigned long )I < Size) {
    StartCRC = CRCTab[(int )((unsigned char )StartCRC) ^ (int )(*(Addr + I))] ^ (StartCRC >>
                                                                                 8);
    I ++;
  }
  return (StartCRC);
}
}
#pragma merger(0,"/tmp/cil-9nF29J93.i","-g -O2 -fPIC")
int zzip_errno(int errcode ) ;
ZZIP_DIR *zzip_opendir(zzip_char_t *filename ) ;
int zzip_closedir(ZZIP_DIR *dir ) ;
ZZIP_DIRENT *zzip_readdir(ZZIP_DIR *dir ) ;
void zzip_rewinddir(ZZIP_DIR *dir ) ;
zzip_off_t zzip_telldir(ZZIP_DIR *dir ) ;
void zzip_seekdir(ZZIP_DIR *dir , zzip_off_t offset ) ;
ZZIP_DIR *zzip_opendir_ext_io(zzip_char_t *filename , int o_modes , zzip_strings_t *ext___0 ,
                              zzip_plugin_io_t io ) ;
ZZIP_DIR *zzip_dir_open_ext_io(zzip_char_t *filename , zzip_error_t *e , zzip_strings_t *ext___0 ,
                               zzip_plugin_io_t io ) ;
void zzip_rewinddir(ZZIP_DIR *dir ) 
{ 

  {
  if (! dir) {
    return;
  }
  if (dir->hdr0) {
    dir->hdr = dir->hdr0;
  } else {
    dir->hdr = (struct zzip_dir_hdr *)0;
  }
  return;
}
}
ZZIP_DIRENT *zzip_readdir(ZZIP_DIR *dir ) 
{ int *tmp ;

  {
  if (! dir) {
    tmp = __errno_location();
    (*tmp) = 9;
    return ((ZZIP_DIRENT *)0);
  }
  if (! dir->hdr) {
    return ((ZZIP_DIRENT *)0);
  }
  dir->dirent.d_name = (dir->hdr)->d_name;
  dir->dirent.d_compr = (int )(dir->hdr)->d_compr;
  dir->dirent.d_csize = (int )(dir->hdr)->d_csize;
  dir->dirent.st_size = (int )(dir->hdr)->d_usize;
  dir->dirent.d_flags = (dir->hdr)->d_flags;
  dir->dirent.d_crc32 = (int )(dir->hdr)->d_crc32;
  if (! (dir->hdr)->d_reclen) {
    dir->hdr = (struct zzip_dir_hdr *)0;
  } else {
    dir->hdr = (struct zzip_dir_hdr *)((char *)dir->hdr + (int )(dir->hdr)->d_reclen);
  }
  return (& dir->dirent);
}
}
zzip_off_t zzip_telldir(ZZIP_DIR *dir ) 
{ int *tmp ;

  {
  if (! dir) {
    tmp = __errno_location();
    (*tmp) = 9;
    return (-1L);
  }
  return ((long )((char *)dir->hdr - (char *)dir->hdr0));
}
}
void zzip_seekdir(ZZIP_DIR *dir , zzip_off_t offset ) 
{ char *tmp ;

  {
  if (! dir) {
    return;
  }
  if (dir->hdr0) {
    tmp = (char *)dir->hdr0 + (unsigned int )offset;
  } else {
    tmp = (char *)0;
  }
  dir->hdr = (struct zzip_dir_hdr *)tmp;
  return;
}
}
ZZIP_DIR *zzip_opendir(zzip_char_t *filename ) 
{ ZZIP_DIR *tmp ;

  {
  tmp = zzip_opendir_ext_io(filename, 0, (zzip_strings_t *)0, (struct zzip_plugin_io  const  *)0);
  return (tmp);
}
}
ZZIP_DIR *zzip_opendir_ext_io(zzip_char_t *filename , int o_modes , zzip_strings_t *ext___0 ,
                              zzip_plugin_io_t io ) 
{ zzip_error_t e ;
  ZZIP_DIR *dir ;
  struct stat st ;
  int tmp ;
  int *tmp___0 ;

  {
  if (o_modes & 81920) {
    goto try_zzip;
  }
  try_real: 
  tmp = stat__extinline(filename, & st);
  if (tmp >= 0) {
    if ((st.st_mode & 61440U) == 16384U) {
      return ((ZZIP_DIR *)0);
    }
  }
  try_zzip: 
  dir = zzip_dir_open_ext_io(filename, & e, ext___0, io);
  if (! dir) {
    if (o_modes & 16384) {
      goto try_real;
    }
  }
  if (e) {
    tmp___0 = __errno_location();
    (*tmp___0) = zzip_errno((int )e);
  }
  return (dir);
}
}
int zzip_closedir(ZZIP_DIR *dir ) 
{ int *tmp ;

  {
  if (! dir) {
    tmp = __errno_location();
    (*tmp) = 9;
    return (-1);
  }
  zzip_dir_close(dir);
  return (0);
}
}
#pragma merger(0,"/tmp/cil-fpr6n4nJ.i","-g -O2 -fPIC")
zzip_char_t *zzip_strerror(int errcode ) ;
zzip_char_t *zzip_strerror_of(ZZIP_DIR *dir ) ;
extern char const   *zError(int  ) ;
static struct errlistentry errlist[14]  = 
  {      {0, "No error"}, 
        {-4116, "could not get temporary memory for internal structures"}, 
        {-4117, "Failed to open zip-file %s"}, 
        {-4118, "Failed to fstat zip-file %s"}, 
        {-4119, "Failed to lseek zip-file %s"}, 
        {-4120, "Failed to read zip-file %s"}, 
        {-4121, "zip-file %s too short"}, 
        {-4122, "zip-file central directory not found"}, 
        {-4123, "Directory size too big..."}, 
        {-4124, "No such file found in zip-file %s"}, 
        {-4125, "Unsupported compression format"}, 
        {-4127, "Zipfile corrupted"}, 
        {-4128, "Some undefined error occurred"}, 
        {0, (char const   *)0}};
zzip_char_t *zzip_strerror(int errcode ) 
{ struct errlistentry *err ;
  zzip_char_t *tmp ;
  zzip_char_t *tmp___0 ;
  zzip_char_t *tmp___1 ;

  {
  if (errcode < -4096) {
    if (errcode > -4128) {
      err = errlist;
      while (err->mesg) {
        if (err->code == errcode) {
          return (err->mesg);
        }
        err ++;
      }
      errcode = 22;
    }
  }
  if (errcode < 0) {
    if (errcode == -1) {
      tmp = strerror(errcode);
      return (tmp);
    } else {
      tmp___0 = zError(errcode);
      return (tmp___0);
    }
  }
  tmp___1 = strerror(errcode);
  return (tmp___1);
}
}
zzip_char_t *zzip_strerror_of(ZZIP_DIR *dir ) 
{ int *tmp ;
  zzip_char_t *tmp___0 ;
  zzip_char_t *tmp___1 ;

  {
  if (! dir) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    return (tmp___0);
  }
  tmp___1 = zzip_strerror(dir->errcode);
  return (tmp___1);
}
}
static struct errnolistentry errnolist[18]  = 
  {      {-2, 32}, 
        {-3, 29}, 
        {-4, 12}, 
        {-5, 24}, 
        {-6, 8}, 
        {-4117, 20}, 
        {-4118, 66}, 
        {-4119, 29}, 
        {-4120, 86}, 
        {-4121, 8}, 
        {-4122, 123}, 
        {-4123, 27}, 
        {-4116, 12}, 
        {-4124, 2}, 
        {-4125, 96}, 
        {-4127, 84}, 
        {-4128, 22}, 
        {0, 0}};
int zzip_errno(int errcode ) 
{ int *tmp ;
  struct errnolistentry *err ;

  {
  if (errcode >= -1) {
    tmp = __errno_location();
    return ((*tmp));
  }
  err = errnolist;
  while (err->code) {
    if (err->code == errcode) {
      return (err->e_no);
    }
    err ++;
  }
  return (22);
}
}
#pragma merger(0,"/tmp/cil-M7hGkpNS.i","-g -O2 -fPIC")
ZZIP_FILE *zzip_open(zzip_char_t *filename , int o_flags ) ;
int zzip_close(ZZIP_FILE *fp ) ;
zzip_ssize_t zzip_read(ZZIP_FILE *fp , char *buf , zzip_size_t len ) ;
ZZIP_FILE *zzip_freopen(zzip_char_t *filename , zzip_char_t *mode , ZZIP_FILE *stream ) ;
ZZIP_FILE *zzip_fopen(zzip_char_t *filename , zzip_char_t *mode ) ;
zzip_size_t zzip_fread(void *ptr , zzip_size_t size , zzip_size_t nmemb , ZZIP_FILE *file ) ;
int zzip_fclose(ZZIP_FILE *fp ) ;
int zzip_rewind(ZZIP_FILE *fp ) ;
zzip_off_t zzip_seek(ZZIP_FILE *fp , zzip_off_t offset , int whence ) ;
zzip_off_t zzip_tell(ZZIP_FILE *fp ) ;
ZZIP_FILE *zzip_open_shared_io(ZZIP_FILE *stream , zzip_char_t *filename , int o_flags ,
                               int o_modes , zzip_strings_t *ext___0 , zzip_plugin_io_t io ) ;
ZZIP_FILE *zzip_open_ext_io(zzip_char_t *filename , int o_flags , int o_modes , zzip_strings_t *ext___0 ,
                            zzip_plugin_io_t io ) ;
zzip_plugin_io_t zzip_get_default_io(void) ;
int __zzip_try_open(zzip_char_t *filename , int filemode , zzip_strings_t *ext___0 ,
                    zzip_plugin_io_t io ) ;
ZZIP_DIR *zzip_dir_fdopen_ext_io(int fd , zzip_error_t *errcode_p , zzip_strings_t *ext___0 ,
                                 zzip_plugin_io_t io ) ;
extern int inflate(z_streamp strm , int flush ) ;
extern int inflateEnd(z_streamp strm ) ;
extern int inflateInit2_(z_streamp strm , int windowBits , char const   *version ,
                         int stream_size ) ;
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
int zzip_file_close(ZZIP_FILE *fp ) 
{ ZZIP_DIR *dir ;
  int tmp ;

  {
  dir = fp->dir;
  if (fp->method) {
    inflateEnd(& fp->d_stream);
  }
  if (fp->buf32k) {
    if ((unsigned int )dir->cache.buf32k == (unsigned int )((void *)0)) {
      dir->cache.buf32k = fp->buf32k;
    } else {
      free((void *)fp->buf32k);
    }
  }
  if ((unsigned int )dir->currentfp == (unsigned int )fp) {
    dir->currentfp = (struct zzip_file *)((void *)0);
  }
  dir->refcount = dir->refcount - 1L;
  memset((void *)fp, 0, sizeof((*fp)));
  if ((unsigned int )dir->cache.fp == (unsigned int )((void *)0)) {
    dir->cache.fp = fp;
  } else {
    free((void *)fp);
  }
  if (! dir->refcount) {
    tmp = zzip_dir_close(dir);
    return (tmp);
  } else {
    return (0);
  }
}
}
static int zzip_file_saveoffset(ZZIP_FILE *fp ) 
{ int fd ;
  zzip_off_t off ;
  zzip_off_t tmp ;

  {
  if (fp) {
    fd = (fp->dir)->fd;
    tmp = ((*((fp->io)->seeks)))(fd, 0L, 1);
    off = tmp;
    if (off < 0L) {
      return (-1);
    }
    fp->offset = off;
  }
  return (0);
}
}
static zzip_char_t *_dirsep_strrchr(zzip_char_t *name ) 
{ char *n ;
  char *tmp ;
  char *m ;
  char *tmp___0 ;

  {
  tmp = strrchr(name, '/');
  n = tmp;
  tmp___0 = strrchr(name, '\\');
  m = tmp___0;
  if (m) {
    if (n) {
      if ((unsigned int )m > (unsigned int )n) {
        n = m;
      }
    }
  }
  return ((zzip_char_t *)n);
}
}
static int _dirsep_casecmp(zzip_char_t *s1 , zzip_char_t *s2 ) ;
static char const   mapping[33]  = 
  {      (char const   )'@',      (char const   )'a',      (char const   )'b',      (char const   )'c', 
        (char const   )'d',      (char const   )'e',      (char const   )'f',      (char const   )'g', 
        (char const   )'h',      (char const   )'i',      (char const   )'j',      (char const   )'k', 
        (char const   )'l',      (char const   )'m',      (char const   )'n',      (char const   )'o', 
        (char const   )'p',      (char const   )'q',      (char const   )'r',      (char const   )'s', 
        (char const   )'t',      (char const   )'u',      (char const   )'v',      (char const   )'w', 
        (char const   )'x',      (char const   )'y',      (char const   )'z',      (char const   )'[', 
        (char const   )'/',      (char const   )']',      (char const   )'^',      (char const   )'_', 
        (char const   )'\000'};
static int _dirsep_casecmp(zzip_char_t *s1 , zzip_char_t *s2 ) 
{ int c1 ;
  int c2 ;

  {
  while (1) {
    if ((*s1)) {
      if (! (*s2)) {
        break;
      }
    } else {
      break;
    }
    c1 = (int )((unsigned char )(*s1));
    c2 = (int )((unsigned char )(*s2));
    if ((c1 & 224) == 64) {
      c1 = (int )mapping[c1 & 31];
    }
    if ((c1 & 224) == 64) {
      c2 = (int )mapping[c2 & 31];
    }
    if (c1 != c2) {
      return (c1 - c2);
    }
    s1 ++;
    s2 ++;
  }
  return ((int )((unsigned char )(*s1)) - (int )((unsigned char )(*s2)));
}
}
static int zzip_inflate_init(ZZIP_FILE *fp , struct zzip_dir_hdr *hdr ) ;
ZZIP_FILE *zzip_file_open(ZZIP_DIR *dir , zzip_char_t *name , int o_mode ) 
{ zzip_error_t err ;
  struct zzip_file *fp ;
  struct zzip_dir_hdr *hdr ;
  int (*cmp)(zzip_char_t * , zzip_char_t * ) ;
  register zzip_char_t *n ;
  zzip_char_t *tmp ;
  register zzip_char_t *hdr_name ;
  register zzip_char_t *n___0 ;
  zzip_char_t *tmp___0 ;
  int tmp___3 ;
  zzip_off_t tmp___4 ;
  zzip_ssize_t dataoff ;
  struct zzip_file_header *p ;
  zzip_off_t tmp___5 ;
  int tmp___6 ;

  {
  err = (enum __anonenum_zzip_error_t_37 )0;
  fp = (struct zzip_file *)0;
  hdr = dir->hdr0;
  if (o_mode & 4096) {
    cmp = & _dirsep_casecmp;
  } else {
    cmp = & strcmp;
  }
  if (! dir) {
    return ((ZZIP_FILE *)0);
  } else {
    if (! dir->fd) {
      return ((ZZIP_FILE *)0);
    } else {
      if (dir->fd == -1) {
        return ((ZZIP_FILE *)0);
      }
    }
  }
  if (o_mode & 8192) {
    tmp = _dirsep_strrchr(name);
    n = tmp;
    if (n) {
      name = n + 1;
    }
  }
  if (hdr) {
    while (1) {
      hdr_name = (zzip_char_t *)(hdr->d_name);
      if (o_mode & 8192) {
        tmp___0 = _dirsep_strrchr(hdr_name);
        n___0 = tmp___0;
        if (n___0) {
          hdr_name = n___0 + 1;
        }
      }
      tmp___6 = ((*cmp))(hdr_name, name);
      if (tmp___6) {
        if ((int )hdr->d_reclen == 0) {
          break;
        }
        hdr = (struct zzip_dir_hdr *)((char *)hdr + (int )hdr->d_reclen);
      } else {
        switch ((int )hdr->d_compr) {
        case 0: ;
        case 1: ;
        case 6: ;
        case 8: ;
        case 9: ;
        break;
        default: 
        cli_dbgmsg("ZzipLib: Unsupported compression mode (%d)\n", hdr->d_compr);
        err = (enum __anonenum_zzip_error_t_37 )-4125;
        goto error;
        }
        if (dir->cache.fp) {
          fp = dir->cache.fp;
          dir->cache.fp = (struct zzip_file *)((void *)0);
        } else {
          fp = (struct zzip_file *)calloc(1U, sizeof((*fp)));
          if (! fp) {
            err = (enum __anonenum_zzip_error_t_37 )-4116;
            goto error;
          }
        }
        fp->dir = dir;
        fp->io = dir->io;
        dir->refcount = dir->refcount + 1L;
        if (dir->cache.buf32k) {
          fp->buf32k = dir->cache.buf32k;
          dir->cache.buf32k = (char *)((void *)0);
        } else {
          fp->buf32k = (char *)malloc(32768U);
          if (! fp->buf32k) {
            err = (enum __anonenum_zzip_error_t_37 )-4116;
            goto error;
          }
        }
        tmp___3 = zzip_file_saveoffset(dir->currentfp);
        if (tmp___3 < 0) {
          err = (enum __anonenum_zzip_error_t_37 )-4119;
          goto error;
        }
        fp->offset = (long )hdr->d_off;
        dir->currentfp = fp;
        tmp___4 = ((*((dir->io)->seeks)))(dir->fd, (long )hdr->d_off, 0);
        if (tmp___4 < 0L) {
          err = (enum __anonenum_zzip_error_t_37 )-4119;
          goto error;
        }
        p = (struct zzip_file_header *)((void *)fp->buf32k);
        dataoff = ((*((dir->io)->read)))(dir->fd, (void *)p, sizeof((*p)));
        if (dataoff < (int )sizeof((*p))) {
          err = (enum __anonenum_zzip_error_t_37 )-4120;
          goto error;
        }
        dataoff = (int )(*((uint16_t *)(p->z_namlen))) + (int )(*((uint16_t *)(p->z_extras)));
        tmp___5 = ((*((dir->io)->seeks)))(dir->fd, (long )dataoff, 1);
        if (tmp___5 < 0L) {
          err = (enum __anonenum_zzip_error_t_37 )-4119;
          goto error;
        }
        fp->dataoffset = ((*((dir->io)->seeks)))(dir->fd, 0L, 1);
        fp->usize = hdr->d_usize;
        fp->csize = hdr->d_csize;
        err = (zzip_error_t )zzip_inflate_init(fp, hdr);
        if (err) {
          goto error;
        }
        return (fp);
      }
    }
  }
  dir->errcode = -4124;
  zzip_errno(-4124);
  return ((ZZIP_FILE *)((void *)0));
  error: 
  if (fp) {
    zzip_file_close(fp);
  }
  dir->errcode = (int )err;
  zzip_errno((int )err);
  return ((ZZIP_FILE *)((void *)0));
}
}
static int zzip_inflate_init(ZZIP_FILE *fp , struct zzip_dir_hdr *hdr ) 
{ int err ;

  {
  fp->method = (int )hdr->d_compr;
  fp->restlen = hdr->d_usize;
  if (fp->method) {
    memset((void *)(& fp->d_stream), 0, sizeof(fp->d_stream));
    err = inflateInit2_(& fp->d_stream, -15, "1.2.2", (int )sizeof(z_stream ));
    if (err != 0) {
      goto error;
    }
    fp->crestlen = hdr->d_csize;
  }
  return (0);
  error: 
  if (fp) {
    zzip_file_close(fp);
  }
  return (err);
}
}
int zzip_fclose(ZZIP_FILE *fp ) 
{ int r ;
  int tmp ;
  int tmp___0 ;

  {
  if (! fp) {
    return (0);
  }
  if (! fp->dir) {
    tmp = ((*((fp->io)->close)))(fp->fd);
    r = tmp;
    free((void *)fp);
    return (r);
  } else {
    tmp___0 = zzip_file_close(fp);
    return (tmp___0);
  }
}
}
int zzip_close(ZZIP_FILE *fp ) 
{ int tmp ;

  {
  tmp = zzip_fclose(fp);
  return (tmp);
}
}
zzip_ssize_t zzip_file_read(ZZIP_FILE *fp , char *buf , zzip_size_t len ) 
{ ZZIP_DIR *dir ;
  zzip_size_t l ;
  zzip_ssize_t rv ;
  int tmp ;
  zzip_off_t tmp___0 ;
  int err ;
  zzip_size_t startlen ;
  zzip_size_t cl ;
  zzip_size_t tmp___1 ;
  zzip_ssize_t i ;
  zzip_ssize_t tmp___2 ;

  {
  if (! fp) {
    return (0);
  } else {
    if (! fp->dir) {
      return (0);
    }
  }
  dir = fp->dir;
  if (fp->restlen > len) {
    l = len;
  } else {
    l = fp->restlen;
  }
  if (fp->restlen == 0U) {
    return (0);
  }
  if ((unsigned int )dir->currentfp != (unsigned int )fp) {
    tmp = zzip_file_saveoffset(dir->currentfp);
    if (tmp < 0) {
      dir->errcode = -4119;
      return (-1);
    } else {
      tmp___0 = ((*((fp->io)->seeks)))(dir->fd, fp->offset, 0);
      if (tmp___0 < 0L) {
        dir->errcode = -4119;
        return (-1);
      } else {
        dir->currentfp = fp;
      }
    }
  }
  if (fp->method) {
    fp->d_stream.avail_out = l;
    fp->d_stream.next_out = (unsigned char *)buf;
    while (1) {
      if (fp->crestlen > 0U) {
        if (fp->d_stream.avail_in == 0U) {
          if (fp->crestlen < 32768U) {
            tmp___1 = fp->crestlen;
          } else {
            tmp___1 = 32768U;
          }
          cl = tmp___1;
          tmp___2 = ((*((fp->io)->read)))(dir->fd, (void *)fp->buf32k, cl);
          i = tmp___2;
          if (i <= 0) {
            dir->errcode = -4120;
            return (-1);
          }
          fp->crestlen = fp->crestlen - (unsigned int )i;
          fp->d_stream.avail_in = (unsigned int )i;
          fp->d_stream.next_in = (unsigned char *)fp->buf32k;
        }
      }
      startlen = (unsigned int )fp->d_stream.total_out;
      err = inflate(& fp->d_stream, 0);
      if (err == 1) {
        fp->restlen = 0U;
      } else {
        if (err == 0) {
          fp->restlen = (unsigned int )((unsigned long )fp->restlen - (fp->d_stream.total_out -
                                                                       (unsigned long )startlen));
        } else {
          dir->errcode = err;
          return (-1);
        }
      }
      if (fp->restlen) {
        if (! fp->d_stream.avail_out) {
          break;
        }
      } else {
        break;
      }
    }
    return ((int )(l - fp->d_stream.avail_out));
  } else {
    rv = ((*((fp->io)->read)))(dir->fd, (void *)buf, l);
    if (rv > 0) {
      fp->restlen = fp->restlen - (unsigned int )rv;
    } else {
      if (rv < 0) {
        dir->errcode = -4120;
      }
    }
    return (rv);
  }
}
}
zzip_ssize_t zzip_read(ZZIP_FILE *fp , char *buf , zzip_size_t len ) 
{ zzip_ssize_t tmp ;
  register zzip_ssize_t v ;
  int *tmp___0 ;

  {
  if (! fp) {
    return (0);
  }
  if (! fp->dir) {
    tmp = ((*((fp->io)->read)))(fp->fd, (void *)buf, len);
    return (tmp);
  } else {
    v = zzip_file_read(fp, buf, len);
    if (v == -1) {
      tmp___0 = __errno_location();
      (*tmp___0) = zzip_errno((fp->dir)->errcode);
    }
    return (v);
  }
}
}
zzip_size_t zzip_fread(void *ptr , zzip_size_t size , zzip_size_t nmemb , ZZIP_FILE *file ) 
{ zzip_ssize_t tmp ;

  {
  if (! size) {
    size = 1U;
  }
  tmp = zzip_read(file, (char *)ptr, size * nmemb);
  return ((unsigned int )tmp / size);
}
}
ZZIP_FILE *zzip_fopen(zzip_char_t *filename , zzip_char_t *mode ) 
{ ZZIP_FILE *tmp ;

  {
  tmp = zzip_freopen(filename, mode, (ZZIP_FILE *)0);
  return (tmp);
}
}
ZZIP_FILE *zzip_freopen(zzip_char_t *filename , zzip_char_t *mode , ZZIP_FILE *stream ) 
{ int o_flags ;
  int o_modes ;
  int tmp ;
  int tmp___0 ;
  ZZIP_FILE *fp ;
  ZZIP_FILE *tmp___1 ;

  {
  o_flags = 0;
  o_modes = 436;
  if (! mode) {
    mode = "rb";
  }
  while ((*mode)) {
    switch ((int )(*mode)) {
    case 48: ;
    case 49: ;
    case 50: ;
    case 51: ;
    case 52: ;
    case 53: ;
    case 54: ;
    case 55: ;
    case 56: ;
    case 57: ;
    goto __Cont;
    case 114: ;
    if ((int const   )(*(mode + 1)) == 43) {
      tmp = 2;
    } else {
      tmp = 0;
    }
    o_flags |= tmp;
    break;
    case 119: ;
    if ((int const   )(*(mode + 1)) == 43) {
      tmp___0 = 2;
    } else {
      tmp___0 = 1;
    }
    o_flags |= tmp___0;
    o_flags |= 512;
    break;
    case 98: 
    o_flags |= 0;
    break;
    case 102: 
    o_flags |= 256;
    break;
    case 105: 
    o_modes |= 4096;
    break;
    case 42: 
    o_modes |= 8192;
    break;
    case 120: 
    o_flags |= 128;
    break;
    case 115: 
    o_flags |= 4096;
    break;
    case 110: 
    o_flags |= 2048;
    break;
    case 111: 
    o_modes &= -8;
    o_modes |= (int )(((int const   )(*(mode + 1)) - 48) & 7);
    goto __Cont;
    case 103: 
    o_modes &= -57;
    o_modes |= (int )((((int const   )(*(mode + 1)) - 48) << 3) & 56);
    goto __Cont;
    case 117: 
    o_modes &= -449;
    o_modes |= (int )((((int const   )(*(mode + 1)) - 48) << 6) & 448);
    goto __Cont;
    case 113: 
    o_modes |= 131072;
    break;
    case 122: ;
    goto __Cont;
    }
    __Cont: 
    mode ++;
  }
  tmp___1 = zzip_open_shared_io(stream, filename, o_flags, o_modes, (zzip_strings_t *)0,
                                (struct zzip_plugin_io  const  *)0);
  fp = tmp___1;
  if (((! o_modes != 0) != 0) & 131072) {
    if (stream) {
      zzip_file_close(stream);
    }
  }
  return (fp);
}
}
ZZIP_FILE *zzip_open(zzip_char_t *filename , int o_flags ) 
{ int o_modes ;
  ZZIP_FILE *tmp ;

  {
  o_modes = 436;
  if (o_flags & 1024) {
    o_flags ^= 1024;
    o_modes |= 4096;
  }
  if (o_flags & 512) {
    o_flags ^= 512;
    o_modes |= 8192;
  }
  tmp = zzip_open_ext_io(filename, o_flags, o_modes, (zzip_strings_t *)0, (struct zzip_plugin_io  const  *)0);
  return (tmp);
}
}
ZZIP_FILE *zzip_open_ext_io(zzip_char_t *filename , int o_flags , int o_modes , zzip_strings_t *ext___0 ,
                            zzip_plugin_io_t io ) 
{ ZZIP_FILE *tmp ;

  {
  tmp = zzip_open_shared_io((ZZIP_FILE *)0, filename, o_flags, o_modes, ext___0, io);
  return (tmp);
}
}
ZZIP_FILE *zzip_open_shared_io(ZZIP_FILE *stream , zzip_char_t *filename , int o_flags ,
                               int o_modes , zzip_strings_t *ext___0 , zzip_plugin_io_t io ) 
{ zzip_plugin_io_t os ;
  zzip_plugin_io_t tmp___0 ;
  int fd ;
  int tmp___1 ;
  ZZIP_FILE *fp ;
  ZZIP_FILE *tmp___2 ;
  int *tmp___3 ;
  char basename[4096] ;
  char *p ;
  zzip_size_t len ;
  zzip_size_t tmp___4 ;
  ZZIP_FILE *fp___0 ;
  ZZIP_FILE *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  zzip_error_t e ;
  ZZIP_DIR *dir ;
  ZZIP_FILE *fp___1 ;
  int fd___0 ;
  int *tmp___8 ;
  int *tmp___9 ;
  size_t __len___2 ;
  size_t tmp___26 ;
  char *__retval___2 ;
  char *tmp___27 ;
  int tmp___29 ;
  int *tmp___30 ;

  {
  if (stream) {
    if (stream->dir) {
      if (! ext___0) {
        ext___0 = (stream->dir)->fileext;
      }
      if (! io) {
        io = (stream->dir)->io;
      }
    }
  }
  if (! io) {
    io = zzip_get_default_io();
  }
  if (o_modes & 81920) {
    goto try_zzip;
  }
  try_real: 
  if (o_modes & 262144) {
    tmp___0 = zzip_get_default_io();
  } else {
    tmp___0 = io;
  }
  os = tmp___0;
  tmp___1 = ((*(os->open)))(filename, o_flags);
  fd = tmp___1;
  if (fd != -1) {
    tmp___2 = (ZZIP_FILE *)calloc(1U, sizeof(ZZIP_FILE ));
    fp = tmp___2;
    if (! fp) {
      ((*(os->close)))(fd);
      return ((ZZIP_FILE *)0);
    }
    fp->fd = fd;
    fp->io = os;
    return (fp);
  }
  if (o_modes & 16384) {
    return ((ZZIP_FILE *)0);
  }
  try_zzip: 
  if (o_flags & 65) {
    tmp___3 = __errno_location();
    (*tmp___3) = 22;
    return ((ZZIP_FILE *)0);
  }
  if (o_flags & 2) {
    o_flags ^= 2;
    o_flags |= 0;
  }
  strcpy((char * __restrict  )(basename), (char const   * __restrict  )filename);
  if (stream) {
    if (stream->dir) {
      if ((stream->dir)->realname) {
        tmp___4 = strlen((char const   *)(stream->dir)->realname);
        len = tmp___4;
        tmp___7 = memcmp((void const   *)filename, (void const   *)(stream->dir)->realname,
                         len);
        if (! tmp___7) {
          if ((int const   )(*(filename + len)) == 47) {
            if ((*(filename + (len + 1U)))) {
              tmp___5 = zzip_file_open(stream->dir, (filename + len) + 1, o_modes);
              fp___0 = tmp___5;
              if (! fp___0) {
                tmp___6 = __errno_location();
                (*tmp___6) = zzip_errno((stream->dir)->errcode);
              }
              return (fp___0);
            }
          }
        }
      }
    }
  }
  while (1) {
    p = strrchr((char const   *)(basename), '/');
    if (! p) {
      break;
    }
    e = (enum __anonenum_zzip_error_t_37 )0;
    (*p) = (char )'\000';
    fd___0 = __zzip_try_open((zzip_char_t *)(basename), (o_flags | 0) | 0, ext___0,
                             io);
    if (fd___0 == -1) {
      continue;
    }
    dir = zzip_dir_fdopen_ext_io(fd___0, & e, ext___0, io);
    if (e) {
      tmp___8 = __errno_location();
      (*tmp___8) = zzip_errno((int )e);
      ((*(io->close)))(fd___0);
      return ((ZZIP_FILE *)0);
    }
    fp___1 = zzip_file_open(dir, (filename + (p - basename)) + 1, o_modes);
    if (! fp___1) {
      tmp___9 = __errno_location();
      (*tmp___9) = zzip_errno(dir->errcode);
    } else {
      if (! dir->realname) {
        tmp___29 = __builtin_constant_p((int )(basename));
        if (tmp___29) {
          if ((unsigned int )((void const   *)(basename + 1)) - (unsigned int )((void const   *)(basename)) ==
              1U) {
            if ((int const   )(*((char const   *)(basename) + 0)) == 0) {
              dir->realname = (char *)calloc(1U, 1U);
            } else {
              tmp___26 = strlen((char const   *)(basename));
              __len___2 = tmp___26 + 1U;
              tmp___27 = (char *)malloc(__len___2);
              __retval___2 = tmp___27;
              if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
                __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )(basename),
                                              __len___2);
              }
              dir->realname = __retval___2;
            }
          } else {
            dir->realname = __strdup((char const   *)(basename));
          }
        } else {
          dir->realname = __strdup((char const   *)(basename));
        }
      }
    }
    zzip_dir_close(dir);
    return (fp___1);
  }
  if (o_modes & 16384) {
    goto try_real;
  }
  tmp___30 = __errno_location();
  (*tmp___30) = 2;
  return ((ZZIP_FILE *)0);
}
}
int zzip_rewind(ZZIP_FILE *fp ) 
{ ZZIP_DIR *dir ;
  int err ;
  int tmp ;
  zzip_off_t tmp___0 ;

  {
  if (! fp) {
    return (-1);
  }
  if (! fp->dir) {
    ((*((fp->io)->seeks)))(fp->fd, 0L, 0);
    return (0);
  }
  dir = fp->dir;
  if ((unsigned int )dir->currentfp != (unsigned int )fp) {
    tmp = zzip_file_saveoffset(dir->currentfp);
    if (tmp < 0) {
      dir->errcode = -4119;
      return (-1);
    } else {
      dir->currentfp = fp;
    }
  }
  tmp___0 = ((*((fp->io)->seeks)))(dir->fd, fp->dataoffset, 0);
  if (tmp___0 < 0L) {
    return (-1);
  }
  fp->restlen = fp->usize;
  fp->offset = fp->dataoffset;
  if (fp->method) {
    memset((void *)(& fp->d_stream), 0, sizeof(fp->d_stream));
    err = inflateInit2_(& fp->d_stream, -15, "1.2.2", (int )sizeof(z_stream ));
    if (err != 0) {
      goto error;
    }
    fp->crestlen = fp->csize;
  }
  return (0);
  error: 
  if (fp) {
    zzip_file_close(fp);
  }
  return (err);
}
}
zzip_off_t zzip_seek(ZZIP_FILE *fp , zzip_off_t offset , int whence ) 
{ zzip_off_t cur_pos ;
  zzip_off_t rel_ofs ;
  zzip_off_t read_size ;
  zzip_off_t ofs ;
  ZZIP_DIR *dir ;
  zzip_off_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  zzip_off_t tmp___2 ;
  char *buf ;
  zzip_off_t size ;
  zzip_off_t tmp___4 ;

  {
  if (! fp) {
    return (-1L);
  }
  if (! fp->dir) {
    tmp = ((*((fp->io)->seeks)))(fp->fd, offset, whence);
    return (tmp);
  }
  cur_pos = zzip_tell(fp);
  switch (whence) {
  case 0: 
  rel_ofs = offset - cur_pos;
  break;
  case 1: 
  rel_ofs = offset;
  break;
  case 2: 
  rel_ofs = (long )(((unsigned long )fp->usize + (unsigned long )offset) - (unsigned long )cur_pos);
  break;
  default: ;
  return (-1L);
  }
  if (rel_ofs == 0L) {
    return (cur_pos);
  }
  if (rel_ofs < 0L) {
    tmp___0 = zzip_rewind(fp);
    if (tmp___0 == -1) {
      return (-1L);
    }
    read_size = cur_pos + rel_ofs;
    cur_pos = 0L;
  } else {
    read_size = rel_ofs;
  }
  if (read_size < 0L) {
    return (-1L);
  }
  if (read_size + cur_pos > (long )fp->usize) {
    return (-1L);
  }
  if (read_size == 0L) {
    return (cur_pos);
  }
  dir = fp->dir;
  if ((unsigned int )dir->currentfp != (unsigned int )fp) {
    tmp___1 = zzip_file_saveoffset(dir->currentfp);
    if (tmp___1 < 0) {
      dir->errcode = -4119;
      return (-1L);
    } else {
      tmp___2 = ((*(((dir->currentfp)->io)->seeks)))(dir->fd, fp->offset, 0);
      if (tmp___2 < 0L) {
        dir->errcode = -4119;
        return (-1L);
      } else {
        dir->currentfp = fp;
      }
    }
  }
  if (fp->method == 0) {
    ofs = ((*((fp->io)->seeks)))(dir->fd, 0L, 1);
    ofs = ((*((fp->io)->seeks)))(dir->fd, read_size, 1);
    if (ofs > 0L) {
      ofs -= fp->dataoffset;
      fp->restlen = (unsigned int )((unsigned long )fp->usize - (unsigned long )ofs);
    }
    return (ofs);
  } else {
    buf = (char *)malloc(32768U);
    if (! buf) {
      return (-1L);
    }
    while (read_size > 0L) {
      size = 32768L;
      if (read_size < size) {
        size = read_size;
      }
      size = (zzip_off_t )zzip_file_read(fp, buf, (unsigned int )size);
      if (size <= 0L) {
        free((void *)buf);
        return (-1L);
      }
      read_size -= size;
    }
    free((void *)buf);
  }
  tmp___4 = zzip_tell(fp);
  return (tmp___4);
}
}
zzip_off_t zzip_tell(ZZIP_FILE *fp ) 
{ zzip_off_t tmp ;

  {
  if (! fp) {
    return (-1L);
  }
  if (! fp->dir) {
    tmp = ((*((fp->io)->seeks)))(fp->fd, 0L, 1);
    return (tmp);
  }
  return ((long )(fp->usize - fp->restlen));
}
}
#pragma merger(0,"/tmp/cil-7Hdk7Rii.i","-g -O2 -fPIC")
int zzip_error(ZZIP_DIR *dir ) ;
void zzip_seterror(ZZIP_DIR *dir , int errcode ) ;
zzip_char_t *zzip_compr_str(int compr ) ;
ZZIP_DIR *zzip_dirhandle(ZZIP_FILE *fp ) ;
int zzip_dirfd(ZZIP_DIR *dir ) ;
int zzip_dir_real(ZZIP_DIR *dir ) ;
int zzip_file_real(ZZIP_FILE *fp ) ;
void *zzip_realdir(ZZIP_DIR *dir ) ;
int zzip_realfd(ZZIP_FILE *fp ) ;
int zzip_error(ZZIP_DIR *dir ) 
{ 

  {
  return (dir->errcode);
}
}
void zzip_seterror(ZZIP_DIR *dir , int errcode ) 
{ 

  {
  dir->errcode = errcode;
  return;
}
}
ZZIP_DIR *zzip_dirhandle(ZZIP_FILE *fp ) 
{ 

  {
  return (fp->dir);
}
}
int zzip_dirfd(ZZIP_DIR *dir ) 
{ 

  {
  return (dir->fd);
}
}
zzip_char_t *zzip_compr_str(int compr ) 
{ 

  {
  switch (compr) {
  case 0: ;
  return ("stored");
  case 1: ;
  return ("shrunk");
  case 2: ;
  case 3: ;
  case 4: ;
  case 5: ;
  return ("reduced");
  case 6: ;
  return ("imploded");
  case 7: ;
  return ("tokenized");
  case 8: ;
  return ("deflated");
  case 9: ;
  return ("deflatedX");
  case 10: ;
  return ("implodedX");
  default: ;
  if (0 < compr) {
    if (compr < 256) {
      return ("zipped");
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((compr & 61440) == 16384) {
      return ("directory");
    }
    if ((compr & 61440) == 8192) {
      return ("is/chr");
    }
    if ((compr & 61440) == 24576) {
      return ("is/blk");
    }
    if ((compr & 61440) == 4096) {
      return ("is/fifo");
    }
    if ((compr & 61440) == 49152) {
      return ("is/sock");
    }
    if ((compr & 61440) == 40960) {
      return ("is/lnk");
    }
    return ("special");
  }
  }
}
}
int zzip_dir_real(ZZIP_DIR *dir ) 
{ 

  {
  return ((unsigned int )dir->realdir != (unsigned int )((void *)0));
}
}
int zzip_file_real(ZZIP_FILE *fp ) 
{ 

  {
  return ((unsigned int )fp->dir == (unsigned int )((struct zzip_dir *)0));
}
}
void *zzip_realdir(ZZIP_DIR *dir ) 
{ 

  {
  return (dir->realdir);
}
}
int zzip_realfd(ZZIP_FILE *fp ) 
{ 

  {
  return (fp->fd);
}
}
#pragma merger(0,"/tmp/cil-tbTgAsit.i","-g -O2 -fPIC")
zzip_off_t zzip_filesize(int fd ) ;
int zzip_init_io(struct zzip_plugin_io *io , int flags ) ;
zzip_off_t zzip_filesize(int fd ) 
{ struct stat st ;
  int tmp ;

  {
  tmp = fstat__extinline(fd, & st);
  if (tmp < 0) {
    return (-1L);
  }
  return (st.st_size);
}
}
static struct zzip_plugin_io  const  default_io  =    {& open, & close, & read, & lseek, & zzip_filesize, 1L};
zzip_plugin_io_t zzip_get_default_io(void) 
{ 

  {
  return (& default_io);
}
}
int zzip_init_io(struct zzip_plugin_io *io , int flags ) 
{ 

  {
  if (! io) {
    return (-4096);
  }
  memcpy((void * __restrict  )io, (void const   * __restrict  )(& default_io), sizeof(default_io));
  io->use_mmap = (long )flags;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-dVpMgZRl.i","-g -O2 -fPIC")
int zzip_dir_stat(ZZIP_DIR *dir , zzip_char_t *name , ZZIP_STAT *zs , int flags ) ;
int zzip_dir_stat(ZZIP_DIR *dir , zzip_char_t *name , ZZIP_STAT *zs , int flags ) 
{ struct zzip_dir_hdr *hdr ;
  int (*cmp)(zzip_char_t * , zzip_char_t * ) ;
  char *n ;
  char *tmp ;
  register char *hdr_name ;
  register char *n___0 ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  hdr = dir->hdr0;
  if (flags & 1024) {
    cmp = & strcasecmp;
  } else {
    cmp = & strcmp;
  }
  if (flags & 512) {
    tmp = strrchr(name, '/');
    n = tmp;
    if (n) {
      name = (zzip_char_t *)(n + 1);
    }
  }
  if (hdr) {
    while (1) {
      hdr_name = hdr->d_name;
      if (flags & 512) {
        tmp___0 = strrchr((char const   *)hdr_name, '/');
        n___0 = tmp___0;
        if (n___0) {
          hdr_name = n___0 + 1;
        }
      }
      tmp___1 = ((*cmp))((zzip_char_t *)hdr_name, name);
      if (! tmp___1) {
        break;
      }
      if (! hdr->d_reclen) {
        dir->errcode = -4124;
        return (-1);
      }
      hdr = (struct zzip_dir_hdr *)((char *)hdr + (int )hdr->d_reclen);
    }
  }
  zs->d_compr = (int )hdr->d_compr;
  zs->d_csize = (int )hdr->d_csize;
  zs->st_size = (int )hdr->d_usize;
  zs->d_name = hdr->d_name;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-NE2JyWtX.i","-g -O2 -fPIC")
ZZIP_DIR *zzip_dir_alloc(zzip_strings_t *fileext ) ;
int zzip_dir_free(ZZIP_DIR *dir ) ;
ZZIP_DIR *zzip_dir_open(zzip_char_t *filename , zzip_error_t *e ) ;
ZZIP_DIR *zzip_dir_alloc_ext_io(zzip_strings_t *ext___0 , zzip_plugin_io_t io ) ;
uint32_t __zzip_get32(unsigned char *s ) ;
uint16_t __zzip_get16(unsigned char *s ) ;
uint32_t __zzip_get32(unsigned char *s ) 
{ 

  {
  return (((((unsigned int )(*(s + 3)) << 24) | ((unsigned int )(*(s + 2)) << 16)) |
           ((unsigned int )(*(s + 1)) << 8)) | (unsigned int )(*(s + 0)));
}
}
uint16_t __zzip_get16(unsigned char *s ) 
{ 

  {
  return ((unsigned short )(((int )((unsigned short )(*(s + 1))) << 8) | (int )((unsigned short )(*(s +
                                                                                                    0)))));
}
}
int __zzip_find_disk_trailer(int fd , zzip_off_t filesize , struct zzip_disk_trailer *trailer ,
                             zzip_plugin_io_t io ) ;
int __zzip_parse_root_directory(int fd , struct zzip_disk_trailer *trailer , struct zzip_dir_hdr **hdr_return ,
                                zzip_plugin_io_t io ) ;
__inline char *__zzip_aligned4(char *p ) ;
int __zzip_find_disk_trailer(int fd , zzip_off_t filesize , struct zzip_disk_trailer *trailer ,
                             zzip_plugin_io_t io ) 
{ register int e ;
  char buffer[1024] ;
  char *buf ;
  zzip_off_t offset ;
  zzip_off_t maplen ;
  char *fd_map ;
  register unsigned char *mapped ;
  zzip_off_t pagesize___0 ;
  zzip_off_t tmp ;
  int tmp___0 ;
  register unsigned char *end ;
  register unsigned char *tail ;

  {
  buf = buffer;
  offset = 0L;
  maplen = 0L;
  fd_map = (char *)0;
  if (! trailer) {
    e = 22;
    goto cleanup;
  }
  if (filesize < (long )((int )sizeof(struct zzip_disk_trailer ))) {
    e = -4121;
    goto cleanup;
  }
  if (! buf) {
    e = -4116;
    goto cleanup;
  }
  offset = filesize;
  while (1) {
    if (offset <= 0L) {
      e = -4122;
      goto cleanup;
    }
    if (filesize - offset > 65536L) {
      e = -4122;
      goto cleanup;
    }
    fd_map = (char *)0;
    pagesize___0 = 512L;
    if (offset == filesize) {
      if (filesize > pagesize___0) {
        offset -= pagesize___0;
      }
    }
    if (offset < pagesize___0) {
      maplen = offset + pagesize___0;
      offset = 0L;
    } else {
      offset -= pagesize___0;
      maplen = 2L * pagesize___0;
      if (offset & (pagesize___0 - 1L)) {
        pagesize___0 -= offset & (pagesize___0 - 1L);
        offset += pagesize___0;
        maplen -= pagesize___0;
      }
    }
    if (offset + maplen > filesize) {
      maplen = filesize - offset;
    }
    tmp = ((*(io->seeks)))(fd, offset, 0);
    if (tmp < 0L) {
      e = -4119;
      goto cleanup;
    }
    tmp___0 = ((*(io->read)))(fd, (void *)buf, (unsigned int )maplen);
    if (tmp___0 < (int )maplen) {
      e = -4120;
      goto cleanup;
    }
    mapped = (unsigned char *)buf;
    end = mapped + maplen;
    tail = end - 1;
    while ((unsigned int )tail >= (unsigned int )mapped) {
      if ((int )(*tail) == 80) {
        if (end - tail >= (int )sizeof((*trailer)) - 2) {
          if ((int )(*((char *)tail + 0)) == 80) {
            if ((int )(*((char *)tail + 1)) == 75) {
              if ((int )(*((char *)tail + 2)) == 5) {
                if ((int )(*((char *)tail + 3)) == 6) {
                  if (end - tail >= (int )sizeof((*trailer))) {
                    memcpy((void * __restrict  )trailer, (void const   * __restrict  )tail,
                           sizeof((*trailer)));
                  } else {
                    memcpy((void * __restrict  )trailer, (void const   * __restrict  )tail,
                           sizeof((*trailer)) - 2U);
                    trailer->z_comment[0] = (char)0;
                    trailer->z_comment[1] = (char)0;
                  }
                  (*((zzip_off_t *)trailer)) = (long )((tail + offset) - mapped);
                  e = 0;
                  goto cleanup;
                }
              }
            }
          }
        }
      }
      tail --;
    }
  }
  cleanup: 
  return (e);
}
}
__inline char *__zzip_aligned4(char *p ) 
{ 

  {
  p += (long )p & 1L;
  p += (long )p & 2L;
  return (p);
}
}
int __zzip_parse_root_directory(int fd , struct zzip_disk_trailer *trailer , struct zzip_dir_hdr **hdr_return ,
                                zzip_plugin_io_t io ) 
{ struct zzip_root_dirent dirent ;
  struct zzip_dir_hdr *hdr ;
  struct zzip_dir_hdr *hdr0 ;
  uint16_t *p_reclen ;
  short entries ;
  long offset ;
  char *fd_map ;
  int32_t fd_gap ;
  uint16_t u_entries ;
  uint32_t u_rootsize ;
  uint32_t u_rootseek ;
  register struct zzip_root_dirent *d ;
  uint16_t u_extras ;
  uint16_t u_comment ;
  uint16_t u_namlen ;
  uint16_t u_flags ;
  zzip_off_t tmp___0 ;
  int tmp___1 ;
  register char *p ;
  register char *q ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  p_reclen = (uint16_t *)0;
  fd_map = (char *)0;
  fd_gap = 0;
  u_entries = (*((uint16_t *)(trailer->z_entries)));
  u_rootsize = (*((uint32_t *)(trailer->z_rootsize)));
  u_rootseek = (*((uint32_t *)(trailer->z_rootseek)));
  if ((unsigned long )u_rootseek > (unsigned long )(*((zzip_off_t *)trailer)) - (unsigned long )u_rootsize) {
    u_rootseek = (unsigned int )((unsigned long )(*((zzip_off_t *)trailer)) - (unsigned long )u_rootsize);
  }
  hdr0 = (struct zzip_dir_hdr *)malloc(u_rootsize);
  if (! hdr0) {
    return (-4123);
  }
  hdr = hdr0;
  entries = (short )u_entries;
  offset = 0L;
  while ((int )entries > 0) {
    if (fd_map) {
      d = (struct zzip_root_dirent *)((void *)((fd_map + fd_gap) + offset));
    } else {
      tmp___0 = ((*(io->seeks)))(fd, (long )((unsigned long )u_rootseek + (unsigned long )offset),
                                 0);
      if (tmp___0 < 0L) {
        free((void *)hdr0);
        return (-4119);
      }
      tmp___1 = ((*(io->read)))(fd, (void *)(& dirent), sizeof(dirent));
      if (tmp___1 < (int )sizeof(dirent)) {
        free((void *)hdr0);
        return (-4120);
      }
      d = & dirent;
    }
    if ((unsigned long )offset + (unsigned long )sizeof((*d)) > (unsigned long )u_rootsize) {
      break;
    }
    u_extras = (*((uint16_t *)(d->z_extras)));
    u_comment = (*((uint16_t *)(d->z_comment)));
    u_namlen = (*((uint16_t *)(d->z_namlen)));
    u_flags = (*((uint16_t *)(d->z_flags)));
    hdr->d_crc32 = (*((uint32_t *)(d->z_crc32)));
    hdr->d_csize = (*((uint32_t *)(d->z_csize)));
    hdr->d_usize = (*((uint32_t *)(d->z_usize)));
    hdr->d_off = (*((uint32_t *)(d->z_off)));
    hdr->d_compr = (unsigned char )(*((uint16_t *)(d->z_compr)));
    hdr->d_flags = u_flags;
    if (((unsigned long )offset + (unsigned long )sizeof((*d))) + (unsigned long )u_namlen >
        (unsigned long )u_rootsize) {
      break;
    }
    if (fd_map) {
      memcpy((void * __restrict  )(hdr->d_name), (void const   * __restrict  )(((fd_map +
                                                                                 fd_gap) +
                                                                                offset) +
                                                                               sizeof((*d))),
             (unsigned int )u_namlen);
    } else {
      ((*(io->read)))(fd, (void *)(hdr->d_name), (unsigned int )u_namlen);
    }
    hdr->d_name[u_namlen] = (char )'\000';
    hdr->d_namlen = u_namlen;
    offset = (long )((unsigned long )offset + (unsigned long )(((sizeof((*d)) + (unsigned int )u_namlen) +
                                                                (unsigned int )u_extras) +
                                                               (unsigned int )u_comment));
    if (offset > (long )u_rootsize) {
      entries = (short )((int )entries - 1);
      break;
    }
    p_reclen = & hdr->d_reclen;
    p = (char *)hdr;
    tmp___2 = __zzip_aligned4(((p + sizeof((*hdr))) + (int )u_namlen) + 1);
    q = tmp___2;
    (*p_reclen) = (unsigned short )(q - p);
    hdr = (struct zzip_dir_hdr *)q;
    entries = (short )((int )entries - 1);
  }
  if (p_reclen) {
    (*p_reclen) = (unsigned short)0;
    if (hdr_return) {
      (*hdr_return) = hdr0;
    }
  } else {
    free((void *)hdr0);
  }
  if (entries) {
    tmp___3 = -4127;
  } else {
    tmp___3 = 0;
  }
  return (tmp___3);
}
}
static zzip_strings_t *zzip_get_default_ext(void) ;
static zzip_strings_t ext[3]  = {      (char const   * const  )".zip",      (char const   * const  )".ZIP",      (char const   * const  )0};
static zzip_strings_t *zzip_get_default_ext(void) 
{ 

  {
  return (ext);
}
}
ZZIP_DIR *zzip_dir_alloc_ext_io(zzip_strings_t *ext___0 , zzip_plugin_io_t io ) 
{ ZZIP_DIR *dir ;

  {
  dir = (ZZIP_DIR *)calloc(1U, sizeof((*dir)));
  if ((unsigned int )dir == (unsigned int )((void *)0)) {
    return ((ZZIP_DIR *)0);
  }
  if (ext___0) {
    dir->fileext = ext___0;
  } else {
    dir->fileext = zzip_get_default_ext();
  }
  if (io) {
    dir->io = io;
  } else {
    dir->io = zzip_get_default_io();
  }
  return (dir);
}
}
ZZIP_DIR *zzip_dir_alloc(zzip_strings_t *fileext ) 
{ ZZIP_DIR *tmp ;

  {
  tmp = zzip_dir_alloc_ext_io(fileext, (struct zzip_plugin_io  const  *)0);
  return (tmp);
}
}
int zzip_dir_free(ZZIP_DIR *dir ) 
{ 

  {
  if (dir->refcount) {
    return ((int )dir->refcount);
  }
  if (dir->fd >= 0) {
    ((*((dir->io)->close)))(dir->fd);
  }
  if (dir->hdr0) {
    free((void *)dir->hdr0);
  }
  if (dir->cache.fp) {
    free((void *)dir->cache.fp);
  }
  if (dir->cache.buf32k) {
    free((void *)dir->cache.buf32k);
  }
  if (dir->realname) {
    free((void *)dir->realname);
  }
  free((void *)dir);
  return (0);
}
}
int zzip_dir_close(ZZIP_DIR *dir ) 
{ int tmp ;

  {
  dir->refcount = dir->refcount & -268435457L;
  tmp = zzip_dir_free(dir);
  return (tmp);
}
}
ZZIP_DIR *zzip_dir_fdopen(int fd , zzip_error_t *errcode_p ) 
{ ZZIP_DIR *tmp ;

  {
  tmp = zzip_dir_fdopen_ext_io(fd, errcode_p, (zzip_strings_t *)0, (struct zzip_plugin_io  const  *)0);
  return (tmp);
}
}
static zzip_error_t __zzip_dir_parse(ZZIP_DIR *dir ) ;
ZZIP_DIR *zzip_dir_fdopen_ext_io(int fd , zzip_error_t *errcode_p , zzip_strings_t *ext___0 ,
                                 zzip_plugin_io_t io ) 
{ zzip_error_t rv ;
  ZZIP_DIR *dir ;

  {
  dir = zzip_dir_alloc_ext_io(ext___0, io);
  if ((unsigned int )dir == (unsigned int )((void *)0)) {
    rv = (enum __anonenum_zzip_error_t_37 )-4116;
    goto error;
  }
  dir->fd = fd;
  rv = __zzip_dir_parse(dir);
  if (rv) {
    goto error;
  }
  dir->hdr = dir->hdr0;
  dir->refcount = dir->refcount | 268435456L;
  if (errcode_p) {
    (*errcode_p) = rv;
  }
  return (dir);
  error: 
  if (dir) {
    zzip_dir_free(dir);
  }
  if (errcode_p) {
    (*errcode_p) = rv;
  }
  return ((ZZIP_DIR *)((void *)0));
}
}
static zzip_error_t __zzip_dir_parse(ZZIP_DIR *dir ) 
{ zzip_error_t rv ;
  zzip_off_t filesize ;
  struct zzip_disk_trailer trailer ;

  {
  filesize = ((*((dir->io)->filesize)))(dir->fd);
  if (filesize < 0L) {
    rv = (enum __anonenum_zzip_error_t_37 )-4118;
    goto error;
  }
  rv = (zzip_error_t )__zzip_find_disk_trailer(dir->fd, filesize, & trailer, dir->io);
  if ((int )rv != 0) {
    goto error;
  }
  rv = (zzip_error_t )__zzip_parse_root_directory(dir->fd, & trailer, & dir->hdr0,
                                                  dir->io);
  if ((int )rv != 0) {
    goto error;
  }
  error: 
  return (rv);
}
}
int __zzip_try_open(zzip_char_t *filename , int filemode , zzip_strings_t *ext___0 ,
                    zzip_plugin_io_t io ) 
{ char file[4096] ;
  int fd ;
  zzip_size_t len ;
  zzip_size_t tmp ;

  {
  tmp = strlen(filename);
  len = tmp;
  if (len + 4U >= 4096U) {
    return (-1);
  }
  memcpy((void * __restrict  )(file), (void const   * __restrict  )filename, len +
                                                                             1U);
  if (! io) {
    io = zzip_get_default_io();
  }
  if (! ext___0) {
    ext___0 = zzip_get_default_ext();
  }
  while ((*ext___0)) {
    strcpy((char * __restrict  )(file + len), (char const   * __restrict  )(*ext___0));
    fd = ((*(io->open)))((zzip_char_t *)(file), filemode);
    if (fd != -1) {
      return (fd);
    }
    ext___0 ++;
  }
  return (-1);
}
}
ZZIP_DIR *zzip_dir_open(zzip_char_t *filename , zzip_error_t *e ) 
{ ZZIP_DIR *tmp ;

  {
  tmp = zzip_dir_open_ext_io(filename, e, (zzip_strings_t *)0, (struct zzip_plugin_io  const  *)0);
  return (tmp);
}
}
ZZIP_DIR *zzip_dir_open_ext_io(zzip_char_t *filename , zzip_error_t *e , zzip_strings_t *ext___0 ,
                               zzip_plugin_io_t io ) 
{ int fd ;
  ZZIP_DIR *tmp ;
  ZZIP_DIR *tmp___0 ;

  {
  if (! io) {
    io = zzip_get_default_io();
  }
  if (! ext___0) {
    ext___0 = zzip_get_default_ext();
  }
  fd = ((*(io->open)))(filename, 0);
  if (fd != -1) {
    tmp = zzip_dir_fdopen_ext_io(fd, e, ext___0, io);
    return (tmp);
  } else {
    fd = __zzip_try_open(filename, 0, ext___0, io);
    if (fd != -1) {
      tmp___0 = zzip_dir_fdopen_ext_io(fd, e, ext___0, io);
      return (tmp___0);
    } else {
      if (e) {
        (*e) = (enum __anonenum_zzip_error_t_37 )-4117;
      }
      return ((ZZIP_DIR *)0);
    }
  }
}
}
int zzip_dir_read(ZZIP_DIR *dir , ZZIP_DIRENT *d ) 
{ 

  {
  if (! dir) {
    return (0);
  } else {
    if (! dir->hdr) {
      return (0);
    } else {
      if (! d) {
        return (0);
      }
    }
  }
  d->d_compr = (int )(dir->hdr)->d_compr;
  d->d_csize = (int )(dir->hdr)->d_csize;
  d->st_size = (int )(dir->hdr)->d_usize;
  d->d_name = (dir->hdr)->d_name;
  d->d_flags = (dir->hdr)->d_flags;
  d->d_crc32 = (int )(dir->hdr)->d_crc32;
  if (! (dir->hdr)->d_reclen) {
    dir->hdr = (struct zzip_dir_hdr *)0;
  } else {
    dir->hdr = (struct zzip_dir_hdr *)((char *)dir->hdr + (int )(dir->hdr)->d_reclen);
  }
  return (1);
}
}
#pragma merger(0,"/tmp/cil-mcMPgSWP.i","-g -O2 -fPIC")
 __attribute__((__nothrow__)) int strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
int strcasecmp(char const   *s1 , char const   *s2 ) 
{ unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int __res ;
  int __c ;
  unsigned char const   *tmp ;
  __int32_t const   **tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;
  int tmp___4 ;
  __int32_t const   **tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;
  int __res___0 ;
  int __c___0 ;
  unsigned char const   *tmp___8 ;
  __int32_t const   **tmp___10 ;
  unsigned char const   *tmp___11 ;
  unsigned char const   *tmp___12 ;
  int tmp___13 ;
  __int32_t const   **tmp___14 ;
  unsigned char const   *tmp___15 ;
  unsigned char const   *tmp___16 ;

  {
  p1 = (unsigned char const   *)s1;
  p2 = (unsigned char const   *)s2;
  if ((unsigned int )p1 == (unsigned int )p2) {
    return (0);
  }
  while (1) {
    if (sizeof((*tmp___7)) > 1U) {
      tmp___3 = p1;
      p1 ++;
      tmp___4 = __builtin_constant_p((int )(*tmp___3));
      if (tmp___4) {
        tmp = p1;
        p1 ++;
        __c = (int )(*tmp);
        if (__c < -128) {
          __res = __c;
        } else {
          if (__c > 255) {
            __res = __c;
          } else {
            tmp___1 = __ctype_tolower_loc();
            __res = (*((*tmp___1) + __c));
          }
        }
      } else {
        tmp___2 = p1;
        p1 ++;
        __res = tolower__extinline((int )(*tmp___2));
      }
    } else {
      tmp___5 = __ctype_tolower_loc();
      tmp___6 = p1;
      p1 ++;
      __res = (*((*tmp___5) + (int )(*tmp___6)));
    }
    c1 = (unsigned char )__res;
    if (sizeof((*tmp___16)) > 1U) {
      tmp___12 = p2;
      p2 ++;
      tmp___13 = __builtin_constant_p((int )(*tmp___12));
      if (tmp___13) {
        tmp___8 = p2;
        p2 ++;
        __c___0 = (int )(*tmp___8);
        if (__c___0 < -128) {
          __res___0 = __c___0;
        } else {
          if (__c___0 > 255) {
            __res___0 = __c___0;
          } else {
            tmp___10 = __ctype_tolower_loc();
            __res___0 = (*((*tmp___10) + __c___0));
          }
        }
      } else {
        tmp___11 = p2;
        p2 ++;
        __res___0 = tolower__extinline((int )(*tmp___11));
      }
    } else {
      tmp___14 = __ctype_tolower_loc();
      tmp___15 = p2;
      p2 ++;
      __res___0 = (*((*tmp___14) + (int )(*tmp___15)));
    }
    c2 = (unsigned char )__res___0;
    if ((int )c1 == 0) {
      break;
    }
    if (! ((int )c1 == (int )c2)) {
      break;
    }
  }
  return ((int )c1 - (int )c2);
}
}
#pragma merger(0,"/tmp/cil-JQz19YYI.i","-g -O2 -fPIC")
extern int mkstemp(char *__template )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int getpagesize(void)  __attribute__((__const__)) ;
blob *blobCreate(void) ;
void blobDestroy(blob *b ) ;
void blobArrayDestroy(blob **blobList , int n ) ;
void blobSetFilename(blob *b , char const   *dir , char const   *filename ) ;
char const   *blobGetFilename(blob const   *b ) ;
int blobAddData(blob *b , unsigned char const   *data , size_t len ) ;
unsigned char *blobGetData(blob const   *b ) ;
unsigned long blobGetDataSize(blob const   *b ) ;
void blobClose(blob *b ) ;
int blobcmp(blob const   *b1 , blob const   *b2 ) ;
void blobGrow(blob *b , size_t len ) ;
fileblob *fileblobCreate(void) ;
void fileblobDestroy(fileblob *fb ) ;
void fileblobSetFilename(fileblob *fb , char const   *dir , char const   *filename ) ;
char const   *fileblobGetFilename(fileblob const   *fb ) ;
int fileblobAddData(fileblob *fb , unsigned char const   *data , size_t len ) ;
void sanitiseName(char *name ) ;
blob *blobCreate(void) 
{ blob *tmp ;

  {
  tmp = (blob *)cli_calloc(1U, sizeof(blob ));
  return (tmp);
}
}
void blobDestroy(blob *b ) 
{ 

  {
  cli_dbgmsg("blobDestroy\n");
  if (b->name) {
    free((void *)b->name);
  }
  if (b->data) {
    free((void *)b->data);
  }
  free((void *)b);
  return;
}
}
void blobArrayDestroy(blob **blobList , int n ) 
{ 

  {
  while (1) {
    n --;
    if (! (n >= 0)) {
      break;
    }
    cli_dbgmsg("blobArrayDestroy: %d\n", n);
    if ((*(blobList + n))) {
      blobDestroy((*(blobList + n)));
      (*(blobList + n)) = (blob *)((void *)0);
    }
  }
  return;
}
}
void blobSetFilename(blob *b , char const   *dir , char const   *filename ) 
{ size_t __len___2 ;
  size_t tmp___15 ;
  char *__retval___2 ;
  char *tmp___16 ;
  int tmp___18 ;

  {
  cli_dbgmsg("blobSetFilename: %s\n", filename);
  if (b->name) {
    free((void *)b->name);
  }
  tmp___18 = __builtin_constant_p((int )filename);
  if (tmp___18) {
    if ((unsigned int )((void const   *)(filename + 1)) - (unsigned int )((void const   *)filename) ==
        1U) {
      if ((int const   )(*(filename + 0)) == 0) {
        b->name = (char *)calloc(1U, 1U);
      } else {
        tmp___15 = strlen(filename);
        __len___2 = tmp___15 + 1U;
        tmp___16 = (char *)malloc(__len___2);
        __retval___2 = tmp___16;
        if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
          __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )filename,
                                        __len___2);
        }
        b->name = __retval___2;
      }
    } else {
      b->name = __strdup(filename);
    }
  } else {
    b->name = __strdup(filename);
  }
  if (b->name) {
    sanitiseName(b->name);
  }
  return;
}
}
char const   *blobGetFilename(blob const   *b ) 
{ 

  {
  return ((char const   *)b->name);
}
}
static int pagesize  ;
int blobAddData(blob *b , unsigned char const   *data , size_t len ) 
{ int growth ;
  unsigned char *p ;
  unsigned char *tmp ;

  {
  if (len == 0U) {
    return (0);
  }
  if (b->isClosed) {
    cli_warnmsg("Reopening closed blob\n");
    b->isClosed = 0;
  }
  if (pagesize == 0) {
    pagesize = getpagesize();
    if (pagesize == 0) {
      pagesize = 4096;
    }
  }
  growth = pagesize;
  if (len >= (unsigned int )pagesize) {
    growth = (int )((len / (unsigned int )pagesize + 1U) * (unsigned int )pagesize);
  }
  if ((unsigned int )b->data == (unsigned int )((void *)0)) {
    b->size = (unsigned long )growth;
    b->data = (unsigned char *)cli_malloc((unsigned int )growth);
  } else {
    if (b->size < b->len + (unsigned long )len) {
      tmp = (unsigned char *)cli_realloc((void *)b->data, (unsigned int )(b->size +
                                                                          (unsigned long )growth));
      p = tmp;
      if ((unsigned int )p == (unsigned int )((void *)0)) {
        return (-1);
      }
      b->size += (unsigned long )growth;
      b->data = p;
    }
  }
  if (b->data) {
    memcpy((void * __restrict  )(b->data + b->len), (void const   * __restrict  )data,
           len);
    b->len += (unsigned long )len;
  }
  return (0);
}
}
unsigned char *blobGetData(blob const   *b ) 
{ 

  {
  if (b->len == 0UL) {
    return ((unsigned char *)((void *)0));
  }
  return (b->data);
}
}
unsigned long blobGetDataSize(blob const   *b ) 
{ 

  {
  return (b->len);
}
}
void blobClose(blob *b ) 
{ unsigned char *ptr ;
  unsigned char *tmp ;

  {
  if (b->isClosed) {
    cli_dbgmsg("Attempt to close a previously closed blob\n");
    return;
  }
  if (b->size - b->len >= 64UL) {
    if (b->len == 0UL) {
      free((void *)b->data);
      b->data = (unsigned char *)((void *)0);
      cli_dbgmsg("blobClose: recovered all %u bytes\n", b->size);
      b->size = 0UL;
    } else {
      tmp = (unsigned char *)cli_realloc((void *)b->data, (unsigned int )b->len);
      ptr = tmp;
      if ((unsigned int )ptr == (unsigned int )((void *)0)) {
        return;
      }
      cli_dbgmsg("blobClose: recovered %u bytes from %u\n", b->size - b->len, b->size);
      b->size = b->len;
      b->data = ptr;
    }
  }
  b->isClosed = 1;
  return;
}
}
int blobcmp(blob const   *b1 , blob const   *b2 ) 
{ unsigned long s1 ;
  unsigned long s2 ;
  void const   *tmp ;
  void const   *tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned int )b1 == (unsigned int )b2) {
    return (0);
  }
  s1 = blobGetDataSize(b1);
  s2 = blobGetDataSize(b2);
  if (s1 != s2) {
    return (1);
  }
  if (s1 == 0UL) {
    if (s2 == 0UL) {
      return (0);
    }
  }
  tmp = (void const   *)blobGetData(b2);
  tmp___0 = (void const   *)blobGetData(b1);
  tmp___1 = memcmp(tmp___0, tmp, (unsigned int )s1);
  return (tmp___1);
}
}
void blobGrow(blob *b , size_t len ) 
{ unsigned char *ptr ;
  unsigned char *tmp ;

  {
  if (len == 0U) {
    return;
  }
  if (b->isClosed) {
    cli_warnmsg("Growing closed blob\n");
    b->isClosed = 0;
  }
  if ((unsigned int )b->data == (unsigned int )((void *)0)) {
    b->data = (unsigned char *)cli_malloc(len);
    if (b->data) {
      b->size = (unsigned long )len;
    }
  } else {
    tmp = (unsigned char *)cli_realloc((void *)b->data, (unsigned int )(b->size +
                                                                        (unsigned long )len));
    ptr = tmp;
    if (ptr) {
      b->size += (unsigned long )len;
      b->data = ptr;
    }
  }
  return;
}
}
fileblob *fileblobCreate(void) 
{ fileblob *tmp ;

  {
  tmp = (fileblob *)cli_calloc(1U, sizeof(fileblob ));
  return (tmp);
}
}
void fileblobDestroy(fileblob *fb ) 
{ 

  {
  if (fb->b.name) {
    if (fb->fp) {
      fclose(fb->fp);
      cli_dbgmsg("fileblobDestroy: %s\n", fb->b.name);
      if (! fb->isNotEmpty) {
        cli_dbgmsg("fileblobDestroy: not saving empty file\n");
        unlink((char const   *)fb->b.name);
      }
      free((void *)fb->b.name);
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (fb->b.data) {
      cli_errmsg("fileblobDestroy: file not saved: report to bugs@clamav.net\n");
      free((void *)fb->b.data);
      if (fb->b.name) {
        free((void *)fb->b.name);
      }
    }
  }
  free((void *)fb);
  return;
}
}
void fileblobSetFilename(fileblob *fb , char const   *dir , char const   *filename ) 
{ int fd ;
  char fullname[256] ;
  size_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;

  {
  if (fb->b.name) {
    return;
  }
  blobSetFilename(& fb->b, dir, filename);
  filename = blobGetFilename((blob const   *)(& fb->b));
  tmp = strlen(dir);
  snprintf((char * __restrict  )(fullname), sizeof(fullname) - 1U, (char const   * __restrict  )"%s/%.*sXXXXXX",
           dir, (int )((sizeof(fullname) - 9U) - tmp), filename);
  cli_dbgmsg("fileblobSetFilename: mkstemp(%s)\n", fullname);
  fd = mkstemp(fullname);
  if (fd < 0) {
    tmp___0 = __errno_location();
    tmp___1 = strerror((*tmp___0));
    cli_errmsg("Can\'t create temporary file %s: %s\n", fullname, tmp___1);
    tmp___2 = strlen((char const   *)(fullname));
    cli_dbgmsg("%d %d\n", sizeof(fullname), tmp___2);
    return;
  }
  cli_dbgmsg("Saving attachment as %s\n", fullname);
  fb->fp = fdopen(fd, "wb");
  if ((unsigned int )fb->fp == (unsigned int )((void *)0)) {
    tmp___3 = __errno_location();
    tmp___4 = strerror((*tmp___3));
    cli_errmsg("Can\'t create file %s: %s\n", fullname, tmp___4);
    tmp___5 = strlen((char const   *)(fullname));
    cli_dbgmsg("%d %d\n", sizeof(fullname), tmp___5);
    close(fd);
    return;
  }
  if (fb->b.data) {
    tmp___8 = fwrite((void const   * __restrict  )fb->b.data, (unsigned int )fb->b.len,
                     1U, (FILE * __restrict  )fb->fp);
    if (tmp___8 != 1U) {
      tmp___6 = __errno_location();
      tmp___7 = strerror((*tmp___6));
      cli_errmsg("fileblobSetFilename: Can\'t write to temporary file %s: %s\n", fullname,
                 tmp___7);
    } else {
      fb->isNotEmpty = 1;
    }
    free((void *)fb->b.data);
    fb->b.data = (unsigned char *)((void *)0);
    fb->b.size = 0UL;
    fb->b.len = fb->b.size;
  }
  return;
}
}
int fileblobAddData(fileblob *fb , unsigned char const   *data , size_t len ) 
{ int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  if (len == 0U) {
    return (0);
  }
  if (fb->fp) {
    tmp___1 = fwrite((void const   * __restrict  )data, len, 1U, (FILE * __restrict  )fb->fp);
    if (tmp___1 != 1U) {
      tmp = __errno_location();
      tmp___0 = strerror((*tmp));
      cli_errmsg("fileblobAddData: Can\'t write %u bytes to temporary file %s: %s\n",
                 len, fb->b.name, tmp___0);
      return (-1);
    }
    fb->isNotEmpty = 1;
    return (0);
  }
  tmp___2 = blobAddData(& fb->b, data, len);
  return (tmp___2);
}
}
char const   *fileblobGetFilename(fileblob const   *fb ) 
{ char const   *tmp ;

  {
  tmp = blobGetFilename((blob const   *)(& fb->b));
  return (tmp);
}
}
void sanitiseName(char *name ) 
{ 

  {
  while ((*name)) {
    if ((int )(*name) == 47) {
      (*name) = (char )'_';
    }
    name ++;
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-Gu7RlaTG.i","-g -O2 -fPIC")
extern  __attribute__((__nothrow__)) int _IO_getc(_IO_FILE *__fp ) ;
extern  __attribute__((__nothrow__)) int _IO_putc(int __c , _IO_FILE *__fp ) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern int ungetc(int __c , FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) char *__strtok_r(char * __restrict  __s , char const   * __restrict  __delim ,
                                                      char ** __restrict  __save_ptr )  __attribute__((__nonnull__(2,3))) ;
__inline static char *__strtok_r_1c__extinline(char *__s , char __sep , char **__nextp ) 
{ char *__result ;
  char *tmp ;
  char *tmp___0 ;

  {
  if ((unsigned int )__s == (unsigned int )((void *)0)) {
    __s = (*__nextp);
  }
  while ((int )(*__s) == (int )__sep) {
    __s ++;
  }
  __result = (char *)((void *)0);
  if ((int )(*__s) != 0) {
    tmp = __s;
    __s ++;
    __result = tmp;
    while ((int )(*__s) != 0) {
      tmp___0 = __s;
      __s ++;
      if ((int )(*tmp___0) == (int )__sep) {
        (*(__s + -1)) = (char )'\000';
        break;
      }
    }
    (*__nextp) = __s;
  }
  return (__result);
}
}
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t * __restrict  __threadp ,
                                                        pthread_attr_t const   * __restrict  __attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
struct table *tableCreate(void) ;
void tableDestroy(table_t *table ) ;
int tableInsert(table_t *table , char const   *key , int value ) ;
int tableFind(table_t const   *table , char const   *key ) ;
size_t strstrip(char *s ) ;
char const   *lineGetData(line_t const   *line ) ;
message *messageCreate(void) ;
void messageDestroy(message *m ) ;
void messageReset(message *m ) ;
int messageSetMimeType(message *mess , char const   *type ) ;
mime_type messageGetMimeType(message const   *m ) ;
void messageSetMimeSubtype(message *m , char const   *subtype___0 ) ;
char const   *messageGetMimeSubtype(message const   *m ) ;
void messageSetDispositionType(message *m , char const   *disptype ) ;
char const   *messageGetDispositionType(message const   *m ) ;
void messageAddArgument(message *m , char const   *arg ) ;
void messageAddArguments(message *m , char const   *s ) ;
char const   *messageFindArgument(message const   *m , char const   *variable ) ;
void messageSetEncoding(message *m , char const   *enctype ) ;
encoding_type messageGetEncoding(message const   *m ) ;
int messageAddLine(message *m , line_t *line ) ;
int messageAddStr(message *m , char const   *data ) ;
text const   *messageGetBody(message const   *m ) ;
void messageClean(message *m ) ;
fileblob *messageToFileblob(message *m , char const   *dir ) ;
blob *messageToBlob(message *m ) ;
text const   *binhexBegin(message const   *m ) ;
text const   *uuencodeBegin(message const   *m ) ;
text const   *bounceBegin(message const   *m ) ;
text const   *encodingLine(message const   *m ) ;
unsigned char *decodeLine(message *m , encoding_type et , char const   *line , unsigned char *buf ,
                          size_t buflen ) ;
int isuuencodebegin(char const   *line ) ;
void textDestroy(text *t_head ) ;
text *textAdd(text *t_head , text const   *t ) ;
text *textAddMessage(text *aText , message *aMessage ) ;
fileblob *textToFileblob(text const   *t , fileblob *fb ) ;
int html_normalise_mem(unsigned char *in_buff , off_t in_size , char const   *dirname ,
                       tag_arguments_t *hrefs ) ;
void html_tag_arg_free(tag_arguments_t *tags ) ;
extern CURLcode curl_global_init(long flags ) ;
extern struct curl_slist *curl_slist_append(struct curl_slist * , char const   * ) ;
extern void curl_slist_free_all(struct curl_slist * ) ;
extern CURL *curl_easy_init(void) ;
extern CURLcode curl_easy_setopt(CURL *curl , CURLoption option  , ...) ;
extern CURLcode curl_easy_perform(CURL *curl ) ;
extern void curl_easy_cleanup(CURL *curl ) ;
static int cli_parse_mbox(char const   *dir , int desc , unsigned int options ) ;
static message *parseEmailFile(FILE *fin , table_t const   *rfc821___0 , char const   *firstLine ,
                               char const   *dir ) ;
static message *parseEmailHeaders(message const   *m , table_t const   *rfc821___0 ) ;
static int parseEmailHeader(message *m , char const   *line , table_t const   *rfc821___0 ) ;
static int parseEmailBody(message *messageIn , text *textIn , char const   *dir ,
                          table_t const   *rfc821Table , table_t const   *subtypeTable ,
                          unsigned int options ) ;
static int boundaryStart(char const   *line , char const   *boundary ) ;
static int endOfMessage(char const   *line , char const   *boundary ) ;
static int initialiseTables(table_t **rfc821Table , table_t **subtypeTable ) ;
static int getTextPart(message * const  *messages , size_t size ) ;
static size_t strip(char *buf , int len ) ;
static bool continuationMarker(char const   *line ) ;
static int parseMimeHeader(message *m , char const   *cmd , table_t const   *rfc821Table ,
                           char const   *arg ) ;
static void saveTextPart(message *m , char const   *dir ) ;
static char *rfc2047(char const   *in ) ;
static char *rfc822comments(char const   *in , char *out ) ;
static int rfc1341(message *m , char const   *dir ) ;
static bool usefulHeader(int commandNumber , char const   *cmd ) ;
static void uufasttrack(message *m , char const   *firstline , char const   *dir ,
                        FILE *fin ) ;
static char *getline(char *buffer , size_t len , FILE *fin ) ;
static void checkURLs(message *m , char const   *dir ) ;
static void *getURL(void *a ) ;
static struct tableinit  const  rfc821headers[4]  = {      {"Content-Type", 1}, 
        {"Content-Transfer-Encoding", 2}, 
        {"Content-Disposition", 3}, 
        {(char const   *)((void *)0), 0}};
static struct tableinit  const  mimeSubtypes[20]  = 
  {      {"plain", 1}, 
        {"enriched", 2}, 
        {"html", 3}, 
        {"richtext", 4}, 
        {"mixed", 5}, 
        {"alternative", 6}, 
        {"digest", 7}, 
        {"signed", 8}, 
        {"parallel", 9}, 
        {"related", 10}, 
        {"report", 11}, 
        {"appledouble", 12}, 
        {"fax-message", 5}, 
        {"encrypted", 13}, 
        {"x-bfile", 10}, 
        {"knowbot", 14}, 
        {"knowbot-metadata", 14}, 
        {"knowbot-code", 14}, 
        {"knowbot-state", 14}, 
        {(char const   *)((void *)0), 0}};
static struct __anonstruct_pthread_mutex_t_16 tables_mutex  =    {0, 0, (struct _pthread_descr_struct *)0, 0, {0L, 0}};
int cli_mbox(char const   *dir , int desc , unsigned int options ) 
{ int tmp ;

  {
  if ((unsigned int )dir == (unsigned int )((void *)0)) {
    cli_warnmsg("cli_mbox called with NULL dir\n");
    return (300);
  }
  tmp = cli_parse_mbox(dir, desc, options);
  return (tmp);
}
}
static table_t *rfc821  ;
static table_t *subtype  ;
static int cli_parse_mbox(char const   *dir , int desc , unsigned int options ) 
{ int retcode ;
  int i ;
  message *body___0 ;
  FILE *fd ;
  char buffer[1001] ;
  char *tmp ;
  int tmp___0 ;
  bool lastLineWasEmpty ;
  int messagenumber ;
  message *m ;
  message *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  text const   *tmp___4 ;
  int tmp___79 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___115 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___134 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  size_t tmp___150 ;
  int tmp___151 ;
  size_t tmp___152 ;
  int tmp___153 ;
  int tmp___154 ;
  char *tmp___155 ;
  char *tmp___156 ;
  char *tmp___161 ;
  int tmp___163 ;
  int tmp___164 ;
  int tmp___239 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___275 ;
  unsigned char const   *__s2___30 ;
  register int __result___90 ;
  int tmp___294 ;
  unsigned char const   *__s1___62 ;
  register int __result___94 ;
  int tmp___303 ;
  int tmp___304 ;
  int tmp___305 ;
  int tmp___306 ;
  int tmp___307 ;
  int tmp___308 ;
  int tmp___309 ;
  size_t tmp___310 ;
  int tmp___311 ;
  size_t tmp___312 ;
  char *tmp___317 ;
  int tmp___319 ;
  int tmp___320 ;
  char *tmp___321 ;
  int tmp___396 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___432 ;
  unsigned char const   *__s2___46 ;
  register int __result___138 ;
  int tmp___451 ;
  unsigned char const   *__s1___94 ;
  register int __result___142 ;
  int tmp___460 ;
  int tmp___461 ;
  int tmp___462 ;
  int tmp___463 ;
  int tmp___464 ;
  int tmp___465 ;
  int tmp___466 ;
  size_t tmp___467 ;
  int tmp___468 ;
  size_t tmp___469 ;
  int tmp___470 ;
  text const   *tmp___471 ;

  {
  cli_dbgmsg("in mbox()\n");
  i = dup(desc);
  fd = fdopen(i, "rb");
  if ((unsigned int )fd == (unsigned int )((void *)0)) {
    cli_errmsg("Can\'t open descriptor %d\n", desc);
    close(i);
    return (-4);
  }
  tmp = fgets((char * __restrict  )(buffer), (int )(sizeof(buffer) - 1U), (FILE * __restrict  )fd);
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
    fclose(fd);
    return (0);
  }
  pthread_mutex_lock(& tables_mutex);
  if ((unsigned int )rfc821 == (unsigned int )((void *)0)) {
    tmp___0 = initialiseTables(& rfc821, & subtype);
    if (tmp___0 < 0) {
      rfc821 = (table_t *)((void *)0);
      subtype = (table_t *)((void *)0);
      pthread_mutex_unlock(& tables_mutex);
      fclose(fd);
      return (-3);
    }
  }
  pthread_mutex_unlock(& tables_mutex);
  tmp___466 = __builtin_constant_p((int )(buffer));
  if (tmp___466) {
    tmp___467 = strlen((char const   *)(buffer));
    if (tmp___467 < 5U) {
      goto _L___123;
    } else {
      goto _L___124;
    }
  } else {
    _L___124: 
    tmp___468 = __builtin_constant_p((int )"From ");
    if (tmp___468) {
      tmp___469 = strlen("From ");
      if (tmp___469 < 5U) {
        _L___123: 
        tmp___463 = __builtin_constant_p((int )(buffer));
        if (tmp___463) {
          tmp___464 = __builtin_constant_p((int )"From ");
          if (tmp___464) {
            __s1_len___4 = strlen((char const   *)(buffer));
            __s2_len___4 = strlen("From ");
            if (! ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                   1U)) {
              goto _L___120;
            } else {
              if (__s1_len___4 >= 4U) {
                _L___120: 
                if (! ((unsigned int )((void const   *)("From " + 1)) - (unsigned int )((void const   *)"From ") ==
                       1U)) {
                  tmp___465 = 1;
                } else {
                  if (__s2_len___4 >= 4U) {
                    tmp___465 = 1;
                  } else {
                    tmp___465 = 0;
                  }
                }
              } else {
                tmp___465 = 0;
              }
            }
            if (tmp___465) {
              tmp___432 = __builtin_strcmp(buffer, "From ");
            } else {
              goto _L___122;
            }
          } else {
            goto _L___122;
          }
        } else {
          _L___122: 
          tmp___462 = __builtin_constant_p((int )(buffer));
          if (tmp___462) {
            if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                1U) {
              __s1_len___4 = strlen((char const   *)(buffer));
              if (__s1_len___4 < 4U) {
                tmp___451 = __builtin_constant_p((int )"From ");
                if (tmp___451) {
                  if ((unsigned int )((void const   *)("From " + 1)) - (unsigned int )((void const   *)"From ") ==
                      1U) {
                    tmp___432 = __builtin_strcmp(buffer, "From ");
                  } else {
                    goto _L___115;
                  }
                } else {
                  _L___115: 
                  __s2___46 = (unsigned char const   *)"From ";
                  __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                           0)) - (int const   )(*(__s2___46 +
                                                                                  0)));
                  if (__s1_len___4 > 0U) {
                    if (__result___138 == 0) {
                      __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                               1)) - (int const   )(*(__s2___46 +
                                                                                      1)));
                      if (__s1_len___4 > 1U) {
                        if (__result___138 == 0) {
                          __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                   2)) - (int const   )(*(__s2___46 +
                                                                                          2)));
                          if (__s1_len___4 > 2U) {
                            if (__result___138 == 0) {
                              __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                       3)) - (int const   )(*(__s2___46 +
                                                                                              3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___432 = __result___138;
                }
              } else {
                goto _L___119;
              }
            } else {
              goto _L___119;
            }
          } else {
            _L___119: 
            tmp___461 = __builtin_constant_p((int )"From ");
            if (tmp___461) {
              if ((unsigned int )((void const   *)("From " + 1)) - (unsigned int )((void const   *)"From ") ==
                  1U) {
                __s2_len___4 = strlen("From ");
                if (__s2_len___4 < 4U) {
                  tmp___460 = __builtin_constant_p((int )(buffer));
                  if (tmp___460) {
                    if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                        1U) {
                      tmp___432 = __builtin_strcmp(buffer, "From ");
                    } else {
                      goto _L___117;
                    }
                  } else {
                    _L___117: 
                    __s1___94 = (unsigned char const   *)((char const   *)(buffer));
                    __result___142 = (int )((int const   )(*(__s1___94 + 0)) - (int const   )(*((unsigned char const   *)"From " +
                                                                                                0)));
                    if (__s2_len___4 > 0U) {
                      if (__result___142 == 0) {
                        __result___142 = (int )((int const   )(*(__s1___94 + 1)) -
                                                (int const   )(*((unsigned char const   *)"From " +
                                                                 1)));
                        if (__s2_len___4 > 1U) {
                          if (__result___142 == 0) {
                            __result___142 = (int )((int const   )(*(__s1___94 + 2)) -
                                                    (int const   )(*((unsigned char const   *)"From " +
                                                                     2)));
                            if (__s2_len___4 > 2U) {
                              if (__result___142 == 0) {
                                __result___142 = (int )((int const   )(*(__s1___94 +
                                                                         3)) - (int const   )(*((unsigned char const   *)"From " +
                                                                                                3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___432 = __result___142;
                  }
                } else {
                  tmp___432 = __builtin_strcmp(buffer, "From ");
                }
              } else {
                tmp___432 = __builtin_strcmp(buffer, "From ");
              }
            } else {
              tmp___432 = __builtin_strcmp(buffer, "From ");
            }
          }
        }
        tmp___396 = tmp___432;
      } else {
        tmp___396 = strncmp((char const   *)(buffer), "From ", 5U);
      }
    } else {
      tmp___396 = strncmp((char const   *)(buffer), "From ", 5U);
    }
  }
  if (tmp___396 == 0) {
    tmp___1 = messageCreate();
    m = tmp___1;
    if ((unsigned int )m == (unsigned int )((void *)0)) {
      fclose(fd);
      return (-3);
    }
    lastLineWasEmpty = (enum __anonenum_bool_35 )0;
    messagenumber = 1;
    while (1) {
      cli_chomp(buffer);
      if (lastLineWasEmpty) {
        tmp___149 = __builtin_constant_p((int )(buffer));
        if (tmp___149) {
          tmp___150 = strlen((char const   *)(buffer));
          if (tmp___150 < 5U) {
            goto _L___39;
          } else {
            goto _L___40;
          }
        } else {
          _L___40: 
          tmp___151 = __builtin_constant_p((int )"From ");
          if (tmp___151) {
            tmp___152 = strlen("From ");
            if (tmp___152 < 5U) {
              _L___39: 
              tmp___146 = __builtin_constant_p((int )(buffer));
              if (tmp___146) {
                tmp___147 = __builtin_constant_p((int )"From ");
                if (tmp___147) {
                  __s1_len___0 = strlen((char const   *)(buffer));
                  __s2_len___0 = strlen("From ");
                  if (! ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                         1U)) {
                    goto _L___36;
                  } else {
                    if (__s1_len___0 >= 4U) {
                      _L___36: 
                      if (! ((unsigned int )((void const   *)("From " + 1)) - (unsigned int )((void const   *)"From ") ==
                             1U)) {
                        tmp___148 = 1;
                      } else {
                        if (__s2_len___0 >= 4U) {
                          tmp___148 = 1;
                        } else {
                          tmp___148 = 0;
                        }
                      }
                    } else {
                      tmp___148 = 0;
                    }
                  }
                  if (tmp___148) {
                    tmp___115 = __builtin_strcmp(buffer, "From ");
                  } else {
                    goto _L___38;
                  }
                } else {
                  goto _L___38;
                }
              } else {
                _L___38: 
                tmp___145 = __builtin_constant_p((int )(buffer));
                if (tmp___145) {
                  if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                      1U) {
                    __s1_len___0 = strlen((char const   *)(buffer));
                    if (__s1_len___0 < 4U) {
                      tmp___134 = __builtin_constant_p((int )"From ");
                      if (tmp___134) {
                        if ((unsigned int )((void const   *)("From " + 1)) - (unsigned int )((void const   *)"From ") ==
                            1U) {
                          tmp___115 = __builtin_strcmp(buffer, "From ");
                        } else {
                          goto _L___31;
                        }
                      } else {
                        _L___31: 
                        __s2___14 = (unsigned char const   *)"From ";
                        __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                0)) - (int const   )(*(__s2___14 +
                                                                                       0)));
                        if (__s1_len___0 > 0U) {
                          if (__result___42 == 0) {
                            __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                    1)) - (int const   )(*(__s2___14 +
                                                                                           1)));
                            if (__s1_len___0 > 1U) {
                              if (__result___42 == 0) {
                                __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                        2)) - (int const   )(*(__s2___14 +
                                                                                               2)));
                                if (__s1_len___0 > 2U) {
                                  if (__result___42 == 0) {
                                    __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                            3)) -
                                                           (int const   )(*(__s2___14 +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
                        tmp___115 = __result___42;
                      }
                    } else {
                      goto _L___35;
                    }
                  } else {
                    goto _L___35;
                  }
                } else {
                  _L___35: 
                  tmp___144 = __builtin_constant_p((int )"From ");
                  if (tmp___144) {
                    if ((unsigned int )((void const   *)("From " + 1)) - (unsigned int )((void const   *)"From ") ==
                        1U) {
                      __s2_len___0 = strlen("From ");
                      if (__s2_len___0 < 4U) {
                        tmp___143 = __builtin_constant_p((int )(buffer));
                        if (tmp___143) {
                          if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                              1U) {
                            tmp___115 = __builtin_strcmp(buffer, "From ");
                          } else {
                            goto _L___33;
                          }
                        } else {
                          _L___33: 
                          __s1___30 = (unsigned char const   *)((char const   *)(buffer));
                          __result___46 = (int )((int const   )(*(__s1___30 + 0)) -
                                                 (int const   )(*((unsigned char const   *)"From " +
                                                                  0)));
                          if (__s2_len___0 > 0U) {
                            if (__result___46 == 0) {
                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                      1)) - (int const   )(*((unsigned char const   *)"From " +
                                                                                             1)));
                              if (__s2_len___0 > 1U) {
                                if (__result___46 == 0) {
                                  __result___46 = (int )((int const   )(*(__s1___30 +
                                                                          2)) - (int const   )(*((unsigned char const   *)"From " +
                                                                                                 2)));
                                  if (__s2_len___0 > 2U) {
                                    if (__result___46 == 0) {
                                      __result___46 = (int )((int const   )(*(__s1___30 +
                                                                              3)) -
                                                             (int const   )(*((unsigned char const   *)"From " +
                                                                              3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
                          tmp___115 = __result___46;
                        }
                      } else {
                        tmp___115 = __builtin_strcmp(buffer, "From ");
                      }
                    } else {
                      tmp___115 = __builtin_strcmp(buffer, "From ");
                    }
                  } else {
                    tmp___115 = __builtin_strcmp(buffer, "From ");
                  }
                }
              }
              tmp___79 = tmp___115;
            } else {
              tmp___79 = strncmp((char const   *)(buffer), "From ", 5U);
            }
          } else {
            tmp___79 = strncmp((char const   *)(buffer), "From ", 5U);
          }
        }
        if (tmp___79 == 0) {
          tmp___2 = messagenumber;
          messagenumber ++;
          cli_dbgmsg("Deal with email number %d\n", tmp___2);
          body___0 = parseEmailHeaders((message const   *)m, (table_t const   *)rfc821);
          if ((unsigned int )body___0 == (unsigned int )((void *)0)) {
            messageReset(m);
            goto __Cont;
          }
          messageDestroy(m);
          tmp___4 = messageGetBody((message const   *)body___0);
          if (tmp___4) {
            tmp___3 = parseEmailBody(body___0, (text *)((void *)0), dir, (table_t const   *)rfc821,
                                     (table_t const   *)subtype, options);
            if (! tmp___3) {
              messageReset(body___0);
              m = body___0;
              goto __Cont;
            }
          }
          m = body___0;
          messageReset(body___0);
          cli_dbgmsg("Finished processing message\n");
        } else {
          lastLineWasEmpty = (enum __anonenum_bool_35 )((int )buffer[0] == 0);
        }
      } else {
        lastLineWasEmpty = (enum __anonenum_bool_35 )((int )buffer[0] == 0);
      }
      tmp___154 = isuuencodebegin((char const   *)(buffer));
      if (tmp___154) {
        uufasttrack(m, (char const   *)(buffer), dir, fd);
      } else {
        tmp___153 = messageAddStr(m, (char const   *)(buffer));
        if (tmp___153 < 0) {
          break;
        }
      }
      __Cont: 
      tmp___155 = fgets((char * __restrict  )(buffer), (int )(sizeof(buffer) - 1U),
                        (FILE * __restrict  )fd);
      if (! ((unsigned int )tmp___155 != (unsigned int )((void *)0))) {
        break;
      }
    }
    fclose(fd);
    cli_dbgmsg("Extract attachments from email %d\n", messagenumber);
    body___0 = parseEmailHeaders((message const   *)m, (table_t const   *)rfc821);
    messageDestroy(m);
  } else {
    tmp___309 = __builtin_constant_p((int )(buffer));
    if (tmp___309) {
      tmp___310 = strlen((char const   *)(buffer));
      if (tmp___310 < 4U) {
        goto _L___81;
      } else {
        goto _L___82;
      }
    } else {
      _L___82: 
      tmp___311 = __builtin_constant_p((int )"P I ");
      if (tmp___311) {
        tmp___312 = strlen("P I ");
        if (tmp___312 < 4U) {
          _L___81: 
          tmp___306 = __builtin_constant_p((int )(buffer));
          if (tmp___306) {
            tmp___307 = __builtin_constant_p((int )"P I ");
            if (tmp___307) {
              __s1_len___2 = strlen((char const   *)(buffer));
              __s2_len___2 = strlen("P I ");
              if (! ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                     1U)) {
                goto _L___78;
              } else {
                if (__s1_len___2 >= 4U) {
                  _L___78: 
                  if (! ((unsigned int )((void const   *)("P I " + 1)) - (unsigned int )((void const   *)"P I ") ==
                         1U)) {
                    tmp___308 = 1;
                  } else {
                    if (__s2_len___2 >= 4U) {
                      tmp___308 = 1;
                    } else {
                      tmp___308 = 0;
                    }
                  }
                } else {
                  tmp___308 = 0;
                }
              }
              if (tmp___308) {
                tmp___275 = __builtin_strcmp(buffer, "P I ");
              } else {
                goto _L___80;
              }
            } else {
              goto _L___80;
            }
          } else {
            _L___80: 
            tmp___305 = __builtin_constant_p((int )(buffer));
            if (tmp___305) {
              if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                  1U) {
                __s1_len___2 = strlen((char const   *)(buffer));
                if (__s1_len___2 < 4U) {
                  tmp___294 = __builtin_constant_p((int )"P I ");
                  if (tmp___294) {
                    if ((unsigned int )((void const   *)("P I " + 1)) - (unsigned int )((void const   *)"P I ") ==
                        1U) {
                      tmp___275 = __builtin_strcmp(buffer, "P I ");
                    } else {
                      goto _L___73;
                    }
                  } else {
                    _L___73: 
                    __s2___30 = (unsigned char const   *)"P I ";
                    __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                            0)) - (int const   )(*(__s2___30 +
                                                                                   0)));
                    if (__s1_len___2 > 0U) {
                      if (__result___90 == 0) {
                        __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                1)) - (int const   )(*(__s2___30 +
                                                                                       1)));
                        if (__s1_len___2 > 1U) {
                          if (__result___90 == 0) {
                            __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                    2)) - (int const   )(*(__s2___30 +
                                                                                           2)));
                            if (__s1_len___2 > 2U) {
                              if (__result___90 == 0) {
                                __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                        3)) - (int const   )(*(__s2___30 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___275 = __result___90;
                  }
                } else {
                  goto _L___77;
                }
              } else {
                goto _L___77;
              }
            } else {
              _L___77: 
              tmp___304 = __builtin_constant_p((int )"P I ");
              if (tmp___304) {
                if ((unsigned int )((void const   *)("P I " + 1)) - (unsigned int )((void const   *)"P I ") ==
                    1U) {
                  __s2_len___2 = strlen("P I ");
                  if (__s2_len___2 < 4U) {
                    tmp___303 = __builtin_constant_p((int )(buffer));
                    if (tmp___303) {
                      if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                          1U) {
                        tmp___275 = __builtin_strcmp(buffer, "P I ");
                      } else {
                        goto _L___75;
                      }
                    } else {
                      _L___75: 
                      __s1___62 = (unsigned char const   *)((char const   *)(buffer));
                      __result___94 = (int )((int const   )(*(__s1___62 + 0)) - (int const   )(*((unsigned char const   *)"P I " +
                                                                                                 0)));
                      if (__s2_len___2 > 0U) {
                        if (__result___94 == 0) {
                          __result___94 = (int )((int const   )(*(__s1___62 + 1)) -
                                                 (int const   )(*((unsigned char const   *)"P I " +
                                                                  1)));
                          if (__s2_len___2 > 1U) {
                            if (__result___94 == 0) {
                              __result___94 = (int )((int const   )(*(__s1___62 +
                                                                      2)) - (int const   )(*((unsigned char const   *)"P I " +
                                                                                             2)));
                              if (__s2_len___2 > 2U) {
                                if (__result___94 == 0) {
                                  __result___94 = (int )((int const   )(*(__s1___62 +
                                                                          3)) - (int const   )(*((unsigned char const   *)"P I " +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___275 = __result___94;
                    }
                  } else {
                    tmp___275 = __builtin_strcmp(buffer, "P I ");
                  }
                } else {
                  tmp___275 = __builtin_strcmp(buffer, "P I ");
                }
              } else {
                tmp___275 = __builtin_strcmp(buffer, "P I ");
              }
            }
          }
          tmp___239 = tmp___275;
        } else {
          tmp___239 = strncmp((char const   *)(buffer), "P I ", 4U);
        }
      } else {
        tmp___239 = strncmp((char const   *)(buffer), "P I ", 4U);
      }
    }
    if (tmp___239 == 0) {
      while (1) {
        tmp___156 = fgets((char * __restrict  )(buffer), (int )(sizeof(buffer) - 1U),
                          (FILE * __restrict  )fd);
        if ((unsigned int )tmp___156 != (unsigned int )((void *)0)) {
          tmp___163 = __builtin_constant_p((int )buffer[0]);
          if (tmp___163) {
            tmp___164 = __builtin_constant_p((int )"\r\n");
            if (tmp___164) {
              tmp___161 = (char *)__builtin_strchr("\r\n", buffer[0]);
            } else {
              if ((int )buffer[0] == 0) {
                tmp___161 = (char *)__rawmemchr((void const   *)"\r\n", (int )buffer[0]);
              } else {
                tmp___161 = (char *)__builtin_strchr("\r\n", buffer[0]);
              }
            }
          } else {
            tmp___161 = (char *)__builtin_strchr("\r\n", buffer[0]);
          }
          if (! ((unsigned int )tmp___161 == (unsigned int )((void *)0))) {
            break;
          }
        } else {
          break;
        }
      }
    }
    while (1) {
      tmp___319 = __builtin_constant_p((int )buffer[0]);
      if (tmp___319) {
        tmp___320 = __builtin_constant_p((int )"\r\n");
        if (tmp___320) {
          tmp___317 = (char *)__builtin_strchr("\r\n", buffer[0]);
        } else {
          if ((int )buffer[0] == 0) {
            tmp___317 = (char *)__rawmemchr((void const   *)"\r\n", (int )buffer[0]);
          } else {
            tmp___317 = (char *)__builtin_strchr("\r\n", buffer[0]);
          }
        }
      } else {
        tmp___317 = (char *)__builtin_strchr("\r\n", buffer[0]);
      }
      if (tmp___317) {
        tmp___321 = getline(buffer, sizeof(buffer) - 1U, fd);
        if (! ((unsigned int )tmp___321 != (unsigned int )((void *)0))) {
          break;
        }
      } else {
        break;
      }
    }
    buffer[sizeof(buffer) - 1U] = (char )'\000';
    body___0 = parseEmailFile(fd, (table_t const   *)rfc821, (char const   *)(buffer),
                              dir);
    fclose(fd);
  }
  retcode = 0;
  if (body___0) {
    tmp___471 = messageGetBody((message const   *)body___0);
    if (tmp___471) {
      tmp___470 = parseEmailBody(body___0, (text *)((void *)0), dir, (table_t const   *)rfc821,
                                 (table_t const   *)subtype, options);
      if (! tmp___470) {
        retcode = -13;
      }
    }
    messageDestroy(body___0);
  }
  cli_dbgmsg("cli_mbox returning %d\n", retcode);
  return (retcode);
}
}
static message *parseEmailFile(FILE *fin , table_t const   *rfc821___0 , char const   *firstLine ,
                               char const   *dir ) 
{ bool inHeader ;
  bool contMarker ;
  bool lastWasBlank ;
  message *ret ;
  bool anyHeadersFound ;
  int commandNumber ;
  char *fullline ;
  char *boundary ;
  size_t fulllinelength ;
  char buffer[1001] ;
  char *line ;
  int tmp ;
  char const   *tmp___0 ;
  char copy[(int )sizeof(buffer)] ;
  int tmp___1 ;
  unsigned short const   **tmp___3 ;
  char *ptr ;
  char const   *qptr ;
  int lookahead ;
  char cmd[1001] ;
  char out[1001] ;
  int tmp___78 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___114 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___133 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  size_t tmp___149 ;
  int tmp___150 ;
  size_t tmp___151 ;
  char *tmp___155 ;
  int tmp___157 ;
  char *tmp___158 ;
  char *tmp___159 ;
  size_t __len___2 ;
  size_t tmp___176 ;
  char *__retval___2 ;
  char *tmp___177 ;
  int tmp___179 ;
  size_t tmp___180 ;
  size_t tmp___181 ;
  int quotes ;
  int tmp___182 ;
  int tmp___183 ;
  int tmp___184 ;
  char *tmp___185 ;

  {
  inHeader = (enum __anonenum_bool_35 )1;
  contMarker = (enum __anonenum_bool_35 )0;
  lastWasBlank = (enum __anonenum_bool_35 )0;
  anyHeadersFound = (enum __anonenum_bool_35 )0;
  commandNumber = -1;
  fullline = (char *)((void *)0);
  boundary = (char *)((void *)0);
  fulllinelength = 0U;
  cli_dbgmsg("parseEmailFile\n");
  ret = messageCreate();
  if ((unsigned int )ret == (unsigned int )((void *)0)) {
    return ((message *)((void *)0));
  }
  strcpy((char * __restrict  )(buffer), (char const   * __restrict  )firstLine);
  while (1) {
    cli_chomp(buffer);
    line = buffer;
    if ((int )(*(line + 0)) == 0) {
      line = (char *)((void *)0);
    }
    if (lastWasBlank) {
      lastWasBlank = (enum __anonenum_bool_35 )0;
      tmp = boundaryStart((char const   *)(buffer), (char const   *)boundary);
      if (tmp) {
        cli_dbgmsg("Found a header line with space that should be blank\n");
        inHeader = (enum __anonenum_bool_35 )0;
      }
    }
    if (boundary) {
      free((void *)boundary);
      boundary = (char *)((void *)0);
    }
    if (inHeader) {
      if (buffer) {
        tmp___0 = (char const   *)(buffer);
      } else {
        tmp___0 = "";
      }
      cli_dbgmsg("parseEmailFile: check \'%s\' contMarker %d fullline 0x%p\n", tmp___0,
                 (int )contMarker, fullline);
      if (line) {
        tmp___3 = __ctype_b_loc();
        if ((int const   )(*((*tmp___3) + (int )(*(line + 0)))) & 8192) {
          strcpy((char * __restrict  )(copy), (char const   * __restrict  )(buffer));
          strstrip(copy);
          if ((int )copy[0] == 0) {
            if (fullline) {
              tmp___1 = parseEmailHeader(ret, (char const   *)fullline, rfc821___0);
              if (tmp___1 < 0) {
                goto __Cont;
              }
              free((void *)fullline);
              fullline = (char *)((void *)0);
            }
            boundary = messageFindArgument((message const   *)ret, "boundary");
            if ((unsigned int )boundary != (unsigned int )((void *)0)) {
              lastWasBlank = (enum __anonenum_bool_35 )1;
              goto __Cont;
            }
          }
        }
      }
      lastWasBlank = (enum __anonenum_bool_35 )0;
      if ((unsigned int )line == (unsigned int )((void *)0)) {
        if ((unsigned int )fullline == (unsigned int )((void *)0)) {
          if (! contMarker) {
            if (! anyHeadersFound) {
              goto __Cont;
            }
            cli_dbgmsg("End of header information\n");
            inHeader = (enum __anonenum_bool_35 )0;
          } else {
            contMarker = (enum __anonenum_bool_35 )0;
          }
        } else {
          goto _L___42;
        }
      } else {
        _L___42: 
        if ((unsigned int )fullline == (unsigned int )((void *)0)) {
          if ((int )(*(line + 0)) == 9) {
            contMarker = continuationMarker((char const   *)line);
            goto __Cont;
          } else {
            if ((int )(*(line + 0)) == 32) {
              contMarker = continuationMarker((char const   *)line);
              goto __Cont;
            } else {
              if (contMarker) {
                contMarker = continuationMarker((char const   *)line);
                goto __Cont;
              }
            }
          }
          tmp___157 = __builtin_constant_p((int )line);
          if (tmp___157) {
            tmp___155 = (char *)__builtin_strchr(line, ':');
          } else {
            tmp___155 = (char *)__builtin_strchr(line, ':');
          }
          if ((unsigned int )tmp___155 == (unsigned int )((void *)0)) {
            goto _L___41;
          } else {
            tmp___158 = cli_strtokbuf((char const   *)line, 0, ":", cmd);
            if ((unsigned int )tmp___158 == (unsigned int )((void *)0)) {
              _L___41: 
              tmp___148 = __builtin_constant_p((int )line);
              if (tmp___148) {
                tmp___149 = strlen((char const   *)line);
                if (tmp___149 < 5U) {
                  goto _L___39;
                } else {
                  goto _L___40;
                }
              } else {
                _L___40: 
                tmp___150 = __builtin_constant_p((int )"From ");
                if (tmp___150) {
                  tmp___151 = strlen("From ");
                  if (tmp___151 < 5U) {
                    _L___39: 
                    tmp___145 = __builtin_constant_p((int )line);
                    if (tmp___145) {
                      tmp___146 = __builtin_constant_p((int )"From ");
                      if (tmp___146) {
                        __s1_len___0 = strlen((char const   *)line);
                        __s2_len___0 = strlen("From ");
                        if (! ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                               1U)) {
                          goto _L___36;
                        } else {
                          if (__s1_len___0 >= 4U) {
                            _L___36: 
                            if (! ((unsigned int )((void const   *)("From " + 1)) -
                                   (unsigned int )((void const   *)"From ") == 1U)) {
                              tmp___147 = 1;
                            } else {
                              if (__s2_len___0 >= 4U) {
                                tmp___147 = 1;
                              } else {
                                tmp___147 = 0;
                              }
                            }
                          } else {
                            tmp___147 = 0;
                          }
                        }
                        if (tmp___147) {
                          tmp___114 = __builtin_strcmp(line, "From ");
                        } else {
                          goto _L___38;
                        }
                      } else {
                        goto _L___38;
                      }
                    } else {
                      _L___38: 
                      tmp___144 = __builtin_constant_p((int )line);
                      if (tmp___144) {
                        if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                            1U) {
                          __s1_len___0 = strlen((char const   *)line);
                          if (__s1_len___0 < 4U) {
                            tmp___133 = __builtin_constant_p((int )"From ");
                            if (tmp___133) {
                              if ((unsigned int )((void const   *)("From " + 1)) -
                                  (unsigned int )((void const   *)"From ") == 1U) {
                                tmp___114 = __builtin_strcmp(line, "From ");
                              } else {
                                goto _L___31;
                              }
                            } else {
                              _L___31: 
                              __s2___14 = (unsigned char const   *)"From ";
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)line) +
                                                                      0)) - (int const   )(*(__s2___14 +
                                                                                             0)));
                              if (__s1_len___0 > 0U) {
                                if (__result___42 == 0) {
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)line) +
                                                                          1)) - (int const   )(*(__s2___14 +
                                                                                                 1)));
                                  if (__s1_len___0 > 1U) {
                                    if (__result___42 == 0) {
                                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)line) +
                                                                              2)) -
                                                             (int const   )(*(__s2___14 +
                                                                              2)));
                                      if (__s1_len___0 > 2U) {
                                        if (__result___42 == 0) {
                                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)line) +
                                                                                  3)) -
                                                                 (int const   )(*(__s2___14 +
                                                                                  3)));
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              tmp___114 = __result___42;
                            }
                          } else {
                            goto _L___35;
                          }
                        } else {
                          goto _L___35;
                        }
                      } else {
                        _L___35: 
                        tmp___143 = __builtin_constant_p((int )"From ");
                        if (tmp___143) {
                          if ((unsigned int )((void const   *)("From " + 1)) - (unsigned int )((void const   *)"From ") ==
                              1U) {
                            __s2_len___0 = strlen("From ");
                            if (__s2_len___0 < 4U) {
                              tmp___142 = __builtin_constant_p((int )line);
                              if (tmp___142) {
                                if ((unsigned int )((void const   *)(line + 1)) -
                                    (unsigned int )((void const   *)line) == 1U) {
                                  tmp___114 = __builtin_strcmp(line, "From ");
                                } else {
                                  goto _L___33;
                                }
                              } else {
                                _L___33: 
                                __s1___30 = (unsigned char const   *)((char const   *)line);
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        0)) - (int const   )(*((unsigned char const   *)"From " +
                                                                                               0)));
                                if (__s2_len___0 > 0U) {
                                  if (__result___46 == 0) {
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            1)) -
                                                           (int const   )(*((unsigned char const   *)"From " +
                                                                            1)));
                                    if (__s2_len___0 > 1U) {
                                      if (__result___46 == 0) {
                                        __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                2)) -
                                                               (int const   )(*((unsigned char const   *)"From " +
                                                                                2)));
                                        if (__s2_len___0 > 2U) {
                                          if (__result___46 == 0) {
                                            __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                    3)) -
                                                                   (int const   )(*((unsigned char const   *)"From " +
                                                                                    3)));
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                                tmp___114 = __result___46;
                              }
                            } else {
                              tmp___114 = __builtin_strcmp(line, "From ");
                            }
                          } else {
                            tmp___114 = __builtin_strcmp(line, "From ");
                          }
                        } else {
                          tmp___114 = __builtin_strcmp(line, "From ");
                        }
                      }
                    }
                    tmp___78 = tmp___114;
                  } else {
                    tmp___78 = strncmp((char const   *)line, "From ", 5U);
                  }
                } else {
                  tmp___78 = strncmp((char const   *)line, "From ", 5U);
                }
              }
              if (tmp___78 == 0) {
                anyHeadersFound = (enum __anonenum_bool_35 )1;
              }
              goto __Cont;
            }
          }
          ptr = rfc822comments((char const   *)(cmd), out);
          if (ptr) {
            tmp___159 = ptr;
          } else {
            tmp___159 = cmd;
          }
          commandNumber = tableFind(rfc821___0, (char const   *)tmp___159);
          switch (commandNumber) {
          case 2: ;
          case 3: ;
          case 1: 
          anyHeadersFound = (enum __anonenum_bool_35 )1;
          break;
          default: ;
          if (! anyHeadersFound) {
            anyHeadersFound = usefulHeader(commandNumber, (char const   *)(cmd));
          }
          goto __Cont;
          }
          tmp___179 = __builtin_constant_p((int )line);
          if (tmp___179) {
            if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                1U) {
              if ((int const   )(*((char const   *)line + 0)) == 0) {
                fullline = (char *)calloc(1U, 1U);
              } else {
                tmp___176 = strlen((char const   *)line);
                __len___2 = tmp___176 + 1U;
                tmp___177 = (char *)malloc(__len___2);
                __retval___2 = tmp___177;
                if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
                  __retval___2 = (char *)memcpy((void * __restrict  )__retval___2,
                                                (void const   * __restrict  )line,
                                                __len___2);
                }
                fullline = __retval___2;
              }
            } else {
              fullline = __strdup((char const   *)line);
            }
          } else {
            fullline = __strdup((char const   *)line);
          }
          tmp___180 = strlen((char const   *)line);
          fulllinelength = tmp___180 + 1U;
        } else {
          if ((unsigned int )line != (unsigned int )((void *)0)) {
            tmp___181 = strlen((char const   *)line);
            fulllinelength += tmp___181;
            fullline = (char *)cli_realloc((void *)fullline, fulllinelength);
            strcat((char * __restrict  )fullline, (char const   * __restrict  )line);
          }
        }
        if (line) {
          contMarker = continuationMarker((char const   *)line);
          if (contMarker) {
            goto __Cont;
          }
        } else {
          contMarker = (enum __anonenum_bool_35 )0;
        }
        lookahead = _IO_getc(fin);
        if (lookahead != -1) {
          ungetc(lookahead, fin);
          if (lookahead == 9) {
            goto __Cont;
          } else {
            if (lookahead == 32) {
              goto __Cont;
            }
          }
        }
        if (line) {
          quotes = 0;
          qptr = (char const   *)fullline;
          while ((*qptr)) {
            if ((int const   )(*qptr) == 34) {
              quotes ++;
            }
            qptr ++;
          }
          if (quotes & 1) {
            goto __Cont;
          }
        }
        ptr = rfc822comments((char const   *)fullline, (char *)((void *)0));
        if (ptr) {
          free((void *)fullline);
          fullline = ptr;
        }
        tmp___182 = parseEmailHeader(ret, (char const   *)fullline, rfc821___0);
        if (tmp___182 < 0) {
          goto __Cont;
        }
        free((void *)fullline);
        fullline = (char *)((void *)0);
      }
    } else {
      if (line) {
        tmp___184 = isuuencodebegin((char const   *)line);
        if (tmp___184) {
          uufasttrack(ret, (char const   *)line, dir, fin);
        } else {
          goto _L___43;
        }
      } else {
        _L___43: 
        tmp___183 = messageAddStr(ret, (char const   *)line);
        if (tmp___183 < 0) {
          break;
        }
      }
    }
    __Cont: 
    tmp___185 = getline(buffer, sizeof(buffer) - 1U, fin);
    if (! ((unsigned int )tmp___185 != (unsigned int )((void *)0))) {
      break;
    }
  }
  if (fullline) {
    if ((*fullline)) {
      switch (commandNumber) {
      case 2: ;
      case 3: ;
      case 1: 
      cli_dbgmsg("parseEmailHeaders: Fullline unparsed \'%s\'\n", fullline);
      }
    }
    free((void *)fullline);
  }
  if (! anyHeadersFound) {
    messageDestroy(ret);
    cli_dbgmsg("parseEmailFile: no headers found, assuming it isn\'t an email\n");
    return ((message *)((void *)0));
  }
  messageClean(ret);
  cli_dbgmsg("parseEmailFile: return\n");
  return (ret);
}
}
static message *parseEmailHeaders(message const   *m , table_t const   *rfc821___0 ) 
{ bool inHeader ;
  text const   *t ;
  message *ret ;
  bool anyHeadersFound ;
  int commandNumber ;
  char *fullline ;
  size_t fulllinelength ;
  char const   *buffer ;
  char const   *tmp ;
  char *ptr ;
  char const   *qptr ;
  int quotes ;
  char cmd[1001] ;
  int tmp___74 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___110 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___129 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  size_t tmp___145 ;
  int tmp___146 ;
  size_t tmp___147 ;
  char *tmp___151 ;
  int tmp___153 ;
  char *tmp___154 ;
  char *tmp___155 ;
  size_t __len___2 ;
  size_t tmp___172 ;
  char *__retval___2 ;
  char *tmp___173 ;
  int tmp___175 ;
  size_t tmp___176 ;
  size_t tmp___177 ;
  char const   *tmp___178 ;
  int tmp___179 ;
  int tmp___180 ;

  {
  inHeader = (enum __anonenum_bool_35 )1;
  anyHeadersFound = (enum __anonenum_bool_35 )0;
  commandNumber = -1;
  fullline = (char *)((void *)0);
  fulllinelength = 0U;
  cli_dbgmsg("parseEmailHeaders\n");
  if ((unsigned int )m == (unsigned int )((void *)0)) {
    return ((message *)((void *)0));
  }
  ret = messageCreate();
  t = messageGetBody(m);
  while (t) {
    if (t->t_line) {
      buffer = lineGetData((line_t const   *)t->t_line);
    } else {
      buffer = (char const   *)((void *)0);
    }
    if (inHeader) {
      if (buffer) {
        tmp = buffer;
      } else {
        tmp = "";
      }
      cli_dbgmsg("parseEmailHeaders: check \'%s\'\n", tmp);
      if ((unsigned int )buffer == (unsigned int )((void *)0)) {
        cli_dbgmsg("End of header information\n");
        inHeader = (enum __anonenum_bool_35 )0;
        if (! anyHeadersFound) {
          cli_dbgmsg("Nothing interesting in the header\n");
          break;
        }
      } else {
        if ((unsigned int )fullline == (unsigned int )((void *)0)) {
          if ((int const   )(*(buffer + 0)) == 9) {
            goto __Cont;
          } else {
            if ((int const   )(*(buffer + 0)) == 32) {
              goto __Cont;
            }
          }
          tmp___153 = __builtin_constant_p((int )buffer);
          if (tmp___153) {
            tmp___151 = (char *)__builtin_strchr(buffer, ':');
          } else {
            tmp___151 = (char *)__builtin_strchr(buffer, ':');
          }
          if ((unsigned int )tmp___151 == (unsigned int )((void *)0)) {
            goto _L___41;
          } else {
            tmp___154 = cli_strtokbuf(buffer, 0, ":", cmd);
            if ((unsigned int )tmp___154 == (unsigned int )((void *)0)) {
              _L___41: 
              tmp___144 = __builtin_constant_p((int )buffer);
              if (tmp___144) {
                tmp___145 = strlen(buffer);
                if (tmp___145 < 5U) {
                  goto _L___39;
                } else {
                  goto _L___40;
                }
              } else {
                _L___40: 
                tmp___146 = __builtin_constant_p((int )"From ");
                if (tmp___146) {
                  tmp___147 = strlen("From ");
                  if (tmp___147 < 5U) {
                    _L___39: 
                    tmp___141 = __builtin_constant_p((int )buffer);
                    if (tmp___141) {
                      tmp___142 = __builtin_constant_p((int )"From ");
                      if (tmp___142) {
                        __s1_len___0 = strlen(buffer);
                        __s2_len___0 = strlen("From ");
                        if (! ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)buffer) ==
                               1U)) {
                          goto _L___36;
                        } else {
                          if (__s1_len___0 >= 4U) {
                            _L___36: 
                            if (! ((unsigned int )((void const   *)("From " + 1)) -
                                   (unsigned int )((void const   *)"From ") == 1U)) {
                              tmp___143 = 1;
                            } else {
                              if (__s2_len___0 >= 4U) {
                                tmp___143 = 1;
                              } else {
                                tmp___143 = 0;
                              }
                            }
                          } else {
                            tmp___143 = 0;
                          }
                        }
                        if (tmp___143) {
                          tmp___110 = __builtin_strcmp(buffer, "From ");
                        } else {
                          goto _L___38;
                        }
                      } else {
                        goto _L___38;
                      }
                    } else {
                      _L___38: 
                      tmp___140 = __builtin_constant_p((int )buffer);
                      if (tmp___140) {
                        if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)buffer) ==
                            1U) {
                          __s1_len___0 = strlen(buffer);
                          if (__s1_len___0 < 4U) {
                            tmp___129 = __builtin_constant_p((int )"From ");
                            if (tmp___129) {
                              if ((unsigned int )((void const   *)("From " + 1)) -
                                  (unsigned int )((void const   *)"From ") == 1U) {
                                tmp___110 = __builtin_strcmp(buffer, "From ");
                              } else {
                                goto _L___31;
                              }
                            } else {
                              _L___31: 
                              __s2___14 = (unsigned char const   *)"From ";
                              __result___42 = (int )((int const   )(*((unsigned char const   *)buffer +
                                                                      0)) - (int const   )(*(__s2___14 +
                                                                                             0)));
                              if (__s1_len___0 > 0U) {
                                if (__result___42 == 0) {
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)buffer +
                                                                          1)) - (int const   )(*(__s2___14 +
                                                                                                 1)));
                                  if (__s1_len___0 > 1U) {
                                    if (__result___42 == 0) {
                                      __result___42 = (int )((int const   )(*((unsigned char const   *)buffer +
                                                                              2)) -
                                                             (int const   )(*(__s2___14 +
                                                                              2)));
                                      if (__s1_len___0 > 2U) {
                                        if (__result___42 == 0) {
                                          __result___42 = (int )((int const   )(*((unsigned char const   *)buffer +
                                                                                  3)) -
                                                                 (int const   )(*(__s2___14 +
                                                                                  3)));
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              tmp___110 = __result___42;
                            }
                          } else {
                            goto _L___35;
                          }
                        } else {
                          goto _L___35;
                        }
                      } else {
                        _L___35: 
                        tmp___139 = __builtin_constant_p((int )"From ");
                        if (tmp___139) {
                          if ((unsigned int )((void const   *)("From " + 1)) - (unsigned int )((void const   *)"From ") ==
                              1U) {
                            __s2_len___0 = strlen("From ");
                            if (__s2_len___0 < 4U) {
                              tmp___138 = __builtin_constant_p((int )buffer);
                              if (tmp___138) {
                                if ((unsigned int )((void const   *)(buffer + 1)) -
                                    (unsigned int )((void const   *)buffer) == 1U) {
                                  tmp___110 = __builtin_strcmp(buffer, "From ");
                                } else {
                                  goto _L___33;
                                }
                              } else {
                                _L___33: 
                                __s1___30 = (unsigned char const   *)buffer;
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        0)) - (int const   )(*((unsigned char const   *)"From " +
                                                                                               0)));
                                if (__s2_len___0 > 0U) {
                                  if (__result___46 == 0) {
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            1)) -
                                                           (int const   )(*((unsigned char const   *)"From " +
                                                                            1)));
                                    if (__s2_len___0 > 1U) {
                                      if (__result___46 == 0) {
                                        __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                2)) -
                                                               (int const   )(*((unsigned char const   *)"From " +
                                                                                2)));
                                        if (__s2_len___0 > 2U) {
                                          if (__result___46 == 0) {
                                            __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                    3)) -
                                                                   (int const   )(*((unsigned char const   *)"From " +
                                                                                    3)));
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                                tmp___110 = __result___46;
                              }
                            } else {
                              tmp___110 = __builtin_strcmp(buffer, "From ");
                            }
                          } else {
                            tmp___110 = __builtin_strcmp(buffer, "From ");
                          }
                        } else {
                          tmp___110 = __builtin_strcmp(buffer, "From ");
                        }
                      }
                    }
                    tmp___74 = tmp___110;
                  } else {
                    tmp___74 = strncmp(buffer, "From ", 5U);
                  }
                } else {
                  tmp___74 = strncmp(buffer, "From ", 5U);
                }
              }
              if (tmp___74 == 0) {
                anyHeadersFound = (enum __anonenum_bool_35 )1;
              }
              goto __Cont;
            }
          }
          ptr = rfc822comments((char const   *)(cmd), (char *)((void *)0));
          if (ptr) {
            tmp___155 = ptr;
          } else {
            tmp___155 = cmd;
          }
          commandNumber = tableFind(rfc821___0, (char const   *)tmp___155);
          if (ptr) {
            free((void *)ptr);
          }
          switch (commandNumber) {
          case 2: ;
          case 3: ;
          case 1: 
          anyHeadersFound = (enum __anonenum_bool_35 )1;
          break;
          default: ;
          if (! anyHeadersFound) {
            anyHeadersFound = usefulHeader(commandNumber, (char const   *)(cmd));
          }
          goto __Cont;
          }
          tmp___175 = __builtin_constant_p((int )buffer);
          if (tmp___175) {
            if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)buffer) ==
                1U) {
              if ((int const   )(*(buffer + 0)) == 0) {
                fullline = (char *)calloc(1U, 1U);
              } else {
                tmp___172 = strlen(buffer);
                __len___2 = tmp___172 + 1U;
                tmp___173 = (char *)malloc(__len___2);
                __retval___2 = tmp___173;
                if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
                  __retval___2 = (char *)memcpy((void * __restrict  )__retval___2,
                                                (void const   * __restrict  )buffer,
                                                __len___2);
                }
                fullline = __retval___2;
              }
            } else {
              fullline = __strdup(buffer);
            }
          } else {
            fullline = __strdup(buffer);
          }
          tmp___176 = strlen(buffer);
          fulllinelength = tmp___176 + 1U;
        } else {
          if (buffer) {
            tmp___177 = strlen(buffer);
            fulllinelength += tmp___177;
            fullline = (char *)cli_realloc((void *)fullline, fulllinelength);
            strcat((char * __restrict  )fullline, (char const   * __restrict  )buffer);
          }
        }
        if (t->t_next) {
          if ((unsigned int )(t->t_next)->t_line != (unsigned int )((void *)0)) {
            tmp___178 = lineGetData((line_t const   *)(t->t_next)->t_line);
            switch ((int )(*(tmp___178 + 0))) {
            case 32: ;
            case 9: ;
            goto __Cont;
            }
          }
        }
        quotes = 0;
        qptr = (char const   *)fullline;
        while ((*qptr)) {
          if ((int const   )(*qptr) == 34) {
            quotes ++;
          }
          qptr ++;
        }
        if (quotes & 1) {
          goto __Cont;
        }
        ptr = rfc822comments((char const   *)fullline, (char *)((void *)0));
        if (ptr) {
          free((void *)fullline);
          fullline = ptr;
        }
        tmp___179 = parseEmailHeader(ret, (char const   *)fullline, rfc821___0);
        if (tmp___179 < 0) {
          goto __Cont;
        }
        free((void *)fullline);
        fullline = (char *)((void *)0);
      }
    } else {
      tmp___180 = messageAddLine(ret, t->t_line);
      if (tmp___180 < 0) {
        break;
      }
    }
    __Cont: 
    t = (text const   *)t->t_next;
  }
  if (fullline) {
    if ((*fullline)) {
      switch (commandNumber) {
      case 2: ;
      case 3: ;
      case 1: 
      cli_dbgmsg("parseEmailHeaders: Fullline unparsed \'%s\'\n", fullline);
      }
    }
    free((void *)fullline);
  }
  if (! anyHeadersFound) {
    messageDestroy(ret);
    cli_dbgmsg("parseEmailHeaders: no headers found, assuming it isn\'t an email\n");
    return ((message *)((void *)0));
  }
  messageClean(ret);
  cli_dbgmsg("parseEmailHeaders: return\n");
  return (ret);
}
}
static int parseEmailHeader(message *m , char const   *line , table_t const   *rfc821___0 ) 
{ char *cmd ;
  int ret ;
  char *strptr ;
  char const   *separater ;
  char *copy ;
  char tokenseparater[2] ;
  char *tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __len___2 ;
  size_t tmp___23 ;
  char *__retval___2 ;
  char *tmp___24 ;
  int tmp___26 ;
  int tmp___34 ;
  char *arg ;
  char *tmp___40 ;
  int tmp___43 ;
  size_t tmp___44 ;

  {
  ret = -1;
  cli_dbgmsg("parseEmailHeader \'%s\'\n", line);
  separater = ":= ";
  while ((*separater)) {
    tmp___5 = __builtin_constant_p((int )(*separater));
    if (tmp___5) {
      tmp___6 = __builtin_constant_p((int )line);
      if (tmp___6) {
        tmp___3 = (char *)__builtin_strchr(line, (*separater));
      } else {
        if ((int const   )(*separater) == 0) {
          tmp___3 = (char *)__rawmemchr((void const   *)line, (int )(*separater));
        } else {
          tmp___3 = (char *)__builtin_strchr(line, (*separater));
        }
      }
    } else {
      tmp___3 = (char *)__builtin_strchr(line, (*separater));
    }
    if ((unsigned int )tmp___3 != (unsigned int )((void *)0)) {
      break;
    }
    separater ++;
  }
  if ((int const   )(*separater) == 0) {
    return (-1);
  }
  copy = rfc2047(line);
  if ((unsigned int )copy == (unsigned int )((void *)0)) {
    tmp___26 = __builtin_constant_p((int )line);
    if (tmp___26) {
      if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
          1U) {
        if ((int const   )(*(line + 0)) == 0) {
          copy = (char *)calloc(1U, 1U);
        } else {
          tmp___23 = strlen(line);
          __len___2 = tmp___23 + 1U;
          tmp___24 = (char *)malloc(__len___2);
          __retval___2 = tmp___24;
          if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
            __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )line,
                                          __len___2);
          }
          copy = __retval___2;
        }
      } else {
        copy = __strdup(line);
      }
    } else {
      copy = __strdup(line);
    }
  }
  tokenseparater[0] = (char )(*separater);
  tokenseparater[1] = (char )'\000';
  tmp___34 = __builtin_constant_p((int )(tokenseparater));
  if (tmp___34) {
    if ((unsigned int )((void const   *)(tokenseparater + 1)) - (unsigned int )((void const   *)(tokenseparater)) ==
        1U) {
      if ((int const   )(*((char const   *)(tokenseparater) + 0)) != 0) {
        if ((int const   )(*((char const   *)(tokenseparater) + 1)) == 0) {
          cmd = __strtok_r_1c__extinline(copy, (char )(*((char const   *)(tokenseparater) +
                                                         0)), & strptr);
        } else {
          cmd = __strtok_r((char * __restrict  )copy, (char const   * __restrict  )(tokenseparater),
                           (char ** __restrict  )(& strptr));
        }
      } else {
        cmd = __strtok_r((char * __restrict  )copy, (char const   * __restrict  )(tokenseparater),
                         (char ** __restrict  )(& strptr));
      }
    } else {
      cmd = __strtok_r((char * __restrict  )copy, (char const   * __restrict  )(tokenseparater),
                       (char ** __restrict  )(& strptr));
    }
  } else {
    cmd = __strtok_r((char * __restrict  )copy, (char const   * __restrict  )(tokenseparater),
                     (char ** __restrict  )(& strptr));
  }
  if (cmd) {
    tmp___44 = strstrip(cmd);
    if (tmp___44 > 0U) {
      tmp___43 = __builtin_constant_p((int )"");
      if (tmp___43) {
        if ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") ==
            1U) {
          if ((int const   )(*("" + 0)) != 0) {
            if ((int const   )(*("" + 1)) == 0) {
              tmp___40 = __strtok_r_1c__extinline((char *)((void *)0), (char )(*("" +
                                                                                 0)),
                                                  & strptr);
            } else {
              tmp___40 = __strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )"",
                                    (char ** __restrict  )(& strptr));
            }
          } else {
            tmp___40 = __strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )"",
                                  (char ** __restrict  )(& strptr));
          }
        } else {
          tmp___40 = __strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )"",
                                (char ** __restrict  )(& strptr));
        }
      } else {
        tmp___40 = __strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )"",
                              (char ** __restrict  )(& strptr));
      }
      arg = tmp___40;
      if (arg) {
        ret = parseMimeHeader(m, (char const   *)cmd, rfc821___0, (char const   *)arg);
      }
    }
  }
  free((void *)copy);
  return (ret);
}
}
static int parseEmailBody(message *messageIn , text *textIn , char const   *dir ,
                          table_t const   *rfc821Table , table_t const   *subtypeTable ,
                          unsigned int options ) 
{ message **messages ;
  int inMimeHead ;
  int i ;
  int rc ;
  int htmltextPart ;
  int multiparts ;
  text *aText ;
  char const   *cptr ;
  message *mainMessage ;
  fileblob *fb ;
  mime_type mimeType ;
  int subtype___0 ;
  int inhead ;
  char const   *mimeSubtype ;
  char const   *boundary ;
  char *protocol ;
  text const   *t_line ;
  message *aMessage ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  encoding_type tmp___2 ;
  encoding_type tmp___3 ;
  encoding_type tmp___4 ;
  text const   *tmp___5 ;
  text const   *tmp___6 ;
  text const   *tmp___7 ;
  int lines ;
  message **m ;
  char const   *tmp___8 ;
  size_t tmp___9 ;
  text const   *tmp___10 ;
  char const   *line ;
  char const   *tmp___11 ;
  unsigned short const   **tmp___12 ;
  int quotes ;
  char *fullline ;
  char *ptr ;
  char const   *qptr ;
  text const   *next ;
  char const   *data ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  encoding_type tmp___15 ;
  mime_type tmp___16 ;
  int tmp___91 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___127 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___146 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___155 ;
  int tmp___156 ;
  int tmp___157 ;
  int tmp___158 ;
  int tmp___159 ;
  int tmp___160 ;
  int tmp___161 ;
  size_t tmp___162 ;
  int tmp___163 ;
  size_t tmp___164 ;
  int tmp___239 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___275 ;
  unsigned char const   *__s2___30 ;
  register int __result___90 ;
  int tmp___294 ;
  unsigned char const   *__s1___62 ;
  register int __result___94 ;
  int tmp___303 ;
  int tmp___304 ;
  int tmp___305 ;
  int tmp___306 ;
  int tmp___307 ;
  int tmp___308 ;
  int tmp___309 ;
  size_t tmp___310 ;
  int tmp___311 ;
  size_t tmp___312 ;
  mime_type tmp___313 ;
  unsigned short const   **tmp___314 ;
  size_t __len___2 ;
  size_t tmp___331 ;
  char *__retval___2 ;
  char *tmp___332 ;
  int tmp___334 ;
  char const   *data___0 ;
  char const   *tmp___335 ;
  unsigned short const   **tmp___336 ;
  size_t tmp___337 ;
  size_t tmp___338 ;
  int tmp___339 ;
  int tmp___340 ;
  int tmp___341 ;
  int tmp___342 ;
  int tmp___343 ;
  mime_type tmp___344 ;
  bool addToText ;
  char const   *dtype ;
  mime_type tmp___345 ;
  int tmp___346 ;
  text const   *tmp___347 ;
  text const   *tmp___348 ;
  text const   *tmp___349 ;
  text const   *tmp___350 ;
  int tmp___351 ;
  char *filename ;
  int tmp___354 ;
  int tmp___355 ;
  encoding_type tmp___356 ;
  text const   *tmp___357 ;
  int tmp___358 ;
  encoding_type tmp___359 ;
  int tmp___360 ;
  text const   *tmp___361 ;
  mime_type tmp___362 ;
  text const   *tmp___363 ;
  int tmp___365 ;
  int tmp___366 ;
  message *m___0 ;
  message *tmp___367 ;
  text const   *tmp___368 ;
  int tmp___369 ;
  int tmp___370 ;
  int tmp___371 ;
  int tmp___372 ;
  int tmp___373 ;
  int tmp___374 ;
  text const   *tmp___375 ;
  text const   *t ;
  line_t const   *l ;
  text const   *lookahead ;
  text const   *topofbounce ;
  char const   *s ;
  bool inheader ;
  size_t tmp___376 ;
  cli_file_t tmp___377 ;
  char *tmp___378 ;
  int tmp___379 ;
  int tmp___380 ;
  char *tmp___381 ;
  char *tmp___382 ;
  char *tmp___383 ;
  size_t tmp___384 ;
  size_t tmp___385 ;
  cli_file_t tmp___386 ;
  text const   *t_line___0 ;
  text const   *t___0 ;
  text const   *start ;
  char cmd[1001] ;
  char const   *txt ;
  char const   *tmp___387 ;
  char *tmp___388 ;
  int tmp___389 ;
  char *tmp___390 ;
  char *tmp___391 ;
  char *tmp___392 ;
  int tmp___393 ;
  int tmp___394 ;
  fileblob *tmp___395 ;
  bool saveIt ;
  text const   *tmp___396 ;
  char const   *tmp___397 ;
  mime_type tmp___398 ;
  text const   *tmp___399 ;

  {
  rc = 1;
  multiparts = 0;
  cli_dbgmsg("in parseEmailBody\n");
  aText = textIn;
  messages = (message **)((void *)0);
  mainMessage = messageIn;
  if (mainMessage) {
    tmp___375 = messageGetBody((message const   *)mainMessage);
    if ((unsigned int )tmp___375 != (unsigned int )((void *)0)) {
      cli_dbgmsg("Parsing mail file\n");
      mimeType = messageGetMimeType((message const   *)mainMessage);
      mimeSubtype = messageGetMimeSubtype((message const   *)mainMessage);
      subtype___0 = tableFind(subtypeTable, mimeSubtype);
      if ((int )mimeType == 6) {
        if (subtype___0 == 1) {
          cli_dbgmsg("assume no encoding\n");
          mimeType = (enum __anonenum_mime_type_31 )0;
          messageSetMimeSubtype(mainMessage, "");
        } else {
          goto _L;
        }
      } else {
        _L: 
        if ((int )mimeType == 4) {
          tmp = strcasecmp(mimeSubtype, "rfc822-headers");
          if (tmp == 0) {
            cli_dbgmsg("Changing message/rfc822-headers to text/rfc822-headers\n");
            mimeType = (enum __anonenum_mime_type_31 )0;
            messageSetMimeSubtype(mainMessage, "");
          }
        }
      }
      cli_dbgmsg("mimeType = %d\n", mimeType);
      switch ((int )mimeType) {
      case 0: 
      cli_dbgmsg("Not a mime encoded message\n");
      aText = textAddMessage(aText, mainMessage);
      break;
      case 6: ;
      if (options & 256U) {
        if (subtype___0 == 3) {
          checkURLs(mainMessage, dir);
        }
      }
      break;
      case 5: 
      cli_dbgmsg("Content-type \'multipart\' handler\n");
      boundary = messageFindArgument((message const   *)mainMessage, "boundary");
      if ((unsigned int )boundary == (unsigned int )((void *)0)) {
        cli_warnmsg("Multipart MIME message contains no boundaries\n");
        mimeType = (enum __anonenum_mime_type_31 )0;
        break;
      }
      if ((int const   )(*(mimeSubtype + 0)) == 0) {
        cli_warnmsg("Multipart has no subtype assuming alternative\n");
        mimeSubtype = "alternative";
        messageSetMimeSubtype(mainMessage, "alternative");
      }
      t_line = messageGetBody((message const   *)mainMessage);
      if ((unsigned int )t_line == (unsigned int )((void *)0)) {
        cli_warnmsg("Multipart MIME message has no body\n");
        free((void *)((char *)boundary));
        mimeType = (enum __anonenum_mime_type_31 )0;
        break;
      }
      while (1) {
        if (t_line->t_line) {
          tmp___0 = lineGetData((line_t const   *)t_line->t_line);
          tmp___1 = boundaryStart(tmp___0, boundary);
          if (tmp___1) {
            break;
          }
          tmp___7 = uuencodeBegin((message const   *)mainMessage);
          if ((unsigned int )tmp___7 == (unsigned int )t_line) {
            tmp___2 = messageGetEncoding((message const   *)mainMessage);
            if ((int )tmp___2 == 0) {
              messageSetEncoding(mainMessage, "x-uuencode");
              fb = messageToFileblob(mainMessage, dir);
              if (fb) {
                fileblobDestroy(fb);
              }
            }
          } else {
            tmp___6 = binhexBegin((message const   *)mainMessage);
            if ((unsigned int )tmp___6 == (unsigned int )t_line) {
              tmp___3 = messageGetEncoding((message const   *)mainMessage);
              if ((int )tmp___3 == 0) {
                messageSetEncoding(mainMessage, "x-binhex");
                fb = messageToFileblob(mainMessage, dir);
                if (fb) {
                  fileblobDestroy(fb);
                }
              }
            } else {
              tmp___5 = encodingLine((message const   *)mainMessage);
              if ((unsigned int )tmp___5 == (unsigned int )t_line->t_next) {
                cli_dbgmsg("Found MIME attachment before the first MIME section\n");
                tmp___4 = messageGetEncoding((message const   *)mainMessage);
                if ((int )tmp___4 == 0) {
                  break;
                }
              }
            }
          }
        }
        t_line = (text const   *)t_line->t_next;
        if (! ((unsigned int )t_line != (unsigned int )((void *)0))) {
          break;
        }
      }
      if ((unsigned int )t_line == (unsigned int )((void *)0)) {
        cli_dbgmsg("Multipart MIME message contains no boundary lines\n");
        free((void *)((char *)boundary));
        mimeType = (enum __anonenum_mime_type_31 )0;
        break;
      }
      inhead = 1;
      inMimeHead = 0;
      multiparts = 0;
      while (t_line) {
        lines = 0;
        m = (message **)cli_realloc((void *)messages, (unsigned int )(multiparts +
                                                                      1) * sizeof(message *));
        if ((unsigned int )m == (unsigned int )((void *)0)) {
          break;
        }
        messages = m;
        (*(messages + multiparts)) = messageCreate();
        aMessage = (*(messages + multiparts));
        if ((unsigned int )aMessage == (unsigned int )((void *)0)) {
          multiparts --;
          goto __Cont;
        }
        cli_dbgmsg("Now read in part %d\n", multiparts);
        while (1) {
          t_line = (text const   *)t_line->t_next;
          if (! ((unsigned int )t_line != (unsigned int )((void *)0))) {
            break;
          }
          if (t_line->t_line) {
            tmp___8 = lineGetData((line_t const   *)t_line->t_line);
            tmp___9 = strlen(tmp___8);
            if (tmp___9 > 0U) {
              break;
            }
          }
        }
        if ((unsigned int )t_line == (unsigned int )((void *)0)) {
          cli_dbgmsg("Empty part\n");
          tmp___10 = uuencodeBegin((message const   *)mainMessage);
          if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
            messageDestroy(aMessage);
            multiparts --;
          }
          goto __Cont;
        }
        while (1) {
          tmp___11 = lineGetData((line_t const   *)t_line->t_line);
          line = tmp___11;
          if (inMimeHead) {
            if ((unsigned int )line == (unsigned int )((void *)0)) {
              inMimeHead = 0;
              goto __Cont___0;
            }
            cli_dbgmsg("Multipart %d: About to add mime Argument \'%s\'\n", multiparts,
                       line);
            parseEmailHeader(aMessage, line, rfc821Table);
            while (1) {
              tmp___12 = __ctype_b_loc();
              if (! ((int const   )(*((*tmp___12) + (int )(*line))) & 8192)) {
                break;
              }
              line ++;
            }
            if ((int const   )(*line) == 0) {
              inMimeHead = 0;
              inhead = inMimeHead;
              goto __Cont___0;
            }
            inMimeHead = (int )continuationMarker(line);
            messageAddArgument(aMessage, line);
          } else {
            if (inhead) {
              if ((unsigned int )line == (unsigned int )((void *)0)) {
                next = (text const   *)t_line->t_next;
                if (next) {
                  if (next->t_line) {
                    tmp___13 = lineGetData((line_t const   *)next->t_line);
                    data = tmp___13;
                    tmp___15 = messageGetEncoding((message const   *)aMessage);
                    if ((int )tmp___15 == 0) {
                      tmp___16 = messageGetMimeType((message const   *)aMessage);
                      if ((int )tmp___16 == 1) {
                        tmp___14 = strstr(data, "base64");
                        if (tmp___14) {
                          messageSetEncoding(aMessage, "base64");
                          cli_dbgmsg("Ignoring fake end of headers\n");
                          goto __Cont___0;
                        }
                      }
                    }
                    tmp___161 = __builtin_constant_p((int )data);
                    if (tmp___161) {
                      tmp___162 = strlen(data);
                      if (tmp___162 < 7U) {
                        goto _L___40;
                      } else {
                        goto _L___41;
                      }
                    } else {
                      _L___41: 
                      tmp___163 = __builtin_constant_p((int )"Content");
                      if (tmp___163) {
                        tmp___164 = strlen("Content");
                        if (tmp___164 < 7U) {
                          _L___40: 
                          tmp___158 = __builtin_constant_p((int )data);
                          if (tmp___158) {
                            tmp___159 = __builtin_constant_p((int )"Content");
                            if (tmp___159) {
                              __s1_len___0 = strlen(data);
                              __s2_len___0 = strlen("Content");
                              if (! ((unsigned int )((void const   *)(data + 1)) -
                                     (unsigned int )((void const   *)data) == 1U)) {
                                goto _L___37;
                              } else {
                                if (__s1_len___0 >= 4U) {
                                  _L___37: 
                                  if (! ((unsigned int )((void const   *)("Content" +
                                                                          1)) - (unsigned int )((void const   *)"Content") ==
                                         1U)) {
                                    tmp___160 = 1;
                                  } else {
                                    if (__s2_len___0 >= 4U) {
                                      tmp___160 = 1;
                                    } else {
                                      tmp___160 = 0;
                                    }
                                  }
                                } else {
                                  tmp___160 = 0;
                                }
                              }
                              if (tmp___160) {
                                tmp___127 = __builtin_strcmp(data, "Content");
                              } else {
                                goto _L___39;
                              }
                            } else {
                              goto _L___39;
                            }
                          } else {
                            _L___39: 
                            tmp___157 = __builtin_constant_p((int )data);
                            if (tmp___157) {
                              if ((unsigned int )((void const   *)(data + 1)) - (unsigned int )((void const   *)data) ==
                                  1U) {
                                __s1_len___0 = strlen(data);
                                if (__s1_len___0 < 4U) {
                                  tmp___146 = __builtin_constant_p((int )"Content");
                                  if (tmp___146) {
                                    if ((unsigned int )((void const   *)("Content" +
                                                                         1)) - (unsigned int )((void const   *)"Content") ==
                                        1U) {
                                      tmp___127 = __builtin_strcmp(data, "Content");
                                    } else {
                                      goto _L___32;
                                    }
                                  } else {
                                    _L___32: 
                                    __s2___14 = (unsigned char const   *)"Content";
                                    __result___42 = (int )((int const   )(*((unsigned char const   *)data +
                                                                            0)) -
                                                           (int const   )(*(__s2___14 +
                                                                            0)));
                                    if (__s1_len___0 > 0U) {
                                      if (__result___42 == 0) {
                                        __result___42 = (int )((int const   )(*((unsigned char const   *)data +
                                                                                1)) -
                                                               (int const   )(*(__s2___14 +
                                                                                1)));
                                        if (__s1_len___0 > 1U) {
                                          if (__result___42 == 0) {
                                            __result___42 = (int )((int const   )(*((unsigned char const   *)data +
                                                                                    2)) -
                                                                   (int const   )(*(__s2___14 +
                                                                                    2)));
                                            if (__s1_len___0 > 2U) {
                                              if (__result___42 == 0) {
                                                __result___42 = (int )((int const   )(*((unsigned char const   *)data +
                                                                                        3)) -
                                                                       (int const   )(*(__s2___14 +
                                                                                        3)));
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                    tmp___127 = __result___42;
                                  }
                                } else {
                                  goto _L___36;
                                }
                              } else {
                                goto _L___36;
                              }
                            } else {
                              _L___36: 
                              tmp___156 = __builtin_constant_p((int )"Content");
                              if (tmp___156) {
                                if ((unsigned int )((void const   *)("Content" + 1)) -
                                    (unsigned int )((void const   *)"Content") ==
                                    1U) {
                                  __s2_len___0 = strlen("Content");
                                  if (__s2_len___0 < 4U) {
                                    tmp___155 = __builtin_constant_p((int )data);
                                    if (tmp___155) {
                                      if ((unsigned int )((void const   *)(data +
                                                                           1)) - (unsigned int )((void const   *)data) ==
                                          1U) {
                                        tmp___127 = __builtin_strcmp(data, "Content");
                                      } else {
                                        goto _L___34;
                                      }
                                    } else {
                                      _L___34: 
                                      __s1___30 = (unsigned char const   *)data;
                                      __result___46 = (int )((int const   )(*(__s1___30 +
                                                                              0)) -
                                                             (int const   )(*((unsigned char const   *)"Content" +
                                                                              0)));
                                      if (__s2_len___0 > 0U) {
                                        if (__result___46 == 0) {
                                          __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                  1)) -
                                                                 (int const   )(*((unsigned char const   *)"Content" +
                                                                                  1)));
                                          if (__s2_len___0 > 1U) {
                                            if (__result___46 == 0) {
                                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                      2)) -
                                                                     (int const   )(*((unsigned char const   *)"Content" +
                                                                                      2)));
                                              if (__s2_len___0 > 2U) {
                                                if (__result___46 == 0) {
                                                  __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                          3)) -
                                                                         (int const   )(*((unsigned char const   *)"Content" +
                                                                                          3)));
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                      tmp___127 = __result___46;
                                    }
                                  } else {
                                    tmp___127 = __builtin_strcmp(data, "Content");
                                  }
                                } else {
                                  tmp___127 = __builtin_strcmp(data, "Content");
                                }
                              } else {
                                tmp___127 = __builtin_strcmp(data, "Content");
                              }
                            }
                          }
                          tmp___91 = tmp___127;
                        } else {
                          tmp___91 = strncmp(data, "Content", 7U);
                        }
                      } else {
                        tmp___91 = strncmp(data, "Content", 7U);
                      }
                    }
                    if (tmp___91 == 0) {
                      cli_dbgmsg("Ignoring fake end of headers\n");
                      goto __Cont___0;
                    } else {
                      tmp___309 = __builtin_constant_p((int )data);
                      if (tmp___309) {
                        tmp___310 = strlen(data);
                        if (tmp___310 < 9U) {
                          goto _L___82;
                        } else {
                          goto _L___83;
                        }
                      } else {
                        _L___83: 
                        tmp___311 = __builtin_constant_p((int )"filename=");
                        if (tmp___311) {
                          tmp___312 = strlen("filename=");
                          if (tmp___312 < 9U) {
                            _L___82: 
                            tmp___306 = __builtin_constant_p((int )data);
                            if (tmp___306) {
                              tmp___307 = __builtin_constant_p((int )"filename=");
                              if (tmp___307) {
                                __s1_len___2 = strlen(data);
                                __s2_len___2 = strlen("filename=");
                                if (! ((unsigned int )((void const   *)(data + 1)) -
                                       (unsigned int )((void const   *)data) == 1U)) {
                                  goto _L___79;
                                } else {
                                  if (__s1_len___2 >= 4U) {
                                    _L___79: 
                                    if (! ((unsigned int )((void const   *)("filename=" +
                                                                            1)) -
                                           (unsigned int )((void const   *)"filename=") ==
                                           1U)) {
                                      tmp___308 = 1;
                                    } else {
                                      if (__s2_len___2 >= 4U) {
                                        tmp___308 = 1;
                                      } else {
                                        tmp___308 = 0;
                                      }
                                    }
                                  } else {
                                    tmp___308 = 0;
                                  }
                                }
                                if (tmp___308) {
                                  tmp___275 = __builtin_strcmp(data, "filename=");
                                } else {
                                  goto _L___81;
                                }
                              } else {
                                goto _L___81;
                              }
                            } else {
                              _L___81: 
                              tmp___305 = __builtin_constant_p((int )data);
                              if (tmp___305) {
                                if ((unsigned int )((void const   *)(data + 1)) -
                                    (unsigned int )((void const   *)data) == 1U) {
                                  __s1_len___2 = strlen(data);
                                  if (__s1_len___2 < 4U) {
                                    tmp___294 = __builtin_constant_p((int )"filename=");
                                    if (tmp___294) {
                                      if ((unsigned int )((void const   *)("filename=" +
                                                                           1)) - (unsigned int )((void const   *)"filename=") ==
                                          1U) {
                                        tmp___275 = __builtin_strcmp(data, "filename=");
                                      } else {
                                        goto _L___74;
                                      }
                                    } else {
                                      _L___74: 
                                      __s2___30 = (unsigned char const   *)"filename=";
                                      __result___90 = (int )((int const   )(*((unsigned char const   *)data +
                                                                              0)) -
                                                             (int const   )(*(__s2___30 +
                                                                              0)));
                                      if (__s1_len___2 > 0U) {
                                        if (__result___90 == 0) {
                                          __result___90 = (int )((int const   )(*((unsigned char const   *)data +
                                                                                  1)) -
                                                                 (int const   )(*(__s2___30 +
                                                                                  1)));
                                          if (__s1_len___2 > 1U) {
                                            if (__result___90 == 0) {
                                              __result___90 = (int )((int const   )(*((unsigned char const   *)data +
                                                                                      2)) -
                                                                     (int const   )(*(__s2___30 +
                                                                                      2)));
                                              if (__s1_len___2 > 2U) {
                                                if (__result___90 == 0) {
                                                  __result___90 = (int )((int const   )(*((unsigned char const   *)data +
                                                                                          3)) -
                                                                         (int const   )(*(__s2___30 +
                                                                                          3)));
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                      tmp___275 = __result___90;
                                    }
                                  } else {
                                    goto _L___78;
                                  }
                                } else {
                                  goto _L___78;
                                }
                              } else {
                                _L___78: 
                                tmp___304 = __builtin_constant_p((int )"filename=");
                                if (tmp___304) {
                                  if ((unsigned int )((void const   *)("filename=" +
                                                                       1)) - (unsigned int )((void const   *)"filename=") ==
                                      1U) {
                                    __s2_len___2 = strlen("filename=");
                                    if (__s2_len___2 < 4U) {
                                      tmp___303 = __builtin_constant_p((int )data);
                                      if (tmp___303) {
                                        if ((unsigned int )((void const   *)(data +
                                                                             1)) -
                                            (unsigned int )((void const   *)data) ==
                                            1U) {
                                          tmp___275 = __builtin_strcmp(data, "filename=");
                                        } else {
                                          goto _L___76;
                                        }
                                      } else {
                                        _L___76: 
                                        __s1___62 = (unsigned char const   *)data;
                                        __result___94 = (int )((int const   )(*(__s1___62 +
                                                                                0)) -
                                                               (int const   )(*((unsigned char const   *)"filename=" +
                                                                                0)));
                                        if (__s2_len___2 > 0U) {
                                          if (__result___94 == 0) {
                                            __result___94 = (int )((int const   )(*(__s1___62 +
                                                                                    1)) -
                                                                   (int const   )(*((unsigned char const   *)"filename=" +
                                                                                    1)));
                                            if (__s2_len___2 > 1U) {
                                              if (__result___94 == 0) {
                                                __result___94 = (int )((int const   )(*(__s1___62 +
                                                                                        2)) -
                                                                       (int const   )(*((unsigned char const   *)"filename=" +
                                                                                        2)));
                                                if (__s2_len___2 > 2U) {
                                                  if (__result___94 == 0) {
                                                    __result___94 = (int )((int const   )(*(__s1___62 +
                                                                                            3)) -
                                                                           (int const   )(*((unsigned char const   *)"filename=" +
                                                                                            3)));
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                        tmp___275 = __result___94;
                                      }
                                    } else {
                                      tmp___275 = __builtin_strcmp(data, "filename=");
                                    }
                                  } else {
                                    tmp___275 = __builtin_strcmp(data, "filename=");
                                  }
                                } else {
                                  tmp___275 = __builtin_strcmp(data, "filename=");
                                }
                              }
                            }
                            tmp___239 = tmp___275;
                          } else {
                            tmp___239 = strncmp(data, "filename=", 9U);
                          }
                        } else {
                          tmp___239 = strncmp(data, "filename=", 9U);
                        }
                      }
                      if (tmp___239 == 0) {
                        cli_dbgmsg("Ignoring fake end of headers\n");
                        goto __Cont___0;
                      }
                    }
                  }
                }
                cli_dbgmsg("Multipart %d: End of header information\n", multiparts);
                inhead = 0;
                goto __Cont___0;
              }
              tmp___314 = __ctype_b_loc();
              if ((int const   )(*((*tmp___314) + (int )(*line))) & 8192) {
                cli_dbgmsg("Part %d starts with a continuation line\n", multiparts);
                messageAddArgument(aMessage, line);
                tmp___313 = messageGetMimeType((message const   *)aMessage);
                if ((int )tmp___313 == 0) {
                  messageSetMimeType(aMessage, "application");
                }
                goto __Cont___0;
              }
              inMimeHead = 0;
              fullline = rfc822comments(line, (char *)((void *)0));
              if ((unsigned int )fullline == (unsigned int )((void *)0)) {
                tmp___334 = __builtin_constant_p((int )line);
                if (tmp___334) {
                  if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                      1U) {
                    if ((int const   )(*(line + 0)) == 0) {
                      fullline = (char *)calloc(1U, 1U);
                    } else {
                      tmp___331 = strlen(line);
                      __len___2 = tmp___331 + 1U;
                      tmp___332 = (char *)malloc(__len___2);
                      __retval___2 = tmp___332;
                      if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
                        __retval___2 = (char *)memcpy((void * __restrict  )__retval___2,
                                                      (void const   * __restrict  )line,
                                                      __len___2);
                      }
                      fullline = __retval___2;
                    }
                  } else {
                    fullline = __strdup(line);
                  }
                } else {
                  fullline = __strdup(line);
                }
              }
              quotes = 0;
              qptr = (char const   *)fullline;
              while ((*qptr)) {
                if ((int const   )(*qptr) == 34) {
                  quotes ++;
                }
                qptr ++;
              }
              next = (text const   *)t_line->t_next;
              while (1) {
                if (next) {
                  if (! next->t_line) {
                    break;
                  }
                } else {
                  break;
                }
                tmp___335 = lineGetData((line_t const   *)next->t_line);
                data___0 = tmp___335;
                tmp___336 = __ctype_b_loc();
                if (! ((int const   )(*((*tmp___336) + (int )(*(data___0 + 0)))) &
                       8192)) {
                  break;
                }
                tmp___337 = strlen((char const   *)fullline);
                tmp___338 = strlen(data___0);
                ptr = (char *)cli_realloc((void *)fullline, (tmp___337 + tmp___338) +
                                                            1U);
                if ((unsigned int )ptr == (unsigned int )((void *)0)) {
                  break;
                }
                fullline = ptr;
                strcat((char * __restrict  )fullline, (char const   * __restrict  )data___0);
                t_line = next;
                next = (text const   *)next->t_next;
              }
              cli_dbgmsg("Multipart %d: About to parse folded header \'%s\'\n", multiparts,
                         fullline);
              parseEmailHeader(aMessage, (char const   *)fullline, rfc821Table);
              free((void *)fullline);
            } else {
              tmp___341 = endOfMessage(line, boundary);
              if (tmp___341) {
                break;
              } else {
                tmp___340 = boundaryStart(line, boundary);
                if (tmp___340) {
                  inhead = 1;
                  break;
                } else {
                  tmp___339 = messageAddLine(aMessage, t_line->t_line);
                  if (tmp___339 < 0) {
                    break;
                  }
                  lines ++;
                }
              }
            }
          }
          __Cont___0: 
          t_line = (text const   *)t_line->t_next;
          if (! ((unsigned int )t_line != (unsigned int )((void *)0))) {
            break;
          }
        }
        messageClean(aMessage);
        cli_dbgmsg("Part %d has %d lines\n", multiparts, lines);
        __Cont: 
        multiparts ++;
      }
      free((void *)((char *)boundary));
      tmp___342 = tableFind(subtypeTable, mimeSubtype);
      switch (tmp___342) {
      case 14: 
      cli_dbgmsg("multipart/knowbot parsed as multipart/mixed for now\n");
      mimeSubtype = "mixed";
      break;
      case -1: 
      cli_dbgmsg("Unsupported multipart format `%s\', parsed as mixed\n", mimeSubtype);
      mimeSubtype = "mixed";
      break;
      }
      if (mainMessage) {
        if ((unsigned int )mainMessage != (unsigned int )messageIn) {
          messageDestroy(mainMessage);
          mainMessage = (message *)((void *)0);
        }
      }
      if (multiparts == 0) {
        if (messages) {
          free((void *)messages);
        }
        return (2);
      }
      cli_dbgmsg("The message has %d parts\n", multiparts);
      cli_dbgmsg("Find out the multipart type (%s)\n", mimeSubtype);
      tmp___343 = tableFind(subtypeTable, mimeSubtype);
      switch (tmp___343) {
      case 10: 
      cli_dbgmsg("Multipart related handler\n");
      aMessage = (message *)((void *)0);
      htmltextPart = getTextPart((message * const  *)messages, (unsigned int )multiparts);
      if (htmltextPart >= 0) {
        aText = textAddMessage(aText, (*(messages + htmltextPart)));
      } else {
        i = 0;
        while (i < multiparts) {
          tmp___344 = messageGetMimeType((message const   *)(*(messages + i)));
          if ((int )tmp___344 == 5) {
            aMessage = (*(messages + i));
            htmltextPart = i;
            break;
          }
          i ++;
        }
      }
      if (htmltextPart == -1) {
        cli_dbgmsg("No HTML code found to be scanned");
      } else {
        rc = parseEmailBody(aMessage, aText, dir, rfc821Table, subtypeTable, options);
        if (rc == 1) {
          messageDestroy(aMessage);
          (*(messages + htmltextPart)) = (message *)((void *)0);
        }
      }
      case 7: ;
      case 6: 
      cli_dbgmsg("Multipart alternative handler\n");
      case 11: ;
      case 5: ;
      case 12: ;
      if (aText) {
        if (mainMessage) {
          if ((unsigned int )mainMessage != (unsigned int )messageIn) {
            messageDestroy(mainMessage);
          }
        }
        mainMessage = (message *)((void *)0);
      }
      cli_dbgmsg("Mixed message with %d parts\n", multiparts);
      i = 0;
      while (i < multiparts) {
        addToText = (enum __anonenum_bool_35 )0;
        aMessage = (*(messages + i));
        if ((unsigned int )aMessage == (unsigned int )((void *)0)) {
          goto __Cont___1;
        }
        tmp___345 = messageGetMimeType((message const   *)aMessage);
        cli_dbgmsg("Mixed message part %d is of type %d\n", i, tmp___345);
        tmp___346 = (int )messageGetMimeType((message const   *)aMessage);
        switch (tmp___346) {
        case 1: ;
        case 2: ;
        case 3: ;
        case 7: ;
        break;
        case 0: 
        cli_dbgmsg("No mime headers found in multipart part %d\n", i);
        if (mainMessage) {
          tmp___347 = uuencodeBegin((message const   *)aMessage);
          if (tmp___347) {
            cli_dbgmsg("Found uuencoded message in multipart/mixed mainMessage\n");
            messageSetEncoding(mainMessage, "x-uuencode");
            fb = messageToFileblob(mainMessage, dir);
            if (fb) {
              fileblobDestroy(fb);
            }
          }
          if ((unsigned int )mainMessage != (unsigned int )messageIn) {
            messageDestroy(mainMessage);
          }
          mainMessage = (message *)((void *)0);
        } else {
          if (aMessage) {
            tmp___349 = uuencodeBegin((message const   *)aMessage);
            if (tmp___349) {
              cli_dbgmsg("Found uuencoded message in multipart/mixed non mime part\n");
              messageSetEncoding(aMessage, "x-uuencode");
              fb = messageToFileblob(aMessage, dir);
              if (fb) {
                fileblobDestroy(fb);
              }
              messageReset((*(messages + i)));
            } else {
              tmp___348 = binhexBegin((message const   *)aMessage);
              if (tmp___348) {
                cli_dbgmsg("Found binhex message in multipart/mixed non mime part\n");
                messageSetEncoding(aMessage, "x-binhex");
                fb = messageToFileblob(aMessage, dir);
                if (fb) {
                  fileblobDestroy(fb);
                }
                messageReset((*(messages + i)));
              }
            }
          }
        }
        addToText = (enum __anonenum_bool_35 )1;
        tmp___350 = messageGetBody((message const   *)aMessage);
        if ((unsigned int )tmp___350 == (unsigned int )((void *)0)) {
          messageAddStr(aMessage, "No plain text alternative");
        }
        break;
        case 6: 
        dtype = messageGetDispositionType((message const   *)aMessage);
        cli_dbgmsg("Mixed message text part disposition \"%s\"\n", dtype);
        tmp___351 = strcasecmp(dtype, "attachment");
        if (tmp___351 == 0) {
          break;
        }
        if ((int const   )(*dtype) == 0) {
          goto _L___85;
        } else {
          tmp___358 = strcasecmp(dtype, "inline");
          if (tmp___358 == 0) {
            _L___85: 
            if (mainMessage) {
              if ((unsigned int )mainMessage != (unsigned int )messageIn) {
                messageDestroy(mainMessage);
              }
            }
            mainMessage = (message *)((void *)0);
            cptr = messageGetMimeSubtype((message const   *)aMessage);
            cli_dbgmsg("Mime subtype \"%s\"\n", cptr);
            tmp___357 = uuencodeBegin((message const   *)aMessage);
            if (tmp___357) {
              cli_dbgmsg("Found uuencoded message in multipart/mixed text portion\n");
              messageSetEncoding(aMessage, "x-uuencode");
            } else {
              tmp___355 = tableFind(subtypeTable, cptr);
              if (tmp___355 == 1) {
                tmp___356 = messageGetEncoding((message const   *)aMessage);
                if ((int )tmp___356 == 0) {
                  filename = messageFindArgument((message const   *)aMessage, "filename");
                  if ((unsigned int )filename == (unsigned int )((void *)0)) {
                    filename = messageFindArgument((message const   *)aMessage, "name");
                  }
                  if ((unsigned int )filename == (unsigned int )((void *)0)) {
                    cli_dbgmsg("Adding part to main message\n");
                    addToText = (enum __anonenum_bool_35 )1;
                  } else {
                    cli_dbgmsg("Treating %s as attachment\n", filename);
                    free((void *)filename);
                  }
                } else {
                  goto _L___84;
                }
              } else {
                _L___84: 
                if (options & 256U) {
                  tmp___354 = tableFind(subtypeTable, cptr);
                  if (tmp___354 == 3) {
                    checkURLs(aMessage, dir);
                  }
                }
                messageAddArgument(aMessage, "filename=mixedtextportion");
              }
            }
          } else {
            cli_dbgmsg("Text type %s is not supported\n", dtype);
            goto __Cont___1;
          }
        }
        break;
        case 4: 
        tmp___359 = messageGetEncoding((message const   *)aMessage);
        cli_dbgmsg("Found message inside multipart (encoding type %d)\n", tmp___359);
        tmp___360 = (int )messageGetEncoding((message const   *)aMessage);
        switch (tmp___360) {
        case 0: ;
        case 3: ;
        case 4: 
        tmp___361 = encodingLine((message const   *)aMessage);
        if ((unsigned int )tmp___361 == (unsigned int )((void *)0)) {
          cli_dbgmsg("No encoding line found in the multipart/message\n");
          messageDestroy((*(messages + i)));
          (*(messages + i)) = (message *)((void *)0);
          goto __Cont___1;
        }
        }
        saveTextPart(aMessage, dir);
        messageDestroy((*(messages + i)));
        (*(messages + i)) = (message *)((void *)0);
        goto __Cont___1;
        case 5: 
        cli_dbgmsg("Found multipart inside multipart\n");
        if (aMessage) {
          rc = parseEmailBody(aMessage, aText, dir, rfc821Table, subtypeTable, options);
          cli_dbgmsg("Finished recursion\n");
          messageDestroy((*(messages + i)));
          (*(messages + i)) = (message *)((void *)0);
        } else {
          rc = parseEmailBody((message *)((void *)0), (text *)((void *)0), dir, rfc821Table,
                              subtypeTable, options);
          if (mainMessage) {
            if ((unsigned int )mainMessage != (unsigned int )messageIn) {
              messageDestroy(mainMessage);
            }
          }
          mainMessage = (message *)((void *)0);
        }
        goto __Cont___1;
        default: 
        tmp___362 = messageGetMimeType((message const   *)aMessage);
        cli_warnmsg("Only text and application attachments are supported, type = %d\n",
                    tmp___362);
        goto __Cont___1;
        }
        if (addToText) {
          cli_dbgmsg("Adding to non mime-part\n");
          tmp___363 = messageGetBody((message const   *)aMessage);
          aText = textAdd(aText, tmp___363);
        } else {
          fb = messageToFileblob(aMessage, dir);
          if (fb) {
            fileblobDestroy(fb);
          }
        }
        messageDestroy((*(messages + i)));
        (*(messages + i)) = (message *)((void *)0);
        __Cont___1: 
        i ++;
      }
      break;
      case 8: ;
      case 9: 
      htmltextPart = getTextPart((message * const  *)messages, (unsigned int )multiparts);
      if (htmltextPart == -1) {
        htmltextPart = 0;
      }
      rc = parseEmailBody((*(messages + htmltextPart)), aText, dir, rfc821Table, subtypeTable,
                          options);
      break;
      case 13: 
      rc = 0;
      protocol = messageFindArgument((message const   *)mainMessage, "protocol");
      if (protocol) {
        tmp___365 = strcasecmp((char const   *)protocol, "application/pgp-encrypted");
        if (tmp___365 == 0) {
          cli_warnmsg("PGP encoded attachment not scanned\n");
          rc = 2;
        } else {
          cli_warnmsg("Unknown encryption protocol \'%s\' - if you believe this file contains a virus, report it to bugs@clamav.net\n");
        }
        free((void *)protocol);
      } else {
        cli_dbgmsg("Encryption method missing protocol name\n");
      }
      break;
      default: ;
      }
      if (mainMessage) {
        if ((unsigned int )mainMessage != (unsigned int )messageIn) {
          messageDestroy(mainMessage);
        }
      }
      if (aText) {
        if ((unsigned int )textIn == (unsigned int )((void *)0)) {
          fb = fileblobCreate();
          if ((unsigned int )fb != (unsigned int )((void *)0)) {
            cli_dbgmsg("Save non mime and/or text/plain part\n");
            fileblobSetFilename(fb, dir, "textpart");
            textToFileblob((text const   *)aText, fb);
            fileblobDestroy(fb);
          }
          textDestroy(aText);
        }
      }
      i = 0;
      while (i < multiparts) {
        if ((*(messages + i))) {
          messageDestroy((*(messages + i)));
        }
        i ++;
      }
      if (messages) {
        free((void *)messages);
      }
      return (rc);
      case 4: 
      tmp___366 = (int )messageGetEncoding((message const   *)mainMessage);
      switch (tmp___366) {
      case 0: ;
      case 3: ;
      case 4: ;
      break;
      default: 
      cli_warnmsg("MIME type \'message\' cannot be decoded\n");
      break;
      }
      rc = 0;
      tmp___373 = strcasecmp(mimeSubtype, "rfc822");
      if (tmp___373 == 0) {
        goto _L___86;
      } else {
        tmp___374 = strcasecmp(mimeSubtype, "delivery-status");
        if (tmp___374 == 0) {
          _L___86: 
          tmp___367 = parseEmailHeaders((message const   *)mainMessage, rfc821Table);
          m___0 = tmp___367;
          if (m___0) {
            cli_dbgmsg("Decode rfc822");
            if (mainMessage) {
              if ((unsigned int )mainMessage != (unsigned int )messageIn) {
                messageDestroy(mainMessage);
                mainMessage = (message *)((void *)0);
              } else {
                messageReset(mainMessage);
              }
            } else {
              messageReset(mainMessage);
            }
            tmp___368 = messageGetBody((message const   *)m___0);
            if (tmp___368) {
              rc = parseEmailBody(m___0, (text *)((void *)0), dir, rfc821Table, subtypeTable,
                                  options);
            }
            messageDestroy(m___0);
          }
          break;
        } else {
          tmp___372 = strcasecmp(mimeSubtype, "disposition-notification");
          if (tmp___372 == 0) {
            rc = 1;
            break;
          } else {
            tmp___371 = strcasecmp(mimeSubtype, "partial");
            if (tmp___371 == 0) {
              tmp___369 = rfc1341(mainMessage, dir);
              if (tmp___369 >= 0) {
                rc = 1;
              }
            } else {
              tmp___370 = strcasecmp(mimeSubtype, "external-body");
              if (tmp___370 == 0) {
                cli_warnmsg("Attempt to send Content-type message/external-body trapped");
              } else {
                cli_warnmsg("Unsupported message format `%s\' - if you believe this file contains a virus, report it to bugs@clamav.net\n",
                            mimeSubtype);
              }
            }
          }
        }
      }
      if (mainMessage) {
        if ((unsigned int )mainMessage != (unsigned int )messageIn) {
          messageDestroy(mainMessage);
        }
      }
      if (messages) {
        free((void *)messages);
      }
      return (rc);
      case 1: 
      fb = messageToFileblob(mainMessage, dir);
      if (fb) {
        cli_dbgmsg("Saving main message as attachment\n");
        fileblobDestroy(fb);
        if ((unsigned int )mainMessage != (unsigned int )messageIn) {
          messageDestroy(mainMessage);
          mainMessage = (message *)((void *)0);
        } else {
          messageReset(mainMessage);
        }
      }
      break;
      case 2: ;
      case 7: ;
      case 3: ;
      break;
      default: 
      cli_warnmsg("Message received with unknown mime encoding");
      break;
      }
    }
  }
  if (aText) {
    if ((unsigned int )textIn == (unsigned int )((void *)0)) {
      t = (text const   *)aText;
      while (t) {
        l = (line_t const   *)t->t_line;
        if ((unsigned int )l == (unsigned int )((void *)0)) {
          goto __Cont___2;
        }
        s = lineGetData(l);
        tmp___376 = strlen(s);
        tmp___377 = cli_filetype(s, tmp___376);
        if ((int )tmp___377 != 520) {
          goto __Cont___2;
        }
        lookahead = (text const   *)t->t_next;
        while (lookahead) {
          l = (line_t const   *)lookahead->t_line;
          if ((unsigned int )l == (unsigned int )((void *)0)) {
            break;
          }
          s = lineGetData(l);
          tmp___379 = strncasecmp(s, "Content-Type:", 13U);
          if (tmp___379 == 0) {
            tmp___378 = strstr(s, "text/");
            if ((unsigned int )tmp___378 == (unsigned int )((void *)0)) {
              break;
            }
          }
          lookahead = (text const   *)lookahead->t_next;
        }
        if (lookahead) {
          if ((unsigned int )lookahead->t_line == (unsigned int )((void *)0)) {
            cli_dbgmsg("Non mime part bounce message is not mime encoded, so it will not be scanned\n");
            t = lookahead;
            goto __Cont___2;
          }
        }
        while (lookahead) {
          l = (line_t const   *)lookahead->t_line;
          if (l) {
            s = lineGetData(l);
            tmp___380 = strncasecmp(s, "Content-Type:", 13U);
            if (tmp___380 == 0) {
              tmp___381 = strstr(s, "multipart/");
              if ((unsigned int )tmp___381 == (unsigned int )((void *)0)) {
                tmp___382 = strstr(s, "message/rfc822");
                if ((unsigned int )tmp___382 == (unsigned int )((void *)0)) {
                  tmp___383 = strstr(s, "text/plain");
                  if ((unsigned int )tmp___383 == (unsigned int )((void *)0)) {
                    break;
                  }
                }
              }
            }
          }
          lookahead = (text const   *)lookahead->t_next;
        }
        if ((unsigned int )lookahead == (unsigned int )((void *)0)) {
          cli_dbgmsg("cli_mbox: I believe it\'s plain text which must be clean\n");
          break;
        }
        fb = fileblobCreate();
        if ((unsigned int )fb == (unsigned int )((void *)0)) {
          break;
        }
        cli_dbgmsg("Save non mime part bounce message\n");
        fileblobSetFilename(fb, dir, "bounce");
        fileblobAddData(fb, (unsigned char const   *)((unsigned char *)"Received: by clamd (bounce)\n"),
                        28U);
        inheader = (enum __anonenum_bool_35 )1;
        topofbounce = (text const   *)((void *)0);
        while (1) {
          l = (line_t const   *)t->t_line;
          if ((unsigned int )l == (unsigned int )((void *)0)) {
            if (inheader) {
              inheader = (enum __anonenum_bool_35 )0;
              topofbounce = t;
            }
          } else {
            s = lineGetData(l);
            tmp___384 = strlen(s);
            fileblobAddData(fb, (unsigned char const   *)((unsigned char *)s), tmp___384);
          }
          fileblobAddData(fb, (unsigned char const   *)((unsigned char *)"\n"), 1U);
          lookahead = (text const   *)t->t_next;
          if ((unsigned int )lookahead == (unsigned int )((void *)0)) {
            break;
          }
          t = lookahead;
          l = (line_t const   *)t->t_line;
          if (! inheader) {
            if (l) {
              s = lineGetData(l);
              tmp___385 = strlen(s);
              tmp___386 = cli_filetype(s, tmp___385);
              if ((int )tmp___386 == 520) {
                cli_dbgmsg("Found the start of another bounce candidate\n");
                break;
              }
            }
          }
        }
        fileblobDestroy(fb);
        if (topofbounce) {
          t = topofbounce;
        }
        __Cont___2: 
        t = (text const   *)t->t_next;
      }
      textDestroy(aText);
      aText = (text *)((void *)0);
    }
  }
  cli_dbgmsg("%d multiparts found\n", multiparts);
  i = 0;
  while (i < multiparts) {
    fb = messageToFileblob((*(messages + i)), dir);
    if (fb) {
      cli_dbgmsg("Saving multipart %d\n", i);
      fileblobDestroy(fb);
    }
    i ++;
  }
  if (mainMessage) {
    t_line___0 = uuencodeBegin((message const   *)mainMessage);
    if ((unsigned int )t_line___0 != (unsigned int )((void *)0)) {
      cli_dbgmsg("Found uuencoded file\n");
      messageSetEncoding(mainMessage, "x-uuencode");
      fb = messageToFileblob(mainMessage, dir);
      if ((unsigned int )fb != (unsigned int )((void *)0)) {
        cptr = fileblobGetFilename((fileblob const   *)fb);
        if ((unsigned int )cptr != (unsigned int )((void *)0)) {
          cli_dbgmsg("Saving uuencoded message %s\n", cptr);
        }
        fileblobDestroy(fb);
      }
      rc = 1;
    } else {
      tmp___399 = encodingLine((message const   *)mainMessage);
      if ((unsigned int )tmp___399 != (unsigned int )((void *)0)) {
        t_line___0 = bounceBegin((message const   *)mainMessage);
        if ((unsigned int )t_line___0 != (unsigned int )((void *)0)) {
          start = t_line___0;
          t___0 = start;
          while (t___0) {
            tmp___387 = lineGetData((line_t const   *)t___0->t_line);
            txt = tmp___387;
            if ((unsigned int )txt == (unsigned int )((void *)0)) {
              goto __Cont___3;
            }
            tmp___388 = cli_strtokbuf(txt, 0, ":", cmd);
            if ((unsigned int )tmp___388 == (unsigned int )((void *)0)) {
              goto __Cont___3;
            }
            tmp___389 = tableFind(rfc821Table, (char const   *)(cmd));
            switch (tmp___389) {
            case 2: 
            tmp___390 = strstr(txt, "7bit");
            if ((unsigned int )tmp___390 == (unsigned int )((void *)0)) {
              tmp___391 = strstr(txt, "8bit");
              if ((unsigned int )tmp___391 == (unsigned int )((void *)0)) {
                break;
              }
            }
            goto __Cont___3;
            case 3: ;
            break;
            case 1: 
            tmp___392 = strstr(txt, "text/plain");
            if ((unsigned int )tmp___392 != (unsigned int )((void *)0)) {
              t___0 = (text const   *)((void *)0);
            }
            break;
            default: 
            tmp___394 = strcasecmp((char const   *)(cmd), "From");
            if (tmp___394 == 0) {
              start = t_line___0;
            } else {
              tmp___393 = strcasecmp((char const   *)(cmd), "Received");
              if (tmp___393 == 0) {
                start = t_line___0;
              }
            }
            goto __Cont___3;
            }
            break;
            __Cont___3: 
            t___0 = (text const   *)t___0->t_next;
          }
          if (t___0) {
            fb = fileblobCreate();
            if ((unsigned int )fb != (unsigned int )((void *)0)) {
              cli_dbgmsg("Found a bounce message\n");
              fileblobSetFilename(fb, dir, "bounce");
              tmp___395 = textToFileblob(start, fb);
              if ((unsigned int )tmp___395 == (unsigned int )((void *)0)) {
                cli_dbgmsg("Nothing new to save in the bounce message");
              } else {
                rc = 1;
              }
              fileblobDestroy(fb);
            } else {
              cli_dbgmsg("Not found a bounce message\n");
            }
          } else {
            cli_dbgmsg("Not found a bounce message\n");
          }
        } else {
          goto _L___87;
        }
      } else {
        _L___87: 
        cli_dbgmsg("Not found uuencoded file\n");
        tmp___398 = messageGetMimeType((message const   *)mainMessage);
        if ((int )tmp___398 == 4) {
          tmp___396 = encodingLine((message const   *)mainMessage);
          saveIt = (enum __anonenum_bool_35 )((unsigned int )tmp___396 != (unsigned int )((void *)0));
        } else {
          t_line___0 = encodingLine((message const   *)mainMessage);
          if ((unsigned int )t_line___0 != (unsigned int )((void *)0)) {
            fb = fileblobCreate();
            if ((unsigned int )fb != (unsigned int )((void *)0)) {
              tmp___397 = lineGetData((line_t const   *)t_line___0->t_line);
              cli_dbgmsg("Found a bounce message with no header at \'%s\'\n", tmp___397);
              fileblobSetFilename(fb, dir, "bounce");
              fileblobAddData(fb, (unsigned char const   *)"Received: by clamd (bounce)\n",
                              28U);
              fb = textToFileblob(t_line___0, fb);
              fileblobDestroy(fb);
            }
            saveIt = (enum __anonenum_bool_35 )0;
          } else {
            if (multiparts == 0) {
              saveIt = (enum __anonenum_bool_35 )1;
            } else {
              saveIt = (enum __anonenum_bool_35 )0;
            }
          }
        }
        if (saveIt) {
          cli_dbgmsg("Saving text part to scan\n");
          saveTextPart(mainMessage, dir);
          if ((unsigned int )mainMessage != (unsigned int )messageIn) {
            messageDestroy(mainMessage);
            mainMessage = (message *)((void *)0);
          } else {
            messageReset(mainMessage);
          }
          rc = 1;
        }
      }
    }
  } else {
    if (multiparts) {
      rc = 1;
    } else {
      rc = 2;
    }
  }
  if (mainMessage) {
    if ((unsigned int )mainMessage != (unsigned int )messageIn) {
      messageDestroy(mainMessage);
    }
  }
  if (messages) {
    free((void *)messages);
  }
  cli_dbgmsg("parseEmailBody() returning %d\n", rc);
  return (rc);
}
}
static int boundaryStart(char const   *line , char const   *boundary ) 
{ char *ptr ;
  char *out ;
  int rc ;
  char buf[1001] ;
  char *tmp___2 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  if ((unsigned int )line == (unsigned int )((void *)0)) {
    return (0);
  }
  if ((int const   )(*line) != 45) {
    if ((int const   )(*line) != 40) {
      return (0);
    }
  }
  tmp___4 = __builtin_constant_p((int )line);
  if (tmp___4) {
    tmp___2 = (char *)__builtin_strchr(line, '-');
  } else {
    tmp___2 = (char *)__builtin_strchr(line, '-');
  }
  if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
    return (0);
  }
  tmp___5 = strlen(line);
  if (tmp___5 <= sizeof(buf)) {
    out = (char *)((void *)0);
    ptr = rfc822comments(line, buf);
  } else {
    ptr = rfc822comments(line, (char *)((void *)0));
    out = ptr;
  }
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
    ptr = (char *)line;
  }
  tmp___6 = ptr;
  ptr ++;
  if ((int )(*tmp___6) != 45) {
    if (out) {
      free((void *)out);
    }
    return (0);
  }
  tmp___9 = strstr((char const   *)ptr, boundary);
  if ((unsigned int )tmp___9 != (unsigned int )((void *)0)) {
    rc = 1;
  } else {
    tmp___10 = strstr(line, boundary);
    if ((unsigned int )tmp___10 != (unsigned int )((void *)0)) {
      rc = 1;
    } else {
      tmp___8 = ptr;
      ptr ++;
      if ((int )(*tmp___8) != 45) {
        rc = 0;
      } else {
        tmp___7 = strcasecmp((char const   *)ptr, boundary);
        rc = tmp___7 == 0;
      }
    }
  }
  if (out) {
    free((void *)out);
  }
  if (rc == 1) {
    cli_dbgmsg("boundaryStart: found %s in %s\n", boundary, line);
  }
  return (rc);
}
}
static int endOfMessage(char const   *line , char const   *boundary ) 
{ size_t len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;

  {
  if ((unsigned int )line == (unsigned int )((void *)0)) {
    return (0);
  }
  tmp = line;
  line ++;
  if ((int const   )(*tmp) != 45) {
    return (0);
  }
  tmp___0 = line;
  line ++;
  if ((int const   )(*tmp___0) != 45) {
    return (0);
  }
  len = strlen(boundary);
  tmp___1 = strncasecmp(line, boundary, len);
  if (tmp___1 != 0) {
    return (0);
  }
  tmp___2 = strlen(line);
  if (tmp___2 < len + 2U) {
    return (0);
  }
  line = line + len;
  tmp___3 = line;
  line ++;
  if ((int const   )(*tmp___3) != 45) {
    return (0);
  }
  return ((int const   )(*line) == 45);
}
}
static int initialiseTables(table_t **rfc821Table , table_t **subtypeTable ) 
{ struct tableinit  const  *tableinit ;
  int tmp ;
  int tmp___0 ;

  {
  (*rfc821Table) = tableCreate();
  tableinit = rfc821headers;
  while (tableinit->key) {
    tmp = tableInsert((*rfc821Table), tableinit->key, tableinit->value);
    if (tmp < 0) {
      tableDestroy((*rfc821Table));
      (*rfc821Table) = (table_t *)((void *)0);
      return (-1);
    }
    tableinit ++;
  }
  (*subtypeTable) = tableCreate();
  tableinit = mimeSubtypes;
  while (tableinit->key) {
    tmp___0 = tableInsert((*subtypeTable), tableinit->key, tableinit->value);
    if (tmp___0 < 0) {
      tableDestroy((*rfc821Table));
      tableDestroy((*subtypeTable));
      (*rfc821Table) = (table_t *)((void *)0);
      (*subtypeTable) = (table_t *)((void *)0);
      return (-1);
    }
    tableinit ++;
  }
  return (0);
}
}
static int getTextPart(message * const  *messages , size_t size ) 
{ size_t i ;
  int textpart ;
  char const   *tmp ;
  int tmp___0 ;
  mime_type tmp___1 ;

  {
  textpart = -1;
  i = 0U;
  while (i < size) {
    tmp___1 = messageGetMimeType((message const   *)(*(messages + i)));
    if ((int )tmp___1 == 6) {
      tmp = messageGetMimeSubtype((message const   *)(*(messages + i)));
      tmp___0 = strcasecmp(tmp, "html");
      if (tmp___0 == 0) {
        return ((int )i);
      }
      textpart = (int )i;
    }
    i ++;
  }
  return (textpart);
}
}
static size_t strip(char *buf , int len ) 
{ register char *ptr ;
  register size_t i ;
  unsigned short const   **tmp ;

  {
  if ((unsigned int )buf == (unsigned int )((void *)0)) {
    return (0U);
  } else {
    if (len <= 0) {
      return (0U);
    }
  }
  i = strlen((char const   *)buf);
  if (len > (int )(i + 1U)) {
    return (i);
  }
  len --;
  ptr = buf + len;
  while (1) {
    if ((*ptr)) {
      (*ptr) = (char )'\000';
    }
    len --;
    if (len >= 0) {
      tmp = __ctype_b_loc();
      ptr --;
      if ((int const   )(*((*tmp) + (int )(*ptr))) & 32768) {
        break;
      } else {
        if ((int )(*ptr) != 10) {
          if (! ((int )(*ptr) != 13)) {
            break;
          }
        } else {
          break;
        }
      }
    } else {
      break;
    }
  }
  return ((unsigned int )(len + 1));
}
}
size_t strstrip(char *s ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
  if ((unsigned int )s == (unsigned int )((char *)((void *)0))) {
    return (0U);
  }
  tmp = strlen((char const   *)s);
  tmp___0 = strip(s, (int )(tmp + 1U));
  return (tmp___0);
}
}
static bool continuationMarker(char const   *line ) 
{ char const   *ptr ;
  size_t tmp ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  if ((unsigned int )line == (unsigned int )((void *)0)) {
    return ((enum __anonenum_bool_35 )0);
  }
  tmp = strlen(line);
  if (tmp == 0U) {
    return ((enum __anonenum_bool_35 )0);
  }
  tmp___4 = __builtin_constant_p((int )line);
  if (tmp___4) {
    ptr = (char const   *)__builtin_strchr(line, '\000');
  } else {
    tmp___3 = __rawmemchr((void const   *)line, '\000');
    ptr = (char const   *)((char *)tmp___3);
  }
  while ((unsigned int )ptr > (unsigned int )line) {
    ptr --;
    switch ((int )(*ptr)) {
    case 10: ;
    case 13: ;
    case 32: ;
    case 9: ;
    continue;
    case 59: ;
    return ((enum __anonenum_bool_35 )1);
    default: ;
    return ((enum __anonenum_bool_35 )0);
    }
  }
  return ((enum __anonenum_bool_35 )0);
}
}
static int parseMimeHeader(message *m , char const   *cmd , table_t const   *rfc821Table ,
                           char const   *arg ) 
{ char *copy ;
  char *p ;
  char const   *ptr ;
  int commandNumber ;
  int i ;
  char *mimeArgs ;
  unsigned short const   **tmp ;
  char *s ;
  char *mimeType ;
  char *strptr ;
  int set ;
  char *tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___17 ;
  size_t len ;
  size_t tmp___18 ;
  char *t ;
  char *tmp___19 ;
  char *tmp___23 ;
  int tmp___25 ;
  unsigned short const   **tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  char *tmp___32 ;
  int tmp___34 ;

  {
  cli_dbgmsg("parseMimeHeader: cmd=\'%s\', arg=\'%s\'\n", cmd, arg);
  copy = rfc822comments(cmd, (char *)((void *)0));
  if (copy) {
    commandNumber = tableFind(rfc821Table, (char const   *)copy);
    free((void *)copy);
  } else {
    commandNumber = tableFind(rfc821Table, cmd);
  }
  copy = rfc822comments(arg, (char *)((void *)0));
  if (copy) {
    ptr = (char const   *)copy;
  } else {
    ptr = arg;
  }
  switch (commandNumber) {
  case 1: ;
  if ((unsigned int )arg == (unsigned int )((void *)0)) {
    cli_warnmsg("Empty content-type received, no subtype specified, assuming text/plain; charset=us-ascii\n");
  } else {
    tmp___34 = __builtin_constant_p((int )ptr);
    if (tmp___34) {
      tmp___32 = (char *)__builtin_strchr(ptr, '/');
    } else {
      tmp___32 = (char *)__builtin_strchr(ptr, '/');
    }
    if ((unsigned int )tmp___32 == (unsigned int )((void *)0)) {
      cli_dbgmsg("Invalid content-type \'%s\' received, no subtype specified, assuming text/plain; charset=us-ascii\n",
                 ptr);
    } else {
      if ((int const   )(*arg) == 47) {
        cli_warnmsg("Content-type \'/\' received, assuming application/octet-stream\n");
        messageSetMimeType(m, "application");
        messageSetMimeSubtype(m, "octet-stream");
      } else {
        while (1) {
          tmp = __ctype_b_loc();
          if (! ((int const   )(*((*tmp) + (int )(*ptr))) & 8192)) {
            break;
          }
          ptr ++;
        }
        if ((int const   )(*(ptr + 0)) == 34) {
          ptr ++;
        }
        if ((int const   )(*(ptr + 0)) != 47) {
          mimeType = cli_strtok(ptr, 0, ";");
          s = mimeType;
          if (s) {
            if ((*s)) {
              while (1) {
                tmp___8 = __builtin_constant_p((int )"/");
                if (tmp___8) {
                  if ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") ==
                      1U) {
                    if ((int const   )(*("/" + 0)) != 0) {
                      if ((int const   )(*("/" + 1)) == 0) {
                        tmp___5 = __strtok_r_1c__extinline(s, (char )(*("/" + 0)),
                                                           & strptr);
                      } else {
                        tmp___5 = __strtok_r((char * __restrict  )s, (char const   * __restrict  )"/",
                                             (char ** __restrict  )(& strptr));
                      }
                    } else {
                      tmp___5 = __strtok_r((char * __restrict  )s, (char const   * __restrict  )"/",
                                           (char ** __restrict  )(& strptr));
                    }
                  } else {
                    tmp___5 = __strtok_r((char * __restrict  )s, (char const   * __restrict  )"/",
                                         (char ** __restrict  )(& strptr));
                  }
                } else {
                  tmp___5 = __strtok_r((char * __restrict  )s, (char const   * __restrict  )"/",
                                       (char ** __restrict  )(& strptr));
                }
                tmp___9 = messageSetMimeType(m, (char const   *)tmp___5);
                set = tmp___9;
                tmp___17 = __builtin_constant_p((int )";");
                if (tmp___17) {
                  if ((unsigned int )((void const   *)(";" + 1)) - (unsigned int )((void const   *)";") ==
                      1U) {
                    if ((int const   )(*(";" + 0)) != 0) {
                      if ((int const   )(*(";" + 1)) == 0) {
                        s = __strtok_r_1c__extinline((char *)((void *)0), (char )(*(";" +
                                                                                    0)),
                                                     & strptr);
                      } else {
                        s = __strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )";",
                                       (char ** __restrict  )(& strptr));
                      }
                    } else {
                      s = __strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )";",
                                     (char ** __restrict  )(& strptr));
                    }
                  } else {
                    s = __strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )";",
                                   (char ** __restrict  )(& strptr));
                  }
                } else {
                  s = __strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )";",
                                 (char ** __restrict  )(& strptr));
                }
                if ((unsigned int )s == (unsigned int )((void *)0)) {
                  break;
                }
                if (set) {
                  tmp___18 = strstrip(s);
                  len = tmp___18 - 1U;
                  if ((int )(*(s + len)) == 34) {
                    (*(s + len)) = (char )'\000';
                    len = strstrip(s);
                  }
                  if (len) {
                    tmp___25 = __builtin_constant_p((int )s);
                    if (tmp___25) {
                      tmp___23 = (char *)__builtin_strchr(s, ' ');
                    } else {
                      tmp___23 = (char *)__builtin_strchr(s, ' ');
                    }
                    if (tmp___23) {
                      tmp___19 = cli_strtok((char const   *)s, 0, " ");
                      t = tmp___19;
                      messageSetMimeSubtype(m, (char const   *)t);
                      free((void *)t);
                    } else {
                      messageSetMimeSubtype(m, (char const   *)s);
                    }
                  }
                }
                while (1) {
                  if ((*s)) {
                    tmp___26 = __ctype_b_loc();
                    if ((int const   )(*((*tmp___26) + (int )(*s))) & 8192) {
                      break;
                    }
                  } else {
                    break;
                  }
                  s ++;
                }
                tmp___27 = s;
                s ++;
                if ((int )(*tmp___27) == 0) {
                  break;
                }
                if ((int )(*s) == 0) {
                  break;
                }
              }
            }
          }
          if (mimeType) {
            free((void *)mimeType);
          }
        }
      }
      i = 1;
      while (1) {
        tmp___28 = i;
        i ++;
        mimeArgs = cli_strtok(ptr, tmp___28, ";");
        if (! ((unsigned int )mimeArgs != (unsigned int )((void *)0))) {
          break;
        }
        cli_dbgmsg("mimeArgs = \'%s\'\n", mimeArgs);
        messageAddArguments(m, (char const   *)mimeArgs);
        free((void *)mimeArgs);
      }
    }
  }
  break;
  case 2: 
  messageSetEncoding(m, ptr);
  break;
  case 3: 
  p = cli_strtok(ptr, 0, ";");
  if (p) {
    if ((*p)) {
      messageSetDispositionType(m, (char const   *)p);
      free((void *)p);
      p = cli_strtok(ptr, 1, ";");
      messageAddArgument(m, (char const   *)p);
    }
    free((void *)p);
  }
  }
  if (copy) {
    free((void *)copy);
  }
  return (0);
}
}
static void saveTextPart(message *m , char const   *dir ) 
{ fileblob *fb ;

  {
  messageAddArgument(m, "filename=textportion");
  fb = messageToFileblob(m, dir);
  if ((unsigned int )fb != (unsigned int )((void *)0)) {
    cli_dbgmsg("Saving main message\n");
    fileblobDestroy(fb);
  }
  return;
}
}
static char *rfc822comments(char const   *in , char *out ) 
{ char const   *iptr ;
  char *optr ;
  int backslash ;
  int inquote ;
  int commentlevel ;
  char *tmp___2 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  if ((unsigned int )in == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  }
  tmp___4 = __builtin_constant_p((int )in);
  if (tmp___4) {
    tmp___2 = (char *)__builtin_strchr(in, '(');
  } else {
    tmp___2 = (char *)__builtin_strchr(in, '(');
  }
  if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  }
  if ((unsigned int )out == (unsigned int )((void *)0)) {
    tmp___5 = strlen(in);
    out = (char *)cli_malloc(tmp___5 + 1U);
    if ((unsigned int )out == (unsigned int )((void *)0)) {
      return ((char *)((void *)0));
    }
  }
  inquote = 0;
  commentlevel = inquote;
  backslash = commentlevel;
  optr = out;
  cli_dbgmsg("rfc822comments: contains a comment\n");
  iptr = in;
  while ((*iptr)) {
    if (backslash) {
      if (commentlevel == 0) {
        tmp___6 = optr;
        optr ++;
        (*tmp___6) = (char )(*iptr);
      }
      backslash = 0;
    } else {
      switch ((int )(*iptr)) {
      case 92: 
      backslash = 1;
      break;
      case 34: 
      tmp___7 = optr;
      optr ++;
      (*tmp___7) = (char )'\"';
      inquote = (! inquote != 0) != 0;
      break;
      case 40: ;
      if (inquote) {
        tmp___8 = optr;
        optr ++;
        (*tmp___8) = (char )'(';
      } else {
        commentlevel ++;
      }
      break;
      case 41: ;
      if (inquote) {
        tmp___9 = optr;
        optr ++;
        (*tmp___9) = (char )')';
      } else {
        if (commentlevel > 0) {
          commentlevel --;
        }
      }
      break;
      default: ;
      if (commentlevel == 0) {
        tmp___10 = optr;
        optr ++;
        (*tmp___10) = (char )(*iptr);
      }
      }
    }
    iptr ++;
  }
  if (backslash) {
    tmp___11 = optr;
    optr ++;
    (*tmp___11) = (char )'\\';
  }
  (*optr) = (char )'\000';
  cli_dbgmsg("rfc822comments \'%s\'=>\'%s\'\n", in, out);
  return (out);
}
}
static char *rfc2047(char const   *in ) 
{ char *out ;
  char *pout ;
  size_t len ;
  char *tmp___10 ;
  size_t __len___2 ;
  size_t tmp___16 ;
  char *__retval___2 ;
  char *tmp___17 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  char encoding___0 ;
  char *ptr ;
  char *enctext ;
  message *m ;
  blob *b ;
  char *tmp___23 ;
  char const   *tmp___24 ;
  int __res ;
  int __c ;
  __int32_t const   **tmp___26 ;
  int tmp___27 ;
  __int32_t const   **tmp___28 ;
  size_t __len___6 ;
  size_t tmp___45 ;
  char *__retval___6 ;
  char *tmp___46 ;
  int tmp___48 ;
  unsigned char *tmp___49 ;
  void const   * __restrict  tmp___50 ;

  {
  tmp___20 = strstr(in, "=?");
  if ((unsigned int )tmp___20 == (unsigned int )((void *)0)) {
    goto _L;
  } else {
    tmp___21 = strstr(in, "?=");
    if ((unsigned int )tmp___21 == (unsigned int )((void *)0)) {
      _L: 
      tmp___19 = __builtin_constant_p((int )in);
      if (tmp___19) {
        if ((unsigned int )((void const   *)(in + 1)) - (unsigned int )((void const   *)in) ==
            1U) {
          if ((int const   )(*(in + 0)) == 0) {
            tmp___10 = (char *)calloc(1U, 1U);
          } else {
            tmp___16 = strlen(in);
            __len___2 = tmp___16 + 1U;
            tmp___17 = (char *)malloc(__len___2);
            __retval___2 = tmp___17;
            if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
              __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )in,
                                            __len___2);
            }
            tmp___10 = __retval___2;
          }
        } else {
          tmp___10 = __strdup(in);
        }
      } else {
        tmp___10 = __strdup(in);
      }
      return (tmp___10);
    }
  }
  cli_dbgmsg("rfc2047 \'%s\'\n", in);
  tmp___22 = strlen(in);
  out = (char *)cli_malloc(tmp___22 + 1U);
  if ((unsigned int )out == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  }
  pout = out;
  while ((*in)) {
    while ((*in)) {
      if ((int const   )(*in) == 61) {
        if ((int const   )(*(in + 1)) == 63) {
          in += 2;
          break;
        }
      }
      tmp___23 = pout;
      pout ++;
      tmp___24 = in;
      in ++;
      (*tmp___23) = (char )(*tmp___24);
    }
    while (1) {
      if ((int const   )(*in) != 63) {
        if (! (*in)) {
          break;
        }
      } else {
        break;
      }
      in ++;
    }
    if ((int const   )(*in) == 0) {
      break;
    }
    in ++;
    encoding___0 = (char )(*in);
    if (sizeof(encoding___0) > 1U) {
      tmp___27 = __builtin_constant_p((int )encoding___0);
      if (tmp___27) {
        __c = (int )encoding___0;
        if (__c < -128) {
          __res = __c;
        } else {
          if (__c > 255) {
            __res = __c;
          } else {
            tmp___26 = __ctype_tolower_loc();
            __res = (*((*tmp___26) + __c));
          }
        }
      } else {
        __res = tolower__extinline((int )encoding___0);
      }
    } else {
      tmp___28 = __ctype_tolower_loc();
      __res = (*((*tmp___28) + (int )encoding___0));
    }
    encoding___0 = (char )__res;
    if ((int )encoding___0 != 113) {
      if ((int )encoding___0 != 98) {
        cli_warnmsg("Unsupported RFC2047 encoding type \'%c\' - if you believe this file contains a virus that was missed, report it to bugs@clamav.net\n",
                    encoding___0);
        free((void *)out);
        out = (char *)((void *)0);
        break;
      }
    }
    in ++;
    if ((int const   )(*in) != 63) {
      break;
    }
    in ++;
    if ((int const   )(*in) == 0) {
      break;
    }
    tmp___48 = __builtin_constant_p((int )in);
    if (tmp___48) {
      if ((unsigned int )((void const   *)(in + 1)) - (unsigned int )((void const   *)in) ==
          1U) {
        if ((int const   )(*(in + 0)) == 0) {
          enctext = (char *)calloc(1U, 1U);
        } else {
          tmp___45 = strlen(in);
          __len___6 = tmp___45 + 1U;
          tmp___46 = (char *)malloc(__len___6);
          __retval___6 = tmp___46;
          if ((unsigned int )__retval___6 != (unsigned int )((void *)0)) {
            __retval___6 = (char *)memcpy((void * __restrict  )__retval___6, (void const   * __restrict  )in,
                                          __len___6);
          }
          enctext = __retval___6;
        }
      } else {
        enctext = __strdup(in);
      }
    } else {
      enctext = __strdup(in);
    }
    if ((unsigned int )enctext == (unsigned int )((void *)0)) {
      free((void *)out);
      out = (char *)((void *)0);
      break;
    }
    in = strstr(in, "?=");
    if ((unsigned int )in == (unsigned int )((void *)0)) {
      free((void *)enctext);
      break;
    }
    in += 2;
    ptr = strstr((char const   *)enctext, "?=");
    (*ptr) = (char )'\000';
    m = messageCreate();
    if ((unsigned int )m == (unsigned int )((void *)0)) {
      break;
    }
    messageAddStr(m, (char const   *)enctext);
    free((void *)enctext);
    switch ((int )encoding___0) {
    case 113: 
    messageSetEncoding(m, "quoted-printable");
    break;
    case 98: 
    messageSetEncoding(m, "base64");
    break;
    }
    b = messageToBlob(m);
    len = (size_t )blobGetDataSize((blob const   *)b);
    tmp___49 = blobGetData((blob const   *)b);
    cli_dbgmsg("Decoded as \'%*.*s\'\n", len, len, tmp___49);
    tmp___50 = (void const   * __restrict  )blobGetData((blob const   *)b);
    memcpy((void * __restrict  )pout, tmp___50, len);
    blobDestroy(b);
    messageDestroy(m);
    if ((int )(*(pout + (len - 1U))) == 10) {
      pout += len - 1U;
    } else {
      pout += len;
    }
  }
  if ((unsigned int )out == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  }
  (*pout) = (char )'\000';
  cli_dbgmsg("rfc2047 returns \'%s\'\n", out);
  return (out);
}
}
static int rfc1341(message *m , char const   *dir ) 
{ fileblob *fb ;
  char *arg ;
  char *id ;
  char *number ;
  char *total ;
  char *oldfilename ;
  char const   *tmpdir ;
  char pdir[256] ;
  struct stat statb ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char const   *tmp___9 ;
  int n ;
  int tmp___10 ;
  int t ;
  int tmp___11 ;
  DIR *dd ;
  FILE *fout ;
  char outname[256] ;
  char filename[256] ;
  struct dirent  const  *dent ;
  FILE *fin ;
  char buffer[8192] ;
  int nblanks ;
  int tmp___91 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___127 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___146 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___155 ;
  int tmp___156 ;
  int tmp___157 ;
  int tmp___158 ;
  int tmp___159 ;
  int tmp___160 ;
  size_t tmp___161 ;
  int tmp___162 ;
  int tmp___163 ;
  int tmp___164 ;
  size_t tmp___165 ;
  size_t tmp___166 ;
  int tmp___167 ;
  size_t tmp___168 ;
  size_t tmp___169 ;
  char *tmp___170 ;

  {
  id = messageFindArgument((message const   *)m, "id");
  if ((unsigned int )id == (unsigned int )((void *)0)) {
    return (-1);
  }
  tmpdir = getenv("TMPDIR");
  if ((unsigned int )tmpdir == (unsigned int )((char *)((void *)0))) {
    tmpdir = getenv("TMP");
    if ((unsigned int )tmpdir == (unsigned int )((char *)((void *)0))) {
      tmpdir = getenv("TEMP");
      if ((unsigned int )tmpdir == (unsigned int )((char *)((void *)0))) {
        tmpdir = "/tmp";
      }
    }
  }
  snprintf((char * __restrict  )(pdir), sizeof(pdir) - 1U, (char const   * __restrict  )"%s/clamav-partial",
           tmpdir);
  tmp___1 = mkdir((char const   *)(pdir), 448U);
  if (tmp___1 < 0) {
    tmp___2 = __errno_location();
    if ((*tmp___2) != 17) {
      cli_errmsg("Can\'t create the directory \'%s\'\n", pdir);
      return (-1);
    } else {
      goto _L;
    }
  } else {
    _L: 
    tmp___0 = stat__extinline((char const   *)(pdir), & statb);
    if (tmp___0 < 0) {
      cli_errmsg("Can\'t stat the directory \'%s\'\n", pdir);
      return (-1);
    }
    if (statb.st_mode & 63U) {
      cli_warnmsg("Insecure partial directory %s (mode 0%o)\n", pdir, statb.st_mode &
                                                                      511U);
    }
  }
  number = messageFindArgument((message const   *)m, "number");
  if ((unsigned int )number == (unsigned int )((void *)0)) {
    free((void *)id);
    return (-1);
  }
  oldfilename = messageFindArgument((message const   *)m, "filename");
  if ((unsigned int )oldfilename == (unsigned int )((void *)0)) {
    oldfilename = messageFindArgument((message const   *)m, "name");
  }
  tmp___6 = strlen((char const   *)id);
  tmp___7 = strlen((char const   *)number);
  arg = (char *)cli_malloc((10U + tmp___6) + tmp___7);
  sprintf((char * __restrict  )arg, (char const   * __restrict  )"filename=%s%s",
          id, number);
  messageAddArgument(m, (char const   *)arg);
  free((void *)arg);
  if (oldfilename) {
    cli_warnmsg("Must reset to %s\n", oldfilename);
    free((void *)oldfilename);
  }
  fb = messageToFileblob(m, (char const   *)(pdir));
  if ((unsigned int )fb == (unsigned int )((void *)0)) {
    free((void *)id);
    free((void *)number);
    return (-1);
  }
  fileblobDestroy(fb);
  total = messageFindArgument((message const   *)m, "total");
  if (total) {
    tmp___9 = (char const   *)total;
  } else {
    tmp___9 = "?";
  }
  cli_dbgmsg("rfc1341: %s, %s of %s\n", id, number, tmp___9);
  if (total) {
    tmp___10 = atoi__extinline((char const   *)number);
    n = tmp___10;
    tmp___11 = atoi__extinline((char const   *)total);
    t = tmp___11;
    dd = (DIR *)((void *)0);
    free((void *)total);
    if (n == t) {
      dd = opendir((char const   *)(pdir));
      if ((unsigned int )dd != (unsigned int )((void *)0)) {
        snprintf((char * __restrict  )(outname), sizeof(outname) - 1U, (char const   * __restrict  )"%s/%s",
                 dir, id);
        cli_dbgmsg("outname: %s\n", outname);
        fout = fopen((char const   * __restrict  )(outname), (char const   * __restrict  )"wb");
        if ((unsigned int )fout == (unsigned int )((void *)0)) {
          cli_errmsg("Can\'t open \'%s\' for writing", outname);
          free((void *)id);
          free((void *)number);
          closedir(dd);
          return (-1);
        }
        n = 1;
        while (n <= t) {
          snprintf((char * __restrict  )(filename), sizeof(filename), (char const   * __restrict  )"%s%d",
                   id, n);
          while (1) {
            dent = readdir(dd);
            if (! dent) {
              break;
            }
            if (dent->d_ino == 0UL) {
              continue;
            }
            tmp___162 = (int )strlen((char const   *)(filename));
            tmp___163 = __builtin_constant_p(tmp___162);
            if (tmp___163) {
              tmp___164 = __builtin_constant_p((int )(filename));
              if (tmp___164) {
                tmp___165 = strlen((char const   *)(filename));
                tmp___166 = strlen((char const   *)(filename));
                if (tmp___165 < tmp___166) {
                  goto _L___40;
                } else {
                  goto _L___41;
                }
              } else {
                _L___41: 
                tmp___167 = __builtin_constant_p((int )(dent->d_name));
                if (tmp___167) {
                  tmp___168 = strlen((char const   *)(dent->d_name));
                  tmp___169 = strlen((char const   *)(filename));
                  if (tmp___168 < tmp___169) {
                    _L___40: 
                    tmp___158 = __builtin_constant_p((int )(filename));
                    if (tmp___158) {
                      tmp___159 = __builtin_constant_p((int )(dent->d_name));
                      if (tmp___159) {
                        __s1_len___0 = strlen((char const   *)(filename));
                        __s2_len___0 = strlen((char const   *)(dent->d_name));
                        if (! ((unsigned int )((void const   *)(filename + 1)) - (unsigned int )((void const   *)(filename)) ==
                               1U)) {
                          goto _L___37;
                        } else {
                          if (__s1_len___0 >= 4U) {
                            _L___37: 
                            if (! ((unsigned int )((void const   *)(dent->d_name +
                                                                    1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                                   1U)) {
                              tmp___160 = 1;
                            } else {
                              if (__s2_len___0 >= 4U) {
                                tmp___160 = 1;
                              } else {
                                tmp___160 = 0;
                              }
                            }
                          } else {
                            tmp___160 = 0;
                          }
                        }
                        if (tmp___160) {
                          tmp___127 = __builtin_strcmp(filename, dent->d_name);
                        } else {
                          goto _L___39;
                        }
                      } else {
                        goto _L___39;
                      }
                    } else {
                      _L___39: 
                      tmp___157 = __builtin_constant_p((int )(filename));
                      if (tmp___157) {
                        if ((unsigned int )((void const   *)(filename + 1)) - (unsigned int )((void const   *)(filename)) ==
                            1U) {
                          __s1_len___0 = strlen((char const   *)(filename));
                          if (__s1_len___0 < 4U) {
                            tmp___146 = __builtin_constant_p((int )(dent->d_name));
                            if (tmp___146) {
                              if ((unsigned int )((void const   *)(dent->d_name +
                                                                   1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                                  1U) {
                                tmp___127 = __builtin_strcmp(filename, dent->d_name);
                              } else {
                                goto _L___32;
                              }
                            } else {
                              _L___32: 
                              __s2___14 = (unsigned char const   *)((char const   *)(dent->d_name));
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(filename)) +
                                                                      0)) - (int const   )(*(__s2___14 +
                                                                                             0)));
                              if (__s1_len___0 > 0U) {
                                if (__result___42 == 0) {
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(filename)) +
                                                                          1)) - (int const   )(*(__s2___14 +
                                                                                                 1)));
                                  if (__s1_len___0 > 1U) {
                                    if (__result___42 == 0) {
                                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(filename)) +
                                                                              2)) -
                                                             (int const   )(*(__s2___14 +
                                                                              2)));
                                      if (__s1_len___0 > 2U) {
                                        if (__result___42 == 0) {
                                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(filename)) +
                                                                                  3)) -
                                                                 (int const   )(*(__s2___14 +
                                                                                  3)));
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              tmp___127 = __result___42;
                            }
                          } else {
                            goto _L___36;
                          }
                        } else {
                          goto _L___36;
                        }
                      } else {
                        _L___36: 
                        tmp___156 = __builtin_constant_p((int )(dent->d_name));
                        if (tmp___156) {
                          if ((unsigned int )((void const   *)(dent->d_name + 1)) -
                              (unsigned int )((void const   *)(dent->d_name)) == 1U) {
                            __s2_len___0 = strlen((char const   *)(dent->d_name));
                            if (__s2_len___0 < 4U) {
                              tmp___155 = __builtin_constant_p((int )(filename));
                              if (tmp___155) {
                                if ((unsigned int )((void const   *)(filename + 1)) -
                                    (unsigned int )((void const   *)(filename)) ==
                                    1U) {
                                  tmp___127 = __builtin_strcmp(filename, dent->d_name);
                                } else {
                                  goto _L___34;
                                }
                              } else {
                                _L___34: 
                                __s1___30 = (unsigned char const   *)((char const   *)(filename));
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        0)) - (int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                                               0)));
                                if (__s2_len___0 > 0U) {
                                  if (__result___46 == 0) {
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            1)) -
                                                           (int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                            1)));
                                    if (__s2_len___0 > 1U) {
                                      if (__result___46 == 0) {
                                        __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                2)) -
                                                               (int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                                2)));
                                        if (__s2_len___0 > 2U) {
                                          if (__result___46 == 0) {
                                            __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                    3)) -
                                                                   (int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                                    3)));
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                                tmp___127 = __result___46;
                              }
                            } else {
                              tmp___127 = __builtin_strcmp(filename, dent->d_name);
                            }
                          } else {
                            tmp___127 = __builtin_strcmp(filename, dent->d_name);
                          }
                        } else {
                          tmp___127 = __builtin_strcmp(filename, dent->d_name);
                        }
                      }
                    }
                    tmp___91 = tmp___127;
                  } else {
                    tmp___161 = strlen((char const   *)(filename));
                    tmp___91 = strncmp((char const   *)(filename), (char const   *)(dent->d_name),
                                       tmp___161);
                  }
                } else {
                  tmp___161 = strlen((char const   *)(filename));
                  tmp___91 = strncmp((char const   *)(filename), (char const   *)(dent->d_name),
                                     tmp___161);
                }
              }
            } else {
              tmp___161 = strlen((char const   *)(filename));
              tmp___91 = strncmp((char const   *)(filename), (char const   *)(dent->d_name),
                                 tmp___161);
            }
            if (tmp___91 != 0) {
              continue;
            }
            sprintf((char * __restrict  )(filename), (char const   * __restrict  )"%s/%s",
                    pdir, dent->d_name);
            fin = fopen((char const   * __restrict  )(filename), (char const   * __restrict  )"rb");
            if ((unsigned int )fin == (unsigned int )((void *)0)) {
              cli_errmsg("Can\'t open \'%s\' for reading", filename);
              fclose(fout);
              unlink((char const   *)(outname));
              free((void *)id);
              free((void *)number);
              closedir(dd);
              return (-1);
            }
            nblanks = 0;
            while (1) {
              tmp___170 = fgets((char * __restrict  )(buffer), (int )sizeof(buffer),
                                (FILE * __restrict  )fin);
              if (! ((unsigned int )tmp___170 != (unsigned int )((void *)0))) {
                break;
              }
              if ((int )buffer[0] == 10) {
                nblanks ++;
              } else {
                if (nblanks) {
                  while (1) {
                    _IO_putc('\n', fout);
                    nblanks --;
                    if (! (nblanks > 0)) {
                      break;
                    }
                  }
                }
                fputs((char const   * __restrict  )(buffer), (FILE * __restrict  )fout);
              }
            }
            fclose(fin);
            if (! cli_leavetemps_flag) {
              unlink((char const   *)(filename));
            }
            break;
          }
          rewinddir(dd);
          n ++;
        }
        closedir(dd);
        fclose(fout);
      }
    }
  }
  free((void *)number);
  free((void *)id);
  return (0);
}
}
static void checkURLs(message *m , char const   *dir ) 
{ blob *b ;
  blob *tmp ;
  size_t len ;
  table_t *t ;
  int i ;
  int n ;
  pthread_t tid[5] ;
  struct arg args[5] ;
  tag_arguments_t hrefs ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  char const   *url ;
  char *ptr ;
  char name[256] ;
  int tmp___2 ;
  size_t __len___2 ;
  size_t tmp___19 ;
  char *__retval___2 ;
  char *tmp___20 ;
  int tmp___22 ;
  int tmp___23 ;

  {
  tmp = messageToBlob(m);
  b = tmp;
  if ((unsigned int )b == (unsigned int )((void *)0)) {
    return;
  }
  len = (size_t )blobGetDataSize((blob const   *)b);
  if (len == 0U) {
    blobDestroy(b);
    return;
  }
  if (len > 102400U) {
    cli_warnmsg("Viruses pointed to by URL not scanned in large message\n");
    blobDestroy(b);
    return;
  }
  blobClose(b);
  t = tableCreate();
  if ((unsigned int )t == (unsigned int )((void *)0)) {
    blobDestroy(b);
    return;
  }
  hrefs.count = 0;
  hrefs.value = (unsigned char **)((void *)0);
  hrefs.tag = hrefs.value;
  cli_dbgmsg("checkURLs: calling html_normalise_mem\n");
  tmp___0 = blobGetData((blob const   *)b);
  tmp___1 = html_normalise_mem(tmp___0, (long )len, (char const   *)((void *)0), & hrefs);
  if (! tmp___1) {
    blobDestroy(b);
    tableDestroy(t);
    return;
  }
  cli_dbgmsg("checkURLs: html_normalise_mem returned\n");
  n = 0;
  i = 0;
  while (i < hrefs.count) {
    url = (char const   *)(*(hrefs.value + i));
    tmp___23 = strncasecmp("http://", url, 7U);
    if (tmp___23 == 0) {
      tmp___2 = tableFind((table_t const   *)t, url);
      if (tmp___2 == 1) {
        cli_dbgmsg("URL %s already downloaded\n", url);
        goto __Cont;
      }
      if (n == 5) {
        cli_warnmsg("Not all URLs will be scanned\n");
        break;
      }
      tableInsert(t, url, 1);
      cli_dbgmsg("Downloading URL %s to be scanned\n", url);
      __builtin_strncpy(name, url, sizeof(name) - 1U);
      name[sizeof(name) - 1U] = (char )'\000';
      ptr = name;
      while ((*ptr)) {
        if ((int )(*ptr) == 47) {
          (*ptr) = (char )'_';
        }
        ptr ++;
      }
      args[n].dir = dir;
      args[n].url = url;
      tmp___22 = __builtin_constant_p((int )(name));
      if (tmp___22) {
        if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)(name)) ==
            1U) {
          if ((int const   )(*((char const   *)(name) + 0)) == 0) {
            args[n].filename = (char *)calloc(1U, 1U);
          } else {
            tmp___19 = strlen((char const   *)(name));
            __len___2 = tmp___19 + 1U;
            tmp___20 = (char *)malloc(__len___2);
            __retval___2 = tmp___20;
            if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
              __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )(name),
                                            __len___2);
            }
            args[n].filename = __retval___2;
          }
        } else {
          args[n].filename = __strdup((char const   *)(name));
        }
      } else {
        args[n].filename = __strdup((char const   *)(name));
      }
      pthread_create((pthread_t * __restrict  )(& tid[n]), (pthread_attr_t const   * __restrict  )((void *)0),
                     & getURL, (void * __restrict  )(& args[n]));
      n ++;
    }
    __Cont: 
    i ++;
  }
  blobDestroy(b);
  tableDestroy(t);
  cli_dbgmsg("checkURLs: waiting for %d thread(s) to finish\n", n);
  while (1) {
    n --;
    if (! (n >= 0)) {
      break;
    }
    pthread_join(tid[n], (void **)((void *)0));
    free((void *)args[n].filename);
  }
  html_tag_arg_free(& hrefs);
  return;
}
}
static int initialised  =    0;
static struct __anonstruct_pthread_mutex_t_16 init_mutex  =    {0, 0, (struct _pthread_descr_struct *)0, 0, {0L, 0}};
static void *getURL(void *a ) 
{ CURL *curl ;
  FILE *fp ;
  struct curl_slist *headers ;
  struct arg *arg ;
  char const   *url ;
  char const   *dir ;
  char const   *filename ;
  char fout[256] ;
  CURLcode tmp ;
  CURLcode tmp___0 ;
  CURLcode tmp___1 ;
  CURLcode tmp___2 ;

  {
  arg = (struct arg *)a;
  url = arg->url;
  dir = arg->dir;
  filename = (char const   *)arg->filename;
  pthread_mutex_lock(& init_mutex);
  if (! initialised) {
    tmp = curl_global_init(0L);
    if ((int )tmp != 0) {
      pthread_mutex_unlock(& init_mutex);
      return ((void *)0);
    }
    initialised = 1;
  }
  pthread_mutex_unlock(& init_mutex);
  curl = curl_easy_init();
  if ((unsigned int )curl == (unsigned int )((void *)0)) {
    return ((void *)0);
  }
  curl_easy_setopt(curl, (enum __anonenum_CURLoption_43 )10018, "www.clamav.net");
  tmp___0 = curl_easy_setopt(curl, (enum __anonenum_CURLoption_43 )10002, url);
  if ((int )tmp___0 != 0) {
    return ((void *)0);
  }
  snprintf((char * __restrict  )(fout), 255U, (char const   * __restrict  )"%s/%s",
           dir, filename);
  fp = fopen((char const   * __restrict  )(fout), (char const   * __restrict  )"w");
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
    cli_errmsg("Can\'t open \'%s\' for writing", fout);
    curl_easy_cleanup(curl);
    return ((void *)0);
  }
  tmp___1 = curl_easy_setopt(curl, (enum __anonenum_CURLoption_43 )10001, fp);
  if ((int )tmp___1 != 0) {
    fclose(fp);
    curl_easy_cleanup(curl);
    return ((void *)0);
  }
  headers = curl_slist_append((struct curl_slist *)((void *)0), "Pragma:");
  curl_easy_setopt(curl, (enum __anonenum_CURLoption_43 )10023, headers);
  curl_easy_setopt(curl, (enum __anonenum_CURLoption_43 )13, 30);
  curl_easy_setopt(curl, (enum __anonenum_CURLoption_43 )78, 10);
  curl_easy_setopt(curl, (enum __anonenum_CURLoption_43 )10005, "username:password");
  tmp___2 = curl_easy_perform(curl);
  if ((int )tmp___2 != 0) {
    cli_warnmsg("URL %s failed to download\n", url);
  }
  fclose(fp);
  curl_slist_free_all(headers);
  curl_easy_cleanup(curl);
  return ((void *)0);
}
}
static bool usefulHeader(int commandNumber , char const   *cmd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  switch (commandNumber) {
  case 2: ;
  case 3: ;
  case 1: ;
  return ((enum __anonenum_bool_35 )1);
  default: 
  tmp___1 = strcasecmp(cmd, "From");
  if (tmp___1 == 0) {
    return ((enum __anonenum_bool_35 )1);
  } else {
    tmp___0 = strcasecmp(cmd, "Received");
    if (tmp___0 == 0) {
      return ((enum __anonenum_bool_35 )1);
    } else {
      tmp = strcasecmp(cmd, "De");
      if (tmp == 0) {
        return ((enum __anonenum_bool_35 )1);
      }
    }
  }
  }
  return ((enum __anonenum_bool_35 )0);
}
}
static void uufasttrack(message *m , char const   *firstline , char const   *dir ,
                        FILE *fin ) 
{ fileblob *fb ;
  fileblob *tmp ;
  char buffer[1001] ;
  char *filename ;
  char *tmp___0 ;
  unsigned char data[1024] ;
  unsigned char const   *uptr ;
  size_t len ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  tmp = fileblobCreate();
  fb = tmp;
  tmp___0 = cli_strtok(firstline, 2, " ");
  filename = tmp___0;
  fileblobSetFilename(fb, dir, (char const   *)filename);
  cli_dbgmsg("Fast track uudecode %s\n", filename);
  free((void *)filename);
  while (1) {
    tmp___3 = fgets((char * __restrict  )(buffer), (int )(sizeof(buffer) - 1U), (FILE * __restrict  )fin);
    if (! ((unsigned int )tmp___3 != (unsigned int )((void *)0))) {
      break;
    }
    cli_chomp(buffer);
    tmp___1 = strcasecmp((char const   *)(buffer), "end");
    if (tmp___1 == 0) {
      break;
    }
    if ((int )buffer[0] == 0) {
      break;
    }
    uptr = decodeLine(m, (enum __anonenum_encoding_type_32 )5, (char const   *)(buffer),
                      data, sizeof(data));
    if ((unsigned int )uptr == (unsigned int )((void *)0)) {
      break;
    }
    len = (unsigned int )(uptr - (unsigned char const   *)(data));
    if (len > 62U) {
      break;
    } else {
      if (len == 0U) {
        break;
      }
    }
    tmp___2 = fileblobAddData(fb, (unsigned char const   *)(data), len);
    if (tmp___2 < 0) {
      break;
    }
  }
  fileblobDestroy(fb);
  return;
}
}
static char *getline(char *buffer , size_t len , FILE *fin ) 
{ char *ret ;
  int tmp ;
  int c ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  tmp = feof(fin);
  if (tmp) {
    return ((char *)((void *)0));
  }
  if (len == 0U) {
    cli_errmsg("Invalid call to getline(). Report to bugs@clamav.net\n");
    return ((char *)((void *)0));
  } else {
    if ((unsigned int )buffer == (unsigned int )((void *)0)) {
      cli_errmsg("Invalid call to getline(). Report to bugs@clamav.net\n");
      return ((char *)((void *)0));
    }
  }
  ret = buffer;
  while (1) {
    tmp___0 = _IO_getc(fin);
    c = tmp___0;
    tmp___1 = ferror(fin);
    if (tmp___1) {
      return ((char *)((void *)0));
    }
    switch (c) {
    case 10: 
    tmp___2 = buffer;
    buffer ++;
    (*tmp___2) = (char )'\n';
    c = _IO_getc(fin);
    if (c != 13) {
      tmp___3 = feof(fin);
      if (! tmp___3) {
        ungetc(c, fin);
      }
    }
    break;
    default: 
    tmp___4 = buffer;
    buffer ++;
    (*tmp___4) = (char )c;
    goto __Cont;
    case -1: ;
    break;
    case 13: 
    tmp___5 = buffer;
    buffer ++;
    (*tmp___5) = (char )'\n';
    c = _IO_getc(fin);
    if (c != 10) {
      tmp___6 = feof(fin);
      if (! tmp___6) {
        ungetc(c, fin);
      }
    }
    break;
    }
    break;
    __Cont: 
    len --;
    if (! (len > 0U)) {
      break;
    }
  }
  if (len == 0U) {
    cli_dbgmsg("getline: buffer overflow stopped\n");
    return ((char *)((void *)0));
  }
  (*buffer) = (char )'\000';
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-0fW8qcUt.i","-g -O2 -fPIC")
line_t *lineCreate(char const   *data ) ;
line_t *lineLink(line_t *line ) ;
line_t *lineUnlink(line_t *line ) ;
unsigned char lineGetRefCount(line_t const   *line ) ;
int messageAddStrAtTop(message *m , char const   *data ) ;
text *messageToText(message *m ) ;
text const   *yEncBegin(message const   *m ) ;
void messageClearMarkers(message *m ) ;
text *textClean(text *t_head ) ;
blob *textToBlob(text const   *t , blob *b ) ;
char *strrcpy(char *dest , char const   *source ) ;
static void messageIsEncoding(message *m ) ;
static unsigned char *decode(message *m , char const   *in , unsigned char *out ,
                             unsigned char (*decoder)(char  ) , bool isFast ) ;
static void sanitiseBase64(char *s ) ;
static unsigned char hex(char c ) ;
static unsigned char base64___0(char c ) ;
static unsigned char uudecode(char c ) ;
static char const   *messageGetArgument(message const   *m , int arg ) ;
static void *messageExport(message *m , char const   *dir , void *(*create)(void) ,
                           void (*destroy)(void * ) , void (*setFilename)(void * ,
                                                                          char const   * ,
                                                                          char const   * ) ,
                           void (*addData)(void * , unsigned char const   * , size_t  ) ,
                           void *(*exportText)(text const   * , void * ) ) ;
static int usefulArg(char const   *arg ) ;
static void messageDedup(message *m ) ;
static char *rfc2231(char const   *in ) ;
static int simil(char const   *str1 , char const   *str2 ) ;
static struct encoding_map  const  encoding_map[13]  = 
  {      {"7bit", (encoding_type )0}, 
        {"text/plain", (encoding_type )0}, 
        {"quoted-printable", (encoding_type )1}, 
        {"base64", (encoding_type )2}, 
        {"8bit", (encoding_type )3}, 
        {"binary", (encoding_type )4}, 
        {"x-uuencode", (encoding_type )5}, 
        {"x-yencode", (encoding_type )6}, 
        {"x-binhex", (encoding_type )8}, 
        {"us-ascii", (encoding_type )0}, 
        {"x-uue", (encoding_type )5}, 
        {"uuencode", (encoding_type )5}, 
        {(char const   *)((void *)0), (encoding_type )0}};
static struct mime_map mime_map[8]  = 
  {      {"text", (mime_type )6}, 
        {"multipart", (mime_type )5}, 
        {"application", (mime_type )1}, 
        {"audio", (mime_type )2}, 
        {"image", (mime_type )3}, 
        {"message", (mime_type )4}, 
        {"video", (mime_type )7}, 
        {(char const   *)((void *)0), (mime_type )6}};
static unsigned char const   base64Table[256]  = 
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )62, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )63, 
        (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )55, 
        (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6, 
        (unsigned char const   )7,      (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10, 
        (unsigned char const   )11,      (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14, 
        (unsigned char const   )15,      (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18, 
        (unsigned char const   )19,      (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22, 
        (unsigned char const   )23,      (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )26,      (unsigned char const   )27,      (unsigned char const   )28, 
        (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31,      (unsigned char const   )32, 
        (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35,      (unsigned char const   )36, 
        (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39,      (unsigned char const   )40, 
        (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43,      (unsigned char const   )44, 
        (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47,      (unsigned char const   )48, 
        (unsigned char const   )49,      (unsigned char const   )50,      (unsigned char const   )51,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255};
message *messageCreate(void) 
{ message *m ;
  message *tmp ;

  {
  tmp = (message *)cli_calloc(1U, sizeof(message ));
  m = tmp;
  if (m) {
    m->mimeType = (enum __anonenum_mime_type_31 )0;
  }
  return (m);
}
}
void messageDestroy(message *m ) 
{ 

  {
  messageReset(m);
  free((void *)m);
  return;
}
}
void messageReset(message *m ) 
{ int i ;

  {
  if (m->mimeSubtype) {
    free((void *)m->mimeSubtype);
  }
  if (m->mimeDispositionType) {
    free((void *)m->mimeDispositionType);
  }
  if (m->mimeArguments) {
    i = 0;
    while (i < m->numberOfArguments) {
      free((void *)(*(m->mimeArguments + i)));
      i ++;
    }
    free((void *)m->mimeArguments);
  }
  if (m->body_first) {
    textDestroy(m->body_first);
  }
  if (m->encodingTypes) {
    free((void *)m->encodingTypes);
  }
  memset((void *)m, '\000', sizeof(message ));
  m->mimeType = (enum __anonenum_mime_type_31 )0;
  return;
}
}
static struct __anonstruct_pthread_mutex_t_16 mime_mutex  =    {0, 0, (struct _pthread_descr_struct *)0, 0, {0L, 0}};
static table_t *mime_table  ;
int messageSetMimeType(message *mess , char const   *type ) 
{ struct mime_map  const  *m ;
  int typeval ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int highestSimil ;
  int t ;
  char const   *closest ;
  int s ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if ((unsigned int )type == (unsigned int )((void *)0)) {
    cli_warnmsg("Empty content-type field\n");
    return (0);
  }
  cli_dbgmsg("messageSetMimeType: \'%s\'\n", type);
  while (1) {
    tmp___0 = __ctype_b_loc();
    if ((int const   )(*((*tmp___0) + (int )(*type))) & 1024) {
      break;
    }
    tmp = type;
    type ++;
    if ((int const   )(*tmp) == 0) {
      return (0);
    }
  }
  pthread_mutex_lock(& mime_mutex);
  if ((unsigned int )mime_table == (unsigned int )((void *)0)) {
    mime_table = tableCreate();
    if ((unsigned int )mime_table == (unsigned int )((void *)0)) {
      pthread_mutex_unlock(& mime_mutex);
      return (0);
    }
    m = (struct mime_map  const  *)(mime_map);
    while (m->string) {
      tmp___1 = tableInsert(mime_table, m->string, (int )m->type);
      if (! tmp___1) {
        tableDestroy(mime_table);
        mime_table = (table_t *)((void *)0);
        pthread_mutex_unlock(& mime_mutex);
        return (0);
      }
      m ++;
    }
  }
  pthread_mutex_unlock(& mime_mutex);
  typeval = tableFind((table_t const   *)mime_table, type);
  if (typeval != -1) {
    mess->mimeType = (enum __anonenum_mime_type_31 )typeval;
    return (1);
  }
  if ((int )mess->mimeType == 0) {
    tmp___4 = strncasecmp(type, "x-", 2U);
    if (tmp___4 == 0) {
      mess->mimeType = (enum __anonenum_mime_type_31 )8;
    } else {
      tmp___3 = strcasecmp(type, "plain");
      if (tmp___3 == 0) {
        cli_dbgmsg("Incorrect MIME type: `plain\', set to Text\n", type);
        mess->mimeType = (enum __anonenum_mime_type_31 )6;
      } else {
        highestSimil = 0;
        t = -1;
        closest = (char const   *)((void *)0);
        m = (struct mime_map  const  *)(mime_map);
        while (m->string) {
          tmp___2 = simil(m->string, type);
          s = tmp___2;
          if (s > highestSimil) {
            highestSimil = s;
            closest = m->string;
            t = (int )m->type;
          }
          m ++;
        }
        if (highestSimil >= 50) {
          cli_dbgmsg("Unknown MIME type \"%s\" - guessing as %s (%u%% certainty)\n",
                     type, closest, highestSimil);
          mess->mimeType = (enum __anonenum_mime_type_31 )t;
        } else {
          cli_dbgmsg("Unknown MIME type: `%s\', set to Application - if you believe this file contains a missed virus, report it to bugs@clamav.net\n",
                     type);
          mess->mimeType = (enum __anonenum_mime_type_31 )1;
        }
      }
    }
    return (1);
  }
  return (0);
}
}
mime_type messageGetMimeType(message const   *m ) 
{ 

  {
  return (m->mimeType);
}
}
void messageSetMimeSubtype(message *m , char const   *subtype___0 ) 
{ size_t __len___2 ;
  size_t tmp___15 ;
  char *__retval___2 ;
  char *tmp___16 ;
  int tmp___18 ;

  {
  if ((unsigned int )subtype___0 == (unsigned int )((void *)0)) {
    cli_dbgmsg("Empty content subtype\n");
    subtype___0 = "";
  }
  if (m->mimeSubtype) {
    free((void *)m->mimeSubtype);
  }
  tmp___18 = __builtin_constant_p((int )subtype___0);
  if (tmp___18) {
    if ((unsigned int )((void const   *)(subtype___0 + 1)) - (unsigned int )((void const   *)subtype___0) ==
        1U) {
      if ((int const   )(*(subtype___0 + 0)) == 0) {
        m->mimeSubtype = (char *)calloc(1U, 1U);
      } else {
        tmp___15 = strlen(subtype___0);
        __len___2 = tmp___15 + 1U;
        tmp___16 = (char *)malloc(__len___2);
        __retval___2 = tmp___16;
        if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
          __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )subtype___0,
                                        __len___2);
        }
        m->mimeSubtype = __retval___2;
      }
    } else {
      m->mimeSubtype = __strdup(subtype___0);
    }
  } else {
    m->mimeSubtype = __strdup(subtype___0);
  }
  return;
}
}
char const   *messageGetMimeSubtype(message const   *m ) 
{ char const   *tmp ;

  {
  if (m->mimeSubtype) {
    tmp = (char const   *)m->mimeSubtype;
  } else {
    tmp = "";
  }
  return (tmp);
}
}
void messageSetDispositionType(message *m , char const   *disptype ) 
{ unsigned short const   **tmp ;
  size_t __len___2 ;
  size_t tmp___16 ;
  char *__retval___2 ;
  char *tmp___17 ;
  int tmp___19 ;

  {
  if (m->mimeDispositionType) {
    free((void *)m->mimeDispositionType);
  }
  if ((unsigned int )disptype == (unsigned int )((void *)0)) {
    m->mimeDispositionType = (char *)((void *)0);
    return;
  }
  while (1) {
    if ((*disptype)) {
      tmp = __ctype_b_loc();
      if (! ((int const   )(*((*tmp) + (int )(*disptype))) & 8192)) {
        break;
      }
    } else {
      break;
    }
    disptype ++;
  }
  if ((*disptype)) {
    tmp___19 = __builtin_constant_p((int )disptype);
    if (tmp___19) {
      if ((unsigned int )((void const   *)(disptype + 1)) - (unsigned int )((void const   *)disptype) ==
          1U) {
        if ((int const   )(*(disptype + 0)) == 0) {
          m->mimeDispositionType = (char *)calloc(1U, 1U);
        } else {
          tmp___16 = strlen(disptype);
          __len___2 = tmp___16 + 1U;
          tmp___17 = (char *)malloc(__len___2);
          __retval___2 = tmp___17;
          if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
            __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )disptype,
                                          __len___2);
          }
          m->mimeDispositionType = __retval___2;
        }
      } else {
        m->mimeDispositionType = __strdup(disptype);
      }
    } else {
      m->mimeDispositionType = __strdup(disptype);
    }
    if (m->mimeDispositionType) {
      strstrip(m->mimeDispositionType);
    }
  } else {
    m->mimeDispositionType = (char *)((void *)0);
  }
  return;
}
}
char const   *messageGetDispositionType(message const   *m ) 
{ char const   *tmp ;

  {
  if (m->mimeDispositionType) {
    tmp = (char const   *)m->mimeDispositionType;
  } else {
    tmp = "";
  }
  return (tmp);
}
}
void messageAddArgument(message *m , char const   *arg ) 
{ int offset ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char **ptr ;
  mime_type tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  if ((unsigned int )arg == (unsigned int )((void *)0)) {
    return;
  }
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )(*((*tmp) + (int )(*arg))) & 8192)) {
      break;
    }
    arg ++;
  }
  if ((int const   )(*arg) == 0) {
    return;
  }
  tmp___0 = usefulArg(arg);
  if (! tmp___0) {
    return;
  }
  offset = 0;
  while (offset < m->numberOfArguments) {
    if ((unsigned int )(*(m->mimeArguments + offset)) == (unsigned int )((void *)0)) {
      break;
    } else {
      tmp___1 = strcasecmp(arg, (char const   *)(*(m->mimeArguments + offset)));
      if (tmp___1 == 0) {
        return;
      }
    }
    offset ++;
  }
  if (offset == m->numberOfArguments) {
    m->numberOfArguments = m->numberOfArguments + 1;
    ptr = (char **)cli_realloc((void *)m->mimeArguments, (unsigned int )m->numberOfArguments *
                                                         sizeof(char *));
    if ((unsigned int )ptr == (unsigned int )((void *)0)) {
      m->numberOfArguments = m->numberOfArguments - 1;
      return;
    }
    m->mimeArguments = ptr;
  }
  (*(m->mimeArguments + offset)) = rfc2231(arg);
  arg = (char const   *)(*(m->mimeArguments + offset));
  tmp___4 = strncasecmp(arg, "filename=", 9U);
  if (tmp___4 == 0) {
    goto _L;
  } else {
    tmp___5 = strncasecmp(arg, "name=", 5U);
    if (tmp___5 == 0) {
      _L: 
      tmp___3 = messageGetMimeType((message const   *)m);
      if ((int )tmp___3 == 0) {
        cli_dbgmsg("Force mime encoding to application\n");
        messageSetMimeType(m, "application");
      }
    }
  }
  return;
}
}
void messageAddArguments(message *m , char const   *s ) 
{ char const   *string ;
  char const   *key ;
  char const   *cptr ;
  char *data ;
  char *field ;
  unsigned short const   **tmp ;
  int tmp___4 ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;
  char const   *tmp___11 ;
  size_t tmp___12 ;
  char *ptr ;
  void *tmp___28 ;
  size_t __len___2 ;
  size_t tmp___29 ;
  char *__retval___2 ;
  char *tmp___30 ;
  int tmp___32 ;
  int tmp___37 ;
  int tmp___42 ;
  int tmp___47 ;
  int tmp___48 ;
  size_t __len___6 ;
  size_t tmp___65 ;
  char *__retval___6 ;
  char *tmp___66 ;
  int tmp___68 ;
  int tmp___79 ;
  size_t tmp___80 ;
  size_t tmp___81 ;
  size_t len ;
  unsigned short const   **tmp___82 ;

  {
  string = s;
  cli_dbgmsg("Add arguments \'%s\'\n", string);
  while ((*string)) {
    tmp = __ctype_b_loc();
    if ((int const   )(*((*tmp) + (int )(*string))) & 8192) {
      string ++;
      continue;
    } else {
      if ((int const   )(*string) == 59) {
        string ++;
        continue;
      }
    }
    key = string;
    tmp___4 = __builtin_constant_p((int )string);
    if (tmp___4) {
      data = (char *)__builtin_strchr(string, '=');
    } else {
      data = (char *)__builtin_strchr(string, '=');
    }
    if ((unsigned int )data == (unsigned int )((void *)0)) {
      tmp___9 = __builtin_constant_p((int )string);
      if (tmp___9) {
        data = (char *)__builtin_strchr(string, ':');
      } else {
        data = (char *)__builtin_strchr(string, ':');
      }
    }
    if ((unsigned int )data == (unsigned int )((void *)0)) {
      cli_dbgmsg("Can\'t parse header \"%s\"\n", s);
      return;
    }
    string = (char const   *)(data + 1);
    while (1) {
      tmp___10 = __ctype_b_loc();
      if ((int const   )(*((*tmp___10) + (int )(*string))) & 8192) {
        if (! ((int const   )(*string) != 0)) {
          break;
        }
      } else {
        break;
      }
      string ++;
    }
    tmp___11 = string;
    string ++;
    cptr = tmp___11;
    tmp___12 = strlen(key);
    if (tmp___12 == 0U) {
      continue;
    }
    if ((int const   )(*cptr) == 34) {
      tmp___32 = __builtin_constant_p((int )key);
      if (tmp___32) {
        if ((unsigned int )((void const   *)(key + 1)) - (unsigned int )((void const   *)key) ==
            1U) {
          if ((int const   )(*(key + 0)) == 0) {
            tmp___28 = calloc(1U, 1U);
            key = (char const   *)((char *)tmp___28);
          } else {
            tmp___29 = strlen(key);
            __len___2 = tmp___29 + 1U;
            tmp___30 = (char *)malloc(__len___2);
            __retval___2 = tmp___30;
            if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
              __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )key,
                                            __len___2);
            }
            key = (char const   *)__retval___2;
          }
        } else {
          key = __strdup(key);
        }
      } else {
        key = __strdup(key);
      }
      if ((unsigned int )key == (unsigned int )((void *)0)) {
        return;
      }
      tmp___37 = __builtin_constant_p((int )key);
      if (tmp___37) {
        ptr = (char *)__builtin_strchr(key, '=');
      } else {
        ptr = (char *)__builtin_strchr(key, '=');
      }
      if ((unsigned int )ptr == (unsigned int )((void *)0)) {
        tmp___42 = __builtin_constant_p((int )key);
        if (tmp___42) {
          ptr = (char *)__builtin_strchr(key, ':');
        } else {
          ptr = (char *)__builtin_strchr(key, ':');
        }
      }
      (*ptr) = (char )'\000';
      cptr ++;
      tmp___47 = __builtin_constant_p((int )cptr);
      if (tmp___47) {
        cptr ++;
        string = (char const   *)__builtin_strchr(cptr, '\"');
      } else {
        cptr ++;
        string = (char const   *)__builtin_strchr(cptr, '\"');
      }
      if ((unsigned int )string == (unsigned int )((void *)0)) {
        cli_dbgmsg("Unbalanced quote character in \"%s\"\n", s);
        string = "";
      } else {
        string ++;
      }
      tmp___48 = usefulArg(key);
      if (! tmp___48) {
        free((void *)((char *)key));
        continue;
      }
      tmp___68 = __builtin_constant_p((int )cptr);
      if (tmp___68) {
        if ((unsigned int )((void const   *)(cptr + 1)) - (unsigned int )((void const   *)cptr) ==
            1U) {
          if ((int const   )(*(cptr + 0)) == 0) {
            data = (char *)calloc(1U, 1U);
          } else {
            tmp___65 = strlen(cptr);
            __len___6 = tmp___65 + 1U;
            tmp___66 = (char *)malloc(__len___6);
            __retval___6 = tmp___66;
            if ((unsigned int )__retval___6 != (unsigned int )((void *)0)) {
              __retval___6 = (char *)memcpy((void * __restrict  )__retval___6, (void const   * __restrict  )cptr,
                                            __len___6);
            }
            data = __retval___6;
          }
        } else {
          data = __strdup(cptr);
        }
      } else {
        data = __strdup(cptr);
      }
      if (data) {
        tmp___79 = __builtin_constant_p((int )data);
        if (tmp___79) {
          ptr = (char *)__builtin_strchr(data, '\"');
        } else {
          ptr = (char *)__builtin_strchr(data, '\"');
        }
      } else {
        ptr = (char *)((void *)0);
      }
      if ((unsigned int )ptr == (unsigned int )((void *)0)) {
        cli_dbgmsg("Can\'t parse header \"%s\" - if you believe this file contains a missed virus, report it to bugs@clamav.net\n",
                   s);
        if (data) {
          free((void *)data);
        }
        free((void *)((char *)key));
        return;
      }
      (*ptr) = (char )'\000';
      tmp___80 = strlen(key);
      tmp___81 = strlen((char const   *)data);
      field = (char *)cli_realloc((void *)((char *)key), (tmp___80 + tmp___81) + 2U);
      if (field) {
        strcat((char * __restrict  )field, (char const   * __restrict  )"=");
        strcat((char * __restrict  )field, (char const   * __restrict  )data);
      } else {
        free((void *)((char *)key));
      }
      free((void *)data);
    } else {
      if ((int const   )(*cptr) == 0) {
        cli_warnmsg("Ignoring empty field in \"%s\"\n", s);
        return;
      }
      while (1) {
        if ((int const   )(*string) != 0) {
          tmp___82 = __ctype_b_loc();
          if ((int const   )(*((*tmp___82) + (int )(*string))) & 8192) {
            break;
          }
        } else {
          break;
        }
        string ++;
      }
      len = ((unsigned int )string - (unsigned int )key) + 1U;
      field = (char *)cli_malloc(len);
      if (field) {
        memcpy((void * __restrict  )field, (void const   * __restrict  )key, len -
                                                                             1U);
        (*(field + (len - 1U))) = (char )'\000';
      }
    }
    if (field) {
      messageAddArgument(m, (char const   *)field);
      free((void *)field);
    }
  }
  return;
}
}
static char const   *messageGetArgument(message const   *m , int arg ) 
{ char const   *tmp ;

  {
  if ((*(m->mimeArguments + arg))) {
    tmp = (char const   *)(*(m->mimeArguments + arg));
  } else {
    tmp = "";
  }
  return (tmp);
}
}
char const   *messageFindArgument(message const   *m , char const   *variable ) 
{ int i ;
  size_t len ;
  char const   *ptr ;
  unsigned short const   **tmp ;
  char *ret ;
  char *tmp___11 ;
  size_t __len___2 ;
  size_t tmp___17 ;
  char *__retval___2 ;
  char *tmp___18 ;
  int tmp___20 ;
  char *p ;
  size_t tmp___21 ;
  int tmp___26 ;
  char *tmp___30 ;
  int tmp___32 ;
  char *tmp___44 ;
  size_t __len___6 ;
  size_t tmp___50 ;
  char *__retval___6 ;
  char *tmp___51 ;
  int tmp___53 ;
  int tmp___54 ;

  {
  len = strlen(variable);
  i = 0;
  while (i < m->numberOfArguments) {
    ptr = messageGetArgument(m, i);
    if ((unsigned int )ptr == (unsigned int )((void *)0)) {
      goto __Cont;
    } else {
      if ((int const   )(*ptr) == 0) {
        goto __Cont;
      }
    }
    tmp___54 = strncasecmp(ptr, variable, len);
    if (tmp___54 == 0) {
      ptr = ptr + len;
      while (1) {
        tmp = __ctype_b_loc();
        if (! ((int const   )(*((*tmp) + (int )(*ptr))) & 8192)) {
          break;
        }
        ptr ++;
      }
      if ((int const   )(*ptr) != 61) {
        cli_warnmsg("messageFindArgument: no \'=\' sign found in MIME header\n");
        return ((char const   *)((void *)0));
      }
      ptr ++;
      if ((int const   )(*ptr) == 34) {
        tmp___32 = __builtin_constant_p((int )(ptr + 1));
        if (tmp___32) {
          tmp___30 = (char *)__builtin_strchr(ptr + 1, '\"');
        } else {
          tmp___30 = (char *)__builtin_strchr(ptr + 1, '\"');
        }
        if ((unsigned int )tmp___30 != (unsigned int )((void *)0)) {
          ptr ++;
          tmp___20 = __builtin_constant_p((int )ptr);
          if (tmp___20) {
            ptr ++;
            ptr ++;
            if ((unsigned int )((void const   *)(ptr + 1)) - (unsigned int )((void const   *)ptr) ==
                1U) {
              ptr ++;
              if ((int const   )(*(ptr + 0)) == 0) {
                tmp___11 = (char *)calloc(1U, 1U);
              } else {
                ptr ++;
                tmp___17 = strlen(ptr);
                __len___2 = tmp___17 + 1U;
                tmp___18 = (char *)malloc(__len___2);
                __retval___2 = tmp___18;
                if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
                  ptr ++;
                  __retval___2 = (char *)memcpy((void * __restrict  )__retval___2,
                                                (void const   * __restrict  )ptr,
                                                __len___2);
                }
                tmp___11 = __retval___2;
              }
            } else {
              ptr ++;
              tmp___11 = __strdup(ptr);
            }
          } else {
            ptr ++;
            tmp___11 = __strdup(ptr);
          }
          ret = tmp___11;
          if ((unsigned int )ret == (unsigned int )((void *)0)) {
            return ((char const   *)((void *)0));
          }
          tmp___26 = __builtin_constant_p((int )ret);
          if (tmp___26) {
            p = (char *)__builtin_strchr(ret, '\"');
          } else {
            p = (char *)__builtin_strchr(ret, '\"');
          }
          if ((unsigned int )p != (unsigned int )((void *)0)) {
            tmp___21 = strlen((char const   *)ret);
            (*(ret + (tmp___21 - 1U))) = (char )'\000';
            (*p) = (char )'\000';
          }
          return ((char const   *)ret);
        }
      }
      tmp___53 = __builtin_constant_p((int )ptr);
      if (tmp___53) {
        if ((unsigned int )((void const   *)(ptr + 1)) - (unsigned int )((void const   *)ptr) ==
            1U) {
          if ((int const   )(*(ptr + 0)) == 0) {
            tmp___44 = (char *)calloc(1U, 1U);
          } else {
            tmp___50 = strlen(ptr);
            __len___6 = tmp___50 + 1U;
            tmp___51 = (char *)malloc(__len___6);
            __retval___6 = tmp___51;
            if ((unsigned int )__retval___6 != (unsigned int )((void *)0)) {
              __retval___6 = (char *)memcpy((void * __restrict  )__retval___6, (void const   * __restrict  )ptr,
                                            __len___6);
            }
            tmp___44 = __retval___6;
          }
        } else {
          tmp___44 = __strdup(ptr);
        }
      } else {
        tmp___44 = __strdup(ptr);
      }
      return ((char const   *)tmp___44);
    }
    __Cont: 
    i ++;
  }
  return ((char const   *)((void *)0));
}
}
void messageSetEncoding(message *m , char const   *enctype ) 
{ struct encoding_map  const  *e ;
  int i ;
  char *type ;
  int tmp ;
  int highestSimil ;
  char const   *closest ;
  int sim ;
  char lowertype ;
  int __res ;
  int __c ;
  __int32_t const   **tmp___1 ;
  int tmp___2 ;
  __int32_t const   **tmp___3 ;
  int __res___0 ;
  int __c___0 ;
  __int32_t const   **tmp___5 ;
  int tmp___6 ;
  __int32_t const   **tmp___7 ;
  int j ;
  encoding_type *et ;
  int tmp___9 ;
  int tmp___10 ;

  {
  i = 0;
  while (1) {
    if (! ((int const   )(*enctype) == 9)) {
      if (! ((int const   )(*enctype) == 32)) {
        break;
      }
    }
    enctype ++;
  }
  cli_dbgmsg("messageSetEncoding: \'%s\'\n", enctype);
  tmp = strcasecmp(enctype, "8 bit");
  if (tmp == 0) {
    cli_dbgmsg("Broken content-transfer-encoding: \'8 bit\' changed to \'8bit\'\n");
    enctype = "8bit";
  }
  i = 0;
  while (1) {
    tmp___10 = i;
    i ++;
    type = cli_strtok(enctype, tmp___10, " \t");
    if (! ((unsigned int )type != (unsigned int )((void *)0))) {
      break;
    }
    highestSimil = 0;
    closest = (char const   *)((void *)0);
    e = encoding_map;
    while (e->string) {
      if (sizeof((*(type + 0))) > 1U) {
        tmp___2 = __builtin_constant_p((int )(*(type + 0)));
        if (tmp___2) {
          __c = (int )(*(type + 0));
          if (__c < -128) {
            __res = __c;
          } else {
            if (__c > 255) {
              __res = __c;
            } else {
              tmp___1 = __ctype_tolower_loc();
              __res = (*((*tmp___1) + __c));
            }
          }
        } else {
          __res = tolower__extinline((int )(*(type + 0)));
        }
      } else {
        tmp___3 = __ctype_tolower_loc();
        __res = (*((*tmp___3) + (int )(*(type + 0))));
      }
      lowertype = (char )__res;
      if (sizeof((*(e->string + 0))) > 1U) {
        tmp___6 = __builtin_constant_p((int )(*(e->string + 0)));
        if (tmp___6) {
          __c___0 = (int )(*(e->string + 0));
          if (__c___0 < -128) {
            __res___0 = __c___0;
          } else {
            if (__c___0 > 255) {
              __res___0 = __c___0;
            } else {
              tmp___5 = __ctype_tolower_loc();
              __res___0 = (*((*tmp___5) + __c___0));
            }
          }
        } else {
          __res___0 = tolower__extinline((int )(*(e->string + 0)));
        }
      } else {
        tmp___7 = __ctype_tolower_loc();
        __res___0 = (*((*tmp___7) + (int )(*(e->string + 0))));
      }
      if ((int )lowertype != __res___0) {
        if ((int )lowertype != 120) {
          goto __Cont;
        }
      }
      sim = simil((char const   *)type, e->string);
      if (sim == 100) {
        j = 0;
        while (j < m->numberOfEncTypes) {
          if ((int )(*(m->encodingTypes + j)) == (int )e->type) {
            break;
          }
          j ++;
        }
        if (j < m->numberOfEncTypes) {
          cli_dbgmsg("Ignoring duplicate encoding mechanism \'%s\'\n", type);
          break;
        }
        et = (encoding_type *)cli_realloc((void *)m->encodingTypes, (unsigned int )(m->numberOfEncTypes +
                                                                                    1) *
                                                                    sizeof(encoding_type ));
        if ((unsigned int )et == (unsigned int )((void *)0)) {
          break;
        }
        m->encodingTypes = et;
        tmp___9 = m->numberOfEncTypes;
        m->numberOfEncTypes = m->numberOfEncTypes + 1;
        (*(m->encodingTypes + tmp___9)) = e->type;
        cli_dbgmsg("Encoding type %d is \"%s\"\n", m->numberOfEncTypes, type);
        break;
      } else {
        if (sim > highestSimil) {
          closest = e->string;
          highestSimil = sim;
        }
      }
      __Cont: 
      e ++;
    }
    if ((unsigned int )e->string == (unsigned int )((void *)0)) {
      if (highestSimil >= 50) {
        cli_dbgmsg("Unknown encoding type \"%s\" - guessing as %s (%u%% certainty)\n",
                   type, closest, highestSimil);
        messageSetEncoding(m, closest);
      } else {
        cli_dbgmsg("Unknown encoding type \"%s\" - if you believe this file contains a virus, report it to bugs@clamav.net\n",
                   type);
        messageSetEncoding(m, "base64");
        messageSetEncoding(m, "quoted-printable");
      }
    }
    free((void *)type);
  }
  return;
}
}
encoding_type messageGetEncoding(message const   *m ) 
{ 

  {
  if (m->numberOfEncTypes == 0) {
    return ((enum __anonenum_encoding_type_32 )0);
  }
  return ((*(m->encodingTypes + 0)));
}
}
int messageAddLine(message *m , line_t *line ) 
{ char const   *tmp___1 ;

  {
  if ((unsigned int )m->body_first == (unsigned int )((void *)0)) {
    m->body_first = (text *)cli_malloc(sizeof(text ));
    m->body_last = m->body_first;
  } else {
    (m->body_last)->t_next = (struct text *)cli_malloc(sizeof(text ));
    m->body_last = (m->body_last)->t_next;
  }
  if ((unsigned int )m->body_last == (unsigned int )((void *)0)) {
    return (-1);
  }
  (m->body_last)->t_next = (struct text *)((void *)0);
  if (line) {
    tmp___1 = lineGetData((line_t const   *)line);
    if (tmp___1) {
      (m->body_last)->t_line = lineLink(line);
      messageIsEncoding(m);
    } else {
      (m->body_last)->t_line = (line_t *)((void *)0);
    }
  } else {
    (m->body_last)->t_line = (line_t *)((void *)0);
  }
  return (1);
}
}
int messageAddStr(message *m , char const   *data ) 
{ line_t *repeat ;
  int iswhite ;
  char const   *p ;
  unsigned short const   **tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___123 ;
  char const   *tmp___124 ;
  char const   *tmp___188 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___190 ;
  int tmp___191 ;
  char const   *tmp___192 ;
  char const   *tmp___193 ;
  char const   *tmp___222 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  char const   *tmp___223 ;
  char const   *tmp___224 ;
  char const   *tmp___225 ;
  char const   *tmp___226 ;
  int tmp___227 ;
  char const   *tmp___228 ;
  int tmp___229 ;
  int tmp___230 ;
  char const   *tmp___231 ;
  char const   *tmp___232 ;
  char const   *tmp___233 ;
  int tmp___234 ;
  int tmp___235 ;
  int tmp___236 ;
  int tmp___237 ;
  char const   *tmp___238 ;
  char const   *tmp___239 ;
  char const   *tmp___240 ;
  int tmp___241 ;

  {
  repeat = (line_t *)((void *)0);
  if (data) {
    if ((int const   )(*data) == 0) {
      data = (char const   *)((void *)0);
    } else {
      iswhite = 1;
      p = data;
      while ((*p)) {
        tmp = __ctype_b_loc();
        if (! ((int const   )(*((*tmp) + (int )(*p))) & 8192)) {
          iswhite = 0;
          break;
        }
        p ++;
      }
      if (iswhite) {
        data = " ";
      }
    }
  }
  if ((unsigned int )m->body_first == (unsigned int )((void *)0)) {
    m->body_first = (text *)cli_malloc(sizeof(text ));
    m->body_last = m->body_first;
  } else {
    if ((unsigned int )data == (unsigned int )((void *)0)) {
      if ((unsigned int )(m->body_last)->t_line == (unsigned int )((void *)0)) {
        return (1);
      }
    }
    (m->body_last)->t_next = (struct text *)cli_malloc(sizeof(text ));
    if ((unsigned int )(m->body_last)->t_next == (unsigned int )((void *)0)) {
      messageDedup(m);
      (m->body_last)->t_next = (struct text *)cli_malloc(sizeof(text ));
      if ((unsigned int )(m->body_last)->t_next == (unsigned int )((void *)0)) {
        cli_errmsg("messageAddStr: out of memory\n");
        return (-1);
      }
    }
    if (data) {
      if ((m->body_last)->t_line) {
        tmp___235 = __builtin_constant_p((int )data);
        if (tmp___235) {
          tmp___236 = (int )lineGetData((line_t const   *)(m->body_last)->t_line);
          tmp___237 = __builtin_constant_p(tmp___236);
          if (tmp___237) {
            __s1_len = strlen(data);
            tmp___238 = lineGetData((line_t const   *)(m->body_last)->t_line);
            __s2_len = strlen(tmp___238);
            if (! ((unsigned int )((void const   *)(data + 1)) - (unsigned int )((void const   *)data) ==
                   1U)) {
              goto _L___16;
            } else {
              if (__s1_len >= 4U) {
                _L___16: 
                tmp___239 = lineGetData((line_t const   *)(m->body_last)->t_line);
                tmp___240 = lineGetData((line_t const   *)(m->body_last)->t_line);
                if ((unsigned int )((void const   *)(tmp___239 + 1)) - (unsigned int )((void const   *)tmp___240) ==
                    1U) {
                  if (__s2_len >= 4U) {
                    tmp___241 = 1;
                  } else {
                    tmp___241 = 0;
                  }
                } else {
                  tmp___241 = 1;
                }
              } else {
                tmp___241 = 0;
              }
            }
            if (tmp___241) {
              tmp___124 = lineGetData((line_t const   *)(m->body_last)->t_line);
              tmp___123 = __builtin_strcmp(data, tmp___124);
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: 
          tmp___234 = __builtin_constant_p((int )data);
          if (tmp___234) {
            if ((unsigned int )((void const   *)(data + 1)) - (unsigned int )((void const   *)data) ==
                1U) {
              __s1_len = strlen(data);
              if (__s1_len < 4U) {
                tmp___190 = (int )lineGetData((line_t const   *)(m->body_last)->t_line);
                tmp___191 = __builtin_constant_p(tmp___190);
                if (tmp___191) {
                  tmp___192 = lineGetData((line_t const   *)(m->body_last)->t_line);
                  tmp___193 = lineGetData((line_t const   *)(m->body_last)->t_line);
                  if ((unsigned int )((void const   *)(tmp___192 + 1)) - (unsigned int )((void const   *)tmp___193) ==
                      1U) {
                    tmp___188 = lineGetData((line_t const   *)(m->body_last)->t_line);
                    tmp___123 = __builtin_strcmp(data, tmp___188);
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: 
                  __s2___6 = (unsigned char const   *)lineGetData((line_t const   *)(m->body_last)->t_line);
                  __result___18 = (int )((int const   )(*((unsigned char const   *)data +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
                  if (__s1_len > 0U) {
                    if (__result___18 == 0) {
                      __result___18 = (int )((int const   )(*((unsigned char const   *)data +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
                      if (__s1_len > 1U) {
                        if (__result___18 == 0) {
                          __result___18 = (int )((int const   )(*((unsigned char const   *)data +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
                          if (__s1_len > 2U) {
                            if (__result___18 == 0) {
                              __result___18 = (int )((int const   )(*((unsigned char const   *)data +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___123 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: 
            tmp___229 = (int )lineGetData((line_t const   *)(m->body_last)->t_line);
            tmp___230 = __builtin_constant_p(tmp___229);
            if (tmp___230) {
              tmp___231 = lineGetData((line_t const   *)(m->body_last)->t_line);
              tmp___232 = lineGetData((line_t const   *)(m->body_last)->t_line);
              if ((unsigned int )((void const   *)(tmp___231 + 1)) - (unsigned int )((void const   *)tmp___232) ==
                  1U) {
                tmp___233 = lineGetData((line_t const   *)(m->body_last)->t_line);
                __s2_len = strlen(tmp___233);
                if (__s2_len < 4U) {
                  tmp___227 = __builtin_constant_p((int )data);
                  if (tmp___227) {
                    if ((unsigned int )((void const   *)(data + 1)) - (unsigned int )((void const   *)data) ==
                        1U) {
                      tmp___222 = lineGetData((line_t const   *)(m->body_last)->t_line);
                      tmp___123 = __builtin_strcmp(data, tmp___222);
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: 
                    __s1___14 = (unsigned char const   *)data;
                    tmp___223 = lineGetData((line_t const   *)(m->body_last)->t_line);
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)tmp___223 +
                                                                                               0)));
                    if (__s2_len > 0U) {
                      if (__result___22 == 0) {
                        tmp___224 = lineGetData((line_t const   *)(m->body_last)->t_line);
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)tmp___224 +
                                                                1)));
                        if (__s2_len > 1U) {
                          if (__result___22 == 0) {
                            tmp___225 = lineGetData((line_t const   *)(m->body_last)->t_line);
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)tmp___225 +
                                                                    2)));
                            if (__s2_len > 2U) {
                              if (__result___22 == 0) {
                                tmp___226 = lineGetData((line_t const   *)(m->body_last)->t_line);
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)tmp___226 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___123 = __result___22;
                  }
                } else {
                  tmp___228 = lineGetData((line_t const   *)(m->body_last)->t_line);
                  tmp___123 = __builtin_strcmp(data, tmp___228);
                }
              } else {
                tmp___228 = lineGetData((line_t const   *)(m->body_last)->t_line);
                tmp___123 = __builtin_strcmp(data, tmp___228);
              }
            } else {
              tmp___228 = lineGetData((line_t const   *)(m->body_last)->t_line);
              tmp___123 = __builtin_strcmp(data, tmp___228);
            }
          }
        }
        if (tmp___123 == 0) {
          repeat = (m->body_last)->t_line;
        }
      }
    }
    m->body_last = (m->body_last)->t_next;
  }
  if ((unsigned int )m->body_last == (unsigned int )((void *)0)) {
    cli_errmsg("messageAddStr: out of memory\n");
    return (-1);
  }
  (m->body_last)->t_next = (struct text *)((void *)0);
  if (data) {
    if ((*data)) {
      if (repeat) {
        (m->body_last)->t_line = lineLink(repeat);
      } else {
        (m->body_last)->t_line = lineCreate(data);
      }
      if ((unsigned int )(m->body_last)->t_line == (unsigned int )((void *)0)) {
        if ((unsigned int )repeat == (unsigned int )((void *)0)) {
          messageDedup(m);
          (m->body_last)->t_line = lineCreate(data);
          if ((unsigned int )(m->body_last)->t_line == (unsigned int )((void *)0)) {
            cli_errmsg("messageAddStr: out of memory\n");
            return (-1);
          }
        }
      }
      if ((unsigned int )repeat == (unsigned int )((void *)0)) {
        messageIsEncoding(m);
      }
    } else {
      (m->body_last)->t_line = (line_t *)((void *)0);
    }
  } else {
    (m->body_last)->t_line = (line_t *)((void *)0);
  }
  return (1);
}
}
int messageAddStrAtTop(message *m , char const   *data ) 
{ text *oldfirst ;
  line_t *tmp ;
  int tmp___0 ;
  char const   *tmp___2 ;

  {
  if ((unsigned int )m->body_first == (unsigned int )((void *)0)) {
    tmp = lineCreate(data);
    tmp___0 = messageAddLine(m, tmp);
    return (tmp___0);
  }
  oldfirst = m->body_first;
  m->body_first = (text *)cli_malloc(sizeof(text ));
  if ((unsigned int )m->body_first == (unsigned int )((void *)0)) {
    m->body_first = oldfirst;
    return (-1);
  }
  (m->body_first)->t_next = oldfirst;
  if (data) {
    tmp___2 = data;
  } else {
    tmp___2 = "";
  }
  (m->body_first)->t_line = lineCreate(tmp___2);
  if ((unsigned int )(m->body_first)->t_line == (unsigned int )((void *)0)) {
    cli_errmsg("messageAddStrAtTop: out of memory\n");
    return (-1);
  }
  return (1);
}
}
static char const   encoding[26]  = 
  {      (char const   )'C',      (char const   )'o',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )'-', 
        (char const   )'T',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'s',      (char const   )'f',      (char const   )'e',      (char const   )'r', 
        (char const   )'-',      (char const   )'E',      (char const   )'n',      (char const   )'c', 
        (char const   )'o',      (char const   )'d',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )'\000'};
static char const   binhex[46]  = 
  {      (char const   )'(',      (char const   )'T',      (char const   )'h',      (char const   )'i', 
        (char const   )'s',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'m', 
        (char const   )'u',      (char const   )'s',      (char const   )'t',      (char const   )' ', 
        (char const   )'b',      (char const   )'e',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'n',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'w',      (char const   )'i',      (char const   )'t', 
        (char const   )'h',      (char const   )' ',      (char const   )'B',      (char const   )'i', 
        (char const   )'n',      (char const   )'H',      (char const   )'e',      (char const   )'x', 
        (char const   )' ',      (char const   )'4',      (char const   )'.',      (char const   )'0', 
        (char const   )')',      (char const   )'\000'};
static void messageIsEncoding(message *m ) 
{ char const   *line ;
  char const   *tmp ;
  int tmp___74 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___110 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___129 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  size_t tmp___145 ;
  int tmp___146 ;
  size_t tmp___147 ;
  char *tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  int tmp___151 ;
  size_t tmp___152 ;
  cli_file_t tmp___153 ;
  int tmp___154 ;
  char *tmp___155 ;

  {
  tmp = lineGetData((line_t const   *)(m->body_last)->t_line);
  line = tmp;
  if ((unsigned int )m->encoding == (unsigned int )((void *)0)) {
    tmp___154 = strncasecmp(line, encoding, sizeof(encoding) - 1U);
    if (tmp___154 == 0) {
      tmp___155 = strstr(line, "7bit");
      if ((unsigned int )tmp___155 == (unsigned int )((void *)0)) {
        m->encoding = (text const   *)m->body_last;
      } else {
        goto _L___47;
      }
    } else {
      goto _L___47;
    }
  } else {
    _L___47: 
    if ((unsigned int )m->bounce == (unsigned int )((void *)0)) {
      tmp___151 = strncasecmp(line, "Received: ", 10U);
      if (tmp___151 == 0) {
        tmp___152 = strlen(line);
        tmp___153 = cli_filetype(line, tmp___152);
        if ((int )tmp___153 == 520) {
          m->bounce = (text const   *)m->body_last;
        } else {
          goto _L___45;
        }
      } else {
        goto _L___45;
      }
    } else {
      _L___45: 
      if ((unsigned int )m->uuencode == (unsigned int )((void *)0)) {
        tmp___150 = isuuencodebegin(line);
        if (tmp___150) {
          m->uuencode = (text const   *)m->body_last;
        } else {
          goto _L___43;
        }
      } else {
        _L___43: 
        if ((unsigned int )m->binhex == (unsigned int )((void *)0)) {
          tmp___148 = strstr(line, "BinHex");
          if (tmp___148) {
            tmp___149 = simil(line, binhex);
            if (tmp___149 > 90) {
              m->binhex = (text const   *)m->body_last;
            } else {
              goto _L___42;
            }
          } else {
            goto _L___42;
          }
        } else {
          _L___42: 
          if ((unsigned int )m->yenc == (unsigned int )((void *)0)) {
            tmp___144 = __builtin_constant_p((int )line);
            if (tmp___144) {
              tmp___145 = strlen(line);
              if (tmp___145 < 13U) {
                goto _L___39;
              } else {
                goto _L___40;
              }
            } else {
              _L___40: 
              tmp___146 = __builtin_constant_p((int )"=ybegin line=");
              if (tmp___146) {
                tmp___147 = strlen("=ybegin line=");
                if (tmp___147 < 13U) {
                  _L___39: 
                  tmp___141 = __builtin_constant_p((int )line);
                  if (tmp___141) {
                    tmp___142 = __builtin_constant_p((int )"=ybegin line=");
                    if (tmp___142) {
                      __s1_len___0 = strlen(line);
                      __s2_len___0 = strlen("=ybegin line=");
                      if (! ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                             1U)) {
                        goto _L___36;
                      } else {
                        if (__s1_len___0 >= 4U) {
                          _L___36: 
                          if (! ((unsigned int )((void const   *)("=ybegin line=" +
                                                                  1)) - (unsigned int )((void const   *)"=ybegin line=") ==
                                 1U)) {
                            tmp___143 = 1;
                          } else {
                            if (__s2_len___0 >= 4U) {
                              tmp___143 = 1;
                            } else {
                              tmp___143 = 0;
                            }
                          }
                        } else {
                          tmp___143 = 0;
                        }
                      }
                      if (tmp___143) {
                        tmp___110 = __builtin_strcmp(line, "=ybegin line=");
                      } else {
                        goto _L___38;
                      }
                    } else {
                      goto _L___38;
                    }
                  } else {
                    _L___38: 
                    tmp___140 = __builtin_constant_p((int )line);
                    if (tmp___140) {
                      if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                          1U) {
                        __s1_len___0 = strlen(line);
                        if (__s1_len___0 < 4U) {
                          tmp___129 = __builtin_constant_p((int )"=ybegin line=");
                          if (tmp___129) {
                            if ((unsigned int )((void const   *)("=ybegin line=" +
                                                                 1)) - (unsigned int )((void const   *)"=ybegin line=") ==
                                1U) {
                              tmp___110 = __builtin_strcmp(line, "=ybegin line=");
                            } else {
                              goto _L___31;
                            }
                          } else {
                            _L___31: 
                            __s2___14 = (unsigned char const   *)"=ybegin line=";
                            __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                    0)) - (int const   )(*(__s2___14 +
                                                                                           0)));
                            if (__s1_len___0 > 0U) {
                              if (__result___42 == 0) {
                                __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                        1)) - (int const   )(*(__s2___14 +
                                                                                               1)));
                                if (__s1_len___0 > 1U) {
                                  if (__result___42 == 0) {
                                    __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                            2)) -
                                                           (int const   )(*(__s2___14 +
                                                                            2)));
                                    if (__s1_len___0 > 2U) {
                                      if (__result___42 == 0) {
                                        __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                                3)) -
                                                               (int const   )(*(__s2___14 +
                                                                                3)));
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            tmp___110 = __result___42;
                          }
                        } else {
                          goto _L___35;
                        }
                      } else {
                        goto _L___35;
                      }
                    } else {
                      _L___35: 
                      tmp___139 = __builtin_constant_p((int )"=ybegin line=");
                      if (tmp___139) {
                        if ((unsigned int )((void const   *)("=ybegin line=" + 1)) -
                            (unsigned int )((void const   *)"=ybegin line=") == 1U) {
                          __s2_len___0 = strlen("=ybegin line=");
                          if (__s2_len___0 < 4U) {
                            tmp___138 = __builtin_constant_p((int )line);
                            if (tmp___138) {
                              if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                                  1U) {
                                tmp___110 = __builtin_strcmp(line, "=ybegin line=");
                              } else {
                                goto _L___33;
                              }
                            } else {
                              _L___33: 
                              __s1___30 = (unsigned char const   *)line;
                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                      0)) - (int const   )(*((unsigned char const   *)"=ybegin line=" +
                                                                                             0)));
                              if (__s2_len___0 > 0U) {
                                if (__result___46 == 0) {
                                  __result___46 = (int )((int const   )(*(__s1___30 +
                                                                          1)) - (int const   )(*((unsigned char const   *)"=ybegin line=" +
                                                                                                 1)));
                                  if (__s2_len___0 > 1U) {
                                    if (__result___46 == 0) {
                                      __result___46 = (int )((int const   )(*(__s1___30 +
                                                                              2)) -
                                                             (int const   )(*((unsigned char const   *)"=ybegin line=" +
                                                                              2)));
                                      if (__s2_len___0 > 2U) {
                                        if (__result___46 == 0) {
                                          __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                  3)) -
                                                                 (int const   )(*((unsigned char const   *)"=ybegin line=" +
                                                                                  3)));
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              tmp___110 = __result___46;
                            }
                          } else {
                            tmp___110 = __builtin_strcmp(line, "=ybegin line=");
                          }
                        } else {
                          tmp___110 = __builtin_strcmp(line, "=ybegin line=");
                        }
                      } else {
                        tmp___110 = __builtin_strcmp(line, "=ybegin line=");
                      }
                    }
                  }
                  tmp___74 = tmp___110;
                } else {
                  tmp___74 = strncmp(line, "=ybegin line=", 13U);
                }
              } else {
                tmp___74 = strncmp(line, "=ybegin line=", 13U);
              }
            }
            if (tmp___74 == 0) {
              m->yenc = (text const   *)m->body_last;
            }
          }
        }
      }
    }
  }
  return;
}
}
text const   *messageGetBody(message const   *m ) 
{ 

  {
  return ((text const   *)m->body_first);
}
}
void messageClean(message *m ) 
{ text *newEnd ;
  text *tmp ;

  {
  tmp = textClean(m->body_first);
  newEnd = tmp;
  if (newEnd) {
    m->body_last = newEnd;
  }
  return;
}
}
static void *messageExport(message *m , char const   *dir , void *(*create)(void) ,
                           void (*destroy)(void * ) , void (*setFilename)(void * ,
                                                                          char const   * ,
                                                                          char const   * ) ,
                           void (*addData)(void * , unsigned char const   * , size_t  ) ,
                           void *(*exportText)(text const   * , void * ) ) 
{ void *ret ;
  text const   *t_line ;
  char *filename ;
  int i ;
  text const   *tmp ;
  unsigned char byte ;
  unsigned long newlen ;
  unsigned long len ;
  unsigned long l ;
  unsigned char *data ;
  char *ptr ;
  int bytenumber ;
  blob *tmp___0 ;
  unsigned char hqxtbl[128] ;
  unsigned char *uptr ;
  unsigned char c ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  blob *u ;
  blob *tmp___4 ;
  unsigned char c___0 ;
  int count ;
  void *tmp___5 ;
  unsigned long tmp___6 ;
  char const   *tmp___9 ;
  text const   *tmp___10 ;
  void *tmp___11 ;
  text const   *tmp___12 ;
  encoding_type enctype ;
  size_t size ;
  void *newret ;
  char const   *tmp___13 ;
  size_t __len___2 ;
  size_t tmp___31 ;
  char *__retval___2 ;
  char *tmp___32 ;
  int tmp___34 ;
  char const   *tmp___35 ;
  char const   *tmp___38 ;
  text const   *tmp___39 ;
  text const   *tmp___40 ;
  text const   *tmp___41 ;
  unsigned char smallbuf[1024] ;
  unsigned char *uptr___0 ;
  unsigned char *data___0 ;
  char const   *line ;
  char const   *tmp___42 ;
  unsigned char *bigbuf ;
  size_t datasize ;
  int tmp___43 ;
  int tmp___118 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___154 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___173 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___182 ;
  int tmp___183 ;
  int tmp___184 ;
  int tmp___185 ;
  int tmp___186 ;
  int tmp___187 ;
  int tmp___188 ;
  size_t tmp___189 ;
  int tmp___190 ;
  size_t tmp___191 ;
  size_t tmp___193 ;
  unsigned char data___1[4] ;
  unsigned char *ptr___0 ;

  {
  tmp = messageGetBody((message const   *)m);
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
    return ((void *)0);
  }
  ret = ((*create))();
  if ((unsigned int )ret == (unsigned int )((void *)0)) {
    return ((void *)0);
  }
  cli_dbgmsg("messageExport: numberOfEncTypes == %d\n", m->numberOfEncTypes);
  t_line = binhexBegin((message const   *)m);
  if ((unsigned int )t_line != (unsigned int )((void *)0)) {
    newlen = 0UL;
    hqxtbl[0] = (unsigned char)255;
    hqxtbl[1] = (unsigned char)255;
    hqxtbl[2] = (unsigned char)255;
    hqxtbl[3] = (unsigned char)255;
    hqxtbl[4] = (unsigned char)255;
    hqxtbl[5] = (unsigned char)255;
    hqxtbl[6] = (unsigned char)255;
    hqxtbl[7] = (unsigned char)255;
    hqxtbl[8] = (unsigned char)255;
    hqxtbl[9] = (unsigned char)255;
    hqxtbl[10] = (unsigned char)255;
    hqxtbl[11] = (unsigned char)255;
    hqxtbl[12] = (unsigned char)255;
    hqxtbl[13] = (unsigned char)255;
    hqxtbl[14] = (unsigned char)255;
    hqxtbl[15] = (unsigned char)255;
    hqxtbl[16] = (unsigned char)255;
    hqxtbl[17] = (unsigned char)255;
    hqxtbl[18] = (unsigned char)255;
    hqxtbl[19] = (unsigned char)255;
    hqxtbl[20] = (unsigned char)255;
    hqxtbl[21] = (unsigned char)255;
    hqxtbl[22] = (unsigned char)255;
    hqxtbl[23] = (unsigned char)255;
    hqxtbl[24] = (unsigned char)255;
    hqxtbl[25] = (unsigned char)255;
    hqxtbl[26] = (unsigned char)255;
    hqxtbl[27] = (unsigned char)255;
    hqxtbl[28] = (unsigned char)255;
    hqxtbl[29] = (unsigned char)255;
    hqxtbl[30] = (unsigned char)255;
    hqxtbl[31] = (unsigned char)255;
    hqxtbl[32] = (unsigned char)255;
    hqxtbl[33] = (unsigned char)0;
    hqxtbl[34] = (unsigned char)1;
    hqxtbl[35] = (unsigned char)2;
    hqxtbl[36] = (unsigned char)3;
    hqxtbl[37] = (unsigned char)4;
    hqxtbl[38] = (unsigned char)5;
    hqxtbl[39] = (unsigned char)6;
    hqxtbl[40] = (unsigned char)7;
    hqxtbl[41] = (unsigned char)8;
    hqxtbl[42] = (unsigned char)9;
    hqxtbl[43] = (unsigned char)10;
    hqxtbl[44] = (unsigned char)11;
    hqxtbl[45] = (unsigned char)12;
    hqxtbl[46] = (unsigned char)255;
    hqxtbl[47] = (unsigned char)255;
    hqxtbl[48] = (unsigned char)13;
    hqxtbl[49] = (unsigned char)14;
    hqxtbl[50] = (unsigned char)15;
    hqxtbl[51] = (unsigned char)16;
    hqxtbl[52] = (unsigned char)17;
    hqxtbl[53] = (unsigned char)18;
    hqxtbl[54] = (unsigned char)19;
    hqxtbl[55] = (unsigned char)255;
    hqxtbl[56] = (unsigned char)20;
    hqxtbl[57] = (unsigned char)21;
    hqxtbl[58] = (unsigned char)255;
    hqxtbl[59] = (unsigned char)255;
    hqxtbl[60] = (unsigned char)255;
    hqxtbl[61] = (unsigned char)255;
    hqxtbl[62] = (unsigned char)255;
    hqxtbl[63] = (unsigned char)255;
    hqxtbl[64] = (unsigned char)22;
    hqxtbl[65] = (unsigned char)23;
    hqxtbl[66] = (unsigned char)24;
    hqxtbl[67] = (unsigned char)25;
    hqxtbl[68] = (unsigned char)26;
    hqxtbl[69] = (unsigned char)27;
    hqxtbl[70] = (unsigned char)28;
    hqxtbl[71] = (unsigned char)29;
    hqxtbl[72] = (unsigned char)30;
    hqxtbl[73] = (unsigned char)31;
    hqxtbl[74] = (unsigned char)32;
    hqxtbl[75] = (unsigned char)33;
    hqxtbl[76] = (unsigned char)34;
    hqxtbl[77] = (unsigned char)35;
    hqxtbl[78] = (unsigned char)36;
    hqxtbl[79] = (unsigned char)255;
    hqxtbl[80] = (unsigned char)37;
    hqxtbl[81] = (unsigned char)38;
    hqxtbl[82] = (unsigned char)39;
    hqxtbl[83] = (unsigned char)40;
    hqxtbl[84] = (unsigned char)41;
    hqxtbl[85] = (unsigned char)42;
    hqxtbl[86] = (unsigned char)43;
    hqxtbl[87] = (unsigned char)255;
    hqxtbl[88] = (unsigned char)44;
    hqxtbl[89] = (unsigned char)45;
    hqxtbl[90] = (unsigned char)46;
    hqxtbl[91] = (unsigned char)47;
    hqxtbl[92] = (unsigned char)255;
    hqxtbl[93] = (unsigned char)255;
    hqxtbl[94] = (unsigned char)255;
    hqxtbl[95] = (unsigned char)255;
    hqxtbl[96] = (unsigned char)48;
    hqxtbl[97] = (unsigned char)49;
    hqxtbl[98] = (unsigned char)50;
    hqxtbl[99] = (unsigned char)51;
    hqxtbl[100] = (unsigned char)52;
    hqxtbl[101] = (unsigned char)53;
    hqxtbl[102] = (unsigned char)54;
    hqxtbl[103] = (unsigned char)255;
    hqxtbl[104] = (unsigned char)55;
    hqxtbl[105] = (unsigned char)56;
    hqxtbl[106] = (unsigned char)57;
    hqxtbl[107] = (unsigned char)58;
    hqxtbl[108] = (unsigned char)59;
    hqxtbl[109] = (unsigned char)60;
    hqxtbl[110] = (unsigned char)255;
    hqxtbl[111] = (unsigned char)255;
    hqxtbl[112] = (unsigned char)61;
    hqxtbl[113] = (unsigned char)62;
    hqxtbl[114] = (unsigned char)63;
    hqxtbl[115] = (unsigned char)255;
    hqxtbl[116] = (unsigned char)255;
    hqxtbl[117] = (unsigned char)255;
    hqxtbl[118] = (unsigned char)255;
    hqxtbl[119] = (unsigned char)255;
    hqxtbl[120] = (unsigned char)255;
    hqxtbl[121] = (unsigned char)255;
    hqxtbl[122] = (unsigned char)255;
    hqxtbl[123] = (unsigned char)255;
    hqxtbl[124] = (unsigned char)255;
    hqxtbl[125] = (unsigned char)255;
    hqxtbl[126] = (unsigned char)255;
    hqxtbl[127] = (unsigned char)255;
    while (1) {
      t_line = (text const   *)t_line->t_next;
      if ((unsigned int )t_line != (unsigned int )((void *)0)) {
        if (! ((unsigned int )t_line->t_line == (unsigned int )((void *)0))) {
          break;
        }
      } else {
        break;
      }
    }
    tmp___0 = textToBlob(t_line, (blob *)((void *)0));
    if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
      ((*destroy))(ret);
      return ((void *)0);
    }
    data = blobGetData((blob const   *)tmp___0);
    if ((unsigned int )data == (unsigned int )((void *)0)) {
      cli_warnmsg("Couldn\'t locate the binhex message that was claimed to be there\n");
      blobDestroy(tmp___0);
      ((*destroy))(ret);
      return ((void *)0);
    }
    len = blobGetDataSize((blob const   *)tmp___0);
    if ((int )(*(data + 0)) == 58) {
      cli_dbgmsg("decode HQX7 message (%lu bytes)\n", len);
      uptr = (unsigned char *)cli_malloc((unsigned int )len);
      if ((unsigned int )uptr == (unsigned int )((void *)0)) {
        blobDestroy(tmp___0);
        ((*destroy))(ret);
        return ((void *)0);
      }
      memcpy((void * __restrict  )uptr, (void const   * __restrict  )data, (unsigned int )len);
      bytenumber = 0;
      l = 1UL;
      while (l < len) {
        c = (*(uptr + l));
        if ((int )c == 58) {
          break;
        }
        if ((int )c == 10) {
          goto __Cont;
        } else {
          if ((int )c == 13) {
            goto __Cont;
          }
        }
        if ((int )c < 32) {
          cli_warnmsg("Invalid HQX7 character \'%c\' (0x%02x)\n", c, c);
          break;
        } else {
          if ((int )c > 127) {
            cli_warnmsg("Invalid HQX7 character \'%c\' (0x%02x)\n", c, c);
            break;
          } else {
            if ((int )hqxtbl[c] == 255) {
              cli_warnmsg("Invalid HQX7 character \'%c\' (0x%02x)\n", c, c);
              break;
            }
          }
        }
        c = hqxtbl[c];
        switch (bytenumber) {
        case 0: 
        (*(data + newlen)) = (unsigned char )(((int )c << 2) & 252);
        bytenumber = 1;
        break;
        case 1: 
        tmp___1 = newlen;
        newlen ++;
        (*(data + tmp___1)) = (unsigned char )((int )(*(data + tmp___1)) | (((int )c >>
                                                                             4) &
                                                                            3));
        (*(data + newlen)) = (unsigned char )(((int )c << 4) & 240);
        bytenumber = 2;
        break;
        case 2: 
        tmp___2 = newlen;
        newlen ++;
        (*(data + tmp___2)) = (unsigned char )((int )(*(data + tmp___2)) | (((int )c >>
                                                                             2) &
                                                                            15));
        (*(data + newlen)) = (unsigned char )(((int )c << 6) & 192);
        bytenumber = 3;
        break;
        case 3: 
        tmp___3 = newlen;
        newlen ++;
        (*(data + tmp___3)) = (unsigned char )((int )(*(data + tmp___3)) | ((int )c &
                                                                            63));
        bytenumber = 0;
        break;
        }
        __Cont: 
        l ++;
      }
      cli_dbgmsg("decoded HQX7 message (now %lu bytes)\n", newlen);
      free((void *)uptr);
    } else {
      cli_warnmsg("HQX8 messages not yet supported - if you believe this file contains a virus, report it to bugs@clamav.net\n",
                  len);
      newlen = len;
    }
    tmp___5 = memchr((void const   *)data, 144, (unsigned int )newlen);
    if (tmp___5) {
      tmp___4 = blobCreate();
      u = tmp___4;
      if ((unsigned int )u == (unsigned int )((void *)0)) {
        ((*destroy))(ret);
        blobDestroy(tmp___0);
        return ((void *)0);
      }
      l = 0UL;
      while (l < newlen) {
        c___0 = (*(data + l));
        blobAddData(u, (unsigned char const   *)(& c___0), 1U);
        if (l < newlen - 1UL) {
          if ((int )(*(data + (l + 1UL))) == 144) {
            l += 2UL;
            count = (int )(*(data + l));
            if (count == 0) {
              c___0 = (unsigned char)144;
              blobAddData(u, (unsigned char const   *)(& c___0), 1U);
            } else {
              blobGrow(u, (unsigned int )count);
              while (1) {
                count --;
                if (! (count > 0)) {
                  break;
                }
                blobAddData(u, (unsigned char const   *)(& c___0), 1U);
              }
            }
          }
        }
        l ++;
      }
      blobDestroy(tmp___0);
      tmp___0 = u;
      data = blobGetData((blob const   *)tmp___0);
      len = blobGetDataSize((blob const   *)tmp___0);
      cli_dbgmsg("Uncompressed %lu bytes to %lu\n", newlen, len);
    } else {
      len = newlen;
      cli_dbgmsg("HQX7 message (%lu bytes) is not compressed\n", len);
    }
    if (len == 0UL) {
      cli_warnmsg("Discarding empty binHex attachment\n");
      ((*destroy))(ret);
      blobDestroy(tmp___0);
      return ((void *)0);
    }
    byte = (*(data + 0));
    if ((unsigned long )byte >= len) {
      ((*destroy))(ret);
      blobDestroy(tmp___0);
      return ((void *)0);
    }
    filename = (char *)cli_malloc((unsigned int )((int )byte + 1));
    if ((unsigned int )filename == (unsigned int )((void *)0)) {
      ((*destroy))(ret);
      blobDestroy(tmp___0);
      return ((void *)0);
    }
    memcpy((void * __restrict  )filename, (void const   * __restrict  )(data + 1),
           (unsigned int )byte);
    (*(filename + (int )byte)) = (char )'\000';
    ((*setFilename))(ret, dir, (char const   *)filename);
    ptr = (char *)cli_malloc((unsigned int )((int )byte + 6));
    if (ptr) {
      sprintf((char * __restrict  )ptr, (char const   * __restrict  )"name=%s", filename);
      messageAddArgument(m, (char const   *)ptr);
      free((void *)ptr);
    }
    byte = (unsigned char )(((((1 + (int )byte) + 1) + 4) + 4) + 2);
    len = (unsigned long )(((((unsigned int )((int )(*(data + (int )byte)) << 24) &
                              4278190080U) | (unsigned int )(((int )(*(data + ((int )byte +
                                                                               1))) <<
                                                              16) & 16711680)) | (unsigned int )(((int )(*(data +
                                                                                                           ((int )byte +
                                                                                                            2))) <<
                                                                                                  8) &
                                                                                                 65280)) |
                           (unsigned int )((int )(*(data + ((int )byte + 3))) & 255));
    cli_dbgmsg("Filename = \'%s\', data fork length = %lu bytes\n", filename, len);
    free((void *)filename);
    byte = (unsigned char )((int )byte + 10);
    tmp___6 = blobGetDataSize((blob const   *)tmp___0);
    l = tmp___6 - (unsigned long )byte;
    if (l < len) {
      cli_warnmsg("Corrupt BinHex file, claims it is %lu bytes long in a message of %lu bytes\n",
                  len, l);
      len = l;
    }
    ((*addData))(ret, (unsigned char const   *)(data + (int )byte), (unsigned int )len);
    blobDestroy(tmp___0);
    m->binhex = (text const   *)((void *)0);
    if (m->numberOfEncTypes == 1) {
      if ((int )(*(m->encodingTypes + 0)) == 8) {
        cli_dbgmsg("Finished exporting binhex file\n");
        return (ret);
      }
    }
  }
  if (m->numberOfEncTypes == 0) {
    filename = messageFindArgument((message const   *)m, "filename");
    if ((unsigned int )filename == (unsigned int )((void *)0)) {
      filename = messageFindArgument((message const   *)m, "name");
      if ((unsigned int )filename == (unsigned int )((void *)0)) {
        cli_dbgmsg("Unencoded attachment sent with no filename\n");
        messageAddArgument(m, "name=attachment");
      } else {
        messageSetEncoding(m, "base64");
      }
    }
    if (filename) {
      if ((*filename)) {
        tmp___9 = (char const   *)filename;
      } else {
        tmp___9 = "attachment";
      }
    } else {
      tmp___9 = "attachment";
    }
    ((*setFilename))(ret, dir, tmp___9);
    if (filename) {
      free((void *)filename);
    }
    if (m->numberOfEncTypes == 0) {
      tmp___12 = uuencodeBegin((message const   *)m);
      if (tmp___12) {
        messageSetEncoding(m, "x-uuencode");
      } else {
        tmp___10 = messageGetBody((message const   *)m);
        tmp___11 = ((*exportText))(tmp___10, ret);
        return (tmp___11);
      }
    }
  }
  i = 0;
  while (i < m->numberOfEncTypes) {
    enctype = (*(m->encodingTypes + i));
    if (i > 0) {
      newret = ((*create))();
      if ((unsigned int )newret == (unsigned int )((void *)0)) {
        cli_errmsg("Not all decoding algorithms were run\n");
        return (ret);
      }
      ((*destroy))(ret);
      ret = newret;
    }
    cli_dbgmsg("messageExport: enctype %d is %d\n", i, enctype);
    if ((int )enctype == 5) {
      goto _L___2;
    } else {
      tmp___41 = uuencodeBegin((message const   *)m);
      if (tmp___41) {
        _L___2: 
        t_line = uuencodeBegin((message const   *)m);
        if ((unsigned int )t_line == (unsigned int )((void *)0)) {
          m->uuencode = (text const   *)((void *)0);
          m->base64chars = 0;
          if (i == m->numberOfEncTypes - 1) {
            ((*destroy))(ret);
            return ((void *)0);
          }
          goto __Cont___0;
        }
        tmp___13 = lineGetData((line_t const   *)t_line->t_line);
        filename = cli_strtok(tmp___13, 2, " ");
        if ((unsigned int )filename == (unsigned int )((void *)0)) {
          cli_dbgmsg("UUencoded attachment sent with no filename\n");
          ((*destroy))(ret);
          return ((void *)0);
        }
        cli_chomp(filename);
        cli_dbgmsg("Set uuencode filename to \"%s\"\n", filename);
        ((*setFilename))(ret, dir, (char const   *)filename);
        t_line = (text const   *)t_line->t_next;
        enctype = (enum __anonenum_encoding_type_32 )5;
        m->uuencode = (text const   *)((void *)0);
      } else {
        if ((int )enctype == 6) {
          tmp___39 = yEncBegin((message const   *)m);
          if (tmp___39) {
            goto _L;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          if (i == 0) {
            tmp___40 = yEncBegin((message const   *)m);
            if (tmp___40) {
              _L: 
              t_line = yEncBegin((message const   *)m);
              filename = lineGetData((line_t const   *)t_line->t_line);
              filename = strstr((char const   *)filename, " name=");
              if ((unsigned int )filename != (unsigned int )((void *)0)) {
                tmp___34 = __builtin_constant_p((int )(filename + 6));
                if (tmp___34) {
                  if ((unsigned int )((void const   *)((filename + 6) + 1)) - (unsigned int )((void const   *)(filename +
                                                                                                               6)) ==
                      1U) {
                    if ((int const   )(*((char const   *)(filename + 6) + 0)) == 0) {
                      filename = (char *)calloc(1U, 1U);
                    } else {
                      tmp___31 = strlen((char const   *)(filename + 6));
                      __len___2 = tmp___31 + 1U;
                      tmp___32 = (char *)malloc(__len___2);
                      __retval___2 = tmp___32;
                      if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
                        __retval___2 = (char *)memcpy((void * __restrict  )__retval___2,
                                                      (void const   * __restrict  )(filename +
                                                                                    6),
                                                      __len___2);
                      }
                      filename = __retval___2;
                    }
                  } else {
                    filename = __strdup((char const   *)(filename + 6));
                  }
                } else {
                  filename = __strdup((char const   *)(filename + 6));
                }
                if (filename) {
                  cli_chomp(filename);
                  strstrip(filename);
                  cli_dbgmsg("Set yEnc filename to \"%s\"\n", filename);
                }
              }
              if (filename) {
                if ((*filename)) {
                  tmp___35 = (char const   *)filename;
                } else {
                  tmp___35 = "attachment";
                }
              } else {
                tmp___35 = "attachment";
              }
              ((*setFilename))(ret, dir, tmp___35);
              if (filename) {
                free((void *)filename);
                filename = (char *)((void *)0);
              }
              t_line = (text const   *)t_line->t_next;
              enctype = (enum __anonenum_encoding_type_32 )6;
              m->yenc = (text const   *)((void *)0);
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
            filename = messageFindArgument((message const   *)m, "filename");
            if ((unsigned int )filename == (unsigned int )((void *)0)) {
              filename = messageFindArgument((message const   *)m, "name");
              if ((unsigned int )filename == (unsigned int )((void *)0)) {
                cli_dbgmsg("Attachment sent with no filename\n");
                messageAddArgument(m, "name=attachment");
              } else {
                if ((int )enctype == 0) {
                  messageSetEncoding(m, "base64");
                }
              }
            }
            if (filename) {
              if ((*filename)) {
                tmp___38 = (char const   *)filename;
              } else {
                tmp___38 = "attachment";
              }
            } else {
              tmp___38 = "attachment";
            }
            ((*setFilename))(ret, dir, tmp___38);
            t_line = messageGetBody((message const   *)m);
          }
        }
      }
    }
    if (filename) {
      free((void *)filename);
    }
    if ((unsigned int )t_line == (unsigned int )((void *)0)) {
      cli_warnmsg("Empty attachment not saved\n");
      ((*destroy))(ret);
      return ((void *)0);
    }
    if ((int )enctype == 0) {
      ((*exportText))(t_line, ret);
      goto __Cont___0;
    }
    size = 0U;
    while (1) {
      tmp___42 = lineGetData((line_t const   *)t_line->t_line);
      line = tmp___42;
      if ((int )enctype == 5) {
        if ((unsigned int )line == (unsigned int )((void *)0)) {
          goto __Cont___1;
        }
        tmp___43 = strcasecmp(line, "end");
        if (tmp___43 == 0) {
          break;
        }
      } else {
        if ((int )enctype == 6) {
          if ((unsigned int )line == (unsigned int )((void *)0)) {
            goto __Cont___1;
          }
          tmp___188 = __builtin_constant_p((int )line);
          if (tmp___188) {
            tmp___189 = strlen(line);
            if (tmp___189 < 6U) {
              goto _L___43;
            } else {
              goto _L___44;
            }
          } else {
            _L___44: 
            tmp___190 = __builtin_constant_p((int )"=yend ");
            if (tmp___190) {
              tmp___191 = strlen("=yend ");
              if (tmp___191 < 6U) {
                _L___43: 
                tmp___185 = __builtin_constant_p((int )line);
                if (tmp___185) {
                  tmp___186 = __builtin_constant_p((int )"=yend ");
                  if (tmp___186) {
                    __s1_len___0 = strlen(line);
                    __s2_len___0 = strlen("=yend ");
                    if (! ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                           1U)) {
                      goto _L___40;
                    } else {
                      if (__s1_len___0 >= 4U) {
                        _L___40: 
                        if (! ((unsigned int )((void const   *)("=yend " + 1)) - (unsigned int )((void const   *)"=yend ") ==
                               1U)) {
                          tmp___187 = 1;
                        } else {
                          if (__s2_len___0 >= 4U) {
                            tmp___187 = 1;
                          } else {
                            tmp___187 = 0;
                          }
                        }
                      } else {
                        tmp___187 = 0;
                      }
                    }
                    if (tmp___187) {
                      tmp___154 = __builtin_strcmp(line, "=yend ");
                    } else {
                      goto _L___42;
                    }
                  } else {
                    goto _L___42;
                  }
                } else {
                  _L___42: 
                  tmp___184 = __builtin_constant_p((int )line);
                  if (tmp___184) {
                    if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                        1U) {
                      __s1_len___0 = strlen(line);
                      if (__s1_len___0 < 4U) {
                        tmp___173 = __builtin_constant_p((int )"=yend ");
                        if (tmp___173) {
                          if ((unsigned int )((void const   *)("=yend " + 1)) - (unsigned int )((void const   *)"=yend ") ==
                              1U) {
                            tmp___154 = __builtin_strcmp(line, "=yend ");
                          } else {
                            goto _L___35;
                          }
                        } else {
                          _L___35: 
                          __s2___14 = (unsigned char const   *)"=yend ";
                          __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                  0)) - (int const   )(*(__s2___14 +
                                                                                         0)));
                          if (__s1_len___0 > 0U) {
                            if (__result___42 == 0) {
                              __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                      1)) - (int const   )(*(__s2___14 +
                                                                                             1)));
                              if (__s1_len___0 > 1U) {
                                if (__result___42 == 0) {
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                          2)) - (int const   )(*(__s2___14 +
                                                                                                 2)));
                                  if (__s1_len___0 > 2U) {
                                    if (__result___42 == 0) {
                                      __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                              3)) -
                                                             (int const   )(*(__s2___14 +
                                                                              3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
                          tmp___154 = __result___42;
                        }
                      } else {
                        goto _L___39;
                      }
                    } else {
                      goto _L___39;
                    }
                  } else {
                    _L___39: 
                    tmp___183 = __builtin_constant_p((int )"=yend ");
                    if (tmp___183) {
                      if ((unsigned int )((void const   *)("=yend " + 1)) - (unsigned int )((void const   *)"=yend ") ==
                          1U) {
                        __s2_len___0 = strlen("=yend ");
                        if (__s2_len___0 < 4U) {
                          tmp___182 = __builtin_constant_p((int )line);
                          if (tmp___182) {
                            if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                                1U) {
                              tmp___154 = __builtin_strcmp(line, "=yend ");
                            } else {
                              goto _L___37;
                            }
                          } else {
                            _L___37: 
                            __s1___30 = (unsigned char const   *)line;
                            __result___46 = (int )((int const   )(*(__s1___30 + 0)) -
                                                   (int const   )(*((unsigned char const   *)"=yend " +
                                                                    0)));
                            if (__s2_len___0 > 0U) {
                              if (__result___46 == 0) {
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        1)) - (int const   )(*((unsigned char const   *)"=yend " +
                                                                                               1)));
                                if (__s2_len___0 > 1U) {
                                  if (__result___46 == 0) {
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            2)) -
                                                           (int const   )(*((unsigned char const   *)"=yend " +
                                                                            2)));
                                    if (__s2_len___0 > 2U) {
                                      if (__result___46 == 0) {
                                        __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                3)) -
                                                               (int const   )(*((unsigned char const   *)"=yend " +
                                                                                3)));
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            tmp___154 = __result___46;
                          }
                        } else {
                          tmp___154 = __builtin_strcmp(line, "=yend ");
                        }
                      } else {
                        tmp___154 = __builtin_strcmp(line, "=yend ");
                      }
                    } else {
                      tmp___154 = __builtin_strcmp(line, "=yend ");
                    }
                  }
                }
                tmp___118 = tmp___154;
              } else {
                tmp___118 = strncmp(line, "=yend ", 6U);
              }
            } else {
              tmp___118 = strncmp(line, "=yend ", 6U);
            }
          }
          if (tmp___118 == 0) {
            break;
          }
        }
      }
      if (line) {
        tmp___193 = strlen(line);
        datasize = tmp___193 + 2U;
      } else {
        datasize = 0U;
      }
      if (datasize >= sizeof(smallbuf)) {
        bigbuf = (unsigned char *)cli_malloc(datasize);
        data___0 = bigbuf;
      } else {
        bigbuf = (unsigned char *)((void *)0);
        data___0 = smallbuf;
        datasize = sizeof(smallbuf);
      }
      uptr___0 = decodeLine(m, enctype, line, data___0, datasize);
      if ((unsigned int )uptr___0 == (unsigned int )((void *)0)) {
        if ((unsigned int )data___0 == (unsigned int )bigbuf) {
          free((void *)data___0);
        }
        break;
      }
      if ((unsigned int )uptr___0 != (unsigned int )data___0) {
        ((*addData))(ret, (unsigned char const   *)data___0, (unsigned int )(uptr___0 -
                                                                             data___0));
        size += (unsigned int )(uptr___0 - data___0);
      }
      if ((unsigned int )data___0 == (unsigned int )bigbuf) {
        free((void *)data___0);
      }
      __Cont___1: 
      t_line = (text const   *)t_line->t_next;
      if (! ((unsigned int )t_line != (unsigned int )((void *)0))) {
        break;
      }
    }
    cli_dbgmsg("Exported %u bytes using enctype %d\n", size, enctype);
    if (m->base64chars) {
      cli_dbgmsg("%u trailing bytes to export\n", m->base64chars);
      ptr___0 = decode(m, (char const   *)((void *)0), data___1, & base64___0, (enum __anonenum_bool_35 )0);
      if (ptr___0) {
        ((*addData))(ret, (unsigned char const   *)(data___1), (unsigned int )(ptr___0 -
                                                                               data___1));
      }
      m->base64chars = 0;
    }
    __Cont___0: 
    i ++;
  }
  return (ret);
}
}
fileblob *messageToFileblob(message *m , char const   *dir ) 
{ fileblob *tmp ;

  {
  cli_dbgmsg("messageToFileblob\n");
  tmp = (fileblob *)messageExport(m, dir, (void *(*)(void))((void *)(& fileblobCreate)),
                                  (void (*)(void * ))((void *)(& fileblobDestroy)),
                                  (void (*)(void * , char const   * , char const   * ))((void *)(& fileblobSetFilename)),
                                  (void (*)(void * , unsigned char const   * , size_t  ))((void *)(& fileblobAddData)),
                                  (void *(*)(text const   * , void * ))((void *)(& textToFileblob)));
  return (tmp);
}
}
blob *messageToBlob(message *m ) 
{ blob *tmp ;

  {
  tmp = (blob *)messageExport(m, (char const   *)((void *)0), (void *(*)(void))((void *)(& blobCreate)),
                              (void (*)(void * ))((void *)(& blobDestroy)), (void (*)(void * ,
                                                                                      char const   * ,
                                                                                      char const   * ))((void *)(& blobSetFilename)),
                              (void (*)(void * , unsigned char const   * , size_t  ))((void *)(& blobAddData)),
                              (void *(*)(text const   * , void * ))((void *)(& textToBlob)));
  return (tmp);
}
}
text *messageToText(message *m ) 
{ int i ;
  text *first ;
  text *last ;
  text const   *t_line ;
  encoding_type enctype ;
  text const   *tmp ;
  unsigned char data[1024] ;
  unsigned char *uptr ;
  char const   *line ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___81 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___117 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___136 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  size_t tmp___151 ;
  int tmp___152 ;
  int tmp___153 ;
  int tmp___154 ;
  size_t tmp___155 ;
  size_t tmp___156 ;
  int tmp___157 ;
  size_t tmp___158 ;
  size_t tmp___159 ;
  char *tmp___163 ;
  int tmp___165 ;
  unsigned char data___0[4] ;
  unsigned char *tmp___166 ;

  {
  first = (text *)((void *)0);
  last = (text *)((void *)0);
  if (m->numberOfEncTypes == 0) {
    t_line = messageGetBody((message const   *)m);
    while (t_line) {
      if ((unsigned int )first == (unsigned int )((void *)0)) {
        last = (text *)cli_malloc(sizeof(text ));
        first = last;
      } else {
        last->t_next = (struct text *)cli_malloc(sizeof(text ));
        last = last->t_next;
      }
      if ((unsigned int )last == (unsigned int )((void *)0)) {
        if (first) {
          textDestroy(first);
        }
        return ((text *)((void *)0));
      }
      if (t_line->t_line) {
        last->t_line = lineLink(t_line->t_line);
      } else {
        last->t_line = (line_t *)((void *)0);
      }
      t_line = (text const   *)t_line->t_next;
    }
    if (last) {
      last->t_next = (struct text *)((void *)0);
    }
    return (first);
  }
  i = 0;
  while (i < m->numberOfEncTypes) {
    enctype = (*(m->encodingTypes + i));
    cli_dbgmsg("messageToText: export transfer method %d = %d\n", i, enctype);
    switch ((int )enctype) {
    case 0: ;
    case 4: ;
    case 3: 
    t_line = messageGetBody((message const   *)m);
    while (t_line) {
      if ((unsigned int )first == (unsigned int )((void *)0)) {
        last = (text *)cli_malloc(sizeof(text ));
        first = last;
      } else {
        last->t_next = (struct text *)cli_malloc(sizeof(text ));
        last = last->t_next;
      }
      if ((unsigned int )last == (unsigned int )((void *)0)) {
        if (first) {
          last->t_next = (struct text *)((void *)0);
          textDestroy(first);
        }
        return ((text *)((void *)0));
      }
      if (t_line->t_line) {
        last->t_line = lineLink(t_line->t_line);
      } else {
        last->t_line = (line_t *)((void *)0);
      }
      t_line = (text const   *)t_line->t_next;
    }
    goto __Cont;
    case 5: 
    t_line = uuencodeBegin((message const   *)m);
    if ((unsigned int )t_line == (unsigned int )((void *)0)) {
      if (first) {
        last->t_next = (struct text *)((void *)0);
        textDestroy(first);
      }
      return ((text *)((void *)0));
    }
    t_line = (text const   *)t_line->t_next;
    m->uuencode = (text const   *)((void *)0);
    break;
    case 6: 
    t_line = yEncBegin((message const   *)m);
    if ((unsigned int )t_line == (unsigned int )((void *)0)) {
      if (first) {
        last->t_next = (struct text *)((void *)0);
        textDestroy(first);
      }
      return ((text *)((void *)0));
    }
    t_line = (text const   *)t_line->t_next;
    default: ;
    if (i == 0) {
      tmp = binhexBegin((message const   *)m);
      if (tmp) {
        cli_warnmsg("Binhex messages not supported yet.\n");
      }
    }
    t_line = messageGetBody((message const   *)m);
    }
    while (t_line) {
      tmp___0 = lineGetData((line_t const   *)t_line->t_line);
      line = tmp___0;
      if ((int )enctype == 2) {
        if ((unsigned int )line == (unsigned int )((void *)0)) {
          goto __Cont___0;
        }
      } else {
        if ((int )enctype == 5) {
          tmp___1 = strcasecmp(line, "end");
          if (tmp___1 == 0) {
            break;
          }
        }
      }
      uptr = decodeLine(m, enctype, line, data, sizeof(data));
      if ((unsigned int )uptr == (unsigned int )((void *)0)) {
        break;
      }
      if ((unsigned int )first == (unsigned int )((void *)0)) {
        last = (text *)cli_malloc(sizeof(text ));
        first = last;
      } else {
        last->t_next = (struct text *)cli_malloc(sizeof(text ));
        last = last->t_next;
      }
      if ((unsigned int )last == (unsigned int )((void *)0)) {
        break;
      }
      if ((int )data[0] == 10) {
        last->t_line = (line_t *)((void *)0);
      } else {
        if ((int )data[0] == 0) {
          last->t_line = (line_t *)((void *)0);
        } else {
          if (line) {
            tmp___152 = (int )strlen(line);
            tmp___153 = __builtin_constant_p(tmp___152);
            if (tmp___153) {
              tmp___154 = __builtin_constant_p((int )((char const   *)(data)));
              if (tmp___154) {
                tmp___155 = strlen((char const   *)(data));
                tmp___156 = strlen(line);
                if (tmp___155 < tmp___156) {
                  goto _L___39;
                } else {
                  goto _L___40;
                }
              } else {
                _L___40: 
                tmp___157 = __builtin_constant_p((int )line);
                if (tmp___157) {
                  tmp___158 = strlen(line);
                  tmp___159 = strlen(line);
                  if (tmp___158 < tmp___159) {
                    _L___39: 
                    tmp___148 = __builtin_constant_p((int )((char const   *)(data)));
                    if (tmp___148) {
                      tmp___149 = __builtin_constant_p((int )line);
                      if (tmp___149) {
                        __s1_len___0 = strlen((char const   *)(data));
                        __s2_len___0 = strlen(line);
                        if (! ((unsigned int )((void const   *)((char const   *)(data) +
                                                                1)) - (unsigned int )((void const   *)((char const   *)(data))) ==
                               1U)) {
                          goto _L___36;
                        } else {
                          if (__s1_len___0 >= 4U) {
                            _L___36: 
                            if (! ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                                   1U)) {
                              tmp___150 = 1;
                            } else {
                              if (__s2_len___0 >= 4U) {
                                tmp___150 = 1;
                              } else {
                                tmp___150 = 0;
                              }
                            }
                          } else {
                            tmp___150 = 0;
                          }
                        }
                        if (tmp___150) {
                          tmp___117 = __builtin_strcmp((char const   *)(data), line);
                        } else {
                          goto _L___38;
                        }
                      } else {
                        goto _L___38;
                      }
                    } else {
                      _L___38: 
                      tmp___147 = __builtin_constant_p((int )((char const   *)(data)));
                      if (tmp___147) {
                        if ((unsigned int )((void const   *)((char const   *)(data) +
                                                             1)) - (unsigned int )((void const   *)((char const   *)(data))) ==
                            1U) {
                          __s1_len___0 = strlen((char const   *)(data));
                          if (__s1_len___0 < 4U) {
                            tmp___136 = __builtin_constant_p((int )line);
                            if (tmp___136) {
                              if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                                  1U) {
                                tmp___117 = __builtin_strcmp((char const   *)(data),
                                                             line);
                              } else {
                                goto _L___31;
                              }
                            } else {
                              _L___31: 
                              __s2___14 = (unsigned char const   *)line;
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(data)) +
                                                                      0)) - (int const   )(*(__s2___14 +
                                                                                             0)));
                              if (__s1_len___0 > 0U) {
                                if (__result___42 == 0) {
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(data)) +
                                                                          1)) - (int const   )(*(__s2___14 +
                                                                                                 1)));
                                  if (__s1_len___0 > 1U) {
                                    if (__result___42 == 0) {
                                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(data)) +
                                                                              2)) -
                                                             (int const   )(*(__s2___14 +
                                                                              2)));
                                      if (__s1_len___0 > 2U) {
                                        if (__result___42 == 0) {
                                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(data)) +
                                                                                  3)) -
                                                                 (int const   )(*(__s2___14 +
                                                                                  3)));
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              tmp___117 = __result___42;
                            }
                          } else {
                            goto _L___35;
                          }
                        } else {
                          goto _L___35;
                        }
                      } else {
                        _L___35: 
                        tmp___146 = __builtin_constant_p((int )line);
                        if (tmp___146) {
                          if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                              1U) {
                            __s2_len___0 = strlen(line);
                            if (__s2_len___0 < 4U) {
                              tmp___145 = __builtin_constant_p((int )((char const   *)(data)));
                              if (tmp___145) {
                                if ((unsigned int )((void const   *)((char const   *)(data) +
                                                                     1)) - (unsigned int )((void const   *)((char const   *)(data))) ==
                                    1U) {
                                  tmp___117 = __builtin_strcmp((char const   *)(data),
                                                               line);
                                } else {
                                  goto _L___33;
                                }
                              } else {
                                _L___33: 
                                __s1___30 = (unsigned char const   *)((char const   *)(data));
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        0)) - (int const   )(*((unsigned char const   *)line +
                                                                                               0)));
                                if (__s2_len___0 > 0U) {
                                  if (__result___46 == 0) {
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            1)) -
                                                           (int const   )(*((unsigned char const   *)line +
                                                                            1)));
                                    if (__s2_len___0 > 1U) {
                                      if (__result___46 == 0) {
                                        __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                2)) -
                                                               (int const   )(*((unsigned char const   *)line +
                                                                                2)));
                                        if (__s2_len___0 > 2U) {
                                          if (__result___46 == 0) {
                                            __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                    3)) -
                                                                   (int const   )(*((unsigned char const   *)line +
                                                                                    3)));
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                                tmp___117 = __result___46;
                              }
                            } else {
                              tmp___117 = __builtin_strcmp((char const   *)(data),
                                                           line);
                            }
                          } else {
                            tmp___117 = __builtin_strcmp((char const   *)(data), line);
                          }
                        } else {
                          tmp___117 = __builtin_strcmp((char const   *)(data), line);
                        }
                      }
                    }
                    tmp___81 = tmp___117;
                  } else {
                    tmp___151 = strlen(line);
                    tmp___81 = strncmp((char const   *)(data), line, tmp___151);
                  }
                } else {
                  tmp___151 = strlen(line);
                  tmp___81 = strncmp((char const   *)(data), line, tmp___151);
                }
              }
            } else {
              tmp___151 = strlen(line);
              tmp___81 = strncmp((char const   *)(data), line, tmp___151);
            }
            if (tmp___81 == 0) {
              last->t_line = lineLink(t_line->t_line);
            } else {
              last->t_line = lineCreate((char const   *)((char *)(data)));
            }
          } else {
            last->t_line = lineCreate((char const   *)((char *)(data)));
          }
        }
      }
      if (line) {
        if ((int )enctype == 2) {
          tmp___165 = __builtin_constant_p((int )line);
          if (tmp___165) {
            tmp___163 = (char *)__builtin_strchr(line, '=');
          } else {
            tmp___163 = (char *)__builtin_strchr(line, '=');
          }
          if (tmp___163) {
            break;
          }
        }
      }
      __Cont___0: 
      t_line = (text const   *)t_line->t_next;
    }
    if (m->base64chars) {
      memset((void *)(data___0), '\000', sizeof(data___0));
      tmp___166 = decode(m, (char const   *)((void *)0), data___0, & base64___0, (enum __anonenum_bool_35 )0);
      if (tmp___166) {
        if (data___0[0]) {
          if ((unsigned int )first == (unsigned int )((void *)0)) {
            last = (text *)cli_malloc(sizeof(text ));
            first = last;
          } else {
            last->t_next = (struct text *)cli_malloc(sizeof(text ));
            last = last->t_next;
          }
          if ((unsigned int )last != (unsigned int )((void *)0)) {
            last->t_line = lineCreate((char const   *)((char *)(data___0)));
          }
        }
      }
      m->base64chars = 0;
    }
    __Cont: 
    i ++;
  }
  if (last) {
    last->t_next = (struct text *)((void *)0);
  }
  return (first);
}
}
text const   *uuencodeBegin(message const   *m ) 
{ 

  {
  return (m->uuencode);
}
}
text const   *yEncBegin(message const   *m ) 
{ 

  {
  return (m->yenc);
}
}
text const   *binhexBegin(message const   *m ) 
{ 

  {
  return (m->binhex);
}
}
text const   *bounceBegin(message const   *m ) 
{ 

  {
  return (m->bounce);
}
}
text const   *encodingLine(message const   *m ) 
{ 

  {
  return (m->encoding);
}
}
void messageClearMarkers(message *m ) 
{ 

  {
  m->binhex = (text const   *)((void *)0);
  m->uuencode = m->binhex;
  m->bounce = m->uuencode;
  m->encoding = m->bounce;
  return;
}
}
unsigned char *decodeLine(message *m , encoding_type et , char const   *line , unsigned char *buf ,
                          size_t buflen ) 
{ size_t len ;
  size_t reallen ;
  bool softbreak ;
  char *p2 ;
  char *copy ;
  char base64buf[77] ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char byte ;
  unsigned char *tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  size_t __len___2 ;
  size_t tmp___23 ;
  char *__retval___2 ;
  char *tmp___24 ;
  int tmp___26 ;
  size_t tmp___27 ;
  int tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  char const   *tmp___37 ;
  int tmp___113 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___149 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___168 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___177 ;
  int tmp___178 ;
  int tmp___179 ;
  int tmp___180 ;
  int tmp___181 ;
  int tmp___182 ;
  int tmp___183 ;
  size_t tmp___184 ;
  int tmp___185 ;
  size_t tmp___186 ;
  unsigned char *tmp___187 ;
  char const   *tmp___188 ;
  unsigned char *tmp___189 ;
  char const   *tmp___190 ;

  {
  switch ((int )et) {
  case 4: ;
  case 0: ;
  case 3: ;
  default: ;
  if (line) {
    buf = (unsigned char *)strrcpy((char *)buf, line);
  }
  tmp___0 = (unsigned char *)strrcpy((char *)buf, "\n");
  return (tmp___0);
  case 1: ;
  if ((unsigned int )line == (unsigned int )((void *)0)) {
    tmp___1 = buf;
    buf ++;
    (*tmp___1) = (unsigned char )'\n';
    break;
  }
  softbreak = (enum __anonenum_bool_35 )0;
  while (1) {
    if (buflen) {
      if (! (*line)) {
        break;
      }
    } else {
      break;
    }
    if ((int const   )(*line) == 61) {
      line ++;
      if ((int const   )(*line) == 0) {
        softbreak = (enum __anonenum_bool_35 )1;
        break;
      } else {
        if ((int const   )(*line) == 10) {
          softbreak = (enum __anonenum_bool_35 )1;
          break;
        }
      }
      byte = hex((char )(*line));
      line ++;
      if ((int const   )(*line) == 0) {
        tmp___2 = buf;
        buf ++;
        (*tmp___2) = byte;
        break;
      } else {
        if ((int const   )(*line) == 10) {
          tmp___2 = buf;
          buf ++;
          (*tmp___2) = byte;
          break;
        }
      }
      byte = (unsigned char )((int )byte << 4);
      tmp___3 = hex((char )(*line));
      byte = (unsigned char )((int )byte + (int )tmp___3);
      tmp___4 = buf;
      buf ++;
      (*tmp___4) = byte;
    } else {
      tmp___5 = buf;
      buf ++;
      (*tmp___5) = (unsigned char )(*line);
    }
    line ++;
    buflen --;
  }
  if (! softbreak) {
    tmp___6 = buf;
    buf ++;
    (*tmp___6) = (unsigned char )'\n';
  }
  break;
  case 2: ;
  if ((unsigned int )line == (unsigned int )((void *)0)) {
    break;
  }
  tmp___27 = strlen(line);
  if (tmp___27 < sizeof(base64buf)) {
    strcpy((char * __restrict  )(base64buf), (char const   * __restrict  )line);
    copy = base64buf;
  } else {
    tmp___26 = __builtin_constant_p((int )line);
    if (tmp___26) {
      if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
          1U) {
        if ((int const   )(*(line + 0)) == 0) {
          copy = (char *)calloc(1U, 1U);
        } else {
          tmp___23 = strlen(line);
          __len___2 = tmp___23 + 1U;
          tmp___24 = (char *)malloc(__len___2);
          __retval___2 = tmp___24;
          if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
            __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )line,
                                          __len___2);
          }
          copy = __retval___2;
        }
      } else {
        copy = __strdup(line);
      }
    } else {
      copy = __strdup(line);
    }
    if ((unsigned int )copy == (unsigned int )((void *)0)) {
      break;
    }
  }
  tmp___32 = __builtin_constant_p((int )copy);
  if (tmp___32) {
    p2 = (char *)__builtin_strchr(copy, '=');
  } else {
    p2 = (char *)__builtin_strchr(copy, '=');
  }
  if (p2) {
    (*p2) = (char )'\000';
  }
  sanitiseBase64(copy);
  if ((unsigned int )p2 == (unsigned int )((void *)0)) {
    tmp___33 = strlen((char const   *)copy);
    if ((tmp___33 & 3U) == 0U) {
      tmp___34 = 1;
    } else {
      tmp___34 = 0;
    }
  } else {
    tmp___34 = 0;
  }
  buf = decode(m, (char const   *)copy, buf, & base64___0, (enum __anonenum_bool_35 )tmp___34);
  if ((unsigned int )copy != (unsigned int )(base64buf)) {
    free((void *)copy);
  }
  break;
  case 5: ;
  if ((unsigned int )line == (unsigned int )((void *)0)) {
    break;
  } else {
    if ((int const   )(*line) == 0) {
      break;
    }
  }
  tmp___35 = strcasecmp(line, "end");
  if (tmp___35 == 0) {
    break;
  }
  tmp___36 = isuuencodebegin(line);
  if (tmp___36) {
    break;
  }
  if (((int const   )(*(line + 0)) & 63) == 32) {
    break;
  }
  tmp___37 = line;
  line ++;
  reallen = (size_t )uudecode((char )(*tmp___37));
  if (reallen <= 0U) {
    break;
  }
  if (reallen > 62U) {
    break;
  }
  len = strlen(line);
  if (len > buflen) {
    cli_warnmsg("uudecode: buffer overflow stopped, attempting to ignore but decoding may fail\n");
  } else {
    if (reallen > len) {
      cli_warnmsg("uudecode: buffer overflow stopped, attempting to ignore but decoding may fail\n");
    } else {
      decode(m, line, buf, & uudecode, (enum __anonenum_bool_35 )((len & 3U) == 0U));
      buf = buf + reallen;
    }
  }
  m->base64chars = 0;
  break;
  case 6: ;
  if ((unsigned int )line == (unsigned int )((void *)0)) {
    break;
  } else {
    if ((int const   )(*line) == 0) {
      break;
    }
  }
  tmp___183 = __builtin_constant_p((int )line);
  if (tmp___183) {
    tmp___184 = strlen(line);
    if (tmp___184 < 6U) {
      goto _L___39;
    } else {
      goto _L___40;
    }
  } else {
    _L___40: 
    tmp___185 = __builtin_constant_p((int )"=yend ");
    if (tmp___185) {
      tmp___186 = strlen("=yend ");
      if (tmp___186 < 6U) {
        _L___39: 
        tmp___180 = __builtin_constant_p((int )line);
        if (tmp___180) {
          tmp___181 = __builtin_constant_p((int )"=yend ");
          if (tmp___181) {
            __s1_len___0 = strlen(line);
            __s2_len___0 = strlen("=yend ");
            if (! ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                   1U)) {
              goto _L___36;
            } else {
              if (__s1_len___0 >= 4U) {
                _L___36: 
                if (! ((unsigned int )((void const   *)("=yend " + 1)) - (unsigned int )((void const   *)"=yend ") ==
                       1U)) {
                  tmp___182 = 1;
                } else {
                  if (__s2_len___0 >= 4U) {
                    tmp___182 = 1;
                  } else {
                    tmp___182 = 0;
                  }
                }
              } else {
                tmp___182 = 0;
              }
            }
            if (tmp___182) {
              tmp___149 = __builtin_strcmp(line, "=yend ");
            } else {
              goto _L___38;
            }
          } else {
            goto _L___38;
          }
        } else {
          _L___38: 
          tmp___179 = __builtin_constant_p((int )line);
          if (tmp___179) {
            if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                1U) {
              __s1_len___0 = strlen(line);
              if (__s1_len___0 < 4U) {
                tmp___168 = __builtin_constant_p((int )"=yend ");
                if (tmp___168) {
                  if ((unsigned int )((void const   *)("=yend " + 1)) - (unsigned int )((void const   *)"=yend ") ==
                      1U) {
                    tmp___149 = __builtin_strcmp(line, "=yend ");
                  } else {
                    goto _L___31;
                  }
                } else {
                  _L___31: 
                  __s2___14 = (unsigned char const   *)"=yend ";
                  __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                          0)) - (int const   )(*(__s2___14 +
                                                                                 0)));
                  if (__s1_len___0 > 0U) {
                    if (__result___42 == 0) {
                      __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                              1)) - (int const   )(*(__s2___14 +
                                                                                     1)));
                      if (__s1_len___0 > 1U) {
                        if (__result___42 == 0) {
                          __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                  2)) - (int const   )(*(__s2___14 +
                                                                                         2)));
                          if (__s1_len___0 > 2U) {
                            if (__result___42 == 0) {
                              __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                      3)) - (int const   )(*(__s2___14 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___149 = __result___42;
                }
              } else {
                goto _L___35;
              }
            } else {
              goto _L___35;
            }
          } else {
            _L___35: 
            tmp___178 = __builtin_constant_p((int )"=yend ");
            if (tmp___178) {
              if ((unsigned int )((void const   *)("=yend " + 1)) - (unsigned int )((void const   *)"=yend ") ==
                  1U) {
                __s2_len___0 = strlen("=yend ");
                if (__s2_len___0 < 4U) {
                  tmp___177 = __builtin_constant_p((int )line);
                  if (tmp___177) {
                    if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                        1U) {
                      tmp___149 = __builtin_strcmp(line, "=yend ");
                    } else {
                      goto _L___33;
                    }
                  } else {
                    _L___33: 
                    __s1___30 = (unsigned char const   *)line;
                    __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)"=yend " +
                                                                                               0)));
                    if (__s2_len___0 > 0U) {
                      if (__result___46 == 0) {
                        __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                               (int const   )(*((unsigned char const   *)"=yend " +
                                                                1)));
                        if (__s2_len___0 > 1U) {
                          if (__result___46 == 0) {
                            __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                   (int const   )(*((unsigned char const   *)"=yend " +
                                                                    2)));
                            if (__s2_len___0 > 2U) {
                              if (__result___46 == 0) {
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        3)) - (int const   )(*((unsigned char const   *)"=yend " +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___149 = __result___46;
                  }
                } else {
                  tmp___149 = __builtin_strcmp(line, "=yend ");
                }
              } else {
                tmp___149 = __builtin_strcmp(line, "=yend ");
              }
            } else {
              tmp___149 = __builtin_strcmp(line, "=yend ");
            }
          }
        }
        tmp___113 = tmp___149;
      } else {
        tmp___113 = strncmp(line, "=yend ", 6U);
      }
    } else {
      tmp___113 = strncmp(line, "=yend ", 6U);
    }
  }
  if (tmp___113 == 0) {
    break;
  }
  while ((*line)) {
    if ((int const   )(*line) == 61) {
      line ++;
      if ((int const   )(*line) == 0) {
        break;
      }
      tmp___187 = buf;
      buf ++;
      tmp___188 = line;
      line ++;
      (*tmp___187) = (unsigned char )(((int const   )(*tmp___188) - 64) & 255);
    } else {
      tmp___189 = buf;
      buf ++;
      tmp___190 = line;
      line ++;
      (*tmp___189) = (unsigned char )(((int const   )(*tmp___190) - 42) & 255);
    }
  }
  break;
  }
  (*buf) = (unsigned char )'\000';
  return (buf);
}
}
static void sanitiseBase64(char *s ) 
{ char *p1 ;

  {
  while ((*s)) {
    if ((int const   )base64Table[(unsigned int )((int )(*s) & 255)] == 255) {
      p1 = s;
      while ((int )(*(p1 + 0)) != 0) {
        (*(p1 + 0)) = (*(p1 + 1));
        p1 ++;
      }
    }
    s ++;
  }
  return;
}
}
static unsigned char *decode(message *m , char const   *in , unsigned char *out ,
                             unsigned char (*decoder)(char  ) , bool isFast ) 
{ unsigned char b1 ;
  unsigned char b2 ;
  unsigned char b3 ;
  unsigned char b4 ;
  unsigned char cb1 ;
  unsigned char cb2 ;
  unsigned char cb3 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  unsigned char *tmp___2 ;
  char const   *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  int nbytes ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  int nbytes___0 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char *tmp___21 ;

  {
  cb3 = (unsigned char )'\000';
  cb2 = cb3;
  cb1 = cb2;
  switch (m->base64chars) {
  case 3: 
  cb3 = (unsigned char )m->base64_3;
  case 2: 
  cb2 = (unsigned char )m->base64_2;
  case 1: 
  cb1 = (unsigned char )m->base64_1;
  isFast = (enum __anonenum_bool_35 )0;
  break;
  default: ;
  }
  if (isFast) {
    while ((*in)) {
      tmp = in;
      in ++;
      b1 = ((*decoder))((char )(*tmp));
      tmp___0 = in;
      in ++;
      b2 = ((*decoder))((char )(*tmp___0));
      tmp___1 = in;
      in ++;
      b3 = ((*decoder))((char )(*tmp___1));
      tmp___2 = out;
      out ++;
      (*tmp___2) = (unsigned char )(((int )b1 << 2) | (((int )b2 >> 4) & 3));
      tmp___3 = in;
      in ++;
      b4 = ((*decoder))((char )(*tmp___3));
      tmp___4 = out;
      out ++;
      (*tmp___4) = (unsigned char )(((int )b2 << 4) | (((int )b3 >> 2) & 15));
      tmp___5 = out;
      out ++;
      (*tmp___5) = (unsigned char )(((int )b3 << 6) | ((int )b4 & 63));
    }
  } else {
    if ((unsigned int )in == (unsigned int )((void *)0)) {
      if (m->base64chars == 0) {
        return (out);
      }
      if (cb3) {
        tmp___6 = (int )cb3;
      } else {
        tmp___6 = '@';
      }
      if (cb2) {
        tmp___7 = (int )cb2;
      } else {
        tmp___7 = '@';
      }
      if (cb1) {
        tmp___8 = (int )cb1;
      } else {
        tmp___8 = '@';
      }
      cli_dbgmsg("base64chars = %d (%c %c %c)\n", m->base64chars, tmp___8, tmp___7,
                 tmp___6);
      m->base64chars = m->base64chars - 1;
      b1 = cb1;
      nbytes = 1;
      if (m->base64chars) {
        m->base64chars = m->base64chars - 1;
        b2 = cb2;
        if (m->base64chars) {
          nbytes = 2;
          m->base64chars = m->base64chars - 1;
          b3 = cb3;
          nbytes = 3;
        } else {
          if (b2) {
            nbytes = 2;
          }
        }
      }
      switch (nbytes) {
      case 3: 
      b4 = (unsigned char )'\000';
      case 4: 
      tmp___9 = out;
      out ++;
      (*tmp___9) = (unsigned char )(((int )b1 << 2) | (((int )b2 >> 4) & 3));
      tmp___10 = out;
      out ++;
      (*tmp___10) = (unsigned char )(((int )b2 << 4) | (((int )b3 >> 2) & 15));
      tmp___11 = out;
      out ++;
      (*tmp___11) = (unsigned char )(((int )b3 << 6) | ((int )b4 & 63));
      break;
      case 2: 
      tmp___12 = out;
      out ++;
      (*tmp___12) = (unsigned char )(((int )b1 << 2) | (((int )b2 >> 4) & 3));
      if (((int )b2 << 4) & 255) {
        tmp___13 = out;
        out ++;
        (*tmp___13) = (unsigned char )((int )b2 << 4);
      }
      break;
      case 1: 
      tmp___14 = out;
      out ++;
      (*tmp___14) = (unsigned char )((int )b1 << 2);
      break;
      default: ;
      }
    } else {
      while ((*in)) {
        if (m->base64chars) {
          m->base64chars = m->base64chars - 1;
          b1 = cb1;
        } else {
          tmp___15 = in;
          in ++;
          b1 = ((*decoder))((char )(*tmp___15));
        }
        if ((int const   )(*in) == 0) {
          b2 = (unsigned char )'\000';
          nbytes___0 = 1;
        } else {
          if (m->base64chars) {
            m->base64chars = m->base64chars - 1;
            b2 = cb2;
          } else {
            tmp___16 = in;
            in ++;
            b2 = ((*decoder))((char )(*tmp___16));
          }
          if ((int const   )(*in) == 0) {
            b3 = (unsigned char )'\000';
            nbytes___0 = 2;
          } else {
            if (m->base64chars) {
              m->base64chars = m->base64chars - 1;
              b3 = cb3;
            } else {
              tmp___17 = in;
              in ++;
              b3 = ((*decoder))((char )(*tmp___17));
            }
            if ((int const   )(*in) == 0) {
              b4 = (unsigned char )'\000';
              nbytes___0 = 3;
            } else {
              tmp___18 = in;
              in ++;
              b4 = ((*decoder))((char )(*tmp___18));
              nbytes___0 = 4;
            }
          }
        }
        switch (nbytes___0) {
        case 3: 
        m->base64_3 = (char )b3;
        case 2: 
        m->base64_2 = (char )b2;
        case 1: 
        m->base64_1 = (char )b1;
        break;
        case 4: 
        tmp___19 = out;
        out ++;
        (*tmp___19) = (unsigned char )(((int )b1 << 2) | (((int )b2 >> 4) & 3));
        tmp___20 = out;
        out ++;
        (*tmp___20) = (unsigned char )(((int )b2 << 4) | (((int )b3 >> 2) & 15));
        tmp___21 = out;
        out ++;
        (*tmp___21) = (unsigned char )(((int )b3 << 6) | ((int )b4 & 63));
        break;
        default: ;
        }
        if (nbytes___0 != 4) {
          m->base64chars = nbytes___0;
          break;
        }
      }
    }
  }
  return (out);
}
}
static unsigned char hex(char c ) 
{ unsigned short const   **tmp ;

  {
  tmp = __ctype_b_loc();
  if ((int const   )(*((*tmp) + (int )c)) & 2048) {
    return ((unsigned char )((int )c - 48));
  }
  if ((int )c >= 65) {
    if ((int )c <= 70) {
      return ((unsigned char )(((int )c - 65) + 10));
    }
  }
  if ((int )c >= 97) {
    if ((int )c <= 102) {
      return ((unsigned char )(((int )c - 97) + 10));
    }
  }
  cli_dbgmsg("Illegal hex character \'%c\'\n", c);
  return ((unsigned char )'=');
}
}
static unsigned char base64___0(char c ) 
{ unsigned char ret ;

  {
  ret = (unsigned char )base64Table[(unsigned int )((int )c & 255)];
  if ((int )ret == 255) {
    return ((unsigned char)63);
  }
  return (ret);
}
}
static unsigned char uudecode(char c ) 
{ 

  {
  return ((unsigned char )((int )c - 32));
}
}
static int usefulArg(char const   *arg ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  tmp = strncasecmp(arg, "name", 4U);
  if (tmp != 0) {
    tmp___0 = strncasecmp(arg, "filename", 8U);
    if (tmp___0 != 0) {
      tmp___1 = strncasecmp(arg, "boundary", 8U);
      if (tmp___1 != 0) {
        tmp___2 = strncasecmp(arg, "protocol", 8U);
        if (tmp___2 != 0) {
          tmp___3 = strncasecmp(arg, "id", 2U);
          if (tmp___3 != 0) {
            tmp___4 = strncasecmp(arg, "number", 6U);
            if (tmp___4 != 0) {
              tmp___5 = strncasecmp(arg, "total", 5U);
              if (tmp___5 != 0) {
                tmp___6 = strncasecmp(arg, "type", 4U);
                if (tmp___6 != 0) {
                  cli_dbgmsg("Discarding unwanted argument \'%s\'\n", arg);
                  return (0);
                }
              }
            }
          }
        }
      }
    }
  }
  return (1);
}
}
static void messageDedup(message *m ) 
{ text const   *t1 ;
  size_t saved ;
  char const   *d1 ;
  text *t2 ;
  line_t *l1 ;
  unsigned int r1 ;
  size_t tmp ;
  char const   *d2 ;
  line_t *l2 ;
  size_t tmp___1 ;
  line_t *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___38 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___57 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;

  {
  saved = 0U;
  cli_dbgmsg("messageDedup\n");
  if (m->dedupedThisFar) {
    t1 = m->dedupedThisFar;
  } else {
    t1 = (text const   *)m->body_first;
  }
  t1 = (text const   *)m->body_first;
  while (t1) {
    if (saved >= 100000U) {
      break;
    }
    l1 = t1->t_line;
    if ((unsigned int )l1 == (unsigned int )((void *)0)) {
      goto __Cont;
    }
    d1 = lineGetData((line_t const   *)l1);
    tmp = strlen(d1);
    if (tmp < 8U) {
      goto __Cont;
    }
    r1 = (unsigned int )lineGetRefCount((line_t const   *)l1);
    if (r1 == 255U) {
      goto __Cont;
    }
    if ((unsigned int )t1 == (unsigned int )m->encoding) {
      goto __Cont;
    }
    if ((unsigned int )t1 == (unsigned int )m->bounce) {
      goto __Cont;
    }
    if ((unsigned int )t1 == (unsigned int )m->uuencode) {
      goto __Cont;
    }
    if ((unsigned int )t1 == (unsigned int )m->binhex) {
      goto __Cont;
    }
    if ((unsigned int )t1 == (unsigned int )m->yenc) {
      goto __Cont;
    }
    t2 = t1->t_next;
    while (t2) {
      l2 = t2->t_line;
      if ((unsigned int )l2 == (unsigned int )((void *)0)) {
        goto __Cont___0;
      }
      d2 = lineGetData((line_t const   *)l2);
      if ((unsigned int )d1 == (unsigned int )d2) {
        goto __Cont___0;
      }
      tmp___69 = __builtin_constant_p((int )d1);
      if (tmp___69) {
        tmp___70 = __builtin_constant_p((int )d2);
        if (tmp___70) {
          __s1_len = strlen(d1);
          __s2_len = strlen(d2);
          if (! ((unsigned int )((void const   *)(d1 + 1)) - (unsigned int )((void const   *)d1) ==
                 1U)) {
            goto _L___16;
          } else {
            if (__s1_len >= 4U) {
              _L___16: 
              if (! ((unsigned int )((void const   *)(d2 + 1)) - (unsigned int )((void const   *)d2) ==
                     1U)) {
                tmp___71 = 1;
              } else {
                if (__s2_len >= 4U) {
                  tmp___71 = 1;
                } else {
                  tmp___71 = 0;
                }
              }
            } else {
              tmp___71 = 0;
            }
          }
          if (tmp___71) {
            tmp___38 = __builtin_strcmp(d1, d2);
          } else {
            goto _L___18;
          }
        } else {
          goto _L___18;
        }
      } else {
        _L___18: 
        tmp___68 = __builtin_constant_p((int )d1);
        if (tmp___68) {
          if ((unsigned int )((void const   *)(d1 + 1)) - (unsigned int )((void const   *)d1) ==
              1U) {
            __s1_len = strlen(d1);
            if (__s1_len < 4U) {
              tmp___57 = __builtin_constant_p((int )d2);
              if (tmp___57) {
                if ((unsigned int )((void const   *)(d2 + 1)) - (unsigned int )((void const   *)d2) ==
                    1U) {
                  tmp___38 = __builtin_strcmp(d1, d2);
                } else {
                  goto _L___11;
                }
              } else {
                _L___11: 
                __s2___6 = (unsigned char const   *)d2;
                __result___18 = (int )((int const   )(*((unsigned char const   *)d1 +
                                                        0)) - (int const   )(*(__s2___6 +
                                                                               0)));
                if (__s1_len > 0U) {
                  if (__result___18 == 0) {
                    __result___18 = (int )((int const   )(*((unsigned char const   *)d1 +
                                                            1)) - (int const   )(*(__s2___6 +
                                                                                   1)));
                    if (__s1_len > 1U) {
                      if (__result___18 == 0) {
                        __result___18 = (int )((int const   )(*((unsigned char const   *)d1 +
                                                                2)) - (int const   )(*(__s2___6 +
                                                                                       2)));
                        if (__s1_len > 2U) {
                          if (__result___18 == 0) {
                            __result___18 = (int )((int const   )(*((unsigned char const   *)d1 +
                                                                    3)) - (int const   )(*(__s2___6 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___38 = __result___18;
              }
            } else {
              goto _L___15;
            }
          } else {
            goto _L___15;
          }
        } else {
          _L___15: 
          tmp___67 = __builtin_constant_p((int )d2);
          if (tmp___67) {
            if ((unsigned int )((void const   *)(d2 + 1)) - (unsigned int )((void const   *)d2) ==
                1U) {
              __s2_len = strlen(d2);
              if (__s2_len < 4U) {
                tmp___66 = __builtin_constant_p((int )d1);
                if (tmp___66) {
                  if ((unsigned int )((void const   *)(d1 + 1)) - (unsigned int )((void const   *)d1) ==
                      1U) {
                    tmp___38 = __builtin_strcmp(d1, d2);
                  } else {
                    goto _L___13;
                  }
                } else {
                  _L___13: 
                  __s1___14 = (unsigned char const   *)d1;
                  __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)d2 +
                                                                                             0)));
                  if (__s2_len > 0U) {
                    if (__result___22 == 0) {
                      __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)d2 +
                                                                                                 1)));
                      if (__s2_len > 1U) {
                        if (__result___22 == 0) {
                          __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                 (int const   )(*((unsigned char const   *)d2 +
                                                                  2)));
                          if (__s2_len > 2U) {
                            if (__result___22 == 0) {
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      3)) - (int const   )(*((unsigned char const   *)d2 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___38 = __result___22;
                }
              } else {
                tmp___38 = __builtin_strcmp(d1, d2);
              }
            } else {
              tmp___38 = __builtin_strcmp(d1, d2);
            }
          } else {
            tmp___38 = __builtin_strcmp(d1, d2);
          }
        }
      }
      if (tmp___38 == 0) {
        tmp___2 = lineUnlink(l2);
        if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
          tmp___1 = strlen(d1);
          saved += tmp___1 + 1U;
        }
        t2->t_line = lineLink(l1);
        if ((unsigned int )t2->t_line == (unsigned int )((void *)0)) {
          cli_errmsg("messageDedup: out of memory\n");
          return;
        }
        r1 ++;
        if (r1 == 255U) {
          break;
        }
      }
      __Cont___0: 
      t2 = t2->t_next;
    }
    __Cont: 
    t1 = (text const   *)t1->t_next;
  }
  cli_dbgmsg("messageDedup reclaimed %u bytes\n", saved);
  m->dedupedThisFar = t1;
  return;
}
}
static char *rfc2231(char const   *in ) 
{ char const   *ptr ;
  char *ret ;
  char *out ;
  enum __anonenum_field_35 field ;
  char *tmp___10 ;
  size_t __len___2 ;
  size_t tmp___16 ;
  char *__retval___2 ;
  char *tmp___17 ;
  int tmp___19 ;
  size_t tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  unsigned char byte ;
  char *tmp___23 ;
  unsigned char tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char const   *tmp___27 ;
  char *tmp___39 ;
  size_t __len___6 ;
  size_t tmp___45 ;
  char *__retval___6 ;
  char *tmp___46 ;
  int tmp___48 ;

  {
  field = (enum __anonenum_field_35 )0;
  ptr = strstr(in, "*=");
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
    tmp___19 = __builtin_constant_p((int )in);
    if (tmp___19) {
      if ((unsigned int )((void const   *)(in + 1)) - (unsigned int )((void const   *)in) ==
          1U) {
        if ((int const   )(*(in + 0)) == 0) {
          tmp___10 = (char *)calloc(1U, 1U);
        } else {
          tmp___16 = strlen(in);
          __len___2 = tmp___16 + 1U;
          tmp___17 = (char *)malloc(__len___2);
          __retval___2 = tmp___17;
          if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
            __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )in,
                                          __len___2);
          }
          tmp___10 = __retval___2;
        }
      } else {
        tmp___10 = __strdup(in);
      }
    } else {
      tmp___10 = __strdup(in);
    }
    return (tmp___10);
  }
  cli_dbgmsg("rfc2231 \'%s\'\n", in);
  tmp___20 = strlen(in);
  ret = (char *)cli_malloc(tmp___20 + 1U);
  if ((unsigned int )ret == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  }
  out = ret;
  while ((unsigned int )in != (unsigned int )ptr) {
    tmp___21 = out;
    out ++;
    (*tmp___21) = (char )(*in);
    in ++;
  }
  tmp___22 = out;
  out ++;
  (*tmp___22) = (char )'=';
  while ((*in)) {
    switch ((int )field) {
    case 0: ;
    if ((int const   )(*in) == 39) {
      field = (enum __anonenum_field_35 )1;
    }
    break;
    case 1: ;
    if ((int const   )(*in) == 39) {
      field = (enum __anonenum_field_35 )2;
    }
    break;
    case 2: ;
    if ((int const   )(*in) == 37) {
      in ++;
      if ((int const   )(*in) == 0) {
        break;
      } else {
        if ((int const   )(*in) == 10) {
          break;
        }
      }
      byte = hex((char )(*in));
      in ++;
      if ((int const   )(*in) == 0) {
        tmp___23 = out;
        out ++;
        (*tmp___23) = (char )byte;
        break;
      } else {
        if ((int const   )(*in) == 10) {
          tmp___23 = out;
          out ++;
          (*tmp___23) = (char )byte;
          break;
        }
      }
      byte = (unsigned char )((int )byte << 4);
      tmp___24 = hex((char )(*in));
      byte = (unsigned char )((int )byte + (int )tmp___24);
      tmp___25 = out;
      out ++;
      (*tmp___25) = (char )byte;
    } else {
      tmp___26 = out;
      out ++;
      (*tmp___26) = (char )(*in);
    }
    }
    tmp___27 = in;
    in ++;
    if ((int const   )(*tmp___27) == 0) {
      break;
    }
  }
  if ((int )field != 2) {
    free((void *)ret);
    cli_warnmsg("Invalid RFC2231 header: \'%s\'\n", in);
    tmp___48 = __builtin_constant_p((int )"");
    if (tmp___48) {
      if ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") ==
          1U) {
        if ((int const   )(*("" + 0)) == 0) {
          tmp___39 = (char *)calloc(1U, 1U);
        } else {
          tmp___45 = strlen("");
          __len___6 = tmp___45 + 1U;
          tmp___46 = (char *)malloc(__len___6);
          __retval___6 = tmp___46;
          if ((unsigned int )__retval___6 != (unsigned int )((void *)0)) {
            __retval___6 = (char *)memcpy((void * __restrict  )__retval___6, (void const   * __restrict  )"",
                                          __len___6);
          }
          tmp___39 = __retval___6;
        }
      } else {
        tmp___39 = __strdup("");
      }
    } else {
      tmp___39 = __strdup("");
    }
    return (tmp___39);
  }
  (*out) = (char )'\000';
  cli_dbgmsg("rfc2231 returns \'%s\'\n", ret);
  return (ret);
}
}
static int push(LINK1 *top , char const   *string ) ;
static int pop(LINK1 *top , char *buffer ) ;
static unsigned int compare(char *ls1 , char **rs1 , char *ls2 , char **rs2 ) ;
static int simil(char const   *str1 , char const   *str2 ) 
{ LINK1 top ;
  unsigned int score ;
  unsigned int common ;
  unsigned int total ;
  unsigned int len1 ;
  unsigned int len2 ;
  char ls1[50] ;
  char ls2[50] ;
  char *rs1 ;
  char *rs2 ;
  char *s1 ;
  char *s2 ;
  int tmp ;
  size_t __len___2 ;
  size_t tmp___16 ;
  char *__retval___2 ;
  char *tmp___17 ;
  int tmp___19 ;
  size_t __len___6 ;
  size_t tmp___36 ;
  char *__retval___6 ;
  char *tmp___37 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  unsigned int tmp___47 ;

  {
  top = (ELEMENT1 *)((void *)0);
  score = 0U;
  rs1 = (char *)((void *)0);
  rs2 = (char *)((void *)0);
  tmp = strcasecmp(str1, str2);
  if (tmp == 0) {
    return (100);
  }
  tmp___19 = __builtin_constant_p((int )str1);
  if (tmp___19) {
    if ((unsigned int )((void const   *)(str1 + 1)) - (unsigned int )((void const   *)str1) ==
        1U) {
      if ((int const   )(*(str1 + 0)) == 0) {
        s1 = (char *)calloc(1U, 1U);
      } else {
        tmp___16 = strlen(str1);
        __len___2 = tmp___16 + 1U;
        tmp___17 = (char *)malloc(__len___2);
        __retval___2 = tmp___17;
        if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
          __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )str1,
                                        __len___2);
        }
        s1 = __retval___2;
      }
    } else {
      s1 = __strdup(str1);
    }
  } else {
    s1 = __strdup(str1);
  }
  if ((unsigned int )s1 == (unsigned int )((void *)0)) {
    return (-2);
  }
  tmp___39 = __builtin_constant_p((int )str2);
  if (tmp___39) {
    if ((unsigned int )((void const   *)(str2 + 1)) - (unsigned int )((void const   *)str2) ==
        1U) {
      if ((int const   )(*(str2 + 0)) == 0) {
        s2 = (char *)calloc(1U, 1U);
      } else {
        tmp___36 = strlen(str2);
        __len___6 = tmp___36 + 1U;
        tmp___37 = (char *)malloc(__len___6);
        __retval___6 = tmp___37;
        if ((unsigned int )__retval___6 != (unsigned int )((void *)0)) {
          __retval___6 = (char *)memcpy((void * __restrict  )__retval___6, (void const   * __restrict  )str2,
                                        __len___6);
        }
        s2 = __retval___6;
      }
    } else {
      s2 = __strdup(str2);
    }
  } else {
    s2 = __strdup(str2);
  }
  if ((unsigned int )s2 == (unsigned int )((void *)0)) {
    free((void *)s1);
    return (-2);
  }
  total = strstrip(s1);
  if (total > 49U) {
    free((void *)s1);
    free((void *)s2);
    return (-5);
  } else {
    len2 = strstrip(s2);
    if (len2 > 49U) {
      free((void *)s1);
      free((void *)s2);
      return (-5);
    }
  }
  total += len2;
  tmp___40 = push(& top, (char const   *)s1);
  if (tmp___40 == -2) {
    free((void *)s1);
    free((void *)s2);
    return (-2);
  } else {
    tmp___41 = push(& top, (char const   *)s2);
    if (tmp___41 == -2) {
      free((void *)s1);
      free((void *)s2);
      return (-2);
    }
  }
  while (1) {
    tmp___46 = pop(& top, ls2);
    if (! (tmp___46 == -4)) {
      break;
    }
    pop(& top, ls1);
    common = compare(ls1, & rs1, ls2, & rs2);
    if (common > 0U) {
      score += common;
      len1 = strlen((char const   *)(ls1));
      len2 = strlen((char const   *)(ls2));
      if (len1 > 1U) {
        if (len2 >= 1U) {
          goto _L;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
        if (len2 > 1U) {
          if (len1 >= 1U) {
            _L: 
            tmp___42 = push(& top, (char const   *)(ls1));
            if (tmp___42 == -2) {
              free((void *)s1);
              free((void *)s2);
              return (-2);
            } else {
              tmp___43 = push(& top, (char const   *)(ls2));
              if (tmp___43 == -2) {
                free((void *)s1);
                free((void *)s2);
                return (-2);
              }
            }
          }
        }
      }
      len1 = strlen((char const   *)rs1);
      len2 = strlen((char const   *)rs2);
      if (len1 > 1U) {
        if (len2 >= 1U) {
          goto _L___1;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: 
        if (len2 > 1U) {
          if (len1 >= 1U) {
            _L___1: 
            tmp___44 = push(& top, (char const   *)rs1);
            if (tmp___44 == -2) {
              free((void *)s1);
              free((void *)s2);
              return (-2);
            } else {
              tmp___45 = push(& top, (char const   *)rs2);
              if (tmp___45 == -2) {
                free((void *)s1);
                free((void *)s2);
                return (-2);
              }
            }
          }
        }
      }
    }
  }
  free((void *)s1);
  free((void *)s2);
  if (total > 0U) {
    tmp___47 = (score * 200U) / total;
  } else {
    tmp___47 = 0U;
  }
  return ((int )tmp___47);
}
}
static unsigned int compare(char *ls1 , char **rs1 , char *ls2 , char **rs2 ) 
{ unsigned int common ;
  unsigned int diff ;
  unsigned int maxchars ;
  bool some_similarity ;
  char *s1 ;
  char *s2 ;
  char *maxs1 ;
  char *maxs2 ;
  char *maxe1 ;
  char *maxe2 ;
  char *cs1 ;
  char *cs2 ;
  char *start1 ;
  char *end1 ;
  char *end2 ;
  size_t tmp ;
  size_t tmp___0 ;
  int __res ;
  int __c ;
  __int32_t const   **tmp___2 ;
  int tmp___3 ;
  __int32_t const   **tmp___4 ;
  int __res___0 ;
  int __c___0 ;
  __int32_t const   **tmp___6 ;
  int tmp___7 ;
  __int32_t const   **tmp___8 ;
  int __res___1 ;
  int __c___1 ;
  __int32_t const   **tmp___10 ;
  int tmp___11 ;
  __int32_t const   **tmp___12 ;
  int __res___2 ;
  int __c___2 ;
  __int32_t const   **tmp___14 ;
  int tmp___15 ;
  __int32_t const   **tmp___16 ;

  {
  maxchars = 0U;
  some_similarity = (enum __anonenum_bool_35 )0;
  maxs1 = (char *)((void *)0);
  maxs2 = (char *)((void *)0);
  maxe1 = (char *)((void *)0);
  maxe2 = (char *)((void *)0);
  tmp = strlen((char const   *)ls1);
  end1 = ls1 + tmp;
  tmp___0 = strlen((char const   *)ls2);
  end2 = ls2 + tmp___0;
  start1 = ls1;
  while (1) {
    s1 = start1;
    s2 = ls2;
    if ((unsigned int )s1 < (unsigned int )end1) {
      while (1) {
        if ((unsigned int )s1 < (unsigned int )end1) {
          if (! ((unsigned int )s2 < (unsigned int )end2)) {
            break;
          }
        } else {
          break;
        }
        if (sizeof((*s1)) > 1U) {
          tmp___11 = __builtin_constant_p((int )(*s1));
          if (tmp___11) {
            __c___1 = (int )(*s1);
            if (__c___1 < -128) {
              __res___1 = __c___1;
            } else {
              if (__c___1 > 255) {
                __res___1 = __c___1;
              } else {
                tmp___10 = __ctype_tolower_loc();
                __res___1 = (*((*tmp___10) + __c___1));
              }
            }
          } else {
            __res___1 = tolower__extinline((int )(*s1));
          }
        } else {
          tmp___12 = __ctype_tolower_loc();
          __res___1 = (*((*tmp___12) + (int )(*s1)));
        }
        if (sizeof((*s2)) > 1U) {
          tmp___15 = __builtin_constant_p((int )(*s2));
          if (tmp___15) {
            __c___2 = (int )(*s2);
            if (__c___2 < -128) {
              __res___2 = __c___2;
            } else {
              if (__c___2 > 255) {
                __res___2 = __c___2;
              } else {
                tmp___14 = __ctype_tolower_loc();
                __res___2 = (*((*tmp___14) + __c___2));
              }
            }
          } else {
            __res___2 = tolower__extinline((int )(*s2));
          }
        } else {
          tmp___16 = __ctype_tolower_loc();
          __res___2 = (*((*tmp___16) + (int )(*s2)));
        }
        if (__res___1 == __res___2) {
          some_similarity = (enum __anonenum_bool_35 )1;
          cs1 = s1;
          cs2 = s2;
          common = 0U;
          while (1) {
            if ((unsigned int )s1 == (unsigned int )end1) {
              break;
            } else {
              if ((unsigned int )s2 == (unsigned int )end2) {
                break;
              } else {
                s1 ++;
                s2 ++;
                common ++;
              }
            }
            if (sizeof((*s1)) > 1U) {
              tmp___3 = __builtin_constant_p((int )(*s1));
              if (tmp___3) {
                __c = (int )(*s1);
                if (__c < -128) {
                  __res = __c;
                } else {
                  if (__c > 255) {
                    __res = __c;
                  } else {
                    tmp___2 = __ctype_tolower_loc();
                    __res = (*((*tmp___2) + __c));
                  }
                }
              } else {
                __res = tolower__extinline((int )(*s1));
              }
            } else {
              tmp___4 = __ctype_tolower_loc();
              __res = (*((*tmp___4) + (int )(*s1)));
            }
            if (sizeof((*s2)) > 1U) {
              tmp___7 = __builtin_constant_p((int )(*s2));
              if (tmp___7) {
                __c___0 = (int )(*s2);
                if (__c___0 < -128) {
                  __res___0 = __c___0;
                } else {
                  if (__c___0 > 255) {
                    __res___0 = __c___0;
                  } else {
                    tmp___6 = __ctype_tolower_loc();
                    __res___0 = (*((*tmp___6) + __c___0));
                  }
                }
              } else {
                __res___0 = tolower__extinline((int )(*s2));
              }
            } else {
              tmp___8 = __ctype_tolower_loc();
              __res___0 = (*((*tmp___8) + (int )(*s2)));
            }
            if (! (__res == __res___0)) {
              break;
            }
          }
          if (common > maxchars) {
            diff = common - maxchars;
            maxchars = common;
            maxs1 = cs1;
            maxs2 = cs2;
            maxe1 = s1;
            maxe2 = s2;
            end1 -= diff;
            end2 -= diff;
          } else {
            s1 -= common;
          }
        } else {
          s2 ++;
        }
      }
      start1 ++;
    } else {
      break;
    }
  }
  if (some_similarity) {
    (*maxs1) = (char )'\000';
    (*maxs2) = (char )'\000';
    (*rs1) = maxe1;
    (*rs2) = maxe2;
  }
  return (maxchars);
}
}
static int push(LINK1 *top , char const   *string ) 
{ LINK1 element ;
  size_t __len___2 ;
  size_t tmp___16 ;
  char *__retval___2 ;
  char *tmp___17 ;
  int tmp___19 ;

  {
  element = (LINK1 )cli_malloc(sizeof(ELEMENT1 ));
  if ((unsigned int )element == (unsigned int )((void *)0)) {
    return (-2);
  }
  tmp___19 = __builtin_constant_p((int )string);
  if (tmp___19) {
    if ((unsigned int )((void const   *)(string + 1)) - (unsigned int )((void const   *)string) ==
        1U) {
      if ((int const   )(*(string + 0)) == 0) {
        element->d1 = (char *)calloc(1U, 1U);
      } else {
        tmp___16 = strlen(string);
        __len___2 = tmp___16 + 1U;
        tmp___17 = (char *)malloc(__len___2);
        __retval___2 = tmp___17;
        if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
          __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )string,
                                        __len___2);
        }
        element->d1 = __retval___2;
      }
    } else {
      element->d1 = __strdup(string);
    }
  } else {
    element->d1 = __strdup(string);
  }
  if ((unsigned int )element->d1 == (unsigned int )((void *)0)) {
    return (-2);
  }
  element->next = (*top);
  (*top) = element;
  return (-4);
}
}
static int pop(LINK1 *top , char *buffer ) 
{ LINK1 t1 ;

  {
  t1 = (*top);
  if ((unsigned int )t1 != (unsigned int )((void *)0)) {
    strcpy((char * __restrict  )buffer, (char const   * __restrict  )t1->d1);
    (*top) = t1->next;
    free((void *)t1->d1);
    free((void *)((char *)t1));
    return (-4);
  }
  return (-3);
}
}
int isuuencodebegin(char const   *line ) 
{ size_t tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;

  {
  tmp = strlen(line);
  if (tmp < 10U) {
    return (0);
  }
  tmp___0 = strncasecmp(line, "begin ", 6U);
  if (tmp___0 == 0) {
    tmp___1 = __ctype_b_loc();
    if ((int const   )(*((*tmp___1) + (int )(*(line + 6)))) & 2048) {
      tmp___2 = __ctype_b_loc();
      if ((int const   )(*((*tmp___2) + (int )(*(line + 7)))) & 2048) {
        tmp___3 = __ctype_b_loc();
        if ((int const   )(*((*tmp___3) + (int )(*(line + 8)))) & 2048) {
          if ((int const   )(*(line + 9)) == 32) {
            tmp___4 = 1;
          } else {
            tmp___4 = 0;
          }
        } else {
          tmp___4 = 0;
        }
      } else {
        tmp___4 = 0;
      }
    } else {
      tmp___4 = 0;
    }
  } else {
    tmp___4 = 0;
  }
  return (tmp___4);
}
}
#pragma merger(0,"/tmp/cil-3A0NzwFK.i","-g -O2 -fPIC")
#pragma merger(0,"/tmp/cil-t2DS1Ab2.i","-g -O2 -fPIC")
char *strrcpy(char *dest , char const   *source ) 
{ char *tmp ;
  char const   *tmp___0 ;

  {
  while (1) {
    tmp = dest;
    dest ++;
    tmp___0 = source;
    source ++;
    (*tmp) = (char )(*tmp___0);
    if (! (*tmp)) {
      break;
    }
  }
  dest --;
  return (dest);
}
}
#pragma merger(0,"/tmp/cil-SAOcHnzS.i","-g -O2 -fPIC")
struct table *tableCreate(void) 
{ struct table *tmp ;

  {
  tmp = (struct table *)cli_calloc(1U, sizeof(struct table ));
  return (tmp);
}
}
void tableDestroy(table_t *table ) 
{ tableEntry *tableItem ;
  tableEntry *tableNext ;

  {
  tableItem = table->tableHead;
  while (tableItem) {
    tableNext = tableItem->next;
    free((void *)tableItem->key);
    free((void *)tableItem);
    tableItem = tableNext;
  }
  free((void *)table);
  return;
}
}
int tableInsert(table_t *table , char const   *key , int value ) 
{ int v ;
  int tmp ;
  int tmp___0 ;
  size_t __len___2 ;
  size_t tmp___19 ;
  char *__retval___2 ;
  char *tmp___20 ;
  int tmp___22 ;

  {
  tmp = tableFind((table_t const   *)table, key);
  v = tmp;
  if (v > 0) {
    if (v == value) {
      tmp___0 = value;
    } else {
      tmp___0 = -1;
    }
    return (tmp___0);
  }
  if ((unsigned int )table->tableHead == (unsigned int )((void *)0)) {
    table->tableHead = (tableEntry *)cli_malloc(sizeof(tableEntry ));
    table->tableLast = table->tableHead;
  } else {
    (table->tableLast)->next = (struct tableEntry *)cli_malloc(sizeof(tableEntry ));
    table->tableLast = (table->tableLast)->next;
  }
  if ((unsigned int )table->tableLast == (unsigned int )((void *)0)) {
    return (-1);
  }
  (table->tableLast)->next = (struct tableEntry *)((void *)0);
  tmp___22 = __builtin_constant_p((int )key);
  if (tmp___22) {
    if ((unsigned int )((void const   *)(key + 1)) - (unsigned int )((void const   *)key) ==
        1U) {
      if ((int const   )(*(key + 0)) == 0) {
        (table->tableLast)->key = (char *)calloc(1U, 1U);
      } else {
        tmp___19 = strlen(key);
        __len___2 = tmp___19 + 1U;
        tmp___20 = (char *)malloc(__len___2);
        __retval___2 = tmp___20;
        if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
          __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )key,
                                        __len___2);
        }
        (table->tableLast)->key = __retval___2;
      }
    } else {
      (table->tableLast)->key = __strdup(key);
    }
  } else {
    (table->tableLast)->key = __strdup(key);
  }
  (table->tableLast)->value = value;
  return (value);
}
}
int tableFind(table_t const   *table , char const   *key ) 
{ tableEntry const   *tableItem ;
  int tmp ;

  {
  if ((unsigned int )key == (unsigned int )((void *)0)) {
    return (-1);
  }
  if ((unsigned int )table->tableHead == (unsigned int )((void *)0)) {
    return (-1);
  }
  tableItem = (tableEntry const   *)table->tableHead;
  while (tableItem) {
    tmp = strcasecmp((char const   *)tableItem->key, key);
    if (tmp == 0) {
      return (tableItem->value);
    }
    tableItem = (tableEntry const   *)tableItem->next;
  }
  return (-1);
}
}
#pragma merger(0,"/tmp/cil-GtvuSWqF.i","-g -O2 -fPIC")
static text *textCopy(text const   *t_head ) ;
static void addToFileblob(line_t const   *line , void *arg ) ;
static void getLength(line_t const   *line , void *arg ) ;
static void addToBlob(line_t const   *line , void *arg ) ;
static void *textIterate(text const   *t_text , void (*cb)(line_t const   *item ,
                                                           void *arg ) , void *arg ) ;
void textDestroy(text *t_head ) 
{ text *t_next ;

  {
  while (t_head) {
    t_next = t_head->t_next;
    if (t_head->t_line) {
      lineUnlink(t_head->t_line);
    }
    free((void *)t_head);
    t_head = t_next;
  }
  return;
}
}
text *textClean(text *t_head ) 
{ 

  {
  return (t_head);
}
}
static text *textCopy(text const   *t_head ) 
{ text *first ;
  text *last ;

  {
  first = (text *)((void *)0);
  last = (text *)((void *)0);
  while (t_head) {
    if ((unsigned int )first == (unsigned int )((void *)0)) {
      first = (text *)cli_malloc(sizeof(text ));
      last = first;
    } else {
      last->t_next = (struct text *)cli_malloc(sizeof(text ));
      last = last->t_next;
    }
    if ((unsigned int )last == (unsigned int )((void *)0)) {
      if (first) {
        textDestroy(first);
      }
      return ((text *)((void *)0));
    }
    if (t_head->t_line) {
      last->t_line = lineLink(t_head->t_line);
    } else {
      last->t_line = (line_t *)((void *)0);
    }
    t_head = (text const   *)t_head->t_next;
  }
  if (first) {
    last->t_next = (struct text *)((void *)0);
  }
  return (first);
}
}
text *textAdd(text *t_head , text const   *t ) 
{ text *ret ;
  int count ;
  text *tmp ;

  {
  if ((unsigned int )t_head == (unsigned int )((void *)0)) {
    tmp = textCopy(t);
    return (tmp);
  }
  if ((unsigned int )t == (unsigned int )((void *)0)) {
    return (t_head);
  }
  ret = t_head;
  count = 0;
  while (t_head->t_next) {
    count ++;
    t_head = t_head->t_next;
  }
  cli_dbgmsg("textAdd: count = %d\n", count);
  while (t) {
    t_head->t_next = (struct text *)cli_malloc(sizeof(text ));
    t_head = t_head->t_next;
    if (t->t_line) {
      t_head->t_line = lineLink(t->t_line);
    } else {
      t_head->t_line = (line_t *)((void *)0);
    }
    t = (text const   *)t->t_next;
  }
  t_head->t_next = (struct text *)((void *)0);
  return (ret);
}
}
text *textAddMessage(text *aText , message *aMessage ) 
{ text const   *tmp ;
  text *tmp___0 ;
  text *anotherText ;
  text *tmp___1 ;
  encoding_type tmp___2 ;

  {
  tmp___2 = messageGetEncoding((message const   *)aMessage);
  if ((int )tmp___2 == 0) {
    tmp = messageGetBody((message const   *)aMessage);
    tmp___0 = textAdd(aText, tmp);
    return (tmp___0);
  } else {
    tmp___1 = messageToText(aMessage);
    anotherText = tmp___1;
    if (aText) {
      aText = textAdd(aText, (text const   *)anotherText);
      textDestroy(anotherText);
      return (aText);
    }
    return (anotherText);
  }
}
}
blob *textToBlob(text const   *t , blob *b ) 
{ size_t s ;

  {
  if ((unsigned int )t == (unsigned int )((void *)0)) {
    return ((blob *)((void *)0));
  }
  s = 0U;
  textIterate(t, & getLength, (void *)(& s));
  if (s == 0U) {
    return (b);
  }
  if ((unsigned int )b == (unsigned int )((void *)0)) {
    b = blobCreate();
    if ((unsigned int )b == (unsigned int )((void *)0)) {
      return ((blob *)((void *)0));
    }
  }
  blobGrow(b, s);
  textIterate(t, & addToBlob, (void *)b);
  blobClose(b);
  return (b);
}
}
fileblob *textToFileblob(text const   *t , fileblob *fb ) 
{ fileblob *tmp ;

  {
  if ((unsigned int )fb == (unsigned int )((void *)0)) {
    fb = fileblobCreate();
    if ((unsigned int )fb == (unsigned int )((void *)0)) {
      return ((fileblob *)((void *)0));
    }
  }
  tmp = (fileblob *)textIterate(t, & addToFileblob, (void *)fb);
  return (tmp);
}
}
static void getLength(line_t const   *line , void *arg ) 
{ size_t *length ;
  char const   *tmp ;
  size_t tmp___0 ;

  {
  length = (size_t *)arg;
  if (line) {
    tmp = lineGetData(line);
    tmp___0 = strlen(tmp);
    (*length) += tmp___0 + 1U;
  } else {
    (*length) ++;
  }
  return;
}
}
static void addToBlob(line_t const   *line , void *arg ) 
{ blob *b ;
  char const   *l ;
  char const   *tmp ;
  size_t tmp___0 ;

  {
  b = (blob *)arg;
  if (line) {
    tmp = lineGetData(line);
    l = tmp;
    tmp___0 = strlen(l);
    blobAddData(b, (unsigned char const   *)((unsigned char *)l), tmp___0);
  }
  blobAddData(b, (unsigned char const   *)((unsigned char *)"\n"), 1U);
  return;
}
}
static void addToFileblob(line_t const   *line , void *arg ) 
{ fileblob *fb ;
  char const   *l ;
  char const   *tmp ;
  size_t tmp___0 ;

  {
  fb = (fileblob *)arg;
  if (line) {
    tmp = lineGetData(line);
    l = tmp;
    tmp___0 = strlen(l);
    fileblobAddData(fb, (unsigned char const   *)((unsigned char *)l), tmp___0);
  }
  fileblobAddData(fb, (unsigned char const   *)((unsigned char *)"\n"), 1U);
  return;
}
}
static void *textIterate(text const   *t_text , void (*cb)(line_t const   *item ,
                                                           void *arg ) , void *arg ) 
{ 

  {
  while (t_text) {
    ((*cb))((line_t const   *)t_text->t_line, arg);
    t_text = (text const   *)t_text->t_next;
  }
  return (arg);
}
}
#pragma merger(0,"/tmp/cil-YmWUK6xn.i","-g -O2 -fPIC")
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
static uint16_t ole2_endian_convert_16(uint16_t v ) 
{ 

  {
  return ((unsigned short )(((int )v >> 8) + ((int )v << 8)));
}
}
static uint32_t ole2_endian_convert_32(uint32_t v ) 
{ 

  {
  return ((((v >> 24) | ((v & 16711680U) >> 8)) | ((v & 65280U) << 8)) | (v << 24));
}
}
unsigned char magic_id[8]  = 
  {      (unsigned char)208,      (unsigned char)207,      (unsigned char)17,      (unsigned char)224, 
        (unsigned char)161,      (unsigned char)177,      (unsigned char)26,      (unsigned char)225};
static char *get_property_name(char *name , int size ) 
{ int i ;
  int j ;
  char *newname ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  size_t tmp___5 ;

  {
  if ((int )(*name) == 0) {
    return ((char *)((void *)0));
  } else {
    if (size <= 0) {
      return ((char *)((void *)0));
    } else {
      if (size > 64) {
        return ((char *)((void *)0));
      }
    }
  }
  newname = (char *)cli_malloc((unsigned int )(size * 2));
  if (! newname) {
    return ((char *)((void *)0));
  }
  j = 0;
  i = 0;
  while (i < size - 2) {
    tmp___4 = __ctype_b_loc();
    if ((int const   )(*((*tmp___4) + (int )(*(name + i)))) & 16384) {
      tmp___0 = j;
      j ++;
      (*(newname + tmp___0)) = (*(name + i));
    } else {
      if ((int )(*(name + i)) < 10) {
        if ((int )(*(name + i)) >= 0) {
          tmp___1 = j;
          j ++;
          (*(newname + tmp___1)) = (char )'_';
          tmp___2 = j;
          j ++;
          (*(newname + tmp___2)) = (char )((int )(*(name + i)) + 48);
        }
      }
      tmp___3 = j;
      j ++;
      (*(newname + tmp___3)) = (char )'_';
    }
    i += 2;
  }
  (*(newname + j)) = (char )'\000';
  tmp___5 = strlen((char const   *)newname);
  if (tmp___5 == 0U) {
    free((void *)newname);
    return ((char *)((void *)0));
  }
  return (newname);
}
}
static void print_property_name(char *pname , int size ) 
{ char *name ;

  {
  name = get_property_name(pname, size);
  if (! name) {
    return;
  }
  cli_dbgmsg("%34s ", name);
  free((void *)name);
  return;
}
}
static void print_ole2_property(property_t *property ) 
{ 

  {
  if ((int )property->name_size > 64) {
    cli_dbgmsg("[err name len: %d]\n", property->name_size);
    return;
  }
  print_property_name((char *)(property->name), (int )property->name_size);
  switch ((int )property->type) {
  case 2: 
  cli_dbgmsg(" [file] ");
  break;
  case 1: 
  cli_dbgmsg(" [dir ] ");
  break;
  case 5: 
  cli_dbgmsg(" [root] ");
  break;
  default: 
  cli_dbgmsg(" [%d]", property->type);
  }
  switch ((int )property->color) {
  case 0: 
  cli_dbgmsg(" r ");
  break;
  case 1: 
  cli_dbgmsg(" b ");
  break;
  default: 
  cli_dbgmsg(" u ");
  }
  cli_dbgmsg(" %d %x\n", property->size, property->user_flags);
  return;
}
}
static void print_ole2_header(ole2_header_t *hdr ) 
{ int i ;

  {
  if (! hdr) {
    return;
  }
  cli_dbgmsg("\nMagic:\t\t\t0x");
  i = 0;
  while (i < 8) {
    cli_dbgmsg("%x", hdr->magic[i]);
    i ++;
  }
  cli_dbgmsg("\n");
  cli_dbgmsg("CLSID:\t\t\t{");
  i = 0;
  while (i < 16) {
    cli_dbgmsg("%x ", hdr->clsid[i]);
    i ++;
  }
  cli_dbgmsg("}\n");
  cli_dbgmsg("Minor version:\t\t0x%x\n", hdr->minor_version);
  cli_dbgmsg("DLL version:\t\t0x%x\n", hdr->dll_version);
  cli_dbgmsg("Byte Order:\t\t%d\n", hdr->byte_order);
  cli_dbgmsg("Big Block Size:\t\t%i\n", hdr->log2_big_block_size);
  cli_dbgmsg("Small Block Size:\t%i\n", hdr->log2_small_block_size);
  cli_dbgmsg("BAT count:\t\t%d\n", hdr->bat_count);
  cli_dbgmsg("Prop start:\t\t%d\n", hdr->prop_start);
  cli_dbgmsg("SBAT cutoff:\t\t%d\n", hdr->sbat_cutoff);
  cli_dbgmsg("SBat start:\t\t%d\n", hdr->sbat_start);
  cli_dbgmsg("SBat block count:\t%d\n", hdr->sbat_block_count);
  cli_dbgmsg("XBat start:\t\t%d\n", hdr->xbat_start);
  cli_dbgmsg("XBat block count:\t%d\n\n", hdr->xbat_count);
  return;
}
}
static int ole2_read_block(int fd , ole2_header_t *hdr , void *buff , int32_t blockno ) 
{ off_t offset ;
  off_t offend ;
  __off_t tmp ;
  int tmp___0 ;

  {
  if (blockno < 0) {
    return (0);
  }
  offset = (long )((blockno << (int )hdr->log2_big_block_size) + 512);
  if ((unsigned int )hdr->m_area == (unsigned int )((void *)0)) {
    tmp = lseek(fd, offset, 0);
    if (tmp != offset) {
      return (0);
    }
    tmp___0 = cli_readn(fd, buff, (unsigned int )(1 << (int )hdr->log2_big_block_size));
    if (tmp___0 != 1 << (int )hdr->log2_big_block_size) {
      return (0);
    }
  } else {
    offend = offset + (long )(1 << (int )hdr->log2_big_block_size);
    if (offend <= 0L) {
      return (0);
    } else {
      if (offend > hdr->m_length) {
        return (0);
      }
    }
    memcpy((void * __restrict  )buff, (void const   * __restrict  )(hdr->m_area +
                                                                    offset), (unsigned int )(1 <<
                                                                                             (int )hdr->log2_big_block_size));
  }
  return (1);
}
}
static int32_t ole2_get_next_bat_block(int fd , ole2_header_t *hdr , int32_t current_block ) 
{ int32_t bat_array_index ;
  uint32_t bat[128] ;
  int32_t tmp ;
  int tmp___0 ;
  int32_t tmp___1 ;

  {
  if (current_block < 0) {
    return (-1);
  }
  bat_array_index = current_block / 128;
  if (bat_array_index > hdr->bat_count) {
    cli_dbgmsg("bat_array index error\n");
    return (-10);
  }
  tmp = (int32_t )ole2_endian_convert_32((unsigned int )hdr->bat_array[bat_array_index]);
  tmp___0 = ole2_read_block(fd, hdr, (void *)(& bat), tmp);
  if (! tmp___0) {
    return (-1);
  }
  tmp___1 = (int32_t )ole2_endian_convert_32(bat[current_block - bat_array_index *
                                                                 128]);
  return (tmp___1);
}
}
static int32_t ole2_get_next_xbat_block(int fd , ole2_header_t *hdr , int32_t current_block ) 
{ int32_t xbat_index ;
  int32_t xbat_block_index ;
  int32_t bat_index ;
  int32_t bat_blockno ;
  uint32_t xbat[128] ;
  uint32_t bat[128] ;
  int tmp ;
  int32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int32_t tmp___3 ;

  {
  if (current_block < 0) {
    return (-1);
  }
  xbat_index = current_block / 128;
  xbat_block_index = (xbat_index - 109) / 127;
  bat_blockno = (xbat_index - 109) % 127;
  bat_index = current_block % 128;
  tmp = ole2_read_block(fd, hdr, (void *)(& xbat), hdr->xbat_start);
  if (! tmp) {
    return (-1);
  }
  while (xbat_block_index > 0) {
    tmp___0 = (int32_t )ole2_endian_convert_32(xbat[127]);
    tmp___1 = ole2_read_block(fd, hdr, (void *)(& xbat), tmp___0);
    if (! tmp___1) {
      return (-1);
    }
    xbat_block_index --;
  }
  tmp___2 = ole2_read_block(fd, hdr, (void *)(& bat), (int )xbat[bat_blockno]);
  if (! tmp___2) {
    return (-1);
  }
  tmp___3 = (int32_t )ole2_endian_convert_32(bat[bat_index]);
  return (tmp___3);
}
}
static int32_t ole2_get_next_block_number(int fd , ole2_header_t *hdr , int32_t current_block ) 
{ int32_t tmp ;
  int32_t tmp___0 ;

  {
  if (current_block < 0) {
    return (-1);
  }
  if (current_block / 128 > 108) {
    tmp = ole2_get_next_xbat_block(fd, hdr, current_block);
    return (tmp);
  } else {
    tmp___0 = ole2_get_next_bat_block(fd, hdr, current_block);
    return (tmp___0);
  }
}
}
static int32_t ole2_get_next_sbat_block(int fd , ole2_header_t *hdr , int32_t current_block ) 
{ int32_t iter ;
  int32_t current_bat_block ;
  uint32_t sbat[128] ;
  int tmp ;
  int32_t tmp___0 ;

  {
  if (current_block < 0) {
    return (-1);
  }
  current_bat_block = hdr->sbat_start;
  iter = current_block / 128;
  while (iter > 0) {
    current_bat_block = ole2_get_next_block_number(fd, hdr, current_bat_block);
    iter --;
  }
  tmp = ole2_read_block(fd, hdr, (void *)(& sbat), current_bat_block);
  if (! tmp) {
    return (-1);
  }
  tmp___0 = (int32_t )ole2_endian_convert_32(sbat[current_block % 128]);
  return (tmp___0);
}
}
static int32_t ole2_get_sbat_data_block(int fd , ole2_header_t *hdr , void *buff ,
                                        int32_t sbat_index ) 
{ int32_t block_count ;
  int32_t current_block ;
  int32_t tmp ;

  {
  if (sbat_index < 0) {
    return (0);
  }
  if (hdr->sbat_root_start < 0) {
    cli_errmsg("No root start block\n");
    return (0);
  }
  block_count = sbat_index / 8;
  current_block = hdr->sbat_root_start;
  while (block_count > 0) {
    current_block = ole2_get_next_block_number(fd, hdr, current_block);
    block_count --;
  }
  tmp = ole2_read_block(fd, hdr, buff, current_block);
  return (tmp);
}
}
static void ole2_walk_property_tree(int fd , ole2_header_t *hdr , char const   *dir ,
                                    int32_t prop_index , int (*handler)(int fd , ole2_header_t *hdr ,
                                                                        property_t *prop ,
                                                                        char const   *dir ) ,
                                    int rec_level , int *file_count , struct cl_limits  const  *limits ) 
{ property_t prop_block[4] ;
  int32_t index___0 ;
  int32_t current_block ;
  int32_t i ;
  unsigned char *dirname ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  current_block = hdr->prop_start;
  if (prop_index < 0) {
    return;
  } else {
    if (rec_level > 100) {
      return;
    } else {
      if ((*file_count) > 100000) {
        return;
      }
    }
  }
  if (limits) {
    if (limits->maxfiles) {
      if ((unsigned int )(*file_count) > limits->maxfiles) {
        cli_dbgmsg("OLE2: File limit reached (max: %d)\n", limits->maxfiles);
        return;
      }
    }
  }
  if (limits) {
    if (limits->maxreclevel) {
      if ((unsigned int )rec_level > limits->maxreclevel) {
        cli_dbgmsg("OLE2: Recursion limit reached (max: %d)\n", limits->maxreclevel);
        return;
      }
    }
  }
  index___0 = prop_index / 4;
  i = 0;
  while (i < index___0) {
    current_block = ole2_get_next_block_number(fd, hdr, current_block);
    if (current_block < 0) {
      return;
    }
    i ++;
  }
  index___0 = prop_index % 4;
  tmp = ole2_read_block(fd, hdr, (void *)(prop_block), current_block);
  if (! tmp) {
    return;
  }
  if ((int )prop_block[index___0].type <= 0) {
    return;
  }
  prop_block[index___0].name_size = (int16_t )ole2_endian_convert_16((unsigned short )prop_block[index___0].name_size);
  prop_block[index___0].prev = (int32_t )ole2_endian_convert_32((unsigned int )prop_block[index___0].prev);
  prop_block[index___0].next = (int32_t )ole2_endian_convert_32((unsigned int )prop_block[index___0].next);
  prop_block[index___0].child = (int32_t )ole2_endian_convert_32((unsigned int )prop_block[index___0].child);
  prop_block[index___0].user_flags = ole2_endian_convert_32(prop_block[index___0].user_flags);
  prop_block[index___0].create_lowdate = ole2_endian_convert_32(prop_block[index___0].create_lowdate);
  prop_block[index___0].create_highdate = ole2_endian_convert_32(prop_block[index___0].create_highdate);
  prop_block[index___0].mod_lowdate = ole2_endian_convert_32(prop_block[index___0].mod_lowdate);
  prop_block[index___0].mod_highdate = ole2_endian_convert_32(prop_block[index___0].mod_highdate);
  prop_block[index___0].start_block = (int32_t )ole2_endian_convert_32((unsigned int )prop_block[index___0].start_block);
  prop_block[index___0].size = (int32_t )ole2_endian_convert_32((unsigned int )prop_block[index___0].size);
  print_ole2_property(& prop_block[index___0]);
  switch ((int )prop_block[index___0].type) {
  case 5: ;
  if (prop_index != 0) {
    cli_dbgmsg("ERROR: illegal Root Entry\n");
    return;
  } else {
    if (rec_level != 0) {
      cli_dbgmsg("ERROR: illegal Root Entry\n");
      return;
    } else {
      if ((*file_count) != 0) {
        cli_dbgmsg("ERROR: illegal Root Entry\n");
        return;
      }
    }
  }
  hdr->sbat_root_start = prop_block[index___0].start_block;
  ole2_walk_property_tree(fd, hdr, dir, prop_block[index___0].prev, handler, rec_level +
                                                                             1, file_count,
                          limits);
  ole2_walk_property_tree(fd, hdr, dir, prop_block[index___0].next, handler, rec_level +
                                                                             1, file_count,
                          limits);
  ole2_walk_property_tree(fd, hdr, dir, prop_block[index___0].child, handler, rec_level +
                                                                              1, file_count,
                          limits);
  break;
  case 2: 
  (*file_count) ++;
  tmp___0 = ((*handler))(fd, hdr, & prop_block[index___0], dir);
  if (! tmp___0) {
    cli_dbgmsg("ERROR: handler failed\n");
  }
  ole2_walk_property_tree(fd, hdr, dir, prop_block[index___0].prev, handler, rec_level,
                          file_count, limits);
  ole2_walk_property_tree(fd, hdr, dir, prop_block[index___0].next, handler, rec_level,
                          file_count, limits);
  ole2_walk_property_tree(fd, hdr, dir, prop_block[index___0].child, handler, rec_level,
                          file_count, limits);
  break;
  case 1: 
  tmp___1 = strlen(dir);
  tmp___2 = cli_malloc(tmp___1 + 8U);
  dirname = (unsigned char *)((char *)tmp___2);
  if (! dirname) {
    return;
  }
  tmp___3 = strlen(dir);
  snprintf((char * __restrict  )dirname, tmp___3 + 8U, (char const   * __restrict  )"%s/%.6d",
           dir, prop_index);
  tmp___4 = mkdir((char const   *)dirname, 448U);
  if (tmp___4 != 0) {
    free((void *)dirname);
    return;
  }
  cli_dbgmsg("OLE2 dir entry: %s\n", dirname);
  ole2_walk_property_tree(fd, hdr, dir, prop_block[index___0].prev, handler, rec_level +
                                                                             1, file_count,
                          limits);
  ole2_walk_property_tree(fd, hdr, dir, prop_block[index___0].next, handler, rec_level +
                                                                             1, file_count,
                          limits);
  ole2_walk_property_tree(fd, hdr, (char const   *)dirname, prop_block[index___0].child,
                          handler, rec_level + 1, file_count, limits);
  free((void *)dirname);
  break;
  default: 
  cli_dbgmsg("ERROR: unknown OLE2 entry type: %d\n", prop_block[index___0].type);
  break;
  }
  return;
}
}
static int handler_writefile(int fd , ole2_header_t *hdr , property_t *prop , char const   *dir ) 
{ unsigned char *buff ;
  int32_t current_block ;
  int32_t ofd ;
  int32_t len ;
  int32_t offset ;
  char *name ;
  char *newname ;
  off_t i ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int32_t tmp___4 ;
  int32_t tmp___5 ;
  int tmp___6 ;
  int32_t tmp___7 ;
  int32_t tmp___8 ;
  int tmp___9 ;
  int32_t tmp___10 ;
  int tmp___11 ;
  int32_t tmp___12 ;
  int32_t tmp___13 ;

  {
  if ((int )prop->type != 2) {
    return (1);
  }
  if ((int )prop->name_size > 64) {
    cli_dbgmsg("\nERROR: property name too long: %d\n", prop->name_size);
    return (0);
  }
  name = get_property_name((char *)(prop->name), (int )prop->name_size);
  if (name) {
    newname = name;
    while ((*newname)) {
      if ((int )(*newname) == 47) {
        (*newname) = (char )'_';
      }
      newname ++;
    }
  } else {
    i = lseek(fd, 0L, 1);
    name = (char *)cli_malloc(11U);
    if (! name) {
      return (0);
    }
    snprintf((char * __restrict  )name, 11U, (char const   * __restrict  )"%.10ld",
             i + (long )prop);
  }
  tmp___0 = strlen((char const   *)name);
  tmp___1 = strlen(dir);
  newname = (char *)cli_malloc((tmp___0 + tmp___1) + 2U);
  if (! newname) {
    free((void *)name);
    return (0);
  }
  sprintf((char * __restrict  )newname, (char const   * __restrict  )"%s/%s", dir,
          name);
  free((void *)name);
  ofd = open((char const   *)newname, 577, 448);
  if (ofd < 0) {
    cli_errmsg("ERROR: failed to create file: %s\n", newname);
    free((void *)newname);
    return (0);
  }
  free((void *)newname);
  current_block = prop->start_block;
  len = prop->size;
  buff = (unsigned char *)cli_malloc((unsigned int )(1 << (int )hdr->log2_big_block_size));
  if (! buff) {
    close(ofd);
    return (0);
  }
  while (1) {
    if (current_block >= 0) {
      if (! (len > 0)) {
        break;
      }
    } else {
      break;
    }
    if ((long long )prop->size < (long long )hdr->sbat_cutoff) {
      tmp___4 = ole2_get_sbat_data_block(fd, hdr, (void *)buff, current_block);
      if (! tmp___4) {
        cli_dbgmsg("ole2_get_sbat_data_block failed\n");
        close(ofd);
        free((void *)buff);
        return (0);
      }
      offset = 64 * (current_block % 8);
      if (len < 64) {
        tmp___5 = len;
      } else {
        tmp___5 = 64;
      }
      tmp___6 = cli_writen(ofd, (void *)(buff + offset), (unsigned int )tmp___5);
      if (len < 64) {
        tmp___7 = len;
      } else {
        tmp___7 = 64;
      }
      if (tmp___6 != tmp___7) {
        close(ofd);
        free((void *)buff);
        return (0);
      }
      if (len < 64) {
        tmp___8 = len;
      } else {
        tmp___8 = 64;
      }
      len -= tmp___8;
      current_block = ole2_get_next_sbat_block(fd, hdr, current_block);
    } else {
      tmp___9 = ole2_read_block(fd, hdr, (void *)buff, current_block);
      if (! tmp___9) {
        close(ofd);
        free((void *)buff);
        return (0);
      }
      if (len < 1 << (int )hdr->log2_big_block_size) {
        tmp___10 = len;
      } else {
        tmp___10 = 1 << (int )hdr->log2_big_block_size;
      }
      tmp___11 = cli_writen(ofd, (void *)buff, (unsigned int )tmp___10);
      if (len < 1 << (int )hdr->log2_big_block_size) {
        tmp___12 = len;
      } else {
        tmp___12 = 1 << (int )hdr->log2_big_block_size;
      }
      if (tmp___11 != tmp___12) {
        close(ofd);
        free((void *)buff);
        return (0);
      }
      current_block = ole2_get_next_block_number(fd, hdr, current_block);
      if (len < 1 << (int )hdr->log2_big_block_size) {
        tmp___13 = len;
      } else {
        tmp___13 = 1 << (int )hdr->log2_big_block_size;
      }
      len -= tmp___13;
    }
  }
  close(ofd);
  free((void *)buff);
  return (1);
}
}
int cli_ole2_extract(int fd , char const   *dirname , struct cl_limits  const  *limits ) 
{ ole2_header_t hdr ;
  int hdr_size ;
  struct stat statbuf ;
  int file_count ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___76 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___112 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___131 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  size_t tmp___147 ;
  int tmp___148 ;
  size_t tmp___149 ;

  {
  file_count = 0;
  cli_dbgmsg("in cli_ole2_extract()\n");
  hdr_size = (int )(((sizeof(struct ole2_header_tag ) - sizeof(int32_t )) - sizeof(unsigned char *)) -
                    sizeof(off_t ));
  hdr.m_area = (unsigned char *)((void *)0);
  tmp___0 = fstat__extinline(fd, & statbuf);
  if (tmp___0 == 0) {
    if (statbuf.st_size < (long )hdr_size) {
      return (0);
    }
    hdr.m_length = statbuf.st_size;
    hdr.m_area = (unsigned char *)mmap((void *)0, (unsigned int )hdr.m_length, 1,
                                       2, fd, 0L);
    if ((unsigned int )hdr.m_area == (unsigned int )((void *)-1)) {
      hdr.m_area = (unsigned char *)((void *)0);
    } else {
      cli_dbgmsg("mmap\'ed file\n");
      memcpy((void * __restrict  )(& hdr), (void const   * __restrict  )hdr.m_area,
             (unsigned int )hdr_size);
    }
  }
  if ((unsigned int )hdr.m_area == (unsigned int )((void *)0)) {
    tmp___1 = cli_readn(fd, (void *)(& hdr), (unsigned int )hdr_size);
    if (tmp___1 != hdr_size) {
      return (0);
    }
  }
  hdr.minor_version = ole2_endian_convert_16(hdr.minor_version);
  hdr.dll_version = ole2_endian_convert_16(hdr.dll_version);
  hdr.byte_order = (int16_t )ole2_endian_convert_16((unsigned short )hdr.byte_order);
  hdr.log2_big_block_size = ole2_endian_convert_16(hdr.log2_big_block_size);
  hdr.log2_small_block_size = ole2_endian_convert_32(hdr.log2_small_block_size);
  hdr.bat_count = (int32_t )ole2_endian_convert_32((unsigned int )hdr.bat_count);
  hdr.prop_start = (int32_t )ole2_endian_convert_32((unsigned int )hdr.prop_start);
  hdr.sbat_cutoff = ole2_endian_convert_32(hdr.sbat_cutoff);
  hdr.sbat_start = (int32_t )ole2_endian_convert_32((unsigned int )hdr.sbat_start);
  hdr.sbat_block_count = (int32_t )ole2_endian_convert_32((unsigned int )hdr.sbat_block_count);
  hdr.xbat_start = (int32_t )ole2_endian_convert_32((unsigned int )hdr.xbat_start);
  hdr.xbat_count = (int32_t )ole2_endian_convert_32((unsigned int )hdr.xbat_count);
  hdr.sbat_root_start = -1;
  tmp___146 = __builtin_constant_p((int )(hdr.magic));
  if (tmp___146) {
    tmp___147 = strlen((char const   *)(hdr.magic));
    if (tmp___147 < 8U) {
      goto _L___39;
    } else {
      goto _L___40;
    }
  } else {
    _L___40: 
    tmp___148 = __builtin_constant_p((int )(magic_id));
    if (tmp___148) {
      tmp___149 = strlen((char const   *)(magic_id));
      if (tmp___149 < 8U) {
        _L___39: 
        tmp___143 = __builtin_constant_p((int )(hdr.magic));
        if (tmp___143) {
          tmp___144 = __builtin_constant_p((int )(magic_id));
          if (tmp___144) {
            __s1_len___0 = strlen((char const   *)(hdr.magic));
            __s2_len___0 = strlen((char const   *)(magic_id));
            if (! ((unsigned int )((void const   *)(hdr.magic + 1)) - (unsigned int )((void const   *)(hdr.magic)) ==
                   1U)) {
              goto _L___36;
            } else {
              if (__s1_len___0 >= 4U) {
                _L___36: 
                if (! ((unsigned int )((void const   *)(magic_id + 1)) - (unsigned int )((void const   *)(magic_id)) ==
                       1U)) {
                  tmp___145 = 1;
                } else {
                  if (__s2_len___0 >= 4U) {
                    tmp___145 = 1;
                  } else {
                    tmp___145 = 0;
                  }
                }
              } else {
                tmp___145 = 0;
              }
            }
            if (tmp___145) {
              tmp___112 = __builtin_strcmp(hdr.magic, magic_id);
            } else {
              goto _L___38;
            }
          } else {
            goto _L___38;
          }
        } else {
          _L___38: 
          tmp___142 = __builtin_constant_p((int )(hdr.magic));
          if (tmp___142) {
            if ((unsigned int )((void const   *)(hdr.magic + 1)) - (unsigned int )((void const   *)(hdr.magic)) ==
                1U) {
              __s1_len___0 = strlen((char const   *)(hdr.magic));
              if (__s1_len___0 < 4U) {
                tmp___131 = __builtin_constant_p((int )(magic_id));
                if (tmp___131) {
                  if ((unsigned int )((void const   *)(magic_id + 1)) - (unsigned int )((void const   *)(magic_id)) ==
                      1U) {
                    tmp___112 = __builtin_strcmp(hdr.magic, magic_id);
                  } else {
                    goto _L___31;
                  }
                } else {
                  _L___31: 
                  __s2___14 = (unsigned char const   *)((char const   *)(magic_id));
                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(hdr.magic)) +
                                                          0)) - (int const   )(*(__s2___14 +
                                                                                 0)));
                  if (__s1_len___0 > 0U) {
                    if (__result___42 == 0) {
                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(hdr.magic)) +
                                                              1)) - (int const   )(*(__s2___14 +
                                                                                     1)));
                      if (__s1_len___0 > 1U) {
                        if (__result___42 == 0) {
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(hdr.magic)) +
                                                                  2)) - (int const   )(*(__s2___14 +
                                                                                         2)));
                          if (__s1_len___0 > 2U) {
                            if (__result___42 == 0) {
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(hdr.magic)) +
                                                                      3)) - (int const   )(*(__s2___14 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___112 = __result___42;
                }
              } else {
                goto _L___35;
              }
            } else {
              goto _L___35;
            }
          } else {
            _L___35: 
            tmp___141 = __builtin_constant_p((int )(magic_id));
            if (tmp___141) {
              if ((unsigned int )((void const   *)(magic_id + 1)) - (unsigned int )((void const   *)(magic_id)) ==
                  1U) {
                __s2_len___0 = strlen((char const   *)(magic_id));
                if (__s2_len___0 < 4U) {
                  tmp___140 = __builtin_constant_p((int )(hdr.magic));
                  if (tmp___140) {
                    if ((unsigned int )((void const   *)(hdr.magic + 1)) - (unsigned int )((void const   *)(hdr.magic)) ==
                        1U) {
                      tmp___112 = __builtin_strcmp(hdr.magic, magic_id);
                    } else {
                      goto _L___33;
                    }
                  } else {
                    _L___33: 
                    __s1___30 = (unsigned char const   *)((char const   *)(hdr.magic));
                    __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)(magic_id)) +
                                                                                               0)));
                    if (__s2_len___0 > 0U) {
                      if (__result___46 == 0) {
                        __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                               (int const   )(*((unsigned char const   *)((char const   *)(magic_id)) +
                                                                1)));
                        if (__s2_len___0 > 1U) {
                          if (__result___46 == 0) {
                            __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                   (int const   )(*((unsigned char const   *)((char const   *)(magic_id)) +
                                                                    2)));
                            if (__s2_len___0 > 2U) {
                              if (__result___46 == 0) {
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        3)) - (int const   )(*((unsigned char const   *)((char const   *)(magic_id)) +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___112 = __result___46;
                  }
                } else {
                  tmp___112 = __builtin_strcmp(hdr.magic, magic_id);
                }
              } else {
                tmp___112 = __builtin_strcmp(hdr.magic, magic_id);
              }
            } else {
              tmp___112 = __builtin_strcmp(hdr.magic, magic_id);
            }
          }
        }
        tmp___76 = tmp___112;
      } else {
        tmp___76 = strncmp((char const   *)(hdr.magic), (char const   *)(magic_id),
                           8U);
      }
    } else {
      tmp___76 = strncmp((char const   *)(hdr.magic), (char const   *)(magic_id),
                         8U);
    }
  }
  if (tmp___76 != 0) {
    cli_dbgmsg("OLE2 magic failed!\n");
    if ((unsigned int )hdr.m_area != (unsigned int )((void *)0)) {
      munmap((void *)hdr.m_area, (unsigned int )hdr.m_length);
    }
    return (105);
  }
  if ((int )hdr.log2_big_block_size != 9) {
    cli_errmsg("WARNING: not scanned; untested big block size - please report\n");
    goto abort;
  }
  if (hdr.log2_small_block_size != 6U) {
    cli_errmsg("WARNING: not scanned; untested small block size - please report\n");
    goto abort;
  }
  if (hdr.sbat_cutoff != 4096U) {
    cli_errmsg("WARNING: not scanned; untested sbat cutoff - please report\n");
    goto abort;
  }
  print_ole2_header(& hdr);
  ole2_walk_property_tree(fd, & hdr, dirname, 0, & handler_writefile, 0, & file_count,
                          limits);
  abort: 
  if ((unsigned int )hdr.m_area != (unsigned int )((void *)0)) {
    munmap((void *)hdr.m_area, (unsigned int )hdr.m_length);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-FGkU5eG9.i","-g -O2 -fPIC")
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
static uint16_t vba_endian_convert_16(uint16_t value , int is_mac ) 
{ 

  {
  if (is_mac) {
    return (value);
  } else {
    return ((unsigned short )(((int )value >> 8) + ((int )value << 8)));
  }
}
}
static uint32_t vba_endian_convert_32(uint32_t value , int is_mac ) 
{ 

  {
  if (is_mac) {
    return (value);
  } else {
    return ((((value >> 24) | ((value & 16711680U) >> 8)) | ((value & 65280U) << 8)) |
            (value << 24));
  }
}
}
vba_version_t vba_version[14]  = 
  {      {{(unsigned char)94, (unsigned char)0, (unsigned char)0, (unsigned char)1}, "Office 97",
      5, 0}, 
        {{(unsigned char)95, (unsigned char)0, (unsigned char)0, (unsigned char)1}, "Office 97 SR1",
      5, 0}, 
        {{(unsigned char)101, (unsigned char)0, (unsigned char)0, (unsigned char)1},
      "Office 2000 alpha?", 6, 0}, 
        {{(unsigned char)107, (unsigned char)0, (unsigned char)0, (unsigned char)1},
      "Office 2000 beta?", 6, 0}, 
        {{(unsigned char)109, (unsigned char)0, (unsigned char)0, (unsigned char)1},
      "Office 2000", 6, 0}, 
        {{(unsigned char)111, (unsigned char)0, (unsigned char)0, (unsigned char)1},
      "Office 2000", 6, 0}, 
        {{(unsigned char)112, (unsigned char)0, (unsigned char)0, (unsigned char)1},
      "Office XP beta 1/2", 6, 0}, 
        {{(unsigned char)115, (unsigned char)0, (unsigned char)0, (unsigned char)1},
      "Office XP", 6, 0}, 
        {{(unsigned char)118, (unsigned char)0, (unsigned char)0, (unsigned char)1},
      "Office 2003", 6, 0}, 
        {{(unsigned char)121, (unsigned char)0, (unsigned char)0, (unsigned char)1},
      "Office 2003", 6, 0}, 
        {{(unsigned char)96, (unsigned char)0, (unsigned char)0, (unsigned char)14},
      "MacOffice 98", 5, 1}, 
        {{(unsigned char)98, (unsigned char)0, (unsigned char)0, (unsigned char)14},
      "MacOffice 2001", 5, 1}, 
        {{(unsigned char)99, (unsigned char)0, (unsigned char)0, (unsigned char)14},
      "MacOffice X", 6, 1}, 
        {{(unsigned char)100, (unsigned char)0, (unsigned char)0, (unsigned char)14},
      "MacOffice 2004", 6, 1}};
static char *get_unicode_name(char *name , int size , int is_mac ) 
{ int i ;
  int j ;
  char *newname ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  if (! name) {
    return ((char *)((void *)0));
  } else {
    if ((int )(*name) == 0) {
      return ((char *)((void *)0));
    } else {
      if (size <= 0) {
        return ((char *)((void *)0));
      }
    }
  }
  newname = (char *)cli_malloc((unsigned int )(size * 4));
  if (! newname) {
    return ((char *)((void *)0));
  }
  j = 0;
  i = 0;
  while (i < size) {
    tmp___5 = __ctype_b_loc();
    if ((int const   )(*((*tmp___5) + (int )(*(name + i)))) & 16384) {
      tmp___1 = j;
      j ++;
      (*(newname + tmp___1)) = (*(name + i));
    } else {
      if ((int )(*(name + i)) < 10) {
        if ((int )(*(name + i)) >= 0) {
          tmp___2 = j;
          j ++;
          (*(newname + tmp___2)) = (char )'_';
          tmp___3 = j;
          j ++;
          (*(newname + tmp___3)) = (char )((int )(*(name + i)) + 48);
        }
      }
      tmp___4 = j;
      j ++;
      (*(newname + tmp___4)) = (char )'_';
    }
    if (is_mac) {
      tmp___0 = 1;
    } else {
      tmp___0 = 2;
    }
    i += tmp___0;
  }
  (*(newname + j)) = (char )'\000';
  return (newname);
}
}
static void vba56_test_middle(int fd ) ;
static uint8_t const   middle1_str[20]  = 
  {      (uint8_t const   )(unsigned char)0,      (uint8_t const   )(unsigned char)1,      (uint8_t const   )(unsigned char)13,      (uint8_t const   )(unsigned char)69, 
        (uint8_t const   )(unsigned char)46,      (uint8_t const   )(unsigned char)225,      (uint8_t const   )(unsigned char)224,      (uint8_t const   )(unsigned char)143, 
        (uint8_t const   )(unsigned char)16,      (uint8_t const   )(unsigned char)26,      (uint8_t const   )(unsigned char)133,      (uint8_t const   )(unsigned char)46, 
        (uint8_t const   )(unsigned char)2,      (uint8_t const   )(unsigned char)96,      (uint8_t const   )(unsigned char)140,      (uint8_t const   )(unsigned char)77, 
        (uint8_t const   )(unsigned char)11,      (uint8_t const   )(unsigned char)180,      (uint8_t const   )(unsigned char)0,      (uint8_t const   )(unsigned char)0};
static uint8_t const   middle2_str[20]  = 
  {      (uint8_t const   )(unsigned char)0,      (uint8_t const   )(unsigned char)0,      (uint8_t const   )(unsigned char)225,      (uint8_t const   )(unsigned char)46, 
        (uint8_t const   )(unsigned char)69,      (uint8_t const   )(unsigned char)13,      (uint8_t const   )(unsigned char)143,      (uint8_t const   )(unsigned char)224, 
        (uint8_t const   )(unsigned char)26,      (uint8_t const   )(unsigned char)16,      (uint8_t const   )(unsigned char)133,      (uint8_t const   )(unsigned char)46, 
        (uint8_t const   )(unsigned char)2,      (uint8_t const   )(unsigned char)96,      (uint8_t const   )(unsigned char)140,      (uint8_t const   )(unsigned char)77, 
        (uint8_t const   )(unsigned char)11,      (uint8_t const   )(unsigned char)180,      (uint8_t const   )(unsigned char)0,      (uint8_t const   )(unsigned char)0};
static void vba56_test_middle(int fd ) 
{ char test_middle[20] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = cli_readn(fd, (void *)(& test_middle), 20U);
  if (tmp != 20) {
    return;
  }
  tmp___0 = memcmp((void const   *)(test_middle), (void const   *)(middle1_str), 20U);
  if (tmp___0 != 0) {
    tmp___1 = memcmp((void const   *)(test_middle), (void const   *)(middle2_str),
                     20U);
    if (tmp___1 != 0) {
      cli_dbgmsg("middle not found\n");
      lseek(fd, -20L, 1);
    } else {
      cli_dbgmsg("middle found\n");
    }
  } else {
    cli_dbgmsg("middle found\n");
  }
  return;
}
}
static int vba_read_project_strings(int fd , int is_mac ) 
{ uint16_t length ;
  unsigned char *buff ;
  unsigned char *name ;
  uint32_t offset ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___79 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___115 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___134 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  size_t tmp___150 ;
  int tmp___151 ;
  size_t tmp___152 ;
  int tmp___227 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___263 ;
  unsigned char const   *__s2___30 ;
  register int __result___90 ;
  int tmp___282 ;
  unsigned char const   *__s1___62 ;
  register int __result___94 ;
  int tmp___291 ;
  int tmp___292 ;
  int tmp___293 ;
  int tmp___294 ;
  int tmp___295 ;
  int tmp___296 ;
  int tmp___297 ;
  size_t tmp___298 ;
  int tmp___299 ;
  size_t tmp___300 ;
  int tmp___375 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___411 ;
  unsigned char const   *__s2___46 ;
  register int __result___138 ;
  int tmp___430 ;
  unsigned char const   *__s1___94 ;
  register int __result___142 ;
  int tmp___439 ;
  int tmp___440 ;
  int tmp___441 ;
  int tmp___442 ;
  int tmp___443 ;
  int tmp___444 ;
  int tmp___445 ;
  size_t tmp___446 ;
  int tmp___447 ;
  size_t tmp___448 ;
  int tmp___523 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___559 ;
  unsigned char const   *__s2___62 ;
  register int __result___186 ;
  int tmp___578 ;
  unsigned char const   *__s1___126 ;
  register int __result___190 ;
  int tmp___587 ;
  int tmp___588 ;
  int tmp___589 ;
  int tmp___590 ;
  int tmp___591 ;
  int tmp___592 ;
  int tmp___593 ;
  size_t tmp___594 ;
  int tmp___595 ;
  size_t tmp___596 ;

  {
  while (1) {
    tmp = cli_readn(fd, (void *)(& length), 2U);
    if (tmp != 2) {
      return (0);
    }
    length = vba_endian_convert_16(length, is_mac);
    if ((int )length < 6) {
      lseek(fd, -2L, 1);
      break;
    }
    cli_dbgmsg("length: %d, ", length);
    buff = (unsigned char *)cli_malloc((unsigned int )length);
    if (! buff) {
      cli_errmsg("cli_malloc failed\n");
      return (0);
    }
    offset = (uint32_t )lseek(fd, 0L, 1);
    tmp___1 = cli_readn(fd, (void *)buff, (unsigned int )length);
    if (tmp___1 != (int )length) {
      cli_dbgmsg("read name failed - rewinding\n");
      lseek(fd, (long )offset, 0);
      free((void *)buff);
      break;
    }
    name = (unsigned char *)get_unicode_name((char *)buff, (int )length, is_mac);
    if (name) {
      cli_dbgmsg("name: %s\n", name);
    } else {
      cli_dbgmsg("name: [null]\n");
    }
    free((void *)buff);
    if (name) {
      tmp___149 = __builtin_constant_p((int )"*\\G");
      if (tmp___149) {
        tmp___150 = strlen("*\\G");
        if (tmp___150 < 3U) {
          goto _L___39;
        } else {
          goto _L___40;
        }
      } else {
        _L___40: 
        tmp___151 = __builtin_constant_p((int )name);
        if (tmp___151) {
          tmp___152 = strlen((char const   *)name);
          if (tmp___152 < 3U) {
            _L___39: 
            tmp___146 = __builtin_constant_p((int )"*\\G");
            if (tmp___146) {
              tmp___147 = __builtin_constant_p((int )name);
              if (tmp___147) {
                __s1_len___0 = strlen("*\\G");
                __s2_len___0 = strlen((char const   *)name);
                if (! ((unsigned int )((void const   *)("*\\G" + 1)) - (unsigned int )((void const   *)"*\\G") ==
                       1U)) {
                  goto _L___36;
                } else {
                  if (__s1_len___0 >= 4U) {
                    _L___36: 
                    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                           1U)) {
                      tmp___148 = 1;
                    } else {
                      if (__s2_len___0 >= 4U) {
                        tmp___148 = 1;
                      } else {
                        tmp___148 = 0;
                      }
                    }
                  } else {
                    tmp___148 = 0;
                  }
                }
                if (tmp___148) {
                  tmp___115 = __builtin_strcmp("*\\G", name);
                } else {
                  goto _L___38;
                }
              } else {
                goto _L___38;
              }
            } else {
              _L___38: 
              tmp___145 = __builtin_constant_p((int )"*\\G");
              if (tmp___145) {
                if ((unsigned int )((void const   *)("*\\G" + 1)) - (unsigned int )((void const   *)"*\\G") ==
                    1U) {
                  __s1_len___0 = strlen("*\\G");
                  if (__s1_len___0 < 4U) {
                    tmp___134 = __builtin_constant_p((int )name);
                    if (tmp___134) {
                      if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                          1U) {
                        tmp___115 = __builtin_strcmp("*\\G", name);
                      } else {
                        goto _L___31;
                      }
                    } else {
                      _L___31: 
                      __s2___14 = (unsigned char const   *)((char const   *)name);
                      __result___42 = (int )((int const   )(*((unsigned char const   *)"*\\G" +
                                                              0)) - (int const   )(*(__s2___14 +
                                                                                     0)));
                      if (__s1_len___0 > 0U) {
                        if (__result___42 == 0) {
                          __result___42 = (int )((int const   )(*((unsigned char const   *)"*\\G" +
                                                                  1)) - (int const   )(*(__s2___14 +
                                                                                         1)));
                          if (__s1_len___0 > 1U) {
                            if (__result___42 == 0) {
                              __result___42 = (int )((int const   )(*((unsigned char const   *)"*\\G" +
                                                                      2)) - (int const   )(*(__s2___14 +
                                                                                             2)));
                              if (__s1_len___0 > 2U) {
                                if (__result___42 == 0) {
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)"*\\G" +
                                                                          3)) - (int const   )(*(__s2___14 +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___115 = __result___42;
                    }
                  } else {
                    goto _L___35;
                  }
                } else {
                  goto _L___35;
                }
              } else {
                _L___35: 
                tmp___144 = __builtin_constant_p((int )name);
                if (tmp___144) {
                  if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                      1U) {
                    __s2_len___0 = strlen((char const   *)name);
                    if (__s2_len___0 < 4U) {
                      tmp___143 = __builtin_constant_p((int )"*\\G");
                      if (tmp___143) {
                        if ((unsigned int )((void const   *)("*\\G" + 1)) - (unsigned int )((void const   *)"*\\G") ==
                            1U) {
                          tmp___115 = __builtin_strcmp("*\\G", name);
                        } else {
                          goto _L___33;
                        }
                      } else {
                        _L___33: 
                        __s1___30 = (unsigned char const   *)"*\\G";
                        __result___46 = (int )((int const   )(*(__s1___30 + 0)) -
                                               (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                0)));
                        if (__s2_len___0 > 0U) {
                          if (__result___46 == 0) {
                            __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                   (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                    1)));
                            if (__s2_len___0 > 1U) {
                              if (__result___46 == 0) {
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        2)) - (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                                               2)));
                                if (__s2_len___0 > 2U) {
                                  if (__result___46 == 0) {
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            3)) -
                                                           (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
                        tmp___115 = __result___46;
                      }
                    } else {
                      tmp___115 = __builtin_strcmp("*\\G", name);
                    }
                  } else {
                    tmp___115 = __builtin_strcmp("*\\G", name);
                  }
                } else {
                  tmp___115 = __builtin_strcmp("*\\G", name);
                }
              }
            }
            tmp___79 = tmp___115;
          } else {
            tmp___79 = strncmp("*\\G", (char const   *)name, 3U);
          }
        } else {
          tmp___79 = strncmp("*\\G", (char const   *)name, 3U);
        }
      }
      if (tmp___79) {
        tmp___297 = __builtin_constant_p((int )"*\\H");
        if (tmp___297) {
          tmp___298 = strlen("*\\H");
          if (tmp___298 < 3U) {
            goto _L___81;
          } else {
            goto _L___82;
          }
        } else {
          _L___82: 
          tmp___299 = __builtin_constant_p((int )name);
          if (tmp___299) {
            tmp___300 = strlen((char const   *)name);
            if (tmp___300 < 3U) {
              _L___81: 
              tmp___294 = __builtin_constant_p((int )"*\\H");
              if (tmp___294) {
                tmp___295 = __builtin_constant_p((int )name);
                if (tmp___295) {
                  __s1_len___2 = strlen("*\\H");
                  __s2_len___2 = strlen((char const   *)name);
                  if (! ((unsigned int )((void const   *)("*\\H" + 1)) - (unsigned int )((void const   *)"*\\H") ==
                         1U)) {
                    goto _L___78;
                  } else {
                    if (__s1_len___2 >= 4U) {
                      _L___78: 
                      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                             1U)) {
                        tmp___296 = 1;
                      } else {
                        if (__s2_len___2 >= 4U) {
                          tmp___296 = 1;
                        } else {
                          tmp___296 = 0;
                        }
                      }
                    } else {
                      tmp___296 = 0;
                    }
                  }
                  if (tmp___296) {
                    tmp___263 = __builtin_strcmp("*\\H", name);
                  } else {
                    goto _L___80;
                  }
                } else {
                  goto _L___80;
                }
              } else {
                _L___80: 
                tmp___293 = __builtin_constant_p((int )"*\\H");
                if (tmp___293) {
                  if ((unsigned int )((void const   *)("*\\H" + 1)) - (unsigned int )((void const   *)"*\\H") ==
                      1U) {
                    __s1_len___2 = strlen("*\\H");
                    if (__s1_len___2 < 4U) {
                      tmp___282 = __builtin_constant_p((int )name);
                      if (tmp___282) {
                        if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                            1U) {
                          tmp___263 = __builtin_strcmp("*\\H", name);
                        } else {
                          goto _L___73;
                        }
                      } else {
                        _L___73: 
                        __s2___30 = (unsigned char const   *)((char const   *)name);
                        __result___90 = (int )((int const   )(*((unsigned char const   *)"*\\H" +
                                                                0)) - (int const   )(*(__s2___30 +
                                                                                       0)));
                        if (__s1_len___2 > 0U) {
                          if (__result___90 == 0) {
                            __result___90 = (int )((int const   )(*((unsigned char const   *)"*\\H" +
                                                                    1)) - (int const   )(*(__s2___30 +
                                                                                           1)));
                            if (__s1_len___2 > 1U) {
                              if (__result___90 == 0) {
                                __result___90 = (int )((int const   )(*((unsigned char const   *)"*\\H" +
                                                                        2)) - (int const   )(*(__s2___30 +
                                                                                               2)));
                                if (__s1_len___2 > 2U) {
                                  if (__result___90 == 0) {
                                    __result___90 = (int )((int const   )(*((unsigned char const   *)"*\\H" +
                                                                            3)) -
                                                           (int const   )(*(__s2___30 +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
                        tmp___263 = __result___90;
                      }
                    } else {
                      goto _L___77;
                    }
                  } else {
                    goto _L___77;
                  }
                } else {
                  _L___77: 
                  tmp___292 = __builtin_constant_p((int )name);
                  if (tmp___292) {
                    if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                        1U) {
                      __s2_len___2 = strlen((char const   *)name);
                      if (__s2_len___2 < 4U) {
                        tmp___291 = __builtin_constant_p((int )"*\\H");
                        if (tmp___291) {
                          if ((unsigned int )((void const   *)("*\\H" + 1)) - (unsigned int )((void const   *)"*\\H") ==
                              1U) {
                            tmp___263 = __builtin_strcmp("*\\H", name);
                          } else {
                            goto _L___75;
                          }
                        } else {
                          _L___75: 
                          __s1___62 = (unsigned char const   *)"*\\H";
                          __result___94 = (int )((int const   )(*(__s1___62 + 0)) -
                                                 (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                  0)));
                          if (__s2_len___2 > 0U) {
                            if (__result___94 == 0) {
                              __result___94 = (int )((int const   )(*(__s1___62 +
                                                                      1)) - (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                                             1)));
                              if (__s2_len___2 > 1U) {
                                if (__result___94 == 0) {
                                  __result___94 = (int )((int const   )(*(__s1___62 +
                                                                          2)) - (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                                                 2)));
                                  if (__s2_len___2 > 2U) {
                                    if (__result___94 == 0) {
                                      __result___94 = (int )((int const   )(*(__s1___62 +
                                                                              3)) -
                                                             (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                              3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
                          tmp___263 = __result___94;
                        }
                      } else {
                        tmp___263 = __builtin_strcmp("*\\H", name);
                      }
                    } else {
                      tmp___263 = __builtin_strcmp("*\\H", name);
                    }
                  } else {
                    tmp___263 = __builtin_strcmp("*\\H", name);
                  }
                }
              }
              tmp___227 = tmp___263;
            } else {
              tmp___227 = strncmp("*\\H", (char const   *)name, 3U);
            }
          } else {
            tmp___227 = strncmp("*\\H", (char const   *)name, 3U);
          }
        }
        if (tmp___227) {
          tmp___445 = __builtin_constant_p((int )"*\\C");
          if (tmp___445) {
            tmp___446 = strlen("*\\C");
            if (tmp___446 < 3U) {
              goto _L___123;
            } else {
              goto _L___124;
            }
          } else {
            _L___124: 
            tmp___447 = __builtin_constant_p((int )name);
            if (tmp___447) {
              tmp___448 = strlen((char const   *)name);
              if (tmp___448 < 3U) {
                _L___123: 
                tmp___442 = __builtin_constant_p((int )"*\\C");
                if (tmp___442) {
                  tmp___443 = __builtin_constant_p((int )name);
                  if (tmp___443) {
                    __s1_len___4 = strlen("*\\C");
                    __s2_len___4 = strlen((char const   *)name);
                    if (! ((unsigned int )((void const   *)("*\\C" + 1)) - (unsigned int )((void const   *)"*\\C") ==
                           1U)) {
                      goto _L___120;
                    } else {
                      if (__s1_len___4 >= 4U) {
                        _L___120: 
                        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                               1U)) {
                          tmp___444 = 1;
                        } else {
                          if (__s2_len___4 >= 4U) {
                            tmp___444 = 1;
                          } else {
                            tmp___444 = 0;
                          }
                        }
                      } else {
                        tmp___444 = 0;
                      }
                    }
                    if (tmp___444) {
                      tmp___411 = __builtin_strcmp("*\\C", name);
                    } else {
                      goto _L___122;
                    }
                  } else {
                    goto _L___122;
                  }
                } else {
                  _L___122: 
                  tmp___441 = __builtin_constant_p((int )"*\\C");
                  if (tmp___441) {
                    if ((unsigned int )((void const   *)("*\\C" + 1)) - (unsigned int )((void const   *)"*\\C") ==
                        1U) {
                      __s1_len___4 = strlen("*\\C");
                      if (__s1_len___4 < 4U) {
                        tmp___430 = __builtin_constant_p((int )name);
                        if (tmp___430) {
                          if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                              1U) {
                            tmp___411 = __builtin_strcmp("*\\C", name);
                          } else {
                            goto _L___115;
                          }
                        } else {
                          _L___115: 
                          __s2___46 = (unsigned char const   *)((char const   *)name);
                          __result___138 = (int )((int const   )(*((unsigned char const   *)"*\\C" +
                                                                   0)) - (int const   )(*(__s2___46 +
                                                                                          0)));
                          if (__s1_len___4 > 0U) {
                            if (__result___138 == 0) {
                              __result___138 = (int )((int const   )(*((unsigned char const   *)"*\\C" +
                                                                       1)) - (int const   )(*(__s2___46 +
                                                                                              1)));
                              if (__s1_len___4 > 1U) {
                                if (__result___138 == 0) {
                                  __result___138 = (int )((int const   )(*((unsigned char const   *)"*\\C" +
                                                                           2)) - (int const   )(*(__s2___46 +
                                                                                                  2)));
                                  if (__s1_len___4 > 2U) {
                                    if (__result___138 == 0) {
                                      __result___138 = (int )((int const   )(*((unsigned char const   *)"*\\C" +
                                                                               3)) -
                                                              (int const   )(*(__s2___46 +
                                                                               3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
                          tmp___411 = __result___138;
                        }
                      } else {
                        goto _L___119;
                      }
                    } else {
                      goto _L___119;
                    }
                  } else {
                    _L___119: 
                    tmp___440 = __builtin_constant_p((int )name);
                    if (tmp___440) {
                      if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                          1U) {
                        __s2_len___4 = strlen((char const   *)name);
                        if (__s2_len___4 < 4U) {
                          tmp___439 = __builtin_constant_p((int )"*\\C");
                          if (tmp___439) {
                            if ((unsigned int )((void const   *)("*\\C" + 1)) - (unsigned int )((void const   *)"*\\C") ==
                                1U) {
                              tmp___411 = __builtin_strcmp("*\\C", name);
                            } else {
                              goto _L___117;
                            }
                          } else {
                            _L___117: 
                            __s1___94 = (unsigned char const   *)"*\\C";
                            __result___142 = (int )((int const   )(*(__s1___94 + 0)) -
                                                    (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                     0)));
                            if (__s2_len___4 > 0U) {
                              if (__result___142 == 0) {
                                __result___142 = (int )((int const   )(*(__s1___94 +
                                                                         1)) - (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                                                1)));
                                if (__s2_len___4 > 1U) {
                                  if (__result___142 == 0) {
                                    __result___142 = (int )((int const   )(*(__s1___94 +
                                                                             2)) -
                                                            (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                             2)));
                                    if (__s2_len___4 > 2U) {
                                      if (__result___142 == 0) {
                                        __result___142 = (int )((int const   )(*(__s1___94 +
                                                                                 3)) -
                                                                (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                                 3)));
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            tmp___411 = __result___142;
                          }
                        } else {
                          tmp___411 = __builtin_strcmp("*\\C", name);
                        }
                      } else {
                        tmp___411 = __builtin_strcmp("*\\C", name);
                      }
                    } else {
                      tmp___411 = __builtin_strcmp("*\\C", name);
                    }
                  }
                }
                tmp___375 = tmp___411;
              } else {
                tmp___375 = strncmp("*\\C", (char const   *)name, 3U);
              }
            } else {
              tmp___375 = strncmp("*\\C", (char const   *)name, 3U);
            }
          }
          if (tmp___375) {
            tmp___593 = __builtin_constant_p((int )"*\\D");
            if (tmp___593) {
              tmp___594 = strlen("*\\D");
              if (tmp___594 < 3U) {
                goto _L___165;
              } else {
                goto _L___166;
              }
            } else {
              _L___166: 
              tmp___595 = __builtin_constant_p((int )name);
              if (tmp___595) {
                tmp___596 = strlen((char const   *)name);
                if (tmp___596 < 3U) {
                  _L___165: 
                  tmp___590 = __builtin_constant_p((int )"*\\D");
                  if (tmp___590) {
                    tmp___591 = __builtin_constant_p((int )name);
                    if (tmp___591) {
                      __s1_len___6 = strlen("*\\D");
                      __s2_len___6 = strlen((char const   *)name);
                      if (! ((unsigned int )((void const   *)("*\\D" + 1)) - (unsigned int )((void const   *)"*\\D") ==
                             1U)) {
                        goto _L___162;
                      } else {
                        if (__s1_len___6 >= 4U) {
                          _L___162: 
                          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                                 1U)) {
                            tmp___592 = 1;
                          } else {
                            if (__s2_len___6 >= 4U) {
                              tmp___592 = 1;
                            } else {
                              tmp___592 = 0;
                            }
                          }
                        } else {
                          tmp___592 = 0;
                        }
                      }
                      if (tmp___592) {
                        tmp___559 = __builtin_strcmp("*\\D", name);
                      } else {
                        goto _L___164;
                      }
                    } else {
                      goto _L___164;
                    }
                  } else {
                    _L___164: 
                    tmp___589 = __builtin_constant_p((int )"*\\D");
                    if (tmp___589) {
                      if ((unsigned int )((void const   *)("*\\D" + 1)) - (unsigned int )((void const   *)"*\\D") ==
                          1U) {
                        __s1_len___6 = strlen("*\\D");
                        if (__s1_len___6 < 4U) {
                          tmp___578 = __builtin_constant_p((int )name);
                          if (tmp___578) {
                            if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                                1U) {
                              tmp___559 = __builtin_strcmp("*\\D", name);
                            } else {
                              goto _L___157;
                            }
                          } else {
                            _L___157: 
                            __s2___62 = (unsigned char const   *)((char const   *)name);
                            __result___186 = (int )((int const   )(*((unsigned char const   *)"*\\D" +
                                                                     0)) - (int const   )(*(__s2___62 +
                                                                                            0)));
                            if (__s1_len___6 > 0U) {
                              if (__result___186 == 0) {
                                __result___186 = (int )((int const   )(*((unsigned char const   *)"*\\D" +
                                                                         1)) - (int const   )(*(__s2___62 +
                                                                                                1)));
                                if (__s1_len___6 > 1U) {
                                  if (__result___186 == 0) {
                                    __result___186 = (int )((int const   )(*((unsigned char const   *)"*\\D" +
                                                                             2)) -
                                                            (int const   )(*(__s2___62 +
                                                                             2)));
                                    if (__s1_len___6 > 2U) {
                                      if (__result___186 == 0) {
                                        __result___186 = (int )((int const   )(*((unsigned char const   *)"*\\D" +
                                                                                 3)) -
                                                                (int const   )(*(__s2___62 +
                                                                                 3)));
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            tmp___559 = __result___186;
                          }
                        } else {
                          goto _L___161;
                        }
                      } else {
                        goto _L___161;
                      }
                    } else {
                      _L___161: 
                      tmp___588 = __builtin_constant_p((int )name);
                      if (tmp___588) {
                        if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                            1U) {
                          __s2_len___6 = strlen((char const   *)name);
                          if (__s2_len___6 < 4U) {
                            tmp___587 = __builtin_constant_p((int )"*\\D");
                            if (tmp___587) {
                              if ((unsigned int )((void const   *)("*\\D" + 1)) -
                                  (unsigned int )((void const   *)"*\\D") == 1U) {
                                tmp___559 = __builtin_strcmp("*\\D", name);
                              } else {
                                goto _L___159;
                              }
                            } else {
                              _L___159: 
                              __s1___126 = (unsigned char const   *)"*\\D";
                              __result___190 = (int )((int const   )(*(__s1___126 +
                                                                       0)) - (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                                              0)));
                              if (__s2_len___6 > 0U) {
                                if (__result___190 == 0) {
                                  __result___190 = (int )((int const   )(*(__s1___126 +
                                                                           1)) - (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                                                  1)));
                                  if (__s2_len___6 > 1U) {
                                    if (__result___190 == 0) {
                                      __result___190 = (int )((int const   )(*(__s1___126 +
                                                                               2)) -
                                                              (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                               2)));
                                      if (__s2_len___6 > 2U) {
                                        if (__result___190 == 0) {
                                          __result___190 = (int )((int const   )(*(__s1___126 +
                                                                                   3)) -
                                                                  (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                                   3)));
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              tmp___559 = __result___190;
                            }
                          } else {
                            tmp___559 = __builtin_strcmp("*\\D", name);
                          }
                        } else {
                          tmp___559 = __builtin_strcmp("*\\D", name);
                        }
                      } else {
                        tmp___559 = __builtin_strcmp("*\\D", name);
                      }
                    }
                  }
                  tmp___523 = tmp___559;
                } else {
                  tmp___523 = strncmp("*\\D", (char const   *)name, 3U);
                }
              } else {
                tmp___523 = strncmp("*\\D", (char const   *)name, 3U);
              }
            }
            if (tmp___523) {
              goto _L___167;
            } else {
              _L___168: 
              tmp___2 = cli_readn(fd, (void *)(& length), 2U);
              if (tmp___2 != 2) {
                return (0);
              }
              length = vba_endian_convert_16(length, is_mac);
              if ((int )length != 0) {
                if ((int )length != 65535) {
                  lseek(fd, -2L, 1);
                  free((void *)name);
                  goto __Cont;
                }
              }
              buff = (unsigned char *)cli_malloc(10U);
              if (! buff) {
                free((void *)name);
                close(fd);
                return (0);
              }
              tmp___4 = cli_readn(fd, (void *)buff, 10U);
              if (tmp___4 != 10) {
                cli_errmsg("failed to read blob\n");
                free((void *)buff);
                free((void *)name);
                close(fd);
                return (0);
              }
              free((void *)buff);
            }
          } else {
            goto _L___168;
          }
        } else {
          goto _L___168;
        }
      } else {
        goto _L___168;
      }
    } else {
      _L___167: 
      lseek(fd, (long )(- ((int )length + 2)), 1);
      if (name) {
        free((void *)name);
      }
      break;
    }
    free((void *)name);
    offset = (uint32_t )lseek(fd, 0L, 1);
    cli_dbgmsg("offset: %u\n", offset);
    vba56_test_middle(fd);
    __Cont: ;
  }
  return (1);
}
}
vba_project_t *vba56_dir_read(char const   *dir ) 
{ unsigned char magic[2] ;
  unsigned char version[4] ;
  unsigned char *buff ;
  unsigned char vba56_signature[2] ;
  uint16_t record_count ;
  uint16_t length ;
  uint16_t ooff ;
  uint16_t byte_count ;
  uint32_t offset ;
  uint32_t LidA ;
  uint32_t LidB ;
  uint16_t CharSet ;
  uint16_t LenA ;
  uint32_t UnknownB ;
  uint32_t UnknownC ;
  uint16_t LenB ;
  uint16_t LenC ;
  uint16_t LenD ;
  int i ;
  int j ;
  int fd ;
  int is_mac ;
  vba_project_t *vba_project ;
  char *fullname ;
  size_t tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __len___2 ;
  size_t tmp___39 ;
  char *__retval___2 ;
  char *tmp___40 ;
  int tmp___42 ;
  int tmp___44 ;
  int tmp___46 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  off_t foffset ;

  {
  vba56_signature[0] = (unsigned char)204;
  vba56_signature[1] = (unsigned char)97;
  cli_dbgmsg("in vba56_dir_read()\n");
  tmp = strlen(dir);
  fullname = (char *)cli_malloc(tmp + 14U);
  if (! fullname) {
    return ((vba_project_t *)((void *)0));
  }
  sprintf((char * __restrict  )fullname, (char const   * __restrict  )"%s/_VBA_PROJECT",
          dir);
  fd = open((char const   *)fullname, 0);
  if (fd == -1) {
    cli_dbgmsg("Can\'t open %s\n", fullname);
    free((void *)fullname);
    return ((vba_project_t *)((void *)0));
  }
  free((void *)fullname);
  tmp___1 = cli_readn(fd, (void *)(& magic), 2U);
  if (tmp___1 != 2) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  tmp___2 = memcmp((void const   *)(magic), (void const   *)(vba56_signature), 2U);
  if (tmp___2 != 0) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  tmp___3 = cli_readn(fd, (void *)(& version), 4U);
  if (tmp___3 != 4) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  i = 0;
  while (i < 14) {
    tmp___4 = memcmp((void const   *)(version), (void const   *)(vba_version[i].signature),
                     4U);
    if (tmp___4 == 0) {
      break;
    }
    i ++;
  }
  if (i == 14) {
    cli_warnmsg("Unknown VBA version signature %x %x %x %x\n", version[0], version[1],
                version[2], version[3]);
    if ((int )version[3] == 1) {
      cli_warnmsg("Guessing little-endian\n");
      is_mac = 0;
    } else {
      if ((int )version[3] == 14) {
        cli_warnmsg("Guessing big-endian\n");
        is_mac = 1;
      } else {
        cli_warnmsg("Unable to guess VBA type\n");
        close(fd);
        return ((vba_project_t *)((void *)0));
      }
    }
  } else {
    cli_dbgmsg("VBA Project: %s, VBA Version=%d\n", vba_version[i].name, vba_version[i].vba_version);
    is_mac = vba_version[i].is_mac;
  }
  tmp___5 = cli_readn(fd, (void *)(& ooff), 2U);
  if (tmp___5 != 2) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  tmp___6 = cli_readn(fd, (void *)(& LidA), 4U);
  if (tmp___6 != 4) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  tmp___7 = cli_readn(fd, (void *)(& LidB), 4U);
  if (tmp___7 != 4) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  tmp___8 = cli_readn(fd, (void *)(& CharSet), 2U);
  if (tmp___8 != 2) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  tmp___9 = cli_readn(fd, (void *)(& LenA), 2U);
  if (tmp___9 != 2) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  tmp___10 = cli_readn(fd, (void *)(& UnknownB), 4U);
  if (tmp___10 != 4) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  tmp___11 = cli_readn(fd, (void *)(& UnknownC), 4U);
  if (tmp___11 != 4) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  tmp___12 = cli_readn(fd, (void *)(& LenB), 2U);
  if (tmp___12 != 2) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  tmp___13 = cli_readn(fd, (void *)(& LenC), 2U);
  if (tmp___13 != 2) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  tmp___14 = cli_readn(fd, (void *)(& LenD), 2U);
  if (tmp___14 != 2) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  LidA = vba_endian_convert_32(LidA, is_mac);
  LidB = vba_endian_convert_32(LidB, is_mac);
  CharSet = vba_endian_convert_16(CharSet, is_mac);
  LenA = vba_endian_convert_16(LenA, is_mac);
  LenB = vba_endian_convert_16(LenB, is_mac);
  LenC = vba_endian_convert_16(LenC, is_mac);
  LenD = vba_endian_convert_16(LenD, is_mac);
  cli_dbgmsg(" LidA: %d\n LidB: %d\n CharSet: %d\n", LidA, LidB, CharSet);
  cli_dbgmsg(" LenA: %d\n UnknownB: %d\n UnknownC: %d\n", LenA, UnknownB, UnknownC);
  cli_dbgmsg(" LenB: %d\n LenC: %d\n LenD: %d\n", LenB, LenC, LenD);
  record_count = LenC;
  tmp___15 = vba_read_project_strings(fd, is_mac);
  if (! tmp___15) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  while (1) {
    tmp___16 = cli_readn(fd, (void *)(& ooff), 2U);
    if (tmp___16 != 2) {
      close(fd);
      return ((vba_project_t *)((void *)0));
    }
    if (! ((int )ooff != 65535)) {
      break;
    }
  }
  lseek(fd, -3L, 1);
  tmp___17 = cli_readn(fd, (void *)(& ooff), 2U);
  if (tmp___17 != 2) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  if ((int )ooff != 65535) {
    lseek(fd, 1L, 1);
  }
  tmp___18 = cli_readn(fd, (void *)(& ooff), 2U);
  if (tmp___18 != 2) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  if ((int )ooff != 65535) {
    ooff = vba_endian_convert_16(ooff, is_mac);
    lseek(fd, (long )ooff, 1);
  }
  tmp___19 = cli_readn(fd, (void *)(& ooff), 2U);
  if (tmp___19 != 2) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  if ((int )ooff != 65535) {
    ooff = vba_endian_convert_16(ooff, is_mac);
    lseek(fd, (long )ooff, 1);
  }
  lseek(fd, 100L, 1);
  tmp___20 = cli_readn(fd, (void *)(& record_count), 2U);
  if (tmp___20 != 2) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  record_count = vba_endian_convert_16(record_count, is_mac);
  cli_dbgmsg("\nVBA Record count: %d\n", record_count);
  if ((int )record_count > 1000) {
    cli_dbgmsg("\nVBA Record count too big");
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  vba_project = (vba_project_t *)cli_malloc(sizeof(struct vba_project_tag ));
  if (! vba_project) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  vba_project->name = (char **)cli_malloc(sizeof(char *) * (unsigned int )record_count);
  if (! vba_project->name) {
    free((void *)vba_project);
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  tmp___42 = __builtin_constant_p((int )dir);
  if (tmp___42) {
    if ((unsigned int )((void const   *)(dir + 1)) - (unsigned int )((void const   *)dir) ==
        1U) {
      if ((int const   )(*(dir + 0)) == 0) {
        vba_project->dir = (char *)calloc(1U, 1U);
      } else {
        tmp___39 = strlen(dir);
        __len___2 = tmp___39 + 1U;
        tmp___40 = (char *)malloc(__len___2);
        __retval___2 = tmp___40;
        if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
          __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )dir,
                                        __len___2);
        }
        vba_project->dir = __retval___2;
      }
    } else {
      vba_project->dir = __strdup(dir);
    }
  } else {
    vba_project->dir = __strdup(dir);
  }
  vba_project->offset = (uint32_t *)cli_malloc(sizeof(uint32_t ) * (unsigned int )record_count);
  if (! vba_project->offset) {
    free((void *)vba_project->dir);
    free((void *)vba_project->name);
    free((void *)vba_project);
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  vba_project->count = (int )record_count;
  i = 0;
  while (i < (int )record_count) {
    tmp___44 = cli_readn(fd, (void *)(& length), 2U);
    if (tmp___44 != 2) {
      goto out_error;
    }
    length = vba_endian_convert_16(length, is_mac);
    if ((int )length == 0) {
      cli_dbgmsg("zero name length\n");
      goto out_error;
    }
    buff = (unsigned char *)cli_malloc((unsigned int )length);
    if (! buff) {
      cli_dbgmsg("cli_malloc failed\n");
      goto out_error;
    }
    tmp___46 = cli_readn(fd, (void *)buff, (unsigned int )length);
    if (tmp___46 != (int )length) {
      cli_dbgmsg("read name failed\n");
      free((void *)buff);
      goto out_error;
    }
    (*(vba_project->name + i)) = get_unicode_name((char *)buff, (int )length, is_mac);
    if (! (*(vba_project->name + i))) {
      offset = (uint32_t )lseek(fd, 0L, 1);
      (*(vba_project->name + i)) = (char *)cli_malloc(18U);
      snprintf((char * __restrict  )(*(vba_project->name + i)), 18U, (char const   * __restrict  )"clamav-%.10d",
               offset);
    }
    cli_dbgmsg("project name: %s, ", (*(vba_project->name + i)));
    free((void *)buff);
    tmp___48 = cli_readn(fd, (void *)(& length), 2U);
    if (tmp___48 != 2) {
      free((void *)(*(vba_project->name + i)));
      goto out_error;
    }
    length = vba_endian_convert_16(length, is_mac);
    lseek(fd, (long )length, 1);
    tmp___49 = cli_readn(fd, (void *)(& ooff), 2U);
    if (tmp___49 != 2) {
      free((void *)(*(vba_project->name + i)));
      goto out_error;
    }
    ooff = vba_endian_convert_16(ooff, is_mac);
    if ((int )ooff == 65535) {
      lseek(fd, 2L, 1);
      tmp___50 = cli_readn(fd, (void *)(& ooff), 2U);
      if (tmp___50 != 2) {
        free((void *)(*(vba_project->name + i)));
        goto out_error;
      }
      ooff = vba_endian_convert_16(ooff, is_mac);
      lseek(fd, (long )ooff, 1);
    } else {
      lseek(fd, (long )(2 + (int )ooff), 1);
    }
    lseek(fd, 8L, 1);
    tmp___51 = cli_readn(fd, (void *)(& byte_count), 2U);
    if (tmp___51 != 2) {
      free((void *)(*(vba_project->name + i)));
      goto out_error;
    }
    byte_count = vba_endian_convert_16(byte_count, is_mac);
    j = 0;
    while (j < (int )byte_count) {
      lseek(fd, 8L, 1);
      j ++;
    }
    lseek(fd, 5L, 1);
    tmp___52 = cli_readn(fd, (void *)(& offset), 4U);
    if (tmp___52 != 4) {
      free((void *)(*(vba_project->name + i)));
      goto out_error;
    }
    offset = vba_endian_convert_32(offset, is_mac);
    (*(vba_project->offset + i)) = offset;
    cli_dbgmsg("offset:%u\n", offset);
    lseek(fd, 2L, 1);
    i ++;
  }
  foffset = lseek(fd, 0L, 1);
  cli_dbgmsg("\nOffset: 0x%x\n", (unsigned int )foffset);
  close(fd);
  return (vba_project);
  out_error: 
  j = 0;
  while (j < i) {
    free((void *)(*(vba_project->name + j)));
    j ++;
  }
  free((void *)vba_project->name);
  free((void *)vba_project->dir);
  free((void *)vba_project->offset);
  free((void *)vba_project);
  close(fd);
  return ((vba_project_t *)((void *)0));
}
}
static void byte_array_append(byte_array_t *array , unsigned char *src , unsigned int len ) 
{ 

  {
  if (array->length == 0U) {
    array->data = (unsigned char *)cli_malloc(len);
    if (! array->data) {
      return;
    }
    array->length = len;
    memcpy((void * __restrict  )array->data, (void const   * __restrict  )src, len);
  } else {
    array->data = (unsigned char *)realloc((void *)array->data, array->length + len);
    if (! array->data) {
      return;
    }
    memcpy((void * __restrict  )(array->data + array->length), (void const   * __restrict  )src,
           len);
    array->length += len;
  }
  return;
}
}
unsigned char *vba_decompress(int fd , uint32_t offset , int *size ) 
{ unsigned int i ;
  unsigned int pos ;
  unsigned int shift ;
  unsigned int win_pos ;
  unsigned int clean ;
  unsigned int mask ;
  unsigned int distance ;
  uint8_t flag ;
  uint16_t token ;
  uint16_t len ;
  unsigned char buffer[4096] ;
  byte_array_t result ;
  int tmp ;
  unsigned int srcpos ;
  unsigned char c ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  pos = 0U;
  clean = 1U;
  result.length = 0U;
  result.data = (unsigned char *)((void *)0);
  lseek(fd, (long )(offset + 3U), 0);
  while (1) {
    tmp___3 = cli_readn(fd, (void *)(& flag), 1U);
    if (! (tmp___3 == 1)) {
      break;
    }
    mask = 1U;
    while (mask < 256U) {
      if ((unsigned int )flag & mask) {
        tmp = cli_readn(fd, (void *)(& token), 2U);
        if (tmp != 2) {
          if (result.data) {
            free((void *)result.data);
          }
          if (size) {
            (*size) = 0;
          }
          return ((unsigned char *)((void *)0));
        }
        token = vba_endian_convert_16(token, 0);
        win_pos = pos % 4096U;
        if (win_pos <= 128U) {
          if (win_pos <= 32U) {
            if (win_pos <= 16U) {
              shift = 12U;
            } else {
              shift = 11U;
            }
          } else {
            if (win_pos <= 64U) {
              shift = 10U;
            } else {
              shift = 9U;
            }
          }
        } else {
          if (win_pos <= 512U) {
            if (win_pos <= 256U) {
              shift = 8U;
            } else {
              shift = 7U;
            }
          } else {
            if (win_pos <= 2048U) {
              if (win_pos <= 1024U) {
                shift = 6U;
              } else {
                shift = 5U;
              }
            } else {
              shift = 4U;
            }
          }
        }
        len = (unsigned short )(((int )token & ((1 << shift) - 1)) + 3);
        distance = (unsigned int )((int )token >> shift);
        clean = 1U;
        i = 0U;
        while (i < (unsigned int )len) {
          srcpos = ((pos - distance) - 1U) % 4096U;
          c = buffer[srcpos];
          tmp___0 = pos;
          pos ++;
          buffer[tmp___0 % 4096U] = c;
          i ++;
        }
      } else {
        if (pos != 0U) {
          if (pos % 4096U == 0U) {
            if (clean) {
              tmp___1 = cli_readn(fd, (void *)(& token), 2U);
              if (tmp___1 != 2) {
                if (result.data) {
                  free((void *)result.data);
                }
                if (size) {
                  (*size) = 0;
                }
                return ((unsigned char *)((void *)0));
              }
              clean = 0U;
              byte_array_append(& result, buffer, 4096U);
              break;
            }
          }
        }
        tmp___2 = cli_readn(fd, (void *)(buffer + pos % 4096U), 1U);
        if (tmp___2 == 1) {
          pos ++;
        }
        clean = 1U;
      }
      mask <<= 1;
    }
  }
  if (pos % 4096U) {
    byte_array_append(& result, buffer, pos % 4096U);
  }
  if (size) {
    (*size) = (int )result.length;
  }
  return (result.data);
}
}
static int ppt_read_atom_header(int fd , atom_header_t *atom_header ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  atom_header->foffset = lseek(fd, 0L, 1);
  tmp = cli_readn(fd, (void *)(& atom_header->ver_inst), 2U);
  if (tmp != 2) {
    cli_dbgmsg("read ppt_current_user failed\n");
    return (0);
  }
  atom_header->ver_inst = vba_endian_convert_16(atom_header->ver_inst, 0);
  atom_header->version = (unsigned char )((int )atom_header->ver_inst & 15);
  atom_header->instance = (unsigned short )((int )atom_header->ver_inst >> 4);
  tmp___0 = cli_readn(fd, (void *)(& atom_header->type), 2U);
  if (tmp___0 != 2) {
    cli_dbgmsg("read ppt_current_user failed\n");
    return (0);
  }
  tmp___1 = cli_readn(fd, (void *)(& atom_header->length), 4U);
  if (tmp___1 != 4) {
    cli_dbgmsg("read ppt_current_user failed\n");
    return (0);
  }
  atom_header->type = vba_endian_convert_16(atom_header->type, 0);
  atom_header->length = vba_endian_convert_32(atom_header->length, 0);
  return (1);
}
}
static void ppt_print_atom_header(atom_header_t *atom_header ) 
{ 

  {
  cli_dbgmsg("Atom Hdr:\n");
  cli_dbgmsg("  Version: 0x%.2x\n", atom_header->version);
  cli_dbgmsg("  Instance: 0x%.4x\n", atom_header->instance);
  cli_dbgmsg("  Type: 0x%.4x\n", atom_header->type);
  cli_dbgmsg("  Length: 0x%.8x\n", atom_header->length);
  return;
}
}
static int ppt_unlzw(char const   *dir , int fd , uint32_t length ) 
{ int ofd ;
  int retval ;
  unsigned char inbuff[8192] ;
  unsigned char outbuff[8192] ;
  char *fullname ;
  uint32_t bufflen ;
  z_stream stream ;
  size_t tmp ;
  __off_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  tmp = strlen(dir);
  fullname = (char *)cli_malloc(tmp + 17U);
  if (! fullname) {
    return (0);
  }
  tmp___0 = lseek(fd, 0L, 1);
  sprintf((char * __restrict  )fullname, (char const   * __restrict  )"%s/ppt%.8lx.doc",
          dir, tmp___0);
  ofd = open((char const   *)fullname, 577, 384);
  free((void *)fullname);
  if (ofd == -1) {
    cli_dbgmsg("ppt_unlzw Open outfile failed\n");
    return (0);
  }
  stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
  stream.zfree = (void (*)(voidpf opaque , voidpf address ))0;
  stream.opaque = (void *)0;
  stream.next_in = inbuff;
  if (length < 8192U) {
    stream.avail_in = length;
  } else {
    stream.avail_in = 8192U;
  }
  bufflen = stream.avail_in;
  tmp___1 = cli_readn(fd, (void *)(inbuff), stream.avail_in);
  if ((long long )tmp___1 != (long long )stream.avail_in) {
    close(ofd);
    return (0);
  }
  length -= stream.avail_in;
  retval = inflateInit_(& stream, "1.2.2", (int )sizeof(z_stream ));
  if (retval != 0) {
    cli_dbgmsg(" ppt_unlzw !Z_OK: %d\n", retval);
  }
  stream.next_out = outbuff;
  stream.avail_out = 8192U;
  while (1) {
    if (stream.avail_out == 0U) {
      tmp___2 = cli_writen(ofd, (void *)(outbuff), 8192U);
      if (tmp___2 != 8192) {
        close(ofd);
        inflateEnd(& stream);
        return (0);
      }
      stream.next_out = outbuff;
      stream.avail_out = 8192U;
    }
    if (stream.avail_in == 0U) {
      stream.next_in = inbuff;
      if (length < 8192U) {
        stream.avail_in = length;
      } else {
        stream.avail_in = 8192U;
      }
      bufflen = stream.avail_in;
      tmp___3 = cli_readn(fd, (void *)(inbuff), stream.avail_in);
      if ((long long )tmp___3 != (long long )stream.avail_in) {
        close(ofd);
        inflateEnd(& stream);
        return (0);
      }
      length -= stream.avail_in;
    }
    retval = inflate(& stream, 0);
    if (! (retval == 0)) {
      break;
    }
  }
  tmp___4 = cli_writen(ofd, (void *)(outbuff), bufflen);
  if ((long long )tmp___4 != (long long )bufflen) {
    close(ofd);
    inflateEnd(& stream);
    return (0);
  }
  inflateEnd(& stream);
  close(ofd);
  return (1);
}
}
static char *ppt_stream_iter(int fd ) 
{ atom_header_t atom_header ;
  uint32_t ole_id ;
  char *out_dir ;
  off_t offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __off_t tmp___3 ;

  {
  out_dir = cli_gentemp((char const   *)((void *)0));
  tmp = mkdir((char const   *)out_dir, 448U);
  if (tmp) {
    printf((char const   * __restrict  )"ScanOLE2 -> Can\'t create temporary directory %s\n",
           out_dir);
    free((void *)out_dir);
    close(fd);
    return ((char *)((void *)0));
  }
  while (1) {
    tmp___0 = ppt_read_atom_header(fd, & atom_header);
    if (! tmp___0) {
      break;
    }
    ppt_print_atom_header(& atom_header);
    if (atom_header.length == 0U) {
      cli_rmdirs((char const   *)out_dir);
      free((void *)out_dir);
      return ((char *)((void *)0));
    }
    if ((int )atom_header.type == 4113) {
      tmp___1 = cli_readn(fd, (void *)(& ole_id), 4U);
      if (tmp___1 != 4) {
        cli_dbgmsg("read ole_id failed\n");
        cli_rmdirs((char const   *)out_dir);
        free((void *)out_dir);
        return ((char *)((void *)0));
      }
      ole_id = vba_endian_convert_32(ole_id, 0);
      cli_dbgmsg("OleID: %d, length: %d\n", ole_id, atom_header.length - 4U);
      tmp___2 = ppt_unlzw((char const   *)out_dir, fd, atom_header.length - 4U);
      if (! tmp___2) {
        cli_dbgmsg("ppt_unlzw failed\n");
        cli_rmdirs((char const   *)out_dir);
        free((void *)out_dir);
        return ((char *)((void *)0));
      }
    } else {
      offset = lseek(fd, 0L, 1);
      if (offset + (long )atom_header.length < offset) {
        break;
      }
      offset = (long )((unsigned long )offset + (unsigned long )atom_header.length);
      tmp___3 = lseek(fd, offset, 0);
      if (tmp___3 != offset) {
        break;
      }
    }
  }
  return (out_dir);
}
}
char *ppt_vba_read(char const   *dir ) 
{ char *fullname ;
  char *out_dir ;
  int fd ;
  size_t tmp ;

  {
  tmp = strlen(dir);
  fullname = (char *)cli_malloc(tmp + 21U);
  if (! fullname) {
    return ((char *)((void *)0));
  }
  sprintf((char * __restrict  )fullname, (char const   * __restrict  )"%s/PowerPoint Document",
          dir);
  fd = open((char const   *)fullname, 0);
  free((void *)fullname);
  if (fd == -1) {
    cli_dbgmsg("Open  PowerPoint Document failed\n");
    return ((char *)((void *)0));
  }
  out_dir = ppt_stream_iter(fd);
  close(fd);
  return (out_dir);
}
}
static void wm_print_fib(mso_fib_t *fib ) 
{ 

  {
  cli_dbgmsg("magic: 0x%.4x\n", fib->magic);
  cli_dbgmsg("version: 0x%.4x\n", fib->version);
  cli_dbgmsg("product: 0x%.4x\n", fib->product);
  cli_dbgmsg("lid: 0x%.4x\n", fib->lid);
  cli_dbgmsg("macro offset: 0x%.4x\n", fib->macro_offset);
  cli_dbgmsg("macro len: 0x%.4x\n\n", fib->macro_len);
  return;
}
}
static int wm_read_fib(int fd , mso_fib_t *fib ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __off_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  tmp = cli_readn(fd, (void *)(& fib->magic), 2U);
  if (tmp != 2) {
    cli_dbgmsg("read wm_fib failed\n");
    return (0);
  }
  tmp___0 = cli_readn(fd, (void *)(& fib->version), 2U);
  if (tmp___0 != 2) {
    cli_dbgmsg("read wm_fib failed\n");
    return (0);
  }
  tmp___1 = cli_readn(fd, (void *)(& fib->product), 2U);
  if (tmp___1 != 2) {
    cli_dbgmsg("read wm_fib failed\n");
    return (0);
  }
  tmp___2 = cli_readn(fd, (void *)(& fib->lid), 2U);
  if (tmp___2 != 2) {
    cli_dbgmsg("read wm_fib failed\n");
    return (0);
  }
  tmp___3 = cli_readn(fd, (void *)(& fib->next), 2U);
  if (tmp___3 != 2) {
    cli_dbgmsg("read wm_fib failed\n");
    return (0);
  }
  tmp___4 = cli_readn(fd, (void *)(& fib->status), 2U);
  if (tmp___4 != 2) {
    cli_dbgmsg("read wm_fib failed\n");
    return (0);
  }
  tmp___5 = lseek(fd, 280L, 0);
  if (tmp___5 != 280L) {
    cli_dbgmsg("lseek wm_fib failed\n");
    return (0);
  }
  tmp___6 = cli_readn(fd, (void *)(& fib->macro_offset), 4U);
  if (tmp___6 != 4) {
    cli_dbgmsg("read wm_fib failed\n");
    return (0);
  }
  tmp___7 = cli_readn(fd, (void *)(& fib->macro_len), 4U);
  if (tmp___7 != 4) {
    cli_dbgmsg("read wm_fib failed\n");
    return (0);
  }
  fib->magic = vba_endian_convert_16(fib->magic, 0);
  fib->version = vba_endian_convert_16(fib->version, 0);
  fib->product = vba_endian_convert_16(fib->product, 0);
  fib->lid = vba_endian_convert_16(fib->lid, 0);
  fib->next = vba_endian_convert_16(fib->next, 0);
  fib->status = vba_endian_convert_16(fib->status, 0);
  fib->macro_offset = vba_endian_convert_32(fib->macro_offset, 0);
  fib->macro_len = vba_endian_convert_32(fib->macro_len, 0);
  return (1);
}
}
static int wm_read_macro_entry(int fd , macro_entry_t *macro_entry ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  tmp = cli_readn(fd, (void *)(& macro_entry->version), 1U);
  if (tmp != 1) {
    cli_dbgmsg("read macro_entry failed\n");
    return (0);
  }
  tmp___0 = cli_readn(fd, (void *)(& macro_entry->key), 1U);
  if (tmp___0 != 1) {
    cli_dbgmsg("read macro_entry failed\n");
    return (0);
  }
  tmp___1 = cli_readn(fd, (void *)(& macro_entry->intname_i), 2U);
  if (tmp___1 != 2) {
    cli_dbgmsg("read macro_entry failed\n");
    return (0);
  }
  tmp___2 = cli_readn(fd, (void *)(& macro_entry->extname_i), 2U);
  if (tmp___2 != 2) {
    cli_dbgmsg("read macro_entry failed\n");
    return (0);
  }
  tmp___3 = cli_readn(fd, (void *)(& macro_entry->xname_i), 2U);
  if (tmp___3 != 2) {
    cli_dbgmsg("read macro_entry failed\n");
    return (0);
  }
  tmp___4 = cli_readn(fd, (void *)(& macro_entry->unknown), 4U);
  if (tmp___4 != 4) {
    cli_dbgmsg("read macro_entry failed\n");
    return (0);
  }
  tmp___5 = cli_readn(fd, (void *)(& macro_entry->len), 4U);
  if (tmp___5 != 4) {
    cli_dbgmsg("read macro_entry failed\n");
    return (0);
  }
  tmp___6 = cli_readn(fd, (void *)(& macro_entry->state), 4U);
  if (tmp___6 != 4) {
    cli_dbgmsg("read macro_entry failed\n");
    return (0);
  }
  tmp___7 = cli_readn(fd, (void *)(& macro_entry->offset), 4U);
  if (tmp___7 != 4) {
    cli_dbgmsg("read macro_entry failed\n");
    return (0);
  }
  macro_entry->intname_i = vba_endian_convert_16(macro_entry->intname_i, 0);
  macro_entry->extname_i = vba_endian_convert_16(macro_entry->extname_i, 0);
  macro_entry->xname_i = vba_endian_convert_16(macro_entry->xname_i, 0);
  macro_entry->len = vba_endian_convert_32(macro_entry->len, 0);
  macro_entry->state = vba_endian_convert_32(macro_entry->state, 0);
  macro_entry->offset = vba_endian_convert_32(macro_entry->offset, 0);
  return (1);
}
}
static macro_info_t *wm_read_macro_info(int fd ) 
{ int i ;
  macro_info_t *macro_info ;
  int tmp___0 ;
  int tmp___2 ;

  {
  macro_info = (macro_info_t *)cli_malloc(sizeof(macro_info_t ));
  if (! macro_info) {
    return ((macro_info_t *)((void *)0));
  }
  tmp___0 = cli_readn(fd, (void *)(& macro_info->count), 2U);
  if (tmp___0 != 2) {
    cli_dbgmsg("read macro_info failed\n");
    return ((macro_info_t *)((void *)0));
  }
  macro_info->count = vba_endian_convert_16(macro_info->count, 0);
  cli_dbgmsg("macro count: %d\n", macro_info->count);
  macro_info->macro_entry = (struct macro_entry_tag *)cli_malloc(sizeof(macro_entry_t ) *
                                                                 (unsigned int )macro_info->count);
  if (! macro_info->macro_entry) {
    free((void *)macro_info);
    return ((macro_info_t *)((void *)0));
  }
  i = 0;
  while (i < (int )macro_info->count) {
    tmp___2 = wm_read_macro_entry(fd, macro_info->macro_entry + i);
    if (! tmp___2) {
      free((void *)macro_info->macro_entry);
      free((void *)macro_info);
      return ((macro_info_t *)((void *)0));
    }
    i ++;
  }
  return (macro_info);
}
}
static void wm_free_macro_info(macro_info_t *macro_info ) 
{ 

  {
  if (macro_info) {
    free((void *)macro_info->macro_entry);
    free((void *)macro_info);
  }
  return;
}
}
static int wm_read_oxo3(int fd ) 
{ uint8_t count ;
  int tmp ;
  __off_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __off_t tmp___4 ;

  {
  tmp = cli_readn(fd, (void *)(& count), 1U);
  if (tmp != 1) {
    cli_dbgmsg("read oxo3 record1 failed\n");
    return (0);
  }
  tmp___0 = lseek(fd, (long )((int )count * 14), 1);
  if (tmp___0 == -1L) {
    cli_dbgmsg("lseek oxo3 record1 failed\n");
    return (0);
  }
  cli_dbgmsg("oxo3 records1: %d\n", count);
  tmp___1 = cli_readn(fd, (void *)(& count), 1U);
  if (tmp___1 != 1) {
    cli_dbgmsg("read oxo3 record2 failed\n");
    return (0);
  }
  if ((int )count == 0) {
    tmp___2 = cli_readn(fd, (void *)(& count), 1U);
    if (tmp___2 != 1) {
      cli_dbgmsg("read oxo3 failed\n");
      return (0);
    }
    if ((int )count != 2) {
      lseek(fd, -1L, 1);
      return (1);
    }
    tmp___3 = cli_readn(fd, (void *)(& count), 1U);
    if (tmp___3 != 1) {
      cli_dbgmsg("read oxo3 failed\n");
      return (0);
    }
  }
  if ((int )count > 0) {
    tmp___4 = lseek(fd, (long )((int )count * 4 + 1), 1);
    if (tmp___4 == -1L) {
      cli_dbgmsg("lseek oxo3 failed\n");
      return (0);
    }
  }
  cli_dbgmsg("oxo3 records2: %d\n", count);
  return (1);
}
}
static menu_info_t *wm_read_menu_info(int fd ) 
{ int i ;
  menu_info_t *menu_info ;
  menu_entry_t *menu_entry ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  menu_info = (menu_info_t *)cli_malloc(sizeof(menu_info_t ));
  if (! menu_info) {
    return ((menu_info_t *)((void *)0));
  }
  tmp___0 = cli_readn(fd, (void *)(& menu_info->count), 2U);
  if (tmp___0 != 2) {
    cli_dbgmsg("read menu_info failed\n");
    free((void *)menu_info);
    return ((menu_info_t *)((void *)0));
  }
  menu_info->count = vba_endian_convert_16(menu_info->count, 0);
  cli_dbgmsg("menu_info count: %d\n", menu_info->count);
  menu_info->menu_entry = (struct menu_entry_tag *)cli_malloc(sizeof(menu_entry_t ) *
                                                              (unsigned int )menu_info->count);
  if (! menu_info->menu_entry) {
    free((void *)menu_info);
    return ((menu_info_t *)((void *)0));
  }
  i = 0;
  while (i < (int )menu_info->count) {
    menu_entry = menu_info->menu_entry + i;
    tmp___2 = cli_readn(fd, (void *)(& menu_entry->context), 2U);
    if (tmp___2 != 2) {
      goto abort;
    }
    tmp___3 = cli_readn(fd, (void *)(& menu_entry->menu), 2U);
    if (tmp___3 != 2) {
      goto abort;
    }
    tmp___4 = cli_readn(fd, (void *)(& menu_entry->extname_i), 2U);
    if (tmp___4 != 2) {
      goto abort;
    }
    tmp___5 = cli_readn(fd, (void *)(& menu_entry->unknown), 2U);
    if (tmp___5 != 2) {
      goto abort;
    }
    tmp___6 = cli_readn(fd, (void *)(& menu_entry->intname_i), 2U);
    if (tmp___6 != 2) {
      goto abort;
    }
    tmp___7 = cli_readn(fd, (void *)(& menu_entry->pos), 2U);
    if (tmp___7 != 2) {
      goto abort;
    }
    menu_entry->context = vba_endian_convert_16(menu_entry->context, 0);
    menu_entry->menu = vba_endian_convert_16(menu_entry->menu, 0);
    menu_entry->extname_i = vba_endian_convert_16(menu_entry->extname_i, 0);
    menu_entry->intname_i = vba_endian_convert_16(menu_entry->intname_i, 0);
    menu_entry->pos = vba_endian_convert_16(menu_entry->pos, 0);
    cli_dbgmsg("menu entry: %d.%d\n", menu_entry->menu, menu_entry->pos);
    i ++;
  }
  return (menu_info);
  abort: 
  cli_dbgmsg("read menu_entry failed\n");
  free((void *)menu_info->menu_entry);
  free((void *)menu_info);
  return ((menu_info_t *)((void *)0));
}
}
static void wm_free_menu_info(menu_info_t *menu_info ) 
{ 

  {
  if (menu_info) {
    free((void *)menu_info->menu_entry);
    free((void *)menu_info);
  }
  return;
}
}
static macro_extnames_t *wm_read_macro_extnames(int fd ) 
{ int i ;
  int is_unicode ;
  int16_t size ;
  off_t offset_end ;
  macro_extnames_t *macro_extnames ;
  macro_extname_t *macro_extname ;
  unsigned char *name_tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___21 ;
  size_t __len___2 ;
  size_t tmp___22 ;
  char *__retval___2 ;
  char *tmp___23 ;
  int tmp___25 ;
  int tmp___26 ;
  void *tmp___27 ;
  int tmp___28 ;
  void *tmp___44 ;
  size_t __len___6 ;
  size_t tmp___45 ;
  char *__retval___6 ;
  char *tmp___46 ;
  int tmp___48 ;
  int tmp___49 ;
  __off_t tmp___50 ;

  {
  is_unicode = 0;
  macro_extnames = (macro_extnames_t *)cli_malloc(sizeof(macro_extnames_t ));
  if (! macro_extnames) {
    return ((macro_extnames_t *)((void *)0));
  }
  macro_extnames->count = (unsigned short)0;
  macro_extnames->macro_extname = (struct macro_extname_tag *)((void *)0);
  offset_end = lseek(fd, 0L, 1);
  tmp___0 = cli_readn(fd, (void *)(& size), 2U);
  if (tmp___0 != 2) {
    cli_dbgmsg("read macro_extnames failed\n");
    free((void *)macro_extnames);
    return ((macro_extnames_t *)((void *)0));
  }
  size = (int16_t )vba_endian_convert_16((unsigned short )size, 0);
  if ((int )size == -1) {
    is_unicode = 1;
    tmp___1 = cli_readn(fd, (void *)(& size), 2U);
    if (tmp___1 != 2) {
      cli_dbgmsg("read macro_extnames failed\n");
      free((void *)macro_extnames);
      return ((macro_extnames_t *)((void *)0));
    }
    size = (int16_t )vba_endian_convert_16((unsigned short )size, 0);
  }
  cli_dbgmsg("ext names size: 0x%x\n", size);
  offset_end += (long )size;
  while (1) {
    tmp___50 = lseek(fd, 0L, 1);
    if (! (tmp___50 < offset_end)) {
      break;
    }
    macro_extnames->count = (unsigned short )((int )macro_extnames->count + 1);
    macro_extnames->macro_extname = (struct macro_extname_tag *)cli_realloc((void *)macro_extnames->macro_extname,
                                                                            sizeof(macro_extname_t ) *
                                                                            (unsigned int )macro_extnames->count);
    if ((unsigned int )macro_extnames->macro_extname == (unsigned int )((void *)0)) {
      cli_dbgmsg("read macro_extnames failed\n");
      goto abort;
    }
    macro_extname = macro_extnames->macro_extname + ((int )macro_extnames->count -
                                                     1);
    if (is_unicode) {
      tmp___3 = cli_readn(fd, (void *)(& macro_extname->length), 1U);
      if (tmp___3 != 1) {
        cli_dbgmsg("read macro_extnames failed\n");
        goto abort;
      }
      lseek(fd, 1L, 1);
      if ((int )macro_extname->length > 0) {
        tmp___4 = cli_malloc((unsigned int )((int )macro_extname->length * 2));
        name_tmp = (unsigned char *)((char *)tmp___4);
        if ((unsigned int )name_tmp == (unsigned int )((void *)0)) {
          goto abort;
        }
        tmp___5 = cli_readn(fd, (void *)name_tmp, (unsigned int )((int )macro_extname->length *
                                                                  2));
        if (tmp___5 != (int )macro_extname->length * 2) {
          cli_dbgmsg("read macro_extnames failed\n");
          free((void *)name_tmp);
          goto abort;
        }
        macro_extname->extname = (unsigned char *)get_unicode_name((char *)name_tmp,
                                                                   (int )macro_extname->length *
                                                                   2, 0);
        free((void *)name_tmp);
      } else {
        tmp___25 = __builtin_constant_p((int )"[no name]");
        if (tmp___25) {
          if ((unsigned int )((void const   *)("[no name]" + 1)) - (unsigned int )((void const   *)"[no name]") ==
              1U) {
            if ((int const   )(*("[no name]" + 0)) == 0) {
              tmp___21 = calloc(1U, 1U);
              macro_extname->extname = (unsigned char *)((char *)tmp___21);
            } else {
              tmp___22 = strlen("[no name]");
              __len___2 = tmp___22 + 1U;
              tmp___23 = (char *)malloc(__len___2);
              __retval___2 = tmp___23;
              if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
                __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )"[no name]",
                                              __len___2);
              }
              macro_extname->extname = (unsigned char *)__retval___2;
            }
          } else {
            macro_extname->extname = (unsigned char *)__strdup("[no name]");
          }
        } else {
          macro_extname->extname = (unsigned char *)__strdup("[no name]");
        }
        macro_extname->length = (unsigned char)10;
      }
    } else {
      tmp___26 = cli_readn(fd, (void *)(& macro_extname->length), 1U);
      if (tmp___26 != 1) {
        cli_dbgmsg("read macro_extnames failed\n");
        goto abort;
      }
      if ((int )macro_extname->length > 0) {
        tmp___27 = cli_malloc((unsigned int )((int )macro_extname->length + 1));
        macro_extname->extname = (unsigned char *)((char *)tmp___27);
        if (! macro_extname->extname) {
          goto abort;
        }
        tmp___28 = cli_readn(fd, (void *)macro_extname->extname, (unsigned int )macro_extname->length);
        if (tmp___28 != (int )macro_extname->length) {
          cli_dbgmsg("read macro_extnames failed\n");
          free((void *)macro_extname->extname);
          goto abort;
        }
        (*(macro_extname->extname + (int )macro_extname->length)) = (unsigned char )'\000';
      } else {
        tmp___48 = __builtin_constant_p((int )"[no name]");
        if (tmp___48) {
          if ((unsigned int )((void const   *)("[no name]" + 1)) - (unsigned int )((void const   *)"[no name]") ==
              1U) {
            if ((int const   )(*("[no name]" + 0)) == 0) {
              tmp___44 = calloc(1U, 1U);
              macro_extname->extname = (unsigned char *)((char *)tmp___44);
            } else {
              tmp___45 = strlen("[no name]");
              __len___6 = tmp___45 + 1U;
              tmp___46 = (char *)malloc(__len___6);
              __retval___6 = tmp___46;
              if ((unsigned int )__retval___6 != (unsigned int )((void *)0)) {
                __retval___6 = (char *)memcpy((void * __restrict  )__retval___6, (void const   * __restrict  )"[no name]",
                                              __len___6);
              }
              macro_extname->extname = (unsigned char *)__retval___6;
            }
          } else {
            macro_extname->extname = (unsigned char *)__strdup("[no name]");
          }
        } else {
          macro_extname->extname = (unsigned char *)__strdup("[no name]");
        }
        macro_extname->length = (unsigned char)10;
      }
    }
    tmp___49 = cli_readn(fd, (void *)(& macro_extname->numref), 2U);
    if (tmp___49 != 2) {
      cli_dbgmsg("read macro_extnames failed\n");
      return ((macro_extnames_t *)((void *)0));
    }
    macro_extname->numref = vba_endian_convert_16(macro_extname->numref, 0);
    cli_dbgmsg("ext name: %s\n", macro_extname->extname);
  }
  return (macro_extnames);
  abort: 
  if ((unsigned int )macro_extnames->macro_extname != (unsigned int )((void *)0)) {
    i = 0;
    while (i < (int )macro_extnames->count - 1) {
      free((void *)(macro_extnames->macro_extname + i)->extname);
      i ++;
    }
    free((void *)macro_extnames->macro_extname);
  }
  free((void *)macro_extnames);
  return ((macro_extnames_t *)((void *)0));
}
}
static void wm_free_extnames(macro_extnames_t *macro_extnames ) 
{ int i ;

  {
  if (macro_extnames) {
    i = 0;
    while (i < (int )macro_extnames->count) {
      free((void *)(macro_extnames->macro_extname + i)->extname);
      i ++;
    }
    free((void *)macro_extnames->macro_extname);
    free((void *)macro_extnames);
  }
  return;
}
}
static macro_intnames_t *wm_read_macro_intnames(int fd ) 
{ int i ;
  macro_intnames_t *macro_intnames ;
  macro_intname_t *macro_intname ;
  uint16_t junk ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  macro_intnames = (macro_intnames_t *)cli_malloc(sizeof(macro_intnames_t ));
  if (! macro_intnames) {
    return ((macro_intnames_t *)((void *)0));
  }
  tmp___0 = cli_readn(fd, (void *)(& macro_intnames->count), 2U);
  if (tmp___0 != 2) {
    cli_dbgmsg("read macro_intnames failed\n");
    return ((macro_intnames_t *)((void *)0));
  }
  macro_intnames->count = vba_endian_convert_16(macro_intnames->count, 0);
  cli_dbgmsg("int names count: %d\n", macro_intnames->count);
  macro_intnames->macro_intname = (struct macro_intname_tag *)cli_malloc(sizeof(macro_intname_t ) *
                                                                         (unsigned int )macro_intnames->count);
  if (! macro_intnames->macro_intname) {
    free((void *)macro_intnames);
    return ((macro_intnames_t *)((void *)0));
  }
  i = 0;
  while (i < (int )macro_intnames->count) {
    macro_intname = macro_intnames->macro_intname + i;
    tmp___2 = cli_readn(fd, (void *)(& macro_intname->id), 2U);
    if (tmp___2 != 2) {
      cli_dbgmsg("read macro_intnames failed\n");
      macro_intnames->count = (unsigned short )i;
      goto abort;
    }
    macro_intname->id = vba_endian_convert_16(macro_intname->id, 0);
    tmp___3 = cli_readn(fd, (void *)(& macro_intname->length), 1U);
    if (tmp___3 != 1) {
      cli_dbgmsg("read macro_intnames failed\n");
      macro_intnames->count = (unsigned short )i;
      goto abort;
    }
    tmp___4 = cli_malloc((unsigned int )((int )macro_intname->length + 1));
    macro_intname->intname = (unsigned char *)((char *)tmp___4);
    if (! macro_intname->intname) {
      macro_intnames->count = (unsigned short )i;
      goto abort;
    }
    tmp___5 = cli_readn(fd, (void *)macro_intname->intname, (unsigned int )macro_intname->length);
    if (tmp___5 != (int )macro_intname->length) {
      cli_dbgmsg("read macro_intnames failed\n");
      macro_intnames->count = (unsigned short )(i + 1);
      goto abort;
    }
    (*(macro_intname->intname + (int )macro_intname->length)) = (unsigned char )'\000';
    tmp___6 = cli_readn(fd, (void *)(& junk), 1U);
    if (tmp___6 != 1) {
      cli_dbgmsg("read macro_intnames failed\n");
      macro_intnames->count = (unsigned short )(i + 1);
      goto abort;
    }
    cli_dbgmsg("int name: %s\n", macro_intname->intname);
    i ++;
  }
  return (macro_intnames);
  abort: 
  i = 0;
  while (i < (int )macro_intnames->count) {
    free((void *)(macro_intnames->macro_intname + i)->intname);
    i ++;
  }
  free((void *)macro_intnames->macro_intname);
  free((void *)macro_intnames);
  return ((macro_intnames_t *)((void *)0));
}
}
static void wm_free_intnames(macro_intnames_t *macro_intnames ) 
{ int i ;

  {
  if (macro_intnames) {
    i = 0;
    while (i < (int )macro_intnames->count) {
      free((void *)(macro_intnames->macro_intname + i)->intname);
      i ++;
    }
    free((void *)macro_intnames->macro_intname);
    free((void *)macro_intnames);
  }
  return;
}
}
vba_project_t *wm_dir_read(char const   *dir ) 
{ int fd ;
  int done ;
  int i ;
  mso_fib_t fib ;
  off_t end_offset ;
  unsigned char start_id ;
  unsigned char info_id ;
  macro_info_t *macro_info ;
  menu_info_t *menu_info ;
  macro_extnames_t *macro_extnames ;
  macro_intnames_t *macro_intnames ;
  vba_project_t *vba_project ;
  char *fullname ;
  size_t tmp ;
  int tmp___1 ;
  __off_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  __off_t tmp___6 ;
  size_t __len___2 ;
  size_t tmp___25 ;
  char *__retval___2 ;
  char *tmp___26 ;
  int tmp___28 ;
  size_t __len___6 ;
  size_t tmp___48 ;
  char *__retval___6 ;
  char *tmp___49 ;
  int tmp___51 ;

  {
  done = 0;
  macro_info = (macro_info_t *)((void *)0);
  menu_info = (menu_info_t *)((void *)0);
  macro_extnames = (macro_extnames_t *)((void *)0);
  macro_intnames = (macro_intnames_t *)((void *)0);
  vba_project = (vba_project_t *)((void *)0);
  tmp = strlen(dir);
  fullname = (char *)cli_malloc(tmp + 14U);
  if (! fullname) {
    return ((vba_project_t *)((void *)0));
  }
  sprintf((char * __restrict  )fullname, (char const   * __restrict  )"%s/WordDocument",
          dir);
  fd = open((char const   *)fullname, 0);
  free((void *)fullname);
  if (fd == -1) {
    cli_dbgmsg("Open WordDocument failed\n");
    return ((vba_project_t *)((void *)0));
  }
  tmp___1 = wm_read_fib(fd, & fib);
  if (! tmp___1) {
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  wm_print_fib(& fib);
  tmp___2 = lseek(fd, (long )fib.macro_offset, 0);
  if ((long long )tmp___2 != (long long )fib.macro_offset) {
    cli_dbgmsg("lseek macro_offset failed\n");
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  end_offset = (long )(fib.macro_offset + fib.macro_len);
  tmp___3 = cli_readn(fd, (void *)(& start_id), 1U);
  if (tmp___3 != 1) {
    cli_dbgmsg("read start_id failed\n");
    close(fd);
    return ((vba_project_t *)((void *)0));
  }
  cli_dbgmsg("start_id: %d\n", start_id);
  while (1) {
    tmp___6 = lseek(fd, 0L, 1);
    if (tmp___6 < end_offset) {
      if (! (! done)) {
        break;
      }
    } else {
      break;
    }
    tmp___4 = cli_readn(fd, (void *)(& info_id), 1U);
    if (tmp___4 != 1) {
      cli_dbgmsg("read macro_info failed\n");
      close(fd);
      return ((vba_project_t *)((void *)0));
    }
    switch ((int )info_id) {
    case 1: 
    macro_info = wm_read_macro_info(fd);
    if ((unsigned int )macro_info == (unsigned int )((void *)0)) {
      done = 1;
    }
    break;
    case 3: 
    tmp___5 = wm_read_oxo3(fd);
    if (! tmp___5) {
      done = 1;
    }
    break;
    case 5: 
    menu_info = wm_read_menu_info(fd);
    if ((unsigned int )menu_info == (unsigned int )((void *)0)) {
      done = 1;
    }
    break;
    case 16: 
    macro_extnames = wm_read_macro_extnames(fd);
    if ((unsigned int )macro_extnames == (unsigned int )((void *)0)) {
      done = 1;
    }
    break;
    case 17: 
    macro_intnames = wm_read_macro_intnames(fd);
    if ((unsigned int )macro_intnames == (unsigned int )((void *)0)) {
      done = 1;
    }
    break;
    case 18: 
    done = 1;
    break;
    case 64: 
    done = 1;
    break;
    default: 
    cli_dbgmsg("\nunknown type: 0x%x\n", info_id);
    done = 1;
    }
  }
  if (macro_info) {
    vba_project = (vba_project_t *)cli_malloc(sizeof(struct vba_project_tag ));
    if (! vba_project) {
      goto abort;
    }
    vba_project->name = (char **)cli_malloc(sizeof(char *) * (unsigned int )macro_info->count);
    if (! vba_project->name) {
      free((void *)vba_project);
      vba_project = (vba_project_t *)((void *)0);
      goto abort;
    }
    tmp___28 = __builtin_constant_p((int )dir);
    if (tmp___28) {
      if ((unsigned int )((void const   *)(dir + 1)) - (unsigned int )((void const   *)dir) ==
          1U) {
        if ((int const   )(*(dir + 0)) == 0) {
          vba_project->dir = (char *)calloc(1U, 1U);
        } else {
          tmp___25 = strlen(dir);
          __len___2 = tmp___25 + 1U;
          tmp___26 = (char *)malloc(__len___2);
          __retval___2 = tmp___26;
          if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
            __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )dir,
                                          __len___2);
          }
          vba_project->dir = __retval___2;
        }
      } else {
        vba_project->dir = __strdup(dir);
      }
    } else {
      vba_project->dir = __strdup(dir);
    }
    vba_project->offset = (uint32_t *)cli_malloc(sizeof(uint32_t ) * (unsigned int )macro_info->count);
    if (! vba_project->offset) {
      free((void *)vba_project->name);
      free((void *)vba_project->dir);
      free((void *)vba_project);
      vba_project = (vba_project_t *)((void *)0);
      goto abort;
    }
    vba_project->length = (uint32_t *)cli_malloc(sizeof(uint32_t ) * (unsigned int )macro_info->count);
    if (! vba_project->length) {
      free((void *)vba_project->offset);
      free((void *)vba_project->name);
      free((void *)vba_project->dir);
      free((void *)vba_project);
      vba_project = (vba_project_t *)((void *)0);
      goto abort;
    }
    vba_project->key = (unsigned char *)cli_malloc(sizeof(unsigned char ) * (unsigned int )macro_info->count);
    if (! vba_project->key) {
      free((void *)vba_project->length);
      free((void *)vba_project->offset);
      free((void *)vba_project->name);
      free((void *)vba_project->dir);
      free((void *)vba_project);
      vba_project = (vba_project_t *)((void *)0);
      goto abort;
    }
    vba_project->count = (int )macro_info->count;
    i = 0;
    while (i < (int )macro_info->count) {
      tmp___51 = __builtin_constant_p((int )"WordDocument");
      if (tmp___51) {
        if ((unsigned int )((void const   *)("WordDocument" + 1)) - (unsigned int )((void const   *)"WordDocument") ==
            1U) {
          if ((int const   )(*("WordDocument" + 0)) == 0) {
            (*(vba_project->name + i)) = (char *)calloc(1U, 1U);
          } else {
            tmp___48 = strlen("WordDocument");
            __len___6 = tmp___48 + 1U;
            tmp___49 = (char *)malloc(__len___6);
            __retval___6 = tmp___49;
            if ((unsigned int )__retval___6 != (unsigned int )((void *)0)) {
              __retval___6 = (char *)memcpy((void * __restrict  )__retval___6, (void const   * __restrict  )"WordDocument",
                                            __len___6);
            }
            (*(vba_project->name + i)) = __retval___6;
          }
        } else {
          (*(vba_project->name + i)) = __strdup("WordDocument");
        }
      } else {
        (*(vba_project->name + i)) = __strdup("WordDocument");
      }
      (*(vba_project->offset + i)) = (macro_info->macro_entry + i)->offset;
      (*(vba_project->length + i)) = (macro_info->macro_entry + i)->len;
      (*(vba_project->key + i)) = (macro_info->macro_entry + i)->key;
      i ++;
    }
  }
  abort: 
  if (macro_info) {
    wm_free_macro_info(macro_info);
  }
  if (menu_info) {
    wm_free_menu_info(menu_info);
  }
  if (macro_extnames) {
    wm_free_extnames(macro_extnames);
  }
  if (macro_intnames) {
    wm_free_intnames(macro_intnames);
  }
  close(fd);
  return (vba_project);
}
}
unsigned char *wm_decrypt_macro(int fd , uint32_t offset , uint32_t len , unsigned char key ) 
{ unsigned char *buff ;
  uint32_t i ;
  __off_t tmp ;
  int tmp___1 ;

  {
  tmp = lseek(fd, (long )offset, 0);
  if ((long long )tmp != (long long )offset) {
    return ((unsigned char *)((void *)0));
  }
  buff = (unsigned char *)cli_malloc(len);
  if (! buff) {
    return ((unsigned char *)((void *)0));
  }
  tmp___1 = cli_readn(fd, (void *)buff, len);
  if ((long long )tmp___1 != (long long )len) {
    free((void *)buff);
    return ((unsigned char *)((void *)0));
  }
  if ((int )key != 0) {
    i = 0U;
    while (i < len) {
      (*(buff + i)) = (unsigned char )((int )(*(buff + i)) ^ (int )key);
      i ++;
    }
  }
  return (buff);
}
}
#pragma merger(0,"/tmp/cil-TsTYMxSq.i","-g -O2 -fPIC")
extern int fgetc(FILE *__stream ) ;
int cli_msexpand(FILE *in , FILE *out ) 
{ int bits ;
  int ch ;
  int i ;
  int j ;
  int len ;
  int mask ;
  unsigned char *buffer ;
  uint32_t magic1 ;
  uint32_t magic2 ;
  uint32_t magic3 ;
  uint32_t filesize ;
  uint16_t reserved ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;

  {
  tmp = fread((void * __restrict  )(& magic1), sizeof(magic1), 1U, (FILE * __restrict  )in);
  if (tmp != 1U) {
    return (-1);
  }
  if ((unsigned long )magic1 == 1398424644UL) {
    tmp___0 = fread((void * __restrict  )(& magic2), sizeof(magic2), 1U, (FILE * __restrict  )in);
    if (tmp___0 != 1U) {
      return (-1);
    }
    tmp___1 = fread((void * __restrict  )(& reserved), sizeof(reserved), 1U, (FILE * __restrict  )in);
    if (tmp___1 != 1U) {
      return (-1);
    }
    tmp___2 = fread((void * __restrict  )(& filesize), sizeof(filesize), 1U, (FILE * __restrict  )in);
    if (tmp___2 != 1U) {
      return (-1);
    }
    if ((unsigned long )magic2 != 2297440051UL) {
      cli_warnmsg("msexpand: Not a MS-compressed file\n");
      return (-1);
    }
  } else {
    if ((unsigned long )magic1 == 1264009546UL) {
      tmp___3 = fread((void * __restrict  )(& magic2), sizeof(magic2), 1U, (FILE * __restrict  )in);
      if (tmp___3 != 1U) {
        return (-1);
      }
      tmp___4 = fread((void * __restrict  )(& magic3), sizeof(magic3), 1U, (FILE * __restrict  )in);
      if (tmp___4 != 1U) {
        return (-1);
      }
      tmp___5 = fread((void * __restrict  )(& reserved), sizeof(reserved), 1U, (FILE * __restrict  )in);
      if (tmp___5 != 1U) {
        return (-1);
      }
      if ((unsigned long )magic2 != 2297440209UL) {
        cli_warnmsg("msexpand: Not a MS-compressed file\n");
        return (-1);
      } else {
        if ((unsigned long )magic3 != 50336256UL) {
          cli_warnmsg("msexpand: Not a MS-compressed file\n");
          return (-1);
        }
      }
      cli_warnmsg("msexpand: unsupported version 6.22\n");
      return (-1);
    } else {
      cli_warnmsg("msexpand: Not a MS-compressed file\n");
      return (-1);
    }
  }
  buffer = (unsigned char *)cli_calloc(4096U, sizeof(char ));
  if ((unsigned int )buffer == (unsigned int )((void *)0)) {
    cli_errmsg("msexpand: Can\'t allocate memory\n");
    return (-1);
  }
  i = 4080;
  while (1) {
    bits = fgetc(in);
    if (bits == -1) {
      break;
    }
    mask = 1;
    while (mask & 255) {
      if (! (bits & mask)) {
        j = fgetc(in);
        if (j == -1) {
          break;
        }
        len = fgetc(in);
        j += (len & 240) << 4;
        len = (len & 15) + 3;
        while (1) {
          tmp___8 = len;
          len --;
          if (! tmp___8) {
            break;
          }
          (*(buffer + i)) = (*(buffer + j));
          tmp___7 = fwrite((void const   * __restrict  )(buffer + i), sizeof(unsigned char ),
                           1U, (FILE * __restrict  )out);
          if (tmp___7 != 1U) {
            free((void *)buffer);
            return (-1);
          }
          j ++;
          j %= 4096;
          i ++;
          i %= 4096;
        }
      } else {
        ch = fgetc(in);
        if (ch == -1) {
          break;
        }
        (*(buffer + i)) = (unsigned char )ch;
        tmp___9 = fwrite((void const   * __restrict  )(buffer + i), sizeof(unsigned char ),
                         1U, (FILE * __restrict  )out);
        if (tmp___9 != 1U) {
          free((void *)buffer);
          return (-1);
        }
        i ++;
        i %= 4096;
      }
      mask <<= 1;
    }
  }
  free((void *)buffer);
  return (0);
}
}
#pragma merger(0,"/tmp/cil-zQxPNCTc.i","-g -O2 -fPIC")
int upx_inflate2b(char *src , int ssize , char *dst , int *dsize , uint32_t upx0 ,
                  uint32_t upx1 , uint32_t ep ) ;
int upx_inflate2d(char *src , int ssize , char *dst , int *dsize , uint32_t upx0 ,
                  uint32_t upx1 , uint32_t ep ) ;
int upx_inflate2e(char *src , int ssize , char *dst , int *dsize , uint32_t upx0 ,
                  uint32_t upx1 , uint32_t ep ) ;
int petite_inflate2x_1to9(char *buf , uint32_t minrva , int bufsz , struct pe_image_section_hdr *sections ,
                          int sectcount , uint32_t Imagebase , uint32_t pep , int desc ,
                          int version , uint32_t ResRva , uint32_t ResSize ) ;
int unfsg_200(char *source , char *dest , int ssize , int dsize ) ;
int unfsg_133(char *source , char *dest , int ssize , int dsize , struct SECTION *sections ,
              int sectcount , uint32_t base , uint32_t ep , int file ) ;
__inline static uint16_t EC16(uint16_t v ) 
{ 

  {
  return ((unsigned short )(((int )v >> 8) + ((int )v << 8)));
}
}
__inline static uint32_t EC32(uint32_t v ) 
{ 

  {
  return ((((v >> 24) | ((v & 16711680U) >> 8)) | ((v & 65280U) << 8)) | (v << 24));
}
}
static uint32_t cli_rawaddr(uint32_t rva , struct pe_image_section_hdr *shp , uint16_t nos ,
                            unsigned int *err ) 
{ int i ;
  int found ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;

  {
  found = 0;
  i = 0;
  while (i < (int )nos) {
    tmp = EC32((shp + i)->VirtualAddress);
    if (tmp <= rva) {
      tmp___0 = EC32((shp + i)->VirtualAddress);
      tmp___1 = EC32((shp + i)->SizeOfRawData);
      if (tmp___0 + tmp___1 > rva) {
        found = 1;
        break;
      }
    }
    i ++;
  }
  if (! found) {
    cli_dbgmsg("Can\'t calculate raw address from RVA 0x%x\n", rva);
    (*err) = 1U;
    return (0U);
  }
  (*err) = 0U;
  tmp___2 = EC32((shp + i)->VirtualAddress);
  tmp___3 = EC32((shp + i)->PointerToRawData);
  return ((rva - tmp___2) + tmp___3);
}
}
int cli_scanpe(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
               struct cl_limits  const  *limits , unsigned int options , unsigned int arec ,
               unsigned int mrec ) 
{ uint16_t e_magic ;
  uint16_t nsections ;
  uint32_t e_lfanew ;
  uint32_t ep ;
  time_t timestamp ;
  struct pe_image_file_hdr file_hdr ;
  struct pe_image_optional_hdr optional_hdr ;
  struct pe_image_section_hdr *section_hdr ;
  struct stat sb ;
  char sname[9] ;
  char buff[4096] ;
  char *tempfile ;
  unsigned int i ;
  unsigned int found ;
  unsigned int upx_success ;
  unsigned int min ;
  unsigned int max ;
  unsigned int err ;
  unsigned int broken ;
  unsigned int ssize ;
  unsigned int dsize ;
  unsigned int dll ;
  int (*upxfn)(char * , int  , char * , int * , uint32_t  , uint32_t  , uint32_t  ) ;
  char *src ;
  char *dest ;
  int ndesc ;
  int ret ;
  ssize_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  ssize_t tmp___2 ;
  __off_t tmp___3 ;
  ssize_t tmp___4 ;
  uint32_t tmp___5 ;
  uint16_t tmp___6 ;
  uint16_t tmp___7 ;
  int tmp___8 ;
  uint16_t tmp___9 ;
  char *tmp___11 ;
  uint16_t tmp___12 ;
  uint16_t tmp___13 ;
  ssize_t tmp___14 ;
  uint32_t tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t tmp___19 ;
  uint32_t tmp___20 ;
  uint16_t tmp___21 ;
  uint16_t tmp___22 ;
  uint32_t tmp___23 ;
  uint32_t tmp___24 ;
  int tmp___25 ;
  uint16_t tmp___26 ;
  uint32_t tmp___27 ;
  int tmp___28 ;
  ssize_t tmp___30 ;
  uint32_t tmp___31 ;
  uint32_t tmp___32 ;
  uint32_t tmp___33 ;
  uint32_t tmp___34 ;
  uint32_t tmp___35 ;
  uint32_t tmp___36 ;
  uint32_t tmp___37 ;
  uint32_t tmp___38 ;
  uint32_t tmp___39 ;
  uint32_t tmp___40 ;
  uint32_t tmp___41 ;
  uint32_t tmp___42 ;
  uint32_t tmp___43 ;
  uint32_t tmp___44 ;
  uint32_t tmp___45 ;
  uint32_t tmp___46 ;
  uint32_t tmp___47 ;
  uint32_t tmp___48 ;
  uint32_t tmp___49 ;
  uint32_t tmp___50 ;
  uint32_t tmp___51 ;
  uint32_t tmp___52 ;
  char const   *pt ;
  char const   *tmp___53 ;
  uint32_t dw1 ;
  uint32_t dw2 ;
  ssize_t tmp___54 ;
  uint32_t tmp___55 ;
  uint32_t rsize ;
  uint32_t vsize ;
  int bw ;
  uint32_t tmp___56 ;
  uint32_t tmp___57 ;
  char const   *tmp___58 ;
  ssize_t tmp___59 ;
  int bw___0 ;
  uint32_t tmp___60 ;
  uint32_t tmp___61 ;
  char const   *tmp___62 ;
  ssize_t tmp___63 ;
  uint32_t tmp___64 ;
  __off_t tmp___65 ;
  ssize_t tmp___66 ;
  uint32_t newesi ;
  uint32_t newedi ;
  uint32_t newebx ;
  uint32_t newedx ;
  int32_t tmp___67 ;
  uint32_t tmp___68 ;
  uint32_t tmp___69 ;
  uint32_t tmp___70 ;
  uint32_t tmp___71 ;
  __off_t tmp___73 ;
  ssize_t tmp___74 ;
  uint32_t tmp___75 ;
  uint32_t tmp___76 ;
  uint32_t tmp___77 ;
  uint32_t tmp___78 ;
  int32_t tmp___79 ;
  uint32_t tmp___80 ;
  uint32_t tmp___81 ;
  uint32_t tmp___82 ;
  uint32_t tmp___83 ;
  uint32_t tmp___84 ;
  uint32_t tmp___85 ;
  uint32_t tmp___86 ;
  int32_t tmp___87 ;
  uint32_t tmp___88 ;
  int32_t tmp___89 ;
  uint32_t tmp___90 ;
  int32_t tmp___91 ;
  uint32_t tmp___92 ;
  uint32_t tmp___93 ;
  uint32_t tmp___94 ;
  uint32_t tmp___95 ;
  uint32_t tmp___96 ;
  uint32_t tmp___97 ;
  uint32_t tmp___98 ;
  uint32_t tmp___99 ;
  uint32_t tmp___100 ;
  uint32_t tmp___101 ;
  int32_t tmp___102 ;
  uint32_t tmp___103 ;
  uint32_t tmp___105 ;
  uint32_t tmp___106 ;
  int tmp___107 ;
  int gp ;
  int t ;
  int sectcnt ;
  char *support ;
  uint32_t newesi___0 ;
  uint32_t newedi___0 ;
  uint32_t newebx___0 ;
  uint32_t oldep ;
  struct SECTION *sections ;
  uint32_t tmp___108 ;
  int32_t tmp___109 ;
  uint32_t tmp___110 ;
  uint32_t tmp___111 ;
  uint32_t tmp___112 ;
  ssize_t tmp___114 ;
  int32_t tmp___115 ;
  uint32_t tmp___116 ;
  int32_t tmp___117 ;
  uint32_t tmp___118 ;
  int32_t tmp___119 ;
  uint32_t tmp___120 ;
  uint32_t tmp___121 ;
  uint32_t tmp___122 ;
  uint32_t tmp___123 ;
  uint32_t tmp___124 ;
  uint32_t tmp___125 ;
  uint32_t rva ;
  uint32_t tmp___126 ;
  uint32_t tmp___127 ;
  uint32_t tmp___128 ;
  uint32_t tmp___129 ;
  uint32_t tmp___130 ;
  int32_t tmp___131 ;
  int32_t tmp___133 ;
  uint32_t tmp___134 ;
  __off_t tmp___136 ;
  ssize_t tmp___137 ;
  uint32_t tmp___139 ;
  int32_t tmp___140 ;
  uint32_t tmp___141 ;
  uint32_t tmp___142 ;
  uint32_t tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int32_t tmp___146 ;
  uint32_t tmp___147 ;
  int gp___0 ;
  int32_t tmp___148 ;
  uint32_t tmp___149 ;
  int t___0 ;
  int sectcnt___0 ;
  char *support___0 ;
  uint32_t newesi___1 ;
  int32_t tmp___150 ;
  uint32_t tmp___151 ;
  uint32_t newedi___1 ;
  int32_t tmp___152 ;
  uint32_t tmp___153 ;
  uint32_t oldep___0 ;
  uint32_t tmp___154 ;
  struct SECTION *sections___0 ;
  uint32_t tmp___155 ;
  uint32_t tmp___156 ;
  uint32_t tmp___157 ;
  uint32_t tmp___158 ;
  uint32_t tmp___159 ;
  uint32_t tmp___160 ;
  uint32_t tmp___161 ;
  uint32_t tmp___162 ;
  uint32_t tmp___163 ;
  uint32_t tmp___164 ;
  uint32_t tmp___165 ;
  uint32_t tmp___166 ;
  ssize_t tmp___168 ;
  uint32_t rva___0 ;
  uint32_t tmp___169 ;
  uint32_t tmp___170 ;
  uint32_t tmp___171 ;
  uint32_t tmp___172 ;
  int32_t tmp___173 ;
  uint32_t tmp___175 ;
  __off_t tmp___177 ;
  ssize_t tmp___178 ;
  uint32_t tmp___180 ;
  int32_t tmp___181 ;
  uint32_t tmp___182 ;
  uint32_t tmp___183 ;
  uint32_t tmp___184 ;
  int tmp___185 ;
  int tmp___186 ;
  int32_t tmp___187 ;
  uint32_t tmp___188 ;
  int tmp___263 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___299 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___318 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___327 ;
  int tmp___328 ;
  int tmp___329 ;
  int tmp___330 ;
  int tmp___331 ;
  int tmp___332 ;
  int tmp___333 ;
  size_t tmp___334 ;
  int tmp___335 ;
  size_t tmp___336 ;
  int tmp___411 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___447 ;
  unsigned char const   *__s2___30 ;
  register int __result___90 ;
  int tmp___466 ;
  unsigned char const   *__s1___62 ;
  register int __result___94 ;
  int tmp___475 ;
  int tmp___476 ;
  int tmp___477 ;
  int tmp___478 ;
  int tmp___479 ;
  int tmp___480 ;
  int tmp___481 ;
  size_t tmp___482 ;
  int tmp___483 ;
  size_t tmp___484 ;
  uint32_t tmp___485 ;
  uint32_t tmp___486 ;
  __off_t tmp___489 ;
  ssize_t tmp___490 ;
  __off_t tmp___491 ;
  char const   *tmp___492 ;
  char const   *tmp___493 ;
  char const   *tmp___494 ;
  char const   *tmp___495 ;
  char const   *tmp___496 ;
  char const   *tmp___497 ;
  ssize_t tmp___498 ;
  int skew ;
  int32_t tmp___499 ;
  uint32_t tmp___500 ;
  uint32_t tmp___501 ;
  uint32_t tmp___502 ;
  uint32_t tmp___503 ;
  uint32_t tmp___504 ;
  int tmp___505 ;
  uint32_t tmp___506 ;
  uint32_t tmp___507 ;
  uint32_t tmp___508 ;
  int tmp___509 ;
  uint32_t tmp___510 ;
  uint32_t tmp___511 ;
  uint32_t tmp___512 ;
  int tmp___513 ;
  uint32_t tmp___514 ;
  uint32_t tmp___515 ;
  uint32_t tmp___516 ;
  int tmp___517 ;
  uint32_t tmp___518 ;
  uint32_t tmp___519 ;
  uint32_t tmp___520 ;
  int tmp___521 ;
  uint32_t tmp___522 ;
  uint32_t tmp___523 ;
  uint32_t tmp___524 ;
  int tmp___525 ;
  uint32_t tmp___526 ;
  uint32_t tmp___527 ;
  uint32_t tmp___528 ;
  int tmp___529 ;
  uint32_t tmp___530 ;
  uint32_t tmp___531 ;
  uint32_t tmp___532 ;
  int tmp___533 ;
  uint32_t tmp___534 ;
  uint32_t tmp___535 ;
  uint32_t tmp___536 ;
  int tmp___537 ;
  ssize_t tmp___538 ;
  ssize_t tmp___539 ;
  int32_t tmp___540 ;
  uint32_t tmp___541 ;
  uint32_t tmp___542 ;
  int32_t tmp___543 ;
  uint32_t tmp___544 ;
  uint32_t tmp___545 ;
  uint32_t offset ;
  uint32_t tmp___547 ;
  uint32_t tmp___548 ;
  __off_t tmp___549 ;
  size_t tmp___550 ;
  uint32_t tmp___551 ;
  ssize_t tmp___552 ;
  uint32_t tmp___553 ;
  uint32_t tmp___554 ;
  uint32_t tmp___555 ;
  uint32_t tmp___556 ;
  uint32_t tmp___557 ;
  int tmp___558 ;
  int tmp___559 ;
  int tmp___560 ;
  int32_t tmp___561 ;

  {
  upx_success = 0U;
  min = 0U;
  max = 0U;
  broken = 0U;
  ssize = 0U;
  dsize = 0U;
  dll = 0U;
  upxfn = (int (*)(char * , int  , char * , int * , uint32_t  , uint32_t  , uint32_t  ))((void *)0);
  src = (char *)((void *)0);
  dest = (char *)((void *)0);
  tmp = read(desc, (void *)(& e_magic), sizeof(e_magic));
  if ((unsigned int )tmp != sizeof(e_magic)) {
    cli_dbgmsg("Can\'t read DOS signature\n");
    return (0);
  }
  tmp___0 = EC16(e_magic);
  if ((int )tmp___0 != 23117) {
    tmp___1 = EC16(e_magic);
    if ((int )tmp___1 != 19802) {
      cli_dbgmsg("Invalid DOS signature\n");
      return (0);
    }
  }
  lseek(desc, 58L, 1);
  tmp___2 = read(desc, (void *)(& e_lfanew), sizeof(e_lfanew));
  if ((unsigned int )tmp___2 != sizeof(e_lfanew)) {
    cli_dbgmsg("Can\'t read new header address\n");
    if (options & 128U) {
      if (virname) {
        (*virname) = "Broken.Executable";
      }
      return (1);
    }
    return (0);
  }
  e_lfanew = EC32(e_lfanew);
  cli_dbgmsg("e_lfanew == %d\n", e_lfanew);
  if (! e_lfanew) {
    cli_dbgmsg("Not a PE file\n");
    return (0);
  }
  tmp___3 = lseek(desc, (long )e_lfanew, 0);
  if (tmp___3 < 0L) {
    cli_dbgmsg("Can\'t lseek to e_lfanew\n");
    return (0);
  }
  tmp___4 = read(desc, (void *)(& file_hdr), sizeof(struct pe_image_file_hdr ));
  if ((unsigned int )tmp___4 != sizeof(struct pe_image_file_hdr )) {
    cli_dbgmsg("Can\'t read file header\n");
    return (0);
  }
  tmp___5 = EC32(file_hdr.Magic);
  if (tmp___5 != 17744U) {
    cli_dbgmsg("Invalid PE signature (probably NE file)\n");
    return (0);
  }
  tmp___7 = EC16(file_hdr.Characteristics);
  if ((int )tmp___7 & 8192) {
    cli_dbgmsg("File type: DLL\n");
    dll = 1U;
  } else {
    tmp___6 = EC16(file_hdr.Characteristics);
    if ((int )tmp___6 & 1) {
      cli_dbgmsg("File type: Executable\n");
    }
  }
  tmp___8 = (int )EC16(file_hdr.Machine);
  switch (tmp___8) {
  case 0: 
  cli_dbgmsg("Machine type: Unknown\n");
  case 332: 
  cli_dbgmsg("Machine type: 80386\n");
  break;
  case 333: 
  cli_dbgmsg("Machine type: 80486\n");
  break;
  case 334: 
  cli_dbgmsg("Machine type: 80586\n");
  break;
  case 352: 
  cli_dbgmsg("Machine type: R30000 (big-endian)\n");
  break;
  case 354: 
  cli_dbgmsg("Machine type: R3000\n");
  break;
  case 358: 
  cli_dbgmsg("Machine type: R4000\n");
  break;
  case 360: 
  cli_dbgmsg("Machine type: R10000\n");
  break;
  case 388: 
  cli_dbgmsg("Machine type: DEC Alpha AXP\n");
  break;
  case 644: 
  cli_dbgmsg("Machine type: DEC Alpha AXP 64bit\n");
  break;
  case 496: 
  cli_dbgmsg("Machine type: PowerPC\n");
  break;
  case 512: 
  cli_dbgmsg("Machine type: IA64\n");
  break;
  case 616: 
  cli_dbgmsg("Machine type: M68k\n");
  break;
  case 614: 
  cli_dbgmsg("Machine type: MIPS16\n");
  break;
  case 870: 
  cli_dbgmsg("Machine type: MIPS+FPU\n");
  break;
  case 1126: 
  cli_dbgmsg("Machine type: MIPS16+FPU\n");
  break;
  case 418: 
  cli_dbgmsg("Machine type: Hitachi SH3\n");
  break;
  case 419: 
  cli_dbgmsg("Machine type: Hitachi SH3-DSP\n");
  break;
  case 420: 
  cli_dbgmsg("Machine type: Hitachi SH3-E\n");
  break;
  case 422: 
  cli_dbgmsg("Machine type: Hitachi SH4\n");
  break;
  case 424: 
  cli_dbgmsg("Machine type: Hitachi SH5\n");
  break;
  case 448: 
  cli_dbgmsg("Machine type: ARM\n");
  break;
  case 450: 
  cli_dbgmsg("Machine type: THUMB\n");
  break;
  case 467: 
  cli_dbgmsg("Machine type: AM33\n");
  break;
  case 1312: 
  cli_dbgmsg("Machine type: Infineon TriCore\n");
  break;
  case 3311: 
  cli_dbgmsg("Machine type: CEF\n");
  break;
  case 3772: 
  cli_dbgmsg("Machine type: EFI Byte Code\n");
  break;
  case 36929: 
  cli_dbgmsg("Machine type: M32R\n");
  break;
  case 49390: 
  cli_dbgmsg("Machine type: CEE\n");
  break;
  case 34404: 
  cli_dbgmsg("Machine type: AMD64\n");
  break;
  default: 
  tmp___9 = EC16(file_hdr.Machine);
  cli_warnmsg("Unknown machine type in PE header (0x%x)\n", tmp___9);
  }
  nsections = EC16(file_hdr.NumberOfSections);
  if ((int )nsections < 1) {
    if (options & 128U) {
      if (virname) {
        (*virname) = "Broken.Executable";
      }
      return (1);
    }
    cli_warnmsg("PE file contains no sections\n");
    return (0);
  }
  cli_dbgmsg("NumberOfSections: %d\n", nsections);
  timestamp = (time_t )EC32(file_hdr.TimeDateStamp);
  tmp___11 = ctime((time_t const   *)(& timestamp));
  cli_dbgmsg("TimeDateStamp: %s", tmp___11);
  tmp___12 = EC16(file_hdr.SizeOfOptionalHeader);
  cli_dbgmsg("SizeOfOptionalHeader: %d\n", tmp___12);
  tmp___13 = EC16(file_hdr.SizeOfOptionalHeader);
  if ((unsigned int )tmp___13 != sizeof(struct pe_image_optional_hdr )) {
    cli_warnmsg("Broken PE header detected.\n");
    if (options & 128U) {
      if (virname) {
        (*virname) = "Broken.Executable";
      }
      return (1);
    }
    return (0);
  }
  tmp___14 = read(desc, (void *)(& optional_hdr), sizeof(struct pe_image_optional_hdr ));
  if ((unsigned int )tmp___14 != sizeof(struct pe_image_optional_hdr )) {
    cli_dbgmsg("Can\'t optional file header\n");
    if (options & 128U) {
      if (virname) {
        (*virname) = "Broken.Executable";
      }
      return (1);
    }
    return (0);
  }
  cli_dbgmsg("MajorLinkerVersion: %d\n", optional_hdr.MajorLinkerVersion);
  cli_dbgmsg("MinorLinkerVersion: %d\n", optional_hdr.MinorLinkerVersion);
  tmp___15 = EC32(optional_hdr.SizeOfCode);
  cli_dbgmsg("SizeOfCode: %d\n", tmp___15);
  tmp___16 = EC32(optional_hdr.SizeOfInitializedData);
  cli_dbgmsg("SizeOfInitializedData: %d\n", tmp___16);
  tmp___17 = EC32(optional_hdr.SizeOfUninitializedData);
  cli_dbgmsg("SizeOfUninitializedData: %d\n", tmp___17);
  tmp___18 = EC32(optional_hdr.AddressOfEntryPoint);
  cli_dbgmsg("AddressOfEntryPoint: 0x%x\n", tmp___18);
  tmp___19 = EC32(optional_hdr.SectionAlignment);
  cli_dbgmsg("SectionAlignment: %d\n", tmp___19);
  tmp___20 = EC32(optional_hdr.FileAlignment);
  cli_dbgmsg("FileAlignment: %d\n", tmp___20);
  tmp___21 = EC16(optional_hdr.MajorSubsystemVersion);
  cli_dbgmsg("MajorSubsystemVersion: %d\n", tmp___21);
  tmp___22 = EC16(optional_hdr.MinorSubsystemVersion);
  cli_dbgmsg("MinorSubsystemVersion: %d\n", tmp___22);
  tmp___23 = EC32(optional_hdr.SizeOfImage);
  cli_dbgmsg("SizeOfImage: %d\n", tmp___23);
  tmp___24 = EC32(optional_hdr.SizeOfHeaders);
  cli_dbgmsg("SizeOfHeaders: %d\n", tmp___24);
  tmp___25 = (int )EC16(optional_hdr.Subsystem);
  switch (tmp___25) {
  case 0: 
  cli_dbgmsg("Subsystem: Unknown\n");
  break;
  case 1: 
  cli_dbgmsg("Subsystem: Native (a driver ?)\n");
  break;
  case 2: 
  cli_dbgmsg("Subsystem: Win32 GUI\n");
  break;
  case 3: 
  cli_dbgmsg("Subsystem: Win32 console\n");
  break;
  case 5: 
  cli_dbgmsg("Subsystem: OS/2 console\n");
  break;
  case 7: 
  cli_dbgmsg("Subsystem: POSIX console\n");
  break;
  case 8: 
  cli_dbgmsg("Subsystem: Native Win9x driver\n");
  break;
  case 9: 
  cli_dbgmsg("Subsystem: WinCE GUI\n");
  break;
  case 10: 
  cli_dbgmsg("Subsystem: EFI application\n");
  break;
  case 11: 
  cli_dbgmsg("Subsystem: EFI driver\n");
  break;
  case 12: 
  cli_dbgmsg("Subsystem: EFI runtime driver\n");
  break;
  default: 
  tmp___26 = EC16(optional_hdr.Subsystem);
  cli_warnmsg("Unknown subsystem in PE header (0x%x)\n", tmp___26);
  }
  tmp___27 = EC32(optional_hdr.NumberOfRvaAndSizes);
  cli_dbgmsg("NumberOfRvaAndSizes: %d\n", tmp___27);
  cli_dbgmsg("------------------------------------\n");
  tmp___28 = fstat__extinline(desc, & sb);
  if (tmp___28 == -1) {
    cli_dbgmsg("fstat failed\n");
    return (-12);
  }
  section_hdr = (struct pe_image_section_hdr *)cli_calloc((unsigned int )nsections,
                                                          sizeof(struct pe_image_section_hdr ));
  if (! section_hdr) {
    cli_dbgmsg("Can\'t allocate memory for section headers\n");
    return (-3);
  }
  i = 0U;
  while (i < (unsigned int )nsections) {
    tmp___30 = read(desc, (void *)(section_hdr + i), sizeof(struct pe_image_section_hdr ));
    if ((unsigned int )tmp___30 != sizeof(struct pe_image_section_hdr )) {
      cli_dbgmsg("Can\'t read section header\n");
      cli_dbgmsg("Possibly broken PE file\n");
      free((void *)section_hdr);
      if (options & 128U) {
        if (virname) {
          (*virname) = "Broken.Executable";
        }
        return (1);
      }
      return (0);
    }
    __builtin_strncpy(sname, (section_hdr + i)->Name, 8);
    sname[8] = (char)0;
    cli_dbgmsg("Section %d\n", i);
    cli_dbgmsg("Section name: %s\n", sname);
    tmp___31 = EC32((section_hdr + i)->VirtualSize);
    cli_dbgmsg("VirtualSize: %d\n", tmp___31);
    tmp___32 = EC32((section_hdr + i)->VirtualAddress);
    cli_dbgmsg("VirtualAddress: 0x%x\n", tmp___32);
    tmp___33 = EC32((section_hdr + i)->SizeOfRawData);
    cli_dbgmsg("SizeOfRawData: %d\n", tmp___33);
    tmp___34 = EC32((section_hdr + i)->PointerToRawData);
    tmp___35 = EC32((section_hdr + i)->PointerToRawData);
    cli_dbgmsg("PointerToRawData: 0x%x (%d)\n", tmp___35, tmp___34);
    tmp___38 = EC32((section_hdr + i)->Characteristics);
    if (tmp___38 & 32U) {
      cli_dbgmsg("Section contains executable code\n");
      tmp___36 = EC32((section_hdr + i)->VirtualSize);
      tmp___37 = EC32((section_hdr + i)->SizeOfRawData);
      if (tmp___36 < tmp___37) {
        cli_dbgmsg("Section contains free space\n");
      }
    }
    tmp___39 = EC32((section_hdr + i)->Characteristics);
    if (tmp___39 & 536870912U) {
      cli_dbgmsg("Section\'s memory is executable\n");
    }
    tmp___40 = EC32((section_hdr + i)->Characteristics);
    if (tmp___40 & 2147483648U) {
      cli_dbgmsg("Section\'s memory is writeable\n");
    }
    cli_dbgmsg("------------------------------------\n");
    tmp___43 = EC32((section_hdr + i)->PointerToRawData);
    tmp___44 = EC32((section_hdr + i)->SizeOfRawData);
    if ((unsigned long )(tmp___43 + tmp___44) > (unsigned long )sb.st_size) {
      tmp___41 = EC32((section_hdr + i)->SizeOfRawData);
      tmp___42 = EC32((section_hdr + i)->PointerToRawData);
      cli_dbgmsg("Possibly broken PE file - Section %d out of file (Offset@ %d, Rsize %d, Total filesize %d)\n",
                 i, tmp___42, tmp___41, sb.st_size);
      if (options & 128U) {
        if (virname) {
          (*virname) = "Broken.Executable";
        }
        free((void *)section_hdr);
        return (1);
      }
      broken = 1U;
    }
    if (! i) {
      min = EC32((section_hdr + i)->VirtualAddress);
      tmp___45 = EC32((section_hdr + i)->VirtualAddress);
      tmp___46 = EC32((section_hdr + i)->SizeOfRawData);
      max = tmp___45 + tmp___46;
    } else {
      tmp___47 = EC32((section_hdr + i)->VirtualAddress);
      if (tmp___47 < min) {
        min = EC32((section_hdr + i)->VirtualAddress);
      }
      tmp___50 = EC32((section_hdr + i)->VirtualAddress);
      tmp___51 = EC32((section_hdr + i)->SizeOfRawData);
      if (tmp___50 + tmp___51 > max) {
        tmp___48 = EC32((section_hdr + i)->VirtualAddress);
        tmp___49 = EC32((section_hdr + i)->SizeOfRawData);
        max = tmp___48 + tmp___49;
      }
    }
    i ++;
  }
  ep = EC32(optional_hdr.AddressOfEntryPoint);
  if (ep >= min) {
    tmp___52 = EC32(optional_hdr.AddressOfEntryPoint);
    ep = cli_rawaddr(tmp___52, section_hdr, nsections, & err);
    if (! ep) {
      if (err) {
        cli_dbgmsg("Possibly broken PE file\n");
        free((void *)section_hdr);
        if (options & 128U) {
          if (virname) {
            (*virname) = "Broken.Executable";
          }
          return (1);
        }
        return (0);
      }
    }
  }
  cli_dbgmsg("EntryPoint offset: 0x%x (%d)\n", ep, ep);
  if (! dll) {
    tmp___55 = EC32((section_hdr + ((int )nsections - 1))->PointerToRawData);
    if (ep == tmp___55) {
      lseek(desc, (long )ep, 0);
      tmp___54 = read(desc, (void *)(buff), 4096U);
      if (tmp___54 == 4096) {
        tmp___53 = cli_memstr((char const   *)(buff), 4040, "GetProcAddress\000",
                              15);
        pt = tmp___53;
        if (pt) {
          pt += 15;
          dw1 = (uint32_t )cli_readint32(pt);
          dw2 = (uint32_t )cli_readint32(pt + 4);
          if ((dw1 ^ dw2) == 5265999U) {
            dw1 = (uint32_t )cli_readint32(pt + 8);
            dw2 = (uint32_t )cli_readint32(pt + 12);
            if ((dw1 ^ dw2) == 1048571U) {
              dw1 = (uint32_t )cli_readint32(pt + 16);
              dw2 = (uint32_t )cli_readint32(pt + 20);
              if ((dw1 ^ dw2) == 184U) {
                (*virname) = "W32.Parite.B";
                free((void *)section_hdr);
                return (1);
              }
            }
          }
        }
      }
    }
  }
  if (! dll) {
    tmp___64 = EC32((section_hdr + ((int )nsections - 1))->Characteristics);
    if (tmp___64 & 2147483648U) {
      rsize = EC32((section_hdr + ((int )nsections - 1))->SizeOfRawData);
      vsize = EC32((section_hdr + ((int )nsections - 1))->VirtualSize);
      if (rsize >= 24876U) {
        if (vsize >= 24876U) {
          if ((vsize & 255U) == 236U) {
            if (rsize < 28672U) {
              tmp___56 = rsize;
            } else {
              tmp___56 = 28672U;
            }
            bw = (int )tmp___56;
            tmp___57 = EC32((section_hdr + ((int )nsections - 1))->PointerToRawData);
            lseek(desc, (long )((tmp___57 + rsize) - (unsigned int )bw), 0);
            tmp___59 = read(desc, (void *)(buff), 4096U);
            if (tmp___59 == 4096) {
              tmp___58 = cli_memstr((char const   *)(buff), 4091, "\350,a\000\000",
                                    5);
              if (tmp___58) {
                (*virname) = "W32.Magistr.A";
                free((void *)section_hdr);
                return (1);
              }
            }
          } else {
            goto _L___0;
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
        if (rsize >= 28672U) {
          if (vsize >= 28672U) {
            if ((vsize & 255U) == 237U) {
              if (rsize < 32768U) {
                tmp___60 = rsize;
              } else {
                tmp___60 = 32768U;
              }
              bw___0 = (int )tmp___60;
              tmp___61 = EC32((section_hdr + ((int )nsections - 1))->PointerToRawData);
              lseek(desc, (long )((tmp___61 + rsize) - (unsigned int )bw___0), 0);
              tmp___63 = read(desc, (void *)(buff), 4096U);
              if (tmp___63 == 4096) {
                tmp___62 = cli_memstr((char const   *)(buff), 4091, "\350\004r\000\000",
                                      5);
                if (tmp___62) {
                  (*virname) = "W32.Magistr.B";
                  free((void *)section_hdr);
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
  if (broken) {
    free((void *)section_hdr);
    return (0);
  }
  found = 0U;
  i = 0U;
  while (i < (unsigned int )nsections - 1U) {
    if (! (section_hdr + i)->SizeOfRawData) {
      if ((section_hdr + i)->VirtualSize) {
        if ((section_hdr + (i + 1U))->SizeOfRawData) {
          if ((section_hdr + (i + 1U))->VirtualSize) {
            found = 1U;
            cli_dbgmsg("UPX/FSG: empty section found - assuming compression\n");
            break;
          }
        }
      }
    }
    i ++;
  }
  if (found) {
    tmp___65 = lseek(desc, (long )ep, 0);
    if (tmp___65 == -1L) {
      cli_dbgmsg("UPX/FSG: lseek() failed\n");
      free((void *)section_hdr);
      return (-12);
    }
    tmp___66 = read(desc, (void *)(buff), 168U);
    if (tmp___66 != 168) {
      cli_dbgmsg("UPX/FSG: Can\'t read 168 bytes at 0x%x (%d)\n", ep, ep);
      cli_dbgmsg("UPX/FSG: Broken or not UPX/FSG compressed file\n");
      free((void *)section_hdr);
      return (0);
    }
    if ((int )buff[0] == -121) {
      if ((int )buff[1] == 37) {
        ssize = EC32((section_hdr + (i + 1U))->SizeOfRawData);
        dsize = EC32((section_hdr + i)->VirtualSize);
        while (found) {
          if (limits) {
            if (limits->maxfilesize) {
              if ((unsigned long )ssize > limits->maxfilesize) {
                cli_dbgmsg("FSG: Sizes exceeded (ssize: %d, dsize: %d, max: %lu)\n",
                           ssize, dsize, limits->maxfilesize);
                free((void *)section_hdr);
                return (0);
              } else {
                if ((unsigned long )dsize > limits->maxfilesize) {
                  cli_dbgmsg("FSG: Sizes exceeded (ssize: %d, dsize: %d, max: %lu)\n",
                             ssize, dsize, limits->maxfilesize);
                  free((void *)section_hdr);
                  return (0);
                }
              }
            }
          }
          if (ssize <= 25U) {
            cli_dbgmsg("FSG: Size mismatch (ssize: %d, dsize: %d)\n", ssize, dsize);
            free((void *)section_hdr);
            return (0);
          } else {
            if (dsize <= ssize) {
              cli_dbgmsg("FSG: Size mismatch (ssize: %d, dsize: %d)\n", ssize, dsize);
              free((void *)section_hdr);
              return (0);
            }
          }
          tmp___67 = cli_readint32((char const   *)(buff + 2));
          tmp___68 = EC32(optional_hdr.ImageBase);
          newedx = (unsigned int )tmp___67 - tmp___68;
          tmp___69 = EC32((section_hdr + (i + 1U))->VirtualAddress);
          if (newedx < tmp___69) {
            cli_dbgmsg("FSG: xchg out of bounds (%x), giving up\n", newedx);
            break;
          } else {
            tmp___70 = EC32((section_hdr + (i + 1U))->VirtualAddress);
            tmp___71 = EC32((section_hdr + (i + 1U))->SizeOfRawData);
            if (newedx >= (tmp___70 + tmp___71) - 4U) {
              cli_dbgmsg("FSG: xchg out of bounds (%x), giving up\n", newedx);
              break;
            }
          }
          src = (char *)cli_malloc(ssize);
          if ((unsigned int )src == (unsigned int )((void *)0)) {
            free((void *)section_hdr);
            return (-3);
          }
          tmp___73 = (__off_t )EC32((section_hdr + (i + 1U))->PointerToRawData);
          lseek(desc, tmp___73, 0);
          tmp___74 = read(desc, (void *)src, ssize);
          if ((unsigned int )tmp___74 != ssize) {
            cli_dbgmsg("Can\'t read raw data of section %d\n", i);
            free((void *)section_hdr);
            free((void *)src);
            return (-12);
          }
          tmp___75 = EC32((section_hdr + (i + 1U))->VirtualAddress);
          if (newedx < tmp___75) {
            cli_dbgmsg("FSG: New ESP out of bounds\n");
            free((void *)src);
            break;
          } else {
            tmp___76 = EC32((section_hdr + (i + 1U))->VirtualAddress);
            dest = (src + newedx) - tmp___76;
            if ((unsigned int )dest < (unsigned int )src) {
              tmp___77 = EC32((section_hdr + (i + 1U))->VirtualAddress);
              tmp___78 = EC32((section_hdr + (i + 1U))->SizeOfRawData);
              if ((unsigned int )dest >= (unsigned int )(((src + tmp___77) + tmp___78) -
                                                         4)) {
                cli_dbgmsg("FSG: New ESP out of bounds\n");
                free((void *)src);
                break;
              }
            }
          }
          tmp___79 = cli_readint32((char const   *)dest);
          tmp___80 = EC32(optional_hdr.ImageBase);
          newedx = (unsigned int )tmp___79 - tmp___80;
          tmp___81 = EC32((section_hdr + (i + 1U))->VirtualAddress);
          if (newedx <= tmp___81) {
            cli_dbgmsg("FSG: New ESP (%x) is wrong\n", newedx);
            free((void *)src);
            break;
          } else {
            tmp___82 = EC32((section_hdr + (i + 1U))->VirtualAddress);
            tmp___83 = EC32((section_hdr + (i + 1U))->SizeOfRawData);
            if (newedx >= (tmp___82 + tmp___83) - 4U) {
              cli_dbgmsg("FSG: New ESP (%x) is wrong\n", newedx);
              free((void *)src);
              break;
            }
          }
          tmp___84 = EC32((section_hdr + (i + 1U))->VirtualAddress);
          dest = (src + newedx) - tmp___84;
          if ((unsigned int )dest < (unsigned int )src) {
            cli_dbgmsg("FSG: New stack out of bounds\n");
            free((void *)src);
            break;
          } else {
            tmp___85 = EC32((section_hdr + (i + 1U))->VirtualAddress);
            tmp___86 = EC32((section_hdr + (i + 1U))->SizeOfRawData);
            if ((unsigned int )dest >= (unsigned int )(((src + tmp___85) + tmp___86) -
                                                       32)) {
              cli_dbgmsg("FSG: New stack out of bounds\n");
              free((void *)src);
              break;
            }
          }
          tmp___87 = cli_readint32((char const   *)dest);
          tmp___88 = EC32(optional_hdr.ImageBase);
          newedi = (unsigned int )tmp___87 - tmp___88;
          tmp___89 = cli_readint32((char const   *)(dest + 4));
          tmp___90 = EC32(optional_hdr.ImageBase);
          newesi = (unsigned int )tmp___89 - tmp___90;
          tmp___91 = cli_readint32((char const   *)(dest + 16));
          tmp___92 = EC32(optional_hdr.ImageBase);
          newebx = (unsigned int )tmp___91 - tmp___92;
          newedx = (uint32_t )cli_readint32((char const   *)(dest + 20));
          tmp___94 = EC32((section_hdr + i)->VirtualAddress);
          if (newedi != tmp___94) {
            tmp___93 = EC32((section_hdr + i)->VirtualAddress);
            cli_dbgmsg("FSG: Bad destination buffer (edi is %x should be %x)\n", newedi,
                       tmp___93);
            free((void *)src);
            break;
          }
          tmp___95 = EC32((section_hdr + (i + 1U))->VirtualAddress);
          if (newesi < tmp___95) {
            cli_dbgmsg("FSG: Source buffer out of section bounds\n");
            free((void *)src);
            break;
          } else {
            tmp___96 = EC32((section_hdr + (i + 1U))->VirtualAddress);
            tmp___97 = EC32((section_hdr + (i + 1U))->SizeOfRawData);
            if (newesi >= tmp___96 + tmp___97) {
              cli_dbgmsg("FSG: Source buffer out of section bounds\n");
              free((void *)src);
              break;
            }
          }
          tmp___98 = EC32((section_hdr + (i + 1U))->VirtualAddress);
          if (newebx < tmp___98) {
            cli_dbgmsg("FSG: Array of functions out of bounds\n");
            free((void *)src);
            break;
          } else {
            tmp___99 = EC32((section_hdr + (i + 1U))->VirtualAddress);
            tmp___100 = EC32((section_hdr + (i + 1U))->SizeOfRawData);
            if (newebx >= (tmp___99 + tmp___100) - 16U) {
              cli_dbgmsg("FSG: Array of functions out of bounds\n");
              free((void *)src);
              break;
            }
          }
          tmp___101 = EC32((section_hdr + (i + 1U))->VirtualAddress);
          tmp___102 = cli_readint32((char const   *)(src + ((newebx + 12U) - tmp___101)));
          tmp___103 = EC32(optional_hdr.ImageBase);
          cli_dbgmsg("FSG: found old EP @%x\n", (unsigned int )tmp___102 - tmp___103);
          dest = (char *)cli_calloc(dsize, sizeof(char ));
          if ((unsigned int )dest == (unsigned int )((void *)0)) {
            free((void *)section_hdr);
            free((void *)src);
            return (-3);
          }
          tmp___105 = EC32((section_hdr + (i + 1U))->VirtualAddress);
          tmp___106 = EC32((section_hdr + (i + 1U))->VirtualAddress);
          tmp___107 = unfsg_200(src + (newesi - tmp___106), dest, (int )((ssize +
                                                                          tmp___105) -
                                                                         newesi),
                                (int )dsize);
          if (tmp___107 == -1) {
            cli_dbgmsg("FSG: Unpacking failed\n");
            free((void *)src);
            free((void *)dest);
            break;
          }
          found = 0U;
          upx_success = 1U;
          cli_dbgmsg("FSG: Successfully decompressed\n");
        }
      }
    }
    if (found) {
      if ((int )buff[0] == -66) {
        tmp___146 = cli_readint32((char const   *)(buff + 1));
        tmp___147 = EC32(optional_hdr.ImageBase);
        if ((unsigned int )tmp___146 - tmp___147 < min) {
          ssize = EC32((section_hdr + (i + 1U))->SizeOfRawData);
          dsize = EC32((section_hdr + i)->VirtualSize);
          while (found) {
            sectcnt = 0;
            if (limits) {
              if (limits->maxfilesize) {
                if ((unsigned long )ssize > limits->maxfilesize) {
                  cli_dbgmsg("FSG: Sizes exceeded (ssize: %d, dsize: %d, max: %lu)\n",
                             ssize, dsize, limits->maxfilesize);
                  free((void *)section_hdr);
                  return (0);
                } else {
                  if ((unsigned long )dsize > limits->maxfilesize) {
                    cli_dbgmsg("FSG: Sizes exceeded (ssize: %d, dsize: %d, max: %lu)\n",
                               ssize, dsize, limits->maxfilesize);
                    free((void *)section_hdr);
                    return (0);
                  }
                }
              }
            }
            if (ssize <= 25U) {
              cli_dbgmsg("FSG: Size mismatch (ssize: %d, dsize: %d)\n", ssize, dsize);
              free((void *)section_hdr);
              return (0);
            } else {
              if (dsize <= ssize) {
                cli_dbgmsg("FSG: Size mismatch (ssize: %d, dsize: %d)\n", ssize, dsize);
                free((void *)section_hdr);
                return (0);
              }
            }
            tmp___109 = cli_readint32((char const   *)(buff + 1));
            tmp___110 = EC32(optional_hdr.ImageBase);
            gp = (int )((unsigned int )tmp___109 - tmp___110);
            tmp___111 = EC32((section_hdr + (i + 1U))->PointerToRawData);
            if (gp >= (int )tmp___111) {
              tmp___108 = EC32((section_hdr + i)->VirtualAddress);
              cli_dbgmsg("FSG: Support data out of padding area (vaddr: %d)\n", tmp___108);
              break;
            } else {
              if (gp < 0) {
                tmp___108 = EC32((section_hdr + i)->VirtualAddress);
                cli_dbgmsg("FSG: Support data out of padding area (vaddr: %d)\n",
                           tmp___108);
                break;
              }
            }
            lseek(desc, (long )gp, 0);
            tmp___112 = EC32((section_hdr + (i + 1U))->PointerToRawData);
            gp = (int )(tmp___112 - (unsigned int )gp);
            if (limits) {
              if (limits->maxfilesize) {
                if ((unsigned long )((unsigned int )gp) > limits->maxfilesize) {
                  cli_dbgmsg("FSG: Buffer size exceeded (size: %d, max: %lu)\n", gp,
                             limits->maxfilesize);
                  free((void *)section_hdr);
                  return (0);
                }
              }
            }
            support = (char *)cli_malloc((unsigned int )gp);
            if ((unsigned int )support == (unsigned int )((void *)0)) {
              free((void *)section_hdr);
              return (-3);
            }
            tmp___114 = read(desc, (void *)support, (unsigned int )gp);
            if (tmp___114 != gp) {
              cli_dbgmsg("Can\'t read %d bytes from padding area\n", gp);
              free((void *)section_hdr);
              free((void *)support);
              return (-12);
            }
            tmp___115 = cli_readint32((char const   *)support);
            tmp___116 = EC32(optional_hdr.ImageBase);
            newebx___0 = (unsigned int )tmp___115 - tmp___116;
            tmp___117 = cli_readint32((char const   *)(support + 4));
            tmp___118 = EC32(optional_hdr.ImageBase);
            newedi___0 = (unsigned int )tmp___117 - tmp___118;
            tmp___119 = cli_readint32((char const   *)(support + 8));
            tmp___120 = EC32(optional_hdr.ImageBase);
            newesi___0 = (unsigned int )tmp___119 - tmp___120;
            tmp___121 = EC32((section_hdr + (i + 1U))->VirtualAddress);
            if (newesi___0 < tmp___121) {
              cli_dbgmsg("FSG: Source buffer out of section bounds\n");
              free((void *)support);
              break;
            } else {
              tmp___122 = EC32((section_hdr + (i + 1U))->VirtualAddress);
              tmp___123 = EC32((section_hdr + (i + 1U))->SizeOfRawData);
              if (newesi___0 >= tmp___122 + tmp___123) {
                cli_dbgmsg("FSG: Source buffer out of section bounds\n");
                free((void *)support);
                break;
              }
            }
            tmp___125 = EC32((section_hdr + i)->VirtualAddress);
            if (newedi___0 != tmp___125) {
              tmp___124 = EC32((section_hdr + i)->VirtualAddress);
              cli_dbgmsg("FSG: Bad destination (is %x should be %x)\n", newedi___0,
                         tmp___124);
              free((void *)support);
              break;
            }
            t = 12;
            while (t < gp - 4) {
              tmp___126 = (uint32_t )cli_readint32((char const   *)(support + t));
              rva = tmp___126;
              if (! rva) {
                break;
              }
              tmp___127 = EC32(optional_hdr.ImageBase);
              rva -= tmp___127 + 1U;
              sectcnt ++;
              if (rva % 4096U) {
                cli_dbgmsg("FSG: Original section %d is misaligned\n", sectcnt);
              }
              tmp___128 = EC32((section_hdr + i)->VirtualAddress);
              if (rva < tmp___128) {
                cli_dbgmsg("FSG: Original section %d is out of bounds\n", sectcnt);
                break;
              } else {
                tmp___129 = EC32((section_hdr + i)->VirtualAddress);
                tmp___130 = EC32((section_hdr + i)->VirtualSize);
                if (rva >= tmp___129 + tmp___130) {
                  cli_dbgmsg("FSG: Original section %d is out of bounds\n", sectcnt);
                  break;
                }
              }
              t += 4;
            }
            if (t >= gp - 4) {
              free((void *)support);
              break;
            } else {
              tmp___131 = cli_readint32((char const   *)(support + t));
              if (tmp___131) {
                free((void *)support);
                break;
              }
            }
            sections = (struct SECTION *)cli_malloc((unsigned int )(sectcnt + 1) *
                                                    sizeof(struct SECTION ));
            if ((unsigned int )sections == (unsigned int )((void *)0)) {
              free((void *)section_hdr);
              free((void *)support);
              return (-3);
            }
            (sections + 0)->rva = newedi___0;
            t = 1;
            while (t <= sectcnt) {
              tmp___133 = cli_readint32((char const   *)((support + 8) + t * 4));
              tmp___134 = EC32(optional_hdr.ImageBase);
              (sections + t)->rva = (unsigned int )(tmp___133 - 1) - tmp___134;
              t ++;
            }
            free((void *)support);
            src = (char *)cli_malloc(ssize);
            if ((unsigned int )src == (unsigned int )((void *)0)) {
              free((void *)section_hdr);
              free((void *)sections);
              return (-3);
            }
            tmp___136 = (__off_t )EC32((section_hdr + (i + 1U))->PointerToRawData);
            lseek(desc, tmp___136, 0);
            tmp___137 = read(desc, (void *)src, ssize);
            if ((unsigned int )tmp___137 != ssize) {
              cli_dbgmsg("Can\'t read raw data of section %d\n", i);
              free((void *)section_hdr);
              free((void *)sections);
              free((void *)src);
              return (-12);
            }
            dest = (char *)cli_calloc(dsize, sizeof(char ));
            if ((unsigned int )dest == (unsigned int )((void *)0)) {
              free((void *)section_hdr);
              free((void *)src);
              free((void *)sections);
              return (-3);
            }
            tmp___139 = EC32(optional_hdr.AddressOfEntryPoint);
            tmp___140 = cli_readint32((char const   *)(buff + 163));
            oldep = ((tmp___139 + 161U) + 6U) + (unsigned int )tmp___140;
            cli_dbgmsg("FSG: found old EP @%x\n", oldep);
            tempfile = cli_gentemp((char const   *)((void *)0));
            ndesc = open((char const   *)tempfile, 578, 448);
            if (ndesc < 0) {
              cli_dbgmsg("FSG: Can\'t create file %s\n", tempfile);
              free((void *)tempfile);
              free((void *)section_hdr);
              free((void *)src);
              free((void *)dest);
              free((void *)sections);
              return (-12);
            }
            tmp___141 = EC32(optional_hdr.ImageBase);
            tmp___142 = EC32((section_hdr + (i + 1U))->VirtualAddress);
            tmp___143 = EC32((section_hdr + (i + 1U))->VirtualAddress);
            tmp___144 = unfsg_133((src + newesi___0) - tmp___143, dest, (int )((ssize +
                                                                                tmp___142) -
                                                                               newesi___0),
                                  (int )dsize, sections, sectcnt, tmp___141, oldep,
                                  ndesc);
            switch (tmp___144) {
            case 1: 
            cli_dbgmsg("FSG: Unpacked and rebuilt executable saved in %s\n", tempfile);
            free((void *)src);
            free((void *)dest);
            free((void *)sections);
            fsync(ndesc);
            lseek(ndesc, 0L, 0);
            cli_dbgmsg("***** Scanning rebuilt PE file *****\n");
            tmp___145 = cli_magic_scandesc(ndesc, virname, scanned, root, limits,
                                           options, arec, mrec);
            if (tmp___145 == 1) {
              free((void *)section_hdr);
              close(ndesc);
              if (! cli_leavetemps_flag) {
                unlink((char const   *)tempfile);
              }
              free((void *)tempfile);
              return (1);
            }
            close(ndesc);
            if (! cli_leavetemps_flag) {
              unlink((char const   *)tempfile);
            }
            free((void *)tempfile);
            free((void *)section_hdr);
            return (0);
            case 0: 
            cli_dbgmsg("FSG: FSG: Successfully decompressed\n");
            close(ndesc);
            unlink((char const   *)tempfile);
            free((void *)tempfile);
            free((void *)sections);
            found = 0U;
            upx_success = 1U;
            break;
            default: 
            cli_dbgmsg("FSG: Unpacking failed\n");
            close(ndesc);
            unlink((char const   *)tempfile);
            free((void *)tempfile);
            free((void *)src);
            free((void *)dest);
            free((void *)sections);
            break;
            }
            break;
          }
        }
      }
    }
    if (found) {
      if ((int )buff[0] == -69) {
        tmp___187 = cli_readint32((char const   *)(buff + 1));
        tmp___188 = EC32(optional_hdr.ImageBase);
        if ((unsigned int )tmp___187 - tmp___188 < min) {
          if ((int )buff[5] == -65) {
            if ((int )buff[10] == -66) {
              ssize = EC32((section_hdr + (i + 1U))->SizeOfRawData);
              dsize = EC32((section_hdr + i)->VirtualSize);
              while (found) {
                tmp___148 = cli_readint32((char const   *)(buff + 1));
                tmp___149 = EC32(optional_hdr.ImageBase);
                gp___0 = (int )((unsigned int )tmp___148 - tmp___149);
                sectcnt___0 = 0;
                tmp___150 = cli_readint32((char const   *)(buff + 11));
                tmp___151 = EC32(optional_hdr.ImageBase);
                newesi___1 = (unsigned int )tmp___150 - tmp___151;
                tmp___152 = cli_readint32((char const   *)(buff + 6));
                tmp___153 = EC32(optional_hdr.ImageBase);
                newedi___1 = (unsigned int )tmp___152 - tmp___153;
                tmp___154 = EC32(optional_hdr.AddressOfEntryPoint);
                oldep___0 = tmp___154;
                tmp___155 = EC32((section_hdr + (i + 1U))->VirtualAddress);
                if (oldep___0 <= tmp___155) {
                  cli_dbgmsg("FSG: EP not in section %d\n", i + 1U);
                  break;
                } else {
                  tmp___156 = EC32((section_hdr + (i + 1U))->VirtualAddress);
                  tmp___157 = EC32((section_hdr + (i + 1U))->SizeOfRawData);
                  if (oldep___0 > (tmp___156 + tmp___157) - 224U) {
                    cli_dbgmsg("FSG: EP not in section %d\n", i + 1U);
                    break;
                  }
                }
                tmp___158 = EC32((section_hdr + (i + 1U))->VirtualAddress);
                oldep___0 -= tmp___158;
                tmp___159 = EC32((section_hdr + (i + 1U))->VirtualAddress);
                if (newesi___1 < tmp___159) {
                  cli_dbgmsg("FSG: Source buffer out of section bounds\n");
                  break;
                } else {
                  tmp___160 = EC32((section_hdr + (i + 1U))->VirtualAddress);
                  tmp___161 = EC32((section_hdr + (i + 1U))->SizeOfRawData);
                  if (newesi___1 >= tmp___160 + tmp___161) {
                    cli_dbgmsg("FSG: Source buffer out of section bounds\n");
                    break;
                  }
                }
                tmp___163 = EC32((section_hdr + i)->VirtualAddress);
                if (newedi___1 != tmp___163) {
                  tmp___162 = EC32((section_hdr + i)->VirtualAddress);
                  cli_dbgmsg("FSG: Bad destination (is %x should be %x)\n", newedi___1,
                             tmp___162);
                  break;
                }
                if (limits) {
                  if (limits->maxfilesize) {
                    if ((unsigned long )ssize > limits->maxfilesize) {
                      cli_dbgmsg("FSG: Sizes exceeded (ssize: %d, dsize: %d, max: %lu)\n",
                                 ssize, dsize, limits->maxfilesize);
                      free((void *)section_hdr);
                      return (0);
                    } else {
                      if ((unsigned long )dsize > limits->maxfilesize) {
                        cli_dbgmsg("FSG: Sizes exceeded (ssize: %d, dsize: %d, max: %lu)\n",
                                   ssize, dsize, limits->maxfilesize);
                        free((void *)section_hdr);
                        return (0);
                      }
                    }
                  }
                }
                if (ssize <= 25U) {
                  cli_dbgmsg("FSG: Size mismatch (ssize: %d, dsize: %d)\n", ssize,
                             dsize);
                  free((void *)section_hdr);
                  return (0);
                } else {
                  if (dsize <= ssize) {
                    cli_dbgmsg("FSG: Size mismatch (ssize: %d, dsize: %d)\n", ssize,
                               dsize);
                    free((void *)section_hdr);
                    return (0);
                  }
                }
                tmp___165 = EC32((section_hdr + (i + 1U))->PointerToRawData);
                if (gp___0 >= (int )tmp___165) {
                  tmp___164 = EC32((section_hdr + i)->VirtualAddress);
                  cli_dbgmsg("FSG: Support data out of padding area (newedi: %d, vaddr: %d)\n",
                             newedi___1, tmp___164);
                  break;
                } else {
                  if (gp___0 < 0) {
                    tmp___164 = EC32((section_hdr + i)->VirtualAddress);
                    cli_dbgmsg("FSG: Support data out of padding area (newedi: %d, vaddr: %d)\n",
                               newedi___1, tmp___164);
                    break;
                  }
                }
                lseek(desc, (long )gp___0, 0);
                tmp___166 = EC32((section_hdr + (i + 1U))->PointerToRawData);
                gp___0 = (int )(tmp___166 - (unsigned int )gp___0);
                if (limits) {
                  if (limits->maxfilesize) {
                    if ((unsigned long )((unsigned int )gp___0) > limits->maxfilesize) {
                      cli_dbgmsg("FSG: Buffer size exceeded (size: %d, max: %lu)\n",
                                 gp___0, limits->maxfilesize);
                      free((void *)section_hdr);
                      return (0);
                    }
                  }
                }
                support___0 = (char *)cli_malloc((unsigned int )gp___0);
                if ((unsigned int )support___0 == (unsigned int )((void *)0)) {
                  free((void *)section_hdr);
                  return (-3);
                }
                tmp___168 = read(desc, (void *)support___0, (unsigned int )gp___0);
                if (tmp___168 != gp___0) {
                  cli_dbgmsg("Can\'t read %d bytes from padding area\n", gp___0);
                  free((void *)section_hdr);
                  free((void *)support___0);
                  return (-12);
                }
                t___0 = 0;
                while (t___0 < gp___0 - 2) {
                  rva___0 = (unsigned int )((int )(*(support___0 + t___0)) + 256 *
                                                                             (int )(*(support___0 +
                                                                                      (t___0 +
                                                                                       1))));
                  if (rva___0 == 2U) {
                    break;
                  } else {
                    if (rva___0 == 1U) {
                      break;
                    }
                  }
                  tmp___169 = EC32(optional_hdr.ImageBase);
                  rva___0 = ((rva___0 - 2U) << 12) - tmp___169;
                  sectcnt___0 ++;
                  tmp___170 = EC32((section_hdr + i)->VirtualAddress);
                  if (rva___0 < tmp___170) {
                    cli_dbgmsg("FSG: Original section %d is out of bounds\n", sectcnt___0);
                    break;
                  } else {
                    tmp___171 = EC32((section_hdr + i)->VirtualAddress);
                    tmp___172 = EC32((section_hdr + i)->VirtualSize);
                    if (rva___0 >= tmp___171 + tmp___172) {
                      cli_dbgmsg("FSG: Original section %d is out of bounds\n", sectcnt___0);
                      break;
                    }
                  }
                  t___0 += 2;
                }
                if (t___0 >= gp___0 - 10) {
                  free((void *)support___0);
                  break;
                } else {
                  tmp___173 = cli_readint32((char const   *)((support___0 + t___0) +
                                                             6));
                  if (tmp___173 != 2) {
                    free((void *)support___0);
                    break;
                  }
                }
                sections___0 = (struct SECTION *)cli_malloc((unsigned int )(sectcnt___0 +
                                                                            1) * sizeof(struct SECTION ));
                if ((unsigned int )sections___0 == (unsigned int )((void *)0)) {
                  free((void *)section_hdr);
                  free((void *)support___0);
                  return (-3);
                }
                (sections___0 + 0)->rva = newedi___1;
                t___0 = 0;
                while (t___0 <= sectcnt___0 - 1) {
                  tmp___175 = EC32(optional_hdr.ImageBase);
                  (sections___0 + (t___0 + 1))->rva = (unsigned int )((((int )(*(support___0 +
                                                                                 t___0 *
                                                                                 2)) +
                                                                        256 * (int )(*(support___0 +
                                                                                       (t___0 *
                                                                                        2 +
                                                                                        1)))) -
                                                                       2) << 12) -
                                                      tmp___175;
                  t___0 ++;
                }
                free((void *)support___0);
                src = (char *)cli_malloc(ssize);
                if ((unsigned int )src == (unsigned int )((void *)0)) {
                  free((void *)section_hdr);
                  free((void *)sections___0);
                  return (-3);
                }
                tmp___177 = (__off_t )EC32((section_hdr + (i + 1U))->PointerToRawData);
                lseek(desc, tmp___177, 0);
                tmp___178 = read(desc, (void *)src, ssize);
                if ((unsigned int )tmp___178 != ssize) {
                  cli_dbgmsg("Can\'t read raw data of section %d\n", i);
                  free((void *)section_hdr);
                  free((void *)sections___0);
                  free((void *)src);
                  return (-12);
                }
                dest = (char *)cli_calloc(dsize, sizeof(char ));
                if ((unsigned int )dest == (unsigned int )((void *)0)) {
                  free((void *)section_hdr);
                  free((void *)src);
                  free((void *)sections___0);
                  return (-3);
                }
                gp___0 = 218 + 6 * ((int )buff[16] == -24);
                tmp___180 = EC32(optional_hdr.AddressOfEntryPoint);
                tmp___181 = cli_readint32((char const   *)(((src + gp___0) + 2) +
                                                           oldep___0));
                oldep___0 = ((tmp___180 + (unsigned int )gp___0) + 6U) + (unsigned int )tmp___181;
                cli_dbgmsg("FSG: found old EP @%x\n", oldep___0);
                tempfile = cli_gentemp((char const   *)((void *)0));
                ndesc = open((char const   *)tempfile, 578, 448);
                if (ndesc < 0) {
                  cli_dbgmsg("FSG: Can\'t create file %s\n", tempfile);
                  free((void *)tempfile);
                  free((void *)section_hdr);
                  free((void *)src);
                  free((void *)dest);
                  free((void *)sections___0);
                  return (-12);
                }
                tmp___182 = EC32(optional_hdr.ImageBase);
                tmp___183 = EC32((section_hdr + (i + 1U))->VirtualAddress);
                tmp___184 = EC32((section_hdr + (i + 1U))->VirtualAddress);
                tmp___185 = unfsg_133((src + newesi___1) - tmp___184, dest, (int )((ssize +
                                                                                    tmp___183) -
                                                                                   newesi___1),
                                      (int )dsize, sections___0, sectcnt___0, tmp___182,
                                      oldep___0, ndesc);
                switch (tmp___185) {
                case 1: 
                cli_dbgmsg("FSG: Unpacked and rebuilt executable saved in %s\n", tempfile);
                free((void *)src);
                free((void *)dest);
                free((void *)sections___0);
                fsync(ndesc);
                lseek(ndesc, 0L, 0);
                cli_dbgmsg("***** Scanning rebuilt PE file *****\n");
                tmp___186 = cli_magic_scandesc(ndesc, virname, scanned, root, limits,
                                               options, arec, mrec);
                if (tmp___186 == 1) {
                  free((void *)section_hdr);
                  close(ndesc);
                  if (! cli_leavetemps_flag) {
                    unlink((char const   *)tempfile);
                  }
                  free((void *)tempfile);
                  return (1);
                }
                close(ndesc);
                if (! cli_leavetemps_flag) {
                  unlink((char const   *)tempfile);
                }
                free((void *)tempfile);
                free((void *)section_hdr);
                return (0);
                case 0: 
                cli_dbgmsg("FSG: FSG: Successfully decompressed\n");
                close(ndesc);
                unlink((char const   *)tempfile);
                free((void *)tempfile);
                free((void *)sections___0);
                found = 0U;
                upx_success = 1U;
                break;
                default: 
                cli_dbgmsg("FSG: Unpacking failed\n");
                close(ndesc);
                unlink((char const   *)tempfile);
                free((void *)tempfile);
                free((void *)src);
                free((void *)dest);
                free((void *)sections___0);
                break;
                }
                break;
              }
            }
          }
        }
      }
    }
    if (found) {
      __builtin_strncpy(sname, (section_hdr + i)->Name, 8);
      sname[8] = (char)0;
      cli_dbgmsg("UPX: Section %d name: %s\n", i, sname);
      __builtin_strncpy(sname, (section_hdr + (i + 1U))->Name, 8);
      sname[8] = (char)0;
      cli_dbgmsg("UPX: Section %d name: %s\n", i + 1U, sname);
      tmp___333 = __builtin_constant_p((int )((section_hdr + i)->Name));
      if (tmp___333) {
        tmp___334 = strlen((char const   *)((section_hdr + i)->Name));
        if (tmp___334 < 4U) {
          goto _L___41;
        } else {
          goto _L___42;
        }
      } else {
        _L___42: 
        tmp___335 = __builtin_constant_p((int )"UPX0");
        if (tmp___335) {
          tmp___336 = strlen("UPX0");
          if (tmp___336 < 4U) {
            _L___41: 
            tmp___330 = __builtin_constant_p((int )((section_hdr + i)->Name));
            if (tmp___330) {
              tmp___331 = __builtin_constant_p((int )"UPX0");
              if (tmp___331) {
                __s1_len___0 = strlen((char const   *)((section_hdr + i)->Name));
                __s2_len___0 = strlen("UPX0");
                if (! ((unsigned int )((void const   *)((section_hdr + i)->Name +
                                                        1)) - (unsigned int )((void const   *)((section_hdr +
                                                                                                i)->Name)) ==
                       1U)) {
                  goto _L___38;
                } else {
                  if (__s1_len___0 >= 4U) {
                    _L___38: 
                    if (! ((unsigned int )((void const   *)("UPX0" + 1)) - (unsigned int )((void const   *)"UPX0") ==
                           1U)) {
                      tmp___332 = 1;
                    } else {
                      if (__s2_len___0 >= 4U) {
                        tmp___332 = 1;
                      } else {
                        tmp___332 = 0;
                      }
                    }
                  } else {
                    tmp___332 = 0;
                  }
                }
                if (tmp___332) {
                  tmp___299 = __builtin_strcmp((section_hdr + i)->Name, "UPX0");
                } else {
                  goto _L___40;
                }
              } else {
                goto _L___40;
              }
            } else {
              _L___40: 
              tmp___329 = __builtin_constant_p((int )((section_hdr + i)->Name));
              if (tmp___329) {
                if ((unsigned int )((void const   *)((section_hdr + i)->Name + 1)) -
                    (unsigned int )((void const   *)((section_hdr + i)->Name)) ==
                    1U) {
                  __s1_len___0 = strlen((char const   *)((section_hdr + i)->Name));
                  if (__s1_len___0 < 4U) {
                    tmp___318 = __builtin_constant_p((int )"UPX0");
                    if (tmp___318) {
                      if ((unsigned int )((void const   *)("UPX0" + 1)) - (unsigned int )((void const   *)"UPX0") ==
                          1U) {
                        tmp___299 = __builtin_strcmp((section_hdr + i)->Name, "UPX0");
                      } else {
                        goto _L___33;
                      }
                    } else {
                      _L___33: 
                      __s2___14 = (unsigned char const   *)"UPX0";
                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)((section_hdr +
                                                                                                          i)->Name)) +
                                                              0)) - (int const   )(*(__s2___14 +
                                                                                     0)));
                      if (__s1_len___0 > 0U) {
                        if (__result___42 == 0) {
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)((section_hdr +
                                                                                                              i)->Name)) +
                                                                  1)) - (int const   )(*(__s2___14 +
                                                                                         1)));
                          if (__s1_len___0 > 1U) {
                            if (__result___42 == 0) {
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)((section_hdr +
                                                                                                                  i)->Name)) +
                                                                      2)) - (int const   )(*(__s2___14 +
                                                                                             2)));
                              if (__s1_len___0 > 2U) {
                                if (__result___42 == 0) {
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)((section_hdr +
                                                                                                                      i)->Name)) +
                                                                          3)) - (int const   )(*(__s2___14 +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___299 = __result___42;
                    }
                  } else {
                    goto _L___37;
                  }
                } else {
                  goto _L___37;
                }
              } else {
                _L___37: 
                tmp___328 = __builtin_constant_p((int )"UPX0");
                if (tmp___328) {
                  if ((unsigned int )((void const   *)("UPX0" + 1)) - (unsigned int )((void const   *)"UPX0") ==
                      1U) {
                    __s2_len___0 = strlen("UPX0");
                    if (__s2_len___0 < 4U) {
                      tmp___327 = __builtin_constant_p((int )((section_hdr + i)->Name));
                      if (tmp___327) {
                        if ((unsigned int )((void const   *)((section_hdr + i)->Name +
                                                             1)) - (unsigned int )((void const   *)((section_hdr +
                                                                                                     i)->Name)) ==
                            1U) {
                          tmp___299 = __builtin_strcmp((section_hdr + i)->Name, "UPX0");
                        } else {
                          goto _L___35;
                        }
                      } else {
                        _L___35: 
                        __s1___30 = (unsigned char const   *)((char const   *)((section_hdr +
                                                                                i)->Name));
                        __result___46 = (int )((int const   )(*(__s1___30 + 0)) -
                                               (int const   )(*((unsigned char const   *)"UPX0" +
                                                                0)));
                        if (__s2_len___0 > 0U) {
                          if (__result___46 == 0) {
                            __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                   (int const   )(*((unsigned char const   *)"UPX0" +
                                                                    1)));
                            if (__s2_len___0 > 1U) {
                              if (__result___46 == 0) {
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        2)) - (int const   )(*((unsigned char const   *)"UPX0" +
                                                                                               2)));
                                if (__s2_len___0 > 2U) {
                                  if (__result___46 == 0) {
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            3)) -
                                                           (int const   )(*((unsigned char const   *)"UPX0" +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
                        tmp___299 = __result___46;
                      }
                    } else {
                      tmp___299 = __builtin_strcmp((section_hdr + i)->Name, "UPX0");
                    }
                  } else {
                    tmp___299 = __builtin_strcmp((section_hdr + i)->Name, "UPX0");
                  }
                } else {
                  tmp___299 = __builtin_strcmp((section_hdr + i)->Name, "UPX0");
                }
              }
            }
            tmp___263 = tmp___299;
          } else {
            tmp___263 = strncmp((char const   *)((section_hdr + i)->Name), "UPX0",
                                4U);
          }
        } else {
          tmp___263 = strncmp((char const   *)((section_hdr + i)->Name), "UPX0", 4U);
        }
      }
      if (tmp___263) {
        cli_dbgmsg("UPX: Possibly hacked UPX section headers\n");
      } else {
        tmp___481 = __builtin_constant_p((int )((section_hdr + (i + 1U))->Name));
        if (tmp___481) {
          tmp___482 = strlen((char const   *)((section_hdr + (i + 1U))->Name));
          if (tmp___482 < 4U) {
            goto _L___83;
          } else {
            goto _L___84;
          }
        } else {
          _L___84: 
          tmp___483 = __builtin_constant_p((int )"UPX1");
          if (tmp___483) {
            tmp___484 = strlen("UPX1");
            if (tmp___484 < 4U) {
              _L___83: 
              tmp___478 = __builtin_constant_p((int )((section_hdr + (i + 1U))->Name));
              if (tmp___478) {
                tmp___479 = __builtin_constant_p((int )"UPX1");
                if (tmp___479) {
                  __s1_len___2 = strlen((char const   *)((section_hdr + (i + 1U))->Name));
                  __s2_len___2 = strlen("UPX1");
                  if (! ((unsigned int )((void const   *)((section_hdr + (i + 1U))->Name +
                                                          1)) - (unsigned int )((void const   *)((section_hdr +
                                                                                                  (i +
                                                                                                   1U))->Name)) ==
                         1U)) {
                    goto _L___80;
                  } else {
                    if (__s1_len___2 >= 4U) {
                      _L___80: 
                      if (! ((unsigned int )((void const   *)("UPX1" + 1)) - (unsigned int )((void const   *)"UPX1") ==
                             1U)) {
                        tmp___480 = 1;
                      } else {
                        if (__s2_len___2 >= 4U) {
                          tmp___480 = 1;
                        } else {
                          tmp___480 = 0;
                        }
                      }
                    } else {
                      tmp___480 = 0;
                    }
                  }
                  if (tmp___480) {
                    tmp___447 = __builtin_strcmp((section_hdr + (i + 1U))->Name, "UPX1");
                  } else {
                    goto _L___82;
                  }
                } else {
                  goto _L___82;
                }
              } else {
                _L___82: 
                tmp___477 = __builtin_constant_p((int )((section_hdr + (i + 1U))->Name));
                if (tmp___477) {
                  if ((unsigned int )((void const   *)((section_hdr + (i + 1U))->Name +
                                                       1)) - (unsigned int )((void const   *)((section_hdr +
                                                                                               (i +
                                                                                                1U))->Name)) ==
                      1U) {
                    __s1_len___2 = strlen((char const   *)((section_hdr + (i + 1U))->Name));
                    if (__s1_len___2 < 4U) {
                      tmp___466 = __builtin_constant_p((int )"UPX1");
                      if (tmp___466) {
                        if ((unsigned int )((void const   *)("UPX1" + 1)) - (unsigned int )((void const   *)"UPX1") ==
                            1U) {
                          tmp___447 = __builtin_strcmp((section_hdr + (i + 1U))->Name,
                                                       "UPX1");
                        } else {
                          goto _L___75;
                        }
                      } else {
                        _L___75: 
                        __s2___30 = (unsigned char const   *)"UPX1";
                        __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)((section_hdr +
                                                                                                            (i +
                                                                                                             1U))->Name)) +
                                                                0)) - (int const   )(*(__s2___30 +
                                                                                       0)));
                        if (__s1_len___2 > 0U) {
                          if (__result___90 == 0) {
                            __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)((section_hdr +
                                                                                                                (i +
                                                                                                                 1U))->Name)) +
                                                                    1)) - (int const   )(*(__s2___30 +
                                                                                           1)));
                            if (__s1_len___2 > 1U) {
                              if (__result___90 == 0) {
                                __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)((section_hdr +
                                                                                                                    (i +
                                                                                                                     1U))->Name)) +
                                                                        2)) - (int const   )(*(__s2___30 +
                                                                                               2)));
                                if (__s1_len___2 > 2U) {
                                  if (__result___90 == 0) {
                                    __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)((section_hdr +
                                                                                                                        (i +
                                                                                                                         1U))->Name)) +
                                                                            3)) -
                                                           (int const   )(*(__s2___30 +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
                        tmp___447 = __result___90;
                      }
                    } else {
                      goto _L___79;
                    }
                  } else {
                    goto _L___79;
                  }
                } else {
                  _L___79: 
                  tmp___476 = __builtin_constant_p((int )"UPX1");
                  if (tmp___476) {
                    if ((unsigned int )((void const   *)("UPX1" + 1)) - (unsigned int )((void const   *)"UPX1") ==
                        1U) {
                      __s2_len___2 = strlen("UPX1");
                      if (__s2_len___2 < 4U) {
                        tmp___475 = __builtin_constant_p((int )((section_hdr + (i +
                                                                                1U))->Name));
                        if (tmp___475) {
                          if ((unsigned int )((void const   *)((section_hdr + (i +
                                                                               1U))->Name +
                                                               1)) - (unsigned int )((void const   *)((section_hdr +
                                                                                                       (i +
                                                                                                        1U))->Name)) ==
                              1U) {
                            tmp___447 = __builtin_strcmp((section_hdr + (i + 1U))->Name,
                                                         "UPX1");
                          } else {
                            goto _L___77;
                          }
                        } else {
                          _L___77: 
                          __s1___62 = (unsigned char const   *)((char const   *)((section_hdr +
                                                                                  (i +
                                                                                   1U))->Name));
                          __result___94 = (int )((int const   )(*(__s1___62 + 0)) -
                                                 (int const   )(*((unsigned char const   *)"UPX1" +
                                                                  0)));
                          if (__s2_len___2 > 0U) {
                            if (__result___94 == 0) {
                              __result___94 = (int )((int const   )(*(__s1___62 +
                                                                      1)) - (int const   )(*((unsigned char const   *)"UPX1" +
                                                                                             1)));
                              if (__s2_len___2 > 1U) {
                                if (__result___94 == 0) {
                                  __result___94 = (int )((int const   )(*(__s1___62 +
                                                                          2)) - (int const   )(*((unsigned char const   *)"UPX1" +
                                                                                                 2)));
                                  if (__s2_len___2 > 2U) {
                                    if (__result___94 == 0) {
                                      __result___94 = (int )((int const   )(*(__s1___62 +
                                                                              3)) -
                                                             (int const   )(*((unsigned char const   *)"UPX1" +
                                                                              3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
                          tmp___447 = __result___94;
                        }
                      } else {
                        tmp___447 = __builtin_strcmp((section_hdr + (i + 1U))->Name,
                                                     "UPX1");
                      }
                    } else {
                      tmp___447 = __builtin_strcmp((section_hdr + (i + 1U))->Name,
                                                   "UPX1");
                    }
                  } else {
                    tmp___447 = __builtin_strcmp((section_hdr + (i + 1U))->Name, "UPX1");
                  }
                }
              }
              tmp___411 = tmp___447;
            } else {
              tmp___411 = strncmp((char const   *)((section_hdr + (i + 1U))->Name),
                                  "UPX1", 4U);
            }
          } else {
            tmp___411 = strncmp((char const   *)((section_hdr + (i + 1U))->Name),
                                "UPX1", 4U);
          }
        }
        if (tmp___411) {
          cli_dbgmsg("UPX: Possibly hacked UPX section headers\n");
        }
      }
      ssize = EC32((section_hdr + (i + 1U))->SizeOfRawData);
      tmp___485 = EC32((section_hdr + i)->VirtualSize);
      tmp___486 = EC32((section_hdr + (i + 1U))->VirtualSize);
      dsize = tmp___485 + tmp___486;
      if (limits) {
        if (limits->maxfilesize) {
          if ((unsigned long )ssize > limits->maxfilesize) {
            cli_dbgmsg("UPX: Sizes exceeded (ssize: %d, dsize: %d, max: %lu)\n", ssize,
                       dsize, limits->maxfilesize);
            free((void *)section_hdr);
            return (0);
          } else {
            if ((unsigned long )dsize > limits->maxfilesize) {
              cli_dbgmsg("UPX: Sizes exceeded (ssize: %d, dsize: %d, max: %lu)\n",
                         ssize, dsize, limits->maxfilesize);
              free((void *)section_hdr);
              return (0);
            }
          }
        }
      }
      if (ssize <= 25U) {
        cli_dbgmsg("UPX: Size mismatch (ssize: %d, dsize: %d)\n", ssize, dsize);
        free((void *)section_hdr);
        return (0);
      } else {
        if (dsize <= ssize) {
          cli_dbgmsg("UPX: Size mismatch (ssize: %d, dsize: %d)\n", ssize, dsize);
          free((void *)section_hdr);
          return (0);
        }
      }
      src = (char *)cli_malloc(ssize);
      if ((unsigned int )src == (unsigned int )((void *)0)) {
        free((void *)section_hdr);
        return (-3);
      }
      dest = (char *)cli_calloc((dsize + 1024U) + (unsigned int )((int )nsections *
                                                                  40), sizeof(char ));
      if ((unsigned int )dest == (unsigned int )((void *)0)) {
        free((void *)section_hdr);
        free((void *)src);
        return (-3);
      }
      tmp___489 = (__off_t )EC32((section_hdr + (i + 1U))->PointerToRawData);
      lseek(desc, tmp___489, 0);
      tmp___490 = read(desc, (void *)src, ssize);
      if ((unsigned int )tmp___490 != ssize) {
        cli_dbgmsg("Can\'t read raw data of section %d\n", i);
        free((void *)section_hdr);
        free((void *)src);
        free((void *)dest);
        return (-12);
      }
      tmp___491 = lseek(desc, (long )ep, 0);
      if (tmp___491 == -1L) {
        cli_dbgmsg("lseek() failed\n");
        free((void *)section_hdr);
        free((void *)src);
        free((void *)dest);
        return (-12);
      }
      tmp___498 = read(desc, (void *)(buff), 126U);
      if (tmp___498 != 126) {
        cli_dbgmsg("UPX: Can\'t read 126 bytes at 0x%x (%d)\n", ep, ep);
        cli_dbgmsg("UPX/FSG: Broken or not UPX/FSG compressed file\n");
        free((void *)section_hdr);
        free((void *)src);
        free((void *)dest);
        return (0);
      } else {
        tmp___496 = cli_memstr("\021\333\021\311\001\333u\a\213\036\203\356\374\021\333\021\311\021\311u A\001\333",
                               24, (char const   *)(buff + 105), 13);
        if (tmp___496) {
          cli_dbgmsg("UPX: Looks like a NRV2B decompression routine\n");
          upxfn = & upx_inflate2b;
        } else {
          tmp___497 = cli_memstr("\021\333\021\311\001\333u\a\213\036\203\356\374\021\333\021\311\021\311u A\001\333",
                                 24, (char const   *)((buff + 105) + 8), 13);
          if (tmp___497) {
            cli_dbgmsg("UPX: Looks like a NRV2B decompression routine\n");
            upxfn = & upx_inflate2b;
          } else {
            tmp___494 = cli_memstr("\203\360\377tx\321\370\211\305\353\v\001\333u\a\213\036\203\356\374\021\333\021\311",
                                   24, (char const   *)(buff + 105), 13);
            if (tmp___494) {
              cli_dbgmsg("UPX: Looks like a NRV2D decompression routine\n");
              upxfn = & upx_inflate2d;
            } else {
              tmp___495 = cli_memstr("\203\360\377tx\321\370\211\305\353\v\001\333u\a\213\036\203\356\374\021\333\021\311",
                                     24, (char const   *)((buff + 105) + 8), 13);
              if (tmp___495) {
                cli_dbgmsg("UPX: Looks like a NRV2D decompression routine\n");
                upxfn = & upx_inflate2d;
              } else {
                tmp___492 = cli_memstr("\353R1\311\203\350\003r\021\301\340\b\212\006F\203\360\377tu\321\370\211\305",
                                       24, (char const   *)(buff + 105), 13);
                if (tmp___492) {
                  cli_dbgmsg("UPX: Looks like a NRV2E decompression routine\n");
                  upxfn = & upx_inflate2e;
                } else {
                  tmp___493 = cli_memstr("\353R1\311\203\350\003r\021\301\340\b\212\006F\203\360\377tu\321\370\211\305",
                                         24, (char const   *)((buff + 105) + 8), 13);
                  if (tmp___493) {
                    cli_dbgmsg("UPX: Looks like a NRV2E decompression routine\n");
                    upxfn = & upx_inflate2e;
                  }
                }
              }
            }
          }
        }
      }
      if (upxfn) {
        tmp___499 = cli_readint32((char const   *)(buff + 2));
        tmp___500 = EC32(optional_hdr.ImageBase);
        tmp___501 = EC32((section_hdr + (i + 1U))->VirtualAddress);
        skew = (int )(((unsigned int )tmp___499 - tmp___500) - tmp___501);
        if ((int )buff[1] != -66) {
          goto _L___85;
        } else {
          if (skew <= 0) {
            goto _L___85;
          } else {
            if (skew > 4095) {
              _L___85: 
              skew = 0;
              tmp___502 = EC32(optional_hdr.AddressOfEntryPoint);
              tmp___503 = EC32((section_hdr + (i + 1U))->VirtualAddress);
              tmp___504 = EC32((section_hdr + i)->VirtualAddress);
              tmp___505 = ((*upxfn))(src, (int )ssize, dest, (int *)(& dsize), tmp___504,
                                     tmp___503, tmp___502);
              if (tmp___505 >= 0) {
                upx_success = 1U;
              }
            } else {
              cli_dbgmsg("UPX: UPX1 seems skewed by %d bytes\n", skew);
              tmp___506 = EC32(optional_hdr.AddressOfEntryPoint);
              tmp___507 = EC32((section_hdr + (i + 1U))->VirtualAddress);
              tmp___508 = EC32((section_hdr + i)->VirtualAddress);
              tmp___509 = ((*upxfn))(src + skew, (int )(ssize - (unsigned int )skew),
                                     dest, (int *)(& dsize), tmp___508, tmp___507,
                                     tmp___506 - (unsigned int )skew);
              if (tmp___509 >= 0) {
                upx_success = 1U;
              } else {
                tmp___510 = EC32(optional_hdr.AddressOfEntryPoint);
                tmp___511 = EC32((section_hdr + (i + 1U))->VirtualAddress);
                tmp___512 = EC32((section_hdr + i)->VirtualAddress);
                tmp___513 = ((*upxfn))(src, (int )ssize, dest, (int *)(& dsize), tmp___512,
                                       tmp___511, tmp___510);
                if (tmp___513 >= 0) {
                  upx_success = 1U;
                }
              }
            }
          }
        }
        if (upx_success) {
          cli_dbgmsg("UPX: Successfully decompressed\n");
        } else {
          cli_dbgmsg("UPX: Prefered decompressor failed\n");
        }
      }
      if (! upx_success) {
        if ((unsigned int )upxfn != (unsigned int )(& upx_inflate2b)) {
          tmp___514 = EC32(optional_hdr.AddressOfEntryPoint);
          tmp___515 = EC32((section_hdr + (i + 1U))->VirtualAddress);
          tmp___516 = EC32((section_hdr + i)->VirtualAddress);
          tmp___517 = upx_inflate2b(src, (int )ssize, dest, (int *)(& dsize), tmp___516,
                                    tmp___515, tmp___514);
          if (tmp___517 == -1) {
            tmp___518 = EC32(optional_hdr.AddressOfEntryPoint);
            tmp___519 = EC32((section_hdr + (i + 1U))->VirtualAddress);
            tmp___520 = EC32((section_hdr + i)->VirtualAddress);
            tmp___521 = upx_inflate2b(src + 21, (int )(ssize - 21U), dest, (int *)(& dsize),
                                      tmp___520, tmp___519, tmp___518 - 21U);
            if (tmp___521 == -1) {
              cli_dbgmsg("UPX: NRV2B decompressor failed\n");
            } else {
              upx_success = 1U;
              cli_dbgmsg("UPX: Successfully decompressed with NRV2B\n");
            }
          } else {
            upx_success = 1U;
            cli_dbgmsg("UPX: Successfully decompressed with NRV2B\n");
          }
        }
      }
      if (! upx_success) {
        if ((unsigned int )upxfn != (unsigned int )(& upx_inflate2d)) {
          tmp___522 = EC32(optional_hdr.AddressOfEntryPoint);
          tmp___523 = EC32((section_hdr + (i + 1U))->VirtualAddress);
          tmp___524 = EC32((section_hdr + i)->VirtualAddress);
          tmp___525 = upx_inflate2d(src, (int )ssize, dest, (int *)(& dsize), tmp___524,
                                    tmp___523, tmp___522);
          if (tmp___525 == -1) {
            tmp___526 = EC32(optional_hdr.AddressOfEntryPoint);
            tmp___527 = EC32((section_hdr + (i + 1U))->VirtualAddress);
            tmp___528 = EC32((section_hdr + i)->VirtualAddress);
            tmp___529 = upx_inflate2d(src + 21, (int )(ssize - 21U), dest, (int *)(& dsize),
                                      tmp___528, tmp___527, tmp___526 - 21U);
            if (tmp___529 == -1) {
              cli_dbgmsg("UPX: NRV2D decompressor failed\n");
            } else {
              upx_success = 1U;
              cli_dbgmsg("UPX: Successfully decompressed with NRV2D\n");
            }
          } else {
            upx_success = 1U;
            cli_dbgmsg("UPX: Successfully decompressed with NRV2D\n");
          }
        }
      }
      if (! upx_success) {
        if ((unsigned int )upxfn != (unsigned int )(& upx_inflate2e)) {
          tmp___530 = EC32(optional_hdr.AddressOfEntryPoint);
          tmp___531 = EC32((section_hdr + (i + 1U))->VirtualAddress);
          tmp___532 = EC32((section_hdr + i)->VirtualAddress);
          tmp___533 = upx_inflate2e(src, (int )ssize, dest, (int *)(& dsize), tmp___532,
                                    tmp___531, tmp___530);
          if (tmp___533 == -1) {
            tmp___534 = EC32(optional_hdr.AddressOfEntryPoint);
            tmp___535 = EC32((section_hdr + (i + 1U))->VirtualAddress);
            tmp___536 = EC32((section_hdr + i)->VirtualAddress);
            tmp___537 = upx_inflate2e(src + 21, (int )(ssize - 21U), dest, (int *)(& dsize),
                                      tmp___536, tmp___535, tmp___534 - 21U);
            if (tmp___537 == -1) {
              cli_dbgmsg("UPX: NRV2E decompressor failed\n");
            } else {
              upx_success = 1U;
              cli_dbgmsg("UPX: Successfully decompressed with NRV2E\n");
            }
          } else {
            upx_success = 1U;
            cli_dbgmsg("UPX: Successfully decompressed with NRV2E\n");
          }
        }
      }
      if (! upx_success) {
        cli_dbgmsg("UPX: All decompressors failed\n");
        free((void *)src);
        free((void *)dest);
      }
    }
    if (upx_success) {
      free((void *)src);
      free((void *)section_hdr);
      tempfile = cli_gentemp((char const   *)((void *)0));
      ndesc = open((char const   *)tempfile, 578, 448);
      if (ndesc < 0) {
        cli_dbgmsg("UPX/FSG: Can\'t create file %s\n", tempfile);
        free((void *)tempfile);
        free((void *)dest);
        return (-12);
      }
      tmp___538 = write(ndesc, (void const   *)dest, dsize);
      if ((unsigned int )tmp___538 != dsize) {
        cli_dbgmsg("UPX/FSG: Can\'t write %d bytes\n", dsize);
        free((void *)tempfile);
        free((void *)dest);
        close(ndesc);
        return (-12);
      }
      free((void *)dest);
      fsync(ndesc);
      lseek(ndesc, 0L, 0);
      if (cli_leavetemps_flag) {
        cli_dbgmsg("UPX/FSG: Decompressed data saved in %s\n", tempfile);
      }
      cli_dbgmsg("***** Scanning rebuilt PE file *****\n");
      ret = cli_magic_scandesc(ndesc, virname, scanned, root, limits, options, arec,
                               mrec);
      if (ret == 1) {
        close(ndesc);
        if (! cli_leavetemps_flag) {
          unlink((char const   *)tempfile);
        }
        free((void *)tempfile);
        return (1);
      }
      close(ndesc);
      if (! cli_leavetemps_flag) {
        unlink((char const   *)tempfile);
      }
      free((void *)tempfile);
      return (ret);
    }
  }
  found = 2U;
  lseek(desc, (long )ep, 0);
  tmp___539 = read(desc, (void *)(buff), 200U);
  if (tmp___539 != 200) {
    cli_dbgmsg("Can\'t read 200 bytes\n");
    free((void *)section_hdr);
    return (-12);
  }
  if ((int )buff[0] != -72) {
    goto _L___86;
  } else {
    tmp___543 = cli_readint32((char const   *)(buff + 1));
    tmp___544 = EC32((section_hdr + ((int )nsections - 1))->VirtualAddress);
    tmp___545 = EC32(optional_hdr.ImageBase);
    if ((unsigned int )tmp___543 != tmp___544 + tmp___545) {
      _L___86: 
      if ((int )nsections < 2) {
        found = 0U;
      } else {
        if ((int )buff[0] != -72) {
          found = 0U;
        } else {
          tmp___540 = cli_readint32((char const   *)(buff + 1));
          tmp___541 = EC32((section_hdr + ((int )nsections - 2))->VirtualAddress);
          tmp___542 = EC32(optional_hdr.ImageBase);
          if ((unsigned int )tmp___540 != tmp___541 + tmp___542) {
            found = 0U;
          } else {
            found = 1U;
          }
        }
      }
    }
  }
  if (found) {
    cli_dbgmsg("Petite: v2.%d compression detected\n", found);
    tmp___561 = cli_readint32((char const   *)(buff + 128));
    if (tmp___561 == 373069965) {
      cli_dbgmsg("Petite: level zero compression is not supported yet\n");
    } else {
      dsize = max - min;
      if (limits) {
        if (limits->maxfilesize) {
          if ((unsigned long )dsize > limits->maxfilesize) {
            cli_dbgmsg("Petite: Size exceeded (dsize: %d, max: %lu)\n", dsize, limits->maxfilesize);
            free((void *)section_hdr);
            return (0);
          }
        }
      }
      dest = (char *)cli_calloc(dsize, sizeof(char ));
      if ((unsigned int )dest == (unsigned int )((void *)0)) {
        cli_dbgmsg("Petite: Can\'t allocate %d bytes\n", dsize);
        free((void *)section_hdr);
        return (-3);
      }
      i = 0U;
      while (i < (unsigned int )nsections) {
        if ((section_hdr + i)->SizeOfRawData) {
          tmp___547 = EC32((section_hdr + i)->VirtualAddress);
          tmp___548 = cli_rawaddr(tmp___547, section_hdr, nsections, & err);
          offset = tmp___548;
          if (err) {
            free((void *)section_hdr);
            free((void *)dest);
            return (-12);
          } else {
            tmp___549 = lseek(desc, (long )offset, 0);
            if (tmp___549 == -1L) {
              free((void *)section_hdr);
              free((void *)dest);
              return (-12);
            } else {
              tmp___550 = EC32((section_hdr + i)->SizeOfRawData);
              tmp___551 = EC32((section_hdr + i)->VirtualAddress);
              tmp___552 = read(desc, (void *)((dest + tmp___551) - min), tmp___550);
              tmp___553 = EC32((section_hdr + i)->SizeOfRawData);
              if ((unsigned int )tmp___552 != tmp___553) {
                free((void *)section_hdr);
                free((void *)dest);
                return (-12);
              }
            }
          }
        }
        i ++;
      }
      tempfile = cli_gentemp((char const   *)((void *)0));
      ndesc = open((char const   *)tempfile, 578, 448);
      if (ndesc < 0) {
        cli_dbgmsg("Petite: Can\'t create file %s\n", tempfile);
        free((void *)tempfile);
        free((void *)section_hdr);
        free((void *)dest);
        return (-12);
      }
      tmp___554 = EC32(optional_hdr.DataDirectory[2].Size);
      tmp___555 = EC32(optional_hdr.DataDirectory[2].VirtualAddress);
      tmp___556 = EC32(optional_hdr.AddressOfEntryPoint);
      tmp___557 = EC32(optional_hdr.ImageBase);
      if (found == 1U) {
        tmp___558 = 1;
      } else {
        tmp___558 = 0;
      }
      tmp___559 = petite_inflate2x_1to9(dest, min, (int )(max - min), section_hdr,
                                        (int )nsections - tmp___558, tmp___557, tmp___556,
                                        ndesc, (int )found, tmp___555, tmp___554);
      switch (tmp___559) {
      case 1: 
      cli_dbgmsg("Petite: Unpacked and rebuilt executable saved in %s\n", tempfile);
      cli_dbgmsg("***** Scanning rebuilt PE file *****\n");
      break;
      case 0: 
      cli_dbgmsg("Petite: Unpacked data saved in %s\n", tempfile);
      break;
      default: 
      cli_dbgmsg("Petite: Unpacking failed\n");
      }
      free((void *)dest);
      fsync(ndesc);
      lseek(ndesc, 0L, 0);
      tmp___560 = cli_magic_scandesc(ndesc, virname, scanned, root, limits, options,
                                     arec, mrec);
      if (tmp___560 == 1) {
        free((void *)section_hdr);
        close(ndesc);
        if (! cli_leavetemps_flag) {
          unlink((char const   *)tempfile);
          free((void *)tempfile);
        } else {
          free((void *)tempfile);
        }
        return (1);
      }
      close(ndesc);
      if (! cli_leavetemps_flag) {
        unlink((char const   *)tempfile);
        free((void *)tempfile);
      } else {
        free((void *)tempfile);
      }
    }
  }
  free((void *)section_hdr);
  return (0);
}
}
int cli_peheader(int desc , struct cli_pe_info *peinfo ) 
{ uint16_t e_magic ;
  uint32_t e_lfanew ;
  struct pe_image_file_hdr file_hdr ;
  struct pe_image_optional_hdr optional_hdr ;
  struct pe_image_section_hdr *section_hdr ;
  struct stat sb ;
  int i ;
  unsigned int err ;
  ssize_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  ssize_t tmp___2 ;
  __off_t tmp___3 ;
  ssize_t tmp___4 ;
  uint32_t tmp___5 ;
  uint16_t tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___9 ;
  ssize_t tmp___11 ;
  uint32_t tmp___12 ;

  {
  cli_dbgmsg("in cli_peheader\n");
  tmp = read(desc, (void *)(& e_magic), sizeof(e_magic));
  if ((unsigned int )tmp != sizeof(e_magic)) {
    cli_dbgmsg("Can\'t read DOS signature\n");
    return (-1);
  }
  tmp___0 = EC16(e_magic);
  if ((int )tmp___0 != 23117) {
    tmp___1 = EC16(e_magic);
    if ((int )tmp___1 != 19802) {
      cli_dbgmsg("Invalid DOS signature\n");
      return (-1);
    }
  }
  lseek(desc, 58L, 1);
  tmp___2 = read(desc, (void *)(& e_lfanew), sizeof(e_lfanew));
  if ((unsigned int )tmp___2 != sizeof(e_lfanew)) {
    cli_dbgmsg("Can\'t read new header address\n");
    return (-1);
  }
  e_lfanew = EC32(e_lfanew);
  if (! e_lfanew) {
    cli_dbgmsg("Not a PE file\n");
    return (-1);
  }
  tmp___3 = lseek(desc, (long )e_lfanew, 0);
  if (tmp___3 < 0L) {
    cli_dbgmsg("Can\'t lseek to e_lfanew\n");
    return (-1);
  }
  tmp___4 = read(desc, (void *)(& file_hdr), sizeof(struct pe_image_file_hdr ));
  if ((unsigned int )tmp___4 != sizeof(struct pe_image_file_hdr )) {
    cli_dbgmsg("Can\'t read file header\n");
    return (-1);
  }
  tmp___5 = EC32(file_hdr.Magic);
  if (tmp___5 != 17744U) {
    cli_dbgmsg("Invalid PE signature (probably NE file)\n");
    return (-1);
  }
  tmp___6 = EC16(file_hdr.SizeOfOptionalHeader);
  if ((unsigned int )tmp___6 != sizeof(struct pe_image_optional_hdr )) {
    cli_warnmsg("Broken PE header detected.\n");
    return (-1);
  }
  peinfo->nsections = EC16(file_hdr.NumberOfSections);
  tmp___7 = read(desc, (void *)(& optional_hdr), sizeof(struct pe_image_optional_hdr ));
  if ((unsigned int )tmp___7 != sizeof(struct pe_image_optional_hdr )) {
    cli_dbgmsg("Can\'t optional file header\n");
    return (-1);
  }
  peinfo->section = (struct SECTION *)cli_calloc((unsigned int )peinfo->nsections,
                                                 sizeof(struct SECTION ));
  if (! peinfo->section) {
    cli_dbgmsg("Can\'t allocate memory for section headers\n");
    return (-1);
  }
  tmp___9 = fstat__extinline(desc, & sb);
  if (tmp___9 == -1) {
    cli_dbgmsg("fstat failed\n");
    free((void *)peinfo->section);
    return (-1);
  }
  section_hdr = (struct pe_image_section_hdr *)cli_calloc((unsigned int )peinfo->nsections,
                                                          sizeof(struct pe_image_section_hdr ));
  if (! section_hdr) {
    cli_dbgmsg("Can\'t allocate memory for section headers\n");
    free((void *)peinfo->section);
    return (-1);
  }
  i = 0;
  while (i < (int )peinfo->nsections) {
    tmp___11 = read(desc, (void *)(section_hdr + i), sizeof(struct pe_image_section_hdr ));
    if ((unsigned int )tmp___11 != sizeof(struct pe_image_section_hdr )) {
      cli_dbgmsg("Can\'t read section header\n");
      cli_dbgmsg("Possibly broken PE file\n");
      free((void *)section_hdr);
      free((void *)peinfo->section);
      return (-1);
    }
    (peinfo->section + i)->rva = EC32((section_hdr + i)->VirtualAddress);
    (peinfo->section + i)->vsz = EC32((section_hdr + i)->VirtualSize);
    (peinfo->section + i)->raw = EC32((section_hdr + i)->PointerToRawData);
    (peinfo->section + i)->rsz = EC32((section_hdr + i)->SizeOfRawData);
    i ++;
  }
  tmp___12 = EC32(optional_hdr.AddressOfEntryPoint);
  peinfo->ep = cli_rawaddr(tmp___12, section_hdr, peinfo->nsections, & err);
  if (err) {
    cli_dbgmsg("Possibly broken PE file\n");
    free((void *)section_hdr);
    free((void *)peinfo->section);
    return (-1);
  }
  free((void *)section_hdr);
  return (0);
}
}
#pragma merger(0,"/tmp/cil-QQT0Lwuj.i","-g -O2 -fPIC")
struct mspack_system *mspack_default_system ;
int mspack_sys_filelen(struct mspack_system *system___0 , struct mspack_file *file ,
                       off_t *length ) ;
int mspack_valid_system(struct mspack_system *sys ) ;
struct mszipd_stream *mszipd_init(struct mspack_system *system___0 , struct mspack_file *input ,
                                  struct mspack_file *output , int input_buffer_size ,
                                  int repair_mode ) ;
int mszipd_decompress(struct mszipd_stream *zip , off_t out_bytes ) ;
void mszipd_free(struct mszipd_stream *zip ) ;
struct qtmd_stream *qtmd_init(struct mspack_system *system___0 , struct mspack_file *input ,
                              struct mspack_file *output , int window_bits , int input_buffer_size ) ;
int qtmd_decompress(struct qtmd_stream *qtm , off_t out_bytes ) ;
void qtmd_free(struct qtmd_stream *qtm ) ;
struct lzxd_stream *lzxd_init(struct mspack_system *system___0 , struct mspack_file *input ,
                              struct mspack_file *output , int window_bits , int reset_interval ,
                              int input_buffer_size , off_t output_length ) ;
void lzxd_set_output_length(struct lzxd_stream *lzx , off_t out_bytes ) ;
int lzxd_decompress(struct lzxd_stream *lzx , off_t out_bytes ) ;
void lzxd_free(struct lzxd_stream *lzx ) ;
static struct mscabd_cabinet *cabd_open(struct mscab_decompressor *base , char *filename ) ;
static struct mscabd_cabinet *cabd_dopen(struct mscab_decompressor *base , int desc ) ;
static void cabd_close(struct mscab_decompressor *base , struct mscabd_cabinet *origcab ) ;
static int cabd_read_headers(struct mspack_system *sys , struct mspack_file *fh ,
                             struct mscabd_cabinet_p *cab , off_t offset , int quiet ) ;
static char *cabd_read_string(struct mspack_system *sys , struct mspack_file *fh ,
                              struct mscabd_cabinet_p *cab , int *error ) ;
static struct mscabd_cabinet *cabd_search(struct mscab_decompressor *base , char *filename ) ;
static struct mscabd_cabinet *cabd_dsearch(struct mscab_decompressor *base , int desc ) ;
static int cabd_find(struct mscab_decompressor_p *this , unsigned char *buf , struct mspack_file *fh ,
                     char *filename , int desc , off_t flen , unsigned int *firstlen ,
                     struct mscabd_cabinet_p **firstcab ) ;
static int cabd_prepend(struct mscab_decompressor *base , struct mscabd_cabinet *cab ,
                        struct mscabd_cabinet *prevcab ) ;
static int cabd_append(struct mscab_decompressor *base , struct mscabd_cabinet *cab ,
                       struct mscabd_cabinet *nextcab ) ;
static int cabd_merge(struct mscab_decompressor *base , struct mscabd_cabinet *lcab ,
                      struct mscabd_cabinet *rcab ) ;
static int cabd_extract(struct mscab_decompressor *base , struct mscabd_file *file ,
                        char *filename ) ;
static int cabd_init_decomp(struct mscab_decompressor_p *this , unsigned int ct ) ;
static void cabd_free_decomp(struct mscab_decompressor_p *this ) ;
static int cabd_sys_read(struct mspack_file *file , void *buffer , int bytes ) ;
static int cabd_sys_write(struct mspack_file *file , void *buffer , int bytes ) ;
static int cabd_sys_read_block(struct mspack_system *sys , struct mscabd_decompress_state *d ,
                               int *out , int ignore_cksum ) ;
static unsigned int cabd_checksum(unsigned char *data , unsigned int bytes , unsigned int cksum ) ;
static struct noned_state *noned_init(struct mspack_system *sys , struct mspack_file *in ,
                                      struct mspack_file *out , int bufsize ) ;
static int noned_decompress(struct noned_state *s , off_t bytes ) ;
static void noned_free(struct noned_state *state ) ;
static int cabd_param(struct mscab_decompressor *base , int param , int value ) ;
static int cabd_error(struct mscab_decompressor *base ) ;
struct mscab_decompressor *mspack_create_cab_decompressor(struct mspack_system *sys ) 
{ struct mscab_decompressor_p *this ;
  int tmp ;

  {
  this = (struct mscab_decompressor_p *)((void *)0);
  if (! sys) {
    sys = mspack_default_system;
  }
  tmp = mspack_valid_system(sys);
  if (! tmp) {
    return ((struct mscab_decompressor *)((void *)0));
  }
  this = (struct mscab_decompressor_p *)((*(sys->alloc)))(sys, sizeof(struct mscab_decompressor_p ));
  if (this) {
    this->base.open = & cabd_open;
    this->base.dopen = & cabd_dopen;
    this->base.close = & cabd_close;
    this->base.search = & cabd_search;
    this->base.dsearch = & cabd_dsearch;
    this->base.extract = & cabd_extract;
    this->base.prepend = & cabd_prepend;
    this->base.append = & cabd_append;
    this->base.set_param = & cabd_param;
    this->base.last_error = & cabd_error;
    this->system = sys;
    this->d = (struct mscabd_decompress_state *)((void *)0);
    this->error = 0;
    this->param[0] = 32768;
    this->param[1] = 0;
    this->param[2] = 4096;
  }
  return ((struct mscab_decompressor *)this);
}
}
void mspack_destroy_cab_decompressor(struct mscab_decompressor *base ) 
{ struct mscab_decompressor_p *this ;
  struct mspack_system *sys ;

  {
  this = (struct mscab_decompressor_p *)base;
  if (this) {
    sys = this->system;
    cabd_free_decomp(this);
    if (this->d) {
      if ((this->d)->infh) {
        ((*(sys->close)))((this->d)->infh);
      }
      ((*(sys->free)))((void *)this->d);
    }
    ((*(sys->free)))((void *)this);
  }
  return;
}
}
static struct mscabd_cabinet *cabd_open(struct mscab_decompressor *base , char *filename ) 
{ struct mscab_decompressor_p *this ;
  struct mscabd_cabinet_p *cab ;
  struct mspack_system *sys ;
  struct mspack_file *fh ;
  int error ;

  {
  this = (struct mscab_decompressor_p *)base;
  cab = (struct mscabd_cabinet_p *)((void *)0);
  if (! base) {
    return ((struct mscabd_cabinet *)((void *)0));
  }
  sys = this->system;
  fh = ((*(sys->open)))(sys, filename, 0);
  if (fh) {
    cab = (struct mscabd_cabinet_p *)((*(sys->alloc)))(sys, sizeof(struct mscabd_cabinet_p ));
    if (cab) {
      cab->base.filename = filename;
      error = cabd_read_headers(sys, fh, cab, 0L, 0);
      if (error) {
        cabd_close(base, (struct mscabd_cabinet *)cab);
        cab = (struct mscabd_cabinet_p *)((void *)0);
      }
      this->error = error;
    } else {
      this->error = 6;
    }
    ((*(sys->close)))(fh);
  } else {
    this->error = 2;
  }
  return ((struct mscabd_cabinet *)cab);
}
}
static struct mscabd_cabinet *cabd_dopen(struct mscab_decompressor *base , int desc ) 
{ struct mscab_decompressor_p *this ;
  struct mscabd_cabinet_p *cab ;
  struct mspack_system *sys ;
  struct mspack_file *fh ;
  int error ;

  {
  this = (struct mscab_decompressor_p *)base;
  cab = (struct mscabd_cabinet_p *)((void *)0);
  if (! base) {
    return ((struct mscabd_cabinet *)((void *)0));
  }
  sys = this->system;
  fh = ((*(sys->dopen)))(sys, desc, 0);
  if (fh) {
    cab = (struct mscabd_cabinet_p *)((*(sys->alloc)))(sys, sizeof(struct mscabd_cabinet_p ));
    if (cab) {
      cab->base.filename = (char *)"descriptor";
      cab->base.desc = dup(desc);
      error = cabd_read_headers(sys, fh, cab, 0L, 0);
      if (error) {
        cabd_close(base, (struct mscabd_cabinet *)cab);
        cab = (struct mscabd_cabinet_p *)((void *)0);
      }
      this->error = error;
    } else {
      this->error = 6;
    }
    ((*(sys->close)))(fh);
  } else {
    this->error = 2;
  }
  return ((struct mscabd_cabinet *)cab);
}
}
static void cabd_close(struct mscab_decompressor *base , struct mscabd_cabinet *origcab ) 
{ struct mscab_decompressor_p *this ;
  struct mscabd_folder_data *dat ;
  struct mscabd_folder_data *ndat ;
  struct mscabd_cabinet *cab ;
  struct mscabd_cabinet *ncab ;
  struct mscabd_folder *fol ;
  struct mscabd_folder *nfol ;
  struct mscabd_file *fi ;
  struct mscabd_file *nfi ;
  struct mspack_system *sys ;

  {
  this = (struct mscab_decompressor_p *)base;
  if (origcab->desc) {
    close(origcab->desc);
  }
  if (! base) {
    return;
  }
  sys = this->system;
  this->error = 0;
  while (origcab) {
    fi = origcab->files;
    while (fi) {
      nfi = fi->next;
      ((*(sys->free)))((void *)fi->filename);
      ((*(sys->free)))((void *)fi);
      fi = nfi;
    }
    fol = origcab->folders;
    while (fol) {
      nfol = fol->next;
      if (this->d) {
        if ((unsigned int )(this->d)->folder == (unsigned int )((struct mscabd_folder_p *)fol)) {
          if ((this->d)->infh) {
            ((*(sys->close)))((this->d)->infh);
          }
          cabd_free_decomp(this);
          ((*(sys->free)))((void *)this->d);
          this->d = (struct mscabd_decompress_state *)((void *)0);
        }
      }
      dat = ((struct mscabd_folder_p *)fol)->data.next;
      while (dat) {
        ndat = dat->next;
        ((*(sys->free)))((void *)dat);
        dat = ndat;
      }
      ((*(sys->free)))((void *)fol);
      fol = nfol;
    }
    cab = origcab;
    while (cab) {
      ncab = cab->prevcab;
      ((*(sys->free)))((void *)cab->prevname);
      ((*(sys->free)))((void *)cab->nextname);
      ((*(sys->free)))((void *)cab->previnfo);
      ((*(sys->free)))((void *)cab->nextinfo);
      if ((unsigned int )cab != (unsigned int )origcab) {
        ((*(sys->free)))((void *)cab);
      }
      cab = ncab;
    }
    cab = origcab->nextcab;
    while (cab) {
      ncab = cab->nextcab;
      ((*(sys->free)))((void *)cab->prevname);
      ((*(sys->free)))((void *)cab->nextname);
      ((*(sys->free)))((void *)cab->previnfo);
      ((*(sys->free)))((void *)cab->nextinfo);
      ((*(sys->free)))((void *)cab);
      cab = ncab;
    }
    cab = origcab->next;
    ((*(sys->free)))((void *)origcab);
    origcab = cab;
  }
  return;
}
}
static int cabd_read_headers(struct mspack_system *sys , struct mspack_file *fh ,
                             struct mscabd_cabinet_p *cab , off_t offset , int quiet ) 
{ int num_folders ;
  int num_files ;
  int folder_resv ;
  int i ;
  int x ;
  struct mscabd_folder_p *fol ;
  struct mscabd_folder_p *linkfol ;
  struct mscabd_file *file ;
  struct mscabd_file *linkfile ;
  unsigned char buf[64] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct mscabd_folder *ifol ;
  int tmp___6 ;
  struct mscabd_folder *ifol___0 ;

  {
  linkfol = (struct mscabd_folder_p *)((void *)0);
  linkfile = (struct mscabd_file *)((void *)0);
  cab->base.next = (struct mscabd_cabinet *)((void *)0);
  cab->base.files = (struct mscabd_file *)((void *)0);
  cab->base.folders = (struct mscabd_folder *)((void *)0);
  cab->base.nextcab = (struct mscabd_cabinet *)((void *)0);
  cab->base.prevcab = cab->base.nextcab;
  cab->base.nextname = (char *)((void *)0);
  cab->base.prevname = cab->base.nextname;
  cab->base.nextinfo = (char *)((void *)0);
  cab->base.previnfo = cab->base.nextinfo;
  cab->base.base_offset = offset;
  tmp = ((*(sys->seek)))(fh, offset, 0);
  if (tmp) {
    return (5);
  }
  tmp___0 = ((*(sys->read)))(fh, (void *)(buf), 36);
  if (tmp___0 != 36) {
    return (3);
  }
  if ((((((int )buf[3] << 24) | ((int )buf[2] << 16)) | ((int )buf[1] << 8)) | (int )buf[0]) !=
      1178817357) {
    return (7);
  }
  cab->base.length = (unsigned int )(((((int )(*(& buf[8] + 3)) << 24) | ((int )(*(& buf[8] +
                                                                                   2)) <<
                                                                          16)) | ((int )(*(& buf[8] +
                                                                                           1)) <<
                                                                                  8)) |
                                     (int )(*(& buf[8] + 0)));
  cab->base.set_id = (unsigned short )(((int )(*(& buf[32] + 1)) << 8) | (int )(*(& buf[32] +
                                                                                  0)));
  cab->base.set_index = (unsigned short )(((int )(*(& buf[34] + 1)) << 8) | (int )(*(& buf[34] +
                                                                                     0)));
  num_folders = ((int )(*(& buf[26] + 1)) << 8) | (int )(*(& buf[26] + 0));
  if (num_folders == 0) {
    if (! quiet) {
      ((*(sys->message)))(fh, (char *)"no folders in cabinet.");
    }
    return (8);
  }
  num_files = ((int )(*(& buf[28] + 1)) << 8) | (int )(*(& buf[28] + 0));
  if (num_files == 0) {
    if (! quiet) {
      ((*(sys->message)))(fh, (char *)"no files in cabinet.");
    }
    return (8);
  }
  if ((int )buf[25] != 1) {
    if ((int )buf[24] != 3) {
      if (! quiet) {
        ((*(sys->message)))(fh, (char *)"WARNING; cabinet version is not 1.3");
      }
    }
  }
  cab->base.flags = ((int )(*(& buf[30] + 1)) << 8) | (int )(*(& buf[30] + 0));
  if (cab->base.flags & 4) {
    tmp___1 = ((*(sys->read)))(fh, (void *)(buf), 4);
    if (tmp___1 != 4) {
      return (3);
    }
    cab->base.header_resv = (unsigned short )(((int )buf[1] << 8) | (int )buf[0]);
    folder_resv = (int )buf[2];
    cab->block_resv = (int )buf[3];
    if ((int )cab->base.header_resv > 60000) {
      if (! quiet) {
        ((*(sys->message)))(fh, (char *)"WARNING; reserved header > 60000.");
      }
    }
    if (cab->base.header_resv) {
      tmp___2 = ((*(sys->seek)))(fh, (long )cab->base.header_resv, 1);
      if (tmp___2) {
        return (5);
      }
    }
  } else {
    cab->base.header_resv = (unsigned short)0;
    folder_resv = 0;
    cab->block_resv = 0;
  }
  if (cab->base.flags & 1) {
    cab->base.prevname = cabd_read_string(sys, fh, cab, & x);
    if (x) {
      return (x);
    }
    cab->base.previnfo = cabd_read_string(sys, fh, cab, & x);
    if (x) {
      return (x);
    }
  }
  if (cab->base.flags & 2) {
    cab->base.nextname = cabd_read_string(sys, fh, cab, & x);
    if (x) {
      return (x);
    }
    cab->base.nextinfo = cabd_read_string(sys, fh, cab, & x);
    if (x) {
      return (x);
    }
  }
  i = 0;
  while (i < num_folders) {
    tmp___3 = ((*(sys->read)))(fh, (void *)(buf), 8);
    if (tmp___3 != 8) {
      return (3);
    }
    if (folder_resv) {
      tmp___4 = ((*(sys->seek)))(fh, (long )folder_resv, 1);
      if (tmp___4) {
        return (5);
      }
    }
    fol = (struct mscabd_folder_p *)((*(sys->alloc)))(sys, sizeof(struct mscabd_folder_p ));
    if (! fol) {
      return (6);
    }
    fol->base.next = (struct mscabd_folder *)((void *)0);
    fol->base.comp_type = ((int )(*(& buf[6] + 1)) << 8) | (int )(*(& buf[6] + 0));
    fol->base.num_blocks = (unsigned int )(((int )(*(& buf[4] + 1)) << 8) | (int )(*(& buf[4] +
                                                                                     0)));
    fol->data.next = (struct mscabd_folder_data *)((void *)0);
    fol->data.cab = cab;
    fol->data.offset = offset + (long )((unsigned int )(((((int )buf[3] << 24) | ((int )buf[2] <<
                                                                                  16)) |
                                                         ((int )buf[1] << 8)) | (int )buf[0]));
    fol->merge_prev = (struct mscabd_file *)((void *)0);
    fol->merge_next = (struct mscabd_file *)((void *)0);
    if (! linkfol) {
      cab->base.folders = (struct mscabd_folder *)fol;
    } else {
      linkfol->base.next = (struct mscabd_folder *)fol;
    }
    linkfol = fol;
    i ++;
  }
  i = 0;
  while (i < num_files) {
    tmp___5 = ((*(sys->read)))(fh, (void *)(buf), 16);
    if (tmp___5 != 16) {
      return (3);
    }
    file = (struct mscabd_file *)((*(sys->alloc)))(sys, sizeof(struct mscabd_file ));
    if (! file) {
      return (6);
    }
    file->next = (struct mscabd_file *)((void *)0);
    file->length = (unsigned int )(((((int )buf[3] << 24) | ((int )buf[2] << 16)) |
                                    ((int )buf[1] << 8)) | (int )buf[0]);
    file->attribs = ((int )(*(& buf[14] + 1)) << 8) | (int )(*(& buf[14] + 0));
    file->offset = (unsigned int )(((((int )(*(& buf[4] + 3)) << 24) | ((int )(*(& buf[4] +
                                                                                 2)) <<
                                                                        16)) | ((int )(*(& buf[4] +
                                                                                         1)) <<
                                                                                8)) |
                                   (int )(*(& buf[4] + 0)));
    x = ((int )(*(& buf[8] + 1)) << 8) | (int )(*(& buf[8] + 0));
    if (x < 65533) {
      ifol = cab->base.folders;
      while (1) {
        tmp___6 = x;
        x --;
        if (! tmp___6) {
          break;
        }
        if (ifol) {
          ifol = ifol->next;
        }
      }
      file->folder = ifol;
      if (! ifol) {
        ((*(sys->free)))((void *)file);
        return (8);
      }
    } else {
      if (x == 65534) {
        goto _L;
      } else {
        if (x == 65535) {
          _L: 
          ifol___0 = cab->base.folders;
          while (ifol___0->next) {
            ifol___0 = ifol___0->next;
          }
          file->folder = ifol___0;
          fol = (struct mscabd_folder_p *)ifol___0;
          if (! fol->merge_next) {
            fol->merge_next = file;
          }
        }
      }
      if (x == 65533) {
        goto _L___0;
      } else {
        if (x == 65535) {
          _L___0: 
          file->folder = cab->base.folders;
          fol = (struct mscabd_folder_p *)file->folder;
          if (! fol->merge_prev) {
            fol->merge_prev = file;
          }
        }
      }
    }
    x = ((int )(*(& buf[12] + 1)) << 8) | (int )(*(& buf[12] + 0));
    file->time_h = (char )(x >> 11);
    file->time_m = (char )((x >> 5) & 63);
    file->time_s = (char )((x << 1) & 62);
    x = ((int )(*(& buf[10] + 1)) << 8) | (int )(*(& buf[10] + 0));
    file->date_d = (char )(x & 31);
    file->date_m = (char )((x >> 5) & 15);
    file->date_y = (x >> 9) + 1980;
    file->filename = cabd_read_string(sys, fh, cab, & x);
    if (x) {
      ((*(sys->free)))((void *)file);
      return (x);
    }
    if (! linkfile) {
      cab->base.files = file;
    } else {
      linkfile->next = file;
    }
    linkfile = file;
    i ++;
  }
  return (0);
}
}
static char *cabd_read_string(struct mspack_system *sys , struct mspack_file *fh ,
                              struct mscabd_cabinet_p *cab , int *error ) 
{ off_t base ;
  off_t tmp ;
  char buf[256] ;
  char *str ;
  unsigned int len ;
  unsigned int i ;
  unsigned int ok ;
  int tmp___0 ;

  {
  tmp = ((*(sys->tell)))(fh);
  base = tmp;
  len = (unsigned int )((*(sys->read)))(fh, (void *)(buf), 256);
  i = 0U;
  ok = 0U;
  while (i < len) {
    if (! buf[i]) {
      ok = 1U;
      break;
    }
    i ++;
  }
  if (! ok) {
    (*error) = 8;
    return ((char *)((void *)0));
  }
  len = i + 1U;
  tmp___0 = ((*(sys->seek)))(fh, base + (long )len, 0);
  if (tmp___0) {
    (*error) = 5;
    return ((char *)((void *)0));
  }
  str = (char *)((*(sys->alloc)))(sys, len);
  if (! str) {
    (*error) = 6;
    return ((char *)((void *)0));
  }
  ((*(sys->copy)))((void *)(buf), (void *)str, len);
  (*error) = 0;
  return (str);
}
}
static struct mscabd_cabinet *cabd_search(struct mscab_decompressor *base , char *filename ) 
{ struct mscab_decompressor_p *this ;
  struct mscabd_cabinet_p *cab ;
  struct mspack_system *sys ;
  unsigned char *search_buf ;
  struct mspack_file *fh ;
  unsigned int firstlen ;
  off_t filelen ;

  {
  this = (struct mscab_decompressor_p *)base;
  cab = (struct mscabd_cabinet_p *)((void *)0);
  firstlen = 0U;
  if (! base) {
    return ((struct mscabd_cabinet *)((void *)0));
  }
  sys = this->system;
  search_buf = (unsigned char *)((*(sys->alloc)))(sys, (unsigned int )this->param[0]);
  if (! search_buf) {
    this->error = 6;
    return ((struct mscabd_cabinet *)((void *)0));
  }
  fh = ((*(sys->open)))(sys, filename, 0);
  if (fh) {
    this->error = mspack_sys_filelen(sys, fh, & filelen);
    if (! this->error) {
      this->error = cabd_find(this, search_buf, fh, filename, 0, filelen, & firstlen,
                              & cab);
    }
    if (firstlen) {
      if ((unsigned long )firstlen != (unsigned long )filelen) {
        if (! cab) {
          goto _L;
        } else {
          if (cab->base.base_offset == 0L) {
            _L: 
            if ((unsigned long )firstlen < (unsigned long )filelen) {
              ((*(sys->message)))(fh, (char *)"WARNING; possible %u extra bytes at end of file.",
                                  (unsigned int )((unsigned long )filelen - (unsigned long )firstlen));
            } else {
              ((*(sys->message)))(fh, (char *)"WARNING; file possibly truncated by %u bytes.",
                                  (unsigned int )((unsigned long )firstlen - (unsigned long )filelen));
            }
          }
        }
      }
    }
    ((*(sys->close)))(fh);
  } else {
    this->error = 2;
  }
  ((*(sys->free)))((void *)search_buf);
  return ((struct mscabd_cabinet *)cab);
}
}
static struct mscabd_cabinet *cabd_dsearch(struct mscab_decompressor *base , int desc ) 
{ struct mscab_decompressor_p *this ;
  struct mscabd_cabinet_p *cab ;
  struct mspack_system *sys ;
  unsigned char *search_buf ;
  struct mspack_file *fh ;
  unsigned int firstlen ;
  off_t filelen ;
  char *filename ;

  {
  this = (struct mscab_decompressor_p *)base;
  cab = (struct mscabd_cabinet_p *)((void *)0);
  firstlen = 0U;
  filename = (char *)"descriptor";
  if (! base) {
    return ((struct mscabd_cabinet *)((void *)0));
  }
  sys = this->system;
  search_buf = (unsigned char *)((*(sys->alloc)))(sys, (unsigned int )this->param[0]);
  if (! search_buf) {
    this->error = 6;
    return ((struct mscabd_cabinet *)((void *)0));
  }
  fh = ((*(sys->dopen)))(sys, desc, 0);
  if (fh) {
    this->error = mspack_sys_filelen(sys, fh, & filelen);
    if (! this->error) {
      this->error = cabd_find(this, search_buf, fh, filename, desc, filelen, & firstlen,
                              & cab);
    }
    if (firstlen) {
      if ((unsigned long )firstlen != (unsigned long )filelen) {
        if (! cab) {
          goto _L;
        } else {
          if (cab->base.base_offset == 0L) {
            _L: 
            if ((unsigned long )firstlen < (unsigned long )filelen) {
              ((*(sys->message)))(fh, (char *)"WARNING; possible %u extra bytes at end of file.",
                                  (unsigned int )((unsigned long )filelen - (unsigned long )firstlen));
            } else {
              ((*(sys->message)))(fh, (char *)"WARNING; file possibly truncated by %u bytes.",
                                  (unsigned int )((unsigned long )firstlen - (unsigned long )filelen));
            }
          }
        }
      }
    }
    ((*(sys->close)))(fh);
  } else {
    this->error = 2;
  }
  ((*(sys->free)))((void *)search_buf);
  return ((struct mscabd_cabinet *)cab);
}
}
static int cabd_find(struct mscab_decompressor_p *this , unsigned char *buf , struct mspack_file *fh ,
                     char *filename , int desc , off_t flen , unsigned int *firstlen ,
                     struct mscabd_cabinet_p **firstcab ) 
{ struct mscabd_cabinet_p *cab ;
  struct mscabd_cabinet_p *link___0 ;
  off_t caboff ;
  off_t offset ;
  off_t foffset ;
  off_t cablen ;
  struct mspack_system *sys ;
  unsigned char *p ;
  unsigned char *pend ;
  unsigned char state ;
  int false_cabs ;
  int length ;
  int tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  link___0 = (struct mscabd_cabinet_p *)((void *)0);
  foffset = 0L;
  cablen = 0L;
  sys = this->system;
  state = (unsigned char)0;
  false_cabs = 0;
  offset = 0L;
  while (offset < flen) {
    length = (int )(flen - offset);
    if (length > this->param[0]) {
      length = this->param[0];
    }
    tmp = ((*(sys->read)))(fh, (void *)(buf + 0), length);
    if (tmp != length) {
      return (3);
    }
    if (offset == 0L) {
      if ((((((int )(*((buf + 0) + 3)) << 24) | ((int )(*((buf + 0) + 2)) << 16)) |
            ((int )(*((buf + 0) + 1)) << 8)) | (int )(*((buf + 0) + 0))) == 677598025) {
        ((*(sys->message)))(fh, (char *)"WARNING; found InstallShield header. This is probably an InstallShield file. Use UNSHIELD (http://synce.sf.net) to unpack it.");
      }
    }
    p = buf + 0;
    pend = buf + length;
    while ((unsigned int )p < (unsigned int )pend) {
      switch ((int )state) {
      case 0: ;
      while (1) {
        if ((unsigned int )p < (unsigned int )pend) {
          if (! ((int )(*p) != 77)) {
            break;
          }
        } else {
          break;
        }
        p ++;
      }
      tmp___0 = p;
      p ++;
      if ((unsigned int )tmp___0 < (unsigned int )pend) {
        state = (unsigned char)1;
      }
      break;
      case 1: 
      tmp___2 = p;
      p ++;
      if ((int )(*tmp___2) == 83) {
        state = (unsigned char)2;
      } else {
        state = (unsigned char)0;
      }
      break;
      case 2: 
      tmp___4 = p;
      p ++;
      if ((int )(*tmp___4) == 67) {
        state = (unsigned char)3;
      } else {
        state = (unsigned char)0;
      }
      break;
      case 3: 
      tmp___6 = p;
      p ++;
      if ((int )(*tmp___6) == 70) {
        state = (unsigned char)4;
      } else {
        state = (unsigned char)0;
      }
      break;
      case 8: 
      tmp___7 = p;
      p ++;
      cablen = (long )(*tmp___7);
      state = (unsigned char )((int )state + 1);
      break;
      case 9: 
      tmp___8 = p;
      p ++;
      cablen |= (long )((int )(*tmp___8) << 8);
      state = (unsigned char )((int )state + 1);
      break;
      case 10: 
      tmp___9 = p;
      p ++;
      cablen |= (long )((int )(*tmp___9) << 16);
      state = (unsigned char )((int )state + 1);
      break;
      case 11: 
      tmp___10 = p;
      p ++;
      cablen |= (long )((int )(*tmp___10) << 24);
      state = (unsigned char )((int )state + 1);
      break;
      case 16: 
      tmp___11 = p;
      p ++;
      foffset = (long )(*tmp___11);
      state = (unsigned char )((int )state + 1);
      break;
      case 17: 
      tmp___12 = p;
      p ++;
      foffset |= (long )((int )(*tmp___12) << 8);
      state = (unsigned char )((int )state + 1);
      break;
      case 18: 
      tmp___13 = p;
      p ++;
      foffset |= (long )((int )(*tmp___13) << 16);
      state = (unsigned char )((int )state + 1);
      break;
      case 19: 
      tmp___14 = p;
      p ++;
      foffset |= (long )((int )(*tmp___14) << 24);
      caboff = (offset + (long )(p - (buf + 0))) - 20L;
      offset = caboff + 4L;
      if (caboff == 0L) {
        (*firstlen) = (unsigned int )cablen;
      }
      if (foffset < cablen) {
        if (caboff + foffset < flen + 32L) {
          if (caboff + cablen < flen + 32L) {
            cab = (struct mscabd_cabinet_p *)((*(sys->alloc)))(sys, sizeof(struct mscabd_cabinet_p ));
            if (! cab) {
              return (6);
            }
            cab->base.filename = filename;
            cab->base.desc = dup(desc);
            tmp___15 = cabd_read_headers(sys, fh, cab, caboff, 1);
            if (tmp___15) {
              cabd_close((struct mscab_decompressor *)this, (struct mscabd_cabinet *)cab);
              false_cabs ++;
            } else {
              offset = caboff + cablen;
              if (! link___0) {
                (*firstcab) = cab;
              } else {
                link___0->base.next = (struct mscabd_cabinet *)cab;
              }
              link___0 = cab;
            }
          }
        }
      }
      if (offset >= flen) {
        return (0);
      }
      tmp___16 = ((*(sys->seek)))(fh, offset, 0);
      if (tmp___16) {
        return (5);
      }
      length = 0;
      p = pend;
      state = (unsigned char)0;
      break;
      default: 
      p ++;
      state = (unsigned char )((int )state + 1);
      }
    }
    offset += (long )length;
  }
  if (false_cabs) {

  }
  return (0);
}
}
static int cabd_prepend(struct mscab_decompressor *base , struct mscabd_cabinet *cab ,
                        struct mscabd_cabinet *prevcab ) 
{ int tmp ;

  {
  tmp = cabd_merge(base, prevcab, cab);
  return (tmp);
}
}
static int cabd_append(struct mscab_decompressor *base , struct mscabd_cabinet *cab ,
                       struct mscabd_cabinet *nextcab ) 
{ int tmp ;

  {
  tmp = cabd_merge(base, cab, nextcab);
  return (tmp);
}
}
static int cabd_merge(struct mscab_decompressor *base , struct mscabd_cabinet *lcab ,
                      struct mscabd_cabinet *rcab ) 
{ struct mscab_decompressor_p *this ;
  struct mscabd_folder_data *data ;
  struct mscabd_folder_data *ndata ;
  struct mscabd_folder_p *lfol ;
  struct mscabd_folder_p *rfol ;
  struct mscabd_file *fi ;
  struct mscabd_file *rfi ;
  struct mscabd_file *lfi ;
  struct mscabd_cabinet *cab ;
  struct mspack_system *sys ;

  {
  this = (struct mscab_decompressor_p *)base;
  if (! this) {
    return (1);
  }
  sys = this->system;
  if (! lcab) {
    this->error = 1;
    return (this->error);
  } else {
    if (! rcab) {
      this->error = 1;
      return (this->error);
    } else {
      if ((unsigned int )lcab == (unsigned int )rcab) {
        this->error = 1;
        return (this->error);
      }
    }
  }
  if (lcab->nextcab) {
    this->error = 1;
    return (this->error);
  } else {
    if (rcab->prevcab) {
      this->error = 1;
      return (this->error);
    }
  }
  cab = lcab->prevcab;
  while (cab) {
    if ((unsigned int )cab == (unsigned int )rcab) {
      this->error = 1;
      return (this->error);
    }
    cab = cab->prevcab;
  }
  cab = rcab->nextcab;
  while (cab) {
    if ((unsigned int )cab == (unsigned int )lcab) {
      this->error = 1;
      return (this->error);
    }
    cab = cab->nextcab;
  }
  if ((int )lcab->set_id != (int )rcab->set_id) {
    ((*(sys->message)))((struct mspack_file *)((void *)0), (char *)"WARNING; merged cabinets with differing Set IDs.");
  }
  if ((int )lcab->set_index > (int )rcab->set_index) {
    ((*(sys->message)))((struct mspack_file *)((void *)0), (char *)"WARNING; merged cabinets with odd order.");
  }
  lfol = (struct mscabd_folder_p *)lcab->folders;
  rfol = (struct mscabd_folder_p *)rcab->folders;
  while (lfol->base.next) {
    lfol = (struct mscabd_folder_p *)lfol->base.next;
  }
  if (! lfol->merge_next) {
    if (! rfol->merge_prev) {
      lcab->nextcab = rcab;
      rcab->prevcab = lcab;
      lfol->base.next = (struct mscabd_folder *)rfol;
      fi = lcab->files;
      while (fi->next) {
        fi = fi->next;
      }
      fi->next = rcab->files;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (! lfol->merge_next) {
      this->error = 8;
      return (this->error);
    }
    if (! rfol->merge_prev) {
      this->error = 8;
      return (this->error);
    }
    if (lfol->base.comp_type != rfol->base.comp_type) {
      this->error = 8;
      return (this->error);
    }
    lfi = lfol->merge_next;
    rfi = rfol->merge_prev;
    while (lfi) {
      if (! rfi) {
        this->error = 8;
        return (this->error);
      } else {
        if (lfi->offset != rfi->offset) {
          this->error = 8;
          return (this->error);
        }
      }
      lfi = lfi->next;
      rfi = rfi->next;
    }
    data = (struct mscabd_folder_data *)((*(sys->alloc)))(sys, sizeof(struct mscabd_folder_data ));
    if (! data) {
      this->error = 6;
      return (this->error);
    }
    lcab->nextcab = rcab;
    rcab->prevcab = lcab;
    ndata = & lfol->data;
    while (ndata->next) {
      ndata = ndata->next;
    }
    ndata->next = data;
    (*data) = rfol->data;
    rfol->data.next = (struct mscabd_folder_data *)((void *)0);
    lfol->base.num_blocks = lfol->base.num_blocks + (rfol->base.num_blocks - 1U);
    if ((unsigned int )rfol->merge_next == (unsigned int )((void *)0)) {
      lfol->merge_next = rfol->merge_next;
    } else {
      if ((unsigned int )(rfol->merge_next)->folder != (unsigned int )((struct mscabd_folder *)rfol)) {
        lfol->merge_next = rfol->merge_next;
      }
    }
    while (lfol->base.next) {
      lfol = (struct mscabd_folder_p *)lfol->base.next;
    }
    lfol->base.next = rfol->base.next;
    ((*(sys->free)))((void *)rfol);
    fi = lcab->files;
    while (fi->next) {
      fi = fi->next;
    }
    fi->next = rcab->files;
    lfi = (struct mscabd_file *)((void *)0);
    fi = lcab->files;
    while (fi) {
      rfi = fi->next;
      if ((unsigned int )fi->folder == (unsigned int )((struct mscabd_folder *)rfol)) {
        if (lfi) {
          lfi->next = rfi;
        } else {
          lcab->files = rfi;
        }
        ((*(sys->free)))((void *)fi->filename);
        ((*(sys->free)))((void *)fi);
      } else {
        lfi = fi;
      }
      fi = rfi;
    }
  }
  cab = lcab->prevcab;
  while (cab) {
    cab->files = lcab->files;
    cab->folders = lcab->folders;
    cab = cab->prevcab;
  }
  cab = lcab->nextcab;
  while (cab) {
    cab->files = lcab->files;
    cab->folders = lcab->folders;
    cab = cab->nextcab;
  }
  this->error = 0;
  return (this->error);
}
}
static int cabd_extract(struct mscab_decompressor *base , struct mscabd_file *file ,
                        char *filename ) 
{ struct mscab_decompressor_p *this ;
  struct mscabd_folder_p *fol ;
  struct mspack_system *sys ;
  struct mspack_file *fh ;
  int tmp ;
  int tmp___0 ;
  off_t bytes ;
  int error ;

  {
  this = (struct mscab_decompressor_p *)base;
  if (! this) {
    return (1);
  }
  if (! file) {
    this->error = 1;
    return (this->error);
  }
  sys = this->system;
  fol = (struct mscabd_folder_p *)file->folder;
  if (! fol) {
    ((*(sys->message)))((struct mspack_file *)((void *)0), (char *)"ERROR; file \"%s\" cannot be extracted, cabinet set is incomplete.",
                        file->filename);
    this->error = 8;
    return (this->error);
  } else {
    if (fol->merge_prev) {
      ((*(sys->message)))((struct mspack_file *)((void *)0), (char *)"ERROR; file \"%s\" cannot be extracted, cabinet set is incomplete.",
                          file->filename);
      this->error = 8;
      return (this->error);
    } else {
      if ((file->offset + file->length) / 32768U > fol->base.num_blocks) {
        ((*(sys->message)))((struct mspack_file *)((void *)0), (char *)"ERROR; file \"%s\" cannot be extracted, cabinet set is incomplete.",
                            file->filename);
        this->error = 8;
        return (this->error);
      }
    }
  }
  if (! this->d) {
    this->d = (struct mscabd_decompress_state *)((*(sys->alloc)))(sys, sizeof(struct mscabd_decompress_state ));
    if (! this->d) {
      this->error = 6;
      return (this->error);
    }
    (this->d)->folder = (struct mscabd_folder_p *)((void *)0);
    (this->d)->data = (struct mscabd_folder_data *)((void *)0);
    (this->d)->sys = (*sys);
    (this->d)->sys.read = & cabd_sys_read;
    (this->d)->sys.write = & cabd_sys_write;
    (this->d)->state = (void *)0;
    (this->d)->infh = (struct mspack_file *)((void *)0);
    (this->d)->incab = (struct mscabd_cabinet_p *)((void *)0);
  }
  if ((unsigned int )(this->d)->folder != (unsigned int )fol) {
    goto _L___0;
  } else {
    if ((this->d)->offset > file->offset) {
      _L___0: 
      if (! (this->d)->infh) {
        goto _L;
      } else {
        if ((unsigned int )fol->data.cab != (unsigned int )(this->d)->incab) {
          _L: 
          if ((this->d)->infh) {
            ((*(sys->close)))((this->d)->infh);
          }
          (this->d)->incab = fol->data.cab;
          if ((fol->data.cab)->base.desc) {
            (this->d)->infh = ((*(sys->dopen)))(sys, (fol->data.cab)->base.desc, 0);
          } else {
            (this->d)->infh = ((*(sys->open)))(sys, (fol->data.cab)->base.filename,
                                               0);
          }
          if (! (this->d)->infh) {
            this->error = 2;
            return (this->error);
          }
        }
      }
      tmp = ((*(sys->seek)))((this->d)->infh, fol->data.offset, 0);
      if (tmp) {
        this->error = 5;
        return (this->error);
      }
      tmp___0 = cabd_init_decomp(this, (unsigned int )fol->base.comp_type);
      if (tmp___0) {
        return (this->error);
      }
      (this->d)->folder = fol;
      (this->d)->data = & fol->data;
      (this->d)->offset = 0U;
      (this->d)->block = 0U;
      (this->d)->i_end = & (this->d)->input[0];
      (this->d)->i_ptr = (this->d)->i_end;
    }
  }
  fh = ((*(sys->open)))(sys, filename, 1);
  if (! fh) {
    this->error = 2;
    return (this->error);
  }
  this->error = 0;
  if (file->length) {
    (this->d)->outfh = (struct mspack_file *)((void *)0);
    bytes = (long )(file->offset - (this->d)->offset);
    if (bytes) {
      error = ((*((this->d)->decompress)))((this->d)->state, bytes);
      if (error != 3) {
        this->error = error;
      }
    }
    if (! this->error) {
      (this->d)->outfh = fh;
      error = ((*((this->d)->decompress)))((this->d)->state, (long )file->length);
      if (error != 3) {
        this->error = error;
      }
    }
  }
  ((*(sys->close)))(fh);
  (this->d)->outfh = (struct mspack_file *)((void *)0);
  return (this->error);
}
}
static int cabd_init_decomp(struct mscab_decompressor_p *this , unsigned int ct ) 
{ struct mspack_file *fh ;

  {
  fh = (struct mspack_file *)this;
  if (! this) {
    this->error = 1;
    return (this->error);
  } else {
    if (! this->d) {
      this->error = 1;
      return (this->error);
    }
  }
  cabd_free_decomp(this);
  (this->d)->comp_type = (int )ct;
  switch ((int )(ct & 15U)) {
  case 0: 
  (this->d)->decompress = (int (*)(void * , off_t  ))(& noned_decompress);
  (this->d)->state = (void *)noned_init(& (this->d)->sys, fh, fh, this->param[2]);
  break;
  case 1: 
  (this->d)->decompress = (int (*)(void * , off_t  ))(& mszipd_decompress);
  (this->d)->state = (void *)mszipd_init(& (this->d)->sys, fh, fh, this->param[2],
                                         this->param[1]);
  break;
  case 2: 
  (this->d)->decompress = (int (*)(void * , off_t  ))(& qtmd_decompress);
  (this->d)->state = (void *)qtmd_init(& (this->d)->sys, fh, fh, (int )(ct >> 8) &
                                                                 31, this->param[2]);
  break;
  case 3: 
  (this->d)->decompress = (int (*)(void * , off_t  ))(& lzxd_decompress);
  (this->d)->state = (void *)lzxd_init(& (this->d)->sys, fh, fh, (int )(ct >> 8) &
                                                                 31, 0, this->param[2],
                                       0L);
  break;
  default: 
  this->error = 8;
  return (this->error);
  }
  if ((this->d)->state) {
    this->error = 0;
  } else {
    this->error = 6;
  }
  return (this->error);
}
}
static void cabd_free_decomp(struct mscab_decompressor_p *this ) 
{ 

  {
  if (! this) {
    return;
  } else {
    if (! this->d) {
      return;
    } else {
      if (! (this->d)->folder) {
        return;
      } else {
        if (! (this->d)->state) {
          return;
        }
      }
    }
  }
  switch ((this->d)->comp_type & 15) {
  case 0: 
  noned_free((struct noned_state *)(this->d)->state);
  break;
  case 1: 
  mszipd_free((struct mszipd_stream *)(this->d)->state);
  break;
  case 2: 
  qtmd_free((struct qtmd_stream *)(this->d)->state);
  break;
  case 3: 
  lzxd_free((struct lzxd_stream *)(this->d)->state);
  break;
  }
  (this->d)->decompress = (int (*)(void * , off_t  ))((void *)0);
  (this->d)->state = (void *)0;
  return;
}
}
static int cabd_sys_read(struct mspack_file *file , void *buffer , int bytes ) 
{ struct mscab_decompressor_p *this ;
  unsigned char *buf ;
  struct mspack_system *sys ;
  int avail ;
  int todo ;
  int outlen ;
  int ignore_cksum ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned char *tmp___1 ;

  {
  this = (struct mscab_decompressor_p *)file;
  buf = (unsigned char *)buffer;
  sys = this->system;
  if (this->param[1]) {
    if (((this->d)->comp_type & 15) == 1) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  ignore_cksum = tmp;
  todo = bytes;
  while (todo > 0) {
    avail = (this->d)->i_end - (this->d)->i_ptr;
    if (avail) {
      if (avail > todo) {
        avail = todo;
      }
      ((*(sys->copy)))((void *)(this->d)->i_ptr, (void *)buf, (unsigned int )avail);
      (this->d)->i_ptr += avail;
      buf += avail;
      todo -= avail;
    } else {
      tmp___0 = (this->d)->block;
      (this->d)->block ++;
      if (tmp___0 >= ((this->d)->folder)->base.num_blocks) {
        this->error = 8;
        break;
      }
      this->error = cabd_sys_read_block(sys, this->d, & outlen, ignore_cksum);
      if (this->error) {
        return (-1);
      }
      if (((this->d)->comp_type & 15) == 2) {
        tmp___1 = (this->d)->i_end;
        (this->d)->i_end ++;
        (*tmp___1) = (unsigned char)255;
      }
      if ((this->d)->block >= ((this->d)->folder)->base.num_blocks) {
        if (((this->d)->comp_type & 15) == 3) {
          lzxd_set_output_length((struct lzxd_stream *)(this->d)->state, (long )(((this->d)->block -
                                                                                  1U) *
                                                                                 32768U +
                                                                                 (unsigned int )outlen));
        }
      } else {
        if (outlen != 32768) {
          ((*((this->system)->message)))((this->d)->infh, (char *)"WARNING; non-maximal data block");
        }
      }
    }
  }
  return (bytes - todo);
}
}
static int cabd_sys_write(struct mspack_file *file , void *buffer , int bytes ) 
{ struct mscab_decompressor_p *this ;
  int tmp ;

  {
  this = (struct mscab_decompressor_p *)file;
  (this->d)->offset += (unsigned int )bytes;
  if ((this->d)->outfh) {
    tmp = ((*((this->system)->write)))((this->d)->outfh, buffer, bytes);
    return (tmp);
  }
  return (bytes);
}
}
static int cabd_sys_read_block(struct mspack_system *sys , struct mscabd_decompress_state *d ,
                               int *out , int ignore_cksum ) 
{ unsigned char hdr[8] ;
  unsigned int cksum ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int sum2 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
  d->i_end = & d->input[0];
  d->i_ptr = d->i_end;
  while (1) {
    tmp = ((*(sys->read)))(d->infh, (void *)(hdr), 8);
    if (tmp != 8) {
      return (3);
    }
    if (((d->data)->cab)->block_resv) {
      tmp___0 = ((*(sys->seek)))(d->infh, (long )((d->data)->cab)->block_resv, 1);
      if (tmp___0) {
        return (5);
      }
    }
    len = ((int )(*(& hdr[4] + 1)) << 8) | (int )(*(& hdr[4] + 0));
    if ((d->i_end - d->i_ptr) + len > 38912) {
      return (8);
    }
    if ((((int )(*(& hdr[6] + 1)) << 8) | (int )(*(& hdr[6] + 0))) > 32768) {
      return (8);
    }
    tmp___1 = ((*(sys->read)))(d->infh, (void *)d->i_end, len);
    if (tmp___1 != len) {
      return (3);
    }
    cksum = (unsigned int )(((((int )hdr[3] << 24) | ((int )hdr[2] << 16)) | ((int )hdr[1] <<
                                                                              8)) |
                            (int )hdr[0]);
    if (cksum) {
      tmp___2 = cabd_checksum(d->i_end, (unsigned int )len, 0U);
      sum2 = tmp___2;
      tmp___3 = cabd_checksum(& hdr[4], 4U, sum2);
      if (tmp___3 != cksum) {
        if (! ignore_cksum) {
          return (9);
        }
        ((*(sys->message)))(d->infh, (char *)"WARNING; bad block checksum found");
      }
    }
    d->i_end += len;
    (*out) = ((int )(*(& hdr[6] + 1)) << 8) | (int )(*(& hdr[6] + 0));
    if ((*out)) {
      return (0);
    }
    ((*(sys->close)))(d->infh);
    d->infh = (struct mspack_file *)((void *)0);
    d->data = (d->data)->next;
    if (! d->data) {
      return (8);
    }
    d->incab = (d->data)->cab;
    d->infh = ((*(sys->open)))(sys, (d->incab)->base.filename, 0);
    if (! d->infh) {
      return (2);
    }
    tmp___4 = ((*(sys->seek)))(d->infh, (d->data)->offset, 0);
    if (tmp___4) {
      return (5);
    }
  }
  return (0);
}
}
static unsigned int cabd_checksum(unsigned char *data , unsigned int bytes , unsigned int cksum ) 
{ unsigned int len ;
  unsigned int ul ;
  unsigned int tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
  ul = 0U;
  len = bytes >> 2;
  while (1) {
    tmp = len;
    len --;
    if (! tmp) {
      break;
    }
    cksum ^= (unsigned int )((((int )(*(data + 0)) | ((int )(*(data + 1)) << 8)) |
                              ((int )(*(data + 2)) << 16)) | ((int )(*(data + 3)) <<
                                                              24));
    data += 4;
  }
  switch ((int )(bytes & 3U)) {
  case 3: 
  tmp___0 = data;
  data ++;
  ul |= (unsigned int )((int )(*tmp___0) << 16);
  case 2: 
  tmp___1 = data;
  data ++;
  ul |= (unsigned int )((int )(*tmp___1) << 8);
  case 1: 
  ul |= (unsigned int )(*data);
  }
  cksum ^= ul;
  return (cksum);
}
}
static struct noned_state *noned_init(struct mspack_system *sys , struct mspack_file *in ,
                                      struct mspack_file *out , int bufsize ) 
{ struct noned_state *state ;
  struct noned_state *tmp ;
  unsigned char *buf ;
  unsigned char *tmp___0 ;

  {
  tmp = (struct noned_state *)((*(sys->alloc)))(sys, sizeof(struct noned_state ));
  state = tmp;
  tmp___0 = (unsigned char *)((*(sys->alloc)))(sys, (unsigned int )bufsize);
  buf = tmp___0;
  if (state) {
    if (buf) {
      state->sys = sys;
      state->i = in;
      state->o = out;
      state->buf = buf;
      state->bufsize = bufsize;
    } else {
      ((*(sys->free)))((void *)buf);
      ((*(sys->free)))((void *)state);
      state = (struct noned_state *)((void *)0);
    }
  } else {
    ((*(sys->free)))((void *)buf);
    ((*(sys->free)))((void *)state);
    state = (struct noned_state *)((void *)0);
  }
  return (state);
}
}
static int noned_decompress(struct noned_state *s , off_t bytes ) 
{ int run ;
  int tmp ;
  int tmp___0 ;

  {
  while (bytes > 0L) {
    if (bytes > (long )s->bufsize) {
      run = s->bufsize;
    } else {
      run = (int )bytes;
    }
    tmp = ((*((s->sys)->read)))(s->i, (void *)(s->buf + 0), run);
    if (tmp != run) {
      return (3);
    }
    tmp___0 = ((*((s->sys)->write)))(s->o, (void *)(s->buf + 0), run);
    if (tmp___0 != run) {
      return (4);
    }
    bytes -= (long )run;
  }
  return (0);
}
}
static void noned_free(struct noned_state *state ) 
{ struct mspack_system *sys ;

  {
  if (state) {
    sys = state->sys;
    ((*(sys->free)))((void *)state->buf);
    ((*(sys->free)))((void *)state);
  }
  return;
}
}
static int cabd_param(struct mscab_decompressor *base , int param , int value ) 
{ struct mscab_decompressor_p *this ;

  {
  this = (struct mscab_decompressor_p *)base;
  if (! this) {
    return (1);
  }
  switch (param) {
  case 0: ;
  if (value < 4) {
    return (1);
  }
  this->param[0] = value;
  break;
  case 1: 
  this->param[1] = value;
  break;
  case 2: ;
  if (value < 4) {
    return (1);
  }
  this->param[2] = value;
  break;
  default: ;
  return (1);
  }
  return (0);
}
}
static int cabd_error(struct mscab_decompressor *base ) 
{ struct mscab_decompressor_p *this ;
  int tmp ;

  {
  this = (struct mscab_decompressor_p *)base;
  if (this) {
    tmp = this->error;
  } else {
    tmp = 1;
  }
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-0WhonlKa.i","-g -O2 -fPIC")
static int lzxd_read_input(struct lzxd_stream *lzx ) 
{ int read___0 ;
  int tmp ;

  {
  tmp = ((*((lzx->sys)->read)))(lzx->input, (void *)(lzx->inbuf + 0), (int )lzx->inbuf_size);
  read___0 = tmp;
  if (read___0 < 0) {
    lzx->error = 3;
    return (lzx->error);
  }
  if (read___0 == 0) {
    if (lzx->input_end) {
      lzx->error = 3;
      return (lzx->error);
    } else {
      read___0 = 2;
      (*(lzx->inbuf + 1)) = (unsigned char)0;
      (*(lzx->inbuf + 0)) = (*(lzx->inbuf + 1));
      lzx->input_end = (unsigned char)1;
    }
  }
  lzx->i_ptr = lzx->inbuf + 0;
  lzx->i_end = lzx->inbuf + read___0;
  return (0);
}
}
static int make_decode_table(unsigned int nsyms , unsigned int nbits , unsigned char *length ,
                             unsigned short *table ) 
{ register unsigned short sym ;
  register unsigned int leaf ;
  register unsigned int fill ;
  register unsigned char bit_num ;
  unsigned int pos ;
  unsigned int table_mask ;
  unsigned int bit_mask___0 ;
  unsigned int next_symbol ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  pos = 0U;
  table_mask = (unsigned int )(1 << nbits);
  bit_mask___0 = table_mask >> 1;
  next_symbol = bit_mask___0;
  bit_num = (unsigned char)1;
  while ((unsigned int )bit_num <= nbits) {
    sym = (unsigned short)0;
    while ((unsigned int )sym < nsyms) {
      if ((int )(*(length + (int )sym)) != (int )bit_num) {
        goto __Cont;
      }
      leaf = pos;
      pos += bit_mask___0;
      if (pos > table_mask) {
        return (1);
      }
      fill = bit_mask___0;
      while (1) {
        tmp___0 = fill;
        fill --;
        if (! (tmp___0 > 0U)) {
          break;
        }
        tmp = leaf;
        leaf ++;
        (*(table + tmp)) = sym;
      }
      __Cont: 
      sym = (unsigned short )((int )sym + 1);
    }
    bit_mask___0 >>= 1;
    bit_num = (unsigned char )((int )bit_num + 1);
  }
  if (pos == table_mask) {
    return (0);
  }
  sym = (unsigned short )pos;
  while ((unsigned int )sym < table_mask) {
    (*(table + (int )sym)) = (unsigned short)65535;
    sym = (unsigned short )((int )sym + 1);
  }
  pos <<= 16;
  table_mask <<= 16;
  bit_mask___0 = 32768U;
  bit_num = (unsigned char )(nbits + 1U);
  while ((int )bit_num <= 16) {
    sym = (unsigned short)0;
    while ((unsigned int )sym < nsyms) {
      if ((int )(*(length + (int )sym)) != (int )bit_num) {
        goto __Cont___0;
      }
      leaf = pos >> 16;
      fill = 0U;
      while (fill < (unsigned int )bit_num - nbits) {
        if ((int )(*(table + leaf)) == 65535) {
          (*(table + (next_symbol << 1))) = (unsigned short)65535;
          (*(table + ((next_symbol << 1) + 1U))) = (unsigned short)65535;
          tmp___1 = next_symbol;
          next_symbol ++;
          (*(table + leaf)) = (unsigned short )tmp___1;
        }
        leaf = (unsigned int )((int )(*(table + leaf)) << 1);
        if ((pos >> (15U - fill)) & 1U) {
          leaf ++;
        }
        fill ++;
      }
      (*(table + leaf)) = sym;
      pos += bit_mask___0;
      if (pos > table_mask) {
        return (1);
      }
      __Cont___0: 
      sym = (unsigned short )((int )sym + 1);
    }
    bit_mask___0 >>= 1;
    bit_num = (unsigned char )((int )bit_num + 1);
  }
  if (pos == table_mask) {
    return (0);
  }
  sym = (unsigned short)0;
  while ((unsigned int )sym < nsyms) {
    if ((*(length + (int )sym))) {
      return (1);
    }
    sym = (unsigned short )((int )sym + 1);
  }
  return (0);
}
}
static int lzxd_read_lens(struct lzxd_stream *lzx , unsigned char *lens , unsigned int first ,
                          unsigned int last ) 
{ register unsigned int bit_buffer ;
  register int bits_left ;
  register int i ;
  register unsigned short sym ;
  unsigned char *i_ptr ;
  unsigned char *i_end ;
  unsigned int x ;
  unsigned int y ;
  int z ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;

  {
  while (1) {
    i_ptr = lzx->i_ptr;
    i_end = lzx->i_end;
    bit_buffer = lzx->bit_buffer;
    bits_left = (int )lzx->bits_left;
    break;
  }
  x = 0U;
  while (x < 20U) {
    while (1) {
      while (bits_left < 4) {
        if ((unsigned int )i_ptr >= (unsigned int )i_end) {
          tmp = lzxd_read_input(lzx);
          if (tmp) {
            return (lzx->error);
          }
          i_ptr = lzx->i_ptr;
          i_end = lzx->i_end;
        }
        bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                              0))) <<
                                      ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
        bits_left += 16;
        i_ptr += 2;
      }
      y = bit_buffer >> (sizeof(bit_buffer) * 8U - 4U);
      bit_buffer <<= 4;
      bits_left -= 4;
      break;
    }
    lzx->PRETREE_len[x] = (unsigned char )y;
    x ++;
  }
  tmp___0 = make_decode_table(20U, 6U, & lzx->PRETREE_len[0], & lzx->PRETREE_table[0]);
  if (tmp___0) {
    lzx->error = 11;
    return (lzx->error);
  }
  x = first;
  while (x < last) {
    while (1) {
      while (bits_left < 16) {
        if ((unsigned int )i_ptr >= (unsigned int )i_end) {
          tmp___1 = lzxd_read_input(lzx);
          if (tmp___1) {
            return (lzx->error);
          }
          i_ptr = lzx->i_ptr;
          i_end = lzx->i_end;
        }
        bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                              0))) <<
                                      ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
        bits_left += 16;
        i_ptr += 2;
      }
      sym = lzx->PRETREE_table[bit_buffer >> (sizeof(bit_buffer) * 8U - 6U)];
      if ((int )sym >= 20) {
        i = 1 << (sizeof(bit_buffer) * 8U - 6U);
        while (1) {
          i >>= 1;
          if (i == 0) {
            lzx->error = 11;
            return (lzx->error);
          }
          sym = (unsigned short )((int )sym << 1);
          if (bit_buffer & (unsigned int )i) {
            tmp___2 = 1;
          } else {
            tmp___2 = 0;
          }
          sym = (unsigned short )((int )sym | tmp___2);
          sym = lzx->PRETREE_table[sym];
          if (! ((int )sym >= 20)) {
            break;
          }
        }
      }
      z = (int )sym;
      i = (int )lzx->PRETREE_len[sym];
      bit_buffer <<= i;
      bits_left -= i;
      break;
    }
    if (z == 17) {
      while (1) {
        while (bits_left < 4) {
          if ((unsigned int )i_ptr >= (unsigned int )i_end) {
            tmp___3 = lzxd_read_input(lzx);
            if (tmp___3) {
              return (lzx->error);
            }
            i_ptr = lzx->i_ptr;
            i_end = lzx->i_end;
          }
          bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                0))) <<
                                        ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
          bits_left += 16;
          i_ptr += 2;
        }
        y = bit_buffer >> (sizeof(bit_buffer) * 8U - 4U);
        bit_buffer <<= 4;
        bits_left -= 4;
        break;
      }
      y += 4U;
      while (1) {
        tmp___5 = y;
        y --;
        if (! tmp___5) {
          break;
        }
        tmp___4 = x;
        x ++;
        (*(lens + tmp___4)) = (unsigned char)0;
      }
    } else {
      if (z == 18) {
        while (1) {
          while (bits_left < 5) {
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
              tmp___6 = lzxd_read_input(lzx);
              if (tmp___6) {
                return (lzx->error);
              }
              i_ptr = lzx->i_ptr;
              i_end = lzx->i_end;
            }
            bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                  0))) <<
                                          ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
            bits_left += 16;
            i_ptr += 2;
          }
          y = bit_buffer >> (sizeof(bit_buffer) * 8U - 5U);
          bit_buffer <<= 5;
          bits_left -= 5;
          break;
        }
        y += 20U;
        while (1) {
          tmp___8 = y;
          y --;
          if (! tmp___8) {
            break;
          }
          tmp___7 = x;
          x ++;
          (*(lens + tmp___7)) = (unsigned char)0;
        }
      } else {
        if (z == 19) {
          while (1) {
            while (bits_left < 1) {
              if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                tmp___9 = lzxd_read_input(lzx);
                if (tmp___9) {
                  return (lzx->error);
                }
                i_ptr = lzx->i_ptr;
                i_end = lzx->i_end;
              }
              bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                    0))) <<
                                            ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
              bits_left += 16;
              i_ptr += 2;
            }
            y = bit_buffer >> (sizeof(bit_buffer) * 8U - 1U);
            bit_buffer <<= 1;
            bits_left --;
            break;
          }
          y += 4U;
          while (1) {
            while (bits_left < 16) {
              if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                tmp___10 = lzxd_read_input(lzx);
                if (tmp___10) {
                  return (lzx->error);
                }
                i_ptr = lzx->i_ptr;
                i_end = lzx->i_end;
              }
              bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                    0))) <<
                                            ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
              bits_left += 16;
              i_ptr += 2;
            }
            sym = lzx->PRETREE_table[bit_buffer >> (sizeof(bit_buffer) * 8U - 6U)];
            if ((int )sym >= 20) {
              i = 1 << (sizeof(bit_buffer) * 8U - 6U);
              while (1) {
                i >>= 1;
                if (i == 0) {
                  lzx->error = 11;
                  return (lzx->error);
                }
                sym = (unsigned short )((int )sym << 1);
                if (bit_buffer & (unsigned int )i) {
                  tmp___11 = 1;
                } else {
                  tmp___11 = 0;
                }
                sym = (unsigned short )((int )sym | tmp___11);
                sym = lzx->PRETREE_table[sym];
                if (! ((int )sym >= 20)) {
                  break;
                }
              }
            }
            z = (int )sym;
            i = (int )lzx->PRETREE_len[sym];
            bit_buffer <<= i;
            bits_left -= i;
            break;
          }
          z = (int )(*(lens + x)) - z;
          if (z < 0) {
            z += 17;
          }
          while (1) {
            tmp___13 = y;
            y --;
            if (! tmp___13) {
              break;
            }
            tmp___12 = x;
            x ++;
            (*(lens + tmp___12)) = (unsigned char )z;
          }
        } else {
          z = (int )(*(lens + x)) - z;
          if (z < 0) {
            z += 17;
          }
          tmp___14 = x;
          x ++;
          (*(lens + tmp___14)) = (unsigned char )z;
        }
      }
    }
  }
  while (1) {
    lzx->i_ptr = i_ptr;
    lzx->i_end = i_end;
    lzx->bit_buffer = bit_buffer;
    lzx->bits_left = (unsigned int )bits_left;
    break;
  }
  return (0);
}
}
static unsigned int position_base[51]  ;
static unsigned char extra_bits[51]  ;
static void lzxd_static_init(void) 
{ int i ;
  int j ;

  {
  i = 0;
  j = 0;
  while (i < 51) {
    extra_bits[i] = (unsigned char )j;
    if (i < 50) {
      extra_bits[i + 1] = (unsigned char )j;
    }
    if (i != 0) {
      if (j < 17) {
        j ++;
      }
    }
    i += 2;
  }
  i = 0;
  j = 0;
  while (i < 51) {
    position_base[i] = (unsigned int )j;
    j += 1 << (int )extra_bits[i];
    i ++;
  }
  return;
}
}
static void lzxd_reset_state(struct lzxd_stream *lzx ) 
{ int i ;

  {
  lzx->R0 = 1U;
  lzx->R1 = 1U;
  lzx->R2 = 1U;
  lzx->header_read = (unsigned char)0;
  lzx->block_remaining = 0U;
  lzx->block_type = (unsigned char)0;
  i = 0;
  while (i < 656) {
    lzx->MAINTREE_len[i] = (unsigned char)0;
    i ++;
  }
  i = 0;
  while (i < 250) {
    lzx->LENGTH_len[i] = (unsigned char)0;
    i ++;
  }
  return;
}
}
struct lzxd_stream *lzxd_init(struct mspack_system *system___0 , struct mspack_file *input ,
                              struct mspack_file *output , int window_bits , int reset_interval ,
                              int input_buffer_size , off_t output_length ) 
{ unsigned int window_size ;
  struct lzxd_stream *lzx ;

  {
  window_size = (unsigned int )(1 << window_bits);
  if (! system___0) {
    return ((struct lzxd_stream *)((void *)0));
  }
  if (window_bits < 15) {
    return ((struct lzxd_stream *)((void *)0));
  } else {
    if (window_bits > 21) {
      return ((struct lzxd_stream *)((void *)0));
    }
  }
  input_buffer_size = (input_buffer_size + 1) & -2;
  if (! input_buffer_size) {
    return ((struct lzxd_stream *)((void *)0));
  }
  lzxd_static_init();
  lzx = (struct lzxd_stream *)((*(system___0->alloc)))(system___0, sizeof(struct lzxd_stream ));
  if (! lzx) {
    return ((struct lzxd_stream *)((void *)0));
  }
  lzx->window = (unsigned char *)((*(system___0->alloc)))(system___0, window_size);
  lzx->inbuf = (unsigned char *)((*(system___0->alloc)))(system___0, (unsigned int )input_buffer_size);
  if (! lzx->window) {
    ((*(system___0->free)))((void *)lzx->window);
    ((*(system___0->free)))((void *)lzx->inbuf);
    ((*(system___0->free)))((void *)lzx);
    return ((struct lzxd_stream *)((void *)0));
  } else {
    if (! lzx->inbuf) {
      ((*(system___0->free)))((void *)lzx->window);
      ((*(system___0->free)))((void *)lzx->inbuf);
      ((*(system___0->free)))((void *)lzx);
      return ((struct lzxd_stream *)((void *)0));
    }
  }
  lzx->sys = system___0;
  lzx->input = input;
  lzx->output = output;
  lzx->offset = 0L;
  lzx->length = output_length;
  lzx->inbuf_size = (unsigned int )input_buffer_size;
  lzx->window_size = (unsigned int )(1 << window_bits);
  lzx->window_posn = 0U;
  lzx->frame_posn = 0U;
  lzx->frame = 0U;
  lzx->reset_interval = (unsigned int )reset_interval;
  lzx->intel_filesize = 0;
  lzx->intel_curpos = 0;
  if (window_bits == 21) {
    lzx->posn_slots = (unsigned char)50;
  } else {
    if (window_bits == 20) {
      lzx->posn_slots = (unsigned char)42;
    } else {
      lzx->posn_slots = (unsigned char )(window_bits << 1);
    }
  }
  lzx->intel_started = (unsigned char)0;
  lzx->input_end = (unsigned char)0;
  lzx->error = 0;
  lzx->i_end = lzx->inbuf + 0;
  lzx->i_ptr = lzx->i_end;
  lzx->o_end = & lzx->e8_buf[0];
  lzx->o_ptr = lzx->o_end;
  lzx->bits_left = 0U;
  lzx->bit_buffer = lzx->bits_left;
  lzxd_reset_state(lzx);
  return (lzx);
}
}
void lzxd_set_output_length(struct lzxd_stream *lzx , off_t out_bytes ) 
{ 

  {
  if (lzx) {
    lzx->length = out_bytes;
  }
  return;
}
}
int lzxd_decompress(struct lzxd_stream *lzx , off_t out_bytes ) 
{ register unsigned int bit_buffer ;
  register int bits_left ;
  register int i ;
  register unsigned short sym ;
  unsigned char *i_ptr ;
  unsigned char *i_end ;
  int match_length ;
  int length_footer ;
  int extra ;
  int verbatim_bits ;
  int bytes_todo ;
  int this_run ;
  int main_element ;
  int aligned_bits ;
  int j ;
  unsigned char *window ;
  unsigned char *runsrc ;
  unsigned char *rundest ;
  unsigned char buf[12] ;
  unsigned int frame_size ;
  unsigned int end_frame ;
  unsigned int match_offset ;
  unsigned int window_posn ;
  unsigned int R0 ;
  unsigned int R1 ;
  unsigned int R2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  unsigned int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char *tmp___25 ;
  int tmp___26 ;
  unsigned char *tmp___27 ;
  unsigned char *tmp___28 ;
  int tmp___29 ;
  unsigned char *tmp___30 ;
  unsigned char *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  unsigned int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  unsigned char *tmp___44 ;
  unsigned char *tmp___45 ;
  int tmp___46 ;
  unsigned char *tmp___47 ;
  unsigned char *tmp___48 ;
  int tmp___49 ;
  unsigned char *tmp___50 ;
  unsigned char *tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  unsigned char *data ;
  unsigned char *dataend ;
  int curpos ;
  int filesize ;
  int abs_off ;
  int rel_off ;
  unsigned char *tmp___55 ;
  int tmp___56 ;

  {
  i = 0;
  frame_size = 0U;
  if (! lzx) {
    return (1);
  } else {
    if (out_bytes < 0L) {
      return (1);
    }
  }
  if (lzx->error) {
    return (lzx->error);
  }
  i = lzx->o_end - lzx->o_ptr;
  if ((long )i > out_bytes) {
    i = (int )out_bytes;
  }
  if (i) {
    tmp = ((*((lzx->sys)->write)))(lzx->output, (void *)lzx->o_ptr, i);
    if (tmp != i) {
      lzx->error = 4;
      return (lzx->error);
    }
    lzx->o_ptr = lzx->o_ptr + i;
    lzx->offset = lzx->offset + (long )i;
    out_bytes -= (long )i;
  }
  if (out_bytes == 0L) {
    return (0);
  }
  while (1) {
    i_ptr = lzx->i_ptr;
    i_end = lzx->i_end;
    bit_buffer = lzx->bit_buffer;
    bits_left = (int )lzx->bits_left;
    break;
  }
  window = lzx->window;
  window_posn = lzx->window_posn;
  R0 = lzx->R0;
  R1 = lzx->R1;
  R2 = lzx->R2;
  end_frame = (unsigned int )((lzx->offset + out_bytes) / 32768L) + 1U;
  while (lzx->frame < end_frame) {
    if (lzx->reset_interval) {
      if (lzx->frame % lzx->reset_interval == 0U) {
        if (lzx->block_remaining) {
          lzx->error = 11;
          return (lzx->error);
        }
        lzxd_reset_state(lzx);
      }
    }
    if (! lzx->header_read) {
      j = 0;
      while (1) {
        while (bits_left < 1) {
          if ((unsigned int )i_ptr >= (unsigned int )i_end) {
            tmp___0 = lzxd_read_input(lzx);
            if (tmp___0) {
              return (lzx->error);
            }
            i_ptr = lzx->i_ptr;
            i_end = lzx->i_end;
          }
          bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                0))) <<
                                        ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
          bits_left += 16;
          i_ptr += 2;
        }
        i = (int )(bit_buffer >> (sizeof(bit_buffer) * 8U - 1U));
        bit_buffer <<= 1;
        bits_left --;
        break;
      }
      if (i) {
        while (1) {
          while (bits_left < 16) {
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
              tmp___1 = lzxd_read_input(lzx);
              if (tmp___1) {
                return (lzx->error);
              }
              i_ptr = lzx->i_ptr;
              i_end = lzx->i_end;
            }
            bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                  0))) <<
                                          ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
            bits_left += 16;
            i_ptr += 2;
          }
          i = (int )(bit_buffer >> (sizeof(bit_buffer) * 8U - 16U));
          bit_buffer <<= 16;
          bits_left -= 16;
          break;
        }
        while (1) {
          while (bits_left < 16) {
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
              tmp___2 = lzxd_read_input(lzx);
              if (tmp___2) {
                return (lzx->error);
              }
              i_ptr = lzx->i_ptr;
              i_end = lzx->i_end;
            }
            bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                  0))) <<
                                          ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
            bits_left += 16;
            i_ptr += 2;
          }
          j = (int )(bit_buffer >> (sizeof(bit_buffer) * 8U - 16U));
          bit_buffer <<= 16;
          bits_left -= 16;
          break;
        }
      }
      lzx->intel_filesize = (i << 16) | j;
      lzx->header_read = (unsigned char)1;
    }
    frame_size = 32768U;
    if (lzx->length) {
      if (lzx->length - lzx->offset < (long )frame_size) {
        frame_size = (unsigned int )(lzx->length - lzx->offset);
      }
    }
    bytes_todo = (int )((lzx->frame_posn + frame_size) - window_posn);
    while (bytes_todo > 0) {
      if (lzx->block_remaining == 0U) {
        if ((int )lzx->block_type == 3) {
          if (lzx->block_length & 1U) {
            if ((unsigned int )i_ptr == (unsigned int )i_end) {
              tmp___3 = lzxd_read_input(lzx);
              if (tmp___3) {
                return (lzx->error);
              }
              i_ptr = lzx->i_ptr;
              i_end = lzx->i_end;
            }
            i_ptr ++;
          }
        }
        while (1) {
          while (bits_left < 3) {
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
              tmp___4 = lzxd_read_input(lzx);
              if (tmp___4) {
                return (lzx->error);
              }
              i_ptr = lzx->i_ptr;
              i_end = lzx->i_end;
            }
            bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                  0))) <<
                                          ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
            bits_left += 16;
            i_ptr += 2;
          }
          lzx->block_type = (unsigned char )(bit_buffer >> (sizeof(bit_buffer) * 8U -
                                                            3U));
          bit_buffer <<= 3;
          bits_left -= 3;
          break;
        }
        while (1) {
          while (bits_left < 16) {
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
              tmp___5 = lzxd_read_input(lzx);
              if (tmp___5) {
                return (lzx->error);
              }
              i_ptr = lzx->i_ptr;
              i_end = lzx->i_end;
            }
            bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                  0))) <<
                                          ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
            bits_left += 16;
            i_ptr += 2;
          }
          i = (int )(bit_buffer >> (sizeof(bit_buffer) * 8U - 16U));
          bit_buffer <<= 16;
          bits_left -= 16;
          break;
        }
        while (1) {
          while (bits_left < 8) {
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
              tmp___6 = lzxd_read_input(lzx);
              if (tmp___6) {
                return (lzx->error);
              }
              i_ptr = lzx->i_ptr;
              i_end = lzx->i_end;
            }
            bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                  0))) <<
                                          ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
            bits_left += 16;
            i_ptr += 2;
          }
          j = (int )(bit_buffer >> (sizeof(bit_buffer) * 8U - 8U));
          bit_buffer <<= 8;
          bits_left -= 8;
          break;
        }
        lzx->block_length = (unsigned int )((i << 8) | j);
        lzx->block_remaining = lzx->block_length;
        switch ((int )lzx->block_type) {
        case 2: 
        i = 0;
        while (i < 8) {
          while (1) {
            while (bits_left < 3) {
              if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                tmp___7 = lzxd_read_input(lzx);
                if (tmp___7) {
                  return (lzx->error);
                }
                i_ptr = lzx->i_ptr;
                i_end = lzx->i_end;
              }
              bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                    0))) <<
                                            ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
              bits_left += 16;
              i_ptr += 2;
            }
            j = (int )(bit_buffer >> (sizeof(bit_buffer) * 8U - 3U));
            bit_buffer <<= 3;
            bits_left -= 3;
            break;
          }
          lzx->ALIGNED_len[i] = (unsigned char )j;
          i ++;
        }
        tmp___8 = make_decode_table(8U, 7U, & lzx->ALIGNED_len[0], & lzx->ALIGNED_table[0]);
        if (tmp___8) {
          lzx->error = 11;
          return (lzx->error);
        }
        case 1: ;
        while (1) {
          while (1) {
            lzx->i_ptr = i_ptr;
            lzx->i_end = i_end;
            lzx->bit_buffer = bit_buffer;
            lzx->bits_left = (unsigned int )bits_left;
            break;
          }
          tmp___9 = lzxd_read_lens(lzx, & lzx->MAINTREE_len[0], 0U, 256U);
          if (tmp___9) {
            return (lzx->error);
          }
          while (1) {
            i_ptr = lzx->i_ptr;
            i_end = lzx->i_end;
            bit_buffer = lzx->bit_buffer;
            bits_left = (int )lzx->bits_left;
            break;
          }
          break;
        }
        while (1) {
          while (1) {
            lzx->i_ptr = i_ptr;
            lzx->i_end = i_end;
            lzx->bit_buffer = bit_buffer;
            lzx->bits_left = (unsigned int )bits_left;
            break;
          }
          tmp___10 = lzxd_read_lens(lzx, & lzx->MAINTREE_len[0], 256U, (unsigned int )(256 +
                                                                                       ((int )lzx->posn_slots <<
                                                                                        3)));
          if (tmp___10) {
            return (lzx->error);
          }
          while (1) {
            i_ptr = lzx->i_ptr;
            i_end = lzx->i_end;
            bit_buffer = lzx->bit_buffer;
            bits_left = (int )lzx->bits_left;
            break;
          }
          break;
        }
        tmp___11 = make_decode_table(656U, 12U, & lzx->MAINTREE_len[0], & lzx->MAINTREE_table[0]);
        if (tmp___11) {
          lzx->error = 11;
          return (lzx->error);
        }
        if ((int )lzx->MAINTREE_len[232] != 0) {
          lzx->intel_started = (unsigned char)1;
        }
        while (1) {
          while (1) {
            lzx->i_ptr = i_ptr;
            lzx->i_end = i_end;
            lzx->bit_buffer = bit_buffer;
            lzx->bits_left = (unsigned int )bits_left;
            break;
          }
          tmp___12 = lzxd_read_lens(lzx, & lzx->LENGTH_len[0], 0U, 249U);
          if (tmp___12) {
            return (lzx->error);
          }
          while (1) {
            i_ptr = lzx->i_ptr;
            i_end = lzx->i_end;
            bit_buffer = lzx->bit_buffer;
            bits_left = (int )lzx->bits_left;
            break;
          }
          break;
        }
        tmp___13 = make_decode_table(250U, 12U, & lzx->LENGTH_len[0], & lzx->LENGTH_table[0]);
        if (tmp___13) {
          lzx->error = 11;
          return (lzx->error);
        }
        break;
        case 3: 
        lzx->intel_started = (unsigned char)1;
        while (bits_left < 16) {
          if ((unsigned int )i_ptr >= (unsigned int )i_end) {
            tmp___14 = lzxd_read_input(lzx);
            if (tmp___14) {
              return (lzx->error);
            }
            i_ptr = lzx->i_ptr;
            i_end = lzx->i_end;
          }
          bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                0))) <<
                                        ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
          bits_left += 16;
          i_ptr += 2;
        }
        if (bits_left > 16) {
          i_ptr -= 2;
        }
        bits_left = 0;
        bit_buffer = 0U;
        rundest = buf;
        i = 0;
        while (i < 12) {
          if ((unsigned int )i_ptr == (unsigned int )i_end) {
            tmp___15 = lzxd_read_input(lzx);
            if (tmp___15) {
              return (lzx->error);
            }
            i_ptr = lzx->i_ptr;
            i_end = lzx->i_end;
          }
          tmp___16 = rundest;
          rundest ++;
          tmp___17 = i_ptr;
          i_ptr ++;
          (*tmp___16) = (*tmp___17);
          i ++;
        }
        R0 = (unsigned int )((((int )buf[0] | ((int )buf[1] << 8)) | ((int )buf[2] <<
                                                                      16)) | ((int )buf[3] <<
                                                                              24));
        R1 = (unsigned int )((((int )buf[4] | ((int )buf[5] << 8)) | ((int )buf[6] <<
                                                                      16)) | ((int )buf[7] <<
                                                                              24));
        R2 = (unsigned int )((((int )buf[8] | ((int )buf[9] << 8)) | ((int )buf[10] <<
                                                                      16)) | ((int )buf[11] <<
                                                                              24));
        break;
        default: 
        lzx->error = 11;
        return (lzx->error);
        }
      }
      this_run = (int )lzx->block_remaining;
      if (this_run > bytes_todo) {
        this_run = bytes_todo;
      }
      bytes_todo -= this_run;
      lzx->block_remaining = lzx->block_remaining - (unsigned int )this_run;
      switch ((int )lzx->block_type) {
      case 1: ;
      while (this_run > 0) {
        while (1) {
          while (bits_left < 16) {
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
              tmp___18 = lzxd_read_input(lzx);
              if (tmp___18) {
                return (lzx->error);
              }
              i_ptr = lzx->i_ptr;
              i_end = lzx->i_end;
            }
            bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                  0))) <<
                                          ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
            bits_left += 16;
            i_ptr += 2;
          }
          sym = lzx->MAINTREE_table[bit_buffer >> (sizeof(bit_buffer) * 8U - 12U)];
          if ((int )sym >= 656) {
            i = 1 << (sizeof(bit_buffer) * 8U - 12U);
            while (1) {
              i >>= 1;
              if (i == 0) {
                lzx->error = 11;
                return (lzx->error);
              }
              sym = (unsigned short )((int )sym << 1);
              if (bit_buffer & (unsigned int )i) {
                tmp___19 = 1;
              } else {
                tmp___19 = 0;
              }
              sym = (unsigned short )((int )sym | tmp___19);
              sym = lzx->MAINTREE_table[sym];
              if (! ((int )sym >= 656)) {
                break;
              }
            }
          }
          main_element = (int )sym;
          i = (int )lzx->MAINTREE_len[sym];
          bit_buffer <<= i;
          bits_left -= i;
          break;
        }
        if (main_element < 256) {
          tmp___20 = window_posn;
          window_posn ++;
          (*(window + tmp___20)) = (unsigned char )main_element;
          this_run --;
        } else {
          main_element -= 256;
          match_length = main_element & 7;
          if (match_length == 7) {
            while (1) {
              while (bits_left < 16) {
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                  tmp___21 = lzxd_read_input(lzx);
                  if (tmp___21) {
                    return (lzx->error);
                  }
                  i_ptr = lzx->i_ptr;
                  i_end = lzx->i_end;
                }
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                      0))) <<
                                              ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
                bits_left += 16;
                i_ptr += 2;
              }
              sym = lzx->LENGTH_table[bit_buffer >> (sizeof(bit_buffer) * 8U - 12U)];
              if ((int )sym >= 250) {
                i = 1 << (sizeof(bit_buffer) * 8U - 12U);
                while (1) {
                  i >>= 1;
                  if (i == 0) {
                    lzx->error = 11;
                    return (lzx->error);
                  }
                  sym = (unsigned short )((int )sym << 1);
                  if (bit_buffer & (unsigned int )i) {
                    tmp___22 = 1;
                  } else {
                    tmp___22 = 0;
                  }
                  sym = (unsigned short )((int )sym | tmp___22);
                  sym = lzx->LENGTH_table[sym];
                  if (! ((int )sym >= 250)) {
                    break;
                  }
                }
              }
              length_footer = (int )sym;
              i = (int )lzx->LENGTH_len[sym];
              bit_buffer <<= i;
              bits_left -= i;
              break;
            }
            match_length += length_footer;
          }
          match_length += 2;
          match_offset = (unsigned int )(main_element >> 3);
          switch ((int )match_offset) {
          case 0: 
          match_offset = R0;
          break;
          case 1: 
          match_offset = R1;
          R1 = R0;
          R0 = match_offset;
          break;
          case 2: 
          match_offset = R2;
          R2 = R0;
          R0 = match_offset;
          break;
          case 3: 
          match_offset = 1U;
          R2 = R1;
          R1 = R0;
          R0 = match_offset;
          break;
          default: 
          extra = (int )extra_bits[match_offset];
          while (1) {
            while (bits_left < extra) {
              if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                tmp___23 = lzxd_read_input(lzx);
                if (tmp___23) {
                  return (lzx->error);
                }
                i_ptr = lzx->i_ptr;
                i_end = lzx->i_end;
              }
              bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                    0))) <<
                                            ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
              bits_left += 16;
              i_ptr += 2;
            }
            verbatim_bits = (int )(bit_buffer >> (sizeof(bit_buffer) * 8U - (unsigned int )extra));
            bit_buffer <<= extra;
            bits_left -= extra;
            break;
          }
          match_offset = (position_base[match_offset] - 2U) + (unsigned int )verbatim_bits;
          R2 = R1;
          R1 = R0;
          R0 = match_offset;
          }
          if (window_posn + (unsigned int )match_length > lzx->window_size) {
            lzx->error = 11;
            return (lzx->error);
          }
          rundest = window + window_posn;
          i = match_length;
          if (match_offset > window_posn) {
            j = (int )(match_offset - window_posn);
            if (j > (int )lzx->window_size) {
              lzx->error = 11;
              return (lzx->error);
            }
            runsrc = window + (lzx->window_size - (unsigned int )j);
            if (j < i) {
              i -= j;
              while (1) {
                tmp___26 = j;
                j --;
                if (! (tmp___26 > 0)) {
                  break;
                }
                tmp___24 = rundest;
                rundest ++;
                tmp___25 = runsrc;
                runsrc ++;
                (*tmp___24) = (*tmp___25);
              }
              runsrc = window;
            }
            while (1) {
              tmp___29 = i;
              i --;
              if (! (tmp___29 > 0)) {
                break;
              }
              tmp___27 = rundest;
              rundest ++;
              tmp___28 = runsrc;
              runsrc ++;
              (*tmp___27) = (*tmp___28);
            }
          } else {
            runsrc = rundest - match_offset;
            while (1) {
              tmp___32 = i;
              i --;
              if (! (tmp___32 > 0)) {
                break;
              }
              tmp___30 = rundest;
              rundest ++;
              tmp___31 = runsrc;
              runsrc ++;
              (*tmp___30) = (*tmp___31);
            }
          }
          this_run -= match_length;
          window_posn += (unsigned int )match_length;
        }
      }
      break;
      case 2: ;
      while (this_run > 0) {
        while (1) {
          while (bits_left < 16) {
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
              tmp___33 = lzxd_read_input(lzx);
              if (tmp___33) {
                return (lzx->error);
              }
              i_ptr = lzx->i_ptr;
              i_end = lzx->i_end;
            }
            bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                  0))) <<
                                          ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
            bits_left += 16;
            i_ptr += 2;
          }
          sym = lzx->MAINTREE_table[bit_buffer >> (sizeof(bit_buffer) * 8U - 12U)];
          if ((int )sym >= 656) {
            i = 1 << (sizeof(bit_buffer) * 8U - 12U);
            while (1) {
              i >>= 1;
              if (i == 0) {
                lzx->error = 11;
                return (lzx->error);
              }
              sym = (unsigned short )((int )sym << 1);
              if (bit_buffer & (unsigned int )i) {
                tmp___34 = 1;
              } else {
                tmp___34 = 0;
              }
              sym = (unsigned short )((int )sym | tmp___34);
              sym = lzx->MAINTREE_table[sym];
              if (! ((int )sym >= 656)) {
                break;
              }
            }
          }
          main_element = (int )sym;
          i = (int )lzx->MAINTREE_len[sym];
          bit_buffer <<= i;
          bits_left -= i;
          break;
        }
        if (main_element < 256) {
          tmp___35 = window_posn;
          window_posn ++;
          (*(window + tmp___35)) = (unsigned char )main_element;
          this_run --;
        } else {
          main_element -= 256;
          match_length = main_element & 7;
          if (match_length == 7) {
            while (1) {
              while (bits_left < 16) {
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                  tmp___36 = lzxd_read_input(lzx);
                  if (tmp___36) {
                    return (lzx->error);
                  }
                  i_ptr = lzx->i_ptr;
                  i_end = lzx->i_end;
                }
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                      0))) <<
                                              ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
                bits_left += 16;
                i_ptr += 2;
              }
              sym = lzx->LENGTH_table[bit_buffer >> (sizeof(bit_buffer) * 8U - 12U)];
              if ((int )sym >= 250) {
                i = 1 << (sizeof(bit_buffer) * 8U - 12U);
                while (1) {
                  i >>= 1;
                  if (i == 0) {
                    lzx->error = 11;
                    return (lzx->error);
                  }
                  sym = (unsigned short )((int )sym << 1);
                  if (bit_buffer & (unsigned int )i) {
                    tmp___37 = 1;
                  } else {
                    tmp___37 = 0;
                  }
                  sym = (unsigned short )((int )sym | tmp___37);
                  sym = lzx->LENGTH_table[sym];
                  if (! ((int )sym >= 250)) {
                    break;
                  }
                }
              }
              length_footer = (int )sym;
              i = (int )lzx->LENGTH_len[sym];
              bit_buffer <<= i;
              bits_left -= i;
              break;
            }
            match_length += length_footer;
          }
          match_length += 2;
          match_offset = (unsigned int )(main_element >> 3);
          switch ((int )match_offset) {
          case 0: 
          match_offset = R0;
          break;
          case 1: 
          match_offset = R1;
          R1 = R0;
          R0 = match_offset;
          break;
          case 2: 
          match_offset = R2;
          R2 = R0;
          R0 = match_offset;
          break;
          default: 
          extra = (int )extra_bits[match_offset];
          match_offset = position_base[match_offset] - 2U;
          if (extra > 3) {
            extra -= 3;
            while (1) {
              while (bits_left < extra) {
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                  tmp___38 = lzxd_read_input(lzx);
                  if (tmp___38) {
                    return (lzx->error);
                  }
                  i_ptr = lzx->i_ptr;
                  i_end = lzx->i_end;
                }
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                      0))) <<
                                              ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
                bits_left += 16;
                i_ptr += 2;
              }
              verbatim_bits = (int )(bit_buffer >> (sizeof(bit_buffer) * 8U - (unsigned int )extra));
              bit_buffer <<= extra;
              bits_left -= extra;
              break;
            }
            match_offset += (unsigned int )(verbatim_bits << 3);
            while (1) {
              while (bits_left < 16) {
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                  tmp___39 = lzxd_read_input(lzx);
                  if (tmp___39) {
                    return (lzx->error);
                  }
                  i_ptr = lzx->i_ptr;
                  i_end = lzx->i_end;
                }
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                      0))) <<
                                              ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
                bits_left += 16;
                i_ptr += 2;
              }
              sym = lzx->ALIGNED_table[bit_buffer >> (sizeof(bit_buffer) * 8U - 7U)];
              if ((int )sym >= 8) {
                i = 1 << (sizeof(bit_buffer) * 8U - 7U);
                while (1) {
                  i >>= 1;
                  if (i == 0) {
                    lzx->error = 11;
                    return (lzx->error);
                  }
                  sym = (unsigned short )((int )sym << 1);
                  if (bit_buffer & (unsigned int )i) {
                    tmp___40 = 1;
                  } else {
                    tmp___40 = 0;
                  }
                  sym = (unsigned short )((int )sym | tmp___40);
                  sym = lzx->ALIGNED_table[sym];
                  if (! ((int )sym >= 8)) {
                    break;
                  }
                }
              }
              aligned_bits = (int )sym;
              i = (int )lzx->ALIGNED_len[sym];
              bit_buffer <<= i;
              bits_left -= i;
              break;
            }
            match_offset += (unsigned int )aligned_bits;
          } else {
            if (extra == 3) {
              while (1) {
                while (bits_left < 16) {
                  if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                    tmp___41 = lzxd_read_input(lzx);
                    if (tmp___41) {
                      return (lzx->error);
                    }
                    i_ptr = lzx->i_ptr;
                    i_end = lzx->i_end;
                  }
                  bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                        0))) <<
                                                ((sizeof(bit_buffer) * 8U - 16U) -
                                                 (unsigned int )bits_left));
                  bits_left += 16;
                  i_ptr += 2;
                }
                sym = lzx->ALIGNED_table[bit_buffer >> (sizeof(bit_buffer) * 8U -
                                                        7U)];
                if ((int )sym >= 8) {
                  i = 1 << (sizeof(bit_buffer) * 8U - 7U);
                  while (1) {
                    i >>= 1;
                    if (i == 0) {
                      lzx->error = 11;
                      return (lzx->error);
                    }
                    sym = (unsigned short )((int )sym << 1);
                    if (bit_buffer & (unsigned int )i) {
                      tmp___42 = 1;
                    } else {
                      tmp___42 = 0;
                    }
                    sym = (unsigned short )((int )sym | tmp___42);
                    sym = lzx->ALIGNED_table[sym];
                    if (! ((int )sym >= 8)) {
                      break;
                    }
                  }
                }
                aligned_bits = (int )sym;
                i = (int )lzx->ALIGNED_len[sym];
                bit_buffer <<= i;
                bits_left -= i;
                break;
              }
              match_offset += (unsigned int )aligned_bits;
            } else {
              if (extra > 0) {
                while (1) {
                  while (bits_left < extra) {
                    if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                      tmp___43 = lzxd_read_input(lzx);
                      if (tmp___43) {
                        return (lzx->error);
                      }
                      i_ptr = lzx->i_ptr;
                      i_end = lzx->i_end;
                    }
                    bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                          0))) <<
                                                  ((sizeof(bit_buffer) * 8U - 16U) -
                                                   (unsigned int )bits_left));
                    bits_left += 16;
                    i_ptr += 2;
                  }
                  verbatim_bits = (int )(bit_buffer >> (sizeof(bit_buffer) * 8U -
                                                        (unsigned int )extra));
                  bit_buffer <<= extra;
                  bits_left -= extra;
                  break;
                }
                match_offset += (unsigned int )verbatim_bits;
              } else {
                match_offset = 1U;
              }
            }
          }
          R2 = R1;
          R1 = R0;
          R0 = match_offset;
          }
          if (window_posn + (unsigned int )match_length > lzx->window_size) {
            lzx->error = 11;
            return (lzx->error);
          }
          rundest = window + window_posn;
          i = match_length;
          if (match_offset > window_posn) {
            j = (int )(match_offset - window_posn);
            if (j > (int )lzx->window_size) {
              lzx->error = 11;
              return (lzx->error);
            }
            runsrc = window + (lzx->window_size - (unsigned int )j);
            if (j < i) {
              i -= j;
              while (1) {
                tmp___46 = j;
                j --;
                if (! (tmp___46 > 0)) {
                  break;
                }
                tmp___44 = rundest;
                rundest ++;
                tmp___45 = runsrc;
                runsrc ++;
                (*tmp___44) = (*tmp___45);
              }
              runsrc = window;
            }
            while (1) {
              tmp___49 = i;
              i --;
              if (! (tmp___49 > 0)) {
                break;
              }
              tmp___47 = rundest;
              rundest ++;
              tmp___48 = runsrc;
              runsrc ++;
              (*tmp___47) = (*tmp___48);
            }
          } else {
            runsrc = rundest - match_offset;
            while (1) {
              tmp___52 = i;
              i --;
              if (! (tmp___52 > 0)) {
                break;
              }
              tmp___50 = rundest;
              rundest ++;
              tmp___51 = runsrc;
              runsrc ++;
              (*tmp___50) = (*tmp___51);
            }
          }
          this_run -= match_length;
          window_posn += (unsigned int )match_length;
        }
      }
      break;
      case 3: 
      rundest = window + window_posn;
      window_posn += (unsigned int )this_run;
      while (this_run > 0) {
        i = i_end - i_ptr;
        if (i) {
          if (i > this_run) {
            i = this_run;
          }
          ((*((lzx->sys)->copy)))((void *)i_ptr, (void *)rundest, (unsigned int )i);
          rundest += i;
          i_ptr += i;
          this_run -= i;
        } else {
          tmp___53 = lzxd_read_input(lzx);
          if (tmp___53) {
            return (lzx->error);
          }
          i_ptr = lzx->i_ptr;
          i_end = lzx->i_end;
        }
      }
      break;
      default: 
      lzx->error = 11;
      return (lzx->error);
      }
      if (this_run < 0) {
        if ((unsigned int )(- this_run) > lzx->block_remaining) {
          lzx->error = 11;
          return (lzx->error);
        }
        lzx->block_remaining = lzx->block_remaining - (unsigned int )(- this_run);
      }
    }
    if (window_posn - lzx->frame_posn != frame_size) {
      lzx->error = 11;
      return (lzx->error);
    }
    if (bits_left > 0) {
      while (bits_left < 16) {
        if ((unsigned int )i_ptr >= (unsigned int )i_end) {
          tmp___54 = lzxd_read_input(lzx);
          if (tmp___54) {
            return (lzx->error);
          }
          i_ptr = lzx->i_ptr;
          i_end = lzx->i_end;
        }
        bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                              0))) <<
                                      ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
        bits_left += 16;
        i_ptr += 2;
      }
    }
    if (bits_left & 15) {
      bit_buffer <<= bits_left & 15;
      bits_left -= bits_left & 15;
    }
    if ((unsigned int )lzx->o_ptr != (unsigned int )lzx->o_end) {
      lzx->error = 11;
      return (lzx->error);
    }
    if (lzx->intel_started) {
      if (lzx->intel_filesize) {
        if (lzx->frame <= 32768U) {
          if (frame_size > 10U) {
            data = & lzx->e8_buf[0];
            dataend = & lzx->e8_buf[frame_size - 10U];
            curpos = lzx->intel_curpos;
            filesize = lzx->intel_filesize;
            lzx->o_ptr = data;
            ((*((lzx->sys)->copy)))((void *)(lzx->window + lzx->frame_posn), (void *)data,
                                    frame_size);
            while ((unsigned int )data < (unsigned int )dataend) {
              tmp___55 = data;
              data ++;
              if ((int )(*tmp___55) != 232) {
                curpos ++;
                continue;
              }
              abs_off = (((int )(*(data + 0)) | ((int )(*(data + 1)) << 8)) | ((int )(*(data +
                                                                                        2)) <<
                                                                               16)) |
                        ((int )(*(data + 3)) << 24);
              if (abs_off >= - curpos) {
                if (abs_off < filesize) {
                  if (abs_off >= 0) {
                    rel_off = abs_off - curpos;
                  } else {
                    rel_off = abs_off + filesize;
                  }
                  (*(data + 0)) = (unsigned char )rel_off;
                  (*(data + 1)) = (unsigned char )(rel_off >> 8);
                  (*(data + 2)) = (unsigned char )(rel_off >> 16);
                  (*(data + 3)) = (unsigned char )(rel_off >> 24);
                }
              }
              data += 4;
              curpos += 5;
            }
            lzx->intel_curpos = (int )((unsigned int )lzx->intel_curpos + frame_size);
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      lzx->o_ptr = lzx->window + lzx->frame_posn;
      if (lzx->intel_filesize) {
        lzx->intel_curpos = (int )((unsigned int )lzx->intel_curpos + frame_size);
      }
    }
    lzx->o_end = lzx->o_ptr + frame_size;
    if (out_bytes < (long )frame_size) {
      i = (int )((unsigned int )out_bytes);
    } else {
      i = (int )frame_size;
    }
    tmp___56 = ((*((lzx->sys)->write)))(lzx->output, (void *)lzx->o_ptr, i);
    if (tmp___56 != i) {
      lzx->error = 4;
      return (lzx->error);
    }
    lzx->o_ptr = lzx->o_ptr + i;
    lzx->offset = lzx->offset + (long )i;
    out_bytes -= (long )i;
    lzx->frame_posn = lzx->frame_posn + frame_size;
    lzx->frame = lzx->frame + 1U;
    if (window_posn == lzx->window_size) {
      window_posn = 0U;
    }
    if (lzx->frame_posn == lzx->window_size) {
      lzx->frame_posn = 0U;
    }
  }
  if (out_bytes) {
    lzx->error = 11;
    return (lzx->error);
  }
  while (1) {
    lzx->i_ptr = i_ptr;
    lzx->i_end = i_end;
    lzx->bit_buffer = bit_buffer;
    lzx->bits_left = (unsigned int )bits_left;
    break;
  }
  lzx->window_posn = window_posn;
  lzx->R0 = R0;
  lzx->R1 = R1;
  lzx->R2 = R2;
  return (0);
}
}
void lzxd_free(struct lzxd_stream *lzx ) 
{ struct mspack_system *sys ;

  {
  if (lzx) {
    sys = lzx->sys;
    ((*(sys->free)))((void *)lzx->inbuf);
    ((*(sys->free)))((void *)lzx->window);
    ((*(sys->free)))((void *)lzx);
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-MJAy2Y9W.i","-g -O2 -fPIC")
static unsigned short const   lit_lengths[29]  = 
  {      (unsigned short const   )3,      (unsigned short const   )4,      (unsigned short const   )5,      (unsigned short const   )6, 
        (unsigned short const   )7,      (unsigned short const   )8,      (unsigned short const   )9,      (unsigned short const   )10, 
        (unsigned short const   )11,      (unsigned short const   )13,      (unsigned short const   )15,      (unsigned short const   )17, 
        (unsigned short const   )19,      (unsigned short const   )23,      (unsigned short const   )27,      (unsigned short const   )31, 
        (unsigned short const   )35,      (unsigned short const   )43,      (unsigned short const   )51,      (unsigned short const   )59, 
        (unsigned short const   )67,      (unsigned short const   )83,      (unsigned short const   )99,      (unsigned short const   )115, 
        (unsigned short const   )131,      (unsigned short const   )163,      (unsigned short const   )195,      (unsigned short const   )227, 
        (unsigned short const   )258};
static unsigned short const   dist_offsets[30]  = 
  {      (unsigned short const   )1,      (unsigned short const   )2,      (unsigned short const   )3,      (unsigned short const   )4, 
        (unsigned short const   )5,      (unsigned short const   )7,      (unsigned short const   )9,      (unsigned short const   )13, 
        (unsigned short const   )17,      (unsigned short const   )25,      (unsigned short const   )33,      (unsigned short const   )49, 
        (unsigned short const   )65,      (unsigned short const   )97,      (unsigned short const   )129,      (unsigned short const   )193, 
        (unsigned short const   )257,      (unsigned short const   )385,      (unsigned short const   )513,      (unsigned short const   )769, 
        (unsigned short const   )1025,      (unsigned short const   )1537,      (unsigned short const   )2049,      (unsigned short const   )3073, 
        (unsigned short const   )4097,      (unsigned short const   )6145,      (unsigned short const   )8193,      (unsigned short const   )12289, 
        (unsigned short const   )16385,      (unsigned short const   )24577};
static unsigned char const   lit_extrabits[29]  = 
  {      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )5,      (unsigned char const   )5,      (unsigned char const   )5, 
        (unsigned char const   )0};
static unsigned char const   dist_extrabits[30]  = 
  {      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )7,      (unsigned char const   )7,      (unsigned char const   )8,      (unsigned char const   )8, 
        (unsigned char const   )9,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )10, 
        (unsigned char const   )11,      (unsigned char const   )11,      (unsigned char const   )12,      (unsigned char const   )12, 
        (unsigned char const   )13,      (unsigned char const   )13};
static unsigned char const   bitlen_order[19]  = 
  {      (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )0, 
        (unsigned char const   )8,      (unsigned char const   )7,      (unsigned char const   )9,      (unsigned char const   )6, 
        (unsigned char const   )10,      (unsigned char const   )5,      (unsigned char const   )11,      (unsigned char const   )4, 
        (unsigned char const   )12,      (unsigned char const   )3,      (unsigned char const   )13,      (unsigned char const   )2, 
        (unsigned char const   )14,      (unsigned char const   )1,      (unsigned char const   )15};
static unsigned short const   bit_mask[17]  = 
  {      (unsigned short const   )0,      (unsigned short const   )1,      (unsigned short const   )3,      (unsigned short const   )7, 
        (unsigned short const   )15,      (unsigned short const   )31,      (unsigned short const   )63,      (unsigned short const   )127, 
        (unsigned short const   )255,      (unsigned short const   )511,      (unsigned short const   )1023,      (unsigned short const   )2047, 
        (unsigned short const   )4095,      (unsigned short const   )8191,      (unsigned short const   )16383,      (unsigned short const   )32767, 
        (unsigned short const   )65535};
static int zipd_read_input(struct mszipd_stream *zip ) 
{ int read___0 ;
  int tmp ;

  {
  tmp = ((*((zip->sys)->read)))(zip->input, (void *)(zip->inbuf + 0), (int )zip->inbuf_size);
  read___0 = tmp;
  if (read___0 < 0) {
    zip->error = 3;
    return (zip->error);
  }
  zip->i_ptr = zip->inbuf + 0;
  zip->i_end = zip->inbuf + read___0;
  return (0);
}
}
static int make_decode_table___0(unsigned int nsyms , unsigned int nbits , unsigned char *length ,
                                 unsigned short *table ) 
{ register unsigned int leaf ;
  register unsigned int reverse ;
  register unsigned int fill ;
  register unsigned short sym ;
  register unsigned short next_sym ;
  register unsigned char bit_num ;
  unsigned int pos ;
  unsigned int table_mask ;
  unsigned int bit_mask___0 ;
  unsigned short tmp ;
  int tmp___0 ;

  {
  pos = 0U;
  table_mask = (unsigned int )(1 << nbits);
  bit_mask___0 = table_mask >> 1;
  bit_num = (unsigned char)1;
  while ((unsigned int )bit_num <= nbits) {
    sym = (unsigned short)0;
    while ((unsigned int )sym < nsyms) {
      if ((int )(*(length + (int )sym)) != (int )bit_num) {
        goto __Cont;
      }
      fill = (unsigned int )(*(length + (int )sym));
      reverse = pos >> (nbits - fill);
      leaf = 0U;
      while (1) {
        leaf <<= 1;
        leaf |= reverse & 1U;
        reverse >>= 1;
        fill --;
        if (! fill) {
          break;
        }
      }
      pos += bit_mask___0;
      if (pos > table_mask) {
        return (1);
      }
      fill = bit_mask___0;
      next_sym = (unsigned short )(1 << (int )bit_num);
      while (1) {
        (*(table + leaf)) = sym;
        leaf += (unsigned int )next_sym;
        fill --;
        if (! fill) {
          break;
        }
      }
      __Cont: 
      sym = (unsigned short )((int )sym + 1);
    }
    bit_mask___0 >>= 1;
    bit_num = (unsigned char )((int )bit_num + 1);
  }
  if (pos == table_mask) {
    return (0);
  }
  sym = (unsigned short )pos;
  while ((unsigned int )sym < table_mask) {
    reverse = (unsigned int )sym;
    leaf = 0U;
    fill = nbits;
    while (1) {
      leaf <<= 1;
      leaf |= reverse & 1U;
      reverse >>= 1;
      fill --;
      if (! fill) {
        break;
      }
    }
    (*(table + leaf)) = (unsigned short)65535;
    sym = (unsigned short )((int )sym + 1);
  }
  if (table_mask >> 1 < nsyms) {
    next_sym = (unsigned short )nsyms;
  } else {
    next_sym = (unsigned short )(table_mask >> 1);
  }
  pos <<= 16;
  table_mask <<= 16;
  bit_mask___0 = 32768U;
  bit_num = (unsigned char )(nbits + 1U);
  while ((int )bit_num <= 16) {
    sym = (unsigned short)0;
    while ((unsigned int )sym < nsyms) {
      if ((int )(*(length + (int )sym)) != (int )bit_num) {
        goto __Cont___0;
      }
      reverse = pos >> 16;
      leaf = 0U;
      fill = nbits;
      while (1) {
        leaf <<= 1;
        leaf |= reverse & 1U;
        reverse >>= 1;
        fill --;
        if (! fill) {
          break;
        }
      }
      fill = 0U;
      while (fill < (unsigned int )bit_num - nbits) {
        if ((int )(*(table + leaf)) == 65535) {
          (*(table + ((int )next_sym << 1))) = (unsigned short)65535;
          (*(table + (((int )next_sym << 1) + 1))) = (unsigned short)65535;
          tmp = next_sym;
          next_sym = (unsigned short )((int )next_sym + 1);
          (*(table + leaf)) = tmp;
        }
        leaf = (unsigned int )((int )(*(table + leaf)) << 1) | ((pos >> (15U - fill)) &
                                                                1U);
        fill ++;
      }
      (*(table + leaf)) = sym;
      pos += bit_mask___0;
      if (pos > table_mask) {
        return (1);
      }
      __Cont___0: 
      sym = (unsigned short )((int )sym + 1);
    }
    bit_mask___0 >>= 1;
    bit_num = (unsigned char )((int )bit_num + 1);
  }
  if (pos != table_mask) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static int zip_read_lens(struct mszipd_stream *zip ) 
{ register unsigned int bit_buffer ;
  register int bits_left ;
  unsigned char *i_ptr ;
  unsigned char *i_end ;
  unsigned short bl_table[128] ;
  unsigned char bl_len[19] ;
  unsigned char lens[320] ;
  unsigned int lit_codes ;
  unsigned int dist_codes ;
  unsigned int code ;
  unsigned int last_code ;
  unsigned int bitlen_codes ;
  unsigned int i ;
  unsigned int run ;
  int tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  int tmp___3 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned char *tmp___10 ;
  int tmp___11 ;
  unsigned char *tmp___12 ;
  int tmp___13 ;
  unsigned char *tmp___14 ;
  int tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;

  {
  last_code = 0U;
  while (1) {
    i_ptr = zip->i_ptr;
    i_end = zip->i_end;
    bit_buffer = zip->bit_buffer;
    bits_left = (int )zip->bits_left;
    break;
  }
  while (1) {
    while (1) {
      while (bits_left < 5) {
        if ((unsigned int )i_ptr >= (unsigned int )i_end) {
          tmp = zipd_read_input(zip);
          if (tmp) {
            return (zip->error);
          }
          i_ptr = zip->i_ptr;
          i_end = zip->i_end;
        }
        tmp___0 = i_ptr;
        i_ptr ++;
        bit_buffer |= (unsigned int )((int )(*tmp___0) << bits_left);
        bits_left += 8;
      }
      break;
    }
    lit_codes = bit_buffer & 31U;
    bit_buffer >>= 5;
    bits_left -= 5;
    break;
  }
  lit_codes += 257U;
  while (1) {
    while (1) {
      while (bits_left < 5) {
        if ((unsigned int )i_ptr >= (unsigned int )i_end) {
          tmp___1 = zipd_read_input(zip);
          if (tmp___1) {
            return (zip->error);
          }
          i_ptr = zip->i_ptr;
          i_end = zip->i_end;
        }
        tmp___2 = i_ptr;
        i_ptr ++;
        bit_buffer |= (unsigned int )((int )(*tmp___2) << bits_left);
        bits_left += 8;
      }
      break;
    }
    dist_codes = bit_buffer & 31U;
    bit_buffer >>= 5;
    bits_left -= 5;
    break;
  }
  dist_codes ++;
  while (1) {
    while (1) {
      while (bits_left < 4) {
        if ((unsigned int )i_ptr >= (unsigned int )i_end) {
          tmp___3 = zipd_read_input(zip);
          if (tmp___3) {
            return (zip->error);
          }
          i_ptr = zip->i_ptr;
          i_end = zip->i_end;
        }
        tmp___4 = i_ptr;
        i_ptr ++;
        bit_buffer |= (unsigned int )((int )(*tmp___4) << bits_left);
        bits_left += 8;
      }
      break;
    }
    bitlen_codes = bit_buffer & 15U;
    bit_buffer >>= 4;
    bits_left -= 4;
    break;
  }
  bitlen_codes += 4U;
  if (lit_codes > 288U) {
    return (-5);
  }
  if (dist_codes > 32U) {
    return (-5);
  }
  i = 0U;
  while (i < bitlen_codes) {
    while (1) {
      while (1) {
        while (bits_left < 3) {
          if ((unsigned int )i_ptr >= (unsigned int )i_end) {
            tmp___5 = zipd_read_input(zip);
            if (tmp___5) {
              return (zip->error);
            }
            i_ptr = zip->i_ptr;
            i_end = zip->i_end;
          }
          tmp___6 = i_ptr;
          i_ptr ++;
          bit_buffer |= (unsigned int )((int )(*tmp___6) << bits_left);
          bits_left += 8;
        }
        break;
      }
      bl_len[bitlen_order[i]] = (unsigned char )(bit_buffer & 7U);
      bit_buffer >>= 3;
      bits_left -= 3;
      break;
    }
    i ++;
  }
  while (i < 19U) {
    tmp___7 = i;
    i ++;
    bl_len[bitlen_order[tmp___7]] = (unsigned char)0;
  }
  tmp___8 = make_decode_table___0(19U, 7U, bl_len, bl_table);
  if (tmp___8) {
    return (-6);
  }
  i = 0U;
  while (i < lit_codes + dist_codes) {
    while (1) {
      while (bits_left < 7) {
        if ((unsigned int )i_ptr >= (unsigned int )i_end) {
          tmp___9 = zipd_read_input(zip);
          if (tmp___9) {
            return (zip->error);
          }
          i_ptr = zip->i_ptr;
          i_end = zip->i_end;
        }
        tmp___10 = i_ptr;
        i_ptr ++;
        bit_buffer |= (unsigned int )((int )(*tmp___10) << bits_left);
        bits_left += 8;
      }
      break;
    }
    code = (unsigned int )bl_table[bit_buffer & 127U];
    bit_buffer >>= (int )bl_len[code];
    bits_left -= (int )bl_len[code];
    if (code < 16U) {
      last_code = code;
      lens[i] = (unsigned char )last_code;
    } else {
      switch ((int )code) {
      case 16: ;
      while (1) {
        while (1) {
          while (bits_left < 2) {
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
              tmp___11 = zipd_read_input(zip);
              if (tmp___11) {
                return (zip->error);
              }
              i_ptr = zip->i_ptr;
              i_end = zip->i_end;
            }
            tmp___12 = i_ptr;
            i_ptr ++;
            bit_buffer |= (unsigned int )((int )(*tmp___12) << bits_left);
            bits_left += 8;
          }
          break;
        }
        run = bit_buffer & 3U;
        bit_buffer >>= 2;
        bits_left -= 2;
        break;
      }
      run += 3U;
      code = last_code;
      break;
      case 17: ;
      while (1) {
        while (1) {
          while (bits_left < 3) {
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
              tmp___13 = zipd_read_input(zip);
              if (tmp___13) {
                return (zip->error);
              }
              i_ptr = zip->i_ptr;
              i_end = zip->i_end;
            }
            tmp___14 = i_ptr;
            i_ptr ++;
            bit_buffer |= (unsigned int )((int )(*tmp___14) << bits_left);
            bits_left += 8;
          }
          break;
        }
        run = bit_buffer & 7U;
        bit_buffer >>= 3;
        bits_left -= 3;
        break;
      }
      run += 3U;
      code = 0U;
      break;
      case 18: ;
      while (1) {
        while (1) {
          while (bits_left < 7) {
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
              tmp___15 = zipd_read_input(zip);
              if (tmp___15) {
                return (zip->error);
              }
              i_ptr = zip->i_ptr;
              i_end = zip->i_end;
            }
            tmp___16 = i_ptr;
            i_ptr ++;
            bit_buffer |= (unsigned int )((int )(*tmp___16) << bits_left);
            bits_left += 8;
          }
          break;
        }
        run = bit_buffer & 127U;
        bit_buffer >>= 7;
        bits_left -= 7;
        break;
      }
      run += 11U;
      code = 0U;
      break;
      default: ;
      return (-10);
      }
      if (i + run > lit_codes + dist_codes) {
        return (-9);
      }
      while (1) {
        tmp___18 = run;
        run --;
        if (! tmp___18) {
          break;
        }
        tmp___17 = i;
        i ++;
        lens[tmp___17] = (unsigned char )code;
      }
      i --;
    }
    i ++;
  }
  i = lit_codes;
  ((*((zip->sys)->copy)))((void *)(lens), (void *)(& zip->LITERAL_len[0]), i);
  while (i < 288U) {
    tmp___19 = i;
    i ++;
    zip->LITERAL_len[tmp___19] = (unsigned char)0;
  }
  i = dist_codes;
  ((*((zip->sys)->copy)))((void *)(& lens[lit_codes]), (void *)(& zip->DISTANCE_len[0]),
                          i);
  while (i < 32U) {
    tmp___20 = i;
    i ++;
    zip->DISTANCE_len[tmp___20] = (unsigned char)0;
  }
  while (1) {
    zip->i_ptr = i_ptr;
    zip->i_end = i_end;
    zip->bit_buffer = bit_buffer;
    zip->bits_left = (unsigned int )bits_left;
    break;
  }
  return (0);
}
}
static int inflate___0(struct mszipd_stream *zip ) 
{ unsigned int last_block ;
  unsigned int block_type ;
  unsigned int distance ;
  unsigned int length ;
  unsigned int this_run ;
  unsigned int i ;
  register unsigned int bit_buffer ;
  register int bits_left ;
  register unsigned short sym ;
  unsigned char *i_ptr ;
  unsigned char *i_end ;
  int tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char lens_buf[4] ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int window_posn ;
  unsigned int match_posn ;
  unsigned int code ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  unsigned char *tmp___20 ;
  int tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned int tmp___23 ;
  int tmp___24 ;
  unsigned char *tmp___25 ;
  int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned char *runsrc ;
  unsigned char *rundest ;
  unsigned char *tmp___31 ;
  unsigned char *tmp___32 ;
  unsigned int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;

  {
  while (1) {
    i_ptr = zip->i_ptr;
    i_end = zip->i_end;
    bit_buffer = zip->bit_buffer;
    bits_left = (int )zip->bits_left;
    break;
  }
  while (1) {
    while (1) {
      while (1) {
        while (bits_left < 1) {
          if ((unsigned int )i_ptr >= (unsigned int )i_end) {
            tmp = zipd_read_input(zip);
            if (tmp) {
              return (zip->error);
            }
            i_ptr = zip->i_ptr;
            i_end = zip->i_end;
          }
          tmp___0 = i_ptr;
          i_ptr ++;
          bit_buffer |= (unsigned int )((int )(*tmp___0) << bits_left);
          bits_left += 8;
        }
        break;
      }
      last_block = bit_buffer & 1U;
      bit_buffer >>= 1;
      bits_left --;
      break;
    }
    while (1) {
      while (1) {
        while (bits_left < 2) {
          if ((unsigned int )i_ptr >= (unsigned int )i_end) {
            tmp___1 = zipd_read_input(zip);
            if (tmp___1) {
              return (zip->error);
            }
            i_ptr = zip->i_ptr;
            i_end = zip->i_end;
          }
          tmp___2 = i_ptr;
          i_ptr ++;
          bit_buffer |= (unsigned int )((int )(*tmp___2) << bits_left);
          bits_left += 8;
        }
        break;
      }
      block_type = bit_buffer & 3U;
      bit_buffer >>= 2;
      bits_left -= 2;
      break;
    }
    if (block_type == 0U) {
      i = (unsigned int )(bits_left & 7);
      bit_buffer >>= i;
      bits_left = (int )((unsigned int )bits_left - i);
      i = 0U;
      while (bits_left >= 8) {
        if (i == 4U) {
          return (-4);
        }
        lens_buf[i] = (unsigned char )(bit_buffer & 255U);
        bit_buffer >>= 8;
        bits_left -= 8;
        i ++;
      }
      if (bits_left != 0) {
        return (-4);
      }
      while (i < 4U) {
        if ((unsigned int )i_ptr >= (unsigned int )i_end) {
          tmp___3 = zipd_read_input(zip);
          if (tmp___3) {
            return (zip->error);
          }
          i_ptr = zip->i_ptr;
          i_end = zip->i_end;
        }
        tmp___4 = i;
        i ++;
        tmp___5 = i_ptr;
        i_ptr ++;
        lens_buf[tmp___4] = (*tmp___5);
      }
      length = (unsigned int )((int )lens_buf[0] | ((int )lens_buf[1] << 8));
      i = (unsigned int )((int )lens_buf[2] | ((int )lens_buf[3] << 8));
      if (length != (~ i & 65535U)) {
        return (-2);
      }
      while (length > 0U) {
        if ((unsigned int )i_ptr >= (unsigned int )i_end) {
          tmp___6 = zipd_read_input(zip);
          if (tmp___6) {
            return (zip->error);
          }
          i_ptr = zip->i_ptr;
          i_end = zip->i_end;
        }
        this_run = length;
        if (this_run > (unsigned int )(i_end - i_ptr)) {
          this_run = (unsigned int )(i_end - i_ptr);
        }
        if (this_run > 32768U - zip->window_posn) {
          this_run = 32768U - zip->window_posn;
        }
        ((*((zip->sys)->copy)))((void *)i_ptr, (void *)(& zip->window[zip->window_posn]),
                                this_run);
        zip->window_posn = zip->window_posn + this_run;
        i_ptr += this_run;
        length -= this_run;
        if (zip->window_posn == 32768U) {
          tmp___7 = ((*(zip->flush_window)))(zip, 32768U);
          if (tmp___7) {
            return (-3);
          }
          zip->window_posn = 0U;
        }
      }
    } else {
      if (block_type == 1U) {
        goto _L;
      } else {
        if (block_type == 2U) {
          _L: 
          if (block_type == 1U) {
            i = 0U;
            while (i < 144U) {
              tmp___8 = i;
              i ++;
              zip->LITERAL_len[tmp___8] = (unsigned char)8;
            }
            while (i < 256U) {
              tmp___9 = i;
              i ++;
              zip->LITERAL_len[tmp___9] = (unsigned char)9;
            }
            while (i < 280U) {
              tmp___10 = i;
              i ++;
              zip->LITERAL_len[tmp___10] = (unsigned char)7;
            }
            while (i < 288U) {
              tmp___11 = i;
              i ++;
              zip->LITERAL_len[tmp___11] = (unsigned char)8;
            }
            i = 0U;
            while (i < 32U) {
              zip->DISTANCE_len[i] = (unsigned char)5;
              i ++;
            }
          } else {
            while (1) {
              zip->i_ptr = i_ptr;
              zip->i_end = i_end;
              zip->bit_buffer = bit_buffer;
              zip->bits_left = (unsigned int )bits_left;
              break;
            }
            i = (unsigned int )zip_read_lens(zip);
            if (i) {
              return ((int )i);
            }
            while (1) {
              i_ptr = zip->i_ptr;
              i_end = zip->i_end;
              bit_buffer = zip->bit_buffer;
              bits_left = (int )zip->bits_left;
              break;
            }
          }
          tmp___12 = make_decode_table___0(288U, 9U, & zip->LITERAL_len[0], & zip->LITERAL_table[0]);
          if (tmp___12) {
            return (-7);
          }
          tmp___13 = make_decode_table___0(32U, 6U, & zip->DISTANCE_len[0], & zip->DISTANCE_table[0]);
          if (tmp___13) {
            return (-8);
          }
          window_posn = zip->window_posn;
          while (1) {
            while (1) {
              while (1) {
                while (bits_left < 16) {
                  if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                    tmp___14 = zipd_read_input(zip);
                    if (tmp___14) {
                      return (zip->error);
                    }
                    i_ptr = zip->i_ptr;
                    i_end = zip->i_end;
                  }
                  tmp___15 = i_ptr;
                  i_ptr ++;
                  bit_buffer |= (unsigned int )((int )(*tmp___15) << bits_left);
                  bits_left += 8;
                }
                break;
              }
              sym = zip->LITERAL_table[bit_buffer & 511U];
              if ((int )sym >= 288) {
                i = 8U;
                while (1) {
                  tmp___16 = i;
                  i ++;
                  if (tmp___16 > 16U) {
                    return (-14);
                  }
                  sym = zip->LITERAL_table[(unsigned int )((int )sym << 1) | ((bit_buffer >>
                                                                               i) &
                                                                              1U)];
                  if (! ((int )sym >= 288)) {
                    break;
                  }
                }
              }
              code = (unsigned int )sym;
              i = (unsigned int )zip->LITERAL_len[sym];
              bit_buffer >>= i;
              bits_left = (int )((unsigned int )bits_left - i);
              break;
            }
            if (code < 256U) {
              tmp___17 = window_posn;
              window_posn ++;
              zip->window[tmp___17] = (unsigned char )code;
              if (window_posn == 32768U) {
                tmp___18 = ((*(zip->flush_window)))(zip, 32768U);
                if (tmp___18) {
                  return (-3);
                }
                window_posn = 0U;
              }
            } else {
              if (code == 256U) {
                break;
              } else {
                code -= 257U;
                if (code > 29U) {
                  return (-11);
                }
                while (1) {
                  while (1) {
                    while (bits_left < (int )lit_extrabits[code]) {
                      if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                        tmp___19 = zipd_read_input(zip);
                        if (tmp___19) {
                          return (zip->error);
                        }
                        i_ptr = zip->i_ptr;
                        i_end = zip->i_end;
                      }
                      tmp___20 = i_ptr;
                      i_ptr ++;
                      bit_buffer |= (unsigned int )((int )(*tmp___20) << bits_left);
                      bits_left += 8;
                    }
                    break;
                  }
                  length = bit_buffer & (unsigned int )bit_mask[lit_extrabits[code]];
                  bit_buffer >>= (int const   )lit_extrabits[code];
                  bits_left -= (int )lit_extrabits[code];
                  break;
                }
                length += (unsigned int )lit_lengths[code];
                while (1) {
                  while (1) {
                    while (bits_left < 16) {
                      if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                        tmp___21 = zipd_read_input(zip);
                        if (tmp___21) {
                          return (zip->error);
                        }
                        i_ptr = zip->i_ptr;
                        i_end = zip->i_end;
                      }
                      tmp___22 = i_ptr;
                      i_ptr ++;
                      bit_buffer |= (unsigned int )((int )(*tmp___22) << bits_left);
                      bits_left += 8;
                    }
                    break;
                  }
                  sym = zip->DISTANCE_table[bit_buffer & 63U];
                  if ((int )sym >= 32) {
                    i = 5U;
                    while (1) {
                      tmp___23 = i;
                      i ++;
                      if (tmp___23 > 16U) {
                        return (-14);
                      }
                      sym = zip->DISTANCE_table[(unsigned int )((int )sym << 1) |
                                                ((bit_buffer >> i) & 1U)];
                      if (! ((int )sym >= 32)) {
                        break;
                      }
                    }
                  }
                  code = (unsigned int )sym;
                  i = (unsigned int )zip->DISTANCE_len[sym];
                  bit_buffer >>= i;
                  bits_left = (int )((unsigned int )bits_left - i);
                  break;
                }
                if (code > 30U) {
                  return (-12);
                }
                while (1) {
                  while (1) {
                    while (bits_left < (int )dist_extrabits[code]) {
                      if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                        tmp___24 = zipd_read_input(zip);
                        if (tmp___24) {
                          return (zip->error);
                        }
                        i_ptr = zip->i_ptr;
                        i_end = zip->i_end;
                      }
                      tmp___25 = i_ptr;
                      i_ptr ++;
                      bit_buffer |= (unsigned int )((int )(*tmp___25) << bits_left);
                      bits_left += 8;
                    }
                    break;
                  }
                  distance = bit_buffer & (unsigned int )bit_mask[dist_extrabits[code]];
                  bit_buffer >>= (int const   )dist_extrabits[code];
                  bits_left -= (int )dist_extrabits[code];
                  break;
                }
                distance += (unsigned int )dist_offsets[code];
                if (distance > window_posn) {
                  tmp___26 = 32768;
                } else {
                  tmp___26 = 0;
                }
                match_posn = ((unsigned int )tmp___26 + window_posn) - distance;
                if (length < 12U) {
                  while (1) {
                    tmp___30 = length;
                    length --;
                    if (! tmp___30) {
                      break;
                    }
                    tmp___27 = window_posn;
                    window_posn ++;
                    tmp___28 = match_posn;
                    match_posn ++;
                    zip->window[tmp___27] = zip->window[tmp___28];
                    match_posn &= 32767U;
                    if (window_posn == 32768U) {
                      tmp___29 = ((*(zip->flush_window)))(zip, 32768U);
                      if (tmp___29) {
                        return (-3);
                      }
                      window_posn = 0U;
                    }
                  }
                } else {
                  while (1) {
                    this_run = length;
                    if (match_posn + this_run > 32768U) {
                      this_run = 32768U - match_posn;
                    }
                    if (window_posn + this_run > 32768U) {
                      this_run = 32768U - window_posn;
                    }
                    rundest = & zip->window[window_posn];
                    window_posn += this_run;
                    runsrc = & zip->window[match_posn];
                    match_posn += this_run;
                    length -= this_run;
                    while (1) {
                      tmp___33 = this_run;
                      this_run --;
                      if (! tmp___33) {
                        break;
                      }
                      tmp___31 = rundest;
                      rundest ++;
                      tmp___32 = runsrc;
                      runsrc ++;
                      (*tmp___31) = (*tmp___32);
                    }
                    if (window_posn == 32768U) {
                      tmp___34 = ((*(zip->flush_window)))(zip, 32768U);
                      if (tmp___34) {
                        return (-3);
                      }
                      window_posn = 0U;
                    }
                    if (match_posn == 32768U) {
                      match_posn = 0U;
                    }
                    if (! (length > 0U)) {
                      break;
                    }
                  }
                }
              }
            }
          }
          zip->window_posn = window_posn;
        } else {
          return (-1);
        }
      }
    }
    if (! (! last_block)) {
      break;
    }
  }
  if (zip->window_posn) {
    tmp___35 = ((*(zip->flush_window)))(zip, zip->window_posn);
    if (tmp___35) {
      return (-3);
    }
  }
  while (1) {
    zip->i_ptr = i_ptr;
    zip->i_end = i_end;
    zip->bit_buffer = bit_buffer;
    zip->bits_left = (unsigned int )bits_left;
    break;
  }
  return (0);
}
}
static int mszipd_flush_window(struct mszipd_stream *zip , unsigned int data_flushed ) 
{ 

  {
  zip->bytes_output = (int )((unsigned int )zip->bytes_output + data_flushed);
  if (zip->bytes_output > 32768) {
    return (1);
  }
  return (0);
}
}
struct mszipd_stream *mszipd_init(struct mspack_system *system___0 , struct mspack_file *input ,
                                  struct mspack_file *output , int input_buffer_size ,
                                  int repair_mode ) 
{ struct mszipd_stream *zip ;

  {
  if (! system___0) {
    return ((struct mszipd_stream *)((void *)0));
  }
  input_buffer_size = (input_buffer_size + 1) & -2;
  if (! input_buffer_size) {
    return ((struct mszipd_stream *)((void *)0));
  }
  zip = (struct mszipd_stream *)((*(system___0->alloc)))(system___0, sizeof(struct mszipd_stream ));
  if (! zip) {
    return ((struct mszipd_stream *)((void *)0));
  }
  zip->inbuf = (unsigned char *)((*(system___0->alloc)))(system___0, (unsigned int )input_buffer_size);
  if (! zip->inbuf) {
    ((*(system___0->free)))((void *)zip);
    return ((struct mszipd_stream *)((void *)0));
  }
  zip->sys = system___0;
  zip->input = input;
  zip->output = output;
  zip->inbuf_size = (unsigned int )input_buffer_size;
  zip->error = 0;
  zip->repair_mode = repair_mode;
  zip->flush_window = & mszipd_flush_window;
  zip->i_end = zip->inbuf + 0;
  zip->i_ptr = zip->i_end;
  zip->o_end = (unsigned char *)((void *)0);
  zip->o_ptr = zip->o_end;
  zip->bit_buffer = 0U;
  zip->bits_left = 0U;
  return (zip);
}
}
int mszipd_decompress(struct mszipd_stream *zip , off_t out_bytes ) 
{ register unsigned int bit_buffer ;
  register int bits_left ;
  unsigned char *i_ptr ;
  unsigned char *i_end ;
  int i ;
  int state ;
  int error ;
  int tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;

  {
  if (! zip) {
    return (1);
  } else {
    if (out_bytes < 0L) {
      return (1);
    }
  }
  if (zip->error) {
    return (zip->error);
  }
  i = zip->o_end - zip->o_ptr;
  if ((long )i > out_bytes) {
    i = (int )out_bytes;
  }
  if (i) {
    tmp = ((*((zip->sys)->write)))(zip->output, (void *)zip->o_ptr, i);
    if (tmp != i) {
      zip->error = 4;
      return (zip->error);
    }
    zip->o_ptr = zip->o_ptr + i;
    out_bytes -= (long )i;
  }
  if (out_bytes == 0L) {
    return (0);
  }
  while (out_bytes > 0L) {
    while (1) {
      i_ptr = zip->i_ptr;
      i_end = zip->i_end;
      bit_buffer = zip->bit_buffer;
      bits_left = (int )zip->bits_left;
      break;
    }
    i = bits_left & 7;
    bit_buffer >>= i;
    bits_left -= i;
    state = 0;
    while (1) {
      while (1) {
        while (1) {
          while (bits_left < 8) {
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
              tmp___0 = zipd_read_input(zip);
              if (tmp___0) {
                return (zip->error);
              }
              i_ptr = zip->i_ptr;
              i_end = zip->i_end;
            }
            tmp___1 = i_ptr;
            i_ptr ++;
            bit_buffer |= (unsigned int )((int )(*tmp___1) << bits_left);
            bits_left += 8;
          }
          break;
        }
        i = (int )(bit_buffer & 255U);
        bit_buffer >>= 8;
        bits_left -= 8;
        break;
      }
      if (i == 67) {
        state = 1;
      } else {
        if (state == 1) {
          if (i == 75) {
            state = 2;
          } else {
            state = 0;
          }
        } else {
          state = 0;
        }
      }
      if (! (state != 2)) {
        break;
      }
    }
    zip->window_posn = 0U;
    zip->bytes_output = 0;
    while (1) {
      zip->i_ptr = i_ptr;
      zip->i_end = i_end;
      zip->bit_buffer = bit_buffer;
      zip->bits_left = (unsigned int )bits_left;
      break;
    }
    error = inflate___0(zip);
    if (error) {
      if (zip->repair_mode) {
        ((*((zip->sys)->message)))((struct mspack_file *)((void *)0), (char *)"MSZIP error, %u bytes of data lost.",
                                   32768 - zip->bytes_output);
        i = zip->bytes_output;
        while (i < 32768) {
          zip->window[i] = (unsigned char )'\000';
          i ++;
        }
        zip->bytes_output = 32768;
      } else {
        if (error > 0) {
          zip->error = error;
        } else {
          zip->error = 11;
        }
        return (zip->error);
      }
    }
    zip->o_ptr = & zip->window[0];
    zip->o_end = zip->o_ptr + zip->bytes_output;
    if (out_bytes < (long )zip->bytes_output) {
      i = (int )out_bytes;
    } else {
      i = zip->bytes_output;
    }
    tmp___2 = ((*((zip->sys)->write)))(zip->output, (void *)zip->o_ptr, i);
    if (tmp___2 != i) {
      zip->error = 4;
      return (zip->error);
    }
    if (error > 0) {
      if (zip->repair_mode) {
        return (error);
      }
    }
    zip->o_ptr = zip->o_ptr + i;
    out_bytes -= (long )i;
  }
  if (out_bytes) {
    zip->error = 11;
    return (zip->error);
  }
  return (0);
}
}
void mszipd_free(struct mszipd_stream *zip ) 
{ struct mspack_system *sys ;

  {
  if (zip) {
    sys = zip->sys;
    ((*(sys->free)))((void *)zip->inbuf);
    ((*(sys->free)))((void *)zip);
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-TXJ8mQKq.i","-g -O2 -fPIC")
static int qtmd_read_input(struct qtmd_stream *qtm ) 
{ int read___0 ;
  int tmp ;

  {
  tmp = ((*((qtm->sys)->read)))(qtm->input, (void *)(qtm->inbuf + 0), (int )qtm->inbuf_size);
  read___0 = tmp;
  if (read___0 < 0) {
    qtm->error = 3;
    return (qtm->error);
  }
  qtm->i_ptr = qtm->inbuf + 0;
  qtm->i_end = qtm->inbuf + read___0;
  return (0);
}
}
static unsigned int position_base___0[42]  ;
static unsigned char extra_bits___0[42]  ;
static unsigned char length_base[27]  ;
static unsigned char length_extra[27]  ;
static void qtmd_static_init(void) 
{ unsigned int i ;
  unsigned int offset ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  i = 0U;
  offset = 0U;
  while (i < 42U) {
    position_base___0[i] = offset;
    if (i < 2U) {
      tmp = 0U;
    } else {
      tmp = i - 2U;
    }
    extra_bits___0[i] = (unsigned char )(tmp >> 1);
    offset += (unsigned int )(1 << (int )extra_bits___0[i]);
    i ++;
  }
  i = 0U;
  offset = 0U;
  while (i < 26U) {
    length_base[i] = (unsigned char )offset;
    if (i < 2U) {
      tmp___0 = 0U;
    } else {
      tmp___0 = i - 2U;
    }
    length_extra[i] = (unsigned char )(tmp___0 >> 2);
    offset += (unsigned int )(1 << (int )length_extra[i]);
    i ++;
  }
  length_base[26] = (unsigned char)254;
  length_extra[26] = (unsigned char)0;
  return;
}
}
static void qtmd_update_model(struct qtmd_model *model ) 
{ struct qtmd_modelsym tmp ;
  int i ;
  int j ;

  {
  model->shiftsleft = model->shiftsleft - 1;
  if (model->shiftsleft) {
    i = model->entries - 1;
    while (i >= 0) {
      (model->syms + i)->cumfreq = (unsigned short )((int )(model->syms + i)->cumfreq >>
                                                     1);
      if ((int )(model->syms + i)->cumfreq <= (int )(model->syms + (i + 1))->cumfreq) {
        (model->syms + i)->cumfreq = (unsigned short )((int )(model->syms + (i + 1))->cumfreq +
                                                       1);
      }
      i --;
    }
  } else {
    model->shiftsleft = 50;
    i = 0;
    while (i < model->entries) {
      (model->syms + i)->cumfreq = (unsigned short )((int )(model->syms + i)->cumfreq -
                                                     (int )(model->syms + (i + 1))->cumfreq);
      (model->syms + i)->cumfreq = (unsigned short )((int )(model->syms + i)->cumfreq +
                                                     1);
      (model->syms + i)->cumfreq = (unsigned short )((int )(model->syms + i)->cumfreq >>
                                                     1);
      i ++;
    }
    i = 0;
    while (i < model->entries - 1) {
      j = i + 1;
      while (j < model->entries) {
        if ((int )(model->syms + i)->cumfreq < (int )(model->syms + j)->cumfreq) {
          tmp = (*(model->syms + i));
          (*(model->syms + i)) = (*(model->syms + j));
          (*(model->syms + j)) = tmp;
        }
        j ++;
      }
      i ++;
    }
    i = model->entries - 1;
    while (i >= 0) {
      (model->syms + i)->cumfreq = (unsigned short )((int )(model->syms + i)->cumfreq +
                                                     (int )(model->syms + (i + 1))->cumfreq);
      i --;
    }
  }
  return;
}
}
static void qtmd_init_model(struct qtmd_model *model , struct qtmd_modelsym *syms ,
                            int start , int len ) 
{ int i ;

  {
  model->shiftsleft = 4;
  model->entries = len;
  model->syms = syms;
  i = 0;
  while (i <= len) {
    (syms + i)->sym = (unsigned short )(start + i);
    (syms + i)->cumfreq = (unsigned short )(len - i);
    i ++;
  }
  return;
}
}
struct qtmd_stream *qtmd_init(struct mspack_system *system___0 , struct mspack_file *input ,
                              struct mspack_file *output , int window_bits , int input_buffer_size ) 
{ unsigned int window_size ;
  struct qtmd_stream *qtm ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  window_size = (unsigned int )(1 << window_bits);
  if (! system___0) {
    return ((struct qtmd_stream *)((void *)0));
  }
  if (window_bits < 10) {
    return ((struct qtmd_stream *)((void *)0));
  } else {
    if (window_bits > 21) {
      return ((struct qtmd_stream *)((void *)0));
    }
  }
  input_buffer_size = (input_buffer_size + 1) & -2;
  if (input_buffer_size < 2) {
    return ((struct qtmd_stream *)((void *)0));
  }
  qtmd_static_init();
  qtm = (struct qtmd_stream *)((*(system___0->alloc)))(system___0, sizeof(struct qtmd_stream ));
  if (! qtm) {
    return ((struct qtmd_stream *)((void *)0));
  }
  qtm->window = (unsigned char *)((*(system___0->alloc)))(system___0, window_size);
  qtm->inbuf = (unsigned char *)((*(system___0->alloc)))(system___0, (unsigned int )input_buffer_size);
  if (! qtm->window) {
    ((*(system___0->free)))((void *)qtm->window);
    ((*(system___0->free)))((void *)qtm->inbuf);
    ((*(system___0->free)))((void *)qtm);
    return ((struct qtmd_stream *)((void *)0));
  } else {
    if (! qtm->inbuf) {
      ((*(system___0->free)))((void *)qtm->window);
      ((*(system___0->free)))((void *)qtm->inbuf);
      ((*(system___0->free)))((void *)qtm);
      return ((struct qtmd_stream *)((void *)0));
    }
  }
  qtm->sys = system___0;
  qtm->input = input;
  qtm->output = output;
  qtm->inbuf_size = (unsigned int )input_buffer_size;
  qtm->window_size = window_size;
  qtm->window_posn = 0U;
  qtm->frame_start = 0U;
  qtm->header_read = (unsigned char)0;
  qtm->error = 0;
  qtm->i_end = qtm->inbuf + 0;
  qtm->i_ptr = qtm->i_end;
  qtm->o_end = qtm->window + 0;
  qtm->o_ptr = qtm->o_end;
  qtm->bits_left = (unsigned char)0;
  qtm->bit_buffer = 0U;
  i = window_bits * 2;
  qtmd_init_model(& qtm->model0, & qtm->m0sym[0], 0, 64);
  qtmd_init_model(& qtm->model1, & qtm->m1sym[0], 64, 64);
  qtmd_init_model(& qtm->model2, & qtm->m2sym[0], 128, 64);
  qtmd_init_model(& qtm->model3, & qtm->m3sym[0], 192, 64);
  if (i > 24) {
    tmp = 24;
  } else {
    tmp = i;
  }
  qtmd_init_model(& qtm->model4, & qtm->m4sym[0], 0, tmp);
  if (i > 36) {
    tmp___0 = 36;
  } else {
    tmp___0 = i;
  }
  qtmd_init_model(& qtm->model5, & qtm->m5sym[0], 0, tmp___0);
  qtmd_init_model(& qtm->model6, & qtm->m6sym[0], 0, i);
  qtmd_init_model(& qtm->model6len, & qtm->m6lsym[0], 0, 27);
  qtmd_init_model(& qtm->model7, & qtm->m7sym[0], 0, 7);
  return (qtm);
}
}
int qtmd_decompress(struct qtmd_stream *qtm , off_t out_bytes ) 
{ unsigned int frame_start ;
  unsigned int frame_end ;
  unsigned int window_posn ;
  unsigned int match_offset ;
  unsigned int range ;
  unsigned char *window ;
  unsigned char *i_ptr ;
  unsigned char *i_end ;
  unsigned char *runsrc ;
  unsigned char *rundest ;
  int i ;
  int j ;
  int selector ;
  int extra ;
  int sym ;
  int match_length ;
  unsigned short H ;
  unsigned short L ;
  unsigned short C ;
  unsigned short symf ;
  register unsigned int bit_buffer ;
  register unsigned char bits_left ;
  unsigned char bits_needed ;
  unsigned char bit_run ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct qtmd_model *mdl ;
  struct qtmd_model *tmp___4 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  int tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  int tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;

  {
  if (! qtm) {
    return (1);
  } else {
    if (out_bytes < 0L) {
      return (1);
    }
  }
  if (qtm->error) {
    return (qtm->error);
  }
  i = qtm->o_end - qtm->o_ptr;
  if ((long )i > out_bytes) {
    i = (int )out_bytes;
  }
  if (i) {
    tmp = ((*((qtm->sys)->write)))(qtm->output, (void *)qtm->o_ptr, i);
    if (tmp != i) {
      qtm->error = 4;
      return (qtm->error);
    }
    qtm->o_ptr = qtm->o_ptr + i;
    out_bytes -= (long )i;
  }
  if (out_bytes == 0L) {
    return (0);
  }
  while (1) {
    i_ptr = qtm->i_ptr;
    i_end = qtm->i_end;
    bit_buffer = qtm->bit_buffer;
    bits_left = qtm->bits_left;
    break;
  }
  window = qtm->window;
  window_posn = qtm->window_posn;
  frame_start = qtm->frame_start;
  H = qtm->H;
  L = qtm->L;
  C = qtm->C;
  while ((long )(qtm->o_end - qtm->o_ptr) < out_bytes) {
    if (! qtm->header_read) {
      H = (unsigned short)65535;
      L = (unsigned short)0;
      while (1) {
        C = (unsigned short)0;
        bits_needed = (unsigned char)16;
        while ((int )bits_needed > 0) {
          while (1) {
            if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
              if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                tmp___0 = qtmd_read_input(qtm);
                if (tmp___0) {
                  return (qtm->error);
                }
                i_ptr = qtm->i_ptr;
                i_end = qtm->i_end;
              }
              bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                    1))) <<
                                            ((sizeof(unsigned int ) * 8U - 16U) -
                                             (unsigned int )bits_left));
              bits_left = (unsigned char )((int )bits_left + 16);
              i_ptr += 2;
            }
            break;
          }
          if ((int )bits_left < (int )bits_needed) {
            bit_run = bits_left;
          } else {
            bit_run = bits_needed;
          }
          C = (unsigned short )((unsigned int )((int )C << (int )bit_run) | (bit_buffer >>
                                                                             (sizeof(unsigned int ) *
                                                                              8U -
                                                                              (unsigned int )bit_run)));
          bit_buffer <<= (int )bit_run;
          bits_left = (unsigned char )((int )bits_left - (int )bit_run);
          bits_needed = (unsigned char )((int )bits_needed - (int )bit_run);
        }
        break;
      }
      qtm->header_read = (unsigned char)1;
    }
    frame_end = (unsigned int )((unsigned long )window_posn + (unsigned long )(out_bytes -
                                                                               (long )(qtm->o_end -
                                                                                       qtm->o_ptr)));
    if (frame_start + 32768U < frame_end) {
      frame_end = frame_start + 32768U;
    }
    while (window_posn < frame_end) {
      while (1) {
        range = (unsigned int )((((int )H - (int )L) & 65535) + 1);
        symf = (unsigned short )((unsigned int )((((int )C - (int )L) + 1) * (int )(qtm->model7.syms +
                                                                                    0)->cumfreq -
                                                 1) / range & 65535U);
        i = 1;
        while (i < qtm->model7.entries) {
          if ((int )(qtm->model7.syms + i)->cumfreq <= (int )symf) {
            break;
          }
          i ++;
        }
        selector = (int )(qtm->model7.syms + (i - 1))->sym;
        range = (unsigned int )(((int )H - (int )L) + 1);
        symf = (qtm->model7.syms + 0)->cumfreq;
        H = (unsigned short )(((unsigned int )L + ((unsigned int )(qtm->model7.syms +
                                                                   (i - 1))->cumfreq *
                                                   range) / (unsigned int )symf) -
                              1U);
        L = (unsigned short )((unsigned int )L + ((unsigned int )(qtm->model7.syms +
                                                                  i)->cumfreq * range) /
                                                 (unsigned int )symf);
        while (1) {
          i --;
          (qtm->model7.syms + i)->cumfreq = (unsigned short )((int )(qtm->model7.syms +
                                                                     i)->cumfreq +
                                                              8);
          if (! (i > 0)) {
            break;
          }
        }
        if ((int )(qtm->model7.syms + 0)->cumfreq > 3800) {
          qtmd_update_model(& qtm->model7);
        }
        while (1) {
          if (((int )L & 32768) != ((int )H & 32768)) {
            if ((int )L & 16384) {
              if (! ((int )H & 16384)) {
                C = (unsigned short )((int )C ^ 16384);
                L = (unsigned short )((int )L & 16383);
                H = (unsigned short )((int )H | 16384);
              } else {
                break;
              }
            } else {
              break;
            }
          }
          L = (unsigned short )((int )L << 1);
          H = (unsigned short )(((int )H << 1) | 1);
          while (1) {
            if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
              if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                tmp___1 = qtmd_read_input(qtm);
                if (tmp___1) {
                  return (qtm->error);
                }
                i_ptr = qtm->i_ptr;
                i_end = qtm->i_end;
              }
              bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                    1))) <<
                                            ((sizeof(unsigned int ) * 8U - 16U) -
                                             (unsigned int )bits_left));
              bits_left = (unsigned char )((int )bits_left + 16);
              i_ptr += 2;
            }
            break;
          }
          C = (unsigned short )((unsigned int )((int )C << 1) | (bit_buffer >> (sizeof(unsigned int ) *
                                                                                8U -
                                                                                1U)));
          bit_buffer <<= 1;
          bits_left = (unsigned char )((int )bits_left - 1);
        }
        break;
      }
      if (selector < 4) {
        if (selector == 0) {
          tmp___4 = & qtm->model0;
        } else {
          if (selector == 1) {
            tmp___4 = & qtm->model1;
          } else {
            if (selector == 2) {
              tmp___4 = & qtm->model2;
            } else {
              tmp___4 = & qtm->model3;
            }
          }
        }
        mdl = tmp___4;
        while (1) {
          range = (unsigned int )((((int )H - (int )L) & 65535) + 1);
          symf = (unsigned short )((unsigned int )((((int )C - (int )L) + 1) * (int )(mdl->syms +
                                                                                      0)->cumfreq -
                                                   1) / range & 65535U);
          i = 1;
          while (i < mdl->entries) {
            if ((int )(mdl->syms + i)->cumfreq <= (int )symf) {
              break;
            }
            i ++;
          }
          sym = (int )(mdl->syms + (i - 1))->sym;
          range = (unsigned int )(((int )H - (int )L) + 1);
          symf = (mdl->syms + 0)->cumfreq;
          H = (unsigned short )(((unsigned int )L + ((unsigned int )(mdl->syms + (i -
                                                                                  1))->cumfreq *
                                                     range) / (unsigned int )symf) -
                                1U);
          L = (unsigned short )((unsigned int )L + ((unsigned int )(mdl->syms + i)->cumfreq *
                                                    range) / (unsigned int )symf);
          while (1) {
            i --;
            (mdl->syms + i)->cumfreq = (unsigned short )((int )(mdl->syms + i)->cumfreq +
                                                         8);
            if (! (i > 0)) {
              break;
            }
          }
          if ((int )(mdl->syms + 0)->cumfreq > 3800) {
            qtmd_update_model(mdl);
          }
          while (1) {
            if (((int )L & 32768) != ((int )H & 32768)) {
              if ((int )L & 16384) {
                if (! ((int )H & 16384)) {
                  C = (unsigned short )((int )C ^ 16384);
                  L = (unsigned short )((int )L & 16383);
                  H = (unsigned short )((int )H | 16384);
                } else {
                  break;
                }
              } else {
                break;
              }
            }
            L = (unsigned short )((int )L << 1);
            H = (unsigned short )(((int )H << 1) | 1);
            while (1) {
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                  tmp___6 = qtmd_read_input(qtm);
                  if (tmp___6) {
                    return (qtm->error);
                  }
                  i_ptr = qtm->i_ptr;
                  i_end = qtm->i_end;
                }
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
                bits_left = (unsigned char )((int )bits_left + 16);
                i_ptr += 2;
              }
              break;
            }
            C = (unsigned short )((unsigned int )((int )C << 1) | (bit_buffer >> (sizeof(unsigned int ) *
                                                                                  8U -
                                                                                  1U)));
            bit_buffer <<= 1;
            bits_left = (unsigned char )((int )bits_left - 1);
          }
          break;
        }
        tmp___7 = window_posn;
        window_posn ++;
        (*(window + tmp___7)) = (unsigned char )sym;
      } else {
        switch (selector) {
        case 4: ;
        while (1) {
          range = (unsigned int )((((int )H - (int )L) & 65535) + 1);
          symf = (unsigned short )((unsigned int )((((int )C - (int )L) + 1) * (int )(qtm->model4.syms +
                                                                                      0)->cumfreq -
                                                   1) / range & 65535U);
          i = 1;
          while (i < qtm->model4.entries) {
            if ((int )(qtm->model4.syms + i)->cumfreq <= (int )symf) {
              break;
            }
            i ++;
          }
          sym = (int )(qtm->model4.syms + (i - 1))->sym;
          range = (unsigned int )(((int )H - (int )L) + 1);
          symf = (qtm->model4.syms + 0)->cumfreq;
          H = (unsigned short )(((unsigned int )L + ((unsigned int )(qtm->model4.syms +
                                                                     (i - 1))->cumfreq *
                                                     range) / (unsigned int )symf) -
                                1U);
          L = (unsigned short )((unsigned int )L + ((unsigned int )(qtm->model4.syms +
                                                                    i)->cumfreq *
                                                    range) / (unsigned int )symf);
          while (1) {
            i --;
            (qtm->model4.syms + i)->cumfreq = (unsigned short )((int )(qtm->model4.syms +
                                                                       i)->cumfreq +
                                                                8);
            if (! (i > 0)) {
              break;
            }
          }
          if ((int )(qtm->model4.syms + 0)->cumfreq > 3800) {
            qtmd_update_model(& qtm->model4);
          }
          while (1) {
            if (((int )L & 32768) != ((int )H & 32768)) {
              if ((int )L & 16384) {
                if (! ((int )H & 16384)) {
                  C = (unsigned short )((int )C ^ 16384);
                  L = (unsigned short )((int )L & 16383);
                  H = (unsigned short )((int )H | 16384);
                } else {
                  break;
                }
              } else {
                break;
              }
            }
            L = (unsigned short )((int )L << 1);
            H = (unsigned short )(((int )H << 1) | 1);
            while (1) {
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                  tmp___8 = qtmd_read_input(qtm);
                  if (tmp___8) {
                    return (qtm->error);
                  }
                  i_ptr = qtm->i_ptr;
                  i_end = qtm->i_end;
                }
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
                bits_left = (unsigned char )((int )bits_left + 16);
                i_ptr += 2;
              }
              break;
            }
            C = (unsigned short )((unsigned int )((int )C << 1) | (bit_buffer >> (sizeof(unsigned int ) *
                                                                                  8U -
                                                                                  1U)));
            bit_buffer <<= 1;
            bits_left = (unsigned char )((int )bits_left - 1);
          }
          break;
        }
        while (1) {
          extra = 0;
          bits_needed = extra_bits___0[sym];
          while ((int )bits_needed > 0) {
            while (1) {
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                  tmp___9 = qtmd_read_input(qtm);
                  if (tmp___9) {
                    return (qtm->error);
                  }
                  i_ptr = qtm->i_ptr;
                  i_end = qtm->i_end;
                }
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
                bits_left = (unsigned char )((int )bits_left + 16);
                i_ptr += 2;
              }
              break;
            }
            if ((int )bits_left < (int )bits_needed) {
              bit_run = bits_left;
            } else {
              bit_run = bits_needed;
            }
            extra = (int )((unsigned int )(extra << (int )bit_run) | (bit_buffer >>
                                                                      (sizeof(unsigned int ) *
                                                                       8U - (unsigned int )bit_run)));
            bit_buffer <<= (int )bit_run;
            bits_left = (unsigned char )((int )bits_left - (int )bit_run);
            bits_needed = (unsigned char )((int )bits_needed - (int )bit_run);
          }
          break;
        }
        match_offset = (position_base___0[sym] + (unsigned int )extra) + 1U;
        match_length = 3;
        break;
        case 5: ;
        while (1) {
          range = (unsigned int )((((int )H - (int )L) & 65535) + 1);
          symf = (unsigned short )((unsigned int )((((int )C - (int )L) + 1) * (int )(qtm->model5.syms +
                                                                                      0)->cumfreq -
                                                   1) / range & 65535U);
          i = 1;
          while (i < qtm->model5.entries) {
            if ((int )(qtm->model5.syms + i)->cumfreq <= (int )symf) {
              break;
            }
            i ++;
          }
          sym = (int )(qtm->model5.syms + (i - 1))->sym;
          range = (unsigned int )(((int )H - (int )L) + 1);
          symf = (qtm->model5.syms + 0)->cumfreq;
          H = (unsigned short )(((unsigned int )L + ((unsigned int )(qtm->model5.syms +
                                                                     (i - 1))->cumfreq *
                                                     range) / (unsigned int )symf) -
                                1U);
          L = (unsigned short )((unsigned int )L + ((unsigned int )(qtm->model5.syms +
                                                                    i)->cumfreq *
                                                    range) / (unsigned int )symf);
          while (1) {
            i --;
            (qtm->model5.syms + i)->cumfreq = (unsigned short )((int )(qtm->model5.syms +
                                                                       i)->cumfreq +
                                                                8);
            if (! (i > 0)) {
              break;
            }
          }
          if ((int )(qtm->model5.syms + 0)->cumfreq > 3800) {
            qtmd_update_model(& qtm->model5);
          }
          while (1) {
            if (((int )L & 32768) != ((int )H & 32768)) {
              if ((int )L & 16384) {
                if (! ((int )H & 16384)) {
                  C = (unsigned short )((int )C ^ 16384);
                  L = (unsigned short )((int )L & 16383);
                  H = (unsigned short )((int )H | 16384);
                } else {
                  break;
                }
              } else {
                break;
              }
            }
            L = (unsigned short )((int )L << 1);
            H = (unsigned short )(((int )H << 1) | 1);
            while (1) {
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                  tmp___10 = qtmd_read_input(qtm);
                  if (tmp___10) {
                    return (qtm->error);
                  }
                  i_ptr = qtm->i_ptr;
                  i_end = qtm->i_end;
                }
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
                bits_left = (unsigned char )((int )bits_left + 16);
                i_ptr += 2;
              }
              break;
            }
            C = (unsigned short )((unsigned int )((int )C << 1) | (bit_buffer >> (sizeof(unsigned int ) *
                                                                                  8U -
                                                                                  1U)));
            bit_buffer <<= 1;
            bits_left = (unsigned char )((int )bits_left - 1);
          }
          break;
        }
        while (1) {
          extra = 0;
          bits_needed = extra_bits___0[sym];
          while ((int )bits_needed > 0) {
            while (1) {
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                  tmp___11 = qtmd_read_input(qtm);
                  if (tmp___11) {
                    return (qtm->error);
                  }
                  i_ptr = qtm->i_ptr;
                  i_end = qtm->i_end;
                }
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
                bits_left = (unsigned char )((int )bits_left + 16);
                i_ptr += 2;
              }
              break;
            }
            if ((int )bits_left < (int )bits_needed) {
              bit_run = bits_left;
            } else {
              bit_run = bits_needed;
            }
            extra = (int )((unsigned int )(extra << (int )bit_run) | (bit_buffer >>
                                                                      (sizeof(unsigned int ) *
                                                                       8U - (unsigned int )bit_run)));
            bit_buffer <<= (int )bit_run;
            bits_left = (unsigned char )((int )bits_left - (int )bit_run);
            bits_needed = (unsigned char )((int )bits_needed - (int )bit_run);
          }
          break;
        }
        match_offset = (position_base___0[sym] + (unsigned int )extra) + 1U;
        match_length = 4;
        break;
        case 6: ;
        while (1) {
          range = (unsigned int )((((int )H - (int )L) & 65535) + 1);
          symf = (unsigned short )((unsigned int )((((int )C - (int )L) + 1) * (int )(qtm->model6len.syms +
                                                                                      0)->cumfreq -
                                                   1) / range & 65535U);
          i = 1;
          while (i < qtm->model6len.entries) {
            if ((int )(qtm->model6len.syms + i)->cumfreq <= (int )symf) {
              break;
            }
            i ++;
          }
          sym = (int )(qtm->model6len.syms + (i - 1))->sym;
          range = (unsigned int )(((int )H - (int )L) + 1);
          symf = (qtm->model6len.syms + 0)->cumfreq;
          H = (unsigned short )(((unsigned int )L + ((unsigned int )(qtm->model6len.syms +
                                                                     (i - 1))->cumfreq *
                                                     range) / (unsigned int )symf) -
                                1U);
          L = (unsigned short )((unsigned int )L + ((unsigned int )(qtm->model6len.syms +
                                                                    i)->cumfreq *
                                                    range) / (unsigned int )symf);
          while (1) {
            i --;
            (qtm->model6len.syms + i)->cumfreq = (unsigned short )((int )(qtm->model6len.syms +
                                                                          i)->cumfreq +
                                                                   8);
            if (! (i > 0)) {
              break;
            }
          }
          if ((int )(qtm->model6len.syms + 0)->cumfreq > 3800) {
            qtmd_update_model(& qtm->model6len);
          }
          while (1) {
            if (((int )L & 32768) != ((int )H & 32768)) {
              if ((int )L & 16384) {
                if (! ((int )H & 16384)) {
                  C = (unsigned short )((int )C ^ 16384);
                  L = (unsigned short )((int )L & 16383);
                  H = (unsigned short )((int )H | 16384);
                } else {
                  break;
                }
              } else {
                break;
              }
            }
            L = (unsigned short )((int )L << 1);
            H = (unsigned short )(((int )H << 1) | 1);
            while (1) {
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                  tmp___12 = qtmd_read_input(qtm);
                  if (tmp___12) {
                    return (qtm->error);
                  }
                  i_ptr = qtm->i_ptr;
                  i_end = qtm->i_end;
                }
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
                bits_left = (unsigned char )((int )bits_left + 16);
                i_ptr += 2;
              }
              break;
            }
            C = (unsigned short )((unsigned int )((int )C << 1) | (bit_buffer >> (sizeof(unsigned int ) *
                                                                                  8U -
                                                                                  1U)));
            bit_buffer <<= 1;
            bits_left = (unsigned char )((int )bits_left - 1);
          }
          break;
        }
        while (1) {
          extra = 0;
          bits_needed = length_extra[sym];
          while ((int )bits_needed > 0) {
            while (1) {
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                  tmp___13 = qtmd_read_input(qtm);
                  if (tmp___13) {
                    return (qtm->error);
                  }
                  i_ptr = qtm->i_ptr;
                  i_end = qtm->i_end;
                }
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
                bits_left = (unsigned char )((int )bits_left + 16);
                i_ptr += 2;
              }
              break;
            }
            if ((int )bits_left < (int )bits_needed) {
              bit_run = bits_left;
            } else {
              bit_run = bits_needed;
            }
            extra = (int )((unsigned int )(extra << (int )bit_run) | (bit_buffer >>
                                                                      (sizeof(unsigned int ) *
                                                                       8U - (unsigned int )bit_run)));
            bit_buffer <<= (int )bit_run;
            bits_left = (unsigned char )((int )bits_left - (int )bit_run);
            bits_needed = (unsigned char )((int )bits_needed - (int )bit_run);
          }
          break;
        }
        match_length = ((int )length_base[sym] + extra) + 5;
        while (1) {
          range = (unsigned int )((((int )H - (int )L) & 65535) + 1);
          symf = (unsigned short )((unsigned int )((((int )C - (int )L) + 1) * (int )(qtm->model6.syms +
                                                                                      0)->cumfreq -
                                                   1) / range & 65535U);
          i = 1;
          while (i < qtm->model6.entries) {
            if ((int )(qtm->model6.syms + i)->cumfreq <= (int )symf) {
              break;
            }
            i ++;
          }
          sym = (int )(qtm->model6.syms + (i - 1))->sym;
          range = (unsigned int )(((int )H - (int )L) + 1);
          symf = (qtm->model6.syms + 0)->cumfreq;
          H = (unsigned short )(((unsigned int )L + ((unsigned int )(qtm->model6.syms +
                                                                     (i - 1))->cumfreq *
                                                     range) / (unsigned int )symf) -
                                1U);
          L = (unsigned short )((unsigned int )L + ((unsigned int )(qtm->model6.syms +
                                                                    i)->cumfreq *
                                                    range) / (unsigned int )symf);
          while (1) {
            i --;
            (qtm->model6.syms + i)->cumfreq = (unsigned short )((int )(qtm->model6.syms +
                                                                       i)->cumfreq +
                                                                8);
            if (! (i > 0)) {
              break;
            }
          }
          if ((int )(qtm->model6.syms + 0)->cumfreq > 3800) {
            qtmd_update_model(& qtm->model6);
          }
          while (1) {
            if (((int )L & 32768) != ((int )H & 32768)) {
              if ((int )L & 16384) {
                if (! ((int )H & 16384)) {
                  C = (unsigned short )((int )C ^ 16384);
                  L = (unsigned short )((int )L & 16383);
                  H = (unsigned short )((int )H | 16384);
                } else {
                  break;
                }
              } else {
                break;
              }
            }
            L = (unsigned short )((int )L << 1);
            H = (unsigned short )(((int )H << 1) | 1);
            while (1) {
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                  tmp___14 = qtmd_read_input(qtm);
                  if (tmp___14) {
                    return (qtm->error);
                  }
                  i_ptr = qtm->i_ptr;
                  i_end = qtm->i_end;
                }
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
                bits_left = (unsigned char )((int )bits_left + 16);
                i_ptr += 2;
              }
              break;
            }
            C = (unsigned short )((unsigned int )((int )C << 1) | (bit_buffer >> (sizeof(unsigned int ) *
                                                                                  8U -
                                                                                  1U)));
            bit_buffer <<= 1;
            bits_left = (unsigned char )((int )bits_left - 1);
          }
          break;
        }
        while (1) {
          extra = 0;
          bits_needed = extra_bits___0[sym];
          while ((int )bits_needed > 0) {
            while (1) {
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                  tmp___15 = qtmd_read_input(qtm);
                  if (tmp___15) {
                    return (qtm->error);
                  }
                  i_ptr = qtm->i_ptr;
                  i_end = qtm->i_end;
                }
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
                bits_left = (unsigned char )((int )bits_left + 16);
                i_ptr += 2;
              }
              break;
            }
            if ((int )bits_left < (int )bits_needed) {
              bit_run = bits_left;
            } else {
              bit_run = bits_needed;
            }
            extra = (int )((unsigned int )(extra << (int )bit_run) | (bit_buffer >>
                                                                      (sizeof(unsigned int ) *
                                                                       8U - (unsigned int )bit_run)));
            bit_buffer <<= (int )bit_run;
            bits_left = (unsigned char )((int )bits_left - (int )bit_run);
            bits_needed = (unsigned char )((int )bits_needed - (int )bit_run);
          }
          break;
        }
        match_offset = (position_base___0[sym] + (unsigned int )extra) + 1U;
        break;
        default: 
        qtm->error = 11;
        return (qtm->error);
        }
        rundest = window + window_posn;
        i = match_length;
        if (match_offset > window_posn) {
          j = (int )(match_offset - window_posn);
          if (j > (int )qtm->window_size) {
            qtm->error = 11;
            return (qtm->error);
          }
          runsrc = window + (qtm->window_size - (unsigned int )j);
          if (j < i) {
            i -= j;
            while (1) {
              tmp___18 = j;
              j --;
              if (! (tmp___18 > 0)) {
                break;
              }
              tmp___16 = rundest;
              rundest ++;
              tmp___17 = runsrc;
              runsrc ++;
              (*tmp___16) = (*tmp___17);
            }
            runsrc = window;
          }
          while (1) {
            tmp___21 = i;
            i --;
            if (! (tmp___21 > 0)) {
              break;
            }
            tmp___19 = rundest;
            rundest ++;
            tmp___20 = runsrc;
            runsrc ++;
            (*tmp___19) = (*tmp___20);
          }
        } else {
          runsrc = rundest - match_offset;
          while (1) {
            tmp___24 = i;
            i --;
            if (! (tmp___24 > 0)) {
              break;
            }
            tmp___22 = rundest;
            rundest ++;
            tmp___23 = runsrc;
            runsrc ++;
            (*tmp___22) = (*tmp___23);
          }
        }
        window_posn += (unsigned int )match_length;
      }
    }
    qtm->o_end = window + window_posn;
    if (window_posn - frame_start >= 32768U) {
      if (window_posn - frame_start != 32768U) {
        qtm->error = 11;
        return (qtm->error);
      }
      if ((int )bits_left & 7) {
        bit_buffer <<= (int )bits_left & 7;
        bits_left = (unsigned char )((int )bits_left - ((int )bits_left & 7));
      }
      while (1) {
        while (1) {
          i = 0;
          bits_needed = (unsigned char)8;
          while ((int )bits_needed > 0) {
            while (1) {
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
                  tmp___25 = qtmd_read_input(qtm);
                  if (tmp___25) {
                    return (qtm->error);
                  }
                  i_ptr = qtm->i_ptr;
                  i_end = qtm->i_end;
                }
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
                bits_left = (unsigned char )((int )bits_left + 16);
                i_ptr += 2;
              }
              break;
            }
            if ((int )bits_left < (int )bits_needed) {
              bit_run = bits_left;
            } else {
              bit_run = bits_needed;
            }
            i = (int )((unsigned int )(i << (int )bit_run) | (bit_buffer >> (sizeof(unsigned int ) *
                                                                             8U -
                                                                             (unsigned int )bit_run)));
            bit_buffer <<= (int )bit_run;
            bits_left = (unsigned char )((int )bits_left - (int )bit_run);
            bits_needed = (unsigned char )((int )bits_needed - (int )bit_run);
          }
          break;
        }
        if (! (i != 255)) {
          break;
        }
      }
      qtm->header_read = (unsigned char)0;
      if (window_posn == qtm->window_size) {
        i = qtm->o_end - qtm->o_ptr;
        tmp___26 = ((*((qtm->sys)->write)))(qtm->output, (void *)qtm->o_ptr, i);
        if (tmp___26 != i) {
          qtm->error = 4;
          return (qtm->error);
        }
        out_bytes -= (long )i;
        qtm->o_ptr = window + 0;
        qtm->o_end = window + 0;
        window_posn = 0U;
      }
      frame_start = window_posn;
    }
  }
  if (out_bytes) {
    i = (int )out_bytes;
    tmp___27 = ((*((qtm->sys)->write)))(qtm->output, (void *)qtm->o_ptr, i);
    if (tmp___27 != i) {
      qtm->error = 4;
      return (qtm->error);
    }
    qtm->o_ptr = qtm->o_ptr + i;
  }
  while (1) {
    qtm->i_ptr = i_ptr;
    qtm->i_end = i_end;
    qtm->bit_buffer = bit_buffer;
    qtm->bits_left = bits_left;
    break;
  }
  qtm->window_posn = window_posn;
  qtm->frame_start = frame_start;
  qtm->H = H;
  qtm->L = L;
  qtm->C = C;
  return (0);
}
}
void qtmd_free(struct qtmd_stream *qtm ) 
{ struct mspack_system *sys ;

  {
  if (qtm) {
    sys = qtm->sys;
    ((*(sys->free)))((void *)qtm->window);
    ((*(sys->free)))((void *)qtm->inbuf);
    ((*(sys->free)))((void *)qtm);
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-wx2gl0sH.i","-g -O2 -fPIC")
int mspack_sys_selftest_internal(int offt_size ) ;
int mspack_version(int entity ) ;
int mspack_version(int entity ) 
{ 

  {
  switch (entity) {
  case 0: ;
  case 1: ;
  case 2: ;
  case 4: ;
  return (1);
  case 3: ;
  case 5: ;
  case 6: ;
  case 7: ;
  case 8: ;
  case 9: ;
  case 10: ;
  case 11: ;
  case 12: ;
  case 13: ;
  return (0);
  }
  return (-1);
}
}
int mspack_sys_selftest_internal(int offt_size ) 
{ int tmp ;

  {
  if (sizeof(off_t ) == (unsigned int )offt_size) {
    tmp = 0;
  } else {
    tmp = 5;
  }
  return (tmp);
}
}
int mspack_valid_system(struct mspack_system *sys ) 
{ int tmp ;

  {
  if ((unsigned int )sys != (unsigned int )((void *)0)) {
    if ((unsigned int )sys->open != (unsigned int )((void *)0)) {
      if ((unsigned int )sys->close != (unsigned int )((void *)0)) {
        if ((unsigned int )sys->read != (unsigned int )((void *)0)) {
          if ((unsigned int )sys->write != (unsigned int )((void *)0)) {
            if ((unsigned int )sys->seek != (unsigned int )((void *)0)) {
              if ((unsigned int )sys->tell != (unsigned int )((void *)0)) {
                if ((unsigned int )sys->message != (unsigned int )((void *)0)) {
                  if ((unsigned int )sys->alloc != (unsigned int )((void *)0)) {
                    if ((unsigned int )sys->free != (unsigned int )((void *)0)) {
                      if ((unsigned int )sys->copy != (unsigned int )((void *)0)) {
                        if ((unsigned int )sys->null_ptr == (unsigned int )((void *)0)) {
                          tmp = 1;
                        } else {
                          tmp = 0;
                        }
                      } else {
                        tmp = 0;
                      }
                    } else {
                      tmp = 0;
                    }
                  } else {
                    tmp = 0;
                  }
                } else {
                  tmp = 0;
                }
              } else {
                tmp = 0;
              }
            } else {
              tmp = 0;
            }
          } else {
            tmp = 0;
          }
        } else {
          tmp = 0;
        }
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
int mspack_sys_filelen(struct mspack_system *system___0 , struct mspack_file *file ,
                       off_t *length ) 
{ off_t current ;
  int tmp ;
  int tmp___0 ;

  {
  if (! system___0) {
    return (2);
  } else {
    if (! file) {
      return (2);
    } else {
      if (! length) {
        return (2);
      }
    }
  }
  current = ((*(system___0->tell)))(file);
  tmp = ((*(system___0->seek)))(file, 0L, 2);
  if (tmp) {
    return (5);
  }
  (*length) = ((*(system___0->tell)))(file);
  tmp___0 = ((*(system___0->seek)))(file, current, 0);
  if (tmp___0) {
    return (5);
  }
  return (0);
}
}
static struct mspack_file *msp_open(struct mspack_system *this , char *filename ,
                                    int mode ) 
{ struct mspack_file_p *fh ;
  char *fmode ;

  {
  switch (mode) {
  case 0: 
  fmode = (char *)"rb";
  break;
  case 1: 
  fmode = (char *)"wb";
  break;
  case 2: 
  fmode = (char *)"r+b";
  break;
  case 3: 
  fmode = (char *)"ab";
  break;
  default: ;
  return ((struct mspack_file *)((void *)0));
  }
  fh = (struct mspack_file_p *)malloc(sizeof(struct mspack_file_p ));
  if (fh) {
    fh->name = (char const   *)filename;
    fh->desc = 0;
    fh->fh = fopen((char const   * __restrict  )filename, (char const   * __restrict  )fmode);
    if (fh->fh) {
      return ((struct mspack_file *)fh);
    }
    free((void *)fh);
  }
  return ((struct mspack_file *)((void *)0));
}
}
static struct mspack_file *msp_dopen(struct mspack_system *this , int desc , int mode ) 
{ struct mspack_file_p *fh ;
  char *fmode ;

  {
  switch (mode) {
  case 0: 
  fmode = (char *)"rb";
  break;
  case 1: 
  fmode = (char *)"wb";
  break;
  case 2: 
  fmode = (char *)"r+b";
  break;
  case 3: 
  fmode = (char *)"ab";
  break;
  default: ;
  return ((struct mspack_file *)((void *)0));
  }
  fh = (struct mspack_file_p *)malloc(sizeof(struct mspack_file_p ));
  if (fh) {
    fh->name = "descriptor";
    fh->desc = desc;
    fh->fh = fdopen(desc, (char const   *)fmode);
    if (fh->fh) {
      return ((struct mspack_file *)fh);
    }
    free((void *)fh);
  }
  return ((struct mspack_file *)((void *)0));
}
}
static void msp_close(struct mspack_file *file ) 
{ struct mspack_file_p *this ;

  {
  this = (struct mspack_file_p *)file;
  if (this) {
    fclose(this->fh);
    free((void *)this);
  }
  return;
}
}
static int msp_read(struct mspack_file *file , void *buffer , int bytes ) 
{ struct mspack_file_p *this ;
  size_t count ;
  size_t tmp ;
  int tmp___0 ;

  {
  this = (struct mspack_file_p *)file;
  if (this) {
    tmp = fread((void * __restrict  )buffer, 1U, (unsigned int )bytes, (FILE * __restrict  )this->fh);
    count = tmp;
    tmp___0 = ferror(this->fh);
    if (! tmp___0) {
      return ((int )count);
    }
  }
  return (-1);
}
}
static int msp_write(struct mspack_file *file , void *buffer , int bytes ) 
{ struct mspack_file_p *this ;
  size_t count ;
  size_t tmp ;
  int tmp___0 ;

  {
  this = (struct mspack_file_p *)file;
  if (this) {
    tmp = fwrite((void const   * __restrict  )buffer, 1U, (unsigned int )bytes, (FILE * __restrict  )this->fh);
    count = tmp;
    tmp___0 = ferror(this->fh);
    if (! tmp___0) {
      return ((int )count);
    }
  }
  return (-1);
}
}
static int msp_seek(struct mspack_file *file , off_t offset , int mode ) 
{ struct mspack_file_p *this ;
  int tmp ;

  {
  this = (struct mspack_file_p *)file;
  if (this) {
    switch (mode) {
    case 0: 
    mode = 0;
    break;
    case 1: 
    mode = 1;
    break;
    case 2: 
    mode = 2;
    break;
    default: ;
    return (-1);
    }
    tmp = fseek(this->fh, offset, mode);
    return (tmp);
  }
  return (-1);
}
}
static off_t msp_tell(struct mspack_file *file ) 
{ struct mspack_file_p *this ;
  long tmp___0 ;
  long tmp___1 ;

  {
  this = (struct mspack_file_p *)file;
  if (this) {
    tmp___1 = ftell(this->fh);
    tmp___0 = tmp___1;
  } else {
    tmp___0 = 0L;
  }
  return (tmp___0);
}
}
static void msp_msg(struct mspack_file *file , char *format  , ...) 
{ va_list ap ;
  char buff[512] ;

  {
  __builtin_va_start(ap, format);
  vsnprintf((char * __restrict  )(buff), 512U, (char const   * __restrict  )format,
            ap);
  __builtin_va_end(ap);
  cli_dbgmsg("libmspack: %s\n", buff);
  return;
}
}
static void *msp_alloc(struct mspack_system *this , size_t bytes ) 
{ void *tmp ;

  {
  tmp = cli_calloc(bytes, 1U);
  return (tmp);
}
}
static void msp_free(void *buffer ) 
{ 

  {
  free(buffer);
  return;
}
}
static void msp_copy(void *src , void *dest , size_t bytes ) 
{ 

  {
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, bytes);
  return;
}
}
static struct mspack_system msp_system  = 
     {& msp_open, & msp_dopen, & msp_close, & msp_read, & msp_write, & msp_seek, & msp_tell,
    & msp_msg, & msp_alloc, & msp_free, & msp_copy, (void *)0};
struct mspack_system *mspack_default_system  =    & msp_system;
#pragma merger(0,"/tmp/cil-l3M8Ejrq.i","-g -O2 -fPIC")
int pefromupx(char *src , char *dst , int *dsize , uint32_t ep , uint32_t upx0 , uint32_t upx1 ,
              uint32_t magic ) 
{ char *imports ;
  char *sections ;
  char *pehdr ;
  char *newbuf ;
  int sectcnt ;
  int upd ;
  int realstuffsz ;
  int foffset ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  uint32_t vsize ;
  int32_t tmp___3 ;
  uint32_t rsize ;
  uint32_t tmp___4 ;
  uint32_t urva ;
  uint32_t tmp___5 ;
  int32_t tmp___6 ;
  size_t tmp___8 ;
  int32_t tmp___9 ;
  int32_t tmp___10 ;

  {
  upd = 1;
  foffset = 456;
  if ((unsigned int )dst == (unsigned int )((void *)0)) {
    return (0);
  } else {
    if ((unsigned int )src == (unsigned int )((void *)0)) {
      return (0);
    }
  }
  tmp = cli_readint32((char const   *)(((src + ep) - upx1) + magic));
  imports = dst + tmp;
  realstuffsz = imports - dst;
  if (realstuffsz < 0) {
    cli_dbgmsg("UPX: wrong realstuff size - giving up rebuild\n");
    return (0);
  } else {
    if (realstuffsz > (*dsize)) {
      cli_dbgmsg("UPX: wrong realstuff size - giving up rebuild\n");
      return (0);
    }
  }
  pehdr = imports;
  while (1) {
    if ((unsigned int )(pehdr + 7) < (unsigned int )(dst + (*dsize))) {
      tmp___0 = cli_readint32((char const   *)pehdr);
      if (! tmp___0) {
        break;
      }
    } else {
      break;
    }
    pehdr += 8;
    while (1) {
      if ((unsigned int )(pehdr + 1) < (unsigned int )(dst + (*dsize))) {
        if (! (*pehdr)) {
          break;
        }
      } else {
        break;
      }
      pehdr ++;
      while (1) {
        if ((unsigned int )(pehdr + 1) < (unsigned int )(dst + (*dsize))) {
          if (! (*pehdr)) {
            break;
          }
        } else {
          break;
        }
        pehdr ++;
      }
      pehdr ++;
    }
    pehdr ++;
  }
  pehdr += 4;
  if ((unsigned int )(pehdr + 248) > (unsigned int )(dst + (*dsize))) {
    cli_dbgmsg("UPX: sections out of bounds - giving up rebuild\n");
    return (0);
  }
  tmp___1 = cli_readint32((char const   *)pehdr);
  if (tmp___1 != 17744) {
    cli_dbgmsg("UPX: No magic for PE - giving up rebuild\n");
    return (0);
  }
  tmp___2 = cli_readint32((char const   *)(pehdr + 56));
  if (! tmp___2) {
    cli_dbgmsg("UPX: Cant align to a NULL bound - giving up rebuild\n");
    return (0);
  }
  sections = pehdr + 248;
  sectcnt = (int )(*(pehdr + 6)) + 256 * (int )(*(pehdr + 7));
  if (! sectcnt) {
    cli_dbgmsg("UPX: No sections? - giving up rebuild\n");
    return (0);
  }
  foffset += 40 * sectcnt;
  if ((unsigned int )((pehdr + 248) + 40 * sectcnt) >= (unsigned int )(dst + (*dsize))) {
    cli_dbgmsg("UPX: Not enough space for all sects - giving up rebuild\n");
    return (0);
  }
  upd = 0;
  while (upd < sectcnt) {
    tmp___3 = cli_readint32((char const   *)(sections + 8));
    vsize = (unsigned int )(tmp___3 - 1);
    tmp___4 = (uint32_t )cli_readint32((char const   *)(sections + 16));
    rsize = tmp___4;
    tmp___5 = (uint32_t )cli_readint32((char const   *)(sections + 12));
    urva = tmp___5;
    vsize = (vsize / 4096U + 1U) * 4096U;
    if (urva < upx0) {
      cli_dbgmsg("UPX: Sect %d out of bounds - giving up rebuild\n", upd);
      return (0);
    } else {
      if (urva + vsize > upx0 + (unsigned int )realstuffsz) {
        cli_dbgmsg("UPX: Sect %d out of bounds - giving up rebuild\n", upd);
        return (0);
      }
    }
    if (rsize > vsize) {
      cli_dbgmsg("UPX: Raw size for sect %d is greater than virtual (%x / %x) - giving up rebuild\n",
                 upd, rsize, vsize);
      return (0);
    }
    if (rsize + 4U < vsize) {
      tmp___6 = cli_readint32((char const   *)(((dst + urva) - upx0) + rsize));
      if (tmp___6) {
        cli_dbgmsg("UPX: Am i been fooled? - giving up rebuild\n", upd);
        return (0);
      }
    }
    cli_writeint32(sections + 8, vsize);
    cli_writeint32(sections + 20, (unsigned int )foffset);
    foffset = (int )((unsigned int )foffset + rsize);
    sections += 40;
    upd ++;
  }
  cli_writeint32(pehdr + 8, 1296124995U);
  newbuf = (char *)cli_malloc((unsigned int )foffset);
  if (! newbuf) {
    cli_dbgmsg("UPX: malloc failed - giving up rebuild\n", upd);
    return (0);
  }
  memcpy((void * __restrict  )newbuf, (void const   * __restrict  )"MZ\220\000\002\000\000\000\004\000\017\000\377\377\000\000\260\000\000\000\000\000\000\000@\000\032\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\320\000\000\000\016\037\264\t\272\r\000\315!\264L\315!This file was created by ClamAV for internal use and should not be run.\r\nClamAV - A GPL virus scanner - http://www.clamav.net\r\n$\000\000\000",
         208U);
  memcpy((void * __restrict  )(newbuf + 208), (void const   * __restrict  )pehdr,
         (unsigned int )(248 + 40 * sectcnt));
  sections = pehdr + 248;
  upd = 0;
  while (upd < sectcnt) {
    tmp___8 = (size_t )cli_readint32((char const   *)(sections + 16));
    tmp___9 = cli_readint32((char const   *)(sections + 12));
    tmp___10 = cli_readint32((char const   *)(sections + 20));
    memcpy((void * __restrict  )(newbuf + tmp___10), (void const   * __restrict  )((dst +
                                                                                    tmp___9) -
                                                                                   upx0),
           tmp___8);
    sections += 40;
    upd ++;
  }
  memcpy((void * __restrict  )dst, (void const   * __restrict  )newbuf, (unsigned int )foffset);
  (*dsize) = foffset;
  free((void *)newbuf);
  cli_dbgmsg("UPX: PE structure rebuilt from compressed file\n");
  return (1);
}
}
static int doubleebx(char *src , int32_t *myebx , int *scur , int ssize ) 
{ int32_t oldebx ;
  char *pt ;
  int32_t shift ;
  int32_t i ;

  {
  oldebx = (*myebx);
  i = 0;
  (*myebx) *= 2;
  if (! (oldebx & 2147483647)) {
    if ((*scur) < 0) {
      return (-1);
    } else {
      if (ssize - (*scur) < 4) {
        return (-1);
      }
    }
    oldebx = 0;
    pt = src + (*scur);
    shift = 0;
    while (shift < 32) {
      oldebx |= ((int )(*(pt + i)) & 255) << shift;
      i ++;
      shift += 8;
    }
    (*myebx) = oldebx * 2 + 1;
    (*scur) += 4;
  }
  return ((oldebx >> 31) & 1);
}
}
int upx_inflate2b(char *src , int ssize , char *dst , int *dsize , uint32_t upx0 ,
                  uint32_t upx1 , uint32_t ep ) 
{ int32_t backbytes ;
  int32_t unp_offset ;
  int32_t myebx ;
  int scur ;
  int dcur ;
  int i ;
  int backsize ;
  int oob ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  unp_offset = -1;
  myebx = 0;
  scur = 0;
  dcur = 0;
  while (1) {
    while (1) {
      oob = doubleebx(src, & myebx, & scur, ssize);
      if (! (oob == 1)) {
        break;
      }
      if (scur < 0) {
        return (-1);
      } else {
        if (scur >= ssize) {
          return (-1);
        } else {
          if (dcur < 0) {
            return (-1);
          } else {
            if (dcur >= (*dsize)) {
              return (-1);
            }
          }
        }
      }
      tmp = dcur;
      dcur ++;
      tmp___0 = scur;
      scur ++;
      (*(dst + tmp)) = (*(src + tmp___0));
    }
    if (oob == -1) {
      return (-1);
    }
    backbytes = 1;
    while (1) {
      oob = doubleebx(src, & myebx, & scur, ssize);
      if (oob == -1) {
        return (-1);
      }
      backbytes = backbytes * 2 + oob;
      oob = doubleebx(src, & myebx, & scur, ssize);
      if (oob == -1) {
        return (-1);
      }
      if (oob) {
        break;
      }
    }
    backsize = 0;
    backbytes -= 3;
    if (backbytes >= 0) {
      if (scur < 0) {
        return (-1);
      } else {
        if (scur >= ssize) {
          return (-1);
        }
      }
      backbytes <<= 8;
      tmp___1 = scur;
      scur ++;
      backbytes += (int )((unsigned char )(*(src + tmp___1)));
      backbytes = (int )((unsigned int )backbytes ^ 4294967295U);
      if (! backbytes) {
        break;
      }
      unp_offset = backbytes;
    }
    oob = doubleebx(src, & myebx, & scur, ssize);
    if (oob == -1) {
      return (-1);
    }
    backsize = oob;
    oob = doubleebx(src, & myebx, & scur, ssize);
    if (oob == -1) {
      return (-1);
    }
    backsize = backsize * 2 + oob;
    if (! backsize) {
      backsize ++;
      while (1) {
        oob = doubleebx(src, & myebx, & scur, ssize);
        if (oob == -1) {
          return (-1);
        }
        backsize = backsize * 2 + oob;
        oob = doubleebx(src, & myebx, & scur, ssize);
        if (! (oob == 0)) {
          break;
        }
      }
      if (oob == -1) {
        return (-1);
      }
      backsize += 2;
    }
    if ((unsigned int )unp_offset < 4294963968U) {
      backsize ++;
    }
    backsize ++;
    i = 0;
    while (i < backsize) {
      if (dcur + i < 0) {
        return (-1);
      } else {
        if (dcur + i >= (*dsize)) {
          return (-1);
        } else {
          if ((dcur + unp_offset) + i < 0) {
            return (-1);
          } else {
            if ((dcur + unp_offset) + i >= (*dsize)) {
              return (-1);
            }
          }
        }
      }
      (*(dst + (dcur + i))) = (*(dst + ((dcur + unp_offset) + i)));
      i ++;
    }
    dcur += backsize;
  }
  if ((ep - upx1) + 264U <= (unsigned int )(ssize - 5)) {
    if ((int )(*(src + ((ep - upx1) + 262U))) == -115) {
      if ((int )(*(src + ((ep - upx1) + 263U))) == -66) {
        tmp___2 = pefromupx(src, dst, dsize, ep, upx0, upx1, 264U);
        return (tmp___2);
      }
    }
  }
  cli_dbgmsg("UPX: bad magic for 2b\n");
  return (0);
}
}
int upx_inflate2d(char *src , int ssize , char *dst , int *dsize , uint32_t upx0 ,
                  uint32_t upx1 , uint32_t ep ) 
{ int32_t backbytes ;
  int32_t unp_offset ;
  int32_t myebx ;
  int scur ;
  int dcur ;
  int i ;
  int backsize ;
  int oob ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  unp_offset = -1;
  myebx = 0;
  scur = 0;
  dcur = 0;
  while (1) {
    while (1) {
      oob = doubleebx(src, & myebx, & scur, ssize);
      if (! (oob == 1)) {
        break;
      }
      if (scur < 0) {
        return (-1);
      } else {
        if (scur >= ssize) {
          return (-1);
        } else {
          if (dcur < 0) {
            return (-1);
          } else {
            if (dcur >= (*dsize)) {
              return (-1);
            }
          }
        }
      }
      tmp = dcur;
      dcur ++;
      tmp___0 = scur;
      scur ++;
      (*(dst + tmp)) = (*(src + tmp___0));
    }
    if (oob == -1) {
      return (-1);
    }
    backbytes = 1;
    while (1) {
      oob = doubleebx(src, & myebx, & scur, ssize);
      if (oob == -1) {
        return (-1);
      }
      backbytes = backbytes * 2 + oob;
      oob = doubleebx(src, & myebx, & scur, ssize);
      if (oob == -1) {
        return (-1);
      }
      if (oob) {
        break;
      }
      backbytes --;
      oob = doubleebx(src, & myebx, & scur, ssize);
      if (oob == -1) {
        return (-1);
      }
      backbytes = backbytes * 2 + oob;
    }
    backsize = 0;
    backbytes -= 3;
    if (backbytes >= 0) {
      if (scur < 0) {
        return (-1);
      } else {
        if (scur >= ssize) {
          return (-1);
        }
      }
      backbytes <<= 8;
      tmp___1 = scur;
      scur ++;
      backbytes += (int )((unsigned char )(*(src + tmp___1)));
      backbytes = (int )((unsigned int )backbytes ^ 4294967295U);
      if (! backbytes) {
        break;
      }
      backsize = backbytes & 1;
      backbytes >>= 1;
      unp_offset = backbytes;
    } else {
      backsize = doubleebx(src, & myebx, & scur, ssize);
      if (backsize == -1) {
        return (-1);
      }
    }
    oob = doubleebx(src, & myebx, & scur, ssize);
    if (oob == -1) {
      return (-1);
    }
    backsize = backsize * 2 + oob;
    if (! backsize) {
      backsize ++;
      while (1) {
        oob = doubleebx(src, & myebx, & scur, ssize);
        if (oob == -1) {
          return (-1);
        }
        backsize = backsize * 2 + oob;
        oob = doubleebx(src, & myebx, & scur, ssize);
        if (! (oob == 0)) {
          break;
        }
      }
      if (oob == -1) {
        return (-1);
      }
      backsize += 2;
    }
    if ((unsigned int )unp_offset < 4294966016U) {
      backsize ++;
    }
    backsize ++;
    i = 0;
    while (i < backsize) {
      if (dcur + i < 0) {
        return (-1);
      } else {
        if (dcur + i >= (*dsize)) {
          return (-1);
        } else {
          if ((dcur + unp_offset) + i < 0) {
            return (-1);
          } else {
            if ((dcur + unp_offset) + i >= (*dsize)) {
              return (-1);
            }
          }
        }
      }
      (*(dst + (dcur + i))) = (*(dst + ((dcur + unp_offset) + i)));
      i ++;
    }
    dcur += backsize;
  }
  if ((ep - upx1) + 292U <= (unsigned int )(ssize - 5)) {
    if ((int )(*(src + ((ep - upx1) + 282U))) == -115) {
      if ((int )(*(src + ((ep - upx1) + 283U))) == -66) {
        tmp___2 = pefromupx(src, dst, dsize, ep, upx0, upx1, 284U);
        return (tmp___2);
      }
    }
    if ((int )(*(src + ((ep - upx1) + 290U))) == -115) {
      if ((int )(*(src + ((ep - upx1) + 291U))) == -66) {
        tmp___3 = pefromupx(src, dst, dsize, ep, upx0, upx1, 292U);
        return (tmp___3);
      }
    }
  }
  cli_dbgmsg("UPX: bad magic for 2d\n");
  return (0);
}
}
int upx_inflate2e(char *src , int ssize , char *dst , int *dsize , uint32_t upx0 ,
                  uint32_t upx1 , uint32_t ep ) 
{ int32_t backbytes ;
  int32_t unp_offset ;
  int32_t myebx ;
  int scur ;
  int dcur ;
  int i ;
  int backsize ;
  int oob ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  unp_offset = -1;
  myebx = 0;
  scur = 0;
  dcur = 0;
  while (1) {
    while (1) {
      oob = doubleebx(src, & myebx, & scur, ssize);
      if (! oob) {
        break;
      }
      if (oob == -1) {
        return (-1);
      }
      if (scur < 0) {
        return (-1);
      } else {
        if (scur >= ssize) {
          return (-1);
        } else {
          if (dcur < 0) {
            return (-1);
          } else {
            if (dcur >= (*dsize)) {
              return (-1);
            }
          }
        }
      }
      tmp = dcur;
      dcur ++;
      tmp___0 = scur;
      scur ++;
      (*(dst + tmp)) = (*(src + tmp___0));
    }
    backbytes = 1;
    while (1) {
      oob = doubleebx(src, & myebx, & scur, ssize);
      if (oob == -1) {
        return (-1);
      }
      backbytes = backbytes * 2 + oob;
      oob = doubleebx(src, & myebx, & scur, ssize);
      if (oob == -1) {
        return (-1);
      }
      if (oob) {
        break;
      }
      backbytes --;
      oob = doubleebx(src, & myebx, & scur, ssize);
      if (oob == -1) {
        return (-1);
      }
      backbytes = backbytes * 2 + oob;
    }
    backsize = 0;
    backbytes -= 3;
    if (backbytes >= 0) {
      if (scur < 0) {
        return (-1);
      } else {
        if (scur >= ssize) {
          return (-1);
        }
      }
      backbytes <<= 8;
      tmp___1 = scur;
      scur ++;
      backbytes += (int )((unsigned char )(*(src + tmp___1)));
      backbytes = (int )((unsigned int )backbytes ^ 4294967295U);
      if (! backbytes) {
        break;
      }
      backsize = backbytes & 1;
      backbytes >>= 1;
      unp_offset = backbytes;
    } else {
      backsize = doubleebx(src, & myebx, & scur, ssize);
      if (backsize == -1) {
        return (-1);
      }
    }
    if (backsize) {
      backsize = doubleebx(src, & myebx, & scur, ssize);
      if (backsize == -1) {
        return (-1);
      }
    } else {
      backsize = 1;
      oob = doubleebx(src, & myebx, & scur, ssize);
      if (oob == -1) {
        return (-1);
      }
      if (oob) {
        oob = doubleebx(src, & myebx, & scur, ssize);
        if (oob == -1) {
          return (-1);
        }
        backsize = 2 + oob;
      } else {
        while (1) {
          oob = doubleebx(src, & myebx, & scur, ssize);
          if (oob == -1) {
            return (-1);
          }
          backsize = backsize * 2 + oob;
          oob = doubleebx(src, & myebx, & scur, ssize);
          if (! (oob == 0)) {
            break;
          }
        }
        if (oob == -1) {
          return (-1);
        }
        backsize += 2;
      }
    }
    if ((unsigned int )unp_offset < 4294966016U) {
      backsize ++;
    }
    backsize += 2;
    i = 0;
    while (i < backsize) {
      if (dcur + i < 0) {
        return (-1);
      } else {
        if (dcur + i >= (*dsize)) {
          return (-1);
        } else {
          if ((dcur + unp_offset) + i < 0) {
            return (-1);
          } else {
            if ((dcur + unp_offset) + i >= (*dsize)) {
              return (-1);
            }
          }
        }
      }
      (*(dst + (dcur + i))) = (*(dst + ((dcur + unp_offset) + i)));
      i ++;
    }
    dcur += backsize;
  }
  if ((ep - upx1) + 304U <= (unsigned int )(ssize - 5)) {
    if ((int )(*(src + ((ep - upx1) + 294U))) == -115) {
      if ((int )(*(src + ((ep - upx1) + 295U))) == -66) {
        tmp___2 = pefromupx(src, dst, dsize, ep, upx0, upx1, 296U);
        return (tmp___2);
      }
    }
    if ((int )(*(src + ((ep - upx1) + 302U))) == -115) {
      if ((int )(*(src + ((ep - upx1) + 303U))) == -66) {
        tmp___3 = pefromupx(src, dst, dsize, ep, upx0, upx1, 304U);
        return (tmp___3);
      }
    }
  }
  cli_dbgmsg("UPX: bad magic for 2e\n");
  return (0);
}
}
#pragma merger(0,"/tmp/cil-ZglX7f5I.i","-g -O2 -fPIC")
static int const   base64_chars[256]  = 
  {      (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )62, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )63, 
        (int const   )52,      (int const   )53,      (int const   )54,      (int const   )55, 
        (int const   )56,      (int const   )57,      (int const   )58,      (int const   )59, 
        (int const   )60,      (int const   )61,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )9,      (int const   )10, 
        (int const   )11,      (int const   )12,      (int const   )13,      (int const   )14, 
        (int const   )15,      (int const   )16,      (int const   )17,      (int const   )18, 
        (int const   )19,      (int const   )20,      (int const   )21,      (int const   )22, 
        (int const   )23,      (int const   )24,      (int const   )25,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )26,      (int const   )27,      (int const   )28, 
        (int const   )29,      (int const   )30,      (int const   )31,      (int const   )32, 
        (int const   )33,      (int const   )34,      (int const   )35,      (int const   )36, 
        (int const   )37,      (int const   )38,      (int const   )39,      (int const   )40, 
        (int const   )41,      (int const   )42,      (int const   )43,      (int const   )44, 
        (int const   )45,      (int const   )46,      (int const   )47,      (int const   )48, 
        (int const   )49,      (int const   )50,      (int const   )51,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1};
int table_order[64]  = 
  {      0,      2,      1,      0, 
        2,      1,      2,      1, 
        1,      2,      1,      2, 
        0,      1,      2,      1, 
        0,      1,      2,      1, 
        0,      0,      2,      1, 
        1,      2,      0,      1, 
        2,      1,      1,      2, 
        0,      0,      1,      2, 
        1,      2,      1,      0, 
        1,      0,      0,      2, 
        1,      0,      1,      2, 
        0,      1,      2,      1, 
        0,      0,      2,      1, 
        1,      0,      0,      2, 
        1,      0,      1,      2};
int decrypt_tables[3][128]  = { {        0,        1,        2,        3, 
            4,        5,        6,        7, 
            8,        87,        10,        11, 
            12,        13,        14,        15, 
            16,        17,        18,        19, 
            20,        21,        22,        23, 
            24,        25,        26,        27, 
            28,        29,        30,        31, 
            46,        71,        122,        86, 
            66,        106,        47,        38, 
            73,        65,        52,        50, 
            91,        118,        114,        67, 
            56,        57,        112,        69, 
            104,        113,        79,        9, 
            98,        68,        35,        117, 
            60,        126,        62,        94, 
            255,        119,        74,        97, 
            93,        34,        75,        111, 
            78,        59,        76,        80, 
            103,        42,        125,        116, 
            84,        43,        45,        44, 
            48,        110,        107,        102, 
            53,        37,        33,        100, 
            77,        82,        99,        63, 
            123,        120,        41,        40, 
            115,        89,        51,        127, 
            109,        85,        83,        124, 
            58,        95,        101,        70, 
            88,        49,        105,        108, 
            90,        72,        39,        92, 
            61,        36,        121,        55, 
            96,        81,        32,        54}, 
   {        0,        1,        2,        3, 
            4,        5,        6,        7, 
            8,        123,        10,        11, 
            12,        13,        14,        15, 
            16,        17,        18,        19, 
            20,        21,        22,        23, 
            24,        25,        26,        27, 
            28,        29,        30,        31, 
            50,        48,        33,        41, 
            91,        56,        51,        61, 
            88,        58,        53,        101, 
            57,        92,        86,        115, 
            102,        78,        69,        107, 
            98,        89,        120,        94, 
            125,        74,        109,        113, 
            60,        96,        62,        83, 
            255,        66,        39,        72, 
            114,        117,        49,        55, 
            77,        82,        34,        84, 
            106,        71,        100,        45, 
            32,        127,        46,        76, 
            93,        126,        108,        111, 
            121,        116,        67,        38, 
            118,        37,        36,        43, 
            40,        35,        65,        52, 
            9,        42,        68,        63, 
            119,        59,        85,        105, 
            97,        99,        80,        103, 
            81,        73,        79,        70, 
            104,        124,        54,        112, 
            110,        122,        47,        95, 
            75,        90,        44,        87}, 
   {        0,        1,        2,        3, 
            4,        5,        6,        7, 
            8,        110,        10,        11, 
            12,        6,        14,        15, 
            16,        17,        18,        19, 
            20,        21,        22,        23, 
            24,        25,        26,        27, 
            28,        29,        30,        31, 
            45,        117,        82,        96, 
            113,        94,        73,        92, 
            98,        125,        41,        54, 
            32,        124,        122,        127, 
            107,        99,        51,        43, 
            104,        81,        102,        118, 
            49,        100,        84,        67, 
            60,        58,        62,        126, 
            255,        69,        44,        42, 
            116,        39,        55,        68, 
            121,        89,        47,        111, 
            38,        114,        106,        57, 
            123,        63,        56,        119, 
            103,        83,        71,        52, 
            120,        93,        48,        35, 
            90,        91,        108,        72, 
            85,        112,        105,        46, 
            76,        33,        36,        78, 
            80,        9,        86,        115, 
            53,        97,        75,        88, 
            59,        87,        34,        109, 
            77,        37,        40,        70, 
            74,        50,        65,        61, 
            95,        79,        66,        101}};
static unsigned char *cli_readline(FILE *stream , m_area_t *m_area , unsigned int max_len ) 
{ unsigned char *line ;
  unsigned char *ptr ;
  unsigned char *start ;
  unsigned char *end ;
  unsigned int line_len ;
  unsigned int count ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  line = (unsigned char *)cli_malloc(max_len);
  if (! line) {
    return ((unsigned char *)((void *)0));
  }
  if (m_area) {
    ptr = m_area->buffer + m_area->offset;
    start = ptr;
    end = m_area->buffer + m_area->length;
    if ((unsigned int )start >= (unsigned int )end) {
      free((void *)line);
      return ((unsigned char *)((void *)0));
    }
    line_len = 1U;
    while (1) {
      if ((unsigned int )ptr < (unsigned int )end) {
        if ((int )(*ptr) != 10) {
          if (! (line_len < max_len - 1U)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      ptr ++;
      line_len ++;
    }
    if ((unsigned int )ptr == (unsigned int )end) {
      line_len --;
      memcpy((void * __restrict  )line, (void const   * __restrict  )start, line_len);
      (*(line + line_len)) = (unsigned char )'\000';
    } else {
      if ((int )(*ptr) == 10) {
        memcpy((void * __restrict  )line, (void const   * __restrict  )start, line_len);
        (*(line + line_len)) = (unsigned char )'\000';
      } else {
        count = line_len;
        while (1) {
          tmp___0 = __ctype_b_loc();
          if ((int const   )(*((*tmp___0) + (int )(*ptr))) & 8192) {
            break;
          } else {
            if (! (line_len > 1U)) {
              break;
            }
          }
          ptr --;
          line_len --;
        }
        if (line_len == 1U) {
          line_len = count;
        }
        memcpy((void * __restrict  )line, (void const   * __restrict  )start, line_len);
        (*(line + line_len)) = (unsigned char )'\000';
      }
    }
    m_area->offset = (long )((unsigned long )m_area->offset + (unsigned long )line_len);
  } else {
    if (! stream) {
      cli_dbgmsg("No HTML stream\n");
      free((void *)line);
      return ((unsigned char *)((void *)0));
    }
    tmp___1 = fgets((char * __restrict  )line, (int )max_len, (FILE * __restrict  )stream);
    if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
      free((void *)line);
      return ((unsigned char *)((void *)0));
    }
    line_len = strlen((char const   *)line);
    if (line_len == 0U) {
      free((void *)line);
      return ((unsigned char *)((void *)0));
    }
    if (line_len == max_len - 1U) {
      count = 0U;
      while (1) {
        tmp___2 = __ctype_b_loc();
        line_len --;
        if ((int const   )(*((*tmp___2) + (int )(*(line + line_len)))) & 8192) {
          break;
        }
        count --;
        if (line_len == 0U) {
          return (line);
        }
      }
      fseek(stream, (long )count, 1);
      (*(line + (line_len + 1U))) = (unsigned char )'\000';
    }
  }
  return (line);
}
}
static void html_output_flush(file_buff_t *fbuff ) 
{ 

  {
  if (fbuff) {
    if (fbuff->length > 0) {
      cli_writen(fbuff->fd, (void *)(fbuff->buffer), (unsigned int )fbuff->length);
      fbuff->length = 0;
    }
  }
  return;
}
}
static void html_output_c(file_buff_t *fbuff1 , file_buff_t *fbuff2 , unsigned char c ) 
{ int tmp ;
  int tmp___0 ;

  {
  if (fbuff1) {
    if (fbuff1->length == 8192) {
      html_output_flush(fbuff1);
    }
    tmp = fbuff1->length;
    fbuff1->length ++;
    fbuff1->buffer[tmp] = c;
  }
  if (fbuff2) {
    if (fbuff2->length == 8192) {
      html_output_flush(fbuff2);
    }
    tmp___0 = fbuff2->length;
    fbuff2->length ++;
    fbuff2->buffer[tmp___0] = c;
  }
  return;
}
}
static void html_output_str(file_buff_t *fbuff , unsigned char *str , int len ) 
{ 

  {
  if (fbuff) {
    if (fbuff->length + len >= 8192) {
      html_output_flush(fbuff);
    }
    if (len >= 8192) {
      html_output_flush(fbuff);
      cli_writen(fbuff->fd, (void *)str, (unsigned int )len);
    } else {
      memcpy((void * __restrict  )(fbuff->buffer + fbuff->length), (void const   * __restrict  )str,
             (unsigned int )len);
      fbuff->length += len;
    }
  }
  return;
}
}
static char *html_tag_arg_value(tag_arguments_t *tags , char *tag ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___53 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;

  {
  i = 0;
  while (i < tags->count) {
    tmp___65 = __builtin_constant_p((int )(*(tags->tag + i)));
    if (tmp___65) {
      tmp___66 = __builtin_constant_p((int )tag);
      if (tmp___66) {
        __s1_len = strlen((char const   *)(*(tags->tag + i)));
        __s2_len = strlen((char const   *)tag);
        if (! ((unsigned int )((void const   *)((*(tags->tag + i)) + 1)) - (unsigned int )((void const   *)(*(tags->tag +
                                                                                                              i))) ==
               1U)) {
          goto _L___16;
        } else {
          if (__s1_len >= 4U) {
            _L___16: 
            if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
                   1U)) {
              tmp___67 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___67 = 1;
              } else {
                tmp___67 = 0;
              }
            }
          } else {
            tmp___67 = 0;
          }
        }
        if (tmp___67) {
          tmp___34 = __builtin_strcmp((*(tags->tag + i)), tag);
        } else {
          goto _L___18;
        }
      } else {
        goto _L___18;
      }
    } else {
      _L___18: 
      tmp___64 = __builtin_constant_p((int )(*(tags->tag + i)));
      if (tmp___64) {
        if ((unsigned int )((void const   *)((*(tags->tag + i)) + 1)) - (unsigned int )((void const   *)(*(tags->tag +
                                                                                                           i))) ==
            1U) {
          __s1_len = strlen((char const   *)(*(tags->tag + i)));
          if (__s1_len < 4U) {
            tmp___53 = __builtin_constant_p((int )tag);
            if (tmp___53) {
              if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
                  1U) {
                tmp___34 = __builtin_strcmp((*(tags->tag + i)), tag);
              } else {
                goto _L___11;
              }
            } else {
              _L___11: 
              __s2___6 = (unsigned char const   *)((char const   *)tag);
              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(tags->tag +
                                                                                                   i))) +
                                                      0)) - (int const   )(*(__s2___6 +
                                                                             0)));
              if (__s1_len > 0U) {
                if (__result___18 == 0) {
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(tags->tag +
                                                                                                       i))) +
                                                          1)) - (int const   )(*(__s2___6 +
                                                                                 1)));
                  if (__s1_len > 1U) {
                    if (__result___18 == 0) {
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(tags->tag +
                                                                                                           i))) +
                                                              2)) - (int const   )(*(__s2___6 +
                                                                                     2)));
                      if (__s1_len > 2U) {
                        if (__result___18 == 0) {
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(tags->tag +
                                                                                                               i))) +
                                                                  3)) - (int const   )(*(__s2___6 +
                                                                                         3)));
                        }
                      }
                    }
                  }
                }
              }
              tmp___34 = __result___18;
            }
          } else {
            goto _L___15;
          }
        } else {
          goto _L___15;
        }
      } else {
        _L___15: 
        tmp___63 = __builtin_constant_p((int )tag);
        if (tmp___63) {
          if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
              1U) {
            __s2_len = strlen((char const   *)tag);
            if (__s2_len < 4U) {
              tmp___62 = __builtin_constant_p((int )(*(tags->tag + i)));
              if (tmp___62) {
                if ((unsigned int )((void const   *)((*(tags->tag + i)) + 1)) - (unsigned int )((void const   *)(*(tags->tag +
                                                                                                                   i))) ==
                    1U) {
                  tmp___34 = __builtin_strcmp((*(tags->tag + i)), tag);
                } else {
                  goto _L___13;
                }
              } else {
                _L___13: 
                __s1___14 = (unsigned char const   *)((char const   *)(*(tags->tag +
                                                                         i)));
                __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)tag) +
                                                                                           0)));
                if (__s2_len > 0U) {
                  if (__result___22 == 0) {
                    __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)((char const   *)tag) +
                                                                                               1)));
                    if (__s2_len > 1U) {
                      if (__result___22 == 0) {
                        __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                               (int const   )(*((unsigned char const   *)((char const   *)tag) +
                                                                2)));
                        if (__s2_len > 2U) {
                          if (__result___22 == 0) {
                            __result___22 = (int )((int const   )(*(__s1___14 + 3)) -
                                                   (int const   )(*((unsigned char const   *)((char const   *)tag) +
                                                                    3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___34 = __result___22;
              }
            } else {
              tmp___34 = __builtin_strcmp((*(tags->tag + i)), tag);
            }
          } else {
            tmp___34 = __builtin_strcmp((*(tags->tag + i)), tag);
          }
        } else {
          tmp___34 = __builtin_strcmp((*(tags->tag + i)), tag);
        }
      }
    }
    if (tmp___34 == 0) {
      return ((char *)(*(tags->value + i)));
    }
    i ++;
  }
  return ((char *)((void *)0));
}
}
static void html_tag_arg_set(tag_arguments_t *tags , char *tag , char *value ) 
{ int i ;
  void *tmp___14 ;
  size_t __len___2 ;
  size_t tmp___15 ;
  char *__retval___2 ;
  char *tmp___16 ;
  int tmp___18 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___54 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___73 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;

  {
  i = 0;
  while (i < tags->count) {
    tmp___85 = __builtin_constant_p((int )(*(tags->tag + i)));
    if (tmp___85) {
      tmp___86 = __builtin_constant_p((int )tag);
      if (tmp___86) {
        __s1_len = strlen((char const   *)(*(tags->tag + i)));
        __s2_len = strlen((char const   *)tag);
        if (! ((unsigned int )((void const   *)((*(tags->tag + i)) + 1)) - (unsigned int )((void const   *)(*(tags->tag +
                                                                                                              i))) ==
               1U)) {
          goto _L___16;
        } else {
          if (__s1_len >= 4U) {
            _L___16: 
            if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
                   1U)) {
              tmp___87 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___87 = 1;
              } else {
                tmp___87 = 0;
              }
            }
          } else {
            tmp___87 = 0;
          }
        }
        if (tmp___87) {
          tmp___54 = __builtin_strcmp((*(tags->tag + i)), tag);
        } else {
          goto _L___18;
        }
      } else {
        goto _L___18;
      }
    } else {
      _L___18: 
      tmp___84 = __builtin_constant_p((int )(*(tags->tag + i)));
      if (tmp___84) {
        if ((unsigned int )((void const   *)((*(tags->tag + i)) + 1)) - (unsigned int )((void const   *)(*(tags->tag +
                                                                                                           i))) ==
            1U) {
          __s1_len = strlen((char const   *)(*(tags->tag + i)));
          if (__s1_len < 4U) {
            tmp___73 = __builtin_constant_p((int )tag);
            if (tmp___73) {
              if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
                  1U) {
                tmp___54 = __builtin_strcmp((*(tags->tag + i)), tag);
              } else {
                goto _L___11;
              }
            } else {
              _L___11: 
              __s2___6 = (unsigned char const   *)((char const   *)tag);
              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(tags->tag +
                                                                                                   i))) +
                                                      0)) - (int const   )(*(__s2___6 +
                                                                             0)));
              if (__s1_len > 0U) {
                if (__result___18 == 0) {
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(tags->tag +
                                                                                                       i))) +
                                                          1)) - (int const   )(*(__s2___6 +
                                                                                 1)));
                  if (__s1_len > 1U) {
                    if (__result___18 == 0) {
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(tags->tag +
                                                                                                           i))) +
                                                              2)) - (int const   )(*(__s2___6 +
                                                                                     2)));
                      if (__s1_len > 2U) {
                        if (__result___18 == 0) {
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(tags->tag +
                                                                                                               i))) +
                                                                  3)) - (int const   )(*(__s2___6 +
                                                                                         3)));
                        }
                      }
                    }
                  }
                }
              }
              tmp___54 = __result___18;
            }
          } else {
            goto _L___15;
          }
        } else {
          goto _L___15;
        }
      } else {
        _L___15: 
        tmp___83 = __builtin_constant_p((int )tag);
        if (tmp___83) {
          if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
              1U) {
            __s2_len = strlen((char const   *)tag);
            if (__s2_len < 4U) {
              tmp___82 = __builtin_constant_p((int )(*(tags->tag + i)));
              if (tmp___82) {
                if ((unsigned int )((void const   *)((*(tags->tag + i)) + 1)) - (unsigned int )((void const   *)(*(tags->tag +
                                                                                                                   i))) ==
                    1U) {
                  tmp___54 = __builtin_strcmp((*(tags->tag + i)), tag);
                } else {
                  goto _L___13;
                }
              } else {
                _L___13: 
                __s1___14 = (unsigned char const   *)((char const   *)(*(tags->tag +
                                                                         i)));
                __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)tag) +
                                                                                           0)));
                if (__s2_len > 0U) {
                  if (__result___22 == 0) {
                    __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)((char const   *)tag) +
                                                                                               1)));
                    if (__s2_len > 1U) {
                      if (__result___22 == 0) {
                        __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                               (int const   )(*((unsigned char const   *)((char const   *)tag) +
                                                                2)));
                        if (__s2_len > 2U) {
                          if (__result___22 == 0) {
                            __result___22 = (int )((int const   )(*(__s1___14 + 3)) -
                                                   (int const   )(*((unsigned char const   *)((char const   *)tag) +
                                                                    3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___54 = __result___22;
              }
            } else {
              tmp___54 = __builtin_strcmp((*(tags->tag + i)), tag);
            }
          } else {
            tmp___54 = __builtin_strcmp((*(tags->tag + i)), tag);
          }
        } else {
          tmp___54 = __builtin_strcmp((*(tags->tag + i)), tag);
        }
      }
    }
    if (tmp___54 == 0) {
      free((void *)(*(tags->value + i)));
      tmp___18 = __builtin_constant_p((int )value);
      if (tmp___18) {
        if ((unsigned int )((void const   *)(value + 1)) - (unsigned int )((void const   *)value) ==
            1U) {
          if ((int const   )(*((char const   *)value + 0)) == 0) {
            tmp___14 = calloc(1U, 1U);
            (*(tags->value + i)) = (unsigned char *)((char *)tmp___14);
          } else {
            tmp___15 = strlen((char const   *)value);
            __len___2 = tmp___15 + 1U;
            tmp___16 = (char *)malloc(__len___2);
            __retval___2 = tmp___16;
            if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
              __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )value,
                                            __len___2);
            }
            (*(tags->value + i)) = (unsigned char *)__retval___2;
          }
        } else {
          (*(tags->value + i)) = (unsigned char *)__strdup((char const   *)value);
        }
      } else {
        (*(tags->value + i)) = (unsigned char *)__strdup((char const   *)value);
      }
      return;
    }
    i ++;
  }
  return;
}
}
static void html_tag_arg_add(tag_arguments_t *tags , unsigned char *tag , unsigned char *value ) 
{ int len ;
  int i ;
  void *tmp___16 ;
  size_t __len___2 ;
  size_t tmp___17 ;
  char *__retval___2 ;
  char *tmp___18 ;
  int tmp___20 ;
  void *tmp___36 ;
  size_t __len___6 ;
  size_t tmp___37 ;
  char *__retval___6 ;
  char *tmp___38 ;
  int tmp___40 ;
  void *tmp___56 ;
  size_t __len___10 ;
  size_t tmp___57 ;
  char *__retval___10 ;
  char *tmp___58 ;
  int tmp___60 ;

  {
  tags->count = tags->count + 1;
  tags->tag = (unsigned char **)cli_realloc((void *)tags->tag, (unsigned int )tags->count *
                                                               sizeof(char *));
  if (! tags->tag) {
    goto abort;
  }
  tags->value = (unsigned char **)cli_realloc((void *)tags->value, (unsigned int )tags->count *
                                                                   sizeof(char *));
  if (! tags->value) {
    goto abort;
  }
  tmp___20 = __builtin_constant_p((int )tag);
  if (tmp___20) {
    if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
        1U) {
      if ((int const   )(*((char const   *)tag + 0)) == 0) {
        tmp___16 = calloc(1U, 1U);
        (*(tags->tag + (tags->count - 1))) = (unsigned char *)((char *)tmp___16);
      } else {
        tmp___17 = strlen((char const   *)tag);
        __len___2 = tmp___17 + 1U;
        tmp___18 = (char *)malloc(__len___2);
        __retval___2 = tmp___18;
        if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
          __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )tag,
                                        __len___2);
        }
        (*(tags->tag + (tags->count - 1))) = (unsigned char *)__retval___2;
      }
    } else {
      (*(tags->tag + (tags->count - 1))) = (unsigned char *)__strdup((char const   *)tag);
    }
  } else {
    (*(tags->tag + (tags->count - 1))) = (unsigned char *)__strdup((char const   *)tag);
  }
  if (value) {
    if ((int )(*value) == 34) {
      tmp___40 = __builtin_constant_p((int )(value + 1));
      if (tmp___40) {
        if ((unsigned int )((void const   *)((value + 1) + 1)) - (unsigned int )((void const   *)(value +
                                                                                                  1)) ==
            1U) {
          if ((int const   )(*((char const   *)(value + 1) + 0)) == 0) {
            tmp___36 = calloc(1U, 1U);
            (*(tags->value + (tags->count - 1))) = (unsigned char *)((char *)tmp___36);
          } else {
            tmp___37 = strlen((char const   *)(value + 1));
            __len___6 = tmp___37 + 1U;
            tmp___38 = (char *)malloc(__len___6);
            __retval___6 = tmp___38;
            if ((unsigned int )__retval___6 != (unsigned int )((void *)0)) {
              __retval___6 = (char *)memcpy((void * __restrict  )__retval___6, (void const   * __restrict  )(value +
                                                                                                             1),
                                            __len___6);
            }
            (*(tags->value + (tags->count - 1))) = (unsigned char *)__retval___6;
          }
        } else {
          (*(tags->value + (tags->count - 1))) = (unsigned char *)__strdup((char const   *)(value +
                                                                                            1));
        }
      } else {
        (*(tags->value + (tags->count - 1))) = (unsigned char *)__strdup((char const   *)(value +
                                                                                          1));
      }
      len = (int )strlen((char const   *)(value + 1));
      if (len > 0) {
        (*((*(tags->value + (tags->count - 1))) + (len - 1))) = (unsigned char )'\000';
      }
    } else {
      tmp___60 = __builtin_constant_p((int )value);
      if (tmp___60) {
        if ((unsigned int )((void const   *)(value + 1)) - (unsigned int )((void const   *)value) ==
            1U) {
          if ((int const   )(*((char const   *)value + 0)) == 0) {
            tmp___56 = calloc(1U, 1U);
            (*(tags->value + (tags->count - 1))) = (unsigned char *)((char *)tmp___56);
          } else {
            tmp___57 = strlen((char const   *)value);
            __len___10 = tmp___57 + 1U;
            tmp___58 = (char *)malloc(__len___10);
            __retval___10 = tmp___58;
            if ((unsigned int )__retval___10 != (unsigned int )((void *)0)) {
              __retval___10 = (char *)memcpy((void * __restrict  )__retval___10, (void const   * __restrict  )value,
                                             __len___10);
            }
            (*(tags->value + (tags->count - 1))) = (unsigned char *)__retval___10;
          }
        } else {
          (*(tags->value + (tags->count - 1))) = (unsigned char *)__strdup((char const   *)value);
        }
      } else {
        (*(tags->value + (tags->count - 1))) = (unsigned char *)__strdup((char const   *)value);
      }
    }
  } else {
    (*(tags->value + (tags->count - 1))) = (unsigned char *)((void *)0);
  }
  return;
  abort: 
  tags->count = tags->count - 1;
  i = 0;
  while (i < tags->count) {
    if (tags->tag) {
      free((void *)(*(tags->tag + i)));
    }
    if (tags->value) {
      free((void *)(*(tags->value + i)));
    }
    i ++;
  }
  if (tags->tag) {
    free((void *)tags->tag);
  }
  if (tags->value) {
    free((void *)tags->value);
  }
  tags->value = (unsigned char **)((void *)0);
  tags->tag = tags->value;
  tags->count = 0;
  return;
}
}
static void html_output_tag(file_buff_t *fbuff , char *tag , tag_arguments_t *tags ) 
{ int i ;
  int j ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int __res ;
  int __c ;
  __int32_t const   **tmp___2 ;
  int tmp___3 ;
  __int32_t const   **tmp___4 ;

  {
  html_output_c(fbuff, (file_buff_t *)((void *)0), (unsigned char )'<');
  tmp = (int )strlen((char const   *)tag);
  html_output_str(fbuff, (unsigned char *)tag, tmp);
  i = 0;
  while (i < tags->count) {
    html_output_c(fbuff, (file_buff_t *)((void *)0), (unsigned char )' ');
    tmp___0 = (int )strlen((char const   *)(*(tags->tag + i)));
    html_output_str(fbuff, (*(tags->tag + i)), tmp___0);
    if ((*(tags->value + i))) {
      html_output_str(fbuff, (unsigned char *)"=\"", 2);
      len = (int )strlen((char const   *)(*(tags->value + i)));
      j = 0;
      while (j < len) {
        if (sizeof((*((*(tags->value + i)) + j))) > 1U) {
          tmp___3 = __builtin_constant_p((int )(*((*(tags->value + i)) + j)));
          if (tmp___3) {
            __c = (int )(*((*(tags->value + i)) + j));
            if (__c < -128) {
              __res = __c;
            } else {
              if (__c > 255) {
                __res = __c;
              } else {
                tmp___2 = __ctype_tolower_loc();
                __res = (*((*tmp___2) + __c));
              }
            }
          } else {
            __res = tolower__extinline((int )(*((*(tags->value + i)) + j)));
          }
        } else {
          tmp___4 = __ctype_tolower_loc();
          __res = (*((*tmp___4) + (int )(*((*(tags->value + i)) + j))));
        }
        html_output_c(fbuff, (file_buff_t *)((void *)0), (unsigned char )__res);
        j ++;
      }
      html_output_c(fbuff, (file_buff_t *)((void *)0), (unsigned char )'\"');
    }
    i ++;
  }
  html_output_c(fbuff, (file_buff_t *)((void *)0), (unsigned char )'>');
  return;
}
}
void html_tag_arg_free(tag_arguments_t *tags ) 
{ int i ;

  {
  i = 0;
  while (i < tags->count) {
    free((void *)(*(tags->tag + i)));
    if ((*(tags->value + i))) {
      free((void *)(*(tags->value + i)));
    }
    i ++;
  }
  if (tags->tag) {
    free((void *)tags->tag);
  }
  if (tags->value) {
    free((void *)tags->value);
  }
  tags->value = (unsigned char **)((void *)0);
  tags->tag = tags->value;
  tags->count = 0;
  return;
}
}
static int cli_html_normalise(int fd , m_area_t *m_area , char const   *dirname ,
                              tag_arguments_t *hrefs ) 
{ int fd_tmp ;
  int tag_length ;
  int tag_arg_length ;
  int binary ;
  int retval ;
  int escape ;
  int value ;
  int hex___0 ;
  int tag_val_length ;
  int table_pos ;
  int in_script ;
  FILE *stream_in ;
  html_state state ;
  html_state next_state ;
  char filename[1024] ;
  char tag[1025] ;
  char tag_arg[1025] ;
  char tag_val[1025] ;
  char *tmp_file ;
  unsigned char *line ;
  unsigned char *ptr ;
  unsigned char *arg_value ;
  tag_arguments_t tag_args ;
  quoted_state quoted ;
  unsigned long length ;
  file_buff_t *file_buff_o1 ;
  file_buff_t *file_buff_o2 ;
  file_buff_t *file_buff_script ;
  file_buff_t *file_tmp_o1 ;
  int tmp ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  int __res ;
  int __c ;
  __int32_t const   **tmp___7 ;
  int tmp___8 ;
  __int32_t const   **tmp___9 ;
  int __res___0 ;
  int __c___0 ;
  __int32_t const   **tmp___11 ;
  int tmp___12 ;
  __int32_t const   **tmp___13 ;
  unsigned short const   **tmp___14 ;
  int __res___1 ;
  int __c___1 ;
  __int32_t const   **tmp___16 ;
  int tmp___17 ;
  __int32_t const   **tmp___18 ;
  int __res___2 ;
  int __c___2 ;
  __int32_t const   **tmp___20 ;
  int tmp___21 ;
  __int32_t const   **tmp___22 ;
  int tmp___23 ;
  int __res___3 ;
  int __c___3 ;
  __int32_t const   **tmp___25 ;
  int tmp___26 ;
  __int32_t const   **tmp___27 ;
  unsigned short const   **tmp___28 ;
  int __res___4 ;
  int __c___4 ;
  __int32_t const   **tmp___30 ;
  int tmp___31 ;
  __int32_t const   **tmp___32 ;
  int tmp___33 ;
  int __res___5 ;
  int __c___5 ;
  __int32_t const   **tmp___35 ;
  int tmp___36 ;
  __int32_t const   **tmp___37 ;
  unsigned short const   **tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  unsigned short const   **tmp___47 ;
  int __res___6 ;
  int __c___6 ;
  __int32_t const   **tmp___49 ;
  int tmp___50 ;
  __int32_t const   **tmp___51 ;
  int tmp___52 ;
  unsigned short const   **tmp___53 ;
  int tmp___128 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___164 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___183 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___192 ;
  int tmp___193 ;
  int tmp___194 ;
  int tmp___195 ;
  int tmp___196 ;
  int tmp___197 ;
  int tmp___198 ;
  size_t tmp___199 ;
  int tmp___200 ;
  size_t tmp___201 ;
  int tmp___276 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___312 ;
  unsigned char const   *__s2___30 ;
  register int __result___90 ;
  int tmp___331 ;
  unsigned char const   *__s1___62 ;
  register int __result___94 ;
  int tmp___340 ;
  int tmp___341 ;
  int tmp___342 ;
  int tmp___343 ;
  int tmp___344 ;
  int tmp___345 ;
  int tmp___346 ;
  size_t tmp___347 ;
  int tmp___348 ;
  size_t tmp___349 ;
  int __res___7 ;
  int __c___7 ;
  __int32_t const   **tmp___351 ;
  int tmp___352 ;
  __int32_t const   **tmp___353 ;
  int __res___8 ;
  int __c___8 ;
  __int32_t const   **tmp___355 ;
  int tmp___356 ;
  __int32_t const   **tmp___357 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___393 ;
  unsigned char const   *__s2___38 ;
  register int __result___114 ;
  int tmp___412 ;
  unsigned char const   *__s1___78 ;
  register int __result___118 ;
  int tmp___421 ;
  int tmp___422 ;
  int tmp___423 ;
  int tmp___424 ;
  int tmp___425 ;
  int tmp___426 ;
  int tmp___427 ;
  int tmp___428 ;
  size_t tmp___429 ;
  size_t tmp___430 ;
  size_t tmp___431 ;
  size_t tmp___432 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___468 ;
  unsigned char const   *__s2___46 ;
  register int __result___138 ;
  int tmp___487 ;
  unsigned char const   *__s1___94 ;
  register int __result___142 ;
  int tmp___496 ;
  int tmp___497 ;
  int tmp___498 ;
  int tmp___499 ;
  int tmp___500 ;
  int tmp___501 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___537 ;
  unsigned char const   *__s2___54 ;
  register int __result___162 ;
  int tmp___556 ;
  unsigned char const   *__s1___110 ;
  register int __result___166 ;
  int tmp___565 ;
  int tmp___566 ;
  int tmp___567 ;
  int tmp___568 ;
  int tmp___569 ;
  int tmp___570 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___606 ;
  unsigned char const   *__s2___62 ;
  register int __result___186 ;
  int tmp___625 ;
  unsigned char const   *__s1___126 ;
  register int __result___190 ;
  int tmp___634 ;
  int tmp___635 ;
  int tmp___636 ;
  int tmp___637 ;
  int tmp___638 ;
  int tmp___639 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___675 ;
  unsigned char const   *__s2___70 ;
  register int __result___210 ;
  int tmp___694 ;
  unsigned char const   *__s1___142 ;
  register int __result___214 ;
  int tmp___703 ;
  int tmp___704 ;
  int tmp___705 ;
  int tmp___706 ;
  int tmp___707 ;
  int tmp___708 ;
  int __res___9 ;
  int __c___9 ;
  __int32_t const   **tmp___710 ;
  int tmp___711 ;
  __int32_t const   **tmp___712 ;
  unsigned short const   **tmp___713 ;
  unsigned short const   **tmp___714 ;
  unsigned short const   **tmp___715 ;
  int __res___10 ;
  int __c___10 ;
  __int32_t const   **tmp___717 ;
  int tmp___718 ;
  __int32_t const   **tmp___719 ;
  int __res___11 ;
  int __c___11 ;
  __int32_t const   **tmp___721 ;
  int tmp___722 ;
  __int32_t const   **tmp___723 ;
  int tmp___798 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___834 ;
  unsigned char const   *__s2___86 ;
  register int __result___258 ;
  int tmp___853 ;
  unsigned char const   *__s1___174 ;
  register int __result___262 ;
  int tmp___862 ;
  int tmp___863 ;
  int tmp___864 ;
  int tmp___865 ;
  int tmp___866 ;
  int tmp___867 ;
  int tmp___868 ;
  size_t tmp___869 ;
  int tmp___870 ;
  size_t tmp___871 ;
  size_t tmp___872 ;
  int __res___12 ;
  int __c___12 ;
  __int32_t const   **tmp___874 ;
  int tmp___875 ;
  __int32_t const   **tmp___876 ;
  int tmp___877 ;
  int tmp___878 ;
  int tmp___879 ;
  int tmp___880 ;
  unsigned short const   **tmp___881 ;
  int tmp___882 ;
  int __res___13 ;
  int __c___13 ;
  __int32_t const   **tmp___884 ;
  int tmp___885 ;
  __int32_t const   **tmp___886 ;
  unsigned short const   **tmp___887 ;
  char *tmp___889 ;
  unsigned short const   **tmp___890 ;
  int __res___14 ;
  int __c___14 ;
  __int32_t const   **tmp___892 ;
  int tmp___893 ;
  __int32_t const   **tmp___894 ;
  unsigned short const   **tmp___895 ;
  unsigned short const   **tmp___896 ;

  {
  retval = 0;
  in_script = 0;
  state = (enum __anonenum_html_state_22 )1;
  next_state = (enum __anonenum_html_state_22 )0;
  if (! m_area) {
    if (fd < 0) {
      cli_dbgmsg("Invalid HTML fd\n");
      return (0);
    }
    lseek(fd, 0L, 0);
    fd_tmp = dup(fd);
    if (fd_tmp < 0) {
      return (0);
    }
    stream_in = fdopen(fd_tmp, "r");
    if (! stream_in) {
      close(fd_tmp);
      return (0);
    }
  }
  tag_args.count = 0;
  tag_args.tag = (unsigned char **)((void *)0);
  tag_args.value = (unsigned char **)((void *)0);
  if (dirname) {
    snprintf((char * __restrict  )(filename), 1024U, (char const   * __restrict  )"%s/rfc2397",
             dirname);
    tmp = mkdir((char const   *)(filename), 448U);
    if (tmp) {
      file_buff_script = (file_buff_t *)((void *)0);
      file_buff_o2 = file_buff_script;
      file_buff_o1 = file_buff_o2;
      goto abort;
    }
    file_buff_o1 = (file_buff_t *)cli_malloc(sizeof(file_buff_t ));
    if (! file_buff_o1) {
      file_buff_script = (file_buff_t *)((void *)0);
      file_buff_o2 = file_buff_script;
      file_buff_o1 = file_buff_o2;
      goto abort;
    }
    file_buff_o2 = (file_buff_t *)cli_malloc(sizeof(file_buff_t ));
    if (! file_buff_o2) {
      free((void *)file_buff_o1);
      file_buff_script = (file_buff_t *)((void *)0);
      file_buff_o2 = file_buff_script;
      file_buff_o1 = file_buff_o2;
      goto abort;
    }
    file_buff_script = (file_buff_t *)cli_malloc(sizeof(file_buff_t ));
    if (! file_buff_script) {
      free((void *)file_buff_o1);
      free((void *)file_buff_o2);
      file_buff_script = (file_buff_t *)((void *)0);
      file_buff_o2 = file_buff_script;
      file_buff_o1 = file_buff_o2;
      goto abort;
    }
    snprintf((char * __restrict  )(filename), 1024U, (char const   * __restrict  )"%s/comment.html",
             dirname);
    file_buff_o1->fd = open((char const   *)(filename), 577, 384);
    if (! file_buff_o1->fd) {
      cli_dbgmsg("open failed: %s\n", filename);
      free((void *)file_buff_o1);
      free((void *)file_buff_o2);
      free((void *)file_buff_script);
      file_buff_script = (file_buff_t *)((void *)0);
      file_buff_o2 = file_buff_script;
      file_buff_o1 = file_buff_o2;
      goto abort;
    }
    snprintf((char * __restrict  )(filename), 1024U, (char const   * __restrict  )"%s/nocomment.html",
             dirname);
    file_buff_o2->fd = open((char const   *)(filename), 577, 384);
    if (! file_buff_o2->fd) {
      cli_dbgmsg("open failed: %s\n", filename);
      close(file_buff_o1->fd);
      free((void *)file_buff_o1);
      free((void *)file_buff_o2);
      free((void *)file_buff_script);
      file_buff_script = (file_buff_t *)((void *)0);
      file_buff_o2 = file_buff_script;
      file_buff_o1 = file_buff_o2;
      goto abort;
    }
    snprintf((char * __restrict  )(filename), 1024U, (char const   * __restrict  )"%s/script.html",
             dirname);
    file_buff_script->fd = open((char const   *)(filename), 577, 384);
    if (! file_buff_script->fd) {
      cli_dbgmsg("open failed: %s\n", filename);
      close(file_buff_o1->fd);
      close(file_buff_o2->fd);
      free((void *)file_buff_o1);
      free((void *)file_buff_o2);
      free((void *)file_buff_script);
      file_buff_script = (file_buff_t *)((void *)0);
      file_buff_o2 = file_buff_script;
      file_buff_o1 = file_buff_o2;
      goto abort;
    }
    file_buff_o1->length = 0;
    file_buff_o2->length = 0;
    file_buff_script->length = 0;
  } else {
    file_buff_o1 = (file_buff_t *)((void *)0);
    file_buff_o2 = (file_buff_t *)((void *)0);
    file_buff_script = (file_buff_t *)((void *)0);
  }
  binary = 0;
  line = cli_readline(stream_in, m_area, 8192U);
  ptr = line;
  while (line) {
    while (1) {
      if ((*ptr)) {
        tmp___3 = __ctype_b_loc();
        if (! ((int const   )(*((*tmp___3) + (int )(*ptr))) & 8192)) {
          break;
        }
      } else {
        break;
      }
      ptr ++;
    }
    while ((*ptr)) {
      if (! binary) {
        if ((int )(*ptr) == 10) {
          (*ptr) = (unsigned char )' ';
          continue;
        }
      }
      if (! binary) {
        if ((int )(*ptr) == 13) {
          ptr ++;
          continue;
        }
      }
      switch ((int )state) {
      case 0: 
      cli_dbgmsg("HTML Engine Error\n");
      goto abort;
      case 12: 
      length --;
      ptr ++;
      if (! length) {
        state = next_state;
      }
      break;
      case 4: 
      tmp___4 = __ctype_b_loc();
      if ((int const   )(*((*tmp___4) + (int )(*ptr))) & 8192) {
        ptr ++;
      } else {
        state = next_state;
        next_state = (enum __anonenum_html_state_22 )0;
      }
      break;
      case 5: 
      tmp___5 = __ctype_b_loc();
      if ((int const   )(*((*tmp___5) + (int )(*ptr))) & 8192) {
        ptr ++;
      } else {
        html_output_c(file_buff_o1, file_buff_o2, (unsigned char )' ');
        state = next_state;
        next_state = (enum __anonenum_html_state_22 )0;
      }
      break;
      case 1: ;
      if ((int )(*ptr) == 60) {
        html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'<');
        if (in_script) {
          html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char )'<');
        }
        ptr ++;
        state = (enum __anonenum_html_state_22 )4;
        tag_length = 0;
        next_state = (enum __anonenum_html_state_22 )6;
      } else {
        tmp___14 = __ctype_b_loc();
        if ((int const   )(*((*tmp___14) + (int )(*ptr))) & 8192) {
          state = (enum __anonenum_html_state_22 )5;
          next_state = (enum __anonenum_html_state_22 )1;
        } else {
          if ((int )(*ptr) == 38) {
            state = (enum __anonenum_html_state_22 )3;
            next_state = (enum __anonenum_html_state_22 )1;
            ptr ++;
          } else {
            if (sizeof((*ptr)) > 1U) {
              tmp___8 = __builtin_constant_p((int )(*ptr));
              if (tmp___8) {
                __c = (int )(*ptr);
                if (__c < -128) {
                  __res = __c;
                } else {
                  if (__c > 255) {
                    __res = __c;
                  } else {
                    tmp___7 = __ctype_tolower_loc();
                    __res = (*((*tmp___7) + __c));
                  }
                }
              } else {
                __res = tolower__extinline((int )(*ptr));
              }
            } else {
              tmp___9 = __ctype_tolower_loc();
              __res = (*((*tmp___9) + (int )(*ptr)));
            }
            html_output_c(file_buff_o1, file_buff_o2, (unsigned char )__res);
            if (in_script) {
              if (sizeof((*ptr)) > 1U) {
                tmp___12 = __builtin_constant_p((int )(*ptr));
                if (tmp___12) {
                  __c___0 = (int )(*ptr);
                  if (__c___0 < -128) {
                    __res___0 = __c___0;
                  } else {
                    if (__c___0 > 255) {
                      __res___0 = __c___0;
                    } else {
                      tmp___11 = __ctype_tolower_loc();
                      __res___0 = (*((*tmp___11) + __c___0));
                    }
                  }
                } else {
                  __res___0 = tolower__extinline((int )(*ptr));
                }
              } else {
                tmp___13 = __ctype_tolower_loc();
                __res___0 = (*((*tmp___13) + (int )(*ptr)));
              }
              html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char )__res___0);
            }
            ptr ++;
          }
        }
      }
      break;
      case 6: ;
      if (tag_length == 0) {
        if ((int )(*ptr) == 33) {
          html_output_c(file_buff_o1, (file_buff_t *)((void *)0), (unsigned char )'!');
          if (in_script) {
            html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char )'!');
          }
          if (file_buff_o2) {
            if (file_buff_o2->length > 0) {
              file_buff_o2->length --;
            }
          }
          state = (enum __anonenum_html_state_22 )2;
          next_state = (enum __anonenum_html_state_22 )0;
          ptr ++;
        } else {
          goto _L;
        }
      } else {
        _L: 
        if ((int )(*ptr) == 62) {
          html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'>');
          if (in_script) {
            html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char )'>');
          }
          ptr ++;
          tag[tag_length] = (char )'\000';
          state = (enum __anonenum_html_state_22 )4;
          next_state = (enum __anonenum_html_state_22 )10;
        } else {
          tmp___28 = __ctype_b_loc();
          if ((int const   )(*((*tmp___28) + (int )(*ptr))) & 8192) {
            tag[tag_length] = (char )'\000';
            state = (enum __anonenum_html_state_22 )4;
            tag_arg_length = 0;
            next_state = (enum __anonenum_html_state_22 )7;
          } else {
            if (sizeof((*ptr)) > 1U) {
              tmp___17 = __builtin_constant_p((int )(*ptr));
              if (tmp___17) {
                __c___1 = (int )(*ptr);
                if (__c___1 < -128) {
                  __res___1 = __c___1;
                } else {
                  if (__c___1 > 255) {
                    __res___1 = __c___1;
                  } else {
                    tmp___16 = __ctype_tolower_loc();
                    __res___1 = (*((*tmp___16) + __c___1));
                  }
                }
              } else {
                __res___1 = tolower__extinline((int )(*ptr));
              }
            } else {
              tmp___18 = __ctype_tolower_loc();
              __res___1 = (*((*tmp___18) + (int )(*ptr)));
            }
            html_output_c(file_buff_o1, file_buff_o2, (unsigned char )__res___1);
            if (in_script) {
              if (sizeof((*ptr)) > 1U) {
                tmp___21 = __builtin_constant_p((int )(*ptr));
                if (tmp___21) {
                  __c___2 = (int )(*ptr);
                  if (__c___2 < -128) {
                    __res___2 = __c___2;
                  } else {
                    if (__c___2 > 255) {
                      __res___2 = __c___2;
                    } else {
                      tmp___20 = __ctype_tolower_loc();
                      __res___2 = (*((*tmp___20) + __c___2));
                    }
                  }
                } else {
                  __res___2 = tolower__extinline((int )(*ptr));
                }
              } else {
                tmp___22 = __ctype_tolower_loc();
                __res___2 = (*((*tmp___22) + (int )(*ptr)));
              }
              html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char )__res___2);
            }
            if (tag_length < 1024) {
              tmp___23 = tag_length;
              tag_length ++;
              if (sizeof((*ptr)) > 1U) {
                tmp___26 = __builtin_constant_p((int )(*ptr));
                if (tmp___26) {
                  __c___3 = (int )(*ptr);
                  if (__c___3 < -128) {
                    __res___3 = __c___3;
                  } else {
                    if (__c___3 > 255) {
                      __res___3 = __c___3;
                    } else {
                      tmp___25 = __ctype_tolower_loc();
                      __res___3 = (*((*tmp___25) + __c___3));
                    }
                  }
                } else {
                  __res___3 = tolower__extinline((int )(*ptr));
                }
              } else {
                tmp___27 = __ctype_tolower_loc();
                __res___3 = (*((*tmp___27) + (int )(*ptr)));
              }
              tag[tmp___23] = (char )__res___3;
            }
            ptr ++;
          }
        }
      }
      break;
      case 7: ;
      if ((int )(*ptr) == 61) {
        html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'=');
        tag_arg[tag_arg_length] = (char )'\000';
        ptr ++;
        state = (enum __anonenum_html_state_22 )4;
        escape = 0;
        quoted = (enum __anonenum_quoted_state_23 )2;
        tag_val_length = 0;
        next_state = (enum __anonenum_html_state_22 )8;
      } else {
        tmp___38 = __ctype_b_loc();
        if ((int const   )(*((*tmp___38) + (int )(*ptr))) & 8192) {
          ptr ++;
          tag_arg[tag_arg_length] = (char )'\000';
          state = (enum __anonenum_html_state_22 )4;
          next_state = (enum __anonenum_html_state_22 )9;
        } else {
          if ((int )(*ptr) == 62) {
            html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'>');
            if (tag_arg_length > 0) {
              tag_arg[tag_arg_length] = (char )'\000';
              html_tag_arg_add(& tag_args, (unsigned char *)(tag_arg), (unsigned char *)((void *)0));
            }
            ptr ++;
            state = (enum __anonenum_html_state_22 )10;
            next_state = (enum __anonenum_html_state_22 )0;
          } else {
            if (tag_arg_length == 0) {
              html_output_c(file_buff_o1, file_buff_o2, (unsigned char )' ');
            }
            if (sizeof((*ptr)) > 1U) {
              tmp___31 = __builtin_constant_p((int )(*ptr));
              if (tmp___31) {
                __c___4 = (int )(*ptr);
                if (__c___4 < -128) {
                  __res___4 = __c___4;
                } else {
                  if (__c___4 > 255) {
                    __res___4 = __c___4;
                  } else {
                    tmp___30 = __ctype_tolower_loc();
                    __res___4 = (*((*tmp___30) + __c___4));
                  }
                }
              } else {
                __res___4 = tolower__extinline((int )(*ptr));
              }
            } else {
              tmp___32 = __ctype_tolower_loc();
              __res___4 = (*((*tmp___32) + (int )(*ptr)));
            }
            html_output_c(file_buff_o1, file_buff_o2, (unsigned char )__res___4);
            if (tag_arg_length < 1024) {
              tmp___33 = tag_arg_length;
              tag_arg_length ++;
              if (sizeof((*ptr)) > 1U) {
                tmp___36 = __builtin_constant_p((int )(*ptr));
                if (tmp___36) {
                  __c___5 = (int )(*ptr);
                  if (__c___5 < -128) {
                    __res___5 = __c___5;
                  } else {
                    if (__c___5 > 255) {
                      __res___5 = __c___5;
                    } else {
                      tmp___35 = __ctype_tolower_loc();
                      __res___5 = (*((*tmp___35) + __c___5));
                    }
                  }
                } else {
                  __res___5 = tolower__extinline((int )(*ptr));
                }
              } else {
                tmp___37 = __ctype_tolower_loc();
                __res___5 = (*((*tmp___37) + (int )(*ptr)));
              }
              tag_arg[tmp___33] = (char )__res___5;
            }
            ptr ++;
          }
        }
      }
      break;
      case 9: ;
      if ((int )(*ptr) == 61) {
        html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'=');
        ptr ++;
        state = (enum __anonenum_html_state_22 )4;
        escape = 0;
        quoted = (enum __anonenum_quoted_state_23 )2;
        tag_val_length = 0;
        next_state = (enum __anonenum_html_state_22 )8;
      } else {
        if (tag_arg_length > 0) {
          tag_arg[tag_arg_length] = (char )'\000';
          html_tag_arg_add(& tag_args, (unsigned char *)(tag_arg), (unsigned char *)((void *)0));
        }
        tag_arg_length = 0;
        state = (enum __anonenum_html_state_22 )7;
        next_state = (enum __anonenum_html_state_22 )0;
      }
      break;
      case 8: ;
      if (tag_val_length == 5) {
        tmp___346 = __builtin_constant_p((int )(tag_val));
        if (tmp___346) {
          tmp___347 = strlen((char const   *)(tag_val));
          if (tmp___347 < 5U) {
            goto _L___86;
          } else {
            goto _L___87;
          }
        } else {
          _L___87: 
          tmp___348 = __builtin_constant_p((int )"data:");
          if (tmp___348) {
            tmp___349 = strlen("data:");
            if (tmp___349 < 5U) {
              _L___86: 
              tmp___343 = __builtin_constant_p((int )(tag_val));
              if (tmp___343) {
                tmp___344 = __builtin_constant_p((int )"data:");
                if (tmp___344) {
                  __s1_len___2 = strlen((char const   *)(tag_val));
                  __s2_len___2 = strlen("data:");
                  if (! ((unsigned int )((void const   *)(tag_val + 1)) - (unsigned int )((void const   *)(tag_val)) ==
                         1U)) {
                    goto _L___83;
                  } else {
                    if (__s1_len___2 >= 4U) {
                      _L___83: 
                      if (! ((unsigned int )((void const   *)("data:" + 1)) - (unsigned int )((void const   *)"data:") ==
                             1U)) {
                        tmp___345 = 1;
                      } else {
                        if (__s2_len___2 >= 4U) {
                          tmp___345 = 1;
                        } else {
                          tmp___345 = 0;
                        }
                      }
                    } else {
                      tmp___345 = 0;
                    }
                  }
                  if (tmp___345) {
                    tmp___312 = __builtin_strcmp(tag_val, "data:");
                  } else {
                    goto _L___85;
                  }
                } else {
                  goto _L___85;
                }
              } else {
                _L___85: 
                tmp___342 = __builtin_constant_p((int )(tag_val));
                if (tmp___342) {
                  if ((unsigned int )((void const   *)(tag_val + 1)) - (unsigned int )((void const   *)(tag_val)) ==
                      1U) {
                    __s1_len___2 = strlen((char const   *)(tag_val));
                    if (__s1_len___2 < 4U) {
                      tmp___331 = __builtin_constant_p((int )"data:");
                      if (tmp___331) {
                        if ((unsigned int )((void const   *)("data:" + 1)) - (unsigned int )((void const   *)"data:") ==
                            1U) {
                          tmp___312 = __builtin_strcmp(tag_val, "data:");
                        } else {
                          goto _L___78;
                        }
                      } else {
                        _L___78: 
                        __s2___30 = (unsigned char const   *)"data:";
                        __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag_val)) +
                                                                0)) - (int const   )(*(__s2___30 +
                                                                                       0)));
                        if (__s1_len___2 > 0U) {
                          if (__result___90 == 0) {
                            __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag_val)) +
                                                                    1)) - (int const   )(*(__s2___30 +
                                                                                           1)));
                            if (__s1_len___2 > 1U) {
                              if (__result___90 == 0) {
                                __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag_val)) +
                                                                        2)) - (int const   )(*(__s2___30 +
                                                                                               2)));
                                if (__s1_len___2 > 2U) {
                                  if (__result___90 == 0) {
                                    __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag_val)) +
                                                                            3)) -
                                                           (int const   )(*(__s2___30 +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
                        tmp___312 = __result___90;
                      }
                    } else {
                      goto _L___82;
                    }
                  } else {
                    goto _L___82;
                  }
                } else {
                  _L___82: 
                  tmp___341 = __builtin_constant_p((int )"data:");
                  if (tmp___341) {
                    if ((unsigned int )((void const   *)("data:" + 1)) - (unsigned int )((void const   *)"data:") ==
                        1U) {
                      __s2_len___2 = strlen("data:");
                      if (__s2_len___2 < 4U) {
                        tmp___340 = __builtin_constant_p((int )(tag_val));
                        if (tmp___340) {
                          if ((unsigned int )((void const   *)(tag_val + 1)) - (unsigned int )((void const   *)(tag_val)) ==
                              1U) {
                            tmp___312 = __builtin_strcmp(tag_val, "data:");
                          } else {
                            goto _L___80;
                          }
                        } else {
                          _L___80: 
                          __s1___62 = (unsigned char const   *)((char const   *)(tag_val));
                          __result___94 = (int )((int const   )(*(__s1___62 + 0)) -
                                                 (int const   )(*((unsigned char const   *)"data:" +
                                                                  0)));
                          if (__s2_len___2 > 0U) {
                            if (__result___94 == 0) {
                              __result___94 = (int )((int const   )(*(__s1___62 +
                                                                      1)) - (int const   )(*((unsigned char const   *)"data:" +
                                                                                             1)));
                              if (__s2_len___2 > 1U) {
                                if (__result___94 == 0) {
                                  __result___94 = (int )((int const   )(*(__s1___62 +
                                                                          2)) - (int const   )(*((unsigned char const   *)"data:" +
                                                                                                 2)));
                                  if (__s2_len___2 > 2U) {
                                    if (__result___94 == 0) {
                                      __result___94 = (int )((int const   )(*(__s1___62 +
                                                                              3)) -
                                                             (int const   )(*((unsigned char const   *)"data:" +
                                                                              3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
                          tmp___312 = __result___94;
                        }
                      } else {
                        tmp___312 = __builtin_strcmp(tag_val, "data:");
                      }
                    } else {
                      tmp___312 = __builtin_strcmp(tag_val, "data:");
                    }
                  } else {
                    tmp___312 = __builtin_strcmp(tag_val, "data:");
                  }
                }
              }
              tmp___276 = tmp___312;
            } else {
              tmp___276 = strncmp((char const   *)(tag_val), "data:", 5U);
            }
          } else {
            tmp___276 = strncmp((char const   *)(tag_val), "data:", 5U);
          }
        }
        if (tmp___276 == 0) {
          if (file_buff_o1) {
            if (file_buff_o1->length > 0) {
              file_buff_o1->length --;
            }
          }
          if (file_buff_o2) {
            if (file_buff_o2->length > 0) {
              file_buff_o2->length --;
            }
          }
          if ((int )quoted != 2) {
            html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'\"');
          }
          tag_val_length = 0;
          state = (enum __anonenum_html_state_22 )17;
          next_state = (enum __anonenum_html_state_22 )7;
        } else {
          goto _L___88;
        }
      } else {
        _L___88: 
        if (tag_val_length == 6) {
          tmp___198 = __builtin_constant_p((int )(tag_val));
          if (tmp___198) {
            tmp___199 = strlen((char const   *)(tag_val));
            if (tmp___199 < 6U) {
              goto _L___43;
            } else {
              goto _L___44;
            }
          } else {
            _L___44: 
            tmp___200 = __builtin_constant_p((int )"\"data:");
            if (tmp___200) {
              tmp___201 = strlen("\"data:");
              if (tmp___201 < 6U) {
                _L___43: 
                tmp___195 = __builtin_constant_p((int )(tag_val));
                if (tmp___195) {
                  tmp___196 = __builtin_constant_p((int )"\"data:");
                  if (tmp___196) {
                    __s1_len___0 = strlen((char const   *)(tag_val));
                    __s2_len___0 = strlen("\"data:");
                    if (! ((unsigned int )((void const   *)(tag_val + 1)) - (unsigned int )((void const   *)(tag_val)) ==
                           1U)) {
                      goto _L___40;
                    } else {
                      if (__s1_len___0 >= 4U) {
                        _L___40: 
                        if (! ((unsigned int )((void const   *)("\"data:" + 1)) -
                               (unsigned int )((void const   *)"\"data:") == 1U)) {
                          tmp___197 = 1;
                        } else {
                          if (__s2_len___0 >= 4U) {
                            tmp___197 = 1;
                          } else {
                            tmp___197 = 0;
                          }
                        }
                      } else {
                        tmp___197 = 0;
                      }
                    }
                    if (tmp___197) {
                      tmp___164 = __builtin_strcmp(tag_val, "\"data:");
                    } else {
                      goto _L___42;
                    }
                  } else {
                    goto _L___42;
                  }
                } else {
                  _L___42: 
                  tmp___194 = __builtin_constant_p((int )(tag_val));
                  if (tmp___194) {
                    if ((unsigned int )((void const   *)(tag_val + 1)) - (unsigned int )((void const   *)(tag_val)) ==
                        1U) {
                      __s1_len___0 = strlen((char const   *)(tag_val));
                      if (__s1_len___0 < 4U) {
                        tmp___183 = __builtin_constant_p((int )"\"data:");
                        if (tmp___183) {
                          if ((unsigned int )((void const   *)("\"data:" + 1)) - (unsigned int )((void const   *)"\"data:") ==
                              1U) {
                            tmp___164 = __builtin_strcmp(tag_val, "\"data:");
                          } else {
                            goto _L___35;
                          }
                        } else {
                          _L___35: 
                          __s2___14 = (unsigned char const   *)"\"data:";
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag_val)) +
                                                                  0)) - (int const   )(*(__s2___14 +
                                                                                         0)));
                          if (__s1_len___0 > 0U) {
                            if (__result___42 == 0) {
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag_val)) +
                                                                      1)) - (int const   )(*(__s2___14 +
                                                                                             1)));
                              if (__s1_len___0 > 1U) {
                                if (__result___42 == 0) {
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag_val)) +
                                                                          2)) - (int const   )(*(__s2___14 +
                                                                                                 2)));
                                  if (__s1_len___0 > 2U) {
                                    if (__result___42 == 0) {
                                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag_val)) +
                                                                              3)) -
                                                             (int const   )(*(__s2___14 +
                                                                              3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
                          tmp___164 = __result___42;
                        }
                      } else {
                        goto _L___39;
                      }
                    } else {
                      goto _L___39;
                    }
                  } else {
                    _L___39: 
                    tmp___193 = __builtin_constant_p((int )"\"data:");
                    if (tmp___193) {
                      if ((unsigned int )((void const   *)("\"data:" + 1)) - (unsigned int )((void const   *)"\"data:") ==
                          1U) {
                        __s2_len___0 = strlen("\"data:");
                        if (__s2_len___0 < 4U) {
                          tmp___192 = __builtin_constant_p((int )(tag_val));
                          if (tmp___192) {
                            if ((unsigned int )((void const   *)(tag_val + 1)) - (unsigned int )((void const   *)(tag_val)) ==
                                1U) {
                              tmp___164 = __builtin_strcmp(tag_val, "\"data:");
                            } else {
                              goto _L___37;
                            }
                          } else {
                            _L___37: 
                            __s1___30 = (unsigned char const   *)((char const   *)(tag_val));
                            __result___46 = (int )((int const   )(*(__s1___30 + 0)) -
                                                   (int const   )(*((unsigned char const   *)"\"data:" +
                                                                    0)));
                            if (__s2_len___0 > 0U) {
                              if (__result___46 == 0) {
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        1)) - (int const   )(*((unsigned char const   *)"\"data:" +
                                                                                               1)));
                                if (__s2_len___0 > 1U) {
                                  if (__result___46 == 0) {
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            2)) -
                                                           (int const   )(*((unsigned char const   *)"\"data:" +
                                                                            2)));
                                    if (__s2_len___0 > 2U) {
                                      if (__result___46 == 0) {
                                        __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                3)) -
                                                               (int const   )(*((unsigned char const   *)"\"data:" +
                                                                                3)));
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            tmp___164 = __result___46;
                          }
                        } else {
                          tmp___164 = __builtin_strcmp(tag_val, "\"data:");
                        }
                      } else {
                        tmp___164 = __builtin_strcmp(tag_val, "\"data:");
                      }
                    } else {
                      tmp___164 = __builtin_strcmp(tag_val, "\"data:");
                    }
                  }
                }
                tmp___128 = tmp___164;
              } else {
                tmp___128 = strncmp((char const   *)(tag_val), "\"data:", 6U);
              }
            } else {
              tmp___128 = strncmp((char const   *)(tag_val), "\"data:", 6U);
            }
          }
          if (tmp___128 == 0) {
            if (file_buff_o1) {
              if (file_buff_o1->length > 0) {
                file_buff_o1->length --;
              }
            }
            if (file_buff_o2) {
              if (file_buff_o2->length > 0) {
                file_buff_o2->length --;
              }
            }
            if ((int )quoted != 2) {
              html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'\"');
            }
            tag_val_length = 0;
            state = (enum __anonenum_html_state_22 )17;
            next_state = (enum __anonenum_html_state_22 )7;
          } else {
            goto _L___45;
          }
        } else {
          _L___45: 
          if ((int )(*ptr) == 38) {
            state = (enum __anonenum_html_state_22 )3;
            next_state = (enum __anonenum_html_state_22 )8;
            ptr ++;
          } else {
            if ((int )(*ptr) == 39) {
              if (tag_val_length == 0) {
                quoted = (enum __anonenum_quoted_state_23 )0;
                html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'\"');
                if (tag_val_length < 1024) {
                  tmp___39 = tag_val_length;
                  tag_val_length ++;
                  tag_val[tmp___39] = (char )'\"';
                }
                ptr ++;
              } else {
                if (! escape) {
                  if ((int )quoted == 0) {
                    html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'\"');
                    if (tag_val_length < 1024) {
                      tmp___40 = tag_val_length;
                      tag_val_length ++;
                      tag_val[tmp___40] = (char )'\"';
                    }
                    tag_val[tag_val_length] = (char )'\000';
                    html_tag_arg_add(& tag_args, (unsigned char *)(tag_arg), (unsigned char *)(tag_val));
                    ptr ++;
                    state = (enum __anonenum_html_state_22 )4;
                    tag_arg_length = 0;
                    next_state = (enum __anonenum_html_state_22 )7;
                  } else {
                    goto _L___0;
                  }
                } else {
                  _L___0: 
                  html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'\"');
                  if (tag_val_length < 1024) {
                    tmp___41 = tag_val_length;
                    tag_val_length ++;
                    tag_val[tmp___41] = (char )'\"';
                  }
                  ptr ++;
                }
              }
            } else {
              if ((int )(*ptr) == 34) {
                if (tag_val_length == 0) {
                  quoted = (enum __anonenum_quoted_state_23 )1;
                  html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'\"');
                  if (tag_val_length < 1024) {
                    tmp___42 = tag_val_length;
                    tag_val_length ++;
                    tag_val[tmp___42] = (char )'\"';
                  }
                  ptr ++;
                } else {
                  if (! escape) {
                    if ((int )quoted == 1) {
                      html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'\"');
                      if (tag_val_length < 1024) {
                        tmp___43 = tag_val_length;
                        tag_val_length ++;
                        tag_val[tmp___43] = (char )'\"';
                      }
                      tag_val[tag_val_length] = (char )'\000';
                      html_tag_arg_add(& tag_args, (unsigned char *)(tag_arg), (unsigned char *)(tag_val));
                      ptr ++;
                      state = (enum __anonenum_html_state_22 )4;
                      tag_arg_length = 0;
                      next_state = (enum __anonenum_html_state_22 )7;
                    } else {
                      goto _L___1;
                    }
                  } else {
                    _L___1: 
                    html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'\"');
                    if (tag_val_length < 1024) {
                      tmp___44 = tag_val_length;
                      tag_val_length ++;
                      tag_val[tmp___44] = (char )'\"';
                    }
                    ptr ++;
                  }
                }
              } else {
                tmp___53 = __ctype_b_loc();
                if ((int const   )(*((*tmp___53) + (int )(*ptr))) & 8192) {
                  goto _L___2;
                } else {
                  if ((int )(*ptr) == 62) {
                    _L___2: 
                    if ((int )quoted == 2) {
                      tag_val[tag_val_length] = (char )'\000';
                      html_tag_arg_add(& tag_args, (unsigned char *)(tag_arg), (unsigned char *)(tag_val));
                      state = (enum __anonenum_html_state_22 )4;
                      tag_arg_length = 0;
                      next_state = (enum __anonenum_html_state_22 )7;
                    } else {
                      html_output_c(file_buff_o1, file_buff_o2, (*ptr));
                      if (tag_val_length < 1024) {
                        tmp___47 = __ctype_b_loc();
                        if ((int const   )(*((*tmp___47) + (int )(*ptr))) & 8192) {
                          tmp___45 = tag_val_length;
                          tag_val_length ++;
                          tag_val[tmp___45] = (char )' ';
                        } else {
                          tmp___46 = tag_val_length;
                          tag_val_length ++;
                          tag_val[tmp___46] = (char )'>';
                        }
                      }
                      state = (enum __anonenum_html_state_22 )4;
                      escape = 0;
                      quoted = (enum __anonenum_quoted_state_23 )2;
                      next_state = (enum __anonenum_html_state_22 )8;
                      ptr ++;
                    }
                  } else {
                    if (sizeof((*ptr)) > 1U) {
                      tmp___50 = __builtin_constant_p((int )(*ptr));
                      if (tmp___50) {
                        __c___6 = (int )(*ptr);
                        if (__c___6 < -128) {
                          __res___6 = __c___6;
                        } else {
                          if (__c___6 > 255) {
                            __res___6 = __c___6;
                          } else {
                            tmp___49 = __ctype_tolower_loc();
                            __res___6 = (*((*tmp___49) + __c___6));
                          }
                        }
                      } else {
                        __res___6 = tolower__extinline((int )(*ptr));
                      }
                    } else {
                      tmp___51 = __ctype_tolower_loc();
                      __res___6 = (*((*tmp___51) + (int )(*ptr)));
                    }
                    html_output_c(file_buff_o1, file_buff_o2, (unsigned char )__res___6);
                    if (tag_val_length < 1024) {
                      tmp___52 = tag_val_length;
                      tag_val_length ++;
                      tag_val[tmp___52] = (char )(*ptr);
                    }
                    ptr ++;
                  }
                }
              }
            }
          }
        }
      }
      if ((int )(*ptr) == 92) {
        escape = 1;
      } else {
        escape = 0;
      }
      break;
      case 2: ;
      if (sizeof((*ptr)) > 1U) {
        tmp___352 = __builtin_constant_p((int )(*ptr));
        if (tmp___352) {
          __c___7 = (int )(*ptr);
          if (__c___7 < -128) {
            __res___7 = __c___7;
          } else {
            if (__c___7 > 255) {
              __res___7 = __c___7;
            } else {
              tmp___351 = __ctype_tolower_loc();
              __res___7 = (*((*tmp___351) + __c___7));
            }
          }
        } else {
          __res___7 = tolower__extinline((int )(*ptr));
        }
      } else {
        tmp___353 = __ctype_tolower_loc();
        __res___7 = (*((*tmp___353) + (int )(*ptr)));
      }
      html_output_c(file_buff_o1, (file_buff_t *)((void *)0), (unsigned char )__res___7);
      if (in_script) {
        if (sizeof((*ptr)) > 1U) {
          tmp___356 = __builtin_constant_p((int )(*ptr));
          if (tmp___356) {
            __c___8 = (int )(*ptr);
            if (__c___8 < -128) {
              __res___8 = __c___8;
            } else {
              if (__c___8 > 255) {
                __res___8 = __c___8;
              } else {
                tmp___355 = __ctype_tolower_loc();
                __res___8 = (*((*tmp___355) + __c___8));
              }
            }
          } else {
            __res___8 = tolower__extinline((int )(*ptr));
          }
        } else {
          tmp___357 = __ctype_tolower_loc();
          __res___8 = (*((*tmp___357) + (int )(*ptr)));
        }
        html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char )__res___8);
      }
      if ((int )(*ptr) == 62) {
        state = (enum __anonenum_html_state_22 )4;
        next_state = (enum __anonenum_html_state_22 )1;
      }
      ptr ++;
      break;
      case 10: 
      state = (enum __anonenum_html_state_22 )4;
      next_state = (enum __anonenum_html_state_22 )1;
      if ((int )tag[0] == 47) {
        state = (enum __anonenum_html_state_22 )4;
        next_state = (enum __anonenum_html_state_22 )1;
        tmp___424 = __builtin_constant_p((int )(tag));
        if (tmp___424) {
          tmp___425 = __builtin_constant_p((int )"/script");
          if (tmp___425) {
            __s1_len___3 = strlen((char const   *)(tag));
            __s2_len___3 = strlen("/script");
            if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                   1U)) {
              goto _L___106;
            } else {
              if (__s1_len___3 >= 4U) {
                _L___106: 
                if (! ((unsigned int )((void const   *)("/script" + 1)) - (unsigned int )((void const   *)"/script") ==
                       1U)) {
                  tmp___426 = 1;
                } else {
                  if (__s2_len___3 >= 4U) {
                    tmp___426 = 1;
                  } else {
                    tmp___426 = 0;
                  }
                }
              } else {
                tmp___426 = 0;
              }
            }
            if (tmp___426) {
              tmp___393 = __builtin_strcmp(tag, "/script");
            } else {
              goto _L___108;
            }
          } else {
            goto _L___108;
          }
        } else {
          _L___108: 
          tmp___423 = __builtin_constant_p((int )(tag));
          if (tmp___423) {
            if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                1U) {
              __s1_len___3 = strlen((char const   *)(tag));
              if (__s1_len___3 < 4U) {
                tmp___412 = __builtin_constant_p((int )"/script");
                if (tmp___412) {
                  if ((unsigned int )((void const   *)("/script" + 1)) - (unsigned int )((void const   *)"/script") ==
                      1U) {
                    tmp___393 = __builtin_strcmp(tag, "/script");
                  } else {
                    goto _L___101;
                  }
                } else {
                  _L___101: 
                  __s2___38 = (unsigned char const   *)"/script";
                  __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                           0)) - (int const   )(*(__s2___38 +
                                                                                  0)));
                  if (__s1_len___3 > 0U) {
                    if (__result___114 == 0) {
                      __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                               1)) - (int const   )(*(__s2___38 +
                                                                                      1)));
                      if (__s1_len___3 > 1U) {
                        if (__result___114 == 0) {
                          __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                   2)) - (int const   )(*(__s2___38 +
                                                                                          2)));
                          if (__s1_len___3 > 2U) {
                            if (__result___114 == 0) {
                              __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                       3)) - (int const   )(*(__s2___38 +
                                                                                              3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___393 = __result___114;
                }
              } else {
                goto _L___105;
              }
            } else {
              goto _L___105;
            }
          } else {
            _L___105: 
            tmp___422 = __builtin_constant_p((int )"/script");
            if (tmp___422) {
              if ((unsigned int )((void const   *)("/script" + 1)) - (unsigned int )((void const   *)"/script") ==
                  1U) {
                __s2_len___3 = strlen("/script");
                if (__s2_len___3 < 4U) {
                  tmp___421 = __builtin_constant_p((int )(tag));
                  if (tmp___421) {
                    if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                        1U) {
                      tmp___393 = __builtin_strcmp(tag, "/script");
                    } else {
                      goto _L___103;
                    }
                  } else {
                    _L___103: 
                    __s1___78 = (unsigned char const   *)((char const   *)(tag));
                    __result___118 = (int )((int const   )(*(__s1___78 + 0)) - (int const   )(*((unsigned char const   *)"/script" +
                                                                                                0)));
                    if (__s2_len___3 > 0U) {
                      if (__result___118 == 0) {
                        __result___118 = (int )((int const   )(*(__s1___78 + 1)) -
                                                (int const   )(*((unsigned char const   *)"/script" +
                                                                 1)));
                        if (__s2_len___3 > 1U) {
                          if (__result___118 == 0) {
                            __result___118 = (int )((int const   )(*(__s1___78 + 2)) -
                                                    (int const   )(*((unsigned char const   *)"/script" +
                                                                     2)));
                            if (__s2_len___3 > 2U) {
                              if (__result___118 == 0) {
                                __result___118 = (int )((int const   )(*(__s1___78 +
                                                                         3)) - (int const   )(*((unsigned char const   *)"/script" +
                                                                                                3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___393 = __result___118;
                  }
                } else {
                  tmp___393 = __builtin_strcmp(tag, "/script");
                }
              } else {
                tmp___393 = __builtin_strcmp(tag, "/script");
              }
            } else {
              tmp___393 = __builtin_strcmp(tag, "/script");
            }
          }
        }
        if (tmp___393 == 0) {
          in_script = 0;
          html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char )'\n');
        }
      } else {
        tmp___706 = __builtin_constant_p((int )(tag));
        if (tmp___706) {
          tmp___707 = __builtin_constant_p((int )"script");
          if (tmp___707) {
            __s1_len___7 = strlen((char const   *)(tag));
            __s2_len___7 = strlen("script");
            if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                   1U)) {
              goto _L___187;
            } else {
              if (__s1_len___7 >= 4U) {
                _L___187: 
                if (! ((unsigned int )((void const   *)("script" + 1)) - (unsigned int )((void const   *)"script") ==
                       1U)) {
                  tmp___708 = 1;
                } else {
                  if (__s2_len___7 >= 4U) {
                    tmp___708 = 1;
                  } else {
                    tmp___708 = 0;
                  }
                }
              } else {
                tmp___708 = 0;
              }
            }
            if (tmp___708) {
              tmp___675 = __builtin_strcmp(tag, "script");
            } else {
              goto _L___189;
            }
          } else {
            goto _L___189;
          }
        } else {
          _L___189: 
          tmp___705 = __builtin_constant_p((int )(tag));
          if (tmp___705) {
            if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                1U) {
              __s1_len___7 = strlen((char const   *)(tag));
              if (__s1_len___7 < 4U) {
                tmp___694 = __builtin_constant_p((int )"script");
                if (tmp___694) {
                  if ((unsigned int )((void const   *)("script" + 1)) - (unsigned int )((void const   *)"script") ==
                      1U) {
                    tmp___675 = __builtin_strcmp(tag, "script");
                  } else {
                    goto _L___182;
                  }
                } else {
                  _L___182: 
                  __s2___70 = (unsigned char const   *)"script";
                  __result___210 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                           0)) - (int const   )(*(__s2___70 +
                                                                                  0)));
                  if (__s1_len___7 > 0U) {
                    if (__result___210 == 0) {
                      __result___210 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                               1)) - (int const   )(*(__s2___70 +
                                                                                      1)));
                      if (__s1_len___7 > 1U) {
                        if (__result___210 == 0) {
                          __result___210 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                   2)) - (int const   )(*(__s2___70 +
                                                                                          2)));
                          if (__s1_len___7 > 2U) {
                            if (__result___210 == 0) {
                              __result___210 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                       3)) - (int const   )(*(__s2___70 +
                                                                                              3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___675 = __result___210;
                }
              } else {
                goto _L___186;
              }
            } else {
              goto _L___186;
            }
          } else {
            _L___186: 
            tmp___704 = __builtin_constant_p((int )"script");
            if (tmp___704) {
              if ((unsigned int )((void const   *)("script" + 1)) - (unsigned int )((void const   *)"script") ==
                  1U) {
                __s2_len___7 = strlen("script");
                if (__s2_len___7 < 4U) {
                  tmp___703 = __builtin_constant_p((int )(tag));
                  if (tmp___703) {
                    if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                        1U) {
                      tmp___675 = __builtin_strcmp(tag, "script");
                    } else {
                      goto _L___184;
                    }
                  } else {
                    _L___184: 
                    __s1___142 = (unsigned char const   *)((char const   *)(tag));
                    __result___214 = (int )((int const   )(*(__s1___142 + 0)) - (int const   )(*((unsigned char const   *)"script" +
                                                                                                 0)));
                    if (__s2_len___7 > 0U) {
                      if (__result___214 == 0) {
                        __result___214 = (int )((int const   )(*(__s1___142 + 1)) -
                                                (int const   )(*((unsigned char const   *)"script" +
                                                                 1)));
                        if (__s2_len___7 > 1U) {
                          if (__result___214 == 0) {
                            __result___214 = (int )((int const   )(*(__s1___142 +
                                                                     2)) - (int const   )(*((unsigned char const   *)"script" +
                                                                                            2)));
                            if (__s2_len___7 > 2U) {
                              if (__result___214 == 0) {
                                __result___214 = (int )((int const   )(*(__s1___142 +
                                                                         3)) - (int const   )(*((unsigned char const   *)"script" +
                                                                                                3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___675 = __result___214;
                  }
                } else {
                  tmp___675 = __builtin_strcmp(tag, "script");
                }
              } else {
                tmp___675 = __builtin_strcmp(tag, "script");
              }
            } else {
              tmp___675 = __builtin_strcmp(tag, "script");
            }
          }
        }
        if (tmp___675 == 0) {
          arg_value = (unsigned char *)html_tag_arg_value(& tag_args, (char *)"language");
          if (arg_value) {
            tmp___428 = strcasecmp((char const   *)arg_value, "jscript.encode");
            if (tmp___428 == 0) {
              html_tag_arg_set(& tag_args, (char *)"language", (char *)"javascript");
              state = (enum __anonenum_html_state_22 )4;
              next_state = (enum __anonenum_html_state_22 )13;
            } else {
              goto _L___109;
            }
          } else {
            _L___109: 
            if (arg_value) {
              tmp___427 = strcasecmp((char const   *)arg_value, "vbscript.encode");
              if (tmp___427 == 0) {
                html_tag_arg_set(& tag_args, (char *)"language", (char *)"vbscript");
                state = (enum __anonenum_html_state_22 )4;
                next_state = (enum __anonenum_html_state_22 )13;
              } else {
                in_script = 1;
              }
            } else {
              in_script = 1;
            }
          }
          html_output_tag(file_buff_script, tag, & tag_args);
        } else {
          if (hrefs) {
            tmp___637 = __builtin_constant_p((int )(tag));
            if (tmp___637) {
              tmp___638 = __builtin_constant_p((int )"a");
              if (tmp___638) {
                __s1_len___6 = strlen((char const   *)(tag));
                __s2_len___6 = strlen("a");
                if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                       1U)) {
                  goto _L___167;
                } else {
                  if (__s1_len___6 >= 4U) {
                    _L___167: 
                    if (! ((unsigned int )((void const   *)("a" + 1)) - (unsigned int )((void const   *)"a") ==
                           1U)) {
                      tmp___639 = 1;
                    } else {
                      if (__s2_len___6 >= 4U) {
                        tmp___639 = 1;
                      } else {
                        tmp___639 = 0;
                      }
                    }
                  } else {
                    tmp___639 = 0;
                  }
                }
                if (tmp___639) {
                  tmp___606 = __builtin_strcmp(tag, "a");
                } else {
                  goto _L___169;
                }
              } else {
                goto _L___169;
              }
            } else {
              _L___169: 
              tmp___636 = __builtin_constant_p((int )(tag));
              if (tmp___636) {
                if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                    1U) {
                  __s1_len___6 = strlen((char const   *)(tag));
                  if (__s1_len___6 < 4U) {
                    tmp___625 = __builtin_constant_p((int )"a");
                    if (tmp___625) {
                      if ((unsigned int )((void const   *)("a" + 1)) - (unsigned int )((void const   *)"a") ==
                          1U) {
                        tmp___606 = __builtin_strcmp(tag, "a");
                      } else {
                        goto _L___162;
                      }
                    } else {
                      _L___162: 
                      __s2___62 = (unsigned char const   *)"a";
                      __result___186 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                               0)) - (int const   )(*(__s2___62 +
                                                                                      0)));
                      if (__s1_len___6 > 0U) {
                        if (__result___186 == 0) {
                          __result___186 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                   1)) - (int const   )(*(__s2___62 +
                                                                                          1)));
                          if (__s1_len___6 > 1U) {
                            if (__result___186 == 0) {
                              __result___186 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                       2)) - (int const   )(*(__s2___62 +
                                                                                              2)));
                              if (__s1_len___6 > 2U) {
                                if (__result___186 == 0) {
                                  __result___186 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                           3)) - (int const   )(*(__s2___62 +
                                                                                                  3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___606 = __result___186;
                    }
                  } else {
                    goto _L___166;
                  }
                } else {
                  goto _L___166;
                }
              } else {
                _L___166: 
                tmp___635 = __builtin_constant_p((int )"a");
                if (tmp___635) {
                  if ((unsigned int )((void const   *)("a" + 1)) - (unsigned int )((void const   *)"a") ==
                      1U) {
                    __s2_len___6 = strlen("a");
                    if (__s2_len___6 < 4U) {
                      tmp___634 = __builtin_constant_p((int )(tag));
                      if (tmp___634) {
                        if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                            1U) {
                          tmp___606 = __builtin_strcmp(tag, "a");
                        } else {
                          goto _L___164;
                        }
                      } else {
                        _L___164: 
                        __s1___126 = (unsigned char const   *)((char const   *)(tag));
                        __result___190 = (int )((int const   )(*(__s1___126 + 0)) -
                                                (int const   )(*((unsigned char const   *)"a" +
                                                                 0)));
                        if (__s2_len___6 > 0U) {
                          if (__result___190 == 0) {
                            __result___190 = (int )((int const   )(*(__s1___126 +
                                                                     1)) - (int const   )(*((unsigned char const   *)"a" +
                                                                                            1)));
                            if (__s2_len___6 > 1U) {
                              if (__result___190 == 0) {
                                __result___190 = (int )((int const   )(*(__s1___126 +
                                                                         2)) - (int const   )(*((unsigned char const   *)"a" +
                                                                                                2)));
                                if (__s2_len___6 > 2U) {
                                  if (__result___190 == 0) {
                                    __result___190 = (int )((int const   )(*(__s1___126 +
                                                                             3)) -
                                                            (int const   )(*((unsigned char const   *)"a" +
                                                                             3)));
                                  }
                                }
                              }
                            }
                          }
                        }
                        tmp___606 = __result___190;
                      }
                    } else {
                      tmp___606 = __builtin_strcmp(tag, "a");
                    }
                  } else {
                    tmp___606 = __builtin_strcmp(tag, "a");
                  }
                } else {
                  tmp___606 = __builtin_strcmp(tag, "a");
                }
              }
            }
            if (tmp___606 == 0) {
              arg_value = (unsigned char *)html_tag_arg_value(& tag_args, (char *)"href");
              if (arg_value) {
                tmp___429 = strlen((char const   *)arg_value);
                if (tmp___429 > 0U) {
                  html_tag_arg_add(hrefs, (unsigned char *)"href", arg_value);
                }
              }
            } else {
              tmp___568 = __builtin_constant_p((int )(tag));
              if (tmp___568) {
                tmp___569 = __builtin_constant_p((int )"img");
                if (tmp___569) {
                  __s1_len___5 = strlen((char const   *)(tag));
                  __s2_len___5 = strlen("img");
                  if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                         1U)) {
                    goto _L___147;
                  } else {
                    if (__s1_len___5 >= 4U) {
                      _L___147: 
                      if (! ((unsigned int )((void const   *)("img" + 1)) - (unsigned int )((void const   *)"img") ==
                             1U)) {
                        tmp___570 = 1;
                      } else {
                        if (__s2_len___5 >= 4U) {
                          tmp___570 = 1;
                        } else {
                          tmp___570 = 0;
                        }
                      }
                    } else {
                      tmp___570 = 0;
                    }
                  }
                  if (tmp___570) {
                    tmp___537 = __builtin_strcmp(tag, "img");
                  } else {
                    goto _L___149;
                  }
                } else {
                  goto _L___149;
                }
              } else {
                _L___149: 
                tmp___567 = __builtin_constant_p((int )(tag));
                if (tmp___567) {
                  if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                      1U) {
                    __s1_len___5 = strlen((char const   *)(tag));
                    if (__s1_len___5 < 4U) {
                      tmp___556 = __builtin_constant_p((int )"img");
                      if (tmp___556) {
                        if ((unsigned int )((void const   *)("img" + 1)) - (unsigned int )((void const   *)"img") ==
                            1U) {
                          tmp___537 = __builtin_strcmp(tag, "img");
                        } else {
                          goto _L___142;
                        }
                      } else {
                        _L___142: 
                        __s2___54 = (unsigned char const   *)"img";
                        __result___162 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                 0)) - (int const   )(*(__s2___54 +
                                                                                        0)));
                        if (__s1_len___5 > 0U) {
                          if (__result___162 == 0) {
                            __result___162 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                     1)) - (int const   )(*(__s2___54 +
                                                                                            1)));
                            if (__s1_len___5 > 1U) {
                              if (__result___162 == 0) {
                                __result___162 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                         2)) - (int const   )(*(__s2___54 +
                                                                                                2)));
                                if (__s1_len___5 > 2U) {
                                  if (__result___162 == 0) {
                                    __result___162 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                             3)) -
                                                            (int const   )(*(__s2___54 +
                                                                             3)));
                                  }
                                }
                              }
                            }
                          }
                        }
                        tmp___537 = __result___162;
                      }
                    } else {
                      goto _L___146;
                    }
                  } else {
                    goto _L___146;
                  }
                } else {
                  _L___146: 
                  tmp___566 = __builtin_constant_p((int )"img");
                  if (tmp___566) {
                    if ((unsigned int )((void const   *)("img" + 1)) - (unsigned int )((void const   *)"img") ==
                        1U) {
                      __s2_len___5 = strlen("img");
                      if (__s2_len___5 < 4U) {
                        tmp___565 = __builtin_constant_p((int )(tag));
                        if (tmp___565) {
                          if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                              1U) {
                            tmp___537 = __builtin_strcmp(tag, "img");
                          } else {
                            goto _L___144;
                          }
                        } else {
                          _L___144: 
                          __s1___110 = (unsigned char const   *)((char const   *)(tag));
                          __result___166 = (int )((int const   )(*(__s1___110 + 0)) -
                                                  (int const   )(*((unsigned char const   *)"img" +
                                                                   0)));
                          if (__s2_len___5 > 0U) {
                            if (__result___166 == 0) {
                              __result___166 = (int )((int const   )(*(__s1___110 +
                                                                       1)) - (int const   )(*((unsigned char const   *)"img" +
                                                                                              1)));
                              if (__s2_len___5 > 1U) {
                                if (__result___166 == 0) {
                                  __result___166 = (int )((int const   )(*(__s1___110 +
                                                                           2)) - (int const   )(*((unsigned char const   *)"img" +
                                                                                                  2)));
                                  if (__s2_len___5 > 2U) {
                                    if (__result___166 == 0) {
                                      __result___166 = (int )((int const   )(*(__s1___110 +
                                                                               3)) -
                                                              (int const   )(*((unsigned char const   *)"img" +
                                                                               3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
                          tmp___537 = __result___166;
                        }
                      } else {
                        tmp___537 = __builtin_strcmp(tag, "img");
                      }
                    } else {
                      tmp___537 = __builtin_strcmp(tag, "img");
                    }
                  } else {
                    tmp___537 = __builtin_strcmp(tag, "img");
                  }
                }
              }
              if (tmp___537 == 0) {
                arg_value = (unsigned char *)html_tag_arg_value(& tag_args, (char *)"src");
                if (arg_value) {
                  tmp___430 = strlen((char const   *)arg_value);
                  if (tmp___430 > 0U) {
                    html_tag_arg_add(hrefs, (unsigned char *)"src", arg_value);
                  }
                }
                arg_value = (unsigned char *)html_tag_arg_value(& tag_args, (char *)"dynsrc");
                if (arg_value) {
                  tmp___431 = strlen((char const   *)arg_value);
                  if (tmp___431 > 0U) {
                    html_tag_arg_add(hrefs, (unsigned char *)"dynsrc", arg_value);
                  }
                }
              } else {
                tmp___499 = __builtin_constant_p((int )(tag));
                if (tmp___499) {
                  tmp___500 = __builtin_constant_p((int )"iframe");
                  if (tmp___500) {
                    __s1_len___4 = strlen((char const   *)(tag));
                    __s2_len___4 = strlen("iframe");
                    if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                           1U)) {
                      goto _L___127;
                    } else {
                      if (__s1_len___4 >= 4U) {
                        _L___127: 
                        if (! ((unsigned int )((void const   *)("iframe" + 1)) - (unsigned int )((void const   *)"iframe") ==
                               1U)) {
                          tmp___501 = 1;
                        } else {
                          if (__s2_len___4 >= 4U) {
                            tmp___501 = 1;
                          } else {
                            tmp___501 = 0;
                          }
                        }
                      } else {
                        tmp___501 = 0;
                      }
                    }
                    if (tmp___501) {
                      tmp___468 = __builtin_strcmp(tag, "iframe");
                    } else {
                      goto _L___129;
                    }
                  } else {
                    goto _L___129;
                  }
                } else {
                  _L___129: 
                  tmp___498 = __builtin_constant_p((int )(tag));
                  if (tmp___498) {
                    if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                        1U) {
                      __s1_len___4 = strlen((char const   *)(tag));
                      if (__s1_len___4 < 4U) {
                        tmp___487 = __builtin_constant_p((int )"iframe");
                        if (tmp___487) {
                          if ((unsigned int )((void const   *)("iframe" + 1)) - (unsigned int )((void const   *)"iframe") ==
                              1U) {
                            tmp___468 = __builtin_strcmp(tag, "iframe");
                          } else {
                            goto _L___122;
                          }
                        } else {
                          _L___122: 
                          __s2___46 = (unsigned char const   *)"iframe";
                          __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                   0)) - (int const   )(*(__s2___46 +
                                                                                          0)));
                          if (__s1_len___4 > 0U) {
                            if (__result___138 == 0) {
                              __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                       1)) - (int const   )(*(__s2___46 +
                                                                                              1)));
                              if (__s1_len___4 > 1U) {
                                if (__result___138 == 0) {
                                  __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                           2)) - (int const   )(*(__s2___46 +
                                                                                                  2)));
                                  if (__s1_len___4 > 2U) {
                                    if (__result___138 == 0) {
                                      __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                               3)) -
                                                              (int const   )(*(__s2___46 +
                                                                               3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
                          tmp___468 = __result___138;
                        }
                      } else {
                        goto _L___126;
                      }
                    } else {
                      goto _L___126;
                    }
                  } else {
                    _L___126: 
                    tmp___497 = __builtin_constant_p((int )"iframe");
                    if (tmp___497) {
                      if ((unsigned int )((void const   *)("iframe" + 1)) - (unsigned int )((void const   *)"iframe") ==
                          1U) {
                        __s2_len___4 = strlen("iframe");
                        if (__s2_len___4 < 4U) {
                          tmp___496 = __builtin_constant_p((int )(tag));
                          if (tmp___496) {
                            if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                                1U) {
                              tmp___468 = __builtin_strcmp(tag, "iframe");
                            } else {
                              goto _L___124;
                            }
                          } else {
                            _L___124: 
                            __s1___94 = (unsigned char const   *)((char const   *)(tag));
                            __result___142 = (int )((int const   )(*(__s1___94 + 0)) -
                                                    (int const   )(*((unsigned char const   *)"iframe" +
                                                                     0)));
                            if (__s2_len___4 > 0U) {
                              if (__result___142 == 0) {
                                __result___142 = (int )((int const   )(*(__s1___94 +
                                                                         1)) - (int const   )(*((unsigned char const   *)"iframe" +
                                                                                                1)));
                                if (__s2_len___4 > 1U) {
                                  if (__result___142 == 0) {
                                    __result___142 = (int )((int const   )(*(__s1___94 +
                                                                             2)) -
                                                            (int const   )(*((unsigned char const   *)"iframe" +
                                                                             2)));
                                    if (__s2_len___4 > 2U) {
                                      if (__result___142 == 0) {
                                        __result___142 = (int )((int const   )(*(__s1___94 +
                                                                                 3)) -
                                                                (int const   )(*((unsigned char const   *)"iframe" +
                                                                                 3)));
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            tmp___468 = __result___142;
                          }
                        } else {
                          tmp___468 = __builtin_strcmp(tag, "iframe");
                        }
                      } else {
                        tmp___468 = __builtin_strcmp(tag, "iframe");
                      }
                    } else {
                      tmp___468 = __builtin_strcmp(tag, "iframe");
                    }
                  }
                }
                if (tmp___468 == 0) {
                  arg_value = (unsigned char *)html_tag_arg_value(& tag_args, (char *)"src");
                  if (arg_value) {
                    tmp___432 = strlen((char const   *)arg_value);
                    if (tmp___432 > 0U) {
                      html_tag_arg_add(hrefs, (unsigned char *)"iframe", arg_value);
                    }
                  }
                }
              }
            }
          }
        }
      }
      html_tag_arg_free(& tag_args);
      break;
      case 3: ;
      if ((int )(*ptr) == 35) {
        value = 0;
        hex___0 = 0;
        state = (enum __anonenum_html_state_22 )11;
        ptr ++;
      } else {
        html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'&');
        state = next_state;
        next_state = (enum __anonenum_html_state_22 )0;
      }
      break;
      case 11: ;
      if (value == 0) {
        if ((int )(*ptr) == 120) {
          hex___0 = 1;
          ptr ++;
        } else {
          if ((int )(*ptr) == 88) {
            hex___0 = 1;
            ptr ++;
          } else {
            goto _L___191;
          }
        }
      } else {
        _L___191: 
        if ((int )(*ptr) == 59) {
          html_output_c(file_buff_o1, file_buff_o2, (unsigned char )value);
          state = next_state;
          next_state = (enum __anonenum_html_state_22 )0;
          ptr ++;
        } else {
          tmp___714 = __ctype_b_loc();
          if ((int const   )(*((*tmp___714) + (int )(*ptr))) & 2048) {
            goto _L___190;
          } else {
            if (hex___0) {
              tmp___715 = __ctype_b_loc();
              if ((int const   )(*((*tmp___715) + (int )(*ptr))) & 4096) {
                _L___190: 
                if (hex___0) {
                  value *= 16;
                } else {
                  value *= 10;
                }
                tmp___713 = __ctype_b_loc();
                if ((int const   )(*((*tmp___713) + (int )(*ptr))) & 2048) {
                  value += (int )(*ptr) - 48;
                } else {
                  if (sizeof((*ptr)) > 1U) {
                    tmp___711 = __builtin_constant_p((int )(*ptr));
                    if (tmp___711) {
                      __c___9 = (int )(*ptr);
                      if (__c___9 < -128) {
                        __res___9 = __c___9;
                      } else {
                        if (__c___9 > 255) {
                          __res___9 = __c___9;
                        } else {
                          tmp___710 = __ctype_tolower_loc();
                          __res___9 = (*((*tmp___710) + __c___9));
                        }
                      }
                    } else {
                      __res___9 = tolower__extinline((int )(*ptr));
                    }
                  } else {
                    tmp___712 = __ctype_tolower_loc();
                    __res___9 = (*((*tmp___712) + (int )(*ptr)));
                  }
                  value += (__res___9 - 97) + 10;
                }
                ptr ++;
              } else {
                html_output_c(file_buff_o1, file_buff_o2, (unsigned char )value);
                state = next_state;
                next_state = (enum __anonenum_html_state_22 )0;
              }
            } else {
              html_output_c(file_buff_o1, file_buff_o2, (unsigned char )value);
              state = next_state;
              next_state = (enum __anonenum_html_state_22 )0;
            }
          }
        }
      }
      break;
      case 13: 
      tmp___868 = __builtin_constant_p((int )ptr);
      if (tmp___868) {
        tmp___869 = strlen((char const   *)ptr);
        if (tmp___869 < 4U) {
          goto _L___232;
        } else {
          goto _L___233;
        }
      } else {
        _L___233: 
        tmp___870 = __builtin_constant_p((int )"#@~^");
        if (tmp___870) {
          tmp___871 = strlen("#@~^");
          if (tmp___871 < 4U) {
            _L___232: 
            tmp___865 = __builtin_constant_p((int )ptr);
            if (tmp___865) {
              tmp___866 = __builtin_constant_p((int )"#@~^");
              if (tmp___866) {
                __s1_len___9 = strlen((char const   *)ptr);
                __s2_len___9 = strlen("#@~^");
                if (! ((unsigned int )((void const   *)(ptr + 1)) - (unsigned int )((void const   *)ptr) ==
                       1U)) {
                  goto _L___229;
                } else {
                  if (__s1_len___9 >= 4U) {
                    _L___229: 
                    if (! ((unsigned int )((void const   *)("#@~^" + 1)) - (unsigned int )((void const   *)"#@~^") ==
                           1U)) {
                      tmp___867 = 1;
                    } else {
                      if (__s2_len___9 >= 4U) {
                        tmp___867 = 1;
                      } else {
                        tmp___867 = 0;
                      }
                    }
                  } else {
                    tmp___867 = 0;
                  }
                }
                if (tmp___867) {
                  tmp___834 = __builtin_strcmp(ptr, "#@~^");
                } else {
                  goto _L___231;
                }
              } else {
                goto _L___231;
              }
            } else {
              _L___231: 
              tmp___864 = __builtin_constant_p((int )ptr);
              if (tmp___864) {
                if ((unsigned int )((void const   *)(ptr + 1)) - (unsigned int )((void const   *)ptr) ==
                    1U) {
                  __s1_len___9 = strlen((char const   *)ptr);
                  if (__s1_len___9 < 4U) {
                    tmp___853 = __builtin_constant_p((int )"#@~^");
                    if (tmp___853) {
                      if ((unsigned int )((void const   *)("#@~^" + 1)) - (unsigned int )((void const   *)"#@~^") ==
                          1U) {
                        tmp___834 = __builtin_strcmp(ptr, "#@~^");
                      } else {
                        goto _L___224;
                      }
                    } else {
                      _L___224: 
                      __s2___86 = (unsigned char const   *)"#@~^";
                      __result___258 = (int )((int const   )(*((unsigned char const   *)((char const   *)ptr) +
                                                               0)) - (int const   )(*(__s2___86 +
                                                                                      0)));
                      if (__s1_len___9 > 0U) {
                        if (__result___258 == 0) {
                          __result___258 = (int )((int const   )(*((unsigned char const   *)((char const   *)ptr) +
                                                                   1)) - (int const   )(*(__s2___86 +
                                                                                          1)));
                          if (__s1_len___9 > 1U) {
                            if (__result___258 == 0) {
                              __result___258 = (int )((int const   )(*((unsigned char const   *)((char const   *)ptr) +
                                                                       2)) - (int const   )(*(__s2___86 +
                                                                                              2)));
                              if (__s1_len___9 > 2U) {
                                if (__result___258 == 0) {
                                  __result___258 = (int )((int const   )(*((unsigned char const   *)((char const   *)ptr) +
                                                                           3)) - (int const   )(*(__s2___86 +
                                                                                                  3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___834 = __result___258;
                    }
                  } else {
                    goto _L___228;
                  }
                } else {
                  goto _L___228;
                }
              } else {
                _L___228: 
                tmp___863 = __builtin_constant_p((int )"#@~^");
                if (tmp___863) {
                  if ((unsigned int )((void const   *)("#@~^" + 1)) - (unsigned int )((void const   *)"#@~^") ==
                      1U) {
                    __s2_len___9 = strlen("#@~^");
                    if (__s2_len___9 < 4U) {
                      tmp___862 = __builtin_constant_p((int )ptr);
                      if (tmp___862) {
                        if ((unsigned int )((void const   *)(ptr + 1)) - (unsigned int )((void const   *)ptr) ==
                            1U) {
                          tmp___834 = __builtin_strcmp(ptr, "#@~^");
                        } else {
                          goto _L___226;
                        }
                      } else {
                        _L___226: 
                        __s1___174 = (unsigned char const   *)((char const   *)ptr);
                        __result___262 = (int )((int const   )(*(__s1___174 + 0)) -
                                                (int const   )(*((unsigned char const   *)"#@~^" +
                                                                 0)));
                        if (__s2_len___9 > 0U) {
                          if (__result___262 == 0) {
                            __result___262 = (int )((int const   )(*(__s1___174 +
                                                                     1)) - (int const   )(*((unsigned char const   *)"#@~^" +
                                                                                            1)));
                            if (__s2_len___9 > 1U) {
                              if (__result___262 == 0) {
                                __result___262 = (int )((int const   )(*(__s1___174 +
                                                                         2)) - (int const   )(*((unsigned char const   *)"#@~^" +
                                                                                                2)));
                                if (__s2_len___9 > 2U) {
                                  if (__result___262 == 0) {
                                    __result___262 = (int )((int const   )(*(__s1___174 +
                                                                             3)) -
                                                            (int const   )(*((unsigned char const   *)"#@~^" +
                                                                             3)));
                                  }
                                }
                              }
                            }
                          }
                        }
                        tmp___834 = __result___262;
                      }
                    } else {
                      tmp___834 = __builtin_strcmp(ptr, "#@~^");
                    }
                  } else {
                    tmp___834 = __builtin_strcmp(ptr, "#@~^");
                  }
                } else {
                  tmp___834 = __builtin_strcmp(ptr, "#@~^");
                }
              }
            }
            tmp___798 = tmp___834;
          } else {
            tmp___798 = strncmp((char const   *)ptr, "#@~^", 4U);
          }
        } else {
          tmp___798 = strncmp((char const   *)ptr, "#@~^", 4U);
        }
      }
      if (tmp___798 == 0) {
        ptr += 4;
        state = (enum __anonenum_html_state_22 )14;
        next_state = (enum __anonenum_html_state_22 )0;
      } else {
        if (sizeof((*ptr)) > 1U) {
          tmp___718 = __builtin_constant_p((int )(*ptr));
          if (tmp___718) {
            __c___10 = (int )(*ptr);
            if (__c___10 < -128) {
              __res___10 = __c___10;
            } else {
              if (__c___10 > 255) {
                __res___10 = __c___10;
              } else {
                tmp___717 = __ctype_tolower_loc();
                __res___10 = (*((*tmp___717) + __c___10));
              }
            }
          } else {
            __res___10 = tolower__extinline((int )(*ptr));
          }
        } else {
          tmp___719 = __ctype_tolower_loc();
          __res___10 = (*((*tmp___719) + (int )(*ptr)));
        }
        html_output_c(file_buff_o1, file_buff_o2, (unsigned char )__res___10);
        if (sizeof((*ptr)) > 1U) {
          tmp___722 = __builtin_constant_p((int )(*ptr));
          if (tmp___722) {
            __c___11 = (int )(*ptr);
            if (__c___11 < -128) {
              __res___11 = __c___11;
            } else {
              if (__c___11 > 255) {
                __res___11 = __c___11;
              } else {
                tmp___721 = __ctype_tolower_loc();
                __res___11 = (*((*tmp___721) + __c___11));
              }
            }
          } else {
            __res___11 = tolower__extinline((int )(*ptr));
          }
        } else {
          tmp___723 = __ctype_tolower_loc();
          __res___11 = (*((*tmp___723) + (int )(*ptr)));
        }
        html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char )__res___11);
        ptr ++;
      }
      break;
      case 14: 
      tmp___872 = strlen((char const   *)ptr);
      if (tmp___872 < 8U) {
        state = (enum __anonenum_html_state_22 )1;
        next_state = (enum __anonenum_html_state_22 )0;
        break;
      }
      length = (unsigned long )(base64_chars[(*(ptr + 0))] << 2);
      length += (unsigned long )(base64_chars[(*(ptr + 1))] >> 4);
      length += (unsigned long )((base64_chars[(*(ptr + 1))] & 15) << 12);
      length += (unsigned long )((base64_chars[(*(ptr + 2))] >> 2) << 8);
      length += (unsigned long )((base64_chars[(*(ptr + 2))] & 3) << 22);
      length += (unsigned long )(base64_chars[(*(ptr + 3))] << 16);
      length += (unsigned long )((base64_chars[(*(ptr + 4))] << 2) << 24);
      length += (unsigned long )((base64_chars[(*(ptr + 5))] >> 4) << 24);
      table_pos = 0;
      state = (enum __anonenum_html_state_22 )15;
      next_state = (enum __anonenum_html_state_22 )0;
      ptr += 8;
      break;
      case 15: ;
      if (length == 0UL) {
        html_output_str(file_buff_script, (unsigned char *)"</script>\n", 10);
        length = 12UL;
        state = (enum __anonenum_html_state_22 )12;
        next_state = (enum __anonenum_html_state_22 )1;
        break;
      }
      if ((int )(*ptr) < 128) {
        value = decrypt_tables[table_order[table_pos]][(*ptr)];
        if (value == 255) {
          ptr ++;
          length --;
          switch ((int )(*ptr)) {
          case 0: 
          ptr --;
          break;
          case 33: 
          html_output_c(file_buff_o1, file_buff_o2, (unsigned char)60);
          html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char)60);
          break;
          case 35: 
          html_output_c(file_buff_o1, file_buff_o2, (unsigned char)13);
          html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char)13);
          break;
          case 36: 
          html_output_c(file_buff_o1, file_buff_o2, (unsigned char)64);
          html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char)64);
          break;
          case 38: 
          html_output_c(file_buff_o1, file_buff_o2, (unsigned char)10);
          html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char)10);
          break;
          case 42: 
          html_output_c(file_buff_o1, file_buff_o2, (unsigned char)62);
          html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char)62);
          break;
          }
        } else {
          html_output_c(file_buff_o1, file_buff_o2, (unsigned char )value);
          if (sizeof(value) > 1U) {
            tmp___875 = __builtin_constant_p(value);
            if (tmp___875) {
              __c___12 = value;
              if (__c___12 < -128) {
                __res___12 = __c___12;
              } else {
                if (__c___12 > 255) {
                  __res___12 = __c___12;
                } else {
                  tmp___874 = __ctype_tolower_loc();
                  __res___12 = (*((*tmp___874) + __c___12));
                }
              }
            } else {
              __res___12 = tolower__extinline(value);
            }
          } else {
            tmp___876 = __ctype_tolower_loc();
            __res___12 = (*((*tmp___876) + value));
          }
          html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char )__res___12);
        }
      }
      table_pos = (table_pos + 1) % 64;
      ptr ++;
      length --;
      break;
      case 17: ;
      if ((int )(*ptr) == 39) {
        if (! escape) {
          if ((int )quoted == 0) {
            ptr ++;
            state = (enum __anonenum_html_state_22 )4;
            tag_arg_length = 0;
            next_state = (enum __anonenum_html_state_22 )7;
          } else {
            goto _L___234;
          }
        } else {
          _L___234: 
          if (tag_val_length < 1024) {
            tmp___877 = tag_val_length;
            tag_val_length ++;
            tag_val[tmp___877] = (char )'\"';
          }
          ptr ++;
        }
      } else {
        if ((int )(*ptr) == 34) {
          if (! escape) {
            if ((int )quoted == 1) {
              ptr ++;
              state = (enum __anonenum_html_state_22 )4;
              tag_arg_length = 0;
              next_state = (enum __anonenum_html_state_22 )7;
            } else {
              goto _L___235;
            }
          } else {
            _L___235: 
            if (tag_val_length < 1024) {
              tmp___878 = tag_val_length;
              tag_val_length ++;
              tag_val[tmp___878] = (char )'\"';
            }
            ptr ++;
          }
        } else {
          tmp___887 = __ctype_b_loc();
          if ((int const   )(*((*tmp___887) + (int )(*ptr))) & 8192) {
            goto _L___236;
          } else {
            if ((int )(*ptr) == 62) {
              _L___236: 
              if ((int )quoted == 2) {
                state = (enum __anonenum_html_state_22 )4;
                tag_arg_length = 0;
                next_state = (enum __anonenum_html_state_22 )7;
              } else {
                if (tag_val_length < 1024) {
                  tmp___881 = __ctype_b_loc();
                  if ((int const   )(*((*tmp___881) + (int )(*ptr))) & 8192) {
                    tmp___879 = tag_val_length;
                    tag_val_length ++;
                    tag_val[tmp___879] = (char )' ';
                  } else {
                    tmp___880 = tag_val_length;
                    tag_val_length ++;
                    tag_val[tmp___880] = (char )'>';
                  }
                }
                state = (enum __anonenum_html_state_22 )4;
                escape = 0;
                quoted = (enum __anonenum_quoted_state_23 )2;
                next_state = (enum __anonenum_html_state_22 )17;
                ptr ++;
              }
            } else {
              if ((int )(*ptr) == 44) {
                tag_val[tag_val_length] = (char )'\000';
                state = (enum __anonenum_html_state_22 )18;
                escape = 0;
                next_state = (enum __anonenum_html_state_22 )0;
                ptr ++;
              } else {
                if (tag_val_length < 1024) {
                  tmp___882 = tag_val_length;
                  tag_val_length ++;
                  if (sizeof((*ptr)) > 1U) {
                    tmp___885 = __builtin_constant_p((int )(*ptr));
                    if (tmp___885) {
                      __c___13 = (int )(*ptr);
                      if (__c___13 < -128) {
                        __res___13 = __c___13;
                      } else {
                        if (__c___13 > 255) {
                          __res___13 = __c___13;
                        } else {
                          tmp___884 = __ctype_tolower_loc();
                          __res___13 = (*((*tmp___884) + __c___13));
                        }
                      }
                    } else {
                      __res___13 = tolower__extinline((int )(*ptr));
                    }
                  } else {
                    tmp___886 = __ctype_tolower_loc();
                    __res___13 = (*((*tmp___886) + (int )(*ptr)));
                  }
                  tag_val[tmp___882] = (char )__res___13;
                }
                ptr ++;
              }
            }
          }
        }
      }
      if ((int )(*ptr) == 92) {
        escape = 1;
      } else {
        escape = 0;
      }
      break;
      case 18: 
      file_tmp_o1 = (file_buff_t *)cli_malloc(sizeof(file_buff_t ));
      if (! file_tmp_o1) {
        goto abort;
      }
      snprintf((char * __restrict  )(filename), 1024U, (char const   * __restrict  )"%s/rfc2397",
               dirname);
      tmp_file = cli_gentemp((char const   *)(filename));
      cli_dbgmsg("RFC2397 data file: %s\n", tmp_file);
      file_tmp_o1->fd = open((char const   *)tmp_file, 577, 384);
      free((void *)tmp_file);
      if (! file_tmp_o1->fd) {
        cli_dbgmsg("open failed: %s\n", filename);
        free((void *)file_tmp_o1);
        goto abort;
      }
      file_tmp_o1->length = 0;
      html_output_str(file_tmp_o1, (unsigned char *)"From html-normalise\n", 20);
      html_output_str(file_tmp_o1, (unsigned char *)"Content-type: ", 14);
      if (tag_val_length == 0) {
        if ((int )tag_val[0] == 59) {
          html_output_str(file_tmp_o1, (unsigned char *)"text/plain\n", 11);
        }
      }
      html_output_str(file_tmp_o1, (unsigned char *)(tag_val), tag_val_length);
      html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (unsigned char )'\n');
      tmp___889 = strstr((char const   *)(tag_val), ";base64");
      if ((unsigned int )tmp___889 != (unsigned int )((void *)0)) {
        html_output_str(file_tmp_o1, (unsigned char *)"Content-transfer-encoding: base64\n",
                        34);
      }
      html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (unsigned char )'\n');
      state = (enum __anonenum_html_state_22 )19;
      binary = 1;
      break;
      case 19: ;
      if ((int )(*ptr) == 38) {
        state = (enum __anonenum_html_state_22 )3;
        next_state = (enum __anonenum_html_state_22 )19;
        ptr ++;
      } else {
        if ((int )(*ptr) == 37) {
          length = 0UL;
          value = 0;
          state = (enum __anonenum_html_state_22 )22;
          next_state = (enum __anonenum_html_state_22 )21;
          ptr ++;
        } else {
          if ((int )(*ptr) == 39) {
            if (! escape) {
              if ((int )quoted == 0) {
                state = (enum __anonenum_html_state_22 )20;
                ptr ++;
              } else {
                html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (*ptr));
                ptr ++;
              }
            } else {
              html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (*ptr));
              ptr ++;
            }
          } else {
            if ((int )(*ptr) == 34) {
              if (! escape) {
                quoted = (enum __anonenum_quoted_state_23 )1;
                if (quoted) {
                  state = (enum __anonenum_html_state_22 )20;
                  ptr ++;
                } else {
                  html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (*ptr));
                  ptr ++;
                }
              } else {
                html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (*ptr));
                ptr ++;
              }
            } else {
              tmp___890 = __ctype_b_loc();
              if ((int const   )(*((*tmp___890) + (int )(*ptr))) & 8192) {
                goto _L___237;
              } else {
                if ((int )(*ptr) == 62) {
                  _L___237: 
                  if ((int )quoted == 2) {
                    state = (enum __anonenum_html_state_22 )20;
                    ptr ++;
                  } else {
                    html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (*ptr));
                    ptr ++;
                  }
                } else {
                  html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (*ptr));
                  ptr ++;
                }
              }
            }
          }
        }
      }
      if ((int )(*ptr) == 92) {
        escape = 1;
      } else {
        escape = 0;
      }
      break;
      case 20: 
      html_output_flush(file_tmp_o1);
      close(file_tmp_o1->fd);
      free((void *)file_tmp_o1);
      state = (enum __anonenum_html_state_22 )4;
      escape = 0;
      quoted = (enum __anonenum_quoted_state_23 )2;
      next_state = (enum __anonenum_html_state_22 )7;
      binary = 0;
      break;
      case 21: ;
      if (length == 2UL) {
        html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (unsigned char )value);
      } else {
        if (length == 1UL) {
          html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (unsigned char )'%');
          html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (unsigned char )(value +
                                                                                  48));
        } else {
          html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (unsigned char )'%');
        }
      }
      state = (enum __anonenum_html_state_22 )19;
      break;
      case 22: 
      value *= 16;
      length ++;
      tmp___896 = __ctype_b_loc();
      if ((int const   )(*((*tmp___896) + (int )(*ptr))) & 4096) {
        tmp___895 = __ctype_b_loc();
        if ((int const   )(*((*tmp___895) + (int )(*ptr))) & 2048) {
          value += (int )(*ptr) - 48;
        } else {
          if (sizeof((*ptr)) > 1U) {
            tmp___893 = __builtin_constant_p((int )(*ptr));
            if (tmp___893) {
              __c___14 = (int )(*ptr);
              if (__c___14 < -128) {
                __res___14 = __c___14;
              } else {
                if (__c___14 > 255) {
                  __res___14 = __c___14;
                } else {
                  tmp___892 = __ctype_tolower_loc();
                  __res___14 = (*((*tmp___892) + __c___14));
                }
              }
            } else {
              __res___14 = tolower__extinline((int )(*ptr));
            }
          } else {
            tmp___894 = __ctype_tolower_loc();
            __res___14 = (*((*tmp___894) + (int )(*ptr)));
          }
          value += (__res___14 - 97) + 10;
        }
      } else {
        state = next_state;
      }
      if (length == 2UL) {
        state = next_state;
      }
      ptr ++;
      break;
      }
    }
    free((void *)line);
    line = cli_readline(stream_in, m_area, 8192U);
    ptr = line;
  }
  retval = 1;
  abort: 
  html_tag_arg_free(& tag_args);
  if (! m_area) {
    fclose(stream_in);
  }
  if (file_buff_o1) {
    html_output_flush(file_buff_o1);
    close(file_buff_o1->fd);
    free((void *)file_buff_o1);
  }
  if (file_buff_o2) {
    html_output_flush(file_buff_o2);
    close(file_buff_o2->fd);
    free((void *)file_buff_o2);
  }
  if (file_buff_script) {
    html_output_flush(file_buff_script);
    close(file_buff_script->fd);
    free((void *)file_buff_script);
  }
  return (retval);
}
}
int html_normalise_mem(unsigned char *in_buff , off_t in_size , char const   *dirname ,
                       tag_arguments_t *hrefs ) 
{ m_area_t m_area ;
  int tmp ;

  {
  m_area.buffer = in_buff;
  m_area.length = in_size;
  m_area.offset = 0L;
  tmp = cli_html_normalise(-1, & m_area, dirname, hrefs);
  return (tmp);
}
}
int html_normalise_fd(int fd , char const   *dirname , tag_arguments_t *hrefs ) 
{ int retval ;
  m_area_t m_area ;
  struct stat statbuf ;
  int tmp___0 ;

  {
  retval = 0;
  tmp___0 = fstat__extinline(fd, & statbuf);
  if (tmp___0 == 0) {
    m_area.length = statbuf.st_size;
    m_area.buffer = (unsigned char *)mmap((void *)0, (unsigned int )m_area.length,
                                          1, 2, fd, 0L);
    m_area.offset = 0L;
    if ((unsigned int )m_area.buffer == (unsigned int )((void *)-1)) {
      cli_dbgmsg("mmap HTML failed\n");
      retval = cli_html_normalise(fd, (m_area_t *)((void *)0), dirname, hrefs);
    } else {
      cli_dbgmsg("mmap\'ed file\n");
      retval = cli_html_normalise(-1, & m_area, dirname, hrefs);
      munmap((void *)m_area.buffer, (unsigned int )m_area.length);
    }
  } else {
    cli_dbgmsg("fstat HTML failed\n");
    retval = cli_html_normalise(fd, (m_area_t *)((void *)0), dirname, hrefs);
  }
  return (retval);
}
}
int html_screnc_decode(int fd , char const   *dirname ) 
{ int fd_tmp ;
  int table_pos ;
  int result ;
  int count ;
  int state ;
  int retval ;
  unsigned char *line ;
  unsigned char tmpstr[6] ;
  unsigned long length ;
  unsigned char *ptr ;
  unsigned char filename[1024] ;
  FILE *stream_in ;
  file_buff_t file_buff ;
  int tmp ;

  {
  table_pos = 0;
  retval = 0;
  lseek(fd, 0L, 0);
  fd_tmp = dup(fd);
  if (fd_tmp < 0) {
    return (0);
  }
  stream_in = fdopen(fd_tmp, "r");
  if (! stream_in) {
    close(fd_tmp);
    return (0);
  }
  snprintf((char * __restrict  )(filename), 1024U, (char const   * __restrict  )"%s/screnc.html",
           dirname);
  file_buff.fd = open((char const   *)(filename), 577, 384);
  file_buff.length = 0;
  if (! file_buff.fd) {
    cli_dbgmsg("open failed: %s\n", filename);
    fclose(stream_in);
    return (0);
  }
  while (1) {
    line = cli_readline(stream_in, (m_area_t *)((void *)0), 8192U);
    if (! ((unsigned int )line != (unsigned int )((void *)0))) {
      break;
    }
    ptr = (unsigned char *)strstr((char const   *)line, "#@~^");
    if (ptr) {
      break;
    }
    free((void *)line);
  }
  if (! line) {
    goto abort;
  }
  ptr += 4;
  count = 0;
  while (1) {
    if (! (*ptr)) {
      free((void *)line);
      line = cli_readline(stream_in, (m_area_t *)((void *)0), 8192U);
      ptr = line;
      if (! line) {
        goto abort;
      }
    }
    tmp = count;
    count ++;
    tmpstr[tmp] = (*ptr);
    ptr ++;
    if (! (count < 6)) {
      break;
    }
  }
  length = (unsigned long )(base64_chars[tmpstr[0]] << 2);
  length += (unsigned long )(base64_chars[tmpstr[1]] >> 4);
  length += (unsigned long )((base64_chars[tmpstr[1]] & 15) << 12);
  length += (unsigned long )((base64_chars[tmpstr[2]] >> 2) << 8);
  length += (unsigned long )((base64_chars[tmpstr[2]] & 3) << 22);
  length += (unsigned long )(base64_chars[tmpstr[3]] << 16);
  length += (unsigned long )((base64_chars[tmpstr[4]] << 2) << 24);
  length += (unsigned long )((base64_chars[tmpstr[5]] >> 4) << 24);
  count = 2;
  state = 12;
  while (1) {
    if (length) {
      if (! line) {
        break;
      }
    } else {
      break;
    }
    while (1) {
      if (length) {
        if (! (*ptr)) {
          break;
        }
      } else {
        break;
      }
      if ((int )(*ptr) == 10) {
        ptr ++;
        continue;
      } else {
        if ((int )(*ptr) == 13) {
          ptr ++;
          continue;
        }
      }
      switch (state) {
      case 12: 
      ptr ++;
      count --;
      if (count == 0) {
        state = 1;
      }
      break;
      case 16: ;
      switch ((int )(*ptr)) {
      case 33: 
      html_output_c(& file_buff, (file_buff_t *)((void *)0), (unsigned char)60);
      break;
      case 35: 
      html_output_c(& file_buff, (file_buff_t *)((void *)0), (unsigned char)13);
      break;
      case 36: 
      html_output_c(& file_buff, (file_buff_t *)((void *)0), (unsigned char)64);
      break;
      case 38: 
      html_output_c(& file_buff, (file_buff_t *)((void *)0), (unsigned char)10);
      break;
      case 42: 
      html_output_c(& file_buff, (file_buff_t *)((void *)0), (unsigned char)62);
      break;
      }
      ptr ++;
      length --;
      state = 1;
      break;
      case 1: ;
      if ((int )(*ptr) < 128) {
        result = decrypt_tables[table_order[table_pos]][(*ptr)];
        if (result == 255) {
          state = 16;
        } else {
          html_output_c(& file_buff, (file_buff_t *)((void *)0), (unsigned char )((char )result));
        }
      }
      ptr ++;
      length --;
      table_pos = (table_pos + 1) % 64;
      break;
      }
    }
    free((void *)line);
    if (length) {
      line = cli_readline(stream_in, (m_area_t *)((void *)0), 8192U);
      ptr = line;
    }
  }
  retval = 1;
  abort: 
  fclose(stream_in);
  html_output_flush(& file_buff);
  close(file_buff.fd);
  return (retval);
}
}
#pragma merger(0,"/tmp/cil-YPKBeo6X.i","-g -O2 -fPIC")
static uint32_t chm_endian_convert_32(uint32_t v ) 
{ 

  {
  return ((((v >> 24) | ((v & 16711680U) >> 8)) | ((v & 65280U) << 8)) | (v << 24));
}
}
static uint64_t chm_endian_convert_64(uint64_t v ) 
{ 

  {
  return ((((((((v >> 56) | ((v & 71776119061217280ULL) >> 40)) | ((v & 280375465082880ULL) >>
                                                                   24)) | ((v & 1095216660480ULL) >>
                                                                           8)) | ((v &
                                                                                   4278190080ULL) <<
                                                                                  8)) |
            ((v & 16711680ULL) << 24)) | ((v & 65280ULL) << 40)) | (v << 56));
}
}
int chm_read_data(int fd , unsigned char *dest , off_t offset , off_t len , unsigned char *m_area ,
                  off_t m_length ) 
{ __off_t tmp ;
  int tmp___0 ;

  {
  if (offset < 0L) {
    return (0);
  } else {
    if (len < 0L) {
      return (0);
    } else {
      if (offset + len < 0L) {
        return (0);
      }
    }
  }
  if ((unsigned int )m_area != (unsigned int )((void *)0)) {
    if (offset + len > m_length) {
      return (0);
    }
    memcpy((void * __restrict  )dest, (void const   * __restrict  )(m_area + offset),
           (unsigned int )len);
  } else {
    tmp = lseek(fd, offset, 0);
    if (tmp != offset) {
      return (0);
    }
    tmp___0 = cli_readn(fd, (void *)dest, (unsigned int )len);
    if ((long )tmp___0 != len) {
      return (0);
    }
  }
  return (1);
}
}
uint64_t chm_copy_file_data(int ifd , int ofd , uint64_t len ) 
{ unsigned char data[8192] ;
  uint64_t count ;
  uint64_t rem ;
  unsigned int todo ;
  int tmp ;

  {
  rem = len;
  while (rem > 0ULL) {
    if (8192ULL < rem) {
      todo = 8192U;
    } else {
      todo = (unsigned int )rem;
    }
    count = (uint64_t )cli_readn(ifd, (void *)(data), todo);
    if (count != (unsigned long long )todo) {
      return (len - rem);
    }
    tmp = cli_writen(ofd, (void *)(data), (unsigned int )count);
    if ((long long )tmp != (long long )count) {
      return ((len - rem) - count);
    }
    rem -= count;
  }
  return (len);
}
}
static void free_file_list(file_list_t *file_l ) 
{ file_list_t *next ;

  {
  while (file_l) {
    next = file_l->next;
    if (file_l->name) {
      free((void *)file_l->name);
    }
    free((void *)file_l);
    file_l = next;
  }
  return;
}
}
static void itsf_print_header(itsf_header_t *itsf_hdr ) 
{ 

  {
  if (! itsf_hdr) {
    return;
  }
  cli_dbgmsg("---- ITSF ----\n");
  cli_dbgmsg("Signature:\t%c%c%c%c\n", itsf_hdr->signature[0], itsf_hdr->signature[1],
             itsf_hdr->signature[2], itsf_hdr->signature[3]);
  cli_dbgmsg("Version:\t%d\n", itsf_hdr->version);
  cli_dbgmsg("Header len:\t%ld\n", itsf_hdr->header_len);
  cli_dbgmsg("Lang ID:\t%d\n", itsf_hdr->lang_id);
  cli_dbgmsg("Sec0 offset:\t%llu\n", itsf_hdr->sec0_offset);
  cli_dbgmsg("Sec0 len:\t%llu\n", itsf_hdr->sec0_len);
  cli_dbgmsg("Dir offset:\t%llu\n", itsf_hdr->dir_offset);
  cli_dbgmsg("Dir len:\t%llu\n", itsf_hdr->dir_len);
  if (itsf_hdr->version > 2) {
    cli_dbgmsg("Data offset:\t%llu\n\n", itsf_hdr->data_offset);
  }
  return;
}
}
static int itsf_read_header(int fd , itsf_header_t *itsf_hdr , unsigned char *m_area ,
                            off_t m_length ) 
{ int tmp ;
  int tmp___0 ;

  {
  tmp = chm_read_data(fd, (unsigned char *)itsf_hdr, 0L, 96L, m_area, m_length);
  if (! tmp) {
    return (0);
  }
  tmp___0 = memcmp((void const   *)(itsf_hdr->signature), (void const   *)"ITSF",
                   4U);
  if (tmp___0 != 0) {
    cli_dbgmsg("ITSF signature mismatch\n");
    return (0);
  }
  itsf_hdr->version = (int32_t )chm_endian_convert_32((unsigned int )itsf_hdr->version);
  itsf_hdr->header_len = (int32_t )chm_endian_convert_32((unsigned int )itsf_hdr->header_len);
  itsf_hdr->last_modified = chm_endian_convert_32(itsf_hdr->last_modified);
  itsf_hdr->lang_id = chm_endian_convert_32(itsf_hdr->lang_id);
  itsf_hdr->sec0_offset = chm_endian_convert_64(itsf_hdr->sec0_offset);
  itsf_hdr->sec0_len = chm_endian_convert_64(itsf_hdr->sec0_len);
  itsf_hdr->dir_offset = chm_endian_convert_64(itsf_hdr->dir_offset);
  itsf_hdr->dir_len = chm_endian_convert_64(itsf_hdr->dir_len);
  if (itsf_hdr->version > 2) {
    itsf_hdr->data_offset = chm_endian_convert_64(itsf_hdr->data_offset);
  }
  return (1);
}
}
static void itsp_print_header(itsp_header_t *itsp_hdr ) 
{ 

  {
  if (! itsp_hdr) {
    return;
  }
  cli_dbgmsg("---- ITSP ----\n");
  cli_dbgmsg("Signature:\t%c%c%c%c\n", itsp_hdr->signature[0], itsp_hdr->signature[1],
             itsp_hdr->signature[2], itsp_hdr->signature[3]);
  cli_dbgmsg("Version:\t%d\n", itsp_hdr->version);
  cli_dbgmsg("Block len:\t%ld\n", itsp_hdr->block_len);
  cli_dbgmsg("Block idx int:\t%d\n", itsp_hdr->blockidx_intvl);
  cli_dbgmsg("Index depth:\t%d\n", itsp_hdr->index_depth);
  cli_dbgmsg("Index root:\t%d\n", itsp_hdr->index_root);
  cli_dbgmsg("Index head:\t%u\n", itsp_hdr->index_head);
  cli_dbgmsg("Index tail:\t%u\n", itsp_hdr->index_tail);
  cli_dbgmsg("Num Blocks:\t%u\n", itsp_hdr->num_blocks);
  cli_dbgmsg("Lang ID:\t%lu\n\n", itsp_hdr->lang_id);
  return;
}
}
static int itsp_read_header(int fd , itsp_header_t *itsp_hdr , off_t offset , unsigned char *m_area ,
                            off_t m_length ) 
{ int tmp ;
  int tmp___0 ;

  {
  tmp = chm_read_data(fd, (unsigned char *)itsp_hdr, offset, 84L, m_area, m_length);
  if (! tmp) {
    return (0);
  }
  tmp___0 = memcmp((void const   *)(itsp_hdr->signature), (void const   *)"ITSP",
                   4U);
  if (tmp___0 != 0) {
    cli_dbgmsg("ITSP signature mismatch\n");
    return (0);
  }
  itsp_hdr->version = (int32_t )chm_endian_convert_32((unsigned int )itsp_hdr->version);
  itsp_hdr->header_len = (int32_t )chm_endian_convert_32((unsigned int )itsp_hdr->header_len);
  itsp_hdr->block_len = chm_endian_convert_32(itsp_hdr->block_len);
  itsp_hdr->blockidx_intvl = (int32_t )chm_endian_convert_32((unsigned int )itsp_hdr->blockidx_intvl);
  itsp_hdr->index_depth = (int32_t )chm_endian_convert_32((unsigned int )itsp_hdr->index_depth);
  itsp_hdr->index_root = (int32_t )chm_endian_convert_32((unsigned int )itsp_hdr->index_root);
  itsp_hdr->index_head = (int32_t )chm_endian_convert_32((unsigned int )itsp_hdr->index_head);
  itsp_hdr->index_tail = (int32_t )chm_endian_convert_32((unsigned int )itsp_hdr->index_tail);
  itsp_hdr->num_blocks = chm_endian_convert_32(itsp_hdr->num_blocks);
  itsp_hdr->lang_id = chm_endian_convert_32(itsp_hdr->lang_id);
  if (itsp_hdr->version != 1) {
    cli_dbgmsg("ITSP header mismatch\n");
    return (0);
  } else {
    if (itsp_hdr->header_len != 84) {
      cli_dbgmsg("ITSP header mismatch\n");
      return (0);
    }
  }
  return (1);
}
}
static uint64_t read_enc_int(unsigned char **start , unsigned char *end ) 
{ uint64_t retval ;
  unsigned char *current ;
  unsigned char *tmp ;

  {
  retval = 0ULL;
  current = (*start);
  if ((unsigned int )current > (unsigned int )end) {
    return (0ULL);
  }
  while (1) {
    if ((unsigned int )current > (unsigned int )end) {
      return (0ULL);
    }
    retval = (retval << 7) | (unsigned long long )((int )(*current) & 127);
    tmp = current;
    current ++;
    if (! ((int )(*tmp) & 128)) {
      break;
    }
  }
  (*start) = current;
  return (retval);
}
}
static int read_chunk_entries(unsigned char *chunk , uint32_t chunk_len , uint16_t num_entries ,
                              file_list_t *file_l , file_list_t *sys_file_l ) 
{ unsigned char *current ;
  unsigned char *end ;
  uint64_t name_len ;
  file_list_t *file_e ;
  uint16_t tmp___1 ;

  {
  end = chunk + chunk_len;
  current = chunk + 20;
  while (1) {
    tmp___1 = num_entries;
    num_entries = (unsigned short )((int )num_entries - 1);
    if (! tmp___1) {
      break;
    }
    if ((unsigned int )current > (unsigned int )end) {
      cli_dbgmsg("read chunk entries failed\n");
      return (0);
    }
    file_e = (file_list_t *)cli_malloc(sizeof(file_list_t ));
    if (! file_e) {
      return (0);
    }
    file_e->next = (struct file_list_tag *)((void *)0);
    name_len = read_enc_int(& current, end);
    file_e->name = (unsigned char *)cli_malloc((unsigned int )(name_len + 1ULL));
    if (! file_e->name) {
      free((void *)file_e);
      return (0);
    }
    __builtin_strncpy(file_e->name, current, name_len);
    (*(file_e->name + name_len)) = (unsigned char )'\000';
    current += name_len;
    file_e->section = read_enc_int(& current, end);
    file_e->offset = read_enc_int(& current, end);
    file_e->length = read_enc_int(& current, end);
    if (name_len >= 2ULL) {
      if ((int )(*(file_e->name + 0)) == 58) {
        if ((int )(*(file_e->name + 1)) == 58) {
          file_e->next = sys_file_l->next;
          sys_file_l->next = file_e;
        } else {
          file_e->next = file_l->next;
          file_l->next = file_e;
        }
      } else {
        file_e->next = file_l->next;
        file_l->next = file_e;
      }
    } else {
      file_e->next = file_l->next;
      file_l->next = file_e;
    }
    cli_dbgmsg("Section: %llu Offset: %llu Length: %llu, Name: %s\n", file_e->section,
               file_e->offset, file_e->length, file_e->name);
  }
  return (1);
}
}
static void print_chunk(chunk_header_t *chunk ) 
{ int tmp ;

  {
  cli_dbgmsg("---- Chunk ----\n");
  cli_dbgmsg("Signature:\t%c%c%c%c\n", chunk->signature[0], chunk->signature[1], chunk->signature[2],
             chunk->signature[3]);
  cli_dbgmsg("Free Space:\t%u\n", chunk->free_space);
  tmp = memcmp((void const   *)(chunk->signature), (void const   *)"PMGL", 4U);
  if (tmp == 0) {
    cli_dbgmsg("Prev Block:\t%d\n", chunk->block_prev);
    cli_dbgmsg("Next Block:\t%d\n", chunk->block_next);
    cli_dbgmsg("Num entries:\t%d\n\n", chunk->num_entries);
  }
  return;
}
}
static int read_chunk(int fd , off_t offset , uint32_t chunk_len , unsigned char *m_area ,
                      off_t m_length , file_list_t *file_l , file_list_t *sys_file_l ) 
{ chunk_header_t *chunk_hdr ;
  int retval ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  retval = 0;
  if (chunk_len < 8U) {
    return (0);
  } else {
    if (chunk_len > 33554432U) {
      return (0);
    }
  }
  chunk_hdr = (chunk_header_t *)cli_malloc(sizeof(chunk_header_t ));
  if (! chunk_hdr) {
    return (0);
  }
  chunk_hdr->chunk_data = (unsigned char *)cli_malloc(chunk_len);
  if (! chunk_hdr->chunk_data) {
    free((void *)chunk_hdr);
    return (0);
  }
  tmp___1 = chm_read_data(fd, chunk_hdr->signature, offset, 8L, m_area, m_length);
  if (! tmp___1) {
    goto abort;
  }
  tmp___2 = chm_read_data(fd, chunk_hdr->chunk_data, offset, (long )chunk_len, m_area,
                          m_length);
  if (! tmp___2) {
    goto abort;
  }
  chunk_hdr->free_space = chm_endian_convert_32(chunk_hdr->free_space);
  tmp___5 = memcmp((void const   *)(chunk_hdr->signature), (void const   *)"PMGL",
                   4U);
  if (tmp___5 == 0) {
    tmp___3 = chm_read_data(fd, (unsigned char *)(& chunk_hdr->unknown), offset +
                                                                         8L, 12L,
                            m_area, m_length);
    if (! tmp___3) {
      goto abort;
    }
    chunk_hdr->block_next = (int32_t )chm_endian_convert_32((unsigned int )chunk_hdr->block_next);
    chunk_hdr->block_prev = (int32_t )chm_endian_convert_32((unsigned int )chunk_hdr->block_prev);
    chunk_hdr->num_entries = (unsigned short )(((int const   )(*((uint8_t const   *)chunk_hdr->chunk_data +
                                                                 (chunk_len - 2U))) <<
                                                0) | ((int const   )(*((uint8_t const   *)chunk_hdr->chunk_data +
                                                                       (chunk_len -
                                                                        1U))) << 8));
    read_chunk_entries(chunk_hdr->chunk_data, chunk_len, chunk_hdr->num_entries, file_l,
                       sys_file_l);
  } else {
    tmp___4 = memcmp((void const   *)(chunk_hdr->signature), (void const   *)"PMGI",
                     4U);
    if (tmp___4 != 0) {
      goto abort;
    }
  }
  print_chunk(chunk_hdr);
  retval = 1;
  abort: 
  free((void *)chunk_hdr->chunk_data);
  free((void *)chunk_hdr);
  return (retval);
}
}
static void print_sys_control(lzx_control_t *lzx_control ) 
{ 

  {
  if (! lzx_control) {
    return;
  }
  cli_dbgmsg("---- Control ----\n");
  cli_dbgmsg("Length:\t\t%lu\n", lzx_control->length);
  cli_dbgmsg("Signature:\t%c%c%c%c\n", lzx_control->signature[0], lzx_control->signature[1],
             lzx_control->signature[2], lzx_control->signature[3]);
  cli_dbgmsg("Version:\t%d\n", lzx_control->version);
  cli_dbgmsg("Reset Interval:\t%d\n", lzx_control->reset_interval);
  cli_dbgmsg("Window Size:\t%d\n", lzx_control->window_size);
  cli_dbgmsg("Cache Size:\t%d\n\n", lzx_control->cache_size);
  return;
}
}
static lzx_control_t *read_sys_control(int fd , itsf_header_t *itsf_hdr , file_list_t *file_e ,
                                       unsigned char *m_area , off_t m_length ) 
{ off_t offset ;
  lzx_control_t *lzx_control ;
  int tmp___0 ;
  int tmp___75 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___111 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___130 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  size_t tmp___146 ;
  int tmp___147 ;
  size_t tmp___148 ;

  {
  if (file_e->length != 28ULL) {
    return ((lzx_control_t *)((void *)0));
  }
  offset = (long )(itsf_hdr->data_offset + file_e->offset);
  if (offset < 0L) {
    return ((lzx_control_t *)((void *)0));
  }
  lzx_control = (lzx_control_t *)cli_malloc(sizeof(lzx_control_t ));
  if (! lzx_control) {
    return ((lzx_control_t *)((void *)0));
  }
  tmp___0 = chm_read_data(fd, (unsigned char *)lzx_control, offset, 24L, m_area, m_length);
  if (! tmp___0) {
    goto abort;
  }
  lzx_control->length = chm_endian_convert_32(lzx_control->length);
  lzx_control->version = chm_endian_convert_32(lzx_control->version);
  lzx_control->reset_interval = chm_endian_convert_32(lzx_control->reset_interval);
  lzx_control->window_size = chm_endian_convert_32(lzx_control->window_size);
  lzx_control->cache_size = chm_endian_convert_32(lzx_control->cache_size);
  tmp___145 = __builtin_constant_p((int )"LZXC");
  if (tmp___145) {
    tmp___146 = strlen("LZXC");
    if (tmp___146 < 4U) {
      goto _L___39;
    } else {
      goto _L___40;
    }
  } else {
    _L___40: 
    tmp___147 = __builtin_constant_p((int )(lzx_control->signature));
    if (tmp___147) {
      tmp___148 = strlen((char const   *)(lzx_control->signature));
      if (tmp___148 < 4U) {
        _L___39: 
        tmp___142 = __builtin_constant_p((int )"LZXC");
        if (tmp___142) {
          tmp___143 = __builtin_constant_p((int )(lzx_control->signature));
          if (tmp___143) {
            __s1_len___0 = strlen("LZXC");
            __s2_len___0 = strlen((char const   *)(lzx_control->signature));
            if (! ((unsigned int )((void const   *)("LZXC" + 1)) - (unsigned int )((void const   *)"LZXC") ==
                   1U)) {
              goto _L___36;
            } else {
              if (__s1_len___0 >= 4U) {
                _L___36: 
                if (! ((unsigned int )((void const   *)(lzx_control->signature + 1)) -
                       (unsigned int )((void const   *)(lzx_control->signature)) ==
                       1U)) {
                  tmp___144 = 1;
                } else {
                  if (__s2_len___0 >= 4U) {
                    tmp___144 = 1;
                  } else {
                    tmp___144 = 0;
                  }
                }
              } else {
                tmp___144 = 0;
              }
            }
            if (tmp___144) {
              tmp___111 = __builtin_strcmp("LZXC", lzx_control->signature);
            } else {
              goto _L___38;
            }
          } else {
            goto _L___38;
          }
        } else {
          _L___38: 
          tmp___141 = __builtin_constant_p((int )"LZXC");
          if (tmp___141) {
            if ((unsigned int )((void const   *)("LZXC" + 1)) - (unsigned int )((void const   *)"LZXC") ==
                1U) {
              __s1_len___0 = strlen("LZXC");
              if (__s1_len___0 < 4U) {
                tmp___130 = __builtin_constant_p((int )(lzx_control->signature));
                if (tmp___130) {
                  if ((unsigned int )((void const   *)(lzx_control->signature + 1)) -
                      (unsigned int )((void const   *)(lzx_control->signature)) ==
                      1U) {
                    tmp___111 = __builtin_strcmp("LZXC", lzx_control->signature);
                  } else {
                    goto _L___31;
                  }
                } else {
                  _L___31: 
                  __s2___14 = (unsigned char const   *)((char const   *)(lzx_control->signature));
                  __result___42 = (int )((int const   )(*((unsigned char const   *)"LZXC" +
                                                          0)) - (int const   )(*(__s2___14 +
                                                                                 0)));
                  if (__s1_len___0 > 0U) {
                    if (__result___42 == 0) {
                      __result___42 = (int )((int const   )(*((unsigned char const   *)"LZXC" +
                                                              1)) - (int const   )(*(__s2___14 +
                                                                                     1)));
                      if (__s1_len___0 > 1U) {
                        if (__result___42 == 0) {
                          __result___42 = (int )((int const   )(*((unsigned char const   *)"LZXC" +
                                                                  2)) - (int const   )(*(__s2___14 +
                                                                                         2)));
                          if (__s1_len___0 > 2U) {
                            if (__result___42 == 0) {
                              __result___42 = (int )((int const   )(*((unsigned char const   *)"LZXC" +
                                                                      3)) - (int const   )(*(__s2___14 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___111 = __result___42;
                }
              } else {
                goto _L___35;
              }
            } else {
              goto _L___35;
            }
          } else {
            _L___35: 
            tmp___140 = __builtin_constant_p((int )(lzx_control->signature));
            if (tmp___140) {
              if ((unsigned int )((void const   *)(lzx_control->signature + 1)) -
                  (unsigned int )((void const   *)(lzx_control->signature)) == 1U) {
                __s2_len___0 = strlen((char const   *)(lzx_control->signature));
                if (__s2_len___0 < 4U) {
                  tmp___139 = __builtin_constant_p((int )"LZXC");
                  if (tmp___139) {
                    if ((unsigned int )((void const   *)("LZXC" + 1)) - (unsigned int )((void const   *)"LZXC") ==
                        1U) {
                      tmp___111 = __builtin_strcmp("LZXC", lzx_control->signature);
                    } else {
                      goto _L___33;
                    }
                  } else {
                    _L___33: 
                    __s1___30 = (unsigned char const   *)"LZXC";
                    __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)(lzx_control->signature)) +
                                                                                               0)));
                    if (__s2_len___0 > 0U) {
                      if (__result___46 == 0) {
                        __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                               (int const   )(*((unsigned char const   *)((char const   *)(lzx_control->signature)) +
                                                                1)));
                        if (__s2_len___0 > 1U) {
                          if (__result___46 == 0) {
                            __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                   (int const   )(*((unsigned char const   *)((char const   *)(lzx_control->signature)) +
                                                                    2)));
                            if (__s2_len___0 > 2U) {
                              if (__result___46 == 0) {
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        3)) - (int const   )(*((unsigned char const   *)((char const   *)(lzx_control->signature)) +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___111 = __result___46;
                  }
                } else {
                  tmp___111 = __builtin_strcmp("LZXC", lzx_control->signature);
                }
              } else {
                tmp___111 = __builtin_strcmp("LZXC", lzx_control->signature);
              }
            } else {
              tmp___111 = __builtin_strcmp("LZXC", lzx_control->signature);
            }
          }
        }
        tmp___75 = tmp___111;
      } else {
        tmp___75 = strncmp("LZXC", (char const   *)(lzx_control->signature), 4U);
      }
    } else {
      tmp___75 = strncmp("LZXC", (char const   *)(lzx_control->signature), 4U);
    }
  }
  if (tmp___75 != 0) {
    cli_dbgmsg("bad sys_control signature");
    goto abort;
  }
  switch ((int )lzx_control->version) {
  case 1: ;
  break;
  case 2: 
  lzx_control->reset_interval *= 32768U;
  lzx_control->window_size *= 32768U;
  break;
  default: 
  cli_dbgmsg("Unknown sys_control version:%d\n", lzx_control->version);
  goto abort;
  }
  print_sys_control(lzx_control);
  return (lzx_control);
  abort: 
  free((void *)lzx_control);
  return ((lzx_control_t *)((void *)0));
}
}
static void print_sys_content(lzx_content_t *lzx_content ) 
{ 

  {
  if (! lzx_content) {
    return;
  }
  cli_dbgmsg("---- Content ----\n");
  cli_dbgmsg("Offset:\t%llu\n", lzx_content->offset);
  cli_dbgmsg("Length:\t%llu\n\n", lzx_content->length);
  return;
}
}
static lzx_content_t *read_sys_content(int fd , itsf_header_t *itsf_hdr , file_list_t *file_e ) 
{ lzx_content_t *lzx_content ;

  {
  lzx_content = (lzx_content_t *)cli_malloc(sizeof(lzx_content_t ));
  if (! lzx_content) {
    return ((lzx_content_t *)((void *)0));
  }
  lzx_content->offset = itsf_hdr->data_offset + file_e->offset;
  lzx_content->length = file_e->length;
  print_sys_content(lzx_content);
  return (lzx_content);
}
}
static void print_sys_reset_table(lzx_reset_table_t *lzx_reset_table ) 
{ 

  {
  if (! lzx_reset_table) {
    return;
  }
  cli_dbgmsg("---- Reset Table ----\n");
  cli_dbgmsg("Num Entries:\t%lu\n", lzx_reset_table->num_entries);
  cli_dbgmsg("Entry Size:\t%lu\n", lzx_reset_table->entry_size);
  cli_dbgmsg("Table Offset:\t%lu\n", lzx_reset_table->table_offset);
  cli_dbgmsg("Uncom Len:\t%llu\n", lzx_reset_table->uncom_len);
  cli_dbgmsg("Com Len:\t%llu\n", lzx_reset_table->com_len);
  cli_dbgmsg("Frame Len:\t%llu\n\n", lzx_reset_table->frame_len);
  return;
}
}
static lzx_reset_table_t *read_sys_reset_table(int fd , itsf_header_t *itsf_hdr ,
                                               file_list_t *file_e , unsigned char *m_area ,
                                               off_t m_length ) 
{ off_t offset ;
  lzx_reset_table_t *lzx_reset_table ;
  int tmp___0 ;

  {
  if (file_e->length < 40ULL) {
    return ((lzx_reset_table_t *)((void *)0));
  }
  offset = (long )((itsf_hdr->data_offset + file_e->offset) + 4ULL);
  if (offset < 0L) {
    return ((lzx_reset_table_t *)((void *)0));
  }
  lzx_reset_table = (lzx_reset_table_t *)cli_malloc(sizeof(lzx_reset_table_t ));
  if (! lzx_reset_table) {
    return ((lzx_reset_table_t *)((void *)0));
  }
  lzx_reset_table->rt_offset = offset - 4L;
  tmp___0 = chm_read_data(fd, (unsigned char *)lzx_reset_table, offset, 36L, m_area,
                          m_length);
  if (! tmp___0) {
    goto abort;
  }
  lzx_reset_table->num_entries = chm_endian_convert_32(lzx_reset_table->num_entries);
  lzx_reset_table->entry_size = chm_endian_convert_32(lzx_reset_table->entry_size);
  lzx_reset_table->table_offset = chm_endian_convert_32(lzx_reset_table->table_offset);
  lzx_reset_table->uncom_len = chm_endian_convert_64(lzx_reset_table->uncom_len);
  lzx_reset_table->com_len = chm_endian_convert_64(lzx_reset_table->com_len);
  lzx_reset_table->frame_len = chm_endian_convert_64(lzx_reset_table->frame_len);
  if (lzx_reset_table->frame_len != 32768ULL) {
    cli_dbgmsg("bad sys_reset_table frame_len: 0x%x\n", lzx_reset_table->frame_len);
    goto abort;
  }
  if (lzx_reset_table->entry_size != 4U) {
    if (lzx_reset_table->entry_size != 8U) {
      cli_dbgmsg("bad sys_reset_table entry_size: 0x%x\n", lzx_reset_table->entry_size);
      goto abort;
    }
  }
  print_sys_reset_table(lzx_reset_table);
  return (lzx_reset_table);
  abort: 
  free((void *)lzx_reset_table);
  return ((lzx_reset_table_t *)((void *)0));
}
}
static int chm_decompress_stream(int fd , char const   *dirname , itsf_header_t *itsf_hdr ,
                                 file_list_t *file_l , file_list_t *sys_file_l , unsigned char *m_area ,
                                 off_t m_length ) 
{ file_list_t *entry ;
  lzx_content_t *lzx_content ;
  lzx_reset_table_t *lzx_reset_table ;
  lzx_control_t *lzx_control ;
  int window_bits ;
  int count ;
  int length ;
  int ofd ;
  int retval ;
  uint64_t com_offset ;
  struct mspack_file_p mf_in ;
  struct mspack_file_p mf_out ;
  struct lzxd_stream *stream ;
  unsigned char filename[1024] ;
  size_t __len___2 ;
  size_t tmp___15 ;
  char *__retval___2 ;
  char *tmp___16 ;
  int tmp___18 ;
  size_t __len___6 ;
  size_t tmp___35 ;
  char *__retval___6 ;
  char *tmp___36 ;
  int tmp___38 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___74 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___93 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___143 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___162 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___171 ;
  int tmp___172 ;
  int tmp___173 ;
  int tmp___174 ;
  int tmp___175 ;
  int tmp___176 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___212 ;
  unsigned char const   *__s2___22 ;
  register int __result___66 ;
  int tmp___231 ;
  unsigned char const   *__s1___46 ;
  register int __result___70 ;
  int tmp___240 ;
  int tmp___241 ;
  int tmp___242 ;
  int tmp___243 ;
  int tmp___244 ;
  int tmp___245 ;
  __off_t tmp___246 ;
  uint64_t tmp___247 ;

  {
  lzx_content = (lzx_content_t *)((void *)0);
  lzx_reset_table = (lzx_reset_table_t *)((void *)0);
  lzx_control = (lzx_control_t *)((void *)0);
  retval = 0;
  mf_in.desc = dup(fd);
  if (mf_in.desc < 0) {
    return (0);
  }
  mf_in.fh = fdopen(mf_in.desc, "r");
  if (! mf_in.fh) {
    close(mf_in.desc);
    return (0);
  }
  tmp___18 = __builtin_constant_p((int )"input");
  if (tmp___18) {
    if ((unsigned int )((void const   *)("input" + 1)) - (unsigned int )((void const   *)"input") ==
        1U) {
      if ((int const   )(*("input" + 0)) == 0) {
        mf_in.name = (char const   *)calloc(1U, 1U);
      } else {
        tmp___15 = strlen("input");
        __len___2 = tmp___15 + 1U;
        tmp___16 = (char *)malloc(__len___2);
        __retval___2 = tmp___16;
        if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
          __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )"input",
                                        __len___2);
        }
        mf_in.name = (char const   *)__retval___2;
      }
    } else {
      mf_in.name = __strdup("input");
    }
  } else {
    mf_in.name = __strdup("input");
  }
  snprintf((char * __restrict  )(filename), 1024U, (char const   * __restrict  )"%s/clamav-unchm.bin",
           dirname);
  mf_out.desc = open((char const   *)(filename), 577, 448);
  if (! mf_out.desc) {
    cli_dbgmsg("open failed\n", filename);
    free((void *)mf_in.name);
    fclose(mf_in.fh);
    return (0);
  }
  mf_out.fh = fdopen(mf_out.desc, "w");
  if (! mf_out.fh) {
    cli_dbgmsg("fdopen failed\n", filename);
    free((void *)mf_in.name);
    fclose(mf_in.fh);
    return (0);
  }
  tmp___38 = __builtin_constant_p((int )"output");
  if (tmp___38) {
    if ((unsigned int )((void const   *)("output" + 1)) - (unsigned int )((void const   *)"output") ==
        1U) {
      if ((int const   )(*("output" + 0)) == 0) {
        mf_out.name = (char const   *)calloc(1U, 1U);
      } else {
        tmp___35 = strlen("output");
        __len___6 = tmp___35 + 1U;
        tmp___36 = (char *)malloc(__len___6);
        __retval___6 = tmp___36;
        if ((unsigned int )__retval___6 != (unsigned int )((void *)0)) {
          __retval___6 = (char *)memcpy((void * __restrict  )__retval___6, (void const   * __restrict  )"output",
                                        __len___6);
        }
        mf_out.name = (char const   *)__retval___6;
      }
    } else {
      mf_out.name = __strdup("output");
    }
  } else {
    mf_out.name = __strdup("output");
  }
  entry = sys_file_l->next;
  while (entry) {
    tmp___243 = __builtin_constant_p((int )entry->name);
    if (tmp___243) {
      tmp___244 = __builtin_constant_p((int )"::DataSpace/Storage/MSCompressed/ControlData");
      if (tmp___244) {
        __s1_len___1 = strlen((char const   *)entry->name);
        __s2_len___1 = strlen("::DataSpace/Storage/MSCompressed/ControlData");
        if (! ((unsigned int )((void const   *)(entry->name + 1)) - (unsigned int )((void const   *)entry->name) ==
               1U)) {
          goto _L___56;
        } else {
          if (__s1_len___1 >= 4U) {
            _L___56: 
            if (! ((unsigned int )((void const   *)("::DataSpace/Storage/MSCompressed/ControlData" +
                                                    1)) - (unsigned int )((void const   *)"::DataSpace/Storage/MSCompressed/ControlData") ==
                   1U)) {
              tmp___245 = 1;
            } else {
              if (__s2_len___1 >= 4U) {
                tmp___245 = 1;
              } else {
                tmp___245 = 0;
              }
            }
          } else {
            tmp___245 = 0;
          }
        }
        if (tmp___245) {
          tmp___212 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/ControlData");
        } else {
          goto _L___58;
        }
      } else {
        goto _L___58;
      }
    } else {
      _L___58: 
      tmp___242 = __builtin_constant_p((int )entry->name);
      if (tmp___242) {
        if ((unsigned int )((void const   *)(entry->name + 1)) - (unsigned int )((void const   *)entry->name) ==
            1U) {
          __s1_len___1 = strlen((char const   *)entry->name);
          if (__s1_len___1 < 4U) {
            tmp___231 = __builtin_constant_p((int )"::DataSpace/Storage/MSCompressed/ControlData");
            if (tmp___231) {
              if ((unsigned int )((void const   *)("::DataSpace/Storage/MSCompressed/ControlData" +
                                                   1)) - (unsigned int )((void const   *)"::DataSpace/Storage/MSCompressed/ControlData") ==
                  1U) {
                tmp___212 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/ControlData");
              } else {
                goto _L___51;
              }
            } else {
              _L___51: 
              __s2___22 = (unsigned char const   *)"::DataSpace/Storage/MSCompressed/ControlData";
              __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                      0)) - (int const   )(*(__s2___22 +
                                                                             0)));
              if (__s1_len___1 > 0U) {
                if (__result___66 == 0) {
                  __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                          1)) - (int const   )(*(__s2___22 +
                                                                                 1)));
                  if (__s1_len___1 > 1U) {
                    if (__result___66 == 0) {
                      __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                              2)) - (int const   )(*(__s2___22 +
                                                                                     2)));
                      if (__s1_len___1 > 2U) {
                        if (__result___66 == 0) {
                          __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                                  3)) - (int const   )(*(__s2___22 +
                                                                                         3)));
                        }
                      }
                    }
                  }
                }
              }
              tmp___212 = __result___66;
            }
          } else {
            goto _L___55;
          }
        } else {
          goto _L___55;
        }
      } else {
        _L___55: 
        tmp___241 = __builtin_constant_p((int )"::DataSpace/Storage/MSCompressed/ControlData");
        if (tmp___241) {
          if ((unsigned int )((void const   *)("::DataSpace/Storage/MSCompressed/ControlData" +
                                               1)) - (unsigned int )((void const   *)"::DataSpace/Storage/MSCompressed/ControlData") ==
              1U) {
            __s2_len___1 = strlen("::DataSpace/Storage/MSCompressed/ControlData");
            if (__s2_len___1 < 4U) {
              tmp___240 = __builtin_constant_p((int )entry->name);
              if (tmp___240) {
                if ((unsigned int )((void const   *)(entry->name + 1)) - (unsigned int )((void const   *)entry->name) ==
                    1U) {
                  tmp___212 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/ControlData");
                } else {
                  goto _L___53;
                }
              } else {
                _L___53: 
                __s1___46 = (unsigned char const   *)((char const   *)entry->name);
                __result___70 = (int )((int const   )(*(__s1___46 + 0)) - (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/ControlData" +
                                                                                           0)));
                if (__s2_len___1 > 0U) {
                  if (__result___70 == 0) {
                    __result___70 = (int )((int const   )(*(__s1___46 + 1)) - (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/ControlData" +
                                                                                               1)));
                    if (__s2_len___1 > 1U) {
                      if (__result___70 == 0) {
                        __result___70 = (int )((int const   )(*(__s1___46 + 2)) -
                                               (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/ControlData" +
                                                                2)));
                        if (__s2_len___1 > 2U) {
                          if (__result___70 == 0) {
                            __result___70 = (int )((int const   )(*(__s1___46 + 3)) -
                                                   (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/ControlData" +
                                                                    3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___212 = __result___70;
              }
            } else {
              tmp___212 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/ControlData");
            }
          } else {
            tmp___212 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/ControlData");
          }
        } else {
          tmp___212 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/ControlData");
        }
      }
    }
    if (tmp___212 == 0) {
      lzx_control = read_sys_control(fd, itsf_hdr, entry, m_area, m_length);
    } else {
      tmp___174 = __builtin_constant_p((int )entry->name);
      if (tmp___174) {
        tmp___175 = __builtin_constant_p((int )"::DataSpace/Storage/MSCompressed/Content");
        if (tmp___175) {
          __s1_len___0 = strlen((char const   *)entry->name);
          __s2_len___0 = strlen("::DataSpace/Storage/MSCompressed/Content");
          if (! ((unsigned int )((void const   *)(entry->name + 1)) - (unsigned int )((void const   *)entry->name) ==
                 1U)) {
            goto _L___36;
          } else {
            if (__s1_len___0 >= 4U) {
              _L___36: 
              if (! ((unsigned int )((void const   *)("::DataSpace/Storage/MSCompressed/Content" +
                                                      1)) - (unsigned int )((void const   *)"::DataSpace/Storage/MSCompressed/Content") ==
                     1U)) {
                tmp___176 = 1;
              } else {
                if (__s2_len___0 >= 4U) {
                  tmp___176 = 1;
                } else {
                  tmp___176 = 0;
                }
              }
            } else {
              tmp___176 = 0;
            }
          }
          if (tmp___176) {
            tmp___143 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Content");
          } else {
            goto _L___38;
          }
        } else {
          goto _L___38;
        }
      } else {
        _L___38: 
        tmp___173 = __builtin_constant_p((int )entry->name);
        if (tmp___173) {
          if ((unsigned int )((void const   *)(entry->name + 1)) - (unsigned int )((void const   *)entry->name) ==
              1U) {
            __s1_len___0 = strlen((char const   *)entry->name);
            if (__s1_len___0 < 4U) {
              tmp___162 = __builtin_constant_p((int )"::DataSpace/Storage/MSCompressed/Content");
              if (tmp___162) {
                if ((unsigned int )((void const   *)("::DataSpace/Storage/MSCompressed/Content" +
                                                     1)) - (unsigned int )((void const   *)"::DataSpace/Storage/MSCompressed/Content") ==
                    1U) {
                  tmp___143 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Content");
                } else {
                  goto _L___31;
                }
              } else {
                _L___31: 
                __s2___14 = (unsigned char const   *)"::DataSpace/Storage/MSCompressed/Content";
                __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                        0)) - (int const   )(*(__s2___14 +
                                                                               0)));
                if (__s1_len___0 > 0U) {
                  if (__result___42 == 0) {
                    __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                            1)) - (int const   )(*(__s2___14 +
                                                                                   1)));
                    if (__s1_len___0 > 1U) {
                      if (__result___42 == 0) {
                        __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                                2)) - (int const   )(*(__s2___14 +
                                                                                       2)));
                        if (__s1_len___0 > 2U) {
                          if (__result___42 == 0) {
                            __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                                    3)) - (int const   )(*(__s2___14 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___143 = __result___42;
              }
            } else {
              goto _L___35;
            }
          } else {
            goto _L___35;
          }
        } else {
          _L___35: 
          tmp___172 = __builtin_constant_p((int )"::DataSpace/Storage/MSCompressed/Content");
          if (tmp___172) {
            if ((unsigned int )((void const   *)("::DataSpace/Storage/MSCompressed/Content" +
                                                 1)) - (unsigned int )((void const   *)"::DataSpace/Storage/MSCompressed/Content") ==
                1U) {
              __s2_len___0 = strlen("::DataSpace/Storage/MSCompressed/Content");
              if (__s2_len___0 < 4U) {
                tmp___171 = __builtin_constant_p((int )entry->name);
                if (tmp___171) {
                  if ((unsigned int )((void const   *)(entry->name + 1)) - (unsigned int )((void const   *)entry->name) ==
                      1U) {
                    tmp___143 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Content");
                  } else {
                    goto _L___33;
                  }
                } else {
                  _L___33: 
                  __s1___30 = (unsigned char const   *)((char const   *)entry->name);
                  __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/Content" +
                                                                                             0)));
                  if (__s2_len___0 > 0U) {
                    if (__result___46 == 0) {
                      __result___46 = (int )((int const   )(*(__s1___30 + 1)) - (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/Content" +
                                                                                                 1)));
                      if (__s2_len___0 > 1U) {
                        if (__result___46 == 0) {
                          __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/Content" +
                                                                  2)));
                          if (__s2_len___0 > 2U) {
                            if (__result___46 == 0) {
                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/Content" +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___143 = __result___46;
                }
              } else {
                tmp___143 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Content");
              }
            } else {
              tmp___143 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Content");
            }
          } else {
            tmp___143 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Content");
          }
        }
      }
      if (tmp___143 == 0) {
        lzx_content = read_sys_content(fd, itsf_hdr, entry);
      } else {
        tmp___105 = __builtin_constant_p((int )entry->name);
        if (tmp___105) {
          tmp___106 = __builtin_constant_p((int )"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
          if (tmp___106) {
            __s1_len = strlen((char const   *)entry->name);
            __s2_len = strlen("::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
            if (! ((unsigned int )((void const   *)(entry->name + 1)) - (unsigned int )((void const   *)entry->name) ==
                   1U)) {
              goto _L___16;
            } else {
              if (__s1_len >= 4U) {
                _L___16: 
                if (! ((unsigned int )((void const   *)("::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable" +
                                                        1)) - (unsigned int )((void const   *)"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable") ==
                       1U)) {
                  tmp___107 = 1;
                } else {
                  if (__s2_len >= 4U) {
                    tmp___107 = 1;
                  } else {
                    tmp___107 = 0;
                  }
                }
              } else {
                tmp___107 = 0;
              }
            }
            if (tmp___107) {
              tmp___74 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: 
          tmp___104 = __builtin_constant_p((int )entry->name);
          if (tmp___104) {
            if ((unsigned int )((void const   *)(entry->name + 1)) - (unsigned int )((void const   *)entry->name) ==
                1U) {
              __s1_len = strlen((char const   *)entry->name);
              if (__s1_len < 4U) {
                tmp___93 = __builtin_constant_p((int )"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
                if (tmp___93) {
                  if ((unsigned int )((void const   *)("::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable" +
                                                       1)) - (unsigned int )((void const   *)"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable") ==
                      1U) {
                    tmp___74 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: 
                  __s2___6 = (unsigned char const   *)"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable";
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
                  if (__s1_len > 0U) {
                    if (__result___18 == 0) {
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
                      if (__s1_len > 1U) {
                        if (__result___18 == 0) {
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
                          if (__s1_len > 2U) {
                            if (__result___18 == 0) {
                              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___74 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: 
            tmp___103 = __builtin_constant_p((int )"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
            if (tmp___103) {
              if ((unsigned int )((void const   *)("::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable" +
                                                   1)) - (unsigned int )((void const   *)"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable") ==
                  1U) {
                __s2_len = strlen("::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
                if (__s2_len < 4U) {
                  tmp___102 = __builtin_constant_p((int )entry->name);
                  if (tmp___102) {
                    if ((unsigned int )((void const   *)(entry->name + 1)) - (unsigned int )((void const   *)entry->name) ==
                        1U) {
                      tmp___74 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: 
                    __s1___14 = (unsigned char const   *)((char const   *)entry->name);
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable" +
                                                                                               0)));
                    if (__s2_len > 0U) {
                      if (__result___22 == 0) {
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable" +
                                                                1)));
                        if (__s2_len > 1U) {
                          if (__result___22 == 0) {
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable" +
                                                                    2)));
                            if (__s2_len > 2U) {
                              if (__result___22 == 0) {
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable" +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___74 = __result___22;
                  }
                } else {
                  tmp___74 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
                }
              } else {
                tmp___74 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
              }
            } else {
              tmp___74 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
            }
          }
        }
        if (tmp___74 == 0) {
          lzx_reset_table = read_sys_reset_table(fd, itsf_hdr, entry, m_area, m_length);
        }
      }
    }
    entry = entry->next;
  }
  if (! lzx_content) {
    goto abort;
  } else {
    if (! lzx_reset_table) {
      goto abort;
    } else {
      if (! lzx_control) {
        goto abort;
      }
    }
  }
  switch ((int )lzx_control->window_size) {
  case 32768: 
  window_bits = 15;
  break;
  case 65536: 
  window_bits = 16;
  break;
  case 131072: 
  window_bits = 17;
  break;
  case 262144: 
  window_bits = 18;
  break;
  case 524288: 
  window_bits = 19;
  break;
  case 1048576: 
  window_bits = 20;
  break;
  case 2097152: 
  window_bits = 21;
  break;
  default: 
  cli_dbgmsg("bad control window size: 0x%x\n", lzx_control->window_size);
  goto abort;
  }
  if (lzx_control->reset_interval % 32768U) {
    cli_dbgmsg("bad reset_interval: 0x%x\n", lzx_control->window_size);
    goto abort;
  }
  length = (int )lzx_reset_table->uncom_len;
  length = (int )((unsigned int )length + lzx_control->reset_interval);
  length = (int )((unsigned int )length & - lzx_control->reset_interval);
  com_offset = lzx_content->offset;
  cli_dbgmsg("Compressed offset: %llu\n", com_offset);
  stream = lzxd_init(mspack_default_system, (struct mspack_file *)(& mf_in), (struct mspack_file *)(& mf_out),
                     window_bits, (int )(lzx_control->reset_interval / 32768U), 4096,
                     (long )length);
  lseek(fd, (long )com_offset, 0);
  if (! stream) {
    cli_dbgmsg("lzxd_init failed\n");
    goto abort;
  }
  lzxd_decompress(stream, (long )length);
  lzxd_free(stream);
  entry = file_l->next;
  fclose(mf_out.fh);
  mf_out.fh = (FILE *)((void *)0);
  mf_out.desc = open((char const   *)(filename), 0);
  if (mf_out.desc < 0) {
    cli_dbgmsg("re-open output failed\n");
    goto abort;
  }
  unlink((char const   *)(filename));
  count = 0;
  while (entry) {
    if (entry->section != 1ULL) {
      entry = entry->next;
      continue;
    }
    tmp___246 = lseek(mf_out.desc, (long )entry->offset, 0);
    if (tmp___246 != (long )entry->offset) {
      cli_dbgmsg("seek in output failed\n");
      entry = entry->next;
      continue;
    }
    snprintf((char * __restrict  )(filename), 1024U, (char const   * __restrict  )"%s/%d-%llu.chm",
             dirname, count, entry->offset);
    ofd = open((char const   *)(filename), 577, 448);
    if (ofd < 0) {
      entry = entry->next;
      continue;
    }
    tmp___247 = chm_copy_file_data(mf_out.desc, ofd, entry->length);
    if (tmp___247 != entry->length) {
      cli_dbgmsg("failed to copy %lu bytes\n", entry->length);
    }
    close(ofd);
    entry = entry->next;
    count ++;
  }
  close(mf_out.desc);
  retval = 1;
  abort: 
  if (lzx_content) {
    free((void *)lzx_content);
  }
  if (lzx_reset_table) {
    free((void *)lzx_reset_table);
  }
  if (lzx_control) {
    free((void *)lzx_control);
  }
  free((void *)mf_in.name);
  fclose(mf_in.fh);
  free((void *)mf_out.name);
  if (mf_out.fh) {
    fclose(mf_out.fh);
  }
  return (retval);
}
}
int chm_unpack(int fd , char const   *dirname ) 
{ int retval ;
  unsigned char *m_area ;
  off_t m_length ;
  off_t offset ;
  file_list_t *file_l ;
  file_list_t *sys_file_l ;
  struct stat statbuf ;
  itsf_header_t itsf_hdr ;
  itsp_header_t itsp_hdr ;
  uint32_t num_chunks ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  retval = 0;
  m_area = (unsigned char *)((void *)0);
  m_length = 0L;
  file_l = (file_list_t *)cli_malloc(sizeof(file_list_t ));
  if (! file_l) {
    return (0);
  }
  file_l->next = (struct file_list_tag *)((void *)0);
  file_l->name = (unsigned char *)((void *)0);
  sys_file_l = (file_list_t *)cli_malloc(sizeof(file_list_t ));
  if (! sys_file_l) {
    free((void *)file_l);
    return (0);
  }
  sys_file_l->next = (struct file_list_tag *)((void *)0);
  sys_file_l->name = (unsigned char *)((void *)0);
  tmp___2 = fstat__extinline(fd, & statbuf);
  if (tmp___2 == 0) {
    if (statbuf.st_size < 96L) {
      goto abort;
    }
    m_length = statbuf.st_size;
    m_area = (unsigned char *)mmap((void *)0, (unsigned int )m_length, 1, 2, fd, 0L);
    if ((unsigned int )m_area == (unsigned int )((void *)-1)) {
      m_area = (unsigned char *)((void *)0);
    }
  }
  tmp___3 = itsf_read_header(fd, & itsf_hdr, m_area, m_length);
  if (! tmp___3) {
    goto abort;
  }
  itsf_print_header(& itsf_hdr);
  tmp___4 = itsp_read_header(fd, & itsp_hdr, (long )itsf_hdr.dir_offset, m_area, m_length);
  if (! tmp___4) {
    goto abort;
  }
  itsp_print_header(& itsp_hdr);
  offset = (long )(itsf_hdr.dir_offset + 84ULL);
  if (itsp_hdr.index_head > 0) {
    offset = (long )((unsigned long )offset + (unsigned long )((unsigned int )itsp_hdr.index_head *
                                                               itsp_hdr.block_len));
  }
  num_chunks = (unsigned int )((itsp_hdr.index_tail - itsp_hdr.index_head) + 1);
  if (itsf_hdr.version < 3) {
    itsf_hdr.data_offset = (itsf_hdr.dir_offset + 84ULL) + (unsigned long long )(itsp_hdr.block_len *
                                                                                 itsp_hdr.num_blocks);
  }
  while (num_chunks) {
    tmp___5 = read_chunk(fd, offset, itsp_hdr.block_len, m_area, m_length, file_l,
                         sys_file_l);
    if (! tmp___5) {
      goto abort;
    }
    num_chunks --;
    offset = (long )((unsigned long )offset + (unsigned long )itsp_hdr.block_len);
  }
  chm_decompress_stream(fd, dirname, & itsf_hdr, file_l, sys_file_l, m_area, m_length);
  retval = 1;
  abort: 
  free_file_list(file_l);
  free_file_list(sys_file_l);
  if (m_area) {
    munmap((void *)m_area, (unsigned int )m_length);
  }
  return (retval);
}
}
#pragma merger(0,"/tmp/cil-6Q5ENQwD.i","-g -O2 -fPIC")
char *rebuildpe(char *buffer , struct SECTION *sections , int sects , uint32_t base ,
                uint32_t ep , uint32_t ResRva , uint32_t ResSize ) ;
char *rebuildpe(char *buffer , struct SECTION *sections , int sects , uint32_t base ,
                uint32_t ep , uint32_t ResRva , uint32_t ResSize ) 
{ int i ;
  uint32_t datasize ;
  uint32_t rawbase ;
  char *pefile ;
  char *curpe ;
  struct IMAGE_PE_HEADER *fakepe ;

  {
  datasize = 0U;
  pefile = (char *)((void *)0);
  i = 0;
  while (i < sects) {
    datasize += (sections + i)->rsz;
    i ++;
  }
  rawbase = (unsigned int )(456 + 40 * sects);
  pefile = (char *)cli_malloc(rawbase + datasize);
  if (pefile) {
    memcpy((void * __restrict  )pefile, (void const   * __restrict  )"MZ\220\000\002\000\000\000\004\000\017\000\377\377\000\000\260\000\000\000\000\000\000\000@\000\032\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\320\000\000\000\016\037\264\t\272\r\000\315!\264L\315!This file was created by ClamAV for internal use and should not be run.\r\nClamAV - A GPL virus scanner - http://www.clamav.net\r\n$\000\000\000PE\000\000L\001\377\377CLAM\000\000\000\000\000\000\000\000\340\000\203\217\v\001\000\000\000\020\000\000\000\020\000\000\000\000\000\000\377\377\377\377\000\020\000\000\000\020\000\000\377\377\377\377\000\020\000\000\000\002\000\000\001\000\000\000\000\000\000\000\003\000\n\000\000\000\000\000\000\020\000\000\000\004\000\000\000\000\000\000\002\000\000\000\000\000\020\000\000\020\000\000\000\000\020\000\000\020\000\000\000\000\000\000\020\000\000\000",
           328U);
    fakepe = (struct IMAGE_PE_HEADER *)(pefile + 208);
    fakepe->NumberOfSections = EC16((unsigned short )sects);
    fakepe->AddressOfEntryPoint = EC32(ep);
    fakepe->ImageBase = EC32(base);
    memset((void *)(pefile + 328), 0, 128U);
    cli_writeint32((pefile + 328) + 16, ResRva);
    cli_writeint32((pefile + 328) + 20, ResSize);
    curpe = (pefile + 328) + 128;
    i = 0;
    while (i < sects) {
      snprintf((char * __restrict  )curpe, 8U, (char const   * __restrict  )".clam%.2d",
               i + 1);
      cli_writeint32(curpe + 8, (sections + i)->vsz);
      cli_writeint32(curpe + 12, (sections + i)->rva);
      cli_writeint32(curpe + 16, (sections + i)->rsz);
      cli_writeint32(curpe + 20, (sections + i)->raw + rawbase);
      cli_writeint32(curpe + 24, 0U);
      cli_writeint32(curpe + 28, 0U);
      cli_writeint32(curpe + 32, 0U);
      cli_writeint32(curpe + 36, 4294967295U);
      curpe += 40;
      i ++;
    }
    memcpy((void * __restrict  )curpe, (void const   * __restrict  )buffer, datasize);
  }
  return (pefile);
}
}
#pragma merger(0,"/tmp/cil-MIpQCBof.i","-g -O2 -fPIC")
static int doubledl(char **scur , uint8_t *mydlptr , char *buffer , int buffersize ) 
{ unsigned char mydl ;
  unsigned char olddl ;

  {
  mydl = (*mydlptr);
  olddl = mydl;
  mydl = (unsigned char )((int )mydl * 2);
  if (! ((int )olddl & 127)) {
    if ((unsigned int )(*scur) < (unsigned int )buffer) {
      return (-1);
    } else {
      if ((unsigned int )(*scur) >= (unsigned int )((buffer + buffersize) - 1)) {
        return (-1);
      }
    }
    olddl = (unsigned char )(*((*scur)));
    mydl = (unsigned char )((int )olddl * 2 + 1);
    (*scur) = (*scur) + 1;
  }
  (*mydlptr) = mydl;
  return (((int )olddl >> 7) & 1);
}
}
int petite_inflate2x_1to9(char *buf , uint32_t minrva , int bufsz , struct pe_image_section_hdr *sections ,
                          int sectcount , uint32_t Imagebase , uint32_t pep , int desc ,
                          int version , uint32_t ResRva , uint32_t ResSize ) 
{ char *adjbuf ;
  char *packed ;
  uint32_t thisrva ;
  uint32_t bottom ;
  uint32_t enc_ep ;
  uint32_t irva ;
  uint32_t workdone ;
  uint32_t grown ;
  uint32_t skew ;
  int j ;
  int oob ;
  int mangled ;
  int check4resources ;
  struct SECTION *usects ;
  void *tmpsct ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  char *ssrc ;
  char *ddst ;
  uint32_t size ;
  uint32_t srva ;
  int backbytes ;
  int oldback ;
  int backsize ;
  int addsize ;
  int t ;
  int upd ;
  uint32_t trva ;
  uint32_t trsz ;
  uint32_t tvsz ;
  uint32_t virtaddr ;
  uint32_t tmpep ;
  int rndm ;
  int dummy ;
  uint32_t *thunk ;
  uint32_t *imports ;
  uint32_t api ;
  uint32_t *tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t tmp___4 ;
  int32_t tmp___5 ;
  int32_t tmp___6 ;
  int32_t tmp___7 ;
  uint32_t check1 ;
  uint32_t check2 ;
  uint8_t mydl ;
  uint8_t goback ;
  int q ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  uint32_t test1 ;
  uint32_t test2 ;
  int reloc ;
  int32_t tmp___17 ;
  int32_t tmp___18 ;
  int32_t tmp___19 ;
  int32_t tmp___20 ;
  int32_t tmp___21 ;
  int32_t tmp___22 ;
  int32_t tmp___23 ;
  int32_t tmp___24 ;
  int32_t tmp___25 ;

  {
  adjbuf = buf - minrva;
  packed = (char *)((void *)0);
  thisrva = 0U;
  bottom = 0U;
  enc_ep = 0U;
  irva = 0U;
  workdone = 0U;
  grown = 853U;
  skew = 53U;
  j = 0;
  mangled = 0;
  check4resources = 0;
  usects = (struct SECTION *)((void *)0);
  tmpsct = (void *)0;
  if (version == 2) {
    tmp = EC32((sections + (sectcount - 1))->VirtualAddress);
    packed = (adjbuf + tmp) + 440;
  }
  if (version == 1) {
    tmp___0 = EC32((sections + (sectcount - 1))->VirtualAddress);
    packed = (adjbuf + tmp___0) + 376;
    grown = 803U;
    skew = 52U;
  }
  while (1) {
    if ((unsigned int )packed < (unsigned int )buf) {
      goto _L;
    } else {
      if ((unsigned int )packed >= (unsigned int )((buf + bufsz) - 4)) {
        _L: 
        if (usects) {
          free((void *)usects);
        }
        return (-1);
      }
    }
    srva = (uint32_t )cli_readint32((char const   *)packed);
    if (! srva) {
      upd = 1;
      if (j <= 0) {
        return (-1);
      }
      while (upd) {
        upd = 0;
        t = 0;
        while (t < j - 1) {
          if ((usects + t)->rva <= (usects + (t + 1))->rva) {
            goto __Cont;
          }
          trva = (usects + t)->rva;
          trsz = (usects + t)->rsz;
          tvsz = (usects + t)->vsz;
          (usects + t)->rva = (usects + (t + 1))->rva;
          (usects + t)->rsz = (usects + (t + 1))->rsz;
          (usects + t)->vsz = (usects + (t + 1))->vsz;
          (usects + (t + 1))->rva = trva;
          (usects + (t + 1))->rsz = trsz;
          (usects + (t + 1))->vsz = tvsz;
          upd = 1;
          __Cont: 
          t ++;
        }
      }
      t = 0;
      while (t < j - 1) {
        if ((usects + t)->vsz != (usects + (t + 1))->rva - (usects + t)->rva) {
          (usects + t)->vsz = (usects + (t + 1))->rva - (usects + t)->rva;
        }
        t ++;
      }
      if (enc_ep) {
        virtaddr = (pep + 5U) + Imagebase;
        rndm = 0;
        dummy = 1;
        thunk = (uint32_t *)(adjbuf + irva);
        if (version == 2) {
          while (1) {
            if ((unsigned int )((char *)thunk) >= (unsigned int )buf) {
              if ((unsigned int )((char *)thunk) < (unsigned int )((buf + bufsz) -
                                                                   4)) {
                if (! dummy) {
                  break;
                }
              } else {
                break;
              }
            } else {
              break;
            }
            if (! (*thunk)) {
              workdone = 1U;
              break;
            }
            tmp___1 = thunk;
            thunk ++;
            tmp___2 = EC32((*tmp___1));
            imports = (uint32_t *)(adjbuf + tmp___2);
            dummy = 0;
            while (1) {
              if ((unsigned int )((char *)imports) >= (unsigned int )buf) {
                if (! ((unsigned int )((char *)imports) < (unsigned int )((buf + bufsz) -
                                                                          4))) {
                  break;
                }
              } else {
                break;
              }
              dummy = 0;
              tmp___3 = imports;
              imports ++;
              api = EC32((*tmp___3));
              if (! api) {
                dummy = 1;
                break;
              }
              if (api != (api | 2147483648U)) {
                if (mangled) {
                  rndm --;
                  if (rndm < 0) {
                    api = virtaddr;
                    virtaddr += 5U;
                    rndm = (int )(virtaddr & 7U);
                  } else {
                    api = 3220181815U;
                  }
                } else {
                  api = 3220181815U;
                }
              } else {
                api = 3220181815U;
              }
              tmp___4 = EC32((sections + (sectcount - 1))->VirtualAddress);
              if (tmp___4 + Imagebase < api) {
                enc_ep --;
              }
              if (api < virtaddr) {
                enc_ep --;
              }
              tmpep = ((enc_ep & 4294967288U) >> 3) & 536870911U;
              enc_ep = ((enc_ep & 7U) << 29) | tmpep;
            }
          }
        } else {
          workdone = 1U;
        }
        enc_ep = (pep + 5U) + enc_ep;
        if (workdone == 1U) {
          cli_dbgmsg("Petite: Old EP: %x\n", enc_ep);
        } else {
          cli_dbgmsg("Petite: In troubles while attempting to decrypt old EP\n");
        }
      }
      t = 0;
      while (t < j) {
        (usects + t)->raw = ((usects + (t - 1))->raw + (usects + (t - 1))->rsz) *
                            (unsigned int )(t > 0);
        if ((usects + t)->rsz != 0U) {
          memmove((void *)(buf + (usects + t)->raw), (void const   *)(adjbuf + (usects +
                                                                                t)->rva),
                  (usects + t)->rsz);
        }
        t ++;
      }
      cli_dbgmsg("Petite: Sections dump:\n");
      t = 0;
      while (t < j) {
        cli_dbgmsg("Petite: .SECT%d RVA:%x VSize:%x ROffset: %x, RSize:% x\n", t,
                   (usects + t)->rva, (usects + t)->vsz, (usects + t)->raw, (usects +
                                                                             t)->rsz);
        t ++;
      }
      ssrc = rebuildpe(buf, usects, j, Imagebase, enc_ep, ResRva, ResSize);
      if (ssrc) {
        write(desc, (void const   *)ssrc, ((unsigned int )(456 + 40 * j) + (usects +
                                                                            (j - 1))->raw) +
                                          (usects + (j - 1))->rsz);
        free((void *)ssrc);
      } else {
        cli_dbgmsg("Petite: Rebuilding failed\n");
      }
      free((void *)usects);
      return ((int )workdone);
    }
    size = srva & 2147483647U;
    if (srva != size) {
      check4resources = 0;
      if ((unsigned int )packed < (unsigned int )buf) {
        goto _L___0;
      } else {
        if ((unsigned int )packed >= (unsigned int )((buf + bufsz) - 12)) {
          _L___0: 
          if (usects) {
            free((void *)usects);
          }
          return (-1);
        }
      }
      tmp___5 = cli_readint32((char const   *)(packed + 8));
      bottom = (unsigned int )(tmp___5 + 4);
      tmp___6 = cli_readint32((char const   *)(packed + 4));
      ssrc = (adjbuf + tmp___6) - (size - 1U) * 4U;
      tmp___7 = cli_readint32((char const   *)(packed + 8));
      ddst = (adjbuf + tmp___7) - (size - 1U) * 4U;
      if ((unsigned int )ssrc < (unsigned int )buf) {
        goto _L___1;
      } else {
        if ((unsigned int )(ssrc + size * 4U) >= (unsigned int )(buf + bufsz)) {
          goto _L___1;
        } else {
          if ((unsigned int )ddst < (unsigned int )buf) {
            goto _L___1;
          } else {
            if ((unsigned int )(ddst + size * 4U) >= (unsigned int )(buf + bufsz)) {
              _L___1: 
              if (usects) {
                free((void *)usects);
              }
              return (-1);
            }
          }
        }
      }
      memmove((void *)ddst, (void const   *)ssrc, size * 4U);
      packed += 12;
    } else {
      mydl = (unsigned char)0;
      if ((unsigned int )packed < (unsigned int )buf) {
        goto _L___2;
      } else {
        if ((unsigned int )packed >= (unsigned int )((buf + bufsz) - 16)) {
          _L___2: 
          if (usects) {
            free((void *)usects);
          }
          return (-1);
        }
      }
      size = (uint32_t )cli_readint32((char const   *)(packed + 4));
      packed += 16;
      thisrva = (uint32_t )cli_readint32((char const   *)(packed - 8));
      tmpsct = realloc((void *)usects, sizeof(struct SECTION ) * (unsigned int )(j +
                                                                                 1));
      if (! tmpsct) {
        if (usects) {
          free((void *)usects);
        }
        return (-1);
      }
      usects = (struct SECTION *)tmpsct;
      (usects + j)->rva = thisrva;
      (usects + j)->rsz = size;
      if ((int )(bottom - thisrva) > 0) {
        (usects + j)->vsz = bottom - thisrva;
      } else {
        (usects + j)->vsz = size;
      }
      (usects + j)->raw = 0U;
      if (! size) {
        j ++;
        continue;
      }
      ssrc = adjbuf + srva;
      ddst = adjbuf + thisrva;
      if (! check4resources) {
        q = 0;
        while (q < sectcount) {
          tmp___8 = EC32((sections + q)->VirtualAddress);
          if (thisrva <= tmp___8) {
            goto __Cont___0;
          } else {
            tmp___9 = EC32((sections + q)->VirtualAddress);
            tmp___10 = EC32((sections + q)->VirtualSize);
            if (thisrva >= tmp___9 + tmp___10) {
              goto __Cont___0;
            }
          }
          (usects + j)->rva = EC32((sections + q)->VirtualAddress);
          tmp___11 = EC32((sections + q)->VirtualAddress);
          (usects + j)->rsz = (thisrva - tmp___11) + size;
          break;
          __Cont___0: 
          q ++;
        }
      }
      j ++;
      if (size < 65536U) {
        check1 = 4294951008U;
        check2 = 4294966368U;
        goback = (unsigned char)5;
      } else {
        if (size < 262144U) {
          check1 = 4294934912U;
          check2 = 4294965632U;
          goback = (unsigned char)7;
        } else {
          check1 = 4294935296U;
          check2 = 4294966016U;
          goback = (unsigned char)8;
        }
      }
      if ((unsigned int )ddst < (unsigned int )buf) {
        free((void *)usects);
        return (-1);
      } else {
        if ((unsigned int )ddst >= (unsigned int )((buf + bufsz) - 1)) {
          free((void *)usects);
          return (-1);
        } else {
          if ((unsigned int )ssrc < (unsigned int )buf) {
            free((void *)usects);
            return (-1);
          } else {
            if ((unsigned int )ssrc >= (unsigned int )((buf + bufsz) - 1)) {
              free((void *)usects);
              return (-1);
            }
          }
        }
      }
      size --;
      tmp___12 = ddst;
      ddst ++;
      tmp___13 = ssrc;
      ssrc ++;
      (*tmp___12) = (*tmp___13);
      backbytes = 0;
      oldback = 0;
      while (size > 0U) {
        oob = doubledl(& ssrc, & mydl, buf, bufsz);
        if (oob == -1) {
          free((void *)usects);
          return (-1);
        }
        if (! oob) {
          if ((unsigned int )ddst < (unsigned int )buf) {
            free((void *)usects);
            return (-1);
          } else {
            if ((unsigned int )ddst >= (unsigned int )((buf + bufsz) - 1)) {
              free((void *)usects);
              return (-1);
            } else {
              if ((unsigned int )ssrc < (unsigned int )buf) {
                free((void *)usects);
                return (-1);
              } else {
                if ((unsigned int )ssrc >= (unsigned int )((buf + bufsz) - 1)) {
                  free((void *)usects);
                  return (-1);
                }
              }
            }
          }
          tmp___14 = ddst;
          ddst ++;
          tmp___15 = ssrc;
          ssrc ++;
          (*tmp___14) = (char )((unsigned int )(*tmp___15) ^ (size & 255U));
          size --;
        } else {
          addsize = 0;
          backbytes ++;
          while (1) {
            oob = doubledl(& ssrc, & mydl, buf, bufsz);
            if (oob == -1) {
              free((void *)usects);
              return (-1);
            }
            backbytes = backbytes * 2 + oob;
            oob = doubledl(& ssrc, & mydl, buf, bufsz);
            if (oob == -1) {
              free((void *)usects);
              return (-1);
            }
            if (! oob) {
              break;
            }
          }
          backbytes -= 3;
          if (backbytes >= 0) {
            backsize = (int )goback;
            while (1) {
              oob = doubledl(& ssrc, & mydl, buf, bufsz);
              if (oob == -1) {
                free((void *)usects);
                return (-1);
              }
              backbytes = backbytes * 2 + oob;
              backsize --;
              if (! backsize) {
                break;
              }
            }
            backbytes = (int )((unsigned int )backbytes ^ 4294967295U);
            addsize += (1 + (backbytes < (int )check2)) + (backbytes < (int )check1);
            oldback = backbytes;
          } else {
            backsize = backbytes + 1;
            backbytes = oldback;
          }
          oob = doubledl(& ssrc, & mydl, buf, bufsz);
          if (oob == -1) {
            free((void *)usects);
            return (-1);
          }
          backsize = backsize * 2 + oob;
          oob = doubledl(& ssrc, & mydl, buf, bufsz);
          if (oob == -1) {
            free((void *)usects);
            return (-1);
          }
          backsize = backsize * 2 + oob;
          if (! backsize) {
            backsize ++;
            while (1) {
              oob = doubledl(& ssrc, & mydl, buf, bufsz);
              if (oob == -1) {
                free((void *)usects);
                return (-1);
              }
              backsize = backsize * 2 + oob;
              oob = doubledl(& ssrc, & mydl, buf, bufsz);
              if (oob == -1) {
                free((void *)usects);
                return (-1);
              }
              if (! oob) {
                break;
              }
            }
            backsize += 2;
          }
          backsize += addsize;
          size -= (unsigned int )backsize;
          if ((unsigned int )ddst < (unsigned int )buf) {
            free((void *)usects);
            return (-1);
          } else {
            if ((unsigned int )(ddst + backsize) >= (unsigned int )(buf + bufsz)) {
              free((void *)usects);
              return (-1);
            } else {
              if ((unsigned int )(ddst + backbytes) < (unsigned int )buf) {
                free((void *)usects);
                return (-1);
              } else {
                if ((unsigned int )((ddst + backbytes) + backsize) >= (unsigned int )(buf +
                                                                                      bufsz)) {
                  free((void *)usects);
                  return (-1);
                }
              }
            }
          }
          while (1) {
            tmp___16 = backsize;
            backsize --;
            if (! tmp___16) {
              break;
            }
            (*ddst) = (*(ddst + backbytes));
            ddst ++;
          }
          backbytes = 0;
          backsize = 0;
        }
      }
      if (j) {
        if ((usects + (j - 1))->rsz > grown) {
          tmp___22 = cli_readint32((char const   *)(((ddst - grown) + 5) + 79));
          if (tmp___22 == 1683931187) {
            tmp___23 = cli_readint32((char const   *)((((ddst - grown) + 5) + 79) +
                                                      4));
            if (tmp___23 == 462100619) {
              goto _L___3;
            } else {
              goto _L___5;
            }
          } else {
            goto _L___5;
          }
        } else {
          _L___5: 
          if ((usects + (j - 1))->rsz > grown + skew) {
            tmp___24 = cli_readint32((char const   *)((((ddst - grown) + 5) + 79) -
                                                      skew));
            if (tmp___24 == 1683931187) {
              tmp___25 = cli_readint32((char const   *)(((((ddst - grown) + 5) + 79) +
                                                         4) - skew));
              if (tmp___25 == 462100619) {
                _L___3: 
                tmp___17 = cli_readint32((char const   *)((((ddst - grown) + 5) +
                                                           79) - skew));
                reloc = (int )(skew * (unsigned int )(tmp___17 == 1683931187));
                tmp___18 = cli_readint32((char const   *)((((ddst - grown) + 15) -
                                                           8) - reloc));
                test1 = (unsigned int )tmp___18 ^ 2640732586U;
                tmp___19 = cli_readint32((char const   *)((((ddst - grown) + 15) -
                                                           4) - reloc));
                test2 = (unsigned int )tmp___19 ^ 3909665923U;
                cli_dbgmsg("Petite: Found petite code in sect%d(%x). Let\'s strip it.\n",
                           j - 1, (usects + (j - 1))->rva);
                if (test1 == test2) {
                  irva = (uint32_t )cli_readint32((char const   *)(((ddst - grown) +
                                                                    289) - reloc));
                  tmp___20 = cli_readint32((char const   *)(((ddst - grown) + 15) -
                                                            reloc));
                  enc_ep = (unsigned int )tmp___20 ^ test1;
                  tmp___21 = cli_readint32((char const   *)(((ddst - grown) + 448) -
                                                            reloc));
                  mangled = (unsigned int )tmp___21 != 2425393296U;
                  cli_dbgmsg("Petite: Encrypted EP: %x | Array of imports: %x\n",
                             enc_ep, irva);
                }
                (usects + (j - 1))->rsz = (usects + (j - 1))->rsz - (grown + (unsigned int )reloc);
              }
            }
          }
        }
      }
      check4resources ++;
    }
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-2VAfpN9j.i","-g -O2 -fPIC")
static int doubledl___0(char **scur , uint8_t *mydlptr , char *buffer , int buffersize ) 
{ unsigned char mydl ;
  unsigned char olddl ;

  {
  mydl = (*mydlptr);
  olddl = mydl;
  mydl = (unsigned char )((int )mydl * 2);
  if (! ((int )olddl & 127)) {
    if ((unsigned int )(*scur) < (unsigned int )buffer) {
      return (-1);
    } else {
      if ((unsigned int )(*scur) >= (unsigned int )((buffer + buffersize) - 1)) {
        return (-1);
      }
    }
    olddl = (unsigned char )(*((*scur)));
    mydl = (unsigned char )((int )olddl * 2 + 1);
    (*scur) = (*scur) + 1;
  }
  (*mydlptr) = mydl;
  return (((int )olddl >> 7) & 1);
}
}
static int unfsg(char *source , char *dest , int ssize , int dsize , char **endsrc ,
                 char **enddst ) 
{ uint8_t mydl ;
  uint32_t backbytes ;
  uint32_t backsize ;
  uint32_t oldback ;
  char *csrc ;
  char *cdst ;
  int oob ;
  int lostbit ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  uint32_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  mydl = (unsigned char)128;
  oldback = 0U;
  csrc = source;
  cdst = dest;
  lostbit = 1;
  tmp = cdst;
  cdst ++;
  tmp___0 = csrc;
  csrc ++;
  (*tmp) = (*tmp___0);
  while (1) {
    oob = doubledl___0(& csrc, & mydl, source, ssize);
    if (oob) {
      if (oob == -1) {
        return (-1);
      }
      backsize = 0U;
      oob = doubledl___0(& csrc, & mydl, source, ssize);
      if (oob) {
        if (oob == -1) {
          return (-1);
        }
        backbytes = 0U;
        oob = doubledl___0(& csrc, & mydl, source, ssize);
        if (oob) {
          if (oob == -1) {
            return (-1);
          }
          lostbit = 1;
          backsize ++;
          backbytes = 16U;
          while (backbytes < 256U) {
            oob = doubledl___0(& csrc, & mydl, source, ssize);
            if (oob == -1) {
              return (-1);
            }
            backbytes = backbytes * 2U + (unsigned int )oob;
          }
          backbytes &= 255U;
          if (! backbytes) {
            if ((unsigned int )cdst >= (unsigned int )(dest + dsize)) {
              return (-1);
            }
            tmp___1 = cdst;
            cdst ++;
            (*tmp___1) = (char)0;
            continue;
          }
        } else {
          if ((unsigned int )csrc >= (unsigned int )(source + ssize)) {
            return (-1);
          }
          backbytes = (unsigned int )(*((unsigned char *)csrc));
          backsize = backsize * 2U + (backbytes & 1U);
          backbytes = (backbytes & 255U) >> 1;
          csrc ++;
          if (! backbytes) {
            break;
          }
          backsize += 2U;
          oldback = backbytes;
          lostbit = 0;
        }
      } else {
        backsize = 1U;
        while (1) {
          oob = doubledl___0(& csrc, & mydl, source, ssize);
          if (oob == -1) {
            return (-1);
          }
          backsize = backsize * 2U + (unsigned int )oob;
          oob = doubledl___0(& csrc, & mydl, source, ssize);
          if (oob == -1) {
            return (-1);
          }
          if (! oob) {
            break;
          }
        }
        backsize = (backsize - 1U) - (unsigned int )lostbit;
        if (! backsize) {
          backsize = 1U;
          while (1) {
            oob = doubledl___0(& csrc, & mydl, source, ssize);
            if (oob == -1) {
              return (-1);
            }
            backsize = backsize * 2U + (unsigned int )oob;
            oob = doubledl___0(& csrc, & mydl, source, ssize);
            if (oob == -1) {
              return (-1);
            }
            if (! oob) {
              break;
            }
          }
          backbytes = oldback;
        } else {
          if ((unsigned int )csrc >= (unsigned int )(source + ssize)) {
            return (-1);
          }
          backbytes = (unsigned int )(*((unsigned char *)csrc));
          backbytes += (backsize - 1U) << 8;
          backsize = 1U;
          csrc ++;
          while (1) {
            oob = doubledl___0(& csrc, & mydl, source, ssize);
            if (oob == -1) {
              return (-1);
            }
            backsize = backsize * 2U + (unsigned int )oob;
            oob = doubledl___0(& csrc, & mydl, source, ssize);
            if (oob == -1) {
              return (-1);
            }
            if (! oob) {
              break;
            }
          }
          if (backbytes >= 32000U) {
            backsize ++;
          }
          if (backbytes >= 1280U) {
            backsize ++;
          }
          if (backbytes <= 127U) {
            backsize += 2U;
          }
          oldback = backbytes;
        }
        lostbit = 0;
      }
      if ((unsigned int )(cdst - backbytes) < (unsigned int )dest) {
        return (-1);
      } else {
        if ((unsigned int )(cdst + backsize) >= (unsigned int )(dest + dsize)) {
          return (-1);
        }
      }
      while (1) {
        tmp___2 = backsize;
        backsize --;
        if (! tmp___2) {
          break;
        }
        (*cdst) = (*(cdst - backbytes));
        cdst ++;
      }
    } else {
      if ((unsigned int )cdst < (unsigned int )dest) {
        return (-1);
      } else {
        if ((unsigned int )cdst >= (unsigned int )(dest + dsize)) {
          return (-1);
        } else {
          if ((unsigned int )csrc < (unsigned int )source) {
            return (-1);
          } else {
            if ((unsigned int )csrc >= (unsigned int )(source + ssize)) {
              return (-1);
            }
          }
        }
      }
      tmp___3 = cdst;
      cdst ++;
      tmp___4 = csrc;
      csrc ++;
      (*tmp___3) = (*tmp___4);
      lostbit = 1;
    }
  }
  (*endsrc) = csrc;
  (*enddst) = cdst;
  return (0);
}
}
int unfsg_200(char *source , char *dest , int ssize , int dsize ) 
{ char *fake ;
  int tmp ;

  {
  tmp = unfsg(source, dest, ssize, dsize, & fake, & fake);
  return (tmp);
}
}
int unfsg_133(char *source , char *dest , int ssize , int dsize , struct SECTION *sections ,
              int sectcount , uint32_t base , uint32_t ep , int file ) 
{ char *tsrc ;
  char *tdst ;
  int i ;
  int upd ;
  int offs ;
  int lastsz ;
  char *startd ;
  int tmp ;
  uint32_t trva ;
  uint32_t trsz ;
  uint32_t traw ;

  {
  tsrc = source;
  tdst = dest;
  upd = 1;
  offs = 0;
  lastsz = dsize;
  i = 0;
  while (i <= sectcount) {
    startd = tdst;
    tmp = unfsg(tsrc, tdst, (tsrc - source) + ssize, (tdst - dest) + dsize, & tsrc,
                & tdst);
    if (tmp == -1) {
      return (-1);
    }
    (sections + i)->raw = (unsigned int )offs;
    (sections + i)->rsz = (unsigned int )(tdst - startd);
    offs += tdst - startd;
    i ++;
  }
  while (upd) {
    upd = 0;
    i = 0;
    while (i < sectcount) {
      if ((sections + i)->rva < (sections + (i + 1))->rva) {
        goto __Cont;
      }
      trva = (sections + i)->rva;
      traw = (sections + i)->raw;
      trsz = (sections + i)->rsz;
      (sections + i)->rva = (sections + (i + 1))->rva;
      (sections + i)->rsz = (sections + (i + 1))->rsz;
      (sections + i)->raw = (sections + (i + 1))->raw;
      (sections + (i + 1))->rva = trva;
      (sections + (i + 1))->raw = traw;
      (sections + (i + 1))->rsz = trsz;
      upd = 1;
      __Cont: 
      i ++;
    }
  }
  i = 0;
  while (i <= sectcount) {
    if (i != sectcount) {
      (sections + i)->vsz = (sections + (i + 1))->rva - (sections + i)->rva;
      lastsz = (int )((unsigned int )lastsz - ((sections + (i + 1))->rva - (sections +
                                                                            i)->rva));
    } else {
      (sections + i)->vsz = (unsigned int )lastsz;
    }
    cli_dbgmsg("FSG: .SECT%d RVA:%x VSize:%x ROffset: %x, RSize:% x\n", i, (sections +
                                                                            i)->rva,
               (sections + i)->vsz, (sections + i)->raw, (sections + i)->rsz);
    i ++;
  }
  tsrc = rebuildpe(dest, sections, sectcount + 1, base, ep, 0U, 0U);
  if (tsrc) {
    write(file, (void const   *)tsrc, (unsigned int )((456 + 40 * (sectcount + 1)) +
                                                      offs));
    free((void *)tsrc);
  } else {
    free((void *)tsrc);
    cli_dbgmsg("FSG: Rebuilding failed\n");
    return (0);
  }
  return (1);
}
}
#pragma merger(0,"/tmp/cil-NCBuzdfd.i","-g -O2 -fPIC")
line_t *lineCreate(char const   *data ) 
{ size_t size ;
  size_t tmp ;
  line_t *ret ;
  line_t *tmp___0 ;

  {
  tmp = strlen(data);
  size = tmp;
  tmp___0 = (line_t *)cli_malloc(size + 2U);
  ret = tmp___0;
  if ((unsigned int )ret == (unsigned int )((void *)0)) {
    return ((line_t *)((void *)0));
  }
  (*(ret + 0)) = (char)1;
  memcpy((void * __restrict  )(ret + 1), (void const   * __restrict  )data, size);
  (*(ret + (size + 1U))) = (char )'\000';
  return (ret);
}
}
line_t *lineLink(line_t *line ) 
{ char const   *tmp ;
  char const   *tmp___0 ;
  line_t *tmp___1 ;

  {
  if ((int )((unsigned char )(*(line + 0))) == 255) {
    tmp = lineGetData((line_t const   *)line);
    cli_dbgmsg("lineLink: linkcount too large (%s)\n", tmp);
    tmp___0 = lineGetData((line_t const   *)line);
    tmp___1 = lineCreate(tmp___0);
    return (tmp___1);
  }
  (*(line + 0)) = (char )((int )(*(line + 0)) + 1);
  return (line);
}
}
line_t *lineUnlink(line_t *line ) 
{ 

  {
  (*(line + 0)) = (char )((int )(*(line + 0)) - 1);
  if ((int )(*(line + 0)) == 0) {
    free((void *)line);
    return ((line_t *)((void *)0));
  }
  return (line);
}
}
char const   *lineGetData(line_t const   *line ) 
{ line_t const   *tmp ;

  {
  if (line) {
    tmp = line + 1;
  } else {
    tmp = (line_t const   *)((void *)0);
  }
  return (tmp);
}
}
unsigned char lineGetRefCount(line_t const   *line ) 
{ 

  {
  return ((unsigned char )(*(line + 0)));
}
}
#pragma merger(0,"/tmp/cil-pBK53o0L.i","-g -O2 -fPIC")
static int octal(char const   *str ) 
{ int ret ;

  {
  ret = -1;
  sscanf((char const   * __restrict  )str, (char const   * __restrict  )"%o", (unsigned int *)(& ret));
  return (ret);
}
}
int cli_untar(char const   *dir , int desc , unsigned int posix ) 
{ int size ;
  int in_block ;
  char fullname[256] ;
  FILE *outfile ;
  char const   *tmp ;
  char block[512] ;
  int nread ;
  int tmp___0 ;
  char type ;
  char const   *suffix ;
  size_t suffixLen ;
  int fd ;
  int directory ;
  char magic[7] ;
  char name[101] ;
  char osize[13] ;
  int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___37 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___56 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  size_t tmp___71 ;
  int *tmp___72 ;
  char *tmp___73 ;
  size_t tmp___74 ;
  int nbytes ;
  int tmp___75 ;
  int nwritten ;
  int tmp___76 ;
  int tmp___77 ;

  {
  size = 0;
  in_block = 0;
  outfile = (FILE *)((void *)0);
  if (dir) {
    tmp = dir;
  } else {
    tmp = "";
  }
  cli_dbgmsg("In untar(%s, %d)\n", tmp, desc);
  while (1) {
    tmp___0 = cli_readn(desc, (void *)(block), sizeof(block));
    nread = tmp___0;
    if (! in_block) {
      if (nread == 0) {
        break;
      }
    }
    if (nread < 0) {
      if (outfile) {
        fclose(outfile);
      }
      cli_errmsg("cli_untar: block read error\n");
      return (-12);
    }
    if (! in_block) {
      suffixLen = 0U;
      if (outfile) {
        tmp___1 = fclose(outfile);
        if (tmp___1) {
          cli_errmsg("cli_untar: cannot close file %s\n", fullname);
          return (-12);
        }
        outfile = (FILE *)0;
      }
      if ((int )block[0] == 0) {
        break;
      }
      if (posix) {
        __builtin_strncpy(magic, block + 257, 5);
        magic[5] = (char )'\000';
        tmp___68 = __builtin_constant_p((int )(magic));
        if (tmp___68) {
          tmp___69 = __builtin_constant_p((int )"ustar");
          if (tmp___69) {
            __s1_len = strlen((char const   *)(magic));
            __s2_len = strlen("ustar");
            if (! ((unsigned int )((void const   *)(magic + 1)) - (unsigned int )((void const   *)(magic)) ==
                   1U)) {
              goto _L___16;
            } else {
              if (__s1_len >= 4U) {
                _L___16: 
                if (! ((unsigned int )((void const   *)("ustar" + 1)) - (unsigned int )((void const   *)"ustar") ==
                       1U)) {
                  tmp___70 = 1;
                } else {
                  if (__s2_len >= 4U) {
                    tmp___70 = 1;
                  } else {
                    tmp___70 = 0;
                  }
                }
              } else {
                tmp___70 = 0;
              }
            }
            if (tmp___70) {
              tmp___37 = __builtin_strcmp(magic, "ustar");
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: 
          tmp___67 = __builtin_constant_p((int )(magic));
          if (tmp___67) {
            if ((unsigned int )((void const   *)(magic + 1)) - (unsigned int )((void const   *)(magic)) ==
                1U) {
              __s1_len = strlen((char const   *)(magic));
              if (__s1_len < 4U) {
                tmp___56 = __builtin_constant_p((int )"ustar");
                if (tmp___56) {
                  if ((unsigned int )((void const   *)("ustar" + 1)) - (unsigned int )((void const   *)"ustar") ==
                      1U) {
                    tmp___37 = __builtin_strcmp(magic, "ustar");
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: 
                  __s2___6 = (unsigned char const   *)"ustar";
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(magic)) +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
                  if (__s1_len > 0U) {
                    if (__result___18 == 0) {
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(magic)) +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
                      if (__s1_len > 1U) {
                        if (__result___18 == 0) {
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(magic)) +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
                          if (__s1_len > 2U) {
                            if (__result___18 == 0) {
                              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(magic)) +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___37 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: 
            tmp___66 = __builtin_constant_p((int )"ustar");
            if (tmp___66) {
              if ((unsigned int )((void const   *)("ustar" + 1)) - (unsigned int )((void const   *)"ustar") ==
                  1U) {
                __s2_len = strlen("ustar");
                if (__s2_len < 4U) {
                  tmp___65 = __builtin_constant_p((int )(magic));
                  if (tmp___65) {
                    if ((unsigned int )((void const   *)(magic + 1)) - (unsigned int )((void const   *)(magic)) ==
                        1U) {
                      tmp___37 = __builtin_strcmp(magic, "ustar");
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: 
                    __s1___14 = (unsigned char const   *)((char const   *)(magic));
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"ustar" +
                                                                                               0)));
                    if (__s2_len > 0U) {
                      if (__result___22 == 0) {
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)"ustar" +
                                                                1)));
                        if (__s2_len > 1U) {
                          if (__result___22 == 0) {
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)"ustar" +
                                                                    2)));
                            if (__s2_len > 2U) {
                              if (__result___22 == 0) {
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)"ustar" +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___37 = __result___22;
                  }
                } else {
                  tmp___37 = __builtin_strcmp(magic, "ustar");
                }
              } else {
                tmp___37 = __builtin_strcmp(magic, "ustar");
              }
            } else {
              tmp___37 = __builtin_strcmp(magic, "ustar");
            }
          }
        }
        if (tmp___37 != 0) {
          cli_dbgmsg("Incorrect magic string \'%s\' in tar header\n", magic);
          return (-13);
        }
      }
      type = block[156];
      switch ((int )type) {
      case 48: ;
      case 0: ;
      case 55: 
      directory = 0;
      break;
      case 49: ;
      case 53: ;
      case 50: ;
      case 51: ;
      case 52: ;
      case 54: 
      directory = 1;
      break;
      case 76: 
      cli_errmsg("cli_untar: only standard TAR files are currently supported\n", type);
      return (-13);
      default: 
      cli_dbgmsg("cli_untar: unknown type flag %c\n", type);
      return (0);
      }
      if (directory) {
        in_block = 0;
        goto __Cont;
      }
      __builtin_strncpy(name, block, 100);
      name[100] = (char )'\000';
      sanitiseName(name);
      suffix = strrchr((char const   *)(name), '.');
      if ((unsigned int )suffix == (unsigned int )((void *)0)) {
        suffix = "";
      } else {
        suffixLen = strlen(suffix);
        if (suffixLen > 4U) {
          suffix = "";
          suffixLen = 0U;
        }
      }
      tmp___71 = strlen(dir);
      snprintf((char * __restrict  )(fullname), (sizeof(fullname) - 1U) - suffixLen,
               (char const   * __restrict  )"%s/%.*sXXXXXX", dir, (int )(((sizeof(fullname) -
                                                                           9U) - suffixLen) -
                                                                         tmp___71),
               name);
      fd = mkstemp(fullname);
      if (fd < 0) {
        tmp___72 = __errno_location();
        tmp___73 = strerror((*tmp___72));
        cli_errmsg("Can\'t create temporary file %s: %s\n", fullname, tmp___73);
        tmp___74 = strlen((char const   *)(fullname));
        cli_dbgmsg("%lu %d %d\n", suffixLen, sizeof(fullname), tmp___74);
        return (-1);
      }
      cli_dbgmsg("cli_untar: extracting %s\n", fullname);
      in_block = 1;
      outfile = fdopen(fd, "wb");
      if ((unsigned int )outfile == (unsigned int )((void *)0)) {
        cli_errmsg("cli_untar: cannot create file %s\n", fullname);
        close(fd);
        return (-1);
      }
      __builtin_strncpy(osize, block + 124, 12);
      osize[12] = (char )'\000';
      size = octal((char const   *)(osize));
      if (size < 0) {
        cli_errmsg("Invalid size in tar header\n");
        fclose(outfile);
        return (-13);
      }
      cli_dbgmsg("cli_untar: size = %d\n", size);
    } else {
      if (size > 512) {
        tmp___75 = 512;
      } else {
        tmp___75 = size;
      }
      nbytes = tmp___75;
      tmp___76 = (int )fwrite((void const   * __restrict  )(block), 1U, (unsigned int )nbytes,
                              (FILE * __restrict  )outfile);
      nwritten = tmp___76;
      if (nwritten != nbytes) {
        cli_errmsg("cli_untar: only wrote %d bytes to file %s (out of disk space?)\n",
                   nwritten, fullname);
        fclose(outfile);
        return (-12);
      }
      size -= nbytes;
    }
    if (size == 0) {
      in_block = 0;
    }
    __Cont: ;
  }
  if (outfile) {
    tmp___77 = fclose(outfile);
    return (tmp___77);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-UwLK3OeV.i","-g -O2 -fPIC")
int cli_check_mydoom_log(int desc , char const   **virname ) 
{ int32_t record[8] ;
  int32_t check ;
  int i ;
  int retval ;
  int j ;
  int tmp ;
  register unsigned int __v ;
  register unsigned int __x ;
  int tmp___0 ;
  register unsigned int __v___0 ;
  register unsigned int __x___0 ;
  int tmp___1 ;

  {
  retval = 1;
  cli_dbgmsg("in cli_check_mydoom_log()\n");
  j = 0;
  while (j < 5) {
    tmp = cli_readn(desc, (void *)(& record), 32U);
    if (tmp != 32) {
      break;
    }
    __x = (unsigned int )record[0];
    tmp___0 = __builtin_constant_p((int )__x);
    if (tmp___0) {
      __v = ((((__x & 4278190080U) >> 24) | ((__x & 16711680U) >> 8)) | ((__x & 65280U) <<
                                                                         8)) | ((__x &
                                                                                 255U) <<
                                                                                24);
    } else {
      __asm__  ("rorw $8, %w0;"
                "rorl $16, %0;"
                "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
    }
    record[0] = (int )(~ __v);
    cli_dbgmsg("Mydoom: key: %lu\n", record[0]);
    check = 0;
    i = 1;
    while (i < 8) {
      __x___0 = (unsigned int )record[i];
      tmp___1 = __builtin_constant_p((int )__x___0);
      if (tmp___1) {
        __v___0 = ((((__x___0 & 4278190080U) >> 24) | ((__x___0 & 16711680U) >> 8)) |
                   ((__x___0 & 65280U) << 8)) | ((__x___0 & 255U) << 24);
      } else {
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
      }
      record[i] = (int )(__v___0 ^ (unsigned int )record[0]);
      check += record[i];
      i ++;
    }
    cli_dbgmsg("Mydoom: check: %lu\n", ~ check);
    if (~ check != record[0]) {
      return (0);
    }
    j ++;
  }
  if (j < 2) {
    retval = 0;
  } else {
    if (retval == 1) {
      if (virname) {
        (*virname) = "Worm.Mydoom.M.log";
      }
    }
  }
  return (retval);
}
}
static int jpeg_check_photoshop_8bim(int fd ) 
{ unsigned char bim[5] ;
  uint16_t id ;
  uint16_t ntmp ;
  uint8_t nlength ;
  uint32_t size ;
  off_t offset ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = cli_readn(fd, (void *)(bim), 4U);
  if (tmp != 4) {
    cli_dbgmsg("read bim failed\n");
    return (-1);
  }
  tmp___0 = memcmp((void const   *)(bim), (void const   *)"8BIM", 4U);
  if (tmp___0 != 0) {
    bim[4] = (unsigned char )'\000';
    cli_dbgmsg("missed 8bim: %s\n", bim);
    return (-1);
  }
  tmp___1 = cli_readn(fd, (void *)(& id), 2U);
  if (tmp___1 != 2) {
    return (-1);
  }
  id = id;
  cli_dbgmsg("ID: 0x%.4x\n", id);
  tmp___2 = cli_readn(fd, (void *)(& nlength), 1U);
  if (tmp___2 != 1) {
    return (-1);
  }
  ntmp = (unsigned short )((int )nlength + (((int )((unsigned short )nlength) + 1) &
                                            1));
  lseek(fd, (long )ntmp, 1);
  tmp___3 = cli_readn(fd, (void *)(& size), 4U);
  if (tmp___3 != 4) {
    return (-1);
  }
  size = size;
  if (size == 0U) {
    return (-1);
  }
  if ((size & 1U) == 1U) {
    size ++;
  }
  if ((int )id != 1033) {
    if ((int )id != 1036) {
      lseek(fd, (long )size, 1);
      return (0);
    }
  }
  cli_dbgmsg("found thumbnail\n");
  offset = lseek(fd, 0L, 1);
  lseek(fd, 28L, 1);
  retval = cli_check_jpeg_exploit(fd);
  if (retval == 1) {
    cli_dbgmsg("Exploit found in thumbnail\n", retval);
  }
  lseek(fd, (long )((unsigned long )offset + (unsigned long )size), 0);
  return (retval);
}
}
static int jpeg_check_photoshop(int fd ) 
{ int retval ;
  unsigned char buffer[14] ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = cli_readn(fd, (void *)(buffer), 14U);
  if (tmp != 14) {
    return (0);
  }
  tmp___0 = memcmp((void const   *)(buffer), (void const   *)"Photoshop 3.0", 14U);
  if (tmp___0 != 0) {
    return (0);
  }
  cli_dbgmsg("Found Photoshop segment\n");
  while (1) {
    retval = jpeg_check_photoshop_8bim(fd);
    if (! (retval == 0)) {
      break;
    }
  }
  if (retval == -1) {
    retval = 0;
  }
  return (retval);
}
}
int cli_check_jpeg_exploit(int fd ) 
{ unsigned char buffer[4] ;
  off_t offset ;
  int retval ;
  int tmp ;
  __off_t tmp___0 ;
  __off_t tmp___1 ;

  {
  cli_dbgmsg("in cli_check_jpeg_exploit()\n");
  tmp = cli_readn(fd, (void *)(buffer), 2U);
  if (tmp != 2) {
    return (0);
  }
  if ((int )buffer[0] != 255) {
    return (0);
  } else {
    if ((int )buffer[1] != 216) {
      return (0);
    }
  }
  while (1) {
    retval = cli_readn(fd, (void *)(buffer), 4U);
    if (retval != 4) {
      return (0);
    }
    if ((int )buffer[0] == 255) {
      if ((int )buffer[1] == 255) {
        lseek(fd, -3L, 1);
        goto __Cont;
      }
    }
    if ((int )buffer[0] == 255) {
      if ((int )buffer[1] == 254) {
        if ((int )buffer[2] == 0) {
          if ((int )buffer[3] == 0) {
            return (1);
          } else {
            if ((int )buffer[3] == 1) {
              return (1);
            }
          }
        }
      }
    }
    if ((int )buffer[0] != 255) {
      return (-1);
    }
    if ((int )buffer[1] == 218) {
      return (0);
    }
    offset = (long )(((unsigned int )buffer[2] << 8) + (unsigned int )buffer[3]);
    if (offset < 2L) {
      return (1);
    }
    offset -= 2L;
    tmp___0 = lseek(fd, 0L, 1);
    offset += tmp___0;
    if ((int )buffer[1] == 237) {
      retval = jpeg_check_photoshop(fd);
      if (retval != 0) {
        return (retval);
      }
    }
    tmp___1 = lseek(fd, offset, 0);
    if (tmp___1 != offset) {
      return (-1);
    }
    __Cont: ;
  }
  return (0);
}
}
static uint32_t riff_endian_convert_32(uint32_t value , int big_endian ) 
{ 

  {
  if (big_endian) {
    return (value);
  } else {
    return ((((value >> 24) | ((value & 16711680U) >> 8)) | ((value & 65280U) << 8)) |
            (value << 24));
  }
}
}
static int riff_read_chunk(int fd , int big_endian , int rec_level ) 
{ uint32_t chunk_id ;
  uint32_t chunk_size ;
  int length ;
  uint32_t list_type ;
  off_t offset ;
  off_t cur_offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __off_t tmp___9 ;

  {
  if (rec_level > 1000) {
    cli_dbgmsg("riff_read_chunk: recursion level exceeded\n");
    return (0);
  }
  length = (int )sizeof(uint32_t );
  tmp = cli_readn(fd, (void *)(& chunk_id), (unsigned int )length);
  if (tmp != length) {
    return (0);
  }
  tmp___0 = cli_readn(fd, (void *)(& chunk_size), (unsigned int )length);
  if (tmp___0 != length) {
    return (0);
  }
  chunk_size = riff_endian_convert_32(chunk_size, big_endian);
  tmp___2 = memcmp((void const   *)(& chunk_id), (void const   *)"RIFF", 4U);
  if (tmp___2 == 0) {
    return (0);
  } else {
    tmp___1 = memcmp((void const   *)(& chunk_id), (void const   *)"RIFX", 4U);
    if (tmp___1 == 0) {
      return (0);
    }
  }
  tmp___5 = memcmp((void const   *)(& chunk_id), (void const   *)"LIST", 4U);
  if (tmp___5 == 0) {
    goto _L;
  } else {
    tmp___6 = memcmp((void const   *)(& chunk_id), (void const   *)"PROP", 4U);
    if (tmp___6 == 0) {
      goto _L;
    } else {
      tmp___7 = memcmp((void const   *)(& chunk_id), (void const   *)"FORM", 4U);
      if (tmp___7 == 0) {
        goto _L;
      } else {
        tmp___8 = memcmp((void const   *)(& chunk_id), (void const   *)"CAT ", 4U);
        if (tmp___8 == 0) {
          _L: 
          tmp___3 = cli_readn(fd, (void *)(& list_type), sizeof(list_type));
          if ((unsigned int )tmp___3 != sizeof(list_type)) {
            cli_dbgmsg("riff_read_chunk: read list type failed\n");
            return (0);
          }
          rec_level ++;
          tmp___4 = riff_read_chunk(fd, big_endian, rec_level);
          return (tmp___4);
        }
      }
    }
  }
  cur_offset = lseek(fd, 0L, 1);
  offset = (long )((unsigned long )cur_offset + (unsigned long )chunk_size);
  if ((offset & 1L) == 1L) {
    offset ++;
  }
  if (offset < cur_offset) {
    return (0);
  }
  tmp___9 = lseek(fd, offset, 0);
  if (tmp___9 != offset) {
    return (2);
  }
  return (1);
}
}
int cli_check_riff_exploit(int fd ) 
{ uint32_t chunk_id ;
  uint32_t chunk_size ;
  uint32_t form_type ;
  int length ;
  int big_endian ;
  int retval ;
  off_t offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  cli_dbgmsg("in cli_check_riff_exploit()\n");
  length = (int )sizeof(uint32_t );
  tmp = cli_readn(fd, (void *)(& chunk_id), (unsigned int )length);
  if (tmp != length) {
    return (0);
  }
  tmp___0 = cli_readn(fd, (void *)(& chunk_size), (unsigned int )length);
  if (tmp___0 != length) {
    return (0);
  }
  tmp___1 = cli_readn(fd, (void *)(& form_type), (unsigned int )length);
  if (tmp___1 != length) {
    return (0);
  }
  tmp___3 = memcmp((void const   *)(& chunk_id), (void const   *)"RIFF", 4U);
  if (tmp___3 == 0) {
    big_endian = 0;
  } else {
    tmp___2 = memcmp((void const   *)(& chunk_id), (void const   *)"RIFX", 4U);
    if (tmp___2 == 0) {
      big_endian = 1;
    } else {
      return (0);
    }
  }
  tmp___4 = memcmp((void const   *)(& form_type), (void const   *)"ACON", 4U);
  if (tmp___4 != 0) {
    return (0);
  }
  chunk_size = riff_endian_convert_32(chunk_size, big_endian);
  while (1) {
    retval = riff_read_chunk(fd, big_endian, 1);
    if (! (retval == 1)) {
      break;
    }
  }
  offset = lseek(fd, 0L, 1);
  if ((long long )offset < (long long )chunk_size) {
    retval = 2;
  }
  return (retval);
}
}
#pragma merger(0,"/tmp/cil-qjgrNqZJ.i","-g -O2 -fPIC")
int cli_binhex(char const   *dir , int desc ) 
{ struct stat statb ;
  char *buf ;
  char *start ;
  char *line ;
  size_t size ;
  long bytesleft ;
  message *m ;
  fileblob *fb ;
  int tmp ;
  int length ;
  char *ptr ;
  int tmp___0 ;
  text const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  tmp = fstat__extinline(desc, & statb);
  if (tmp < 0) {
    return (-4);
  }
  size = (unsigned int )statb.st_size;
  if (size == 0U) {
    return (0);
  }
  m = messageCreate();
  if ((unsigned int )m == (unsigned int )((void *)0)) {
    return (-3);
  }
  buf = (char *)mmap((void *)0, size, 1, 1, desc, 0L);
  start = buf;
  if ((unsigned int )buf == (unsigned int )((void *)-1)) {
    messageDestroy(m);
    return (-3);
  }
  cli_dbgmsg("mmap\'ed binhex file\n");
  bytesleft = (long )((int )size);
  line = (char *)((void *)0);
  while (bytesleft > 0L) {
    length = 0;
    ptr = buf;
    while (1) {
      if (bytesleft) {
        if ((int )(*ptr) != 10) {
          if (! ((int )(*ptr) != 13)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      length ++;
      bytesleft --;
      ptr ++;
    }
    line = (char *)cli_realloc((void *)line, (unsigned int )(length + 1));
    memcpy((void * __restrict  )line, (void const   * __restrict  )buf, (unsigned int )length);
    (*(line + length)) = (char )'\000';
    tmp___0 = messageAddStr(m, (char const   *)line);
    if (tmp___0 < 0) {
      break;
    }
    if (bytesleft > 0L) {
      if ((int )(*ptr) == 13) {
        ptr ++;
        bytesleft --;
      }
    }
    ptr ++;
    buf = ptr;
    bytesleft --;
  }
  munmap((void *)start, size);
  if (line) {
    free((void *)line);
  }
  tmp___1 = binhexBegin((message const   *)m);
  if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
    messageDestroy(m);
    cli_errmsg("No binhex line found\n");
    return (-13);
  }
  messageSetEncoding(m, "x-binhex");
  fb = messageToFileblob(m, dir);
  if (fb) {
    tmp___2 = fileblobGetFilename((fileblob const   *)fb);
    cli_dbgmsg("Binhex file decoded to %s\n", tmp___2);
    fileblobDestroy(fb);
  } else {
    cli_errmsg("Couldn\'t decode binhex file to %s\n", dir);
  }
  messageDestroy(m);
  if (fb) {
    return (0);
  }
  return (-4);
}
}
#pragma merger(0,"/tmp/cil-os3Ku5bd.i","-g -O2 -fPIC")
static int from_oct(int digs , char *where ) ;
int is_tar(unsigned char *buf , int nbytes ) 
{ union record *header ;
  int i ;
  int sum ;
  int recsum ;
  char *p ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___35 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___54 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;

  {
  header = (union record *)buf;
  if ((unsigned int )nbytes < sizeof(union record )) {
    return (0);
  }
  recsum = from_oct(8, header->header.chksum);
  sum = 0;
  p = header->charptr;
  i = (int )sizeof(union record );
  while (1) {
    i --;
    if (! (i >= 0)) {
      break;
    }
    tmp = p;
    p ++;
    sum += 255 & (int )(*tmp);
  }
  i = (int )sizeof(header->header.chksum);
  while (1) {
    i --;
    if (! (i >= 0)) {
      break;
    }
    sum -= 255 & (int )header->header.chksum[i];
  }
  sum = (int )((unsigned int )sum + 32U * sizeof(header->header.chksum));
  if (sum != recsum) {
    return (0);
  }
  tmp___66 = __builtin_constant_p((int )(header->header.magic));
  if (tmp___66) {
    tmp___67 = __builtin_constant_p((int )"ustar  ");
    if (tmp___67) {
      __s1_len = strlen((char const   *)(header->header.magic));
      __s2_len = strlen("ustar  ");
      if (! ((unsigned int )((void const   *)(header->header.magic + 1)) - (unsigned int )((void const   *)(header->header.magic)) ==
             1U)) {
        goto _L___16;
      } else {
        if (__s1_len >= 4U) {
          _L___16: 
          if (! ((unsigned int )((void const   *)("ustar  " + 1)) - (unsigned int )((void const   *)"ustar  ") ==
                 1U)) {
            tmp___68 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___68 = 1;
            } else {
              tmp___68 = 0;
            }
          }
        } else {
          tmp___68 = 0;
        }
      }
      if (tmp___68) {
        tmp___35 = __builtin_strcmp(header->header.magic, "ustar  ");
      } else {
        goto _L___18;
      }
    } else {
      goto _L___18;
    }
  } else {
    _L___18: 
    tmp___65 = __builtin_constant_p((int )(header->header.magic));
    if (tmp___65) {
      if ((unsigned int )((void const   *)(header->header.magic + 1)) - (unsigned int )((void const   *)(header->header.magic)) ==
          1U) {
        __s1_len = strlen((char const   *)(header->header.magic));
        if (__s1_len < 4U) {
          tmp___54 = __builtin_constant_p((int )"ustar  ");
          if (tmp___54) {
            if ((unsigned int )((void const   *)("ustar  " + 1)) - (unsigned int )((void const   *)"ustar  ") ==
                1U) {
              tmp___35 = __builtin_strcmp(header->header.magic, "ustar  ");
            } else {
              goto _L___11;
            }
          } else {
            _L___11: 
            __s2___6 = (unsigned char const   *)"ustar  ";
            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(header->header.magic)) +
                                                    0)) - (int const   )(*(__s2___6 +
                                                                           0)));
            if (__s1_len > 0U) {
              if (__result___18 == 0) {
                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(header->header.magic)) +
                                                        1)) - (int const   )(*(__s2___6 +
                                                                               1)));
                if (__s1_len > 1U) {
                  if (__result___18 == 0) {
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(header->header.magic)) +
                                                            2)) - (int const   )(*(__s2___6 +
                                                                                   2)));
                    if (__s1_len > 2U) {
                      if (__result___18 == 0) {
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(header->header.magic)) +
                                                                3)) - (int const   )(*(__s2___6 +
                                                                                       3)));
                      }
                    }
                  }
                }
              }
            }
            tmp___35 = __result___18;
          }
        } else {
          goto _L___15;
        }
      } else {
        goto _L___15;
      }
    } else {
      _L___15: 
      tmp___64 = __builtin_constant_p((int )"ustar  ");
      if (tmp___64) {
        if ((unsigned int )((void const   *)("ustar  " + 1)) - (unsigned int )((void const   *)"ustar  ") ==
            1U) {
          __s2_len = strlen("ustar  ");
          if (__s2_len < 4U) {
            tmp___63 = __builtin_constant_p((int )(header->header.magic));
            if (tmp___63) {
              if ((unsigned int )((void const   *)(header->header.magic + 1)) - (unsigned int )((void const   *)(header->header.magic)) ==
                  1U) {
                tmp___35 = __builtin_strcmp(header->header.magic, "ustar  ");
              } else {
                goto _L___13;
              }
            } else {
              _L___13: 
              __s1___14 = (unsigned char const   *)((char const   *)(header->header.magic));
              __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"ustar  " +
                                                                                         0)));
              if (__s2_len > 0U) {
                if (__result___22 == 0) {
                  __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)"ustar  " +
                                                                                             1)));
                  if (__s2_len > 1U) {
                    if (__result___22 == 0) {
                      __result___22 = (int )((int const   )(*(__s1___14 + 2)) - (int const   )(*((unsigned char const   *)"ustar  " +
                                                                                                 2)));
                      if (__s2_len > 2U) {
                        if (__result___22 == 0) {
                          __result___22 = (int )((int const   )(*(__s1___14 + 3)) -
                                                 (int const   )(*((unsigned char const   *)"ustar  " +
                                                                  3)));
                        }
                      }
                    }
                  }
                }
              }
              tmp___35 = __result___22;
            }
          } else {
            tmp___35 = __builtin_strcmp(header->header.magic, "ustar  ");
          }
        } else {
          tmp___35 = __builtin_strcmp(header->header.magic, "ustar  ");
        }
      } else {
        tmp___35 = __builtin_strcmp(header->header.magic, "ustar  ");
      }
    }
  }
  if (0 == tmp___35) {
    return (2);
  }
  return (1);
}
}
static int from_oct(int digs , char *where ) 
{ int value ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*where)))) & 8192)) {
      break;
    }
    where ++;
    digs --;
    if (digs <= 0) {
      return (-1);
    }
  }
  value = 0;
  while (1) {
    if (digs > 0) {
      if ((int )(*where) >= 48) {
        if (! ((int )(*where) <= 55)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    tmp___0 = where;
    where ++;
    value = (value << 3) | ((int )(*tmp___0) - 48);
    digs --;
  }
  if (digs > 0) {
    if ((*where)) {
      tmp___1 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___1) + (int )((unsigned char )(*where)))) & 8192)) {
        return (-1);
      }
    }
  }
  return (value);
}
}
#pragma merger(0,"/tmp/cil-5Ws5WnJV.i","-g -O2 -fPIC")
static int tnef_message(FILE *fp , uint16_t type , uint16_t tag , uint32_t length ) ;
static int tnef_attachment(FILE *fp , uint16_t type , uint16_t tag , uint32_t length ,
                           char const   *dir , fileblob **fbref ) ;
static int tnef_header(FILE *fp , uint8_t *part , uint16_t *type , uint16_t *tag ,
                       uint32_t *length ) ;
int cli_tnef(char const   *dir , int desc ) 
{ uint32_t i32 ;
  uint16_t i16 ;
  fileblob *fb ;
  int i ;
  int ret ;
  int alldone ;
  FILE *fp ;
  size_t tmp ;
  size_t tmp___0 ;
  uint8_t part ;
  uint16_t type ;
  uint16_t tag ;
  uint32_t length ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int fout ;
  char *filename ;
  char *tmp___5 ;
  char buffer[8192] ;
  int count ;

  {
  lseek(desc, 0L, 0);
  i = dup(desc);
  fp = fdopen(i, "rb");
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
    cli_errmsg("Can\'t open descriptor %d\n", desc);
    close(i);
    return (-4);
  }
  tmp = fread((void * __restrict  )(& i32), sizeof(uint32_t ), 1U, (FILE * __restrict  )fp);
  if (tmp != 1U) {
    fclose(fp);
    return (-12);
  }
  if (((((i32 >> 24) | ((i32 & 16711680U) >> 8)) | ((i32 & 65280U) << 8)) | (i32 <<
                                                                             24)) !=
      574529400U) {
    fclose(fp);
    return (-13);
  }
  tmp___0 = fread((void * __restrict  )(& i16), sizeof(uint16_t ), 1U, (FILE * __restrict  )fp);
  if (tmp___0 != 1U) {
    fclose(fp);
    return (-12);
  }
  fb = (fileblob *)((void *)0);
  ret = 0;
  alldone = 0;
  while (1) {
    tmp___1 = tnef_header(fp, & part, & type, & tag, & length);
    switch (tmp___1) {
    case 0: 
    tmp___2 = ferror(fp);
    if (tmp___2) {
      perror("read");
      ret = -12;
    }
    alldone = 1;
    break;
    case 1: ;
    break;
    default: 
    ret = -12;
    alldone = 1;
    break;
    }
    if (alldone) {
      break;
    }
    switch ((int )part) {
    case 1: 
    cli_dbgmsg("TNEF - found message\n");
    if ((unsigned int )fb != (unsigned int )((void *)0)) {
      fileblobDestroy(fb);
      fb = (fileblob *)((void *)0);
    }
    fb = fileblobCreate();
    tmp___3 = tnef_message(fp, type, tag, length);
    if (tmp___3 != 0) {
      cli_errmsg("Error reading TNEF message\n");
      ret = -13;
      alldone = 1;
    }
    break;
    case 2: 
    cli_dbgmsg("TNEF - found attachment\n");
    tmp___4 = tnef_attachment(fp, type, tag, length, dir, & fb);
    if (tmp___4 != 0) {
      cli_errmsg("Error reading TNEF message\n");
      ret = -13;
      alldone = 1;
    }
    break;
    case 0: ;
    break;
    default: 
    cli_warnmsg("TNEF - unknown level %d tag 0x%x\n", (int )part, (int )tag);
    if (cli_debug_flag) {
      tmp___5 = cli_gentemp((char const   *)((void *)0));
      filename = tmp___5;
      fout = open((char const   *)filename, 705, 384);
      if (fout >= 0) {
        cli_warnmsg("Saving dump to %s - send to bugs@clamav.net\n", filename);
        lseek(desc, 0L, 0);
        while (1) {
          count = cli_readn(desc, (void *)(buffer), sizeof(buffer));
          if (! (count > 0)) {
            break;
          }
          cli_writen(fout, (void *)(buffer), (unsigned int )count);
        }
        close(fout);
      }
      free((void *)filename);
    }
    ret = -13;
    alldone = 1;
    break;
    }
    if (! (! alldone)) {
      break;
    }
  }
  if (fb) {
    fileblobDestroy(fb);
    fb = (fileblob *)((void *)0);
  }
  fclose(fp);
  cli_dbgmsg("cli_tnef: returning %d\n", ret);
  return (ret);
}
}
static int tnef_message(FILE *fp , uint16_t type , uint16_t tag , uint32_t length ) 
{ uint16_t i16 ;
  off_t offset ;
  size_t tmp ;

  {
  cli_dbgmsg("message tag 0x%x, type 0x%x, length %u\n", tag, type, length);
  offset = ftell(fp);
  switch ((int )tag) {
  case 32780: 
  cli_warnmsg("TNEF body not being scanned - if you believe this file contains a virus, submit it to www.clamav.net\n");
  break;
  }
  fseek(fp, (long )((unsigned long )offset + (unsigned long )length), 0);
  tmp = fread((void * __restrict  )(& i16), sizeof(uint16_t ), 1U, (FILE * __restrict  )fp);
  if (tmp != 1U) {
    return (-1);
  }
  return (0);
}
}
static int tnef_attachment(FILE *fp , uint16_t type , uint16_t tag , uint32_t length ,
                           char const   *dir , fileblob **fbref ) 
{ uint32_t todo ;
  uint16_t i16 ;
  off_t offset ;
  char *string ;
  size_t tmp ;
  int c ;
  unsigned char c2 ;
  size_t tmp___0 ;

  {
  cli_dbgmsg("attachment tag 0x%x, type 0x%x, length %u\n", tag, type, length);
  offset = ftell(fp);
  switch ((int )tag) {
  case 32784: 
  string = (char *)cli_malloc(length + 1U);
  tmp = fread((void * __restrict  )string, 1U, length, (FILE * __restrict  )fp);
  if (tmp != length) {
    free((void *)string);
    return (-1);
  }
  (*(string + length)) = (char )'\000';
  cli_dbgmsg("TNEF filename %s\n", string);
  if ((unsigned int )(*fbref) == (unsigned int )((void *)0)) {
    (*fbref) = fileblobCreate();
    if ((unsigned int )(*fbref) == (unsigned int )((void *)0)) {
      free((void *)string);
      return (-1);
    }
  }
  fileblobSetFilename((*fbref), dir, (char const   *)string);
  free((void *)string);
  break;
  case 32783: ;
  if ((unsigned int )(*fbref) == (unsigned int )((void *)0)) {
    (*fbref) = fileblobCreate();
    if ((unsigned int )(*fbref) == (unsigned int )((void *)0)) {
      return (-1);
    }
  }
  todo = length;
  while (todo) {
    c = fgetc(fp);
    if (c == -1) {
      break;
    }
    c2 = (unsigned char )c;
    fileblobAddData((*fbref), (unsigned char const   *)(& c2), 1U);
    todo --;
  }
  break;
  default: 
  cli_dbgmsg("TNEF - unsupported attachment tag 0x%x type 0x%d length %u\n", tag,
             type, length);
  break;
  }
  fseek(fp, (long )((unsigned long )offset + (unsigned long )length), 0);
  tmp___0 = fread((void * __restrict  )(& i16), sizeof(uint16_t ), 1U, (FILE * __restrict  )fp);
  if (tmp___0 != 1U) {
    return (-1);
  }
  return (0);
}
}
static int tnef_header(FILE *fp , uint8_t *part , uint16_t *type , uint16_t *tag ,
                       uint32_t *length ) 
{ uint32_t i32 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  tmp = fread((void * __restrict  )part, sizeof(uint8_t ), 1U, (FILE * __restrict  )fp);
  if (tmp != 1U) {
    return (0);
  }
  if ((int )(*part) == 0) {
    return (0);
  }
  tmp___0 = fread((void * __restrict  )(& i32), sizeof(uint32_t ), 1U, (FILE * __restrict  )fp);
  if (tmp___0 != 1U) {
    return (-1);
  }
  i32 = (((i32 >> 24) | ((i32 & 16711680U) >> 8)) | ((i32 & 65280U) << 8)) | (i32 <<
                                                                              24);
  (*tag) = (unsigned short )(i32 & 65535U);
  (*type) = (unsigned short )((i32 & 4294901760U) >> 16);
  tmp___1 = fread((void * __restrict  )(& i32), sizeof(uint32_t ), 1U, (FILE * __restrict  )fp);
  if (tmp___1 != 1U) {
    return (-1);
  }
  (*length) = (((i32 >> 24) | ((i32 & 16711680U) >> 8)) | ((i32 & 65280U) << 8)) |
              (i32 << 24);
  cli_dbgmsg("message tag 0x%x, type 0x%x, length %u\n", (*tag), (*type), (*length));
  return (1);
}
}

