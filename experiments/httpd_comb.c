/* Generated by CIL v. 1.3.2 */
/* print_CIL_Input is true */

typedef unsigned int size_t;
typedef unsigned int __socklen_t;
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct sockaddr_in;
struct sockaddr_in6;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned short apr_uint16_t;
typedef int apr_int32_t;
typedef long long apr_int64_t;
typedef socklen_t apr_socklen_t;
struct apr_pool_t;
typedef struct apr_pool_t apr_pool_t;
struct apr_array_header_t;
typedef struct apr_array_header_t apr_array_header_t;
struct apr_array_header_t {
   apr_pool_t *pool ;
   int elt_size ;
   int nelts ;
   int nalloc ;
   char *elts ;
};
typedef apr_int64_t apr_interval_time_t;
struct apr_file_t;
typedef struct apr_file_t apr_file_t;
typedef uint16_t in_port_t;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
union __anonunion_in6_u_54 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
struct in6_addr {
   union __anonunion_in6_u_54 in6_u ;
};
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[(int )(((sizeof(struct sockaddr ) - sizeof(unsigned short )) -
                                  sizeof(in_port_t )) - sizeof(struct in_addr ))] ;
};
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
typedef apr_uint16_t apr_port_t;
struct apr_sockaddr_t;
typedef struct apr_sockaddr_t apr_sockaddr_t;
union __anonunion_sa_57 {
   struct sockaddr_in sin ;
   struct sockaddr_in6 sin6 ;
};
struct apr_sockaddr_t {
   apr_pool_t *pool ;
   char *hostname ;
   char *servname ;
   apr_port_t port ;
   apr_int32_t family ;
   union __anonunion_sa_57 sa ;
   apr_socklen_t salen ;
   int ipaddr_len ;
   int addr_str_len ;
   void *ipaddr_ptr ;
   apr_sockaddr_t *next ;
};
struct ap_method_list_t;
typedef struct ap_method_list_t ap_method_list_t;
struct ap_method_list_t {
   apr_int64_t method_mask ;
   apr_array_header_t *method_list ;
};
struct ap_conf_vector_t;
struct process_rec;
typedef struct process_rec process_rec;
struct server_rec;
typedef struct server_rec server_rec;
struct process_rec {
   apr_pool_t *pool ;
   apr_pool_t *pconf ;
   int argc ;
   char const   * const  *argv ;
   char const   *short_name ;
};
struct server_addr_rec;
typedef struct server_addr_rec server_addr_rec;
struct server_addr_rec {
   server_addr_rec *next ;
   apr_sockaddr_t *host_addr ;
   apr_port_t host_port ;
   char *virthost ;
};
struct server_rec {
   process_rec *process ;
   server_rec *next ;
   char const   *defn_name ;
   unsigned int defn_line_number ;
   char *server_admin ;
   char *server_hostname ;
   apr_port_t port ;
   char *error_fname ;
   apr_file_t *error_log ;
   int loglevel ;
   int is_virtual ;
   struct ap_conf_vector_t *module_config ;
   struct ap_conf_vector_t *lookup_defaults ;
   server_addr_rec *addrs ;
   apr_interval_time_t timeout ;
   apr_interval_time_t keep_alive_timeout ;
   int keep_alive_max ;
   int keep_alive ;
   char const   *path ;
   int pathlen ;
   apr_array_header_t *names ;
   apr_array_header_t *wild_names ;
   int limit_req_line ;
   int limit_req_fieldsize ;
   int limit_req_fields ;
};
struct ap_directive_t;
typedef struct ap_directive_t ap_directive_t;
struct ap_directive_t {
   char const   *directive ;
   char const   *args ;
   struct ap_directive_t *next ;
   struct ap_directive_t *first_child ;
   struct ap_directive_t *parent ;
   void *data ;
   char const   *filename ;
   int line_num ;
};
enum cmd_how {
    RAW_ARGS = 0,
    TAKE1 = 1,
    TAKE2 = 2,
    ITERATE = 3,
    ITERATE2 = 4,
    FLAG = 5,
    NO_ARGS = 6,
    TAKE12 = 7,
    TAKE3 = 8,
    TAKE23 = 9,
    TAKE123 = 10,
    TAKE13 = 11
};
struct cmd_parms_struct;
typedef struct cmd_parms_struct cmd_parms;
union __anonunion_cmd_func_69 {
   char const   *(*no_args)(cmd_parms *parms , void *mconfig ) ;
   char const   *(*raw_args)(cmd_parms *parms , void *mconfig , char const   *args ) ;
   char const   *(*take1)(cmd_parms *parms , void *mconfig , char const   *w ) ;
   char const   *(*take2)(cmd_parms *parms , void *mconfig , char const   *w , char const   *w2 ) ;
   char const   *(*take3)(cmd_parms *parms , void *mconfig , char const   *w , char const   *w2 ,
                          char const   *w3 ) ;
   char const   *(*flag)(cmd_parms *parms , void *mconfig , int on ) ;
};
typedef union __anonunion_cmd_func_69 cmd_func;
struct command_struct;
typedef struct command_struct command_rec;
struct command_struct {
   char const   *name ;
   cmd_func func ;
   void *cmd_data ;
   int req_override ;
   enum cmd_how args_how ;
   char const   *errmsg ;
};
struct ap_configfile_t;
typedef struct ap_configfile_t ap_configfile_t;
struct ap_configfile_t {
   int (*getch)(void *param ) ;
   void *(*getstr)(void *buf , size_t bufsiz , void *param ) ;
   int (*close)(void *param ) ;
   void *param ;
   char const   *name ;
   unsigned int line_number ;
};
struct cmd_parms_struct {
   void *info ;
   int override ;
   apr_int64_t limited ;
   apr_array_header_t *limited_xmethods ;
   ap_method_list_t *xlimited ;
   ap_configfile_t *config_file ;
   ap_directive_t *directive ;
   apr_pool_t *pool ;
   apr_pool_t *temp_pool ;
   server_rec *server ;
   char *path ;
   command_rec const   *cmd ;
   struct ap_conf_vector_t *context ;
   ap_directive_t const   *err_directive ;
};
struct module_struct;
typedef struct module_struct module;
struct module_struct {
   int version ;
   int minor_version ;
   int module_index ;
   char const   *name ;
   void *dynamic_load_handle ;
   struct module_struct *next ;
   unsigned long magic ;
   void (*rewrite_args)(process_rec *process ) ;
   void *(*create_dir_config)(apr_pool_t *p , char *dir ) ;
   void *(*merge_dir_config)(apr_pool_t *p , void *base_conf , void *new_conf ) ;
   void *(*create_server_config)(apr_pool_t *p , server_rec *s ) ;
   void *(*merge_server_config)(apr_pool_t *p , void *base_conf , void *new_conf ) ;
   command_rec const   *cmds ;
   void (*register_hooks)(apr_pool_t *p ) ;
};
typedef unsigned long long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef long __off_t;
typedef __ino_t ino_t;
typedef __dev_t dev_t;
typedef __gid_t gid_t;
typedef __uid_t uid_t;
typedef __off_t off_t;
typedef size_t apr_size_t;
typedef off_t apr_off_t;
typedef int apr_status_t;
typedef apr_int64_t apr_time_t;
typedef uid_t apr_uid_t;
typedef gid_t apr_gid_t;
enum __anonenum_apr_filetype_e_42 {
    APR_NOFILE = 0,
    APR_REG = 1,
    APR_DIR = 2,
    APR_CHR = 3,
    APR_BLK = 4,
    APR_PIPE = 5,
    APR_LNK = 6,
    APR_SOCK = 7,
    APR_UNKFILE = 127
};
typedef enum __anonenum_apr_filetype_e_42 apr_filetype_e;
typedef apr_int32_t apr_fileperms_t;
typedef ino_t apr_ino_t;
typedef dev_t apr_dev_t;
struct apr_finfo_t;
typedef struct apr_finfo_t apr_finfo_t;
struct apr_finfo_t {
   apr_pool_t *pool ;
   apr_int32_t valid ;
   apr_fileperms_t protection ;
   apr_filetype_e filetype ;
   apr_uid_t user ;
   apr_gid_t group ;
   apr_ino_t inode ;
   apr_dev_t device ;
   apr_int32_t nlink ;
   apr_off_t size ;
   apr_off_t csize ;
   apr_time_t atime ;
   apr_time_t mtime ;
   apr_time_t ctime ;
   char const   *fname ;
   char const   *name ;
   struct apr_file_t *filehand ;
};
struct apr_ipsubnet_t;
typedef struct apr_ipsubnet_t apr_ipsubnet_t;
struct apr_table_t;
typedef struct apr_table_t apr_table_t;
enum __anonenum_apr_read_type_e_60 {
    APR_BLOCK_READ = 0,
    APR_NONBLOCK_READ = 1
};
typedef enum __anonenum_apr_read_type_e_60 apr_read_type_e;
struct apr_bucket_brigade;
typedef struct apr_bucket_brigade apr_bucket_brigade;
struct apr_bucket;
typedef struct apr_bucket apr_bucket;
struct apr_bucket_alloc_t;
typedef struct apr_bucket_alloc_t apr_bucket_alloc_t;
struct apr_bucket_type_t;
typedef struct apr_bucket_type_t apr_bucket_type_t;
enum __anonenum_is_metadata_61 {
    APR_BUCKET_DATA = 0,
    APR_BUCKET_METADATA = 1
};
struct apr_bucket_type_t {
   char const   *name ;
   int num_func ;
   enum __anonenum_is_metadata_61 is_metadata ;
   void (*destroy)(void *data ) ;
   apr_status_t (*read)(apr_bucket *b , char const   **str , apr_size_t *len , apr_read_type_e block ) ;
   apr_status_t (*setaside)(apr_bucket *e , apr_pool_t *pool ) ;
   apr_status_t (*split)(apr_bucket *e , apr_size_t point ) ;
   apr_status_t (*copy)(apr_bucket *e , apr_bucket **c ) ;
};
struct __anonstruct_link_62 {
   struct apr_bucket *next ;
   struct apr_bucket *prev ;
};
struct apr_bucket {
   struct __anonstruct_link_62 link ;
   apr_bucket_type_t const   *type ;
   apr_size_t length ;
   apr_off_t start ;
   void *data ;
   void (*free)(void *e ) ;
   apr_bucket_alloc_t *list ;
};
struct apr_bucket_list {
   struct apr_bucket *next ;
   struct apr_bucket *prev ;
};
struct apr_bucket_brigade {
   apr_pool_t *p ;
   struct apr_bucket_list list ;
   apr_bucket_alloc_t *bucket_alloc ;
};
struct htaccess_result {
   char const   *dir ;
   int override ;
   struct ap_conf_vector_t *htaccess ;
   struct htaccess_result  const  *next ;
};
struct conn_rec;
typedef struct conn_rec conn_rec;
struct request_rec;
typedef struct request_rec request_rec;
struct apr_uri_t;
typedef struct apr_uri_t apr_uri_t;
struct hostent;
struct apr_uri_t {
   char *scheme ;
   char *hostinfo ;
   char *user ;
   char *password ;
   char *hostname ;
   char *port_str ;
   char *path ;
   char *query ;
   char *fragment ;
   struct hostent *hostent ;
   apr_port_t port ;
   unsigned int is_initialized : 1 ;
   unsigned int dns_looked_up : 1 ;
   unsigned int dns_resolved : 1 ;
};
struct ap_filter_t;
struct request_rec {
   apr_pool_t *pool ;
   conn_rec *connection ;
   server_rec *server ;
   request_rec *next ;
   request_rec *prev ;
   request_rec *main ;
   char *the_request ;
   int assbackwards ;
   int proxyreq ;
   int header_only ;
   char *protocol ;
   int proto_num ;
   char const   *hostname ;
   apr_time_t request_time ;
   char const   *status_line ;
   int status ;
   char const   *method ;
   int method_number ;
   apr_int64_t allowed ;
   apr_array_header_t *allowed_xmethods ;
   ap_method_list_t *allowed_methods ;
   apr_off_t sent_bodyct ;
   apr_off_t bytes_sent ;
   apr_time_t mtime ;
   int chunked ;
   char const   *range ;
   apr_off_t clength ;
   apr_off_t remaining ;
   apr_off_t read_length ;
   int read_body ;
   int read_chunked ;
   unsigned int expecting_100 ;
   apr_table_t *headers_in ;
   apr_table_t *headers_out ;
   apr_table_t *err_headers_out ;
   apr_table_t *subprocess_env ;
   apr_table_t *notes ;
   char const   *content_type ;
   char const   *handler ;
   char const   *content_encoding ;
   apr_array_header_t *content_languages ;
   char *vlist_validator ;
   char *user ;
   char *ap_auth_type ;
   int no_cache ;
   int no_local_copy ;
   char *unparsed_uri ;
   char *uri ;
   char *filename ;
   char *canonical_filename ;
   char *path_info ;
   char *args ;
   apr_finfo_t finfo ;
   apr_uri_t parsed_uri ;
   int used_path_info ;
   struct ap_conf_vector_t *per_dir_config ;
   struct ap_conf_vector_t *request_config ;
   struct htaccess_result  const  *htaccess ;
   struct ap_filter_t *output_filters ;
   struct ap_filter_t *input_filters ;
   struct ap_filter_t *proto_output_filters ;
   struct ap_filter_t *proto_input_filters ;
   int eos_sent ;
};
enum __anonenum_ap_conn_keepalive_e_69 {
    AP_CONN_UNKNOWN = 0,
    AP_CONN_CLOSE = 1,
    AP_CONN_KEEPALIVE = 2
};
typedef enum __anonenum_ap_conn_keepalive_e_69 ap_conn_keepalive_e;
struct conn_rec {
   apr_pool_t *pool ;
   server_rec *base_server ;
   void *vhost_lookup_data ;
   apr_sockaddr_t *local_addr ;
   apr_sockaddr_t *remote_addr ;
   char *remote_ip ;
   char *remote_host ;
   char *remote_logname ;
   unsigned int aborted : 1 ;
   ap_conn_keepalive_e keepalive ;
   int double_reverse : 2 ;
   int keepalives ;
   char *local_ip ;
   char *local_host ;
   long id ;
   struct ap_conf_vector_t *conn_config ;
   apr_table_t *notes ;
   struct ap_filter_t *input_filters ;
   struct ap_filter_t *output_filters ;
   void *sbh ;
   struct apr_bucket_alloc_t *bucket_alloc ;
};
enum __anonenum_ap_input_mode_t_70 {
    AP_MODE_READBYTES = 0,
    AP_MODE_GETLINE = 1,
    AP_MODE_EATCRLF = 2,
    AP_MODE_SPECULATIVE = 3,
    AP_MODE_EXHAUSTIVE = 4,
    AP_MODE_INIT = 5
};
typedef enum __anonenum_ap_input_mode_t_70 ap_input_mode_t;
typedef struct ap_filter_t ap_filter_t;
union ap_filter_func {
   apr_status_t (*out_func)(ap_filter_t *f , apr_bucket_brigade *b ) ;
   apr_status_t (*in_func)(ap_filter_t *f , apr_bucket_brigade *b , ap_input_mode_t mode ,
                           apr_read_type_e block , apr_off_t readbytes ) ;
};
typedef union ap_filter_func ap_filter_func;
enum __anonenum_ap_filter_type_71 {
    AP_FTYPE_RESOURCE = 10,
    AP_FTYPE_CONTENT_SET = 20,
    AP_FTYPE_PROTOCOL = 30,
    AP_FTYPE_TRANSCODE = 40,
    AP_FTYPE_CONNECTION = 50,
    AP_FTYPE_NETWORK = 60
};
typedef enum __anonenum_ap_filter_type_71 ap_filter_type;
struct ap_filter_rec_t;
typedef struct ap_filter_rec_t ap_filter_rec_t;
struct ap_filter_rec_t {
   char const   *name ;
   ap_filter_func filter_func ;
   int (*filter_init_func)(ap_filter_t *f ) ;
   ap_filter_type ftype ;
   struct ap_filter_rec_t *next ;
};
struct ap_filter_t {
   ap_filter_rec_t *frec ;
   void *ctx ;
   ap_filter_t *next ;
   request_rec *r ;
   conn_rec *c ;
};
typedef int ap_HOOK_access_checker_t(request_rec *r );
enum allowdeny_type {
    T_ENV = 0,
    T_ALL = 1,
    T_IP = 2,
    T_HOST = 3,
    T_FAIL = 4
};
union __anonunion_x_81 {
   char *from ;
   apr_ipsubnet_t *ip ;
};
struct __anonstruct_allowdeny_80 {
   apr_int64_t limited ;
   union __anonunion_x_81 x ;
   enum allowdeny_type type ;
};
typedef struct __anonstruct_allowdeny_80 allowdeny;
struct __anonstruct_access_dir_conf_82 {
   int order[64] ;
   apr_array_header_t *allows ;
   apr_array_header_t *denys ;
};
typedef struct __anonstruct_access_dir_conf_82 access_dir_conf;
struct apr_allocator_t;
typedef struct apr_allocator_t apr_allocator_t;
struct require_line;
typedef struct require_line require_line;
struct require_line {
   apr_int64_t method_mask ;
   char *requirement ;
};
typedef int ap_HOOK_check_user_id_t(request_rec *r );
typedef int ap_HOOK_auth_checker_t(request_rec *r );
struct __anonstruct_auth_config_rec_90 {
   char *auth_pwfile ;
   char *auth_grpfile ;
   int auth_authoritative ;
};
typedef struct __anonstruct_auth_config_rec_90 auth_config_rec;
typedef int __ssize_t;
typedef __ssize_t ssize_t;
typedef unsigned int apr_uint32_t;
typedef ssize_t apr_ssize_t;
struct apr_hash_t;
typedef struct apr_hash_t apr_hash_t;
typedef void apr_opt_fn_t(void);
struct apr_table_entry_t;
typedef struct apr_table_entry_t apr_table_entry_t;
struct apr_table_entry_t {
   char *key ;
   char *val ;
   apr_uint32_t key_checksum ;
};
struct __anonstruct_regex_t_71 {
   void *re_pcre ;
   size_t re_nsub ;
   size_t re_erroffset ;
};
typedef struct __anonstruct_regex_t_71 regex_t;
typedef int regoff_t;
struct __anonstruct_regmatch_t_72 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
typedef struct __anonstruct_regmatch_t_72 regmatch_t;
typedef int ap_HOOK_post_config_t(apr_pool_t *pconf , apr_pool_t *plog , apr_pool_t *ptemp ,
                                  server_rec *s );
typedef int ap_HOOK_fixups_t(request_rec *r );
enum __anonenum_states_95 {
    PRE_HEAD = 0,
    PARSE_HEAD = 1,
    PARSE_DIRECTIVE = 2,
    PARSE_TAG = 3,
    PARSE_TAIL = 4,
    PARSED = 5
};
typedef enum __anonenum_states_95 states;
struct bndm_t;
typedef struct bndm_t bndm_t;
struct include_filter_ctx {
   states state ;
   long flags ;
   int if_nesting_level ;
   apr_size_t parse_pos ;
   int bytes_parsed ;
   apr_status_t status ;
   int output_now ;
   int output_flush ;
   apr_bucket *head_start_bucket ;
   apr_size_t head_start_index ;
   apr_bucket *tag_start_bucket ;
   apr_size_t tag_start_index ;
   apr_bucket *tail_start_bucket ;
   apr_size_t tail_start_index ;
   char *combined_tag ;
   char *curr_tag_pos ;
   apr_size_t directive_length ;
   apr_size_t tag_length ;
   char *error_str ;
   char *error_str_override ;
   char *time_str ;
   char *time_str_override ;
   apr_pool_t *pool ;
   apr_bucket_brigade *ssi_tag_brigade ;
   bndm_t *start_seq_pat ;
   char *start_seq ;
   int start_seq_len ;
   char *end_seq ;
   char *re_string ;
   regmatch_t (*re_result)[10] ;
};
typedef struct include_filter_ctx include_ctx_t;
typedef int include_handler_fn_t(include_ctx_t *ctx , apr_bucket_brigade **bb , request_rec *r ,
                                 ap_filter_t *f , apr_bucket *head_ptr , apr_bucket **inserted_head );
typedef void apr_OFN_ap_ssi_get_tag_and_value_t(include_ctx_t *ctx , char **tag ,
                                                char **tag_val , int dodecode );
typedef char *apr_OFN_ap_ssi_parse_string_t(request_rec *r , include_ctx_t *ctx ,
                                            char const   *in , char *out , apr_size_t length ,
                                            int leave_name );
typedef void apr_OFN_ap_register_include_handler_t(char *tag , include_handler_fn_t *func );
enum xbithack {
    xbithack_off = 0,
    xbithack_on = 1,
    xbithack_full = 2
};
struct bndm_t {
   unsigned int T[256] ;
   unsigned int x ;
};
struct __anonstruct_include_dir_config_96 {
   char *default_error_msg ;
   char *default_time_fmt ;
   enum xbithack *xbithack ;
};
typedef struct __anonstruct_include_dir_config_96 include_dir_config;
struct __anonstruct_include_server_config_97 {
   char *default_start_tag ;
   char *default_end_tag ;
   int start_tag_len ;
   bndm_t start_seq_pat ;
   char *undefinedEcho ;
   int undefinedEchoLen ;
};
typedef struct __anonstruct_include_server_config_97 include_server_config;
enum __anonenum_encode_98 {
    E_NONE = 0,
    E_URL = 1,
    E_ENTITY = 2
};
enum token_type {
    token_string = 0,
    token_re = 1,
    token_and = 2,
    token_or = 3,
    token_not = 4,
    token_eq = 5,
    token_ne = 6,
    token_rbrace = 7,
    token_lbrace = 8,
    token_group = 9,
    token_ge = 10,
    token_le = 11,
    token_gt = 12,
    token_lt = 13
};
struct token {
   enum token_type type ;
   char *value ;
};
struct parse_node {
   struct parse_node *left ;
   struct parse_node *right ;
   struct parse_node *parent ;
   struct token token ;
   int value ;
   int done ;
};
typedef int __pid_t;
typedef __pid_t pid_t;
struct apr_time_exp_t;
typedef struct apr_time_exp_t apr_time_exp_t;
struct apr_time_exp_t {
   apr_int32_t tm_usec ;
   apr_int32_t tm_sec ;
   apr_int32_t tm_min ;
   apr_int32_t tm_hour ;
   apr_int32_t tm_mday ;
   apr_int32_t tm_mon ;
   apr_int32_t tm_year ;
   apr_int32_t tm_wday ;
   apr_int32_t tm_yday ;
   apr_int32_t tm_isdst ;
   apr_int32_t tm_gmtoff ;
};
struct apr_proc_t;
typedef struct apr_proc_t apr_proc_t;
struct apr_proc_t {
   pid_t pid ;
   apr_file_t *in ;
   apr_file_t *out ;
   apr_file_t *err ;
};
typedef char const   *ap_log_handler_fn_t(request_rec *r , char *a );
typedef void *ap_log_writer_init(apr_pool_t *p , server_rec *s , char const   *name );
typedef apr_status_t ap_log_writer(request_rec *r , void *handle , char const   **portions ,
                                   int *lengths , int nelts , apr_size_t len );
struct ap_log_handler {
   ap_log_handler_fn_t *func ;
   int want_orig_default ;
};
typedef struct ap_log_handler ap_log_handler;
typedef void apr_OFN_ap_register_log_handler_t(apr_pool_t *p , char *tag , ap_log_handler_fn_t *func ,
                                               int def );
typedef void apr_OFN_ap_log_set_writer_init_t(ap_log_writer_init *func );
typedef void apr_OFN_ap_log_set_writer_t(ap_log_writer *func );
typedef int ap_HOOK_pre_config_t(apr_pool_t *pconf , apr_pool_t *plog , apr_pool_t *ptemp );
typedef int ap_HOOK_open_logs_t(apr_pool_t *pconf , apr_pool_t *plog , apr_pool_t *ptemp ,
                                server_rec *s );
typedef void ap_HOOK_child_init_t(apr_pool_t *pchild , server_rec *s );
struct piped_log;
typedef struct piped_log piped_log;
struct piped_log {
   apr_pool_t *p ;
   apr_file_t *fds[2] ;
   char *program ;
   apr_proc_t *pid ;
};
typedef int ap_HOOK_log_transaction_t(request_rec *r );
struct __anonstruct_multi_log_state_97 {
   char const   *default_format_string ;
   apr_array_header_t *default_format ;
   apr_array_header_t *config_logs ;
   apr_array_header_t *server_config_logs ;
   apr_table_t *formats ;
};
typedef struct __anonstruct_multi_log_state_97 multi_log_state;
struct __anonstruct_buffered_log_98 {
   apr_file_t *handle ;
   apr_size_t outcnt ;
   char outbuf[4096] ;
};
typedef struct __anonstruct_buffered_log_98 buffered_log;
struct __anonstruct_config_log_state_99 {
   char const   *fname ;
   char const   *format_string ;
   apr_array_header_t *format ;
   void *log_writer ;
   char *condition_var ;
};
typedef struct __anonstruct_config_log_state_99 config_log_state;
struct __anonstruct_log_format_item_100 {
   ap_log_handler_fn_t *func ;
   char *arg ;
   int condition_sense ;
   int want_orig ;
   apr_array_header_t *conditions ;
};
typedef struct __anonstruct_log_format_item_100 log_format_item;
struct __anonstruct_cached_request_time_101 {
   unsigned int t ;
   char timestr[32] ;
   unsigned int t_validate ;
};
typedef struct __anonstruct_cached_request_time_101 cached_request_time;
struct __anonstruct_env_dir_config_rec_76 {
   apr_table_t *vars ;
   apr_table_t *unsetenv ;
};
typedef struct __anonstruct_env_dir_config_rec_76 env_dir_config_rec;
struct apr_strmatch_pattern;
typedef struct apr_strmatch_pattern apr_strmatch_pattern;
struct apr_strmatch_pattern {
   char const   *(*compare)(apr_strmatch_pattern const   *this_pattern , char const   *s ,
                            apr_size_t slen ) ;
   char const   *pattern ;
   apr_size_t length ;
   void *context ;
};
typedef int ap_HOOK_header_parser_t(request_rec *r );
typedef int ap_HOOK_post_read_request_t(request_rec *r );
enum special {
    SPECIAL_NOT = 0,
    SPECIAL_REMOTE_ADDR = 1,
    SPECIAL_REMOTE_HOST = 2,
    SPECIAL_REMOTE_USER = 3,
    SPECIAL_REQUEST_URI = 4,
    SPECIAL_REQUEST_METHOD = 5,
    SPECIAL_REQUEST_PROTOCOL = 6,
    SPECIAL_SERVER_ADDR = 7
};
struct __anonstruct_sei_entry_90 {
   char *name ;
   regex_t *pnamereg ;
   char *regex ;
   regex_t *preg ;
   apr_strmatch_pattern const   *pattern ;
   apr_table_t *features ;
   enum special special_type ;
   int icase ;
};
typedef struct __anonstruct_sei_entry_90 sei_entry;
struct __anonstruct_sei_cfg_rec_91 {
   apr_array_header_t *conditionals ;
};
typedef struct __anonstruct_sei_cfg_rec_91 sei_cfg_rec;
struct apr_socket_t;
typedef struct apr_socket_t apr_socket_t;
typedef int ap_HOOK_process_connection_t(conn_rec *c );
typedef char const   *ap_HOOK_http_method_t(request_rec const   *r );
typedef apr_port_t ap_HOOK_default_port_t(request_rec const   *r );
typedef int ap_HOOK_create_request_t(request_rec *r );
typedef int ap_HOOK_map_to_storage_t(request_rec *r );
struct ap_sb_handle_t;
typedef struct ap_sb_handle_t ap_sb_handle_t;
typedef unsigned long __rlim_t;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
typedef __rlim_t rlim_t;
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct apr_bucket_refcount;
typedef struct apr_bucket_refcount apr_bucket_refcount;
struct apr_bucket_refcount {
   int refcount ;
};
typedef int apr_table_do_callback_fn_t(void *rec , char const   *key , char const   *value );
struct apr_hash_index_t;
typedef struct apr_hash_index_t apr_hash_index_t;
typedef unsigned char allow_options_t;
typedef unsigned char overrides_t;
typedef unsigned long etag_components_t;
enum __anonenum_server_signature_e_74 {
    srv_sig_unset = 0,
    srv_sig_off = 1,
    srv_sig_on = 2,
    srv_sig_withmail = 3
};
typedef enum __anonenum_server_signature_e_74 server_signature_e;
struct __anonstruct_core_dir_config_75 {
   char *d ;
   unsigned int d_components ;
   allow_options_t opts ;
   allow_options_t opts_add ;
   allow_options_t opts_remove ;
   overrides_t override ;
   char *ap_default_type ;
   int satisfy ;
   char *ap_auth_type ;
   char *ap_auth_name ;
   apr_array_header_t *ap_requires ;
   char **response_code_strings ;
   unsigned int hostname_lookups : 4 ;
   int do_rfc1413 : 2 ;
   int content_md5 : 2 ;
   unsigned int use_canonical_name : 2 ;
   unsigned int d_is_fnmatch : 1 ;
   unsigned int add_default_charset : 2 ;
   char const   *add_default_charset_name ;
   struct rlimit *limit_cpu ;
   struct rlimit *limit_mem ;
   struct rlimit *limit_nproc ;
   apr_off_t limit_req_body ;
   long limit_xml_body ;
   server_signature_e server_signature ;
   int loglevel ;
   apr_array_header_t *sec_file ;
   regex_t *r ;
   char const   *mime_type ;
   char const   *handler ;
   char const   *output_filters ;
   char const   *input_filters ;
   int accept_path_info ;
   apr_hash_t *ct_output_filters ;
   etag_components_t etag_bits ;
   etag_components_t etag_add ;
   etag_components_t etag_remove ;
   unsigned int enable_mmap : 2 ;
   unsigned int enable_sendfile : 2 ;
};
typedef struct __anonstruct_core_dir_config_75 core_dir_config;
struct ap_bucket_error;
typedef struct ap_bucket_error ap_bucket_error;
struct ap_bucket_error {
   apr_bucket_refcount refcount ;
   int status ;
   char const   *data ;
};
enum __anonenum_state_98 {
    BODY_NONE = 0,
    BODY_LENGTH = 1,
    BODY_CHUNK = 2
};
struct http_filter_ctx {
   apr_off_t remaining ;
   apr_off_t limit ;
   apr_off_t limit_used ;
   enum __anonenum_state_98 state ;
   int eos_sent ;
};
typedef struct http_filter_ctx http_ctx_t;
struct header_struct {
   apr_pool_t *pool ;
   apr_bucket_brigade *bb ;
};
typedef struct header_struct header_struct;
struct header_filter_ctx {
   int headers_sent ;
};
typedef struct header_filter_ctx header_filter_ctx;
struct byterange_ctx {
   apr_bucket_brigade *bb ;
   int num_ranges ;
   char *boundary ;
   char *bound_head ;
};
typedef struct byterange_ctx byterange_ctx;
typedef struct ap_conf_vector_t ap_conf_vector_t;
typedef int ap_HOOK_type_checker_t(request_rec *r );
struct attrib_info {
   char *name ;
   int offset ;
};
typedef struct attrib_info attrib_info;
struct extension_info {
   char *forced_type ;
   char *encoding_type ;
   char *language_type ;
   char *handler ;
   char *charset_type ;
   char *input_filters ;
   char *output_filters ;
};
typedef struct extension_info extension_info;
struct __anonstruct_mime_dir_config_88 {
   apr_hash_t *extension_mappings ;
   apr_array_header_t *remove_mappings ;
   char *default_language ;
   int multimatch ;
   int use_path_info ;
};
typedef struct __anonstruct_mime_dir_config_88 mime_dir_config;
struct param_s {
   char *attr ;
   char *val ;
   struct param_s *next ;
};
typedef struct param_s param;
struct __anonstruct_content_type_89 {
   char const   *type ;
   apr_size_t type_len ;
   char const   *subtype ;
   apr_size_t subtype_len ;
   param *param ;
};
typedef struct __anonstruct_content_type_89 content_type;
typedef long __clock_t;
typedef __clock_t clock_t;
typedef unsigned long pthread_t;
typedef int ap_HOOK_handler_t(request_rec *r );
typedef pthread_t apr_os_thread_t;
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
typedef int ap_generation_t;
enum __anonenum_ap_scoreboard_e_94 {
    SB_NOT_SHARED = 1,
    SB_SHARED = 2
};
typedef enum __anonenum_ap_scoreboard_e_94 ap_scoreboard_e;
struct worker_score;
typedef struct worker_score worker_score;
struct worker_score {
   int thread_num ;
   apr_os_thread_t tid ;
   unsigned char status ;
   unsigned long access_count ;
   apr_off_t bytes_served ;
   unsigned long my_access_count ;
   apr_off_t my_bytes_served ;
   apr_off_t conn_bytes ;
   unsigned short conn_count ;
   apr_time_t start_time ;
   apr_time_t stop_time ;
   struct tms times ;
   apr_time_t last_used ;
   char client[32] ;
   char request[64] ;
   char vhost[32] ;
};
struct __anonstruct_global_score_95 {
   int server_limit ;
   int thread_limit ;
   ap_scoreboard_e sb_type ;
   ap_generation_t running_generation ;
   apr_time_t restart_time ;
};
typedef struct __anonstruct_global_score_95 global_score;
struct process_score;
typedef struct process_score process_score;
struct process_score {
   pid_t pid ;
   ap_generation_t generation ;
   ap_scoreboard_e sb_type ;
   int quiescing ;
};
struct __anonstruct_scoreboard_96 {
   global_score *global ;
   process_score *parent ;
   worker_score **servers ;
};
typedef struct __anonstruct_scoreboard_96 scoreboard;
struct stat_opt {
   int id ;
   char const   *form_data_str ;
   char const   *hdr_out_str ;
};
struct apr_dir_t;
typedef struct apr_dir_t apr_dir_t;
struct item {
   char *type ;
   char *apply_to ;
   char *apply_path ;
   char *data ;
};
struct ai_desc_t {
   char *pattern ;
   char *description ;
   int full_path ;
   int wildcards ;
};
typedef struct ai_desc_t ai_desc_t;
struct autoindex_config_struct {
   char *default_icon ;
   apr_int32_t opts ;
   apr_int32_t incremented_opts ;
   apr_int32_t decremented_opts ;
   int name_width ;
   int name_adjust ;
   int desc_width ;
   int desc_adjust ;
   int icon_width ;
   int icon_height ;
   char default_keyid ;
   char default_direction ;
   apr_array_header_t *icon_list ;
   apr_array_header_t *alt_list ;
   apr_array_header_t *desc_list ;
   apr_array_header_t *ign_list ;
   apr_array_header_t *hdr_list ;
   apr_array_header_t *rdme_list ;
};
typedef struct autoindex_config_struct autoindex_config_rec;
struct ent {
   char *name ;
   char *icon ;
   char *alt ;
   char *desc ;
   apr_off_t size ;
   apr_time_t lm ;
   struct ent *next ;
   int ascending ;
   int ignore_case ;
   int version_sort ;
   char key ;
   int isdir ;
};
typedef int apr_seek_where_t;
enum __anonenum_apr_cmdtype_e_52 {
    APR_SHELLCMD = 0,
    APR_PROGRAM = 1,
    APR_PROGRAM_ENV = 2,
    APR_PROGRAM_PATH = 3
};
typedef enum __anonenum_apr_cmdtype_e_52 apr_cmdtype_e;
struct apr_procattr_t;
typedef struct apr_procattr_t apr_procattr_t;
enum __anonenum_apr_kill_conditions_e_55 {
    APR_KILL_NEVER = 0,
    APR_KILL_ALWAYS = 1,
    APR_KILL_AFTER_TIMEOUT = 2,
    APR_JUST_WAIT = 3,
    APR_KILL_ONLY_ONCE = 4
};
typedef enum __anonenum_apr_kill_conditions_e_55 apr_kill_conditions_e;
enum __anonenum_prog_types_96 {
    RUN_AS_SSI = 0,
    RUN_AS_CGI = 1
};
typedef enum __anonenum_prog_types_96 prog_types;
struct __anonstruct_cgi_exec_info_t_97 {
   apr_int32_t in_pipe ;
   apr_int32_t out_pipe ;
   apr_int32_t err_pipe ;
   int process_cgi ;
   apr_cmdtype_e cmd_type ;
   apr_int32_t detached ;
   prog_types prog_type ;
   apr_bucket_brigade **bb ;
   include_ctx_t *ctx ;
   ap_filter_t *next ;
};
typedef struct __anonstruct_cgi_exec_info_t_97 cgi_exec_info_t;
typedef apr_status_t apr_OFN_ap_cgi_build_command_t(char const   **cmd , char const   ***argv ,
                                                    request_rec *r , apr_pool_t *p ,
                                                    cgi_exec_info_t *e_info );
struct __anonstruct_cgi_server_conf_98 {
   char const   *logname ;
   long logbytes ;
   apr_size_t bufbytes ;
};
typedef struct __anonstruct_cgi_server_conf_98 cgi_server_conf;
struct __anonstruct_neg_dir_config_91 {
   int forcelangpriority ;
   apr_array_header_t *language_priority ;
};
typedef struct __anonstruct_neg_dir_config_91 neg_dir_config;
struct accept_rec {
   char *name ;
   float quality ;
   float level ;
   char *charset ;
};
typedef struct accept_rec accept_rec;
struct var_rec {
   request_rec *sub_req ;
   char const   *mime_type ;
   char const   *file_name ;
   apr_off_t body ;
   char const   *content_encoding ;
   apr_array_header_t *content_languages ;
   char const   *content_charset ;
   char const   *description ;
   float lang_quality ;
   float encoding_quality ;
   float charset_quality ;
   float mime_type_quality ;
   float source_quality ;
   float level ;
   apr_off_t bytes ;
   int lang_index ;
   int is_pseudo_html ;
   float level_matched ;
   int mime_stars ;
   int definite ;
};
typedef struct var_rec var_rec;
struct __anonstruct_negotiation_state_92 {
   apr_pool_t *pool ;
   request_rec *r ;
   neg_dir_config *conf ;
   char *dir_name ;
   int accept_q ;
   float default_lang_quality ;
   apr_array_header_t *accepts ;
   apr_array_header_t *accept_encodings ;
   apr_array_header_t *accept_charsets ;
   apr_array_header_t *accept_langs ;
   apr_array_header_t *avail_vars ;
   int count_multiviews_variants ;
   int is_transparent ;
   int dont_fiddle_headers ;
   int ua_supports_trans ;
   int send_alternates ;
   int may_choose ;
   int use_rvsa ;
};
typedef struct __anonstruct_negotiation_state_92 negotiation_state;
enum header_state {
    header_eof = 0,
    header_seen = 1,
    header_sep = 2
};
enum algorithm_results {
    alg_choice = 1,
    alg_list = 2
};
struct dir_config_struct {
   apr_array_header_t *index_names ;
};
typedef struct dir_config_struct dir_config_rec;
struct __anonstruct_imap_conf_rec_91 {
   char *imap_menu ;
   char *imap_default ;
   char *imap_base ;
};
typedef struct __anonstruct_imap_conf_rec_91 imap_conf_rec;
struct __anonstruct_action_dir_config_90 {
   apr_table_t *action_types ;
   char const   *scripted[64] ;
   int configured ;
};
typedef struct __anonstruct_action_dir_config_90 action_dir_config;
typedef int ap_HOOK_translate_name_t(request_rec *r );
struct __anonstruct_ap_unix_identity_t_80 {
   uid_t uid ;
   gid_t gid ;
   int userdir ;
};
typedef struct __anonstruct_ap_unix_identity_t_80 ap_unix_identity_t;
typedef ap_unix_identity_t *ap_HOOK_get_suexec_identity_t(request_rec const   *r );
struct __anonstruct_userdir_config_82 {
   int globally_disabled ;
   char *userdir ;
   apr_table_t *enabled_users ;
   apr_table_t *disabled_users ;
};
typedef struct __anonstruct_userdir_config_82 userdir_config;
struct __anonstruct_alias_entry_80 {
   char const   *real ;
   char const   *fake ;
   char *handler ;
   regex_t *regexp ;
   int redir_status ;
};
typedef struct __anonstruct_alias_entry_80 alias_entry;
struct __anonstruct_alias_server_conf_81 {
   apr_array_header_t *aliases ;
   apr_array_header_t *redirects ;
};
typedef struct __anonstruct_alias_server_conf_81 alias_server_conf;
struct __anonstruct_alias_dir_conf_82 {
   apr_array_header_t *redirects ;
};
typedef struct __anonstruct_alias_dir_conf_82 alias_dir_conf;
struct apr_dso_handle_t;
typedef struct apr_dso_handle_t apr_dso_handle_t;
typedef void *apr_dso_handle_sym_t;
struct moduleinfo {
   char const   *name ;
   module *modp ;
};
typedef struct moduleinfo moduleinfo;
struct so_server_conf {
   apr_array_header_t *loaded_modules ;
};
typedef struct so_server_conf so_server_conf;
struct __anonstruct___sigset_t_2 {
   unsigned long __val[(int )(1024U / (8U * sizeof(unsigned long )))] ;
};
typedef struct __anonstruct___sigset_t_2 __sigset_t;
typedef __sigset_t sigset_t;
typedef short apr_int16_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_17 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
struct __anonstruct__timer_18 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
struct __anonstruct__rt_19 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
struct __anonstruct__sigchld_20 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
struct __anonstruct__sigfault_21 {
   void *si_addr ;
};
struct __anonstruct__sigpoll_22 {
   long si_band ;
   int si_fd ;
};
union __anonunion__sifields_16 {
   int _pad[(int )(128U / sizeof(int ) - 3U)] ;
   struct __anonstruct__kill_17 _kill ;
   struct __anonstruct__timer_18 _timer ;
   struct __anonstruct__rt_19 _rt ;
   struct __anonstruct__sigchld_20 _sigchld ;
   struct __anonstruct__sigfault_21 _sigfault ;
   struct __anonstruct__sigpoll_22 _sigpoll ;
};
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_16 _sifields ;
};
typedef struct siginfo siginfo_t;
union __anonunion___sigaction_handler_34 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
struct sigaction {
   union __anonunion___sigaction_handler_34 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
enum __anonenum_apr_exit_why_e_54 {
    APR_PROC_EXIT = 1,
    APR_PROC_SIGNAL = 2,
    APR_PROC_SIGNAL_CORE = 4
};
typedef enum __anonenum_apr_exit_why_e_54 apr_exit_why_e;
typedef int apr_lockmech_e;
struct apr_proc_mutex_t;
typedef struct apr_proc_mutex_t apr_proc_mutex_t;
struct apr_shm_t;
typedef struct apr_shm_t apr_shm_t;
typedef void apr_sigfunc_t(int  );
struct ap_listen_rec;
typedef struct ap_listen_rec ap_listen_rec;
struct ap_listen_rec {
   ap_listen_rec *next ;
   apr_socket_t *sd ;
   apr_sockaddr_t *bind_addr ;
   apr_status_t (*accept_func)(void **csd , ap_listen_rec *lr , apr_pool_t *ptrans ) ;
   int active ;
};
struct ap_pod_t;
typedef struct ap_pod_t ap_pod_t;
struct ap_pod_t {
   apr_file_t *pod_in ;
   apr_file_t *pod_out ;
   apr_pool_t *p ;
   apr_sockaddr_t *sa ;
};
enum __anonenum_apr_datatype_e_103 {
    APR_NO_DESC = 0,
    APR_POLL_SOCKET = 1,
    APR_POLL_FILE = 2,
    APR_POLL_LASTDESC = 3
};
typedef enum __anonenum_apr_datatype_e_103 apr_datatype_e;
union __anonunion_apr_descriptor_104 {
   apr_file_t *f ;
   apr_socket_t *s ;
};
typedef union __anonunion_apr_descriptor_104 apr_descriptor;
struct apr_pollfd_t;
typedef struct apr_pollfd_t apr_pollfd_t;
struct apr_pollfd_t {
   apr_pool_t *p ;
   apr_datatype_e desc_type ;
   apr_int16_t reqevents ;
   apr_int16_t rtnevents ;
   apr_descriptor desc ;
   void *client_data ;
};
typedef long long __off64_t;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[(int )(15U * sizeof(int ) - 2U * sizeof(void *))] ;
};
struct ap_LINK_header_parser_t {
   ap_HOOK_header_parser_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_header_parser_t ap_LINK_header_parser_t;
struct ap_LINK_pre_config_t {
   ap_HOOK_pre_config_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_pre_config_t ap_LINK_pre_config_t;
struct ap_LINK_post_config_t {
   ap_HOOK_post_config_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_post_config_t ap_LINK_post_config_t;
struct ap_LINK_open_logs_t {
   ap_HOOK_open_logs_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_open_logs_t ap_LINK_open_logs_t;
struct ap_LINK_child_init_t {
   ap_HOOK_child_init_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_child_init_t ap_LINK_child_init_t;
struct ap_LINK_handler_t {
   ap_HOOK_handler_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_handler_t ap_LINK_handler_t;
typedef int ap_HOOK_quick_handler_t(request_rec *r , int lookup_uri );
struct ap_LINK_quick_handler_t {
   ap_HOOK_quick_handler_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_quick_handler_t ap_LINK_quick_handler_t;
typedef void ap_HOOK_optional_fn_retrieve_t(void);
struct ap_LINK_optional_fn_retrieve_t {
   ap_HOOK_optional_fn_retrieve_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_optional_fn_retrieve_t ap_LINK_optional_fn_retrieve_t;
struct __anonstruct__hooks_99 {
   apr_array_header_t *link_header_parser ;
   apr_array_header_t *link_pre_config ;
   apr_array_header_t *link_post_config ;
   apr_array_header_t *link_open_logs ;
   apr_array_header_t *link_child_init ;
   apr_array_header_t *link_handler ;
   apr_array_header_t *link_quick_handler ;
   apr_array_header_t *link_optional_fn_retrieve ;
};
struct __anonstruct_arr_elts_param_t_100 {
   apr_array_header_t *array ;
   int curr_idx ;
};
typedef struct __anonstruct_arr_elts_param_t_100 arr_elts_param_t;
struct __anonstruct_fnames_101 {
   char *fname ;
};
typedef struct __anonstruct_fnames_101 fnames;
typedef void ap_HOOK_error_log_t(char const   *file , int line , int level , apr_status_t status ,
                                 server_rec const   *s , request_rec const   *r ,
                                 apr_pool_t *pool , char const   *errstr );
struct ap_LINK_error_log_t {
   ap_HOOK_error_log_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_error_log_t ap_LINK_error_log_t;
struct __anonstruct_TRANS_87 {
   char *t_name ;
   int t_val ;
};
typedef struct __anonstruct_TRANS_87 TRANS;
struct __anonstruct__hooks_88 {
   apr_array_header_t *link_error_log ;
};
typedef void apr_getopt_err_fn_t(void *arg , char const   *err  , ...);
struct apr_getopt_t;
typedef struct apr_getopt_t apr_getopt_t;
struct apr_getopt_t {
   apr_pool_t *cont ;
   apr_getopt_err_fn_t *errfn ;
   void *errarg ;
   int ind ;
   int opt ;
   int reset ;
   int argc ;
   char const   **argv ;
   char const   *place ;
   int interleave ;
   int skip_start ;
   int skip_end ;
};
typedef int apr_OFN_ap_signal_server_t(int * , apr_pool_t * );
struct name_chain;
typedef struct name_chain name_chain;
struct name_chain {
   name_chain *next ;
   server_addr_rec *sar ;
   server_rec *server ;
};
struct ipaddr_chain;
typedef struct ipaddr_chain ipaddr_chain;
struct ipaddr_chain {
   ipaddr_chain *next ;
   server_addr_rec *sar ;
   server_rec *server ;
   name_chain *names ;
};
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
struct vastrs {
   va_list args ;
   int arg ;
   char const   *curpos ;
};
struct apr_xlate_t;
typedef struct apr_xlate_t apr_xlate_t;
struct apr_md5_ctx_t;
typedef struct apr_md5_ctx_t apr_md5_ctx_t;
struct apr_md5_ctx_t {
   apr_uint32_t state[4] ;
   apr_uint32_t count[2] ;
   unsigned char buffer[64] ;
   apr_xlate_t *xlate ;
};
struct exploded_time_cache_element {
   apr_int64_t t ;
   apr_time_exp_t xt ;
   apr_int64_t t_validate ;
};
enum __anonenum_apr_shutdown_how_e_55 {
    APR_SHUTDOWN_READ = 0,
    APR_SHUTDOWN_WRITE = 1,
    APR_SHUTDOWN_READWRITE = 2
};
typedef enum __anonenum_apr_shutdown_how_e_55 apr_shutdown_how_e;
typedef conn_rec *ap_HOOK_create_connection_t(apr_pool_t *p , server_rec *server ,
                                              apr_socket_t *csd , long conn_id , void *sbh ,
                                              apr_bucket_alloc_t *alloc );
struct ap_LINK_create_connection_t {
   ap_HOOK_create_connection_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_create_connection_t ap_LINK_create_connection_t;
typedef int ap_HOOK_pre_connection_t(conn_rec *c , void *csd );
struct ap_LINK_pre_connection_t {
   ap_HOOK_pre_connection_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_pre_connection_t ap_LINK_pre_connection_t;
struct ap_LINK_process_connection_t {
   ap_HOOK_process_connection_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_process_connection_t ap_LINK_process_connection_t;
struct __anonstruct__hooks_97 {
   apr_array_header_t *link_create_connection ;
   apr_array_header_t *link_process_connection ;
   apr_array_header_t *link_pre_connection ;
};
enum __anonenum_apr_wait_how_e_53 {
    APR_WAIT = 0,
    APR_NOWAIT = 1
};
typedef enum __anonenum_apr_wait_how_e_53 apr_wait_how_e;
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
struct apr_text;
typedef struct apr_text apr_text;
struct apr_text {
   char const   *text ;
   struct apr_text *next ;
};
struct apr_text_header;
typedef struct apr_text_header apr_text_header;
struct apr_text_header {
   apr_text *first ;
   apr_text *last ;
};
struct apr_xml_attr;
struct apr_xml_elem;
typedef struct apr_xml_elem apr_xml_elem;
struct apr_xml_doc;
typedef struct apr_xml_doc apr_xml_doc;
struct apr_xml_attr {
   char const   *name ;
   int ns ;
   char const   *value ;
   struct apr_xml_attr *next ;
};
struct apr_xml_ns_scope;
struct apr_xml_elem {
   char const   *name ;
   int ns ;
   char const   *lang ;
   apr_text_header first_cdata ;
   apr_text_header following_cdata ;
   struct apr_xml_elem *parent ;
   struct apr_xml_elem *next ;
   struct apr_xml_elem *first_child ;
   struct apr_xml_attr *attr ;
   struct apr_xml_elem *last_child ;
   struct apr_xml_ns_scope *ns_scope ;
   void *priv ;
};
struct apr_xml_doc {
   apr_xml_elem *root ;
   apr_array_header_t *namespaces ;
};
struct apr_xml_parser;
typedef struct apr_xml_parser apr_xml_parser;
struct filter_trie_node;
typedef struct filter_trie_node filter_trie_node;
struct __anonstruct_filter_trie_child_ptr_76 {
   int c ;
   filter_trie_node *child ;
};
typedef struct __anonstruct_filter_trie_child_ptr_76 filter_trie_child_ptr;
struct filter_trie_node {
   ap_filter_rec_t *frec ;
   filter_trie_child_ptr *children ;
   int nchildren ;
   int size ;
};
typedef long __time_t;
typedef long __suseconds_t;
typedef __time_t time_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct _pthread_fastlock {
   long __status ;
   int __spinlock ;
};
struct _pthread_descr_struct;
typedef struct _pthread_descr_struct *_pthread_descr;
typedef unsigned int pthread_key_t;
struct __anonstruct_pthread_mutex_t_6 {
   int __m_reserved ;
   int __m_count ;
   _pthread_descr __m_owner ;
   int __m_kind ;
   struct _pthread_fastlock __m_lock ;
};
typedef struct __anonstruct_pthread_mutex_t_6 pthread_mutex_t;
typedef int (*apr_abortfunc_t)(int retcode );
struct apr_memnode_t;
typedef struct apr_memnode_t apr_memnode_t;
struct apr_memnode_t {
   apr_memnode_t *next ;
   apr_memnode_t **ref ;
   apr_uint32_t index ;
   apr_uint32_t free_index ;
   char *first_avail ;
   char *endp ;
};
struct apr_thread_mutex_t;
typedef struct apr_thread_mutex_t apr_thread_mutex_t;
typedef apr_uint32_t apr_fileattrs_t;
enum __anonenum_apr_interface_e_56 {
    APR_LOCAL = 0,
    APR_REMOTE = 1
};
typedef enum __anonenum_apr_interface_e_56 apr_interface_e;
struct apr_hdtr_t;
typedef struct apr_hdtr_t apr_hdtr_t;
struct apr_hdtr_t {
   struct iovec *headers ;
   int numheaders ;
   struct iovec *trailers ;
   int numtrailers ;
};
struct apr_mmap_t;
typedef struct apr_mmap_t apr_mmap_t;
struct __anonstruct_link_58 {
   struct apr_mmap_t *next ;
   struct apr_mmap_t *prev ;
};
struct apr_mmap_t {
   apr_pool_t *cntxt ;
   void *mm ;
   apr_size_t size ;
   int unused ;
   struct __anonstruct_link_58 link ;
};
struct apr_thread_t;
typedef struct apr_thread_t apr_thread_t;
struct apr_threadattr_t;
typedef struct apr_threadattr_t apr_threadattr_t;
struct apr_thread_once_t;
typedef struct apr_thread_once_t apr_thread_once_t;
struct apr_threadkey_t;
typedef struct apr_threadkey_t apr_threadkey_t;
typedef int ap_HOOK_get_mgmt_items_t(apr_pool_t *p , char const   *val , apr_hash_t *ht );
struct apr_global_mutex_t;
typedef struct apr_global_mutex_t apr_global_mutex_t;
struct __dirstream;
typedef struct __dirstream DIR;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
struct apr_os_proc_mutex_t {
   int crossproc ;
   pthread_mutex_t *pthread_interproc ;
   pthread_mutex_t *intraproc ;
};
typedef int apr_os_file_t;
typedef DIR apr_os_dir_t;
typedef int apr_os_sock_t;
typedef struct apr_os_proc_mutex_t apr_os_proc_mutex_t;
typedef pthread_key_t apr_os_threadkey_t;
typedef struct timeval apr_os_imp_time_t;
typedef struct tm apr_os_exp_time_t;
typedef void *apr_os_dso_handle_t;
typedef void *apr_os_shm_t;
struct apr_os_sock_info_t {
   apr_os_sock_t *os_sock ;
   struct sockaddr *local ;
   struct sockaddr *remote ;
   int family ;
   int type ;
};
typedef struct apr_os_sock_info_t apr_os_sock_info_t;
struct apr_os_global_mutex_t {
   apr_pool_t *pool ;
   apr_proc_mutex_t *proc_mutex ;
   apr_thread_mutex_t *thread_mutex ;
};
typedef struct apr_os_global_mutex_t apr_os_global_mutex_t;
typedef void ap_HOOK_insert_filter_t(request_rec *r );
typedef int ap_HOOK_pre_mpm_t(apr_pool_t *p , ap_scoreboard_e sb_type );
struct apr_getopt_option_t;
typedef struct apr_getopt_option_t apr_getopt_option_t;
struct apr_getopt_option_t {
   char const   *name ;
   int optch ;
   int has_arg ;
   char const   *description ;
};
struct apr_vformatter_buff_t;
typedef struct apr_vformatter_buff_t apr_vformatter_buff_t;
struct apr_vformatter_buff_t {
   char *curpos ;
   char *endpos ;
};
struct apr_pollset_t;
typedef struct apr_pollset_t apr_pollset_t;
struct apr_thread_cond_t;
typedef struct apr_thread_cond_t apr_thread_cond_t;
struct apr_thread_rwlock_t;
typedef struct apr_thread_rwlock_t apr_thread_rwlock_t;
struct __anonstruct_apr_version_t_103 {
   int major ;
   int minor ;
   int patch ;
   int is_dev ;
};
typedef struct __anonstruct_apr_version_t_103 apr_version_t;
enum tm_lock {
    apr_anylock_none = 0,
    apr_anylock_procmutex = 1,
    apr_anylock_threadmutex = 2,
    apr_anylock_readlock = 3,
    apr_anylock_writelock = 4
};
union apr_anylock_u_t {
   apr_proc_mutex_t *pm ;
   apr_thread_mutex_t *tm ;
   apr_thread_rwlock_t *rw ;
};
struct apr_anylock_t {
   enum tm_lock type ;
   union apr_anylock_u_t lock ;
};
typedef struct apr_anylock_t apr_anylock_t;
struct apr_dbm_t;
typedef struct apr_dbm_t apr_dbm_t;
struct __anonstruct_apr_datum_t_104 {
   char *dptr ;
   apr_size_t dsize ;
};
typedef struct __anonstruct_apr_datum_t_104 apr_datum_t;
struct apr_md4_ctx_t;
typedef struct apr_md4_ctx_t apr_md4_ctx_t;
struct apr_md4_ctx_t {
   apr_uint32_t state[4] ;
   apr_uint32_t count[2] ;
   unsigned char buffer[64] ;
   apr_xlate_t *xlate ;
};
struct apr_queue_t;
typedef struct apr_queue_t apr_queue_t;
struct apr_reslist_t;
typedef struct apr_reslist_t apr_reslist_t;
struct apr_rmm_t;
typedef struct apr_rmm_t apr_rmm_t;
typedef apr_size_t apr_rmm_off_t;
struct apr_sdbm_t;
typedef struct apr_sdbm_t apr_sdbm_t;
struct __anonstruct_apr_sdbm_datum_t_105 {
   char *dptr ;
   int dsize ;
};
typedef struct __anonstruct_apr_sdbm_datum_t_105 apr_sdbm_datum_t;
struct apr_sha1_ctx_t;
typedef struct apr_sha1_ctx_t apr_sha1_ctx_t;
struct apr_sha1_ctx_t {
   apr_uint32_t digest[5] ;
   apr_uint32_t count_lo ;
   apr_uint32_t count_hi ;
   apr_uint32_t data[16] ;
   int local ;
};
struct __anonstruct_apr_uuid_t_106 {
   unsigned char data[16] ;
};
typedef struct __anonstruct_apr_uuid_t_106 apr_uuid_t;
struct ap_LINK_pre_mpm_t {
   ap_HOOK_pre_mpm_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_pre_mpm_t ap_LINK_pre_mpm_t;
struct __anonstruct__hooks_96 {
   apr_array_header_t *link_pre_mpm ;
};
struct ap_sb_handle_t {
   int child_num ;
   int thread_num ;
};
struct ap_LINK_post_read_request_t {
   ap_HOOK_post_read_request_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_post_read_request_t ap_LINK_post_read_request_t;
struct ap_LINK_log_transaction_t {
   ap_HOOK_log_transaction_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_log_transaction_t ap_LINK_log_transaction_t;
struct ap_LINK_http_method_t {
   ap_HOOK_http_method_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_http_method_t ap_LINK_http_method_t;
struct ap_LINK_default_port_t {
   ap_HOOK_default_port_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_default_port_t ap_LINK_default_port_t;
struct __anonstruct__hooks_98 {
   apr_array_header_t *link_post_read_request ;
   apr_array_header_t *link_log_transaction ;
   apr_array_header_t *link_http_method ;
   apr_array_header_t *link_default_port ;
};
struct content_length_ctx {
   int data_sent ;
};
struct __anonstruct_old_write_filter_ctx_99 {
   apr_bucket_brigade *bb ;
};
typedef struct __anonstruct_old_write_filter_ctx_99 old_write_filter_ctx;
struct ap_vrprintf_data {
   apr_vformatter_buff_t vbuff ;
   request_rec *r ;
   char *buff ;
};
struct apr_bucket_file;
typedef struct apr_bucket_file apr_bucket_file;
struct apr_bucket_file {
   apr_bucket_refcount refcount ;
   apr_file_t *fd ;
   apr_pool_t *readpool ;
   int can_mmap ;
};
struct core_output_filter_ctx {
   apr_bucket_brigade *b ;
   apr_pool_t *deferred_write_pool ;
};
typedef struct core_output_filter_ctx core_output_filter_ctx_t;
struct core_filter_ctx {
   apr_bucket_brigade *b ;
};
typedef struct core_filter_ctx core_ctx_t;
struct core_net_rec {
   apr_socket_t *client_socket ;
   conn_rec *c ;
   core_output_filter_ctx_t *out_ctx ;
   core_ctx_t *in_ctx ;
};
typedef struct core_net_rec core_net_rec;
struct __anonstruct_core_request_config_77 {
   struct apr_bucket_brigade *bb ;
   void **notes ;
   int deliver_script ;
};
typedef struct __anonstruct_core_request_config_77 core_request_config;
struct __anonstruct_core_server_config_80 {
   char const   *ap_document_root ;
   char *access_name ;
   apr_array_header_t *sec_dir ;
   apr_array_header_t *sec_url ;
};
typedef struct __anonstruct_core_server_config_80 core_server_config;
struct ap_LINK_get_mgmt_items_t {
   ap_HOOK_get_mgmt_items_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_get_mgmt_items_t ap_LINK_get_mgmt_items_t;
typedef void apr_OFN_ap_logio_add_bytes_out_t(conn_rec *c , apr_off_t bytes );
typedef int proxy_HOOK_create_req_t(request_rec *r , request_rec *pr );
struct __anonstruct__hooks_107 {
   apr_array_header_t *link_get_mgmt_items ;
};
struct reorder_sort_rec {
   ap_conf_vector_t *elt ;
   int orig_index ;
};
enum __anonenum_what_108 {
    MSG = 0,
    LOCAL_PATH = 1,
    REMOTE_PATH = 2
};
enum server_token_type {
    SrvTk_MAJOR = 0,
    SrvTk_MINOR = 1,
    SrvTk_MINIMAL = 2,
    SrvTk_OS = 3,
    SrvTk_FULL = 4,
    SrvTk_PRODUCT_ONLY = 5
};
struct net_time_filter_ctx {
   apr_socket_t *csd ;
   int first_line ;
};
typedef struct net_time_filter_ctx net_time_filter_ctx_t;
struct ap_LINK_create_request_t {
   ap_HOOK_create_request_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_create_request_t ap_LINK_create_request_t;
struct ap_LINK_translate_name_t {
   ap_HOOK_translate_name_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_translate_name_t ap_LINK_translate_name_t;
struct ap_LINK_map_to_storage_t {
   ap_HOOK_map_to_storage_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_map_to_storage_t ap_LINK_map_to_storage_t;
struct ap_LINK_check_user_id_t {
   ap_HOOK_check_user_id_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_check_user_id_t ap_LINK_check_user_id_t;
struct ap_LINK_fixups_t {
   ap_HOOK_fixups_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_fixups_t ap_LINK_fixups_t;
struct ap_LINK_type_checker_t {
   ap_HOOK_type_checker_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_type_checker_t ap_LINK_type_checker_t;
struct ap_LINK_access_checker_t {
   ap_HOOK_access_checker_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_access_checker_t ap_LINK_access_checker_t;
struct ap_LINK_auth_checker_t {
   ap_HOOK_auth_checker_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_auth_checker_t ap_LINK_auth_checker_t;
struct ap_LINK_insert_filter_t {
   ap_HOOK_insert_filter_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_insert_filter_t ap_LINK_insert_filter_t;
struct __anonstruct__hooks_94 {
   apr_array_header_t *link_translate_name ;
   apr_array_header_t *link_map_to_storage ;
   apr_array_header_t *link_check_user_id ;
   apr_array_header_t *link_fixups ;
   apr_array_header_t *link_type_checker ;
   apr_array_header_t *link_access_checker ;
   apr_array_header_t *link_auth_checker ;
   apr_array_header_t *link_insert_filter ;
   apr_array_header_t *link_create_request ;
};
struct walk_walked_t {
   ap_conf_vector_t *matched ;
   ap_conf_vector_t *merged ;
};
typedef struct walk_walked_t walk_walked_t;
struct walk_cache_t {
   char const   *cached ;
   ap_conf_vector_t **dir_conf_tested ;
   ap_conf_vector_t *dir_conf_merged ;
   ap_conf_vector_t *per_dir_result ;
   apr_array_header_t *walked ;
};
typedef struct walk_cache_t walk_cache_t;
struct core_opts_t {
   allow_options_t opts ;
   allow_options_t add ;
   allow_options_t remove ;
   overrides_t override ;
};
typedef struct core_opts_t core_opts_t;
typedef int __key_t;
typedef unsigned short ushort;
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    RLIMIT_NPROC = 6,
    RLIMIT_MEMLOCK = 8,
    RLIMIT_LOCKS = 10,
    RLIMIT_NLIMITS = 11,
    RLIM_NLIMITS = 11
};
typedef enum __rlimit_resource __rlimit_resource_t;
struct ipc_perm {
   __key_t __key ;
   __uid_t uid ;
   __gid_t gid ;
   __uid_t cuid ;
   __gid_t cgid ;
   unsigned short mode ;
   unsigned short __pad1 ;
   unsigned short __seq ;
   unsigned short __pad2 ;
   unsigned long __unused1 ;
   unsigned long __unused2 ;
};
struct ap_LINK_get_suexec_identity_t {
   ap_HOOK_get_suexec_identity_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct ap_LINK_get_suexec_identity_t ap_LINK_get_suexec_identity_t;
struct __anonstruct_unixd_config_rec_76 {
   char const   *user_name ;
   uid_t user_id ;
   gid_t group_id ;
   int suexec_enabled ;
};
typedef struct __anonstruct_unixd_config_rec_76 unixd_config_rec;
struct semid_ds {
   struct ipc_perm sem_perm ;
   __time_t sem_otime ;
   unsigned long __unused1 ;
   __time_t sem_ctime ;
   unsigned long __unused2 ;
   unsigned long sem_nsems ;
   unsigned long __unused3 ;
   unsigned long __unused4 ;
};
struct __anonstruct__hooks_94___0 {
   apr_array_header_t *link_get_suexec_identity ;
};
union semun {
   long val ;
   struct semid_ds *buf ;
   ushort *array ;
};
struct real_pcre;
struct real_pcre_extra;
typedef struct real_pcre pcre;
typedef struct real_pcre_extra pcre_extra;
typedef int BOOL;
typedef unsigned char uschar;
struct real_pcre {
   unsigned long magic_number ;
   size_t size ;
   unsigned char const   *tables ;
   unsigned long options ;
   unsigned short top_bracket ;
   unsigned short top_backref ;
   uschar first_char ;
   uschar req_char ;
   uschar code[1] ;
};
typedef struct real_pcre real_pcre;
struct real_pcre_extra {
   uschar options ;
   uschar start_bits[32] ;
};
typedef struct real_pcre_extra real_pcre_extra;
struct compile_data {
   uschar const   *lcc ;
   uschar const   *fcc ;
   uschar const   *cbits ;
   uschar const   *ctypes ;
};
typedef struct compile_data compile_data;
struct match_data {
   int errorcode ;
   int *offset_vector ;
   int offset_end ;
   int offset_max ;
   uschar const   *lcc ;
   uschar const   *ctypes ;
   BOOL offset_overflow ;
   BOOL notbol ;
   BOOL noteol ;
   BOOL utf8 ;
   BOOL endonly ;
   BOOL notempty ;
   uschar const   *start_pattern ;
   uschar const   *start_subject ;
   uschar const   *end_subject ;
   uschar const   *start_match ;
   uschar const   *end_match_ptr ;
   int end_offset_top ;
};
typedef struct match_data match_data;
struct eptrblock {
   struct eptrblock *prev ;
   uschar const   *saved_eptr ;
};
typedef struct eptrblock eptrblock;
struct apr_bucket_heap;
typedef struct apr_bucket_heap apr_bucket_heap;
struct apr_bucket_heap {
   apr_bucket_refcount refcount ;
   char *base ;
   apr_size_t alloc_len ;
   void (*free_func)(void *data ) ;
};
struct apr_bucket_pool;
typedef struct apr_bucket_pool apr_bucket_pool;
struct apr_bucket_pool {
   apr_bucket_heap heap ;
   char const   *base ;
   apr_pool_t *pool ;
   apr_bucket_alloc_t *list ;
};
struct apr_bucket_mmap;
typedef struct apr_bucket_mmap apr_bucket_mmap;
struct apr_bucket_mmap {
   apr_bucket_refcount refcount ;
   apr_mmap_t *mmap ;
};
typedef apr_status_t (*apr_brigade_flush)(apr_bucket_brigade *bb , void *ctx );
struct brigade_vprintf_data_t {
   apr_vformatter_buff_t vbuff ;
   apr_bucket_brigade *b ;
   apr_brigade_flush *flusher ;
   void *ctx ;
   char *cbuff ;
};
union apr_bucket_structs;
typedef union apr_bucket_structs apr_bucket_structs;
union apr_bucket_structs {
   apr_bucket b ;
   apr_bucket_heap heap ;
   apr_bucket_pool pool ;
   apr_bucket_mmap mmap ;
   apr_bucket_file file ;
};
struct node_header_t {
   apr_size_t size ;
   apr_bucket_alloc_t *alloc ;
   apr_memnode_t *memnode ;
   struct node_header_t *next ;
};
typedef struct node_header_t node_header_t;
struct apr_bucket_alloc_t {
   apr_pool_t *pool ;
   apr_allocator_t *allocator ;
   node_header_t *freelist ;
   apr_memnode_t *blocks ;
};
typedef unsigned char apr_byte_t;
union endianTest {
   long Long ;
   char Char[(int )sizeof(long )] ;
};
typedef unsigned long long apr_uint64_t;
struct apr_sdbm_t {
   apr_pool_t *pool ;
   apr_file_t *dirf ;
   apr_file_t *pagf ;
   apr_int32_t flags ;
   long maxbno ;
   long curbit ;
   long hmask ;
   long blkptr ;
   int keyptr ;
   long blkno ;
   long pagbno ;
   char pagbuf[1024] ;
   long dirbno ;
   char dirbuf[4096] ;
   int lckcnt ;
};
struct __anonstruct_apr_dbm_type_t_53 {
   char const   *name ;
   apr_status_t (*open)(apr_dbm_t **pdb , char const   *pathname , apr_int32_t mode ,
                        apr_fileperms_t perm , apr_pool_t *pool ) ;
   void (*close)(apr_dbm_t *dbm ) ;
   apr_status_t (*fetch)(apr_dbm_t *dbm , apr_datum_t key , apr_datum_t *pvalue ) ;
   apr_status_t (*store)(apr_dbm_t *dbm , apr_datum_t key , apr_datum_t value ) ;
   apr_status_t (*del)(apr_dbm_t *dbm , apr_datum_t key ) ;
   int (*exists)(apr_dbm_t *dbm , apr_datum_t key ) ;
   apr_status_t (*firstkey)(apr_dbm_t *dbm , apr_datum_t *pkey ) ;
   apr_status_t (*nextkey)(apr_dbm_t *dbm , apr_datum_t *pkey ) ;
   void (*freedatum)(apr_dbm_t *dbm , apr_datum_t data ) ;
   void (*getusednames)(apr_pool_t *pool , char const   *pathname , char const   **used1 ,
                        char const   **used2 ) ;
};
typedef struct __anonstruct_apr_dbm_type_t_53 apr_dbm_type_t;
struct apr_dbm_t {
   apr_pool_t *pool ;
   void *file ;
   int errcode ;
   char const   *errmsg ;
   apr_dbm_type_t const   *type ;
};
typedef unsigned long __u_long;
typedef __u_long u_long;
typedef int int32_t;
typedef unsigned char u_int8_t;
typedef unsigned int u_int32_t;
typedef u_int32_t db_pgno_t;
typedef u_int32_t db_recno_t;
typedef u_int32_t db_timeout_t;
typedef u_int32_t roff_t;
struct __db;
typedef struct __db DB;
struct __db_dbt;
typedef struct __db_dbt DBT;
struct __db_env;
typedef struct __db_env DB_ENV;
struct __db_ilock;
typedef struct __db_ilock DB_LOCK_ILOCK;
struct __db_lock_stat;
typedef struct __db_lock_stat DB_LOCK_STAT;
struct __db_lock_u;
typedef struct __db_lock_u DB_LOCK;
struct __db_lockreq;
typedef struct __db_lockreq DB_LOCKREQ;
struct __db_log_cursor;
typedef struct __db_log_cursor DB_LOGC;
struct __db_log_stat;
typedef struct __db_log_stat DB_LOG_STAT;
struct __db_lsn;
typedef struct __db_lsn DB_LSN;
struct __db_mpool;
typedef struct __db_mpool DB_MPOOL;
struct __db_mpool_fstat;
typedef struct __db_mpool_fstat DB_MPOOL_FSTAT;
struct __db_mpool_stat;
typedef struct __db_mpool_stat DB_MPOOL_STAT;
struct __db_mpoolfile;
typedef struct __db_mpoolfile DB_MPOOLFILE;
struct __db_preplist;
typedef struct __db_preplist DB_PREPLIST;
struct __db_rep_stat;
typedef struct __db_rep_stat DB_REP_STAT;
struct __db_txn;
typedef struct __db_txn DB_TXN;
struct __db_txn_active;
typedef struct __db_txn_active DB_TXN_ACTIVE;
struct __db_txn_stat;
typedef struct __db_txn_stat DB_TXN_STAT;
struct __db_txnmgr;
typedef struct __db_txnmgr DB_TXNMGR;
struct __dbc;
typedef struct __dbc DBC;
struct __dbc_internal;
typedef struct __dbc_internal DBC_INTERNAL;
struct __fh_t;
typedef struct __fh_t DB_FH;
struct __fname;
typedef struct __fname FNAME;
struct __key_range;
typedef struct __key_range DB_KEY_RANGE;
struct __mpoolfile;
typedef struct __mpoolfile MPOOLFILE;
struct __mutex_t;
typedef struct __mutex_t DB_MUTEX;
struct __db_dbt {
   void *data ;
   u_int32_t size ;
   u_int32_t ulen ;
   u_int32_t dlen ;
   u_int32_t doff ;
   u_int32_t flags ;
};
enum __anonenum_db_lockmode_t_54 {
    DB_LOCK_NG = 0,
    DB_LOCK_READ = 1,
    DB_LOCK_WRITE = 2,
    DB_LOCK_WAIT = 3,
    DB_LOCK_IWRITE = 4,
    DB_LOCK_IREAD = 5,
    DB_LOCK_IWR = 6,
    DB_LOCK_DIRTY = 7,
    DB_LOCK_WWRITE = 8
};
typedef enum __anonenum_db_lockmode_t_54 db_lockmode_t;
enum __anonenum_db_lockop_t_55 {
    DB_LOCK_DUMP = 0,
    DB_LOCK_GET = 1,
    DB_LOCK_GET_TIMEOUT = 2,
    DB_LOCK_INHERIT = 3,
    DB_LOCK_PUT = 4,
    DB_LOCK_PUT_ALL = 5,
    DB_LOCK_PUT_OBJ = 6,
    DB_LOCK_PUT_READ = 7,
    DB_LOCK_TIMEOUT = 8,
    DB_LOCK_TRADE = 9,
    DB_LOCK_UPGRADE_WRITE = 10
};
typedef enum __anonenum_db_lockop_t_55 db_lockop_t;
struct __db_lock_stat {
   u_int32_t st_id ;
   u_int32_t st_cur_maxid ;
   u_int32_t st_maxlocks ;
   u_int32_t st_maxlockers ;
   u_int32_t st_maxobjects ;
   u_int32_t st_nmodes ;
   u_int32_t st_nlocks ;
   u_int32_t st_maxnlocks ;
   u_int32_t st_nlockers ;
   u_int32_t st_maxnlockers ;
   u_int32_t st_nobjects ;
   u_int32_t st_maxnobjects ;
   u_int32_t st_nconflicts ;
   u_int32_t st_nrequests ;
   u_int32_t st_nreleases ;
   u_int32_t st_nnowaits ;
   u_int32_t st_ndeadlocks ;
   db_timeout_t st_locktimeout ;
   u_int32_t st_nlocktimeouts ;
   db_timeout_t st_txntimeout ;
   u_int32_t st_ntxntimeouts ;
   u_int32_t st_region_wait ;
   u_int32_t st_region_nowait ;
   u_int32_t st_regsize ;
};
struct __db_ilock {
   db_pgno_t pgno ;
   u_int8_t fileid[20] ;
   u_int32_t type ;
};
struct __db_lock_u {
   size_t off ;
   u_int32_t ndx ;
   u_int32_t gen ;
   db_lockmode_t mode ;
};
struct __db_lockreq {
   db_lockop_t op ;
   db_lockmode_t mode ;
   db_timeout_t timeout ;
   DBT *obj ;
   DB_LOCK lock ;
};
struct __db_lsn {
   u_int32_t file ;
   u_int32_t offset ;
};
struct __db_log_cursor {
   DB_ENV *dbenv ;
   DB_FH *c_fh ;
   DB_LSN c_lsn ;
   u_int32_t c_len ;
   u_int32_t c_prev ;
   DBT c_dbt ;
   u_int8_t *bp ;
   u_int32_t bp_size ;
   u_int32_t bp_rlen ;
   DB_LSN bp_lsn ;
   u_int32_t bp_maxrec ;
   int (*close)(DB_LOGC * , u_int32_t  ) ;
   int (*get)(DB_LOGC * , DB_LSN * , DBT * , u_int32_t  ) ;
   u_int32_t flags ;
};
struct __db_log_stat {
   u_int32_t st_magic ;
   u_int32_t st_version ;
   int st_mode ;
   u_int32_t st_lg_bsize ;
   u_int32_t st_lg_size ;
   u_int32_t st_w_bytes ;
   u_int32_t st_w_mbytes ;
   u_int32_t st_wc_bytes ;
   u_int32_t st_wc_mbytes ;
   u_int32_t st_wcount ;
   u_int32_t st_wcount_fill ;
   u_int32_t st_scount ;
   u_int32_t st_region_wait ;
   u_int32_t st_region_nowait ;
   u_int32_t st_cur_file ;
   u_int32_t st_cur_offset ;
   u_int32_t st_disk_file ;
   u_int32_t st_disk_offset ;
   u_int32_t st_regsize ;
   u_int32_t st_maxcommitperflush ;
   u_int32_t st_mincommitperflush ;
};
enum __anonenum_DB_CACHE_PRIORITY_57 {
    DB_PRIORITY_VERY_LOW = 1,
    DB_PRIORITY_LOW = 2,
    DB_PRIORITY_DEFAULT = 3,
    DB_PRIORITY_HIGH = 4,
    DB_PRIORITY_VERY_HIGH = 5
};
typedef enum __anonenum_DB_CACHE_PRIORITY_57 DB_CACHE_PRIORITY;
struct __anonstruct_q_58 {
   struct __db_mpoolfile *tqe_next ;
   struct __db_mpoolfile **tqe_prev ;
};
struct __db_mpoolfile {
   DB_MUTEX *mutexp ;
   DB_FH *fhp ;
   u_int32_t ref ;
   u_int32_t pinref ;
   struct __anonstruct_q_58 q ;
   int ftype ;
   DBT *pgcookie ;
   u_int8_t *fileid ;
   int32_t lsn_offset ;
   u_int32_t clear_len ;
   DB_MPOOL *dbmp ;
   MPOOLFILE *mfp ;
   void *addr ;
   size_t len ;
   int (*close)(DB_MPOOLFILE * , u_int32_t  ) ;
   int (*get)(DB_MPOOLFILE * , db_pgno_t * , u_int32_t  , void * ) ;
   void (*get_fileid)(DB_MPOOLFILE * , u_int8_t * ) ;
   void (*last_pgno)(DB_MPOOLFILE * , db_pgno_t * ) ;
   int (*open)(DB_MPOOLFILE * , char const   * , u_int32_t  , int  , size_t  ) ;
   int (*put)(DB_MPOOLFILE * , void * , u_int32_t  ) ;
   void (*refcnt)(DB_MPOOLFILE * , db_pgno_t * ) ;
   int (*set)(DB_MPOOLFILE * , void * , u_int32_t  ) ;
   int (*set_clear_len)(DB_MPOOLFILE * , u_int32_t  ) ;
   int (*set_fileid)(DB_MPOOLFILE * , u_int8_t * ) ;
   int (*set_ftype)(DB_MPOOLFILE * , int  ) ;
   int (*set_lsn_offset)(DB_MPOOLFILE * , int32_t  ) ;
   int (*set_pgcookie)(DB_MPOOLFILE * , DBT * ) ;
   int (*set_priority)(DB_MPOOLFILE * , DB_CACHE_PRIORITY  ) ;
   void (*set_unlink)(DB_MPOOLFILE * , int  ) ;
   int (*sync)(DB_MPOOLFILE * ) ;
   u_int32_t flags ;
};
struct __db_mpool_stat {
   u_int32_t st_gbytes ;
   u_int32_t st_bytes ;
   u_int32_t st_ncache ;
   u_int32_t st_regsize ;
   u_int32_t st_map ;
   u_int32_t st_cache_hit ;
   u_int32_t st_cache_miss ;
   u_int32_t st_page_create ;
   u_int32_t st_page_in ;
   u_int32_t st_page_out ;
   u_int32_t st_ro_evict ;
   u_int32_t st_rw_evict ;
   u_int32_t st_page_trickle ;
   u_int32_t st_pages ;
   u_int32_t st_page_clean ;
   u_int32_t st_page_dirty ;
   u_int32_t st_hash_buckets ;
   u_int32_t st_hash_searches ;
   u_int32_t st_hash_longest ;
   u_int32_t st_hash_examined ;
   u_int32_t st_hash_nowait ;
   u_int32_t st_hash_wait ;
   u_int32_t st_hash_max_wait ;
   u_int32_t st_region_nowait ;
   u_int32_t st_region_wait ;
   u_int32_t st_alloc ;
   u_int32_t st_alloc_buckets ;
   u_int32_t st_alloc_max_buckets ;
   u_int32_t st_alloc_pages ;
   u_int32_t st_alloc_max_pages ;
};
struct __db_mpool_fstat {
   char *file_name ;
   size_t st_pagesize ;
   u_int32_t st_map ;
   u_int32_t st_cache_hit ;
   u_int32_t st_cache_miss ;
   u_int32_t st_page_create ;
   u_int32_t st_page_in ;
   u_int32_t st_page_out ;
};
enum __anonenum_db_recops_59 {
    DB_TXN_ABORT = 0,
    DB_TXN_APPLY = 1,
    DB_TXN_BACKWARD_ALLOC = 2,
    DB_TXN_BACKWARD_ROLL = 3,
    DB_TXN_FORWARD_ROLL = 4,
    DB_TXN_GETPGNOS = 5,
    DB_TXN_OPENFILES = 6,
    DB_TXN_POPENFILES = 7,
    DB_TXN_PRINT = 8
};
typedef enum __anonenum_db_recops_59 db_recops;
struct __anonstruct_links_60 {
   struct __db_txn *tqe_next ;
   struct __db_txn **tqe_prev ;
};
struct __txn_event;
struct __anonstruct_events_61 {
   struct __txn_event *tqh_first ;
   struct __txn_event **tqh_last ;
};
struct __kids {
   struct __db_txn *tqh_first ;
   struct __db_txn **tqh_last ;
};
struct __anonstruct_klinks_62 {
   struct __db_txn *tqe_next ;
   struct __db_txn **tqe_prev ;
};
struct __db_txn {
   DB_TXNMGR *mgrp ;
   DB_TXN *parent ;
   DB_LSN last_lsn ;
   u_int32_t txnid ;
   roff_t off ;
   db_timeout_t lock_timeout ;
   db_timeout_t expire ;
   void *txn_list ;
   struct __anonstruct_links_60 links ;
   struct __anonstruct_events_61 events ;
   struct __kids kids ;
   struct __anonstruct_klinks_62 klinks ;
   void *api_internal ;
   u_int32_t cursors ;
   int (*abort)(DB_TXN * ) ;
   int (*commit)(DB_TXN * , u_int32_t  ) ;
   int (*discard)(DB_TXN * , u_int32_t  ) ;
   u_int32_t (*id)(DB_TXN * ) ;
   int (*prepare)(DB_TXN * , u_int8_t * ) ;
   int (*set_timeout)(DB_TXN * , db_timeout_t  , u_int32_t  ) ;
   u_int32_t flags ;
};
struct __db_txn_active {
   u_int32_t txnid ;
   u_int32_t parentid ;
   DB_LSN lsn ;
};
struct __db_txn_stat {
   DB_LSN st_last_ckp ;
   time_t st_time_ckp ;
   u_int32_t st_last_txnid ;
   u_int32_t st_maxtxns ;
   u_int32_t st_naborts ;
   u_int32_t st_nbegins ;
   u_int32_t st_ncommits ;
   u_int32_t st_nactive ;
   u_int32_t st_nrestores ;
   u_int32_t st_maxnactive ;
   DB_TXN_ACTIVE *st_txnarray ;
   u_int32_t st_region_wait ;
   u_int32_t st_region_nowait ;
   u_int32_t st_regsize ;
};
struct __db_preplist {
   DB_TXN *txn ;
   u_int8_t gid[128] ;
};
struct __db_rep_stat {
   u_int32_t st_status ;
   DB_LSN st_next_lsn ;
   DB_LSN st_waiting_lsn ;
   u_int32_t st_dupmasters ;
   int st_env_id ;
   int st_env_priority ;
   u_int32_t st_gen ;
   u_int32_t st_log_duplicated ;
   u_int32_t st_log_queued ;
   u_int32_t st_log_queued_max ;
   u_int32_t st_log_queued_total ;
   u_int32_t st_log_records ;
   u_int32_t st_log_requested ;
   int st_master ;
   u_int32_t st_master_changes ;
   u_int32_t st_msgs_badgen ;
   u_int32_t st_msgs_processed ;
   u_int32_t st_msgs_recover ;
   u_int32_t st_msgs_send_failures ;
   u_int32_t st_msgs_sent ;
   u_int32_t st_newsites ;
   int st_nsites ;
   u_int32_t st_nthrottles ;
   u_int32_t st_outdated ;
   u_int32_t st_txns_applied ;
   u_int32_t st_elections ;
   u_int32_t st_elections_won ;
   int st_election_cur_winner ;
   u_int32_t st_election_gen ;
   DB_LSN st_election_lsn ;
   int st_election_nsites ;
   int st_election_priority ;
   int st_election_status ;
   int st_election_tiebreaker ;
   int st_election_votes ;
};
enum __anonenum_DBTYPE_63 {
    DB_BTREE = 1,
    DB_HASH = 2,
    DB_RECNO = 3,
    DB_QUEUE = 4,
    DB_UNKNOWN = 5
};
typedef enum __anonenum_DBTYPE_63 DBTYPE;
struct __anonstruct_dblistlinks_64 {
   struct __db *le_next ;
   struct __db **le_prev ;
};
struct __cq_fq {
   struct __dbc *tqh_first ;
   struct __dbc **tqh_last ;
};
struct __cq_aq {
   struct __dbc *tqh_first ;
   struct __dbc **tqh_last ;
};
struct __cq_jq {
   struct __dbc *tqh_first ;
   struct __dbc **tqh_last ;
};
struct __anonstruct_s_secondaries_65 {
   struct __db *lh_first ;
};
struct __anonstruct_s_links_66 {
   struct __db *le_next ;
   struct __db **le_prev ;
};
struct __db {
   u_int32_t pgsize ;
   int (*db_append_recno)(DB * , DBT * , db_recno_t  ) ;
   void (*db_feedback)(DB * , int  , int  ) ;
   int (*dup_compare)(DB * , DBT const   * , DBT const   * ) ;
   void *app_private ;
   DB_ENV *dbenv ;
   DBTYPE type ;
   DB_MPOOLFILE *mpf ;
   DB_CACHE_PRIORITY priority ;
   DB_MUTEX *mutexp ;
   u_int8_t fileid[20] ;
   u_int32_t adj_fileid ;
   FNAME *log_filename ;
   db_pgno_t meta_pgno ;
   u_int32_t lid ;
   u_int32_t cur_lid ;
   u_int32_t associate_lid ;
   DB_LOCK handle_lock ;
   long cl_id ;
   DBT my_rskey ;
   DBT my_rkey ;
   DBT my_rdata ;
   DB_FH *saved_open_fhp ;
   struct __anonstruct_dblistlinks_64 dblistlinks ;
   struct __cq_fq free_queue ;
   struct __cq_aq active_queue ;
   struct __cq_jq join_queue ;
   struct __anonstruct_s_secondaries_65 s_secondaries ;
   struct __anonstruct_s_links_66 s_links ;
   u_int32_t s_refcnt ;
   int (*s_callback)(DB * , DBT const   * , DBT const   * , DBT * ) ;
   DB *s_primary ;
   void *api_internal ;
   void *bt_internal ;
   void *h_internal ;
   void *q_internal ;
   void *xa_internal ;
   int (*associate)(DB * , DB_TXN * , DB * , int (*)(DB * , DBT const   * , DBT const   * ,
                                                     DBT * ) , u_int32_t  ) ;
   int (*close)(DB * , u_int32_t  ) ;
   int (*cursor)(DB * , DB_TXN * , DBC ** , u_int32_t  ) ;
   int (*del)(DB * , DB_TXN * , DBT * , u_int32_t  ) ;
   void (*err)(DB * , int  , char const   *  , ...) ;
   void (*errx)(DB * , char const   *  , ...) ;
   int (*fd)(DB * , int * ) ;
   int (*get)(DB * , DB_TXN * , DBT * , DBT * , u_int32_t  ) ;
   int (*pget)(DB * , DB_TXN * , DBT * , DBT * , DBT * , u_int32_t  ) ;
   int (*get_byteswapped)(DB * , int * ) ;
   int (*get_type)(DB * , DBTYPE * ) ;
   int (*join)(DB * , DBC ** , DBC ** , u_int32_t  ) ;
   int (*key_range)(DB * , DB_TXN * , DBT * , DB_KEY_RANGE * , u_int32_t  ) ;
   int (*open)(DB * , DB_TXN * , char const   * , char const   * , DBTYPE  , u_int32_t  ,
               int  ) ;
   int (*put)(DB * , DB_TXN * , DBT * , DBT * , u_int32_t  ) ;
   int (*remove)(DB * , char const   * , char const   * , u_int32_t  ) ;
   int (*rename)(DB * , char const   * , char const   * , char const   * , u_int32_t  ) ;
   int (*truncate)(DB * , DB_TXN * , u_int32_t * , u_int32_t  ) ;
   int (*set_append_recno)(DB * , int (*)(DB * , DBT * , db_recno_t  ) ) ;
   int (*set_alloc)(DB * , void *(*)(size_t  ) , void *(*)(void * , size_t  ) , void (*)(void * ) ) ;
   int (*set_cachesize)(DB * , u_int32_t  , u_int32_t  , int  ) ;
   int (*set_cache_priority)(DB * , DB_CACHE_PRIORITY  ) ;
   int (*set_dup_compare)(DB * , int (*)(DB * , DBT const   * , DBT const   * ) ) ;
   int (*set_encrypt)(DB * , char const   * , u_int32_t  ) ;
   void (*set_errcall)(DB * , void (*)(char const   * , char * ) ) ;
   void (*set_errfile)(DB * , FILE * ) ;
   void (*set_errpfx)(DB * , char const   * ) ;
   int (*set_feedback)(DB * , void (*)(DB * , int  , int  ) ) ;
   int (*set_flags)(DB * , u_int32_t  ) ;
   int (*set_lorder)(DB * , int  ) ;
   int (*set_pagesize)(DB * , u_int32_t  ) ;
   int (*set_paniccall)(DB * , void (*)(DB_ENV * , int  ) ) ;
   int (*stat)(DB * , void * , u_int32_t  ) ;
   int (*sync)(DB * , u_int32_t  ) ;
   int (*upgrade)(DB * , char const   * , u_int32_t  ) ;
   int (*verify)(DB * , char const   * , char const   * , FILE * , u_int32_t  ) ;
   int (*set_bt_compare)(DB * , int (*)(DB * , DBT const   * , DBT const   * ) ) ;
   int (*set_bt_maxkey)(DB * , u_int32_t  ) ;
   int (*set_bt_minkey)(DB * , u_int32_t  ) ;
   int (*set_bt_prefix)(DB * , size_t (*)(DB * , DBT const   * , DBT const   * ) ) ;
   int (*set_h_ffactor)(DB * , u_int32_t  ) ;
   int (*set_h_hash)(DB * , u_int32_t (*)(DB * , void const   * , u_int32_t  ) ) ;
   int (*set_h_nelem)(DB * , u_int32_t  ) ;
   int (*set_re_delim)(DB * , int  ) ;
   int (*set_re_len)(DB * , u_int32_t  ) ;
   int (*set_re_pad)(DB * , int  ) ;
   int (*set_re_source)(DB * , char const   * ) ;
   int (*set_q_extentsize)(DB * , u_int32_t  ) ;
   int (*db_am_remove)(DB * , DB_TXN * , char const   * , char const   * , DB_LSN * ) ;
   int (*db_am_rename)(DB * , DB_TXN * , char const   * , char const   * , char const   * ) ;
   int (*stored_get)(DB * , DB_TXN * , DBT * , DBT * , u_int32_t  ) ;
   int (*stored_close)(DB * , u_int32_t  ) ;
   u_int32_t am_ok ;
   u_int32_t flags ;
};
struct __anonstruct_links_67 {
   DBC *tqe_next ;
   DBC **tqe_prev ;
};
struct __dbc {
   DB *dbp ;
   DB_TXN *txn ;
   struct __anonstruct_links_67 links ;
   DBT *rskey ;
   DBT *rkey ;
   DBT *rdata ;
   DBT my_rskey ;
   DBT my_rkey ;
   DBT my_rdata ;
   u_int32_t lid ;
   u_int32_t locker ;
   DBT lock_dbt ;
   DB_LOCK_ILOCK lock ;
   DB_LOCK mylock ;
   long cl_id ;
   DBTYPE dbtype ;
   DBC_INTERNAL *internal ;
   int (*c_close)(DBC * ) ;
   int (*c_count)(DBC * , db_recno_t * , u_int32_t  ) ;
   int (*c_del)(DBC * , u_int32_t  ) ;
   int (*c_dup)(DBC * , DBC ** , u_int32_t  ) ;
   int (*c_get)(DBC * , DBT * , DBT * , u_int32_t  ) ;
   int (*c_pget)(DBC * , DBT * , DBT * , DBT * , u_int32_t  ) ;
   int (*c_put)(DBC * , DBT * , DBT * , u_int32_t  ) ;
   int (*c_am_bulk)(DBC * , DBT * , u_int32_t  ) ;
   int (*c_am_close)(DBC * , db_pgno_t  , int * ) ;
   int (*c_am_del)(DBC * ) ;
   int (*c_am_destroy)(DBC * ) ;
   int (*c_am_get)(DBC * , DBT * , DBT * , u_int32_t  , db_pgno_t * ) ;
   int (*c_am_put)(DBC * , DBT * , DBT * , u_int32_t  , db_pgno_t * ) ;
   int (*c_am_writelock)(DBC * ) ;
   int (*c_real_get)(DBC * , DBT * , DBT * , u_int32_t  ) ;
   u_int32_t flags ;
};
struct __key_range {
   double less ;
   double equal ;
   double greater ;
};
struct __anonstruct_dblist_68 {
   struct __db *lh_first ;
};
struct __anonstruct_links_69 {
   struct __db_env *tqe_next ;
   struct __db_env **tqe_prev ;
};
struct __db_env {
   FILE *db_errfile ;
   char const   *db_errpfx ;
   void (*db_errcall)(char const   * , char * ) ;
   void (*db_feedback)(DB_ENV * , int  , int  ) ;
   void (*db_paniccall)(DB_ENV * , int  ) ;
   void *(*db_malloc)(size_t  ) ;
   void *(*db_realloc)(void * , size_t  ) ;
   void (*db_free)(void * ) ;
   u_int32_t verbose ;
   void *app_private ;
   int (*app_dispatch)(DB_ENV * , DBT * , DB_LSN * , db_recops  ) ;
   u_int8_t *lk_conflicts ;
   u_int32_t lk_modes ;
   u_int32_t lk_max ;
   u_int32_t lk_max_lockers ;
   u_int32_t lk_max_objects ;
   u_int32_t lk_detect ;
   db_timeout_t lk_timeout ;
   u_int32_t lg_bsize ;
   u_int32_t lg_size ;
   u_int32_t lg_regionmax ;
   u_int32_t mp_gbytes ;
   u_int32_t mp_bytes ;
   size_t mp_size ;
   int mp_ncache ;
   size_t mp_mmapsize ;
   int rep_eid ;
   u_int32_t tx_max ;
   time_t tx_timestamp ;
   db_timeout_t tx_timeout ;
   int panic_errval ;
   char *db_home ;
   char *db_log_dir ;
   char *db_tmp_dir ;
   char **db_data_dir ;
   int data_cnt ;
   int data_next ;
   int db_mode ;
   void *reginfo ;
   DB_FH *lockfhp ;
   int (**recover_dtab)(DB_ENV * , DBT * , DB_LSN * , db_recops  , void * ) ;
   size_t recover_dtab_size ;
   void *cl_handle ;
   long cl_id ;
   int db_ref ;
   long shm_key ;
   u_int32_t tas_spins ;
   DB_MUTEX *dblist_mutexp ;
   struct __anonstruct_dblist_68 dblist ;
   struct __anonstruct_links_69 links ;
   int xa_rmid ;
   DB_TXN *xa_txn ;
   void *api1_internal ;
   void *api2_internal ;
   char *passwd ;
   size_t passwd_len ;
   void *crypto_handle ;
   DB_MUTEX *mt_mutexp ;
   int mti ;
   u_long *mt ;
   int (*close)(DB_ENV * , u_int32_t  ) ;
   int (*dbremove)(DB_ENV * , DB_TXN * , char const   * , char const   * , u_int32_t  ) ;
   int (*dbrename)(DB_ENV * , DB_TXN * , char const   * , char const   * , char const   * ,
                   u_int32_t  ) ;
   void (*err)(DB_ENV const   * , int  , char const   *  , ...) ;
   void (*errx)(DB_ENV const   * , char const   *  , ...) ;
   int (*open)(DB_ENV * , char const   * , u_int32_t  , int  ) ;
   int (*remove)(DB_ENV * , char const   * , u_int32_t  ) ;
   int (*set_data_dir)(DB_ENV * , char const   * ) ;
   int (*set_alloc)(DB_ENV * , void *(*)(size_t  ) , void *(*)(void * , size_t  ) ,
                    void (*)(void * ) ) ;
   int (*set_app_dispatch)(DB_ENV * , int (*)(DB_ENV * , DBT * , DB_LSN * , db_recops  ) ) ;
   int (*set_encrypt)(DB_ENV * , char const   * , u_int32_t  ) ;
   void (*set_errcall)(DB_ENV * , void (*)(char const   * , char * ) ) ;
   void (*set_errfile)(DB_ENV * , FILE * ) ;
   void (*set_errpfx)(DB_ENV * , char const   * ) ;
   int (*set_feedback)(DB_ENV * , void (*)(DB_ENV * , int  , int  ) ) ;
   int (*set_flags)(DB_ENV * , u_int32_t  , int  ) ;
   int (*set_paniccall)(DB_ENV * , void (*)(DB_ENV * , int  ) ) ;
   int (*set_rpc_server)(DB_ENV * , void * , char const   * , long  , long  , u_int32_t  ) ;
   int (*set_shm_key)(DB_ENV * , long  ) ;
   int (*set_tas_spins)(DB_ENV * , u_int32_t  ) ;
   int (*set_tmp_dir)(DB_ENV * , char const   * ) ;
   int (*set_verbose)(DB_ENV * , u_int32_t  , int  ) ;
   void *lg_handle ;
   int (*set_lg_bsize)(DB_ENV * , u_int32_t  ) ;
   int (*set_lg_dir)(DB_ENV * , char const   * ) ;
   int (*set_lg_max)(DB_ENV * , u_int32_t  ) ;
   int (*set_lg_regionmax)(DB_ENV * , u_int32_t  ) ;
   int (*log_archive)(DB_ENV * , char *** , u_int32_t  ) ;
   int (*log_cursor)(DB_ENV * , DB_LOGC ** , u_int32_t  ) ;
   int (*log_file)(DB_ENV * , DB_LSN const   * , char * , size_t  ) ;
   int (*log_flush)(DB_ENV * , DB_LSN const   * ) ;
   int (*log_put)(DB_ENV * , DB_LSN * , DBT const   * , u_int32_t  ) ;
   int (*log_stat)(DB_ENV * , DB_LOG_STAT ** , u_int32_t  ) ;
   void *lk_handle ;
   int (*set_lk_conflicts)(DB_ENV * , u_int8_t * , int  ) ;
   int (*set_lk_detect)(DB_ENV * , u_int32_t  ) ;
   int (*set_lk_max)(DB_ENV * , u_int32_t  ) ;
   int (*set_lk_max_locks)(DB_ENV * , u_int32_t  ) ;
   int (*set_lk_max_lockers)(DB_ENV * , u_int32_t  ) ;
   int (*set_lk_max_objects)(DB_ENV * , u_int32_t  ) ;
   int (*lock_detect)(DB_ENV * , u_int32_t  , u_int32_t  , int * ) ;
   int (*lock_dump_region)(DB_ENV * , char * , FILE * ) ;
   int (*lock_get)(DB_ENV * , u_int32_t  , u_int32_t  , DBT const   * , db_lockmode_t  ,
                   DB_LOCK * ) ;
   int (*lock_put)(DB_ENV * , DB_LOCK * ) ;
   int (*lock_id)(DB_ENV * , u_int32_t * ) ;
   int (*lock_id_free)(DB_ENV * , u_int32_t  ) ;
   int (*lock_id_set)(DB_ENV * , u_int32_t  , u_int32_t  ) ;
   int (*lock_stat)(DB_ENV * , DB_LOCK_STAT ** , u_int32_t  ) ;
   int (*lock_vec)(DB_ENV * , u_int32_t  , u_int32_t  , DB_LOCKREQ * , int  , DB_LOCKREQ ** ) ;
   int (*lock_downgrade)(DB_ENV * , DB_LOCK * , db_lockmode_t  , u_int32_t  ) ;
   void *mp_handle ;
   int (*set_mp_mmapsize)(DB_ENV * , size_t  ) ;
   int (*set_cachesize)(DB_ENV * , u_int32_t  , u_int32_t  , int  ) ;
   int (*memp_dump_region)(DB_ENV * , char * , FILE * ) ;
   int (*memp_fcreate)(DB_ENV * , DB_MPOOLFILE ** , u_int32_t  ) ;
   int (*memp_nameop)(DB_ENV * , u_int8_t * , char const   * , char const   * , char const   * ) ;
   int (*memp_register)(DB_ENV * , int  , int (*)(DB_ENV * , db_pgno_t  , void * ,
                                                  DBT * ) , int (*)(DB_ENV * , db_pgno_t  ,
                                                                    void * , DBT * ) ) ;
   int (*memp_stat)(DB_ENV * , DB_MPOOL_STAT ** , DB_MPOOL_FSTAT *** , u_int32_t  ) ;
   int (*memp_sync)(DB_ENV * , DB_LSN * ) ;
   int (*memp_trickle)(DB_ENV * , int  , int * ) ;
   void *rep_handle ;
   int (*rep_elect)(DB_ENV * , int  , int  , u_int32_t  , int * ) ;
   int (*rep_flush)(DB_ENV * ) ;
   int (*rep_process_message)(DB_ENV * , DBT * , DBT * , int * ) ;
   int (*rep_start)(DB_ENV * , DBT * , u_int32_t  ) ;
   int (*rep_stat)(DB_ENV * , DB_REP_STAT ** , u_int32_t  ) ;
   int (*set_rep_election)(DB_ENV * , u_int32_t  , u_int32_t  , u_int32_t  , u_int32_t  ) ;
   int (*set_rep_limit)(DB_ENV * , u_int32_t  , u_int32_t  ) ;
   int (*set_rep_request)(DB_ENV * , u_int32_t  , u_int32_t  ) ;
   int (*set_rep_timeout)(DB_ENV * , u_int32_t  , u_int32_t  ) ;
   int (*set_rep_transport)(DB_ENV * , int  , int (*)(DB_ENV * , DBT const   * , DBT const   * ,
                                                      int  , u_int32_t  ) ) ;
   void *tx_handle ;
   int (*set_tx_max)(DB_ENV * , u_int32_t  ) ;
   int (*set_tx_timestamp)(DB_ENV * , time_t * ) ;
   int (*txn_begin)(DB_ENV * , DB_TXN * , DB_TXN ** , u_int32_t  ) ;
   int (*txn_checkpoint)(DB_ENV * , u_int32_t  , u_int32_t  , u_int32_t  ) ;
   int (*txn_id_set)(DB_ENV * , u_int32_t  , u_int32_t  ) ;
   int (*txn_recover)(DB_ENV * , DB_PREPLIST * , long  , long * , u_int32_t  ) ;
   int (*txn_stat)(DB_ENV * , DB_TXN_STAT ** , u_int32_t  ) ;
   int (*set_timeout)(DB_ENV * , db_timeout_t  , u_int32_t  ) ;
   int test_abort ;
   int test_copy ;
   u_int32_t flags ;
};
struct __anonstruct_real_file_t_73 {
   DB *bdb ;
   DBC *curs ;
};
typedef struct __anonstruct_real_file_t_73 real_file_t;
struct __anonstruct_GDBM_FILE_58 {
   int dummy[10] ;
};
typedef struct __anonstruct_GDBM_FILE_58 *GDBM_FILE;
typedef int gdbm_error;
typedef GDBM_FILE real_file_t___0;
typedef apr_sdbm_datum_t *cvt_datum_t;
typedef apr_sdbm_datum_t result_datum_t;
typedef apr_sdbm_t *real_file_t___1;
struct __anonstruct_TSortData_54 {
   void (*dummy)(void * ) ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct __anonstruct_TSortData_54 TSortData;
struct tsort_ {
   void *pData ;
   int nPredecessors ;
   struct tsort_ **ppPredecessors ;
   struct tsort_ *pNext ;
};
typedef struct tsort_ TSort;
struct __anonstruct_HookSortEntry_55 {
   char const   *szHookName ;
   apr_array_header_t **paHooks ;
};
typedef struct __anonstruct_HookSortEntry_55 HookSortEntry;
typedef void apr_HOOK__optional_t(void);
struct apr_LINK__optional_t {
   apr_HOOK__optional_t *pFunc ;
   char const   *szName ;
   char const   * const  *aszPredecessors ;
   char const   * const  *aszSuccessors ;
   int nOrder ;
};
typedef struct apr_LINK__optional_t apr_LINK__optional_t;
struct schemes_t;
typedef struct schemes_t schemes_t;
struct schemes_t {
   char const   *name ;
   apr_port_t default_port ;
};
typedef struct apr_xml_attr apr_xml_attr;
struct XML_ParserStruct;
typedef struct XML_ParserStruct *XML_Parser;
typedef char XML_Char;
typedef char XML_LChar;
enum XML_Error {
    XML_ERROR_NONE = 0,
    XML_ERROR_NO_MEMORY = 1,
    XML_ERROR_SYNTAX = 2,
    XML_ERROR_NO_ELEMENTS = 3,
    XML_ERROR_INVALID_TOKEN = 4,
    XML_ERROR_UNCLOSED_TOKEN = 5,
    XML_ERROR_PARTIAL_CHAR = 6,
    XML_ERROR_TAG_MISMATCH = 7,
    XML_ERROR_DUPLICATE_ATTRIBUTE = 8,
    XML_ERROR_JUNK_AFTER_DOC_ELEMENT = 9,
    XML_ERROR_PARAM_ENTITY_REF = 10,
    XML_ERROR_UNDEFINED_ENTITY = 11,
    XML_ERROR_RECURSIVE_ENTITY_REF = 12,
    XML_ERROR_ASYNC_ENTITY = 13,
    XML_ERROR_BAD_CHAR_REF = 14,
    XML_ERROR_BINARY_ENTITY_REF = 15,
    XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF = 16,
    XML_ERROR_MISPLACED_XML_PI = 17,
    XML_ERROR_UNKNOWN_ENCODING = 18,
    XML_ERROR_INCORRECT_ENCODING = 19,
    XML_ERROR_UNCLOSED_CDATA_SECTION = 20,
    XML_ERROR_EXTERNAL_ENTITY_HANDLING = 21,
    XML_ERROR_NOT_STANDALONE = 22,
    XML_ERROR_UNEXPECTED_STATE = 23,
    XML_ERROR_ENTITY_DECLARED_IN_PE = 24,
    XML_ERROR_FEATURE_REQUIRES_XML_DTD = 25,
    XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING = 26
};
enum XML_Status {
    XML_STATUS_ERROR = 0,
    XML_STATUS_OK = 1
};
struct apr_xml_parser {
   apr_xml_doc *doc ;
   apr_pool_t *p ;
   apr_xml_elem *cur_elem ;
   int error ;
   XML_Parser xp ;
   enum XML_Error xp_err ;
};
struct apr_xml_ns_scope {
   char const   *prefix ;
   int ns ;
   int emptyURI ;
   struct apr_xml_ns_scope *next ;
};
typedef struct apr_xml_ns_scope apr_xml_ns_scope;
struct rmm_block_t {
   apr_size_t size ;
   apr_rmm_off_t prev ;
   apr_rmm_off_t next ;
};
typedef struct rmm_block_t rmm_block_t;
struct rmm_hdr_block_t {
   apr_size_t abssize ;
   apr_rmm_off_t firstused ;
   apr_rmm_off_t firstfree ;
};
typedef struct rmm_hdr_block_t rmm_hdr_block_t;
struct apr_rmm_t {
   apr_pool_t *p ;
   rmm_hdr_block_t *base ;
   apr_size_t size ;
   apr_anylock_t lock ;
};
union grainbit {
   long l ;
   long *pl ;
};
struct apr_res_t;
struct __anonstruct_link_42 {
   struct apr_res_t *next ;
   struct apr_res_t *prev ;
};
struct apr_res_t {
   apr_time_t freed ;
   void *opaque ;
   struct __anonstruct_link_42 link ;
};
typedef struct apr_res_t apr_res_t;
struct apr_resring_t {
   struct apr_res_t *next ;
   struct apr_res_t *prev ;
};
typedef struct apr_resring_t apr_resring_t;
struct apr_reslist_t {
   apr_pool_t *pool ;
   int ntotal ;
   int nidle ;
   int min ;
   int smax ;
   int hmax ;
   apr_interval_time_t ttl ;
   apr_status_t (*constructor)(void **resource , void *params , apr_pool_t *pool ) ;
   apr_status_t (*destructor)(void *resource , void *params , apr_pool_t *pool ) ;
   void *params ;
   apr_resring_t avail_list ;
   apr_resring_t free_list ;
   apr_thread_mutex_t *listlock ;
   apr_thread_cond_t *avail ;
};
struct apr_queue_t {
   void **data ;
   unsigned int nelts ;
   unsigned int in ;
   unsigned int out ;
   unsigned int bounds ;
   apr_thread_mutex_t *one_big_mutex ;
   apr_thread_cond_t *not_empty ;
   apr_thread_cond_t *not_full ;
   int terminated ;
};
typedef void *iconv_t;
struct apr_xlate_t {
   apr_pool_t *pool ;
   char *frompage ;
   char *topage ;
   char *sbcs_table ;
   iconv_t ich ;
};
enum __anonenum_boolean_e_61 {
    NO = 0,
    YES = 1
};
typedef enum __anonenum_boolean_e_61 boolean_e;
typedef long wide_int;
typedef unsigned long u_wide_int;
typedef apr_int64_t widest_int;
typedef apr_uint64_t u_widest_int;
typedef int bool_int;
enum __anonenum_adjust_62 {
    LEFT = 0,
    RIGHT = 1
};
enum var_type_enum {
    IS_QUAD = 0,
    IS_LONG = 1,
    IS_SHORT = 2,
    IS_INT = 3
};
struct apr_hash_entry_t;
typedef struct apr_hash_entry_t apr_hash_entry_t;
struct apr_hash_entry_t {
   apr_hash_entry_t *next ;
   unsigned int hash ;
   void const   *key ;
   apr_ssize_t klen ;
   void const   *val ;
};
struct apr_hash_index_t {
   apr_hash_t *ht ;
   apr_hash_entry_t *this ;
   apr_hash_entry_t *next ;
   unsigned int index ;
};
struct apr_hash_t {
   apr_pool_t *pool ;
   apr_hash_entry_t **array ;
   apr_hash_index_t iterator ;
   unsigned int count ;
   unsigned int max ;
};
struct apr_table_t {
   apr_array_header_t a ;
   apr_uint32_t index_initialized ;
   int index_first[32] ;
   int index_last[32] ;
};
struct overlap_key {
   apr_table_entry_t *elt ;
   int level ;
   int skip ;
   int black ;
   struct overlap_key *tree_parent ;
   struct overlap_key *tree_left ;
   struct overlap_key *tree_right ;
   int color ;
   struct overlap_key *merge_next ;
   struct overlap_key *merge_last ;
};
typedef struct overlap_key overlap_key;
enum __anonenum_blocking_60 {
    BLK_UNKNOWN = 0,
    BLK_OFF = 1,
    BLK_ON = 2
};
struct apr_file_t {
   apr_pool_t *pool ;
   int filedes ;
   char *fname ;
   apr_int32_t flags ;
   int eof_hit ;
   int is_pipe ;
   apr_interval_time_t timeout ;
   int buffered ;
   enum __anonenum_blocking_60 blocking ;
   int ungetchar ;
   char *buffer ;
   int bufpos ;
   unsigned long dataRead ;
   int direction ;
   unsigned long filePtr ;
   struct apr_thread_mutex_t *thlock ;
};
typedef unsigned int __mode_t;
typedef __mode_t mode_t;
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct apr_dir_t {
   apr_pool_t *pool ;
   char *dirname ;
   DIR *dirstruct ;
   struct dirent *entry ;
};
typedef unsigned int __nlink_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
struct __anonstruct_best_63 {
   int base ;
   int len ;
};
struct apr_socket_t {
   apr_pool_t *cntxt ;
   int socketdes ;
   int type ;
   int protocol ;
   apr_sockaddr_t *local_addr ;
   apr_sockaddr_t *remote_addr ;
   apr_interval_time_t timeout ;
   int local_port_unknown ;
   int local_interface_unknown ;
   int remote_addr_unknown ;
   apr_int32_t netmask ;
   apr_int32_t inherit ;
};
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
struct apr_ipsubnet_t {
   int family ;
   apr_uint32_t sub[4] ;
   apr_uint32_t mask[4] ;
};
struct linger {
   int l_onoff ;
   int l_linger ;
};
struct apr_procattr_t {
   apr_pool_t *pool ;
   apr_file_t *parent_in ;
   apr_file_t *child_in ;
   apr_file_t *parent_out ;
   apr_file_t *child_out ;
   apr_file_t *parent_err ;
   apr_file_t *child_err ;
   char *currdir ;
   apr_int32_t cmdtype ;
   apr_int32_t detached ;
   struct rlimit *limit_cpu ;
   struct rlimit *limit_mem ;
   struct rlimit *limit_nproc ;
   struct rlimit *limit_nofile ;
};
union __anonunion___u_81 {
   int __in ;
   int __i ;
};
union __anonunion___u_82 {
   int __in ;
   int __i ;
};
union __anonunion___u_83 {
   int __in ;
   int __i ;
};
union __anonunion___u_84 {
   int __in ;
   int __i ;
};
union __anonunion___u_85 {
   int __in ;
   int __i ;
};
struct __sched_param {
   int __sched_priority ;
};
struct __pthread_attr_s {
   int __detachstate ;
   int __schedpolicy ;
   struct __sched_param __schedparam ;
   int __inheritsched ;
   int __scope ;
   size_t __guardsize ;
   int __stackaddr_set ;
   void *__stackaddr ;
   size_t __stacksize ;
};
typedef struct __pthread_attr_s pthread_attr_t;
typedef int pthread_once_t;
struct apr_thread_t {
   apr_pool_t *pool ;
   pthread_t *td ;
   void *data ;
   void *(*func)(apr_thread_t * , void * ) ;
   apr_status_t exitval ;
};
struct apr_threadattr_t {
   apr_pool_t *pool ;
   pthread_attr_t *attr ;
};
struct apr_thread_once_t {
   pthread_once_t once ;
};
struct apr_threadkey_t {
   apr_pool_t *pool ;
   pthread_key_t key ;
};
struct apr_other_child_rec_t;
typedef struct apr_other_child_rec_t apr_other_child_rec_t;
struct apr_other_child_rec_t {
   apr_pool_t *p ;
   struct apr_other_child_rec_t *next ;
   apr_proc_t *proc ;
   void (*maintenance)(int  , void * , int  ) ;
   void *data ;
   apr_os_file_t write_fd ;
};
struct apr_proc_mutex_unix_lock_methods_t {
   unsigned int flags ;
   apr_status_t (*create)(apr_proc_mutex_t * , char const   * ) ;
   apr_status_t (*acquire)(apr_proc_mutex_t * ) ;
   apr_status_t (*tryacquire)(apr_proc_mutex_t * ) ;
   apr_status_t (*release)(apr_proc_mutex_t * ) ;
   apr_status_t (*cleanup)(void * ) ;
   apr_status_t (*child_init)(apr_proc_mutex_t ** , apr_pool_t * , char const   * ) ;
   char const   *name ;
};
typedef struct apr_proc_mutex_unix_lock_methods_t apr_proc_mutex_unix_lock_methods_t;
struct apr_proc_mutex_t {
   apr_pool_t *pool ;
   apr_proc_mutex_unix_lock_methods_t const   *meth ;
   apr_proc_mutex_unix_lock_methods_t const   *inter_meth ;
   int curr_locked ;
   char *fname ;
   apr_file_t *interproc ;
   pthread_mutex_t *pthread_interproc ;
};
struct apr_thread_mutex_t {
   apr_pool_t *pool ;
   pthread_mutex_t mutex ;
   apr_os_thread_t owner ;
   int owner_ref ;
   char nested ;
};
struct apr_global_mutex_t {
   apr_pool_t *pool ;
   apr_proc_mutex_t *proc_mutex ;
   apr_thread_mutex_t *thread_mutex ;
};
typedef __key_t key_t;
struct __anonstruct_pthread_mutexattr_t_7 {
   int __mutexkind ;
};
typedef struct __anonstruct_pthread_mutexattr_t_7 pthread_mutexattr_t;
struct sembuf {
   unsigned short sem_num ;
   short sem_op ;
   short sem_flg ;
};
struct __anonstruct_sem_t_81 {
   struct _pthread_fastlock __sem_lock ;
   int __sem_value ;
   _pthread_descr __sem_waiting ;
};
typedef struct __anonstruct_sem_t_81 sem_t;
union semun___0 {
   int val ;
   struct semid_ds *buf ;
   unsigned short *array ;
};
typedef long long __pthread_cond_align_t;
struct __anonstruct_pthread_cond_t_4 {
   struct _pthread_fastlock __c_lock ;
   _pthread_descr __c_waiting ;
   char __padding[(int )(((48U - sizeof(struct _pthread_fastlock )) - sizeof(_pthread_descr )) -
                         sizeof(__pthread_cond_align_t ))] ;
   __pthread_cond_align_t __align ;
};
typedef struct __anonstruct_pthread_cond_t_4 pthread_cond_t;
struct __anonstruct_pthread_condattr_t_5 {
   int __dummy ;
};
typedef struct __anonstruct_pthread_condattr_t_5 pthread_condattr_t;
struct apr_thread_cond_t {
   apr_pool_t *pool ;
   pthread_cond_t *cond ;
};
struct _pthread_rwlock_t {
   struct _pthread_fastlock __rw_lock ;
   int __rw_readers ;
   _pthread_descr __rw_writer ;
   _pthread_descr __rw_read_waiting ;
   _pthread_descr __rw_write_waiting ;
   int __rw_kind ;
   int __rw_pshared ;
};
typedef struct _pthread_rwlock_t pthread_rwlock_t;
struct __anonstruct_pthread_rwlockattr_t_8 {
   int __lockkind ;
   int __pshared ;
};
typedef struct __anonstruct_pthread_rwlockattr_t_8 pthread_rwlockattr_t;
struct apr_thread_rwlock_t {
   apr_pool_t *pool ;
   pthread_rwlock_t *rwlock ;
};
typedef long __fd_mask;
struct __anonstruct_fd_set_3 {
   __fd_mask fds_bits[(int )(1024U / (8U * sizeof(__fd_mask )))] ;
};
typedef struct __anonstruct_fd_set_3 fd_set;
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
typedef struct timezone * __restrict  __timezone_ptr_t;
typedef unsigned long shmatt_t;
struct shmid_ds {
   struct ipc_perm shm_perm ;
   size_t shm_segsz ;
   __time_t shm_atime ;
   unsigned long __unused1 ;
   __time_t shm_dtime ;
   unsigned long __unused2 ;
   __time_t shm_ctime ;
   unsigned long __unused3 ;
   __pid_t shm_cpid ;
   __pid_t shm_lpid ;
   shmatt_t shm_nattch ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
struct apr_shm_t {
   apr_pool_t *pool ;
   void *base ;
   void *usable ;
   apr_size_t reqsize ;
   apr_size_t realsize ;
   char const   *filename ;
   int shmid ;
};
struct apr_allocator_t {
   apr_uint32_t max_index ;
   apr_uint32_t max_free_index ;
   apr_uint32_t current_free_index ;
   apr_thread_mutex_t *mutex ;
   apr_pool_t *owner ;
   apr_memnode_t *free[20] ;
};
struct cleanup_t;
typedef struct cleanup_t cleanup_t;
struct process_chain {
   apr_proc_t *pid ;
   apr_kill_conditions_e kill_how ;
   struct process_chain *next ;
};
struct apr_pool_t {
   apr_pool_t *parent ;
   apr_pool_t *child ;
   apr_pool_t *sibling ;
   apr_pool_t **ref ;
   cleanup_t *cleanups ;
   apr_allocator_t *allocator ;
   struct process_chain *subprocesses ;
   int (*abort_fn)(int retcode ) ;
   apr_hash_t *user_data ;
   char const   *tag ;
   apr_memnode_t *active ;
   apr_memnode_t *self ;
   char *self_first_avail ;
};
struct psprintf_data {
   apr_vformatter_buff_t vbuff ;
   apr_memnode_t *node ;
   apr_pool_t *pool ;
   apr_byte_t got_a_new_node ;
   apr_memnode_t *free ;
};
struct cleanup_t {
   struct cleanup_t *next ;
   void const   *data ;
   apr_status_t (*plain_cleanup_fn)(void *data ) ;
   apr_status_t (*child_cleanup_fn)(void *data ) ;
};
typedef unsigned long nfds_t;
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
struct apr_pollset_t {
   apr_uint32_t nelts ;
   apr_uint32_t nalloc ;
   struct pollfd *pollset ;
   apr_pollfd_t *query_set ;
   apr_pollfd_t *result_set ;
   apr_pool_t *pool ;
};
struct apr_dso_handle_t {
   apr_pool_t *pool ;
   void *handle ;
   char const   *errormsg ;
};
#pragma merger(0,"/tmp/cil-Fs5tByA2.i","-g -pthread")
struct module_struct core_module ;
struct module_struct access_module ;
struct module_struct auth_module ;
struct module_struct include_module ;
struct module_struct log_config_module ;
struct module_struct env_module ;
struct module_struct setenvif_module ;
struct module_struct mpm_prefork_module ;
struct module_struct http_module ;
struct module_struct mime_module ;
struct module_struct status_module ;
struct module_struct autoindex_module ;
struct module_struct asis_module ;
struct module_struct cgi_module ;
struct module_struct negotiation_module ;
struct module_struct dir_module ;
struct module_struct imap_module ;
struct module_struct actions_module ;
struct module_struct userdir_module ;
struct module_struct alias_module ;
struct module_struct so_module ;
module *ap_prelinked_modules[22]  = 
  {      & core_module,      & access_module,      & auth_module,      & include_module, 
        & log_config_module,      & env_module,      & setenvif_module,      & mpm_prefork_module, 
        & http_module,      & mime_module,      & status_module,      & autoindex_module, 
        & asis_module,      & cgi_module,      & negotiation_module,      & dir_module, 
        & imap_module,      & actions_module,      & userdir_module,      & alias_module, 
        & so_module,      (module *)((void *)0)};
module *ap_preloaded_modules[22]  = 
  {      & core_module,      & access_module,      & auth_module,      & include_module, 
        & log_config_module,      & env_module,      & setenvif_module,      & mpm_prefork_module, 
        & http_module,      & mime_module,      & status_module,      & autoindex_module, 
        & asis_module,      & cgi_module,      & negotiation_module,      & dir_module, 
        & imap_module,      & actions_module,      & userdir_module,      & alias_module, 
        & so_module,      (module *)((void *)0)};
#pragma merger(0,"/tmp/cil-Qh2uTZ0N.i","-g -pthread")
char *apr_strerror(apr_status_t statcode , char *buf , apr_size_t bufsize ) ;
extern void *memset(void *__s , int __c , size_t __n ) ;
extern char *strchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
extern size_t strlen(char const   *__s )  __attribute__((__pure__)) ;
extern int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
extern int strncasecmp(char const   *__s1 , char const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
void *apr_palloc(apr_pool_t *pool , apr_size_t size ) ;
char *apr_pstrdup(apr_pool_t *a , char const   *s ) ;
apr_status_t apr_ipsubnet_create(apr_ipsubnet_t **ipsub , char const   *ipstr , char const   *mask_or_numbits ,
                                 apr_pool_t *p ) ;
int apr_ipsubnet_test(apr_ipsubnet_t *ipsub , apr_sockaddr_t *sa ) ;
apr_array_header_t *apr_array_make(apr_pool_t *p , int nelts , int elt_size ) ;
void *apr_array_push(apr_array_header_t *arr ) ;
char const   *apr_table_get(apr_table_t const   *t , char const   *key ) ;
char const   *ap_get_remote_host(conn_rec *conn , void *dir_config , int type , int *str_is_ip ) ;
int ap_satisfies(request_rec *r ) ;
void ( /* format attribute */  ap_log_rerror)(char const   *file , int line , int level ,
                                              apr_status_t status , request_rec const   *r ,
                                              char const   *fmt  , ...) ;
int ap_some_auth_required(request_rec *r ) ;
void ap_hook_access_checker(ap_HOOK_access_checker_t *pf , char const   * const  *aszPre___1 ,
                            char const   * const  *aszSucc___2 , int nOrder ) ;
static void *create_access_dir_config(apr_pool_t *p , char *dummy ) 
{ int i ;
  access_dir_conf *conf ;
  void *tmp ;
  access_dir_conf *tmp___0 ;

  {
  tmp = apr_palloc(p, sizeof(access_dir_conf ));
  tmp___0 = (access_dir_conf *)memset(tmp, 0, sizeof(access_dir_conf ));
  conf = tmp___0;
  i = 0;
  while (i < 64) {
    conf->order[i] = 0;
    i ++;
  }
  conf->allows = apr_array_make(p, 1, (int )sizeof(allowdeny ));
  conf->denys = apr_array_make(p, 1, (int )sizeof(allowdeny ));
  return ((void *)conf);
}
}
static char const   *order(cmd_parms *cmd , void *dv , char const   *arg ) 
{ access_dir_conf *d ;
  int i ;
  int o ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  d = (access_dir_conf *)dv;
  tmp___1 = strcasecmp(arg, "allow,deny");
  if (tmp___1) {
    tmp___0 = strcasecmp(arg, "deny,allow");
    if (tmp___0) {
      tmp = strcasecmp(arg, "mutual-failure");
      if (tmp) {
        return ("unknown order");
      } else {
        o = 2;
      }
    } else {
      o = 0;
    }
  } else {
    o = 1;
  }
  i = 0;
  while (i < 64) {
    if (cmd->limited & (1LL << i)) {
      d->order[i] = o;
    }
    i ++;
  }
  return ((char const   *)((void *)0));
}
}
static char const   *allow_cmd(cmd_parms *cmd , void *dv , char const   *from , char const   *where_c ) 
{ access_dir_conf *d ;
  allowdeny *a ;
  char *where ;
  char *tmp ;
  char *s ;
  char msgbuf[120] ;
  apr_status_t rv ;
  int tmp___0 ;
  apr_array_header_t *tmp___1 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  d = (access_dir_conf *)dv;
  tmp = apr_pstrdup(cmd->pool, where_c);
  where = tmp;
  tmp___0 = strcasecmp(from, "from");
  if (tmp___0) {
    return ("allow and deny must be followed by \'from\'");
  }
  if (cmd->info) {
    tmp___1 = d->allows;
  } else {
    tmp___1 = d->denys;
  }
  a = (allowdeny *)apr_array_push(tmp___1);
  a->x.from = where;
  a->limited = cmd->limited;
  tmp___7 = strncasecmp((char const   *)where, "env=", 4U);
  if (tmp___7) {
    tmp___6 = strcasecmp((char const   *)where, "all");
    if (tmp___6) {
      s = strchr((char const   *)where, '/');
      if (s) {
        tmp___3 = s;
        s ++;
        (*tmp___3) = (char )'\000';
        rv = apr_ipsubnet_create(& a->x.ip, (char const   *)where, (char const   *)s,
                                 cmd->pool);
        if (rv == 22) {
          return ("An IP address was expected");
        } else {
          if (rv != 0) {
            apr_strerror(rv, msgbuf, sizeof(msgbuf));
            tmp___4 = apr_pstrdup(cmd->pool, (char const   *)(msgbuf));
            return (tmp___4);
          }
        }
        a->type = 2;
      } else {
        rv = apr_ipsubnet_create(& a->x.ip, (char const   *)where, (char const   *)((void *)0),
                                 cmd->pool);
        if (rv == 22) {
          a->type = 3;
        } else {
          if (rv != 0) {
            apr_strerror(rv, msgbuf, sizeof(msgbuf));
            tmp___5 = apr_pstrdup(cmd->pool, (char const   *)(msgbuf));
            return (tmp___5);
          }
          a->type = 2;
        }
      }
    } else {
      a->type = 1;
    }
  } else {
    a->type = 0;
    a->x.from += 4;
  }
  return ((char const   *)((void *)0));
}
}
static char its_an_allow  ;
static command_rec const   access_cmds[4]  = {      {"order", {& order}, (void *)0, 1, 1, "\'allow,deny\', \'deny,allow\', or \'mutual-failure\'"}, 
        {"allow",
      {& allow_cmd}, (void *)(& its_an_allow), 1, 4, "\'from\' followed by hostnames or IP-address wildcards"}, 
        {"deny",
      {& allow_cmd}, (void *)0, 1, 4, "\'from\' followed by hostnames or IP-address wildcards"}, 
        {(char const   *)((void *)0),
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))0}, (void *)0,
      0, 0, (char const   *)0}};
static int in_domain(char const   *domain , char const   *what ) 
{ int dl ;
  int tmp ;
  int wl ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = (int )strlen(domain);
  dl = tmp;
  tmp___0 = (int )strlen(what);
  wl = tmp___0;
  if (wl - dl >= 0) {
    tmp___1 = strcasecmp(domain, what + (wl - dl));
    if (tmp___1 != 0) {
      return (0);
    }
    if (wl == dl) {
      return (1);
    } else {
      if ((int const   )(*(domain + 0)) == 46) {
        goto _L;
      } else {
        if ((int const   )(*(what + ((wl - dl) - 1))) == 46) {
          _L: /* CIL Label */ 
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      }
      return (tmp___2);
    }
  } else {
    return (0);
  }
}
}
static int find_allowdeny(request_rec *r , apr_array_header_t *a , int method ) 
{ allowdeny *ap ;
  apr_int64_t mmask ;
  int i ;
  int gothost ;
  char const   *remotehost ;
  char const   *tmp ;
  int tmp___0 ;
  int remotehost_is_ip ;
  int tmp___1 ;

  {
  ap = (allowdeny *)a->elts;
  mmask = 1LL << method;
  gothost = 0;
  remotehost = (char const   *)((void *)0);
  i = 0;
  while (i < a->nelts) {
    if (! (mmask & (ap + i)->limited)) {
      goto __Cont;
    }
    switch ((int )(ap + i)->type) {
    case 0: 
    tmp = apr_table_get((apr_table_t const   *)r->subprocess_env, (char const   *)(ap +
                                                                                   i)->x.from);
    if (tmp) {
      return (1);
    }
    break;
    case 1: ;
    return (1);
    case 2: 
    tmp___0 = apr_ipsubnet_test((ap + i)->x.ip, (r->connection)->remote_addr);
    if (tmp___0) {
      return (1);
    }
    break;
    case 3: ;
    if (! gothost) {
      remotehost = ap_get_remote_host(r->connection, (void *)r->per_dir_config, 3,
                                      & remotehost_is_ip);
      if ((unsigned int )remotehost == (unsigned int )((void *)0)) {
        goto _L;
      } else {
        if (remotehost_is_ip) {
          _L: /* CIL Label */ 
          gothost = 1;
        } else {
          gothost = 2;
        }
      }
    }
    if (gothost == 2) {
      tmp___1 = in_domain((char const   *)(ap + i)->x.from, remotehost);
      if (tmp___1) {
        return (1);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
    break;
    case 4: ;
    break;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return (0);
}
}
static int check_dir_access(request_rec *r ) 
{ int method ;
  int ret ;
  access_dir_conf *a ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  method = r->method_number;
  ret = 0;
  a = (access_dir_conf *)(*((void **)r->per_dir_config + access_module.module_index));
  if (a->order[method] == 1) {
    ret = 403;
    tmp = find_allowdeny(r, a->allows, method);
    if (tmp) {
      ret = 0;
    }
    tmp___0 = find_allowdeny(r, a->denys, method);
    if (tmp___0) {
      ret = 403;
    }
  } else {
    if (a->order[method] == 0) {
      tmp___1 = find_allowdeny(r, a->denys, method);
      if (tmp___1) {
        ret = 403;
      }
      tmp___2 = find_allowdeny(r, a->allows, method);
      if (tmp___2) {
        ret = 0;
      }
    } else {
      tmp___3 = find_allowdeny(r, a->allows, method);
      if (tmp___3) {
        tmp___4 = find_allowdeny(r, a->denys, method);
        if (tmp___4) {
          goto _L;
        } else {
          ret = 0;
        }
      } else {
        _L: /* CIL Label */ 
        ret = 403;
      }
    }
  }
  if (ret == 403) {
    tmp___5 = ap_satisfies(r);
    if (tmp___5 != 1) {
      goto _L___1;
    } else {
      tmp___6 = ap_some_auth_required(r);
      if (tmp___6) {
        goto _L___0;
      } else {
        _L___1: /* CIL Label */ 
        ap_log_rerror("mod_access.c", 324, 3, 0, (request_rec const   *)r, "client denied by server configuration: %s",
                      r->filename);
      }
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
  return (ret);
}
}
static void register_hooks(apr_pool_t *p ) 
{ 

  {
  ap_hook_access_checker(& check_dir_access, (char const   * const  *)((void *)0),
                         (char const   * const  *)((void *)0), 10);
  return;
}
}
struct module_struct access_module  = 
     {20020903, 0, -1, "mod_access.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, (void (*)(process_rec *process ))((void *)0), & create_access_dir_config,
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), (void *(*)(apr_pool_t *p ,
                                                                                          server_rec *s ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), access_cmds,
    & register_hooks};
#pragma merger(0,"/tmp/cil-nSqSGQjB.i","-g -pthread")
extern int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
apr_status_t apr_pool_create_ex(apr_pool_t **newpool , apr_pool_t *parent , int (*abort_fn)(int retcode ) ,
                                apr_allocator_t *allocator ) ;
void apr_pool_clear(apr_pool_t *pool ) ;
void apr_pool_destroy(apr_pool_t *pool ) ;
char *apr_pstrcat(apr_pool_t *a  , ...) ;
apr_status_t apr_password_validate(char const   *passwd , char const   *hash ) ;
apr_table_t *apr_table_make(apr_pool_t *p , int nelts ) ;
void apr_table_setn(apr_table_t *t , char const   *key , char const   *val ) ;
char *ap_getword(apr_pool_t *atrans , char const   **line , char stop ) ;
char *ap_getword_white(apr_pool_t *atrans , char const   **line ) ;
char *ap_getword_conf(apr_pool_t *p , char const   **line ) ;
char const   *ap_set_flag_slot(cmd_parms *cmd , void *struct_ptr_v , int arg ) ;
char const   *ap_set_file_slot(cmd_parms *cmd , void *struct_ptr , char const   *arg ) ;
apr_status_t ap_pcfg_openfile(ap_configfile_t **ret_cfg , apr_pool_t *p , char const   *name ) ;
int ap_cfg_getline(char *buf , size_t bufsize , ap_configfile_t *cfp ) ;
int ap_cfg_closefile(ap_configfile_t *cfp ) ;
apr_array_header_t const   *ap_requires(request_rec *r ) ;
void ap_note_basic_auth_failure(request_rec *r ) ;
int ap_get_basic_auth_pw(request_rec *r , char const   **pw ) ;
void ap_hook_check_user_id(ap_HOOK_check_user_id_t *pf , char const   * const  *aszPre___1 ,
                           char const   * const  *aszSucc___2 , int nOrder ) ;
void ap_hook_auth_checker(ap_HOOK_auth_checker_t *pf , char const   * const  *aszPre___1 ,
                          char const   * const  *aszSucc___2 , int nOrder ) ;
static void *create_auth_dir_config(apr_pool_t *p , char *d ) 
{ auth_config_rec *conf ;
  auth_config_rec *tmp ;

  {
  tmp = (auth_config_rec *)apr_palloc(p, sizeof((*conf)));
  conf = tmp;
  conf->auth_pwfile = (char *)((void *)0);
  conf->auth_grpfile = (char *)((void *)0);
  conf->auth_authoritative = 1;
  return ((void *)conf);
}
}
static char const   *set_auth_slot(cmd_parms *cmd , void *offset , char const   *f ,
                                   char const   *t ) 
{ char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  if (t) {
    tmp___0 = strcmp(t, "standard");
    if (tmp___0) {
      tmp = apr_pstrcat(cmd->pool, "Invalid auth file type: ", t, (void *)0);
      return (tmp);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  tmp___1 = ap_set_file_slot(cmd, offset, f);
  return (tmp___1);
}
}
static command_rec const   auth_cmds[4]  = {      {"AuthUserFile", {& set_auth_slot}, (void *)((long )((char *)(& ((auth_config_rec *)((void *)0))->auth_pwfile) -
                                                          (char *)((void *)0))), 8,
      7, "text file containing user IDs and passwords"}, 
        {"AuthGroupFile", {& set_auth_slot}, (void *)((long )((char *)(& ((auth_config_rec *)((void *)0))->auth_grpfile) -
                                                           (char *)((void *)0))),
      8, 7, "text file containing group names and member user IDs"}, 
        {"AuthAuthoritative", {& ap_set_flag_slot}, (void *)((long )((char *)(& ((auth_config_rec *)((void *)0))->auth_authoritative) -
                                                                  (char *)((void *)0))),
      8, 5, "Set to \'no\' to allow access control to be passed along to lower modules if the UserID is not known to this module"}, 
        {(char const   *)((void *)0),
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))0}, (void *)0,
      0, 0, (char const   *)0}};
static char *get_pw(request_rec *r , char *user , char *auth_pwfile ) 
{ ap_configfile_t *f ;
  char l[8192] ;
  char const   *rpw ;
  char const   *w ;
  apr_status_t status ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  status = ap_pcfg_openfile(& f, r->pool, (char const   *)auth_pwfile);
  if (status != 0) {
    ap_log_rerror("mod_auth.c", 138, 3, status, (request_rec const   *)r, "Could not open password file: %s",
                  auth_pwfile);
    return ((char *)((void *)0));
  }
  while (1) {
    tmp___1 = ap_cfg_getline(l, 8192U, f);
    if (tmp___1) {
      break;
    }
    if ((int )l[0] == 35) {
      goto _L;
    } else {
      if (! l[0]) {
        _L: /* CIL Label */ 
        continue;
      }
    }
    rpw = (char const   *)(l);
    w = ap_getword(r->pool, & rpw, (char )':');
    tmp___0 = strcmp((char const   *)user, w);
    if (! tmp___0) {
      ap_cfg_closefile(f);
      tmp = ap_getword(r->pool, & rpw, (char )':');
      return (tmp);
    }
  }
  ap_cfg_closefile(f);
  return ((char *)((void *)0));
}
}
static apr_table_t *groups_for_user(apr_pool_t *p , char *user , char *grpfile ) 
{ ap_configfile_t *f ;
  apr_table_t *grps ;
  apr_table_t *tmp ;
  apr_pool_t *sp ;
  char l[8192] ;
  char const   *group_name ;
  char const   *ll ;
  char const   *w ;
  apr_status_t status ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = apr_table_make(p, 15);
  grps = tmp;
  status = ap_pcfg_openfile(& f, p, (char const   *)grpfile);
  if (status != 0) {
    return ((apr_table_t *)((void *)0));
  }
  apr_pool_create_ex(& sp, p, (int (*)(int retcode ))((void *)0), (apr_allocator_t *)((void *)0));
  while (1) {
    tmp___2 = ap_cfg_getline(l, 8192U, f);
    if (tmp___2) {
      break;
    }
    if ((int )l[0] == 35) {
      goto _L;
    } else {
      if (! l[0]) {
        _L: /* CIL Label */ 
        continue;
      }
    }
    ll = (char const   *)(l);
    apr_pool_clear(sp);
    group_name = ap_getword(sp, & ll, (char )':');
    while ((*(ll + 0))) {
      w = ap_getword_conf(sp, & ll);
      tmp___1 = strcmp(w, (char const   *)user);
      if (! tmp___1) {
        tmp___0 = apr_pstrdup(p, group_name);
        apr_table_setn(grps, tmp___0, "in");
        break;
      }
    }
  }
  ap_cfg_closefile(f);
  apr_pool_destroy(sp);
  return (grps);
}
}
static int authenticate_basic_user(request_rec *r ) 
{ auth_config_rec *conf ;
  char const   *sent_pw ;
  char *real_pw ;
  apr_status_t invalid_pw ;
  int res ;

  {
  conf = (auth_config_rec *)(*((void **)r->per_dir_config + auth_module.module_index));
  res = ap_get_basic_auth_pw(r, & sent_pw);
  if (res) {
    return (res);
  }
  if (! conf->auth_pwfile) {
    return (-1);
  }
  real_pw = get_pw(r, r->user, conf->auth_pwfile);
  if (! real_pw) {
    if (! conf->auth_authoritative) {
      return (-1);
    }
    ap_log_rerror("mod_auth.c", 232, 3, 0, (request_rec const   *)r, "user %s not found: %s",
                  r->user, r->uri);
    ap_note_basic_auth_failure(r);
    return (401);
  }
  invalid_pw = apr_password_validate(sent_pw, (char const   *)real_pw);
  if (invalid_pw != 0) {
    ap_log_rerror("mod_auth.c", 239, 3, 0, (request_rec const   *)r, "user %s: authentication failure for \"%s\": Password Mismatch",
                  r->user, r->uri);
    ap_note_basic_auth_failure(r);
    return (401);
  }
  return (0);
}
}
static int check_user_access(request_rec *r ) 
{ auth_config_rec *conf ;
  char *user ;
  int m ;
  int method_restricted ;
  register int x ;
  char const   *t ;
  char const   *w ;
  apr_table_t *grpstatus ;
  apr_array_header_t const   *reqs_arr ;
  apr_array_header_t const   *tmp ;
  require_line *reqs ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  conf = (auth_config_rec *)(*((void **)r->per_dir_config + auth_module.module_index));
  user = r->user;
  m = r->method_number;
  method_restricted = 0;
  tmp = ap_requires(r);
  reqs_arr = tmp;
  if (! reqs_arr) {
    return (0);
  }
  reqs = (require_line *)reqs_arr->elts;
  if (conf->auth_grpfile) {
    grpstatus = groups_for_user(r->pool, user, conf->auth_grpfile);
  } else {
    grpstatus = (apr_table_t *)((void *)0);
  }
  x = 0;
  while (x < reqs_arr->nelts) {
    if (! ((reqs + x)->method_mask & (1LL << m))) {
      goto __Cont;
    }
    method_restricted = 1;
    t = (char const   *)(reqs + x)->requirement;
    w = ap_getword_white(r->pool, & t);
    tmp___0 = strcmp(w, "valid-user");
    if (! tmp___0) {
      return (0);
    }
    tmp___4 = strcmp(w, "user");
    if (tmp___4) {
      tmp___3 = strcmp(w, "group");
      if (tmp___3) {
        if (conf->auth_authoritative) {
          ap_log_rerror("mod_auth.c", 319, 3, 0, (request_rec const   *)r, "access to %s failed, reason: unknown require directive:\"%s\"",
                        r->uri, (reqs + x)->requirement);
        }
      } else {
        if (! grpstatus) {
          return (-1);
        }
        while ((*(t + 0))) {
          w = ap_getword_conf(r->pool, & t);
          tmp___2 = apr_table_get((apr_table_t const   *)grpstatus, w);
          if (tmp___2) {
            return (0);
          }
        }
      }
    } else {
      while ((*(t + 0))) {
        w = ap_getword_conf(r->pool, & t);
        tmp___1 = strcmp((char const   *)user, w);
        if (! tmp___1) {
          return (0);
        }
      }
    }
    __Cont: /* CIL Label */ 
    x ++;
  }
  if (! method_restricted) {
    return (0);
  }
  if (! conf->auth_authoritative) {
    return (-1);
  }
  ap_log_rerror("mod_auth.c", 333, 3, 0, (request_rec const   *)r, "access to %s failed, reason: user %s not allowed access",
                r->uri, user);
  ap_note_basic_auth_failure(r);
  return (401);
}
}
static void register_hooks___0(apr_pool_t *p ) 
{ 

  {
  ap_hook_check_user_id(& authenticate_basic_user, (char const   * const  *)((void *)0),
                        (char const   * const  *)((void *)0), 10);
  ap_hook_auth_checker(& check_user_access, (char const   * const  *)((void *)0),
                       (char const   * const  *)((void *)0), 10);
  return;
}
}
struct module_struct auth_module  = 
     {20020903, 0, -1, "mod_auth.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, (void (*)(process_rec *process ))((void *)0), & create_auth_dir_config,
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), (void *(*)(apr_pool_t *p ,
                                                                                          server_rec *s ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), auth_cmds,
    & register_hooks___0};
#pragma merger(0,"/tmp/cil-AQHVWdrY.i","-g -pthread")
extern void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                    size_t __n ) ;
extern int strncmp(char const   *__s1 , char const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
extern char *strrchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
char *apr_pstrmemdup(apr_pool_t *a , char const   *s , apr_size_t n ) ;
int ( /* format attribute */  apr_snprintf)(char *buf , apr_size_t len , char const   *format 
                                            , ...) ;
char *apr_strfsize(apr_off_t size , char *buf ) ;
apr_status_t apr_get_username(char **username , apr_uid_t userid , apr_pool_t *p ) ;
apr_status_t apr_stat(apr_finfo_t *finfo , char const   *fname , apr_int32_t wanted ,
                      apr_pool_t *pool ) ;
apr_hash_t *apr_hash_make(apr_pool_t *pool ) ;
void apr_hash_set(apr_hash_t *ht , void const   *key , apr_ssize_t klen , void const   *val ) ;
void *apr_hash_get(apr_hash_t *ht , void const   *key , apr_ssize_t klen ) ;
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern int tolower(int __c ) ;
void apr_dynamic_fn_register(char const   *szName , apr_opt_fn_t *pfn ) ;
apr_opt_fn_t *apr_dynamic_fn_retrieve(char const   *szName ) ;
apr_array_header_t const   *apr_table_elts(apr_table_t const   *t ) ;
void apr_table_unset(apr_table_t *t , char const   *key ) ;
apr_bucket_brigade *apr_brigade_create(apr_pool_t *p , apr_bucket_alloc_t *list ) ;
apr_status_t apr_brigade_cleanup(void *data ) ;
apr_bucket_brigade *apr_brigade_split(apr_bucket_brigade *b , apr_bucket *e ) ;
struct apr_bucket_type_t  const  apr_bucket_type_eos ;
apr_bucket *apr_bucket_flush_create(apr_bucket_alloc_t *list ) ;
apr_bucket *apr_bucket_immortal_create(char const   *buf , apr_size_t length , apr_bucket_alloc_t *list ) ;
apr_bucket *apr_bucket_heap_create(char const   *buf , apr_size_t length , void (*free_func)(void *data ) ,
                                   apr_bucket_alloc_t *list ) ;
apr_bucket *apr_bucket_pool_create(char const   *buf , apr_size_t length , apr_pool_t *pool ,
                                   apr_bucket_alloc_t *list ) ;
extern int atoi(char const   *__nptr )  __attribute__((__pure__)) ;
char *ap_ht_time(apr_pool_t *p , apr_time_t t , char const   *fmt , int gmt ) ;
int ap_unescape_url(char *url ) ;
void ap_getparents(char *name ) ;
char *ap_os_escape_path(apr_pool_t *p , char const   *path , int partial ) ;
char *ap_escape_html(apr_pool_t *p , char const   *s ) ;
char *ap_escape_shell_cmd(apr_pool_t *p , char const   *str ) ;
regex_t *ap_pregcomp(apr_pool_t *p , char const   *pattern , int cflags ) ;
void ap_pregfree(apr_pool_t *p , regex_t *reg ) ;
int ap_regexec(regex_t *preg , char const   *string , size_t nmatch , regmatch_t *pmatch ,
               int eflags ) ;
apr_status_t ap_pass_brigade(ap_filter_t *next , apr_bucket_brigade *bb ) ;
ap_filter_rec_t *ap_register_output_filter(char const   *name , apr_status_t (*filter_func)(ap_filter_t *f ,
                                                                                            apr_bucket_brigade *b ) ,
                                           int (*filter_init)(ap_filter_t *f ) , ap_filter_type ftype ) ;
ap_filter_t *ap_add_output_filter(char const   *name , void *ctx , request_rec *r ,
                                  conn_rec *c ) ;
apr_status_t ap_save_brigade(ap_filter_t *f , apr_bucket_brigade **saveto , apr_bucket_brigade **b ,
                             apr_pool_t *p ) ;
void ap_hook_post_config(ap_HOOK_post_config_t *pf , char const   * const  *aszPre___1 ,
                         char const   * const  *aszSucc___2 , int nOrder ) ;
int ap_allow_options(request_rec *r ) ;
request_rec *ap_sub_req_lookup_uri(char const   *new_file , request_rec const   *r ,
                                   ap_filter_t *next_filter ) ;
request_rec *ap_sub_req_lookup_file(char const   *new_file , request_rec const   *r ,
                                    ap_filter_t *next_filter ) ;
int ap_run_sub_req(request_rec *r ) ;
void ap_destroy_sub_req(request_rec *r ) ;
void ap_update_mtime(request_rec *r , apr_time_t dependency_mtime ) ;
void ap_hook_fixups(ap_HOOK_fixups_t *pf , char const   * const  *aszPre___1 , char const   * const  *aszSucc___2 ,
                    int nOrder ) ;
void ap_set_last_modified(request_rec *r ) ;
void ap_set_content_type(request_rec *r , char const   *ct ) ;
void ap_add_cgi_vars(request_rec *r ) ;
void ap_add_common_vars(request_rec *r ) ;
static apr_hash_t *include_hash  ;
static apr_OFN_ap_register_include_handler_t *ssi_pfn_register  ;
static char const   lazy_eval_sentinel  ;
static void add_include_vars(request_rec *r , char *timefmt ) 
{ apr_table_t *e ;
  char *t ;
  char *arg_copy ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  e = r->subprocess_env;
  apr_table_setn(e, "DATE_LOCAL", & lazy_eval_sentinel);
  apr_table_setn(e, "DATE_GMT", & lazy_eval_sentinel);
  apr_table_setn(e, "LAST_MODIFIED", & lazy_eval_sentinel);
  apr_table_setn(e, "DOCUMENT_URI", (char const   *)r->uri);
  if (r->path_info) {
    if ((*(r->path_info))) {
      apr_table_setn(e, "DOCUMENT_PATH_INFO", (char const   *)r->path_info);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  apr_table_setn(e, "USER_NAME", & lazy_eval_sentinel);
  t = strrchr((char const   *)r->filename, '/');
  if (t) {
    t ++;
    apr_table_setn(e, "DOCUMENT_NAME", (char const   *)t);
  } else {
    apr_table_setn(e, "DOCUMENT_NAME", (char const   *)r->uri);
  }
  if (r->args) {
    tmp = apr_pstrdup(r->pool, (char const   *)r->args);
    arg_copy = tmp;
    ap_unescape_url(arg_copy);
    tmp___0 = ap_escape_shell_cmd(r->pool, (char const   *)arg_copy);
    apr_table_setn(e, "QUERY_STRING_UNESCAPED", tmp___0);
  }
  return;
}
}
static char const   *add_include_vars_lazy(request_rec *r , char const   *var ) 
{ char *val ;
  include_dir_config *conf ;
  include_dir_config *conf___0 ;
  include_dir_config *conf___1 ;
  apr_status_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___3 = strcasecmp(var, "DATE_LOCAL");
  if (tmp___3) {
    tmp___2 = strcasecmp(var, "DATE_GMT");
    if (tmp___2) {
      tmp___1 = strcasecmp(var, "LAST_MODIFIED");
      if (tmp___1) {
        tmp___0 = strcasecmp(var, "USER_NAME");
        if (tmp___0) {
          val = (char *)((void *)0);
        } else {
          tmp = apr_get_username(& val, r->finfo.user, r->pool);
          if (tmp != 0) {
            val = (char *)"<unknown>";
          }
        }
      } else {
        conf___1 = (include_dir_config *)(*((void **)r->per_dir_config + include_module.module_index));
        val = ap_ht_time(r->pool, r->finfo.mtime, (char const   *)conf___1->default_time_fmt,
                         0);
      }
    } else {
      conf___0 = (include_dir_config *)(*((void **)r->per_dir_config + include_module.module_index));
      val = ap_ht_time(r->pool, r->request_time, (char const   *)conf___0->default_time_fmt,
                       1);
    }
  } else {
    conf = (include_dir_config *)(*((void **)r->per_dir_config + include_module.module_index));
    val = ap_ht_time(r->pool, r->request_time, (char const   *)conf->default_time_fmt,
                     0);
  }
  if (val) {
    apr_table_setn(r->subprocess_env, var, (char const   *)val);
  }
  return ((char const   *)val);
}
}
static char const   *get_include_var(request_rec *r , include_ctx_t *ctx , char const   *var ) 
{ char const   *val ;
  int idx ;
  int tmp ;
  apr_size_t len ;
  unsigned short const   **tmp___0 ;

  {
  tmp___0 = __ctype_b_loc();
  if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*var)))) & 2048) {
    if (! (*(var + 1))) {
      if (! ctx->re_result) {
        goto _L___0;
      } else {
        if (! ctx->re_string) {
          _L___0: /* CIL Label */ 
          return ((char const   *)((void *)0));
        } else {
          tmp = atoi(var);
          idx = tmp;
          len = (apr_size_t )((*(ctx->re_result))[idx].rm_eo - (*(ctx->re_result))[idx].rm_so);
          if ((*(ctx->re_result))[idx].rm_so < 0) {
            goto _L;
          } else {
            if ((*(ctx->re_result))[idx].rm_eo < 0) {
              _L: /* CIL Label */ 
              return ((char const   *)((void *)0));
            }
          }
          val = apr_pstrmemdup(r->pool, (char const   *)(ctx->re_string + (*(ctx->re_result))[idx].rm_so),
                               len);
        }
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    val = apr_table_get((apr_table_t const   *)r->subprocess_env, var);
    if ((unsigned int )val == (unsigned int )(& lazy_eval_sentinel)) {
      val = add_include_vars_lazy(r, var);
    }
  }
  return (val);
}
}
static void bndm_compile(bndm_t *t , char const   *n , apr_size_t nl ) 
{ unsigned int x ;
  char const   *ne ;
  char const   *tmp ;

  {
  ne = n + nl;
  memset((void *)(t->T), 0, sizeof(unsigned int ) * 256U);
  x = 1U;
  while ((unsigned int )n < (unsigned int )ne) {
    tmp = n;
    n ++;
    t->T[(unsigned char )(*tmp)] |= x;
    x <<= 1;
  }
  t->x = x - 1U;
  return;
}
}
static apr_size_t bndm(char const   *n , apr_size_t nl , char const   *h , apr_size_t hl ,
                       bndm_t *t ) 
{ char const   *skip ;
  char const   *he ;
  char const   *p ;
  char const   *pi ;
  unsigned int *T ;
  unsigned int x ;
  unsigned int d ;
  char const   *tmp ;

  {
  he = h + hl;
  T = t->T;
  x = t->x;
  pi = h - 1;
  p = pi + nl;
  while ((unsigned int )p < (unsigned int )he) {
    skip = p;
    d = x;
    while (1) {
      tmp = p;
      p --;
      d &= (*(T + (unsigned char )(*tmp)));
      if (! d) {
        break;
      }
      if (d & 1U) {
        if ((unsigned int )p != (unsigned int )pi) {
          skip = p;
        } else {
          return ((unsigned int )((p - h) + 1));
        }
      }
      d >>= 1;
      if (! d) {
        break;
      }
    }
    pi = skip;
    p = pi + nl;
  }
  return (hl);
}
}
static apr_bucket *found_start_sequence(apr_bucket *dptr , include_ctx_t *ctx , apr_size_t tagStart ,
                                        apr_size_t len ) 
{ apr_bucket *tmp_bkt ;

  {
  ctx->state = 2;
  ctx->tag_length = 0U;
  ctx->parse_pos = 0U;
  if (tagStart < len) {
    ctx->tag_start_bucket = dptr;
    ctx->tag_start_index = tagStart;
  } else {
    ctx->tag_start_bucket = dptr->link.next;
    ctx->tag_start_index = 0U;
  }
  if (ctx->head_start_index > 0U) {
    ((*(((ctx->head_start_bucket)->type)->split)))(ctx->head_start_bucket, ctx->head_start_index);
    tmp_bkt = (ctx->head_start_bucket)->link.next;
    if (tagStart < len) {
      if ((unsigned int )dptr == (unsigned int )ctx->head_start_bucket) {
        ctx->tag_start_bucket = tmp_bkt;
        ctx->tag_start_index = tagStart - ctx->head_start_index;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
    ctx->head_start_bucket = tmp_bkt;
    ctx->head_start_index = 0U;
  }
  return (ctx->head_start_bucket);
}
}
static apr_bucket *find_start_sequence(apr_bucket *dptr , include_ctx_t *ctx , apr_bucket_brigade *bb ,
                                       int *do_cleanup ) 
{ apr_size_t len ;
  char const   *c ;
  char const   *buf ;
  char const   *str ;
  apr_size_t slen ;
  apr_size_t pos ;
  apr_status_t rv ;
  int read_done ;
  apr_bucket *start_bucket ;
  apr_size_t tmpLen ;
  apr_bucket *tmp ;
  apr_bucket *tmp___0 ;

  {
  str = (char const   *)ctx->start_seq;
  slen = (apr_size_t )ctx->start_seq_len;
  (*do_cleanup) = 0;
  while (1) {
    rv = 0;
    read_done = 0;
    if ((unsigned int )dptr->type == (unsigned int )(& apr_bucket_type_eos)) {
      break;
    }
    if (ctx->bytes_parsed >= 8000) {
      ctx->output_now = 1;
    } else {
      if (ctx->bytes_parsed > 0) {
        rv = ((*((dptr->type)->read)))(dptr, & buf, & len, 1);
        read_done = 1;
        if (rv == 11) {
          ctx->output_now = 1;
        }
      }
    }
    if (ctx->output_now) {
      if (ctx->head_start_index > 0U) {
        start_bucket = ctx->head_start_bucket;
        ((*((start_bucket->type)->split)))(start_bucket, ctx->head_start_index);
        start_bucket = start_bucket->link.next;
        ctx->head_start_index = 0U;
        ctx->head_start_bucket = start_bucket;
        ctx->parse_pos = 0U;
        ctx->state = 0;
      } else {
        start_bucket = dptr;
      }
      return (start_bucket);
    }
    if (! read_done) {
      rv = ((*((dptr->type)->read)))(dptr, & buf, & len, 0);
    }
    if (! (rv == 0)) {
      ctx->status = rv;
      return ((apr_bucket *)((void *)0));
    }
    if (len == 0U) {
      break;
    }
    c = buf;
    if ((int )ctx->state == 1) {
      if (len < slen - 1U) {
        tmpLen = len;
      } else {
        tmpLen = slen - 1U;
      }
      while (1) {
        if ((unsigned int )c < (unsigned int )(buf + tmpLen)) {
          if (! ((int const   )(*c) == (int const   )(*(str + ctx->parse_pos)))) {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          break;
        }
        c ++;
        ctx->parse_pos ++;
      }
      if ((int const   )(*(str + ctx->parse_pos)) == 0) {
        ctx->bytes_parsed += c - buf;
        tmp = found_start_sequence(dptr, ctx, (unsigned int )(c - buf), len);
        return (tmp);
      } else {
        if ((unsigned int )c == (unsigned int )(buf + tmpLen)) {
          dptr = dptr->link.next;
          goto __Cont;
        }
      }
      while (1) {
        if (! ((unsigned int )(ctx->ssi_tag_brigade)->list.next == (unsigned int )((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                                                         (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                                 (char *)((void *)0)))))) {
          while (1) {
            ((ctx->ssi_tag_brigade)->list.next)->link.prev = (struct apr_bucket *)((char *)(& bb->list) -
                                                                                   (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                           (char *)((void *)0)));
            ((ctx->ssi_tag_brigade)->list.prev)->link.next = ((struct apr_bucket *)((char *)(& bb->list) -
                                                                                    (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                            (char *)((void *)0))))->link.next;
            (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                   (char *)((void *)0))))->link.next)->link.prev = (ctx->ssi_tag_brigade)->list.prev;
            ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                  (char *)((void *)0))))->link.next = (ctx->ssi_tag_brigade)->list.next;
            break;
          }
          while (1) {
            (ctx->ssi_tag_brigade)->list.next = (struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                      (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                              (char *)((void *)0)));
            (ctx->ssi_tag_brigade)->list.prev = (struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                      (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                              (char *)((void *)0)));
            break;
          }
        }
        break;
      }
      ctx->state = 0;
      ctx->head_start_bucket = (apr_bucket *)((void *)0);
      ctx->head_start_index = 0U;
    }
    if (len) {
      pos = bndm(str, slen, c, len, ctx->start_seq_pat);
      if (pos != len) {
        ctx->head_start_bucket = dptr;
        ctx->head_start_index = pos;
        ctx->bytes_parsed = (int )((apr_size_t )ctx->bytes_parsed + (pos + slen));
        tmp___0 = found_start_sequence(dptr, ctx, pos + slen, len);
        return (tmp___0);
      }
    }
    if (len > slen) {
      ctx->bytes_parsed = (int )((apr_size_t )ctx->bytes_parsed + (len - slen));
      c = (buf + len) - slen;
    } else {
      c = buf;
    }
    ctx->parse_pos = 0U;
    while ((unsigned int )c < (unsigned int )(buf + len)) {
      if ((int const   )(*c) == (int const   )(*(str + ctx->parse_pos))) {
        if ((int )ctx->state == 0) {
          ctx->state = 1;
          ctx->head_start_bucket = dptr;
          ctx->head_start_index = (unsigned int )(c - buf);
        }
        ctx->parse_pos ++;
        c ++;
        ctx->bytes_parsed ++;
      } else {
        if (ctx->parse_pos != 0U) {
          (*do_cleanup) = 1;
          ctx->parse_pos = 0U;
          ctx->state = 0;
          ctx->head_start_bucket = (apr_bucket *)((void *)0);
          ctx->head_start_index = 0U;
        } else {
          c ++;
          ctx->bytes_parsed ++;
        }
      }
    }
    dptr = dptr->link.next;
    __Cont: /* CIL Label */ 
    if (! ((unsigned int )dptr != (unsigned int )((struct apr_bucket *)((char *)(& bb->list) -
                                                                        (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                (char *)((void *)0)))))) {
      break;
    }
  }
  return ((apr_bucket *)((void *)0));
}
}
static apr_bucket *find_end_sequence(apr_bucket *dptr , include_ctx_t *ctx , apr_bucket_brigade *bb ) 
{ apr_size_t len ;
  char const   *c ;
  char const   *buf ;
  char const   *str ;
  char const   *start ;
  apr_status_t rv ;
  int read_done ;
  apr_bucket *tmp_buck ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___3 ;

  {
  str = (char const   *)ctx->end_seq;
  while (1) {
    rv = 0;
    read_done = 0;
    if ((unsigned int )dptr->type == (unsigned int )(& apr_bucket_type_eos)) {
      break;
    }
    if (ctx->bytes_parsed >= 8000) {
      ctx->output_now = 1;
    } else {
      if (ctx->bytes_parsed > 0) {
        rv = ((*((dptr->type)->read)))(dptr, & buf, & len, 1);
        read_done = 1;
        if (rv == 11) {
          ctx->output_now = 1;
        }
      }
    }
    if (ctx->output_now) {
      if ((int )ctx->state == 2) {
        ctx->directive_length = 0U;
        ctx->tag_length = 0U;
      }
      return (dptr);
    }
    if (! read_done) {
      rv = ((*((dptr->type)->read)))(dptr, & buf, & len, 0);
    }
    if (! (rv == 0)) {
      ctx->status = rv;
      return ((apr_bucket *)((void *)0));
    }
    if (len == 0U) {
      break;
    }
    if ((unsigned int )dptr == (unsigned int )ctx->tag_start_bucket) {
      c = buf + ctx->tag_start_index;
    } else {
      c = buf;
    }
    start = c;
    while ((unsigned int )c < (unsigned int )(buf + len)) {
      if ((int const   )(*c) == (int const   )(*(str + ctx->parse_pos))) {
        if ((int )ctx->state != 4) {
          ctx->state = 4;
          ctx->tail_start_bucket = dptr;
          ctx->tail_start_index = (unsigned int )(c - buf);
        }
        ctx->parse_pos ++;
        if ((int const   )(*(str + ctx->parse_pos)) == 0) {
          tmp_buck = dptr;
          c ++;
          ctx->bytes_parsed += c - start;
          ctx->state = 5;
          ((*((dptr->type)->split)))(dptr, (unsigned int )(c - buf));
          tmp_buck = dptr->link.next;
          return (tmp_buck);
        }
      } else {
        if ((int )ctx->state == 2) {
          if (ctx->tag_length == 0U) {
            tmp___1 = __ctype_b_loc();
            if (! ((int const   )(*((*tmp___1) + (int )((unsigned char )(*c)))) &
                   8192)) {
              tmp = c;
              ctx->tag_start_bucket = dptr;
              ctx->tag_start_index = (unsigned int )(c - buf);
              while (1) {
                c ++;
                if ((unsigned int )c < (unsigned int )(buf + len)) {
                  tmp___0 = __ctype_b_loc();
                  if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*c)))) &
                      8192) {
                    goto _L___0;
                  } else {
                    if (! ((int const   )(*c) != (int const   )(*str))) {
                      goto _L___0;
                    }
                  }
                } else {
                  _L___0: /* CIL Label */ 
                  break;
                }
              }
              ctx->directive_length = (unsigned int )(c - tmp);
              ctx->tag_length = ctx->directive_length;
              continue;
            }
          } else {
            tmp___2 = __ctype_b_loc();
            if ((int const   )(*((*tmp___2) + (int )((unsigned char )(*c)))) & 8192) {
              ctx->state = 3;
            } else {
              ctx->directive_length ++;
            }
            ctx->tag_length ++;
          }
        } else {
          if ((int )ctx->state == 3) {
            tmp___3 = c;
            while (1) {
              c ++;
              if ((unsigned int )c < (unsigned int )(buf + len)) {
                if (! ((int const   )(*c) != (int const   )(*str))) {
                  goto _L___1;
                }
              } else {
                _L___1: /* CIL Label */ 
                break;
              }
            }
            ctx->tag_length += (apr_size_t )(c - tmp___3);
            continue;
          } else {
            if (ctx->parse_pos != 0U) {
              ctx->tag_length += ctx->parse_pos;
              if ((int const   )(*c) == (int const   )(*(str + 0))) {
                ctx->state = 4;
                ctx->tail_start_bucket = dptr;
                ctx->tail_start_index = (unsigned int )(c - buf);
                ctx->parse_pos = 1U;
              } else {
                ctx->tag_length ++;
                if (ctx->tag_length > ctx->directive_length) {
                  ctx->state = 3;
                } else {
                  ctx->state = 2;
                  ctx->directive_length += ctx->parse_pos;
                }
                ctx->tail_start_bucket = (apr_bucket *)((void *)0);
                ctx->tail_start_index = 0U;
                ctx->parse_pos = 0U;
              }
            }
          }
        }
      }
      c ++;
    }
    ctx->bytes_parsed += c - start;
    dptr = dptr->link.next;
    if (! ((unsigned int )dptr != (unsigned int )((struct apr_bucket *)((char *)(& bb->list) -
                                                                        (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                (char *)((void *)0)))))) {
      break;
    }
  }
  return ((apr_bucket *)((void *)0));
}
}
static apr_status_t get_combined_directive(include_ctx_t *ctx , request_rec *r , apr_bucket_brigade *bb ,
                                           char *tmp_buf , apr_size_t tmp_buf_size ) 
{ int done ;
  apr_bucket *dptr ;
  char const   *tmp_from ;
  apr_size_t tmp_from_len ;
  void *tmp ;

  {
  done = 0;
  if (ctx->tag_length > tmp_buf_size - 1U) {
    tmp = apr_palloc(r->pool, ctx->tag_length + 1U);
    ctx->combined_tag = (char *)memset(tmp, 0, ctx->tag_length + 1U);
    if ((unsigned int )ctx->combined_tag == (unsigned int )((void *)0)) {
      return (12);
    }
  } else {
    ctx->combined_tag = tmp_buf;
  }
  dptr = ctx->tag_start_bucket;
  ((*((dptr->type)->read)))(dptr, & tmp_from, & tmp_from_len, (enum __anonenum_apr_read_type_e_60 )0);
  if ((unsigned int )dptr == (unsigned int )ctx->tail_start_bucket) {
    tmp_from_len -= tmp_from_len - ctx->tail_start_index;
  }
  tmp_from = tmp_from + ctx->tag_start_index;
  tmp_from_len -= ctx->tag_start_index;
  ctx->curr_tag_pos = ctx->combined_tag;
  while (1) {
    memcpy((void * __restrict  )ctx->curr_tag_pos, (void const   * __restrict  )tmp_from,
           tmp_from_len);
    ctx->curr_tag_pos += tmp_from_len;
    if ((unsigned int )dptr == (unsigned int )ctx->tail_start_bucket) {
      done = 1;
    } else {
      dptr = dptr->link.next;
      ((*((dptr->type)->read)))(dptr, & tmp_from, & tmp_from_len, (enum __anonenum_apr_read_type_e_60 )0);
      if ((unsigned int )dptr == (unsigned int )ctx->tail_start_bucket) {
        tmp_from_len -= tmp_from_len - ctx->tail_start_index;
      }
    }
    if (! done) {
      if (! ((unsigned int )ctx->curr_tag_pos < (unsigned int )(ctx->combined_tag +
                                                                ctx->tag_length))) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      break;
    }
  }
  (*(ctx->combined_tag + ctx->tag_length)) = (char )'\000';
  ctx->curr_tag_pos = ctx->combined_tag;
  return (0);
}
}
static void decodehtml(char *s ) ;
static char const   * const  entlist[7]  = {      (char const   * const  )((void *)0),      (char const   * const  )((void *)0),      (char const   * const  )"lt<gt>",      (char const   * const  )"amp&ETH\320eth\360", 
        (char const   * const  )"quot\"Auml\304Euml\313Iuml\317Ouml\326Uuml\334auml\344euml\353iuml\357ouml\366uuml\374yuml\377",      (char const   * const  )"Acirc\302Aring\305AElig\306Ecirc\312Icirc\316Ocirc\324Ucirc\333THORN\336szlig\337acirc\342aring\345aelig\346ecirc\352icirc\356ocirc\364ucirc\373thorn\376",      (char const   * const  )"Agrave\300Aacute\301Atilde\303Ccedil\307Egrave\310Eacute\311Igrave\314Iacute\315Ntilde\321Ograve\322Oacute\323Otilde\325Oslash\330Ugrave\331Uacute\332Yacute\335agrave\340aacute\341atilde\343ccedil\347egrave\350eacute\351igrave\354iacute\355ntilde\361ograve\362oacute\363otilde\365oslash\370ugrave\371uacute\372yacute\375"};
static void decodehtml(char *s ) 
{ int val ;
  int i ;
  int j ;
  char *p ;
  char const   *ents ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  while ((int )(*s) != 38) {
    if ((int )(*s) == 0) {
      return;
    }
    s ++;
  }
  p = s;
  while ((int )(*s) != 0) {
    if ((int )(*s) != 38) {
      (*p) = (*s);
      goto __Cont;
    }
    i = 1;
    while (1) {
      if ((int )(*(s + i)) != 59) {
        if (! ((int )(*(s + i)) != 0)) {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        break;
      }
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
      i ++;
    }
    if ((int )(*(s + i)) == 0) {
      (*p) = (*s);
      goto __Cont;
    }
    if ((int )(*(s + 1)) == 35) {
      j = 2;
      val = 0;
      while (1) {
        if (j < i) {
          tmp = __ctype_b_loc();
          if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*(s + j))))) &
                 2048)) {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          break;
        }
        val = (val * 10 + (int )(*(s + j))) - 48;
        j ++;
      }
      s += i;
      if (j < i) {
        goto _L___6;
      } else {
        if (val <= 8) {
          _L___6: /* CIL Label */ 
          goto _L___4;
        } else {
          if (val >= 11) {
            if (val <= 31) {
              _L___4: /* CIL Label */ 
              goto _L___2;
            } else {
              goto _L___5;
            }
          } else {
            _L___5: /* CIL Label */ 
            if (val >= 127) {
              if (val <= 160) {
                _L___2: /* CIL Label */ 
                goto _L___1;
              } else {
                goto _L___3;
              }
            } else {
              _L___3: /* CIL Label */ 
              if (val >= 256) {
                _L___1: /* CIL Label */ 
                p --;
              } else {
                (*p) = (char )val;
              }
            }
          }
        }
      }
    } else {
      j = i - 1;
      if (j > 6) {
        goto _L___7;
      } else {
        if ((unsigned int )entlist[j] == (unsigned int )((void *)0)) {
          _L___7: /* CIL Label */ 
          (*p) = (char )'&';
          goto __Cont;
        }
      }
      ents = (char const   *)entlist[j];
      while ((int const   )(*ents) != 0) {
        tmp___0 = strncmp((char const   *)(s + 1), ents, (unsigned int )j);
        if (tmp___0 == 0) {
          break;
        }
        ents += i;
      }
      if ((int const   )(*ents) == 0) {
        (*p) = (char )'&';
      } else {
        (*p) = (char )(*((unsigned char const   *)ents + j));
        s += i;
      }
    }
    __Cont: /* CIL Label */ 
    s ++;
    p ++;
  }
  (*p) = (char )'\000';
  return;
}
}
static void ap_ssi_get_tag_and_value(include_ctx_t *ctx , char **tag , char **tag_val ,
                                     int dodecode ) 
{ char *c ;
  int shift_val ;
  char term ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  unsigned short const   **tmp___7 ;

  {
  c = ctx->curr_tag_pos;
  shift_val = 0;
  term = (char )'\000';
  (*tag_val) = (char *)((void *)0);
  if ((unsigned int )ctx->curr_tag_pos > (unsigned int )(ctx->combined_tag + ctx->tag_length)) {
    (*tag) = (char *)((void *)0);
    return;
  }
  while (1) {
    if ((int )(*c) != 0) {
      tmp = __ctype_b_loc();
      if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*c)))) & 8192)) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      break;
    }
    c ++;
  }
  (*tag) = c;
  while (1) {
    tmp___0 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___0) + (int )((unsigned char )(*c)))) & 512)) {
      break;
    }
    c ++;
  }
  while (1) {
    if ((int )(*c) != 61) {
      tmp___1 = __ctype_b_loc();
      if ((int const   )(*((*tmp___1) + (int )((unsigned char )(*c)))) & 8192) {
        goto _L___1;
      } else {
        if (! ((int )(*c) != 0)) {
          goto _L___1;
        }
      }
    } else {
      _L___1: /* CIL Label */ 
      break;
    }
    (*c) = (char )tolower((int )((unsigned char )(*c)));
    c ++;
  }
  if ((int )(*c) == 0) {
    goto _L___3;
  } else {
    if ((int )(*((*tag))) == 61) {
      _L___3: /* CIL Label */ 
      if ((int )(*((*tag))) == 0) {
        goto _L___2;
      } else {
        if ((int )(*((*tag))) == 61) {
          _L___2: /* CIL Label */ 
          (*tag) = (char *)((void *)0);
        }
      }
      ctx->curr_tag_pos = c;
      return;
    }
  }
  if ((int )(*c) == 61) {
    tmp___2 = c;
    c ++;
    (*tmp___2) = (char )'\000';
  } else {
    tmp___3 = c;
    c ++;
    (*tmp___3) = (char )'\000';
    while (1) {
      if ((int )(*c) != 0) {
        tmp___4 = __ctype_b_loc();
        if (! ((int const   )(*((*tmp___4) + (int )((unsigned char )(*c)))) & 8192)) {
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
        break;
      }
      c ++;
    }
    if ((int )(*c) != 61) {
      ctx->curr_tag_pos = c;
      return;
    } else {
      c ++;
    }
  }
  while (1) {
    if ((int )(*c) != 0) {
      tmp___5 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___5) + (int )((unsigned char )(*c)))) & 8192)) {
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
      break;
    }
    c ++;
  }
  if ((int )(*c) == 34) {
    goto _L___7;
  } else {
    if ((int )(*c) == 39) {
      _L___7: /* CIL Label */ 
      goto _L___6;
    } else {
      if ((int )(*c) == 96) {
        _L___6: /* CIL Label */ 
        tmp___6 = c;
        c ++;
        term = (*tmp___6);
      }
    }
  }
  (*tag_val) = c;
  if (! term) {
    while (1) {
      tmp___7 = __ctype_b_loc();
      if ((int const   )(*((*tmp___7) + (int )((unsigned char )(*c)))) & 8192) {
        _L___8: /* CIL Label */ 
        break;
      } else {
        if (! ((int )(*c) != 0)) {
          goto _L___8;
        }
      }
      c ++;
    }
  } else {
    while (1) {
      if ((int )(*c) != (int )term) {
        if ((int )(*c) != 0) {
          if (! ((int )(*c) != 92)) {
            goto _L___10;
          }
        } else {
          goto _L___10;
        }
      } else {
        _L___10: /* CIL Label */ 
        break;
      }
      c ++;
    }
    if ((int )(*c) == 92) {
      while (1) {
        if ((int )(*c) == 92) {
          c ++;
          if ((int )(*c) == (int )term) {
            shift_val ++;
          }
          if (shift_val > 0) {
            (*(c - shift_val)) = (*c);
          }
          if ((int )(*c) == 0) {
            break;
          }
        }
        c ++;
        if (shift_val > 0) {
          (*(c - shift_val)) = (*c);
        }
        if ((int )(*c) != (int )term) {
          if (! ((int )(*c) != 0)) {
            goto _L___11;
          }
        } else {
          _L___11: /* CIL Label */ 
          break;
        }
      }
    }
  }
  (*(c - shift_val)) = (char )'\000';
  c ++;
  ctx->curr_tag_pos = c;
  if (dodecode) {
    decodehtml((*tag_val));
  }
  return;
}
}
static char *ap_ssi_parse_string(request_rec *r , include_ctx_t *ctx , char const   *in ,
                                 char *out , apr_size_t length , int leave_name ) 
{ char ch ;
  char *next ;
  char *end_out ;
  apr_size_t out_size ;
  apr_size_t new_out_size ;
  apr_size_t current_length ;
  char *new_out ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *start_of_var_name ;
  char *end_of_var_name ;
  char const   *expansion ;
  char const   *temp_end ;
  char const   *val ;
  char tmp_store ;
  apr_size_t l ;
  unsigned short const   **tmp___2 ;
  apr_size_t new_out_size___0 ;
  apr_size_t current_length___0 ;
  char *new_out___0 ;
  apr_size_t new_out_size___1 ;
  apr_size_t current_length___1 ;
  char *new_out___1 ;
  char *tmp___3 ;
  char const   *tmp___4 ;

  {
  if (! out) {
    out_size = 64U;
    if (out_size > length) {
      out_size = length;
    }
    out = (char *)apr_palloc(r->pool, out_size);
  } else {
    out_size = length;
  }
  end_out = (out + out_size) - 1;
  next = out;
  while (1) {
    tmp___4 = in;
    in ++;
    ch = (char )(*tmp___4);
    if (! ((int )ch != 0)) {
      break;
    }
    switch ((int )ch) {
    case 92: ;
    if ((unsigned int )next == (unsigned int )end_out) {
      if (out_size < length) {
        new_out_size = out_size * 2U;
        current_length = (apr_size_t )(next - out);
        if (new_out_size > length) {
          new_out_size = length;
        }
        new_out = (char *)apr_palloc(r->pool, new_out_size);
        memcpy((void * __restrict  )new_out, (void const   * __restrict  )out, current_length);
        out = new_out;
        out_size = new_out_size;
        end_out = (out + out_size) - 1;
        next = out + current_length;
      } else {
        (*next) = (char )'\000';
        return (out);
      }
    }
    if ((int const   )(*in) == 36) {
      tmp = next;
      next ++;
      tmp___0 = in;
      in ++;
      (*tmp) = (char )(*tmp___0);
    } else {
      tmp___1 = next;
      next ++;
      (*tmp___1) = ch;
    }
    break;
    case 36: 
    expansion = in - 1;
    if ((int const   )(*in) == 123) {
      in ++;
      start_of_var_name = in;
      in = strchr(in, '}');
      if ((unsigned int )in == (unsigned int )((void *)0)) {
        ap_log_rerror("mod_include.c", 1078, 3, 0, (request_rec const   *)r, "Missing \'}\' on variable \"%s\"",
                      expansion);
        (*next) = (char )'\000';
        return (out);
      }
      temp_end = in;
      end_of_var_name = (char *)temp_end;
      in ++;
    } else {
      start_of_var_name = in;
      while (1) {
        tmp___2 = __ctype_b_loc();
        if ((int const   )(*((*tmp___2) + (int )((unsigned char )(*in)))) & 8) {
          goto _L;
        } else {
          if ((int const   )(*in) == 95) {
            _L: /* CIL Label */ ;
          } else {
            break;
          }
        }
        in ++;
      }
      temp_end = in;
      end_of_var_name = (char *)temp_end;
    }
    l = (unsigned int )(end_of_var_name - (char *)start_of_var_name);
    if (l != 0U) {
      tmp_store = (*end_of_var_name);
      (*end_of_var_name) = (char )'\000';
      val = get_include_var(r, ctx, start_of_var_name);
      (*end_of_var_name) = tmp_store;
      if (val) {
        expansion = val;
        l = strlen(expansion);
      } else {
        if (leave_name) {
          l = (unsigned int )(in - expansion);
        } else {
          break;
        }
      }
    } else {
      l = 1U;
    }
    if ((unsigned int )(next + l) > (unsigned int )end_out) {
      if (out_size < length) {
        new_out_size___0 = out_size;
        current_length___0 = (apr_size_t )(next - out);
        while (1) {
          new_out_size___0 *= 2U;
          if (! (new_out_size___0 < current_length___0 + l)) {
            break;
          }
        }
        if (new_out_size___0 > length) {
          new_out_size___0 = length;
        }
        new_out___0 = (char *)apr_palloc(r->pool, new_out_size___0);
        memcpy((void * __restrict  )new_out___0, (void const   * __restrict  )out,
               current_length___0);
        out = new_out___0;
        out_size = new_out_size___0;
        end_out = (out + out_size) - 1;
        next = out + current_length___0;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
    if ((int )l > end_out - next) {
      l = (unsigned int )(end_out - next);
    } else {
      l = l;
    }
    memcpy((void * __restrict  )next, (void const   * __restrict  )expansion, l);
    next += l;
    break;
    default: ;
    if ((unsigned int )next == (unsigned int )end_out) {
      if (out_size < length) {
        new_out_size___1 = out_size * 2U;
        current_length___1 = (apr_size_t )(next - out);
        if (new_out_size___1 > length) {
          new_out_size___1 = length;
        }
        new_out___1 = (char *)apr_palloc(r->pool, new_out_size___1);
        memcpy((void * __restrict  )new_out___1, (void const   * __restrict  )out,
               current_length___1);
        out = new_out___1;
        out_size = new_out_size___1;
        end_out = (out + out_size) - 1;
        next = out + current_length___1;
      } else {
        (*next) = (char )'\000';
        return (out);
      }
    }
    tmp___3 = next;
    next ++;
    (*tmp___3) = ch;
    break;
    }
  }
  (*next) = (char )'\000';
  return (out);
}
}
static int is_only_below(char const   *path ) 
{ int dots ;
  char const   *tmp ;

  {
  if ((int const   )(*(path + 0)) == 47) {
    return (0);
  }
  while ((*path)) {
    dots = 0;
    while ((int const   )(*(path + dots)) == 46) {
      dots ++;
    }
    if (dots == 2) {
      if (! (*(path + dots))) {
        goto _L___0;
      } else {
        if ((int const   )(*(path + dots)) == 47) {
          _L___0: /* CIL Label */ 
          return (0);
        } else {
          goto _L;
        }
      }
    } else {
      _L: /* CIL Label */ ;
    }
    path += dots;
    while (1) {
      if ((*path)) {
        tmp = path;
        path ++;
        if (! ((int const   )(*tmp) != 47)) {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        break;
      }
      continue;
    }
  }
  return (1);
}
}
static int handle_include(include_ctx_t *ctx , apr_bucket_brigade **bb , request_rec *r ,
                          ap_filter_t *f , apr_bucket *head_ptr , apr_bucket **inserted_head ) 
{ char *tag ;
  char *tag_val ;
  apr_bucket *tmp_buck ;
  char *parsed_string ;
  int loglevel ;
  request_rec *rr ;
  char *error_fmt ;
  apr_status_t rc ;
  apr_bucket_brigade *tag_plus ;
  apr_bucket *ap__b ;
  apr_bucket *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int founddupe ;
  request_rec *p ;
  request_rec *q ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  apr_size_t tmp___5 ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b___0 ;
  apr_size_t tmp___6 ;
  apr_bucket *ap__a___0 ;
  apr_bucket *ap__b___1 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  tag = (char *)((void *)0);
  tag_val = (char *)((void *)0);
  loglevel = 3;
  (*inserted_head) = (apr_bucket *)((void *)0);
  if (ctx->flags & 1L) {
    while (1) {
      ap_ssi_get_tag_and_value(ctx, & tag, & tag_val, 1);
      if ((unsigned int )tag_val == (unsigned int )((void *)0)) {
        if ((unsigned int )tag == (unsigned int )((void *)0)) {
          return (0);
        } else {
          return (1);
        }
      }
      tmp___7 = strcmp((char const   *)tag, "virtual");
      if (tmp___7) {
        tmp___8 = strcmp((char const   *)tag, "file");
        if (tmp___8) {
          ap_log_rerror("mod_include.c", 1351, 3, 0, (request_rec const   *)r, "unknown parameter \"%s\" to tag include in %s",
                        tag, r->filename);
          tmp___6 = strlen((char const   *)ctx->error_str);
          tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp___6,
                                            (void (*)(void *data ))((void *)0), head_ptr->list);
          while (1) {
            ap__a___0 = head_ptr;
            ap__b___1 = tmp_buck;
            while (1) {
              ap__b___1->link.next = ap__a___0;
              ap__b___1->link.prev = ap__a___0->link.prev;
              (ap__a___0->link.prev)->link.next = ap__b___1;
              ap__a___0->link.prev = ap__b___1;
              break;
            }
            break;
          }
          if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
            (*inserted_head) = tmp_buck;
          }
        } else {
          _L___10: /* CIL Label */ 
          rr = (request_rec *)((void *)0);
          error_fmt = (char *)((void *)0);
          rc = 0;
          if ((unsigned int )(ctx->ssi_tag_brigade)->list.next == (unsigned int )((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                                                        (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                                (char *)((void *)0))))) {
            if ((unsigned int )ctx->head_start_bucket != (unsigned int )((void *)0)) {
              tag_plus = apr_brigade_split((*bb), ctx->head_start_bucket);
              if (ctx->output_flush) {
                while (1) {
                  tmp = apr_bucket_flush_create(((*bb))->bucket_alloc);
                  ap__b = tmp;
                  while (1) {
                    ap__b->link.next = (struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                             (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                     (char *)((void *)0)));
                    ap__b->link.prev = ((struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                              (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                      (char *)((void *)0))))->link.prev;
                    (((struct apr_bucket *)((char *)(& ((*bb))->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                (char *)((void *)0))))->link.prev)->link.next = ap__b;
                    ((struct apr_bucket *)((char *)(& ((*bb))->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                               (char *)((void *)0))))->link.prev = ap__b;
                    break;
                  }
                  break;
                }
              }
              rc = ap_pass_brigade(f->next, (*bb));
              ctx->bytes_parsed = 0;
              (*bb) = tag_plus;
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ ;
          }
          if (rc != 0) {
            return (rc);
          }
          parsed_string = ap_ssi_parse_string(r, ctx, (char const   *)tag_val, (char *)((void *)0),
                                              8192U, 0);
          if ((int )(*(tag + 0)) == 102) {
            tmp___0 = is_only_below((char const   *)parsed_string);
            if (tmp___0) {
              rr = ap_sub_req_lookup_uri((char const   *)parsed_string, (request_rec const   *)r,
                                         f->next);
            } else {
              error_fmt = (char *)"unable to include file \"%s\" in parsed file %s";
            }
          } else {
            rr = ap_sub_req_lookup_uri((char const   *)parsed_string, (request_rec const   *)r,
                                       f->next);
          }
          if (! error_fmt) {
            if (rr->status != 200) {
              error_fmt = (char *)"unable to include \"%s\" in parsed file %s";
            } else {
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ ;
          }
          if (! error_fmt) {
            if (ctx->flags & 8L) {
              if (rr->content_type) {
                tmp___1 = strncmp(rr->content_type, "text/", 5U);
                if (tmp___1) {
                  error_fmt = (char *)"unable to include potential exec \"%s\" in parsed file %s";
                } else {
                  goto _L___3;
                }
              } else {
                goto _L___3;
              }
            } else {
              goto _L___3;
            }
          } else {
            _L___3: /* CIL Label */ ;
          }
          if ((unsigned int )error_fmt == (unsigned int )((void *)0)) {
            founddupe = 0;
            p = r;
            while (1) {
              if ((unsigned int )p != (unsigned int )((void *)0)) {
                if (! (! founddupe)) {
                  goto _L___8;
                }
              } else {
                _L___8: /* CIL Label */ 
                break;
              }
              q = p;
              while ((unsigned int )q != (unsigned int )((void *)0)) {
                if (q->filename) {
                  if (rr->filename) {
                    tmp___2 = strcmp((char const   *)q->filename, (char const   *)rr->filename);
                    if (tmp___2 == 0) {
                      goto _L___4;
                    } else {
                      goto _L___7;
                    }
                  } else {
                    goto _L___7;
                  }
                } else {
                  _L___7: /* CIL Label */ 
                  if ((int )(*(q->uri)) == 47) {
                    tmp___3 = strcmp((char const   *)q->uri, (char const   *)rr->uri);
                    if (tmp___3 == 0) {
                      _L___4: /* CIL Label */ 
                      founddupe = 1;
                      break;
                    } else {
                      goto _L___5;
                    }
                  } else {
                    _L___5: /* CIL Label */ ;
                  }
                }
                q = q->prev;
              }
              p = p->main;
            }
            if ((unsigned int )p != (unsigned int )((void *)0)) {
              error_fmt = (char *)"Recursive include of \"%s\" in parsed file %s";
            }
          }
          if (rr) {
            (*((void **)rr->request_config + include_module.module_index)) = (void *)r;
          }
          if (! error_fmt) {
            tmp___4 = ap_run_sub_req(rr);
            if (tmp___4) {
              error_fmt = (char *)"unable to include \"%s\" in parsed file %s";
            } else {
              goto _L___9;
            }
          } else {
            _L___9: /* CIL Label */ ;
          }
          if (error_fmt) {
            ap_log_rerror("mod_include.c", 1339, loglevel, 0, (request_rec const   *)r,
                          (char const   *)error_fmt, tag_val, r->filename);
            tmp___5 = strlen((char const   *)ctx->error_str);
            tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp___5,
                                              (void (*)(void *data ))((void *)0),
                                              head_ptr->list);
            while (1) {
              ap__a = head_ptr;
              ap__b___0 = tmp_buck;
              while (1) {
                ap__b___0->link.next = ap__a;
                ap__b___0->link.prev = ap__a->link.prev;
                (ap__a->link.prev)->link.next = ap__b___0;
                ap__a->link.prev = ap__b___0;
                break;
              }
              break;
            }
            if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
              (*inserted_head) = tmp_buck;
            }
          }
          if ((unsigned int )rr != (unsigned int )((void *)0)) {
            ap_destroy_sub_req(rr);
          }
        }
      } else {
        goto _L___10;
      }
    }
  }
  return (0);
}
}
static int handle_echo(include_ctx_t *ctx , apr_bucket_brigade **bb , request_rec *r ,
                       ap_filter_t *f , apr_bucket *head_ptr , apr_bucket **inserted_head ) 
{ char *tag ;
  char *tag_val ;
  char const   *echo_text ;
  apr_bucket *tmp_buck ;
  apr_size_t e_len ;
  enum __anonenum_encode_98 encode ;
  conn_rec *c ;
  char const   *val ;
  char const   *tmp ;
  char const   *tmp___0 ;
  include_server_config *sconf ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b ;
  apr_size_t tmp___1 ;
  apr_bucket *ap__a___0 ;
  apr_bucket *ap__b___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  apr_size_t tmp___5 ;
  apr_bucket *ap__a___1 ;
  apr_bucket *ap__b___1 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  tag = (char *)((void *)0);
  tag_val = (char *)((void *)0);
  echo_text = (char const   *)((void *)0);
  encode = 2;
  (*inserted_head) = (apr_bucket *)((void *)0);
  if (ctx->flags & 1L) {
    while (1) {
      ap_ssi_get_tag_and_value(ctx, & tag, & tag_val, 1);
      if ((unsigned int )tag_val == (unsigned int )((void *)0)) {
        if ((unsigned int )tag != (unsigned int )((void *)0)) {
          return (1);
        } else {
          return (0);
        }
      }
      tmp___7 = strcmp((char const   *)tag, "var");
      if (tmp___7) {
        tmp___6 = strcmp((char const   *)tag, "encoding");
        if (tmp___6) {
          ap_log_rerror("mod_include.c", 1436, 3, 0, (request_rec const   *)r, "unknown parameter \"%s\" in tag echo of %s",
                        tag, r->filename);
          tmp___5 = strlen((char const   *)ctx->error_str);
          tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp___5,
                                            (void (*)(void *data ))((void *)0), head_ptr->list);
          while (1) {
            ap__a___1 = head_ptr;
            ap__b___1 = tmp_buck;
            while (1) {
              ap__b___1->link.next = ap__a___1;
              ap__b___1->link.prev = ap__a___1->link.prev;
              (ap__a___1->link.prev)->link.next = ap__b___1;
              ap__a___1->link.prev = ap__b___1;
              break;
            }
            break;
          }
          if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
            (*inserted_head) = tmp_buck;
          }
        } else {
          tmp___4 = strcasecmp((char const   *)tag_val, "none");
          if (tmp___4) {
            tmp___3 = strcasecmp((char const   *)tag_val, "url");
            if (tmp___3) {
              tmp___2 = strcasecmp((char const   *)tag_val, "entity");
              if (tmp___2) {
                ap_log_rerror("mod_include.c", 1428, 3, 0, (request_rec const   *)r,
                              "unknown value \"%s\" to parameter \"encoding\" of tag echo in %s",
                              tag_val, r->filename);
                tmp___1 = strlen((char const   *)ctx->error_str);
                tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str,
                                                  tmp___1, (void (*)(void *data ))((void *)0),
                                                  head_ptr->list);
                while (1) {
                  ap__a___0 = head_ptr;
                  ap__b___0 = tmp_buck;
                  while (1) {
                    ap__b___0->link.next = ap__a___0;
                    ap__b___0->link.prev = ap__a___0->link.prev;
                    (ap__a___0->link.prev)->link.next = ap__b___0;
                    ap__a___0->link.prev = ap__b___0;
                    break;
                  }
                  break;
                }
                if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
                  (*inserted_head) = tmp_buck;
                }
              } else {
                encode = 2;
              }
            } else {
              encode = 1;
            }
          } else {
            encode = 0;
          }
        }
      } else {
        c = r->connection;
        tmp = ap_ssi_parse_string(r, ctx, (char const   *)tag_val, (char *)((void *)0),
                                  8192U, 0);
        tmp___0 = get_include_var(r, ctx, tmp);
        val = tmp___0;
        if (val) {
          switch ((int )encode) {
          case 0: 
          echo_text = val;
          break;
          case 1: 
          echo_text = ap_os_escape_path(r->pool, val, 1);
          break;
          case 2: 
          echo_text = ap_escape_html(r->pool, val);
          break;
          }
          e_len = strlen(echo_text);
          tmp_buck = apr_bucket_pool_create(echo_text, e_len, r->pool, c->bucket_alloc);
        } else {
          sconf = (include_server_config *)(*((void **)(r->server)->module_config +
                                              include_module.module_index));
          tmp_buck = apr_bucket_pool_create((char const   *)sconf->undefinedEcho,
                                            (unsigned int )sconf->undefinedEchoLen,
                                            r->pool, c->bucket_alloc);
        }
        while (1) {
          ap__a = head_ptr;
          ap__b = tmp_buck;
          while (1) {
            ap__b->link.next = ap__a;
            ap__b->link.prev = ap__a->link.prev;
            (ap__a->link.prev)->link.next = ap__b;
            ap__a->link.prev = ap__b;
            break;
          }
          break;
        }
        if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
          (*inserted_head) = tmp_buck;
        }
      }
    }
  }
  return (0);
}
}
static int handle_config(include_ctx_t *ctx , apr_bucket_brigade **bb , request_rec *r ,
                         ap_filter_t *f , apr_bucket *head_ptr , apr_bucket **inserted_head ) 
{ char *tag ;
  char *tag_val ;
  char *parsed_string ;
  apr_table_t *env ;
  apr_time_t date ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  apr_bucket *tmp_buck ;
  apr_size_t tmp___6 ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  tag = (char *)((void *)0);
  tag_val = (char *)((void *)0);
  env = r->subprocess_env;
  (*inserted_head) = (apr_bucket *)((void *)0);
  if (ctx->flags & 1L) {
    while (1) {
      ap_ssi_get_tag_and_value(ctx, & tag, & tag_val, 0);
      if ((unsigned int )tag_val == (unsigned int )((void *)0)) {
        if ((unsigned int )tag == (unsigned int )((void *)0)) {
          return (0);
        } else {
          return (1);
        }
      }
      tmp___9 = strcmp((char const   *)tag, "errmsg");
      if (tmp___9) {
        tmp___8 = strcmp((char const   *)tag, "timefmt");
        if (tmp___8) {
          tmp___7 = strcmp((char const   *)tag, "sizefmt");
          if (tmp___7) {
            ap_log_rerror("mod_include.c", 1511, 3, 0, (request_rec const   *)r, "unknown parameter \"%s\" to tag config in %s",
                          tag, r->filename);
            tmp___6 = strlen((char const   *)ctx->error_str);
            tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp___6,
                                              (void (*)(void *data ))((void *)0),
                                              head_ptr->list);
            while (1) {
              ap__a = head_ptr;
              ap__b = tmp_buck;
              while (1) {
                ap__b->link.next = ap__a;
                ap__b->link.prev = ap__a->link.prev;
                (ap__a->link.prev)->link.next = ap__b;
                ap__a->link.prev = ap__b;
                break;
              }
              break;
            }
            if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
              (*inserted_head) = tmp_buck;
            }
          } else {
            parsed_string = ap_ssi_parse_string(r, ctx, (char const   *)tag_val, (char *)((void *)0),
                                                8192U, 0);
            decodehtml(parsed_string);
            tmp___5 = strcmp((char const   *)parsed_string, "bytes");
            if (tmp___5) {
              tmp___4 = strcmp((char const   *)parsed_string, "abbrev");
              if (! tmp___4) {
                ctx->flags = (long )((unsigned long )ctx->flags & 4294967291UL);
              }
            } else {
              ctx->flags |= 4L;
            }
          }
        } else {
          date = r->request_time;
          if ((unsigned int )ctx->time_str_override == (unsigned int )((void *)0)) {
            ctx->time_str_override = (char *)apr_palloc(ctx->pool, 8192U);
            ctx->time_str = ctx->time_str_override;
          }
          ap_ssi_parse_string(r, ctx, (char const   *)tag_val, ctx->time_str_override,
                              8192U, 0);
          tmp___1 = ap_ht_time(r->pool, date, (char const   *)ctx->time_str, 0);
          apr_table_setn(env, "DATE_LOCAL", tmp___1);
          tmp___2 = ap_ht_time(r->pool, date, (char const   *)ctx->time_str, 1);
          apr_table_setn(env, "DATE_GMT", tmp___2);
          tmp___3 = ap_ht_time(r->pool, r->finfo.mtime, (char const   *)ctx->time_str,
                               0);
          apr_table_setn(env, "LAST_MODIFIED", tmp___3);
        }
      } else {
        if ((unsigned int )ctx->error_str_override == (unsigned int )((void *)0)) {
          ctx->error_str_override = (char *)apr_palloc(ctx->pool, 8192U);
          ctx->error_str = ctx->error_str_override;
        }
        ap_ssi_parse_string(r, ctx, (char const   *)tag_val, ctx->error_str_override,
                            8192U, 0);
      }
    }
  }
  return (0);
}
}
static int find_file(request_rec *r , char const   *directive , char const   *tag ,
                     char *tag_val , apr_finfo_t *finfo ) 
{ char *to_send ;
  request_rec *rr ;
  int ret ;
  char *error_fmt ;
  apr_status_t rv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  to_send = tag_val;
  rr = (request_rec *)((void *)0);
  ret = 0;
  error_fmt = (char *)((void *)0);
  rv = 0;
  tmp___1 = strcmp(tag, "file");
  if (tmp___1) {
    tmp___0 = strcmp(tag, "virtual");
    if (tmp___0) {
      ap_log_rerror("mod_include.c", 1592, 3, 0, (request_rec const   *)r, "unknown parameter \"%s\" to tag %s in %s",
                    tag, directive, r->filename);
      return (-1);
    } else {
      rr = ap_sub_req_lookup_uri((char const   *)tag_val, (request_rec const   *)r,
                                 (ap_filter_t *)((void *)0));
      if (rr->status == 200) {
        if ((int )rr->finfo.filetype != 0) {
          memcpy((void * __restrict  )((char *)finfo), (void const   * __restrict  )((char const   *)(& rr->finfo)),
                 sizeof(rr->finfo));
          ap_destroy_sub_req(rr);
          return (0);
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        ap_log_rerror("mod_include.c", 1583, 3, 0, (request_rec const   *)r, "unable to get information about \"%s\" in parsed file %s",
                      tag_val, r->filename);
        ap_destroy_sub_req(rr);
        return (-1);
      }
    }
  } else {
    tmp = is_only_below((char const   *)tag_val);
    if (tmp) {
      ap_getparents(tag_val);
      rr = ap_sub_req_lookup_file((char const   *)tag_val, (request_rec const   *)r,
                                  (ap_filter_t *)((void *)0));
      if (rr->status == 200) {
        if ((int )rr->finfo.filetype != 0) {
          to_send = rr->filename;
          rv = apr_stat(finfo, (char const   *)to_send, 2130288, rr->pool);
          if (rv != 0) {
            if (rv != 70008) {
              error_fmt = (char *)"unable to get information about \"%s\" in parsed file %s";
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ ;
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        error_fmt = (char *)"unable to lookup information about \"%s\" in parsed file %s";
      }
    } else {
      error_fmt = (char *)"unable to access file \"%s\" in parsed file %s";
    }
    if (error_fmt) {
      ret = -1;
      ap_log_rerror("mod_include.c", 1563, 3, rv, (request_rec const   *)r, (char const   *)error_fmt,
                    to_send, r->filename);
    }
    if (rr) {
      ap_destroy_sub_req(rr);
    }
    return (ret);
  }
}
}
static int handle_fsize(include_ctx_t *ctx , apr_bucket_brigade **bb , request_rec *r ,
                        ap_filter_t *f , apr_bucket *head_ptr , apr_bucket **inserted_head ) 
{ char *tag ;
  char *tag_val ;
  apr_finfo_t finfo ;
  apr_size_t s_len ;
  apr_bucket *tmp_buck ;
  char *parsed_string ;
  char buff[50] ;
  int l ;
  int x ;
  int pos ;
  char tmp_buff[50] ;
  int tmp ;
  int tmp___0 ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b ;
  apr_size_t tmp___1 ;
  apr_bucket *ap__a___0 ;
  apr_bucket *ap__b___0 ;
  int tmp___2 ;

  {
  tag = (char *)((void *)0);
  tag_val = (char *)((void *)0);
  (*inserted_head) = (apr_bucket *)((void *)0);
  if (ctx->flags & 1L) {
    while (1) {
      ap_ssi_get_tag_and_value(ctx, & tag, & tag_val, 1);
      if ((unsigned int )tag_val == (unsigned int )((void *)0)) {
        if ((unsigned int )tag == (unsigned int )((void *)0)) {
          return (0);
        } else {
          return (1);
        }
      } else {
        parsed_string = ap_ssi_parse_string(r, ctx, (char const   *)tag_val, (char *)((void *)0),
                                            8192U, 0);
        tmp___2 = find_file(r, "fsize", (char const   *)tag, parsed_string, & finfo);
        if (tmp___2) {
          tmp___1 = strlen((char const   *)ctx->error_str);
          tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp___1,
                                            (void (*)(void *data ))((void *)0), head_ptr->list);
          while (1) {
            ap__a___0 = head_ptr;
            ap__b___0 = tmp_buck;
            while (1) {
              ap__b___0->link.next = ap__a___0;
              ap__b___0->link.prev = ap__a___0->link.prev;
              (ap__a___0->link.prev)->link.next = ap__b___0;
              ap__a___0->link.prev = ap__b___0;
              break;
            }
            break;
          }
          if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
            (*inserted_head) = tmp_buck;
          }
        } else {
          if (! (ctx->flags & 4L)) {
            apr_strfsize(finfo.size, buff);
            s_len = strlen((char const   *)(buff));
          } else {
            pos = 0;
            apr_snprintf(tmp_buff, sizeof(tmp_buff), "%ld", finfo.size);
            l = (int )strlen((char const   *)(tmp_buff));
            x = 0;
            while (x < l) {
              if (x) {
                if (! ((l - x) % 3)) {
                  tmp = pos;
                  pos ++;
                  buff[tmp] = (char )',';
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ ;
              }
              tmp___0 = pos;
              pos ++;
              buff[tmp___0] = tmp_buff[x];
              x ++;
            }
            buff[pos] = (char )'\000';
            s_len = (unsigned int )pos;
          }
          tmp_buck = apr_bucket_heap_create((char const   *)(buff), s_len, (void (*)(void *data ))((void *)0),
                                            (r->connection)->bucket_alloc);
          while (1) {
            ap__a = head_ptr;
            ap__b = tmp_buck;
            while (1) {
              ap__b->link.next = ap__a;
              ap__b->link.prev = ap__a->link.prev;
              (ap__a->link.prev)->link.next = ap__b;
              ap__a->link.prev = ap__b;
              break;
            }
            break;
          }
          if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
            (*inserted_head) = tmp_buck;
          }
        }
      }
    }
  }
  return (0);
}
}
static int handle_flastmod(include_ctx_t *ctx , apr_bucket_brigade **bb , request_rec *r ,
                           ap_filter_t *f , apr_bucket *head_ptr , apr_bucket **inserted_head ) 
{ char *tag ;
  char *tag_val ;
  apr_finfo_t finfo ;
  apr_size_t t_len ;
  apr_bucket *tmp_buck ;
  char *parsed_string ;
  char *t_val ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b ;
  apr_size_t tmp ;
  apr_bucket *ap__a___0 ;
  apr_bucket *ap__b___0 ;
  int tmp___0 ;

  {
  tag = (char *)((void *)0);
  tag_val = (char *)((void *)0);
  (*inserted_head) = (apr_bucket *)((void *)0);
  if (ctx->flags & 1L) {
    while (1) {
      ap_ssi_get_tag_and_value(ctx, & tag, & tag_val, 1);
      if ((unsigned int )tag_val == (unsigned int )((void *)0)) {
        if ((unsigned int )tag == (unsigned int )((void *)0)) {
          return (0);
        } else {
          return (1);
        }
      } else {
        parsed_string = ap_ssi_parse_string(r, ctx, (char const   *)tag_val, (char *)((void *)0),
                                            8192U, 0);
        tmp___0 = find_file(r, "flastmod", (char const   *)tag, parsed_string, & finfo);
        if (tmp___0) {
          tmp = strlen((char const   *)ctx->error_str);
          tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp, (void (*)(void *data ))((void *)0),
                                            head_ptr->list);
          while (1) {
            ap__a___0 = head_ptr;
            ap__b___0 = tmp_buck;
            while (1) {
              ap__b___0->link.next = ap__a___0;
              ap__b___0->link.prev = ap__a___0->link.prev;
              (ap__a___0->link.prev)->link.next = ap__b___0;
              ap__a___0->link.prev = ap__b___0;
              break;
            }
            break;
          }
          if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
            (*inserted_head) = tmp_buck;
          }
        } else {
          t_val = ap_ht_time(r->pool, finfo.mtime, (char const   *)ctx->time_str,
                             0);
          t_len = strlen((char const   *)t_val);
          tmp_buck = apr_bucket_pool_create((char const   *)t_val, t_len, r->pool,
                                            (r->connection)->bucket_alloc);
          while (1) {
            ap__a = head_ptr;
            ap__b = tmp_buck;
            while (1) {
              ap__b->link.next = ap__a;
              ap__b->link.prev = ap__a->link.prev;
              (ap__a->link.prev)->link.next = ap__b;
              ap__a->link.prev = ap__b;
              break;
            }
            break;
          }
          if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
            (*inserted_head) = tmp_buck;
          }
        }
      }
    }
  }
  return (0);
}
}
static int re_check(request_rec *r , include_ctx_t *ctx , char *string , char *rexp ) 
{ regex_t *compiled ;
  apr_size_t nres ;
  int regex_error ;
  void *tmp ;

  {
  nres = sizeof((*(ctx->re_result))) / sizeof(regmatch_t );
  compiled = ap_pregcomp(r->pool, (char const   *)rexp, 0);
  if ((unsigned int )compiled == (unsigned int )((void *)0)) {
    ap_log_rerror("mod_include.c", 1729, 3, 0, (request_rec const   *)r, "unable to compile pattern \"%s\"",
                  rexp);
    return (-1);
  }
  if (! ctx->re_result) {
    tmp = apr_palloc(r->pool, sizeof((*(ctx->re_result))));
    ctx->re_result = (regmatch_t (*)[10])memset(tmp, 0, sizeof((*(ctx->re_result))));
  }
  ctx->re_string = string;
  regex_error = ap_regexec(compiled, (char const   *)string, nres, (*(ctx->re_result)),
                           0);
  ap_pregfree(r->pool, compiled);
  return (! regex_error != 0);
}
}
static char const   *get_ptoken(request_rec *r , char const   *string , struct token *token ,
                                int *unmatched ) 
{ char ch ;
  int next ;
  char qs ;
  int tkn_fnd ;
  unsigned short const   **tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;

  {
  next = 0;
  qs = (char)0;
  tkn_fnd = 0;
  token->value = (char *)((void *)0);
  if ((unsigned int )string == (unsigned int )((char *)((void *)0))) {
    return ((char const   *)((char *)((void *)0)));
  }
  while (1) {
    tmp___0 = string;
    string ++;
    ch = (char )(*tmp___0);
    if (! ch) {
      break;
    }
    tmp = __ctype_b_loc();
    if (! ((int const   )(*((*tmp) + (int )((unsigned char )ch))) & 8192)) {
      break;
    }
  }
  if ((int )ch == 0) {
    return ((char const   *)((char *)((void *)0)));
  }
  token->type = 0;
  switch ((int )ch) {
  case 40: 
  token->type = 8;
  return (string);
  case 41: 
  token->type = 7;
  return (string);
  case 61: 
  token->type = 5;
  return (string);
  case 33: ;
  if ((int const   )(*string) == 61) {
    token->type = 6;
    return (string + 1);
  } else {
    token->type = 4;
    return (string);
  }
  case 39: 
  qs = (char )'\'';
  break;
  case 47: 
  token->type = 1;
  qs = (char )'/';
  break;
  case 124: ;
  if ((int const   )(*string) == 124) {
    token->type = 3;
    return (string + 1);
  }
  break;
  case 38: ;
  if ((int const   )(*string) == 38) {
    token->type = 2;
    return (string + 1);
  }
  break;
  case 62: ;
  if ((int const   )(*string) == 61) {
    token->type = 10;
    return (string + 1);
  } else {
    token->type = 12;
    return (string);
  }
  case 60: ;
  if ((int const   )(*string) == 61) {
    token->type = 11;
    return (string + 1);
  } else {
    token->type = 13;
    return (string);
  }
  default: ;
  break;
  }
  tmp___1 = strlen(string);
  token->value = (char *)apr_palloc(r->pool, tmp___1 + 2U);
  if (! qs) {
    tmp___2 = next;
    next ++;
    (*(token->value + tmp___2)) = ch;
  }
  ch = (char )(*string);
  while (1) {
    if ((int )ch != 0) {
      if (! (! tkn_fnd)) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      break;
    }
    if ((int )ch == 92) {
      string ++;
      ch = (char )(*string);
      if ((int )ch == 0) {
        tkn_fnd = 1;
      } else {
        tmp___3 = next;
        next ++;
        (*(token->value + tmp___3)) = ch;
      }
    } else {
      if (! qs) {
        tmp___5 = __ctype_b_loc();
        if ((int const   )(*((*tmp___5) + (int )((unsigned char )ch))) & 8192) {
          tkn_fnd = 1;
        } else {
          switch ((int )ch) {
          case 40: ;
          case 41: ;
          case 61: ;
          case 33: ;
          case 60: ;
          case 62: 
          tkn_fnd = 1;
          break;
          case 124: ;
          if ((int const   )(*(string + 1)) == 124) {
            tkn_fnd = 1;
          }
          break;
          case 38: ;
          if ((int const   )(*(string + 1)) == 38) {
            tkn_fnd = 1;
          }
          break;
          }
          if (! tkn_fnd) {
            tmp___4 = next;
            next ++;
            (*(token->value + tmp___4)) = ch;
          }
        }
      } else {
        if ((int )ch == (int )qs) {
          qs = (char)0;
          tkn_fnd = 1;
          string ++;
        } else {
          tmp___6 = next;
          next ++;
          (*(token->value + tmp___6)) = ch;
        }
      }
    }
    if (tkn_fnd) {
      break;
    }
    string ++;
    ch = (char )(*string);
  }
  if (qs) {
    (*unmatched) = 1;
    next = 0;
  }
  (*(token->value + next)) = (char )'\000';
  return (string);
}
}
static int parse_expr(request_rec *r , include_ctx_t *ctx , char const   *expr , int *was_error ,
                      int *was_unmatched , char *debug ) 
{ struct parse_node *root ;
  struct parse_node *current ;
  struct parse_node *new ;
  char const   *parse ;
  char *buffer ;
  int retval ;
  apr_size_t debug_pos ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  retval = 0;
  debug_pos = (apr_size_t )0;
  (*(debug + debug_pos)) = (char )'\000';
  (*was_error) = 0;
  (*was_unmatched) = 0;
  parse = expr;
  if ((unsigned int )parse == (unsigned int )((char *)((void *)0))) {
    return (0);
  }
  current = (struct parse_node *)((void *)0);
  root = current;
  while (1) {
    new = (struct parse_node *)apr_palloc(r->pool, sizeof(struct parse_node ));
    new->right = (struct parse_node *)((void *)0);
    new->left = new->right;
    new->parent = new->left;
    new->done = 0;
    parse = get_ptoken(r, parse, & new->token, was_unmatched);
    if ((unsigned int )parse == (unsigned int )((char *)((void *)0))) {
      break;
    }
    switch ((int )new->token.type) {
    case 0: ;
    if ((unsigned int )current == (unsigned int )((struct parse_node *)((void *)0))) {
      current = new;
      root = current;
      break;
    }
    switch ((int )current->token.type) {
    case 0: ;
    if ((*(current->token.value + 0))) {
      tmp___0 = " ";
    } else {
      tmp___0 = "";
    }
    current->token.value = apr_pstrcat(r->pool, current->token.value, tmp___0, new->token.value,
                                       (void *)0);
    break;
    case 5: ;
    case 6: ;
    case 2: ;
    case 3: ;
    case 8: ;
    case 4: ;
    case 10: ;
    case 12: ;
    case 11: ;
    case 13: 
    new->parent = current;
    current->right = new;
    current = current->right;
    break;
    default: 
    ap_log_rerror("mod_include.c", 1985, 3, 0, (request_rec const   *)r, "Invalid expression \"%s\" in file %s",
                  expr, r->filename);
    (*was_error) = 1;
    return (retval);
    }
    break;
    case 1: ;
    if ((unsigned int )current == (unsigned int )((struct parse_node *)((void *)0))) {
      current = new;
      root = current;
      break;
    }
    switch ((int )current->token.type) {
    case 5: ;
    case 6: ;
    case 2: ;
    case 3: ;
    case 8: ;
    case 4: 
    new->parent = current;
    current->right = new;
    current = current->right;
    break;
    default: 
    ap_log_rerror("mod_include.c", 2014, 3, 0, (request_rec const   *)r, "Invalid expression \"%s\" in file %s",
                  expr, r->filename);
    (*was_error) = 1;
    return (retval);
    }
    break;
    case 2: ;
    case 3: ;
    if ((unsigned int )current == (unsigned int )((struct parse_node *)((void *)0))) {
      ap_log_rerror("mod_include.c", 2030, 3, 0, (request_rec const   *)r, "Invalid expression \"%s\" in file %s",
                    expr, r->filename);
      (*was_error) = 1;
      return (retval);
    }
    while ((unsigned int )current != (unsigned int )((struct parse_node *)((void *)0))) {
      switch ((int )current->token.type) {
      case 0: ;
      case 1: ;
      case 9: ;
      case 4: ;
      case 5: ;
      case 6: ;
      case 2: ;
      case 3: ;
      case 10: ;
      case 12: ;
      case 11: ;
      case 13: 
      current = current->parent;
      continue;
      case 8: ;
      break;
      default: 
      ap_log_rerror("mod_include.c", 2056, 3, 0, (request_rec const   *)r, "Invalid expression \"%s\" in file %s",
                    expr, r->filename);
      (*was_error) = 1;
      return (retval);
      }
      break;
    }
    if ((unsigned int )current == (unsigned int )((struct parse_node *)((void *)0))) {
      new->left = root;
      (new->left)->parent = new;
      new->parent = (struct parse_node *)((void *)0);
      root = new;
    } else {
      new->left = current->right;
      current->right = new;
      new->parent = current;
    }
    current = new;
    break;
    case 4: ;
    if ((unsigned int )current == (unsigned int )((struct parse_node *)((void *)0))) {
      current = new;
      root = current;
      break;
    }
    if ((unsigned int )current != (unsigned int )((struct parse_node *)((void *)0))) {
      switch ((int )current->token.type) {
      case 4: ;
      case 5: ;
      case 6: ;
      case 2: ;
      case 3: ;
      case 8: ;
      case 10: ;
      case 12: ;
      case 11: ;
      case 13: ;
      break;
      default: 
      ap_log_rerror("mod_include.c", 2103, 3, 0, (request_rec const   *)r, "Invalid expression \"%s\" in file %s",
                    expr, r->filename);
      (*was_error) = 1;
      return (retval);
      }
    }
    if ((unsigned int )current == (unsigned int )((struct parse_node *)((void *)0))) {
      new->left = root;
      (new->left)->parent = new;
      new->parent = (struct parse_node *)((void *)0);
      root = new;
    } else {
      new->left = current->right;
      current->right = new;
      new->parent = current;
    }
    current = new;
    break;
    case 5: ;
    case 6: ;
    case 10: ;
    case 12: ;
    case 11: ;
    case 13: ;
    if ((unsigned int )current == (unsigned int )((struct parse_node *)((void *)0))) {
      ap_log_rerror("mod_include.c", 2136, 3, 0, (request_rec const   *)r, "Invalid expression \"%s\" in file %s",
                    expr, r->filename);
      (*was_error) = 1;
      return (retval);
    }
    while ((unsigned int )current != (unsigned int )((struct parse_node *)((void *)0))) {
      switch ((int )current->token.type) {
      case 0: ;
      case 1: ;
      case 9: 
      current = current->parent;
      continue;
      case 8: ;
      case 2: ;
      case 3: ;
      break;
      case 4: ;
      case 5: ;
      case 6: ;
      case 10: ;
      case 12: ;
      case 11: ;
      case 13: ;
      default: 
      ap_log_rerror("mod_include.c", 2162, 3, 0, (request_rec const   *)r, "Invalid expression \"%s\" in file %s",
                    expr, r->filename);
      (*was_error) = 1;
      return (retval);
      }
      break;
    }
    if ((unsigned int )current == (unsigned int )((struct parse_node *)((void *)0))) {
      new->left = root;
      (new->left)->parent = new;
      new->parent = (struct parse_node *)((void *)0);
      root = new;
    } else {
      new->left = current->right;
      current->right = new;
      new->parent = current;
    }
    current = new;
    break;
    case 7: ;
    while ((unsigned int )current != (unsigned int )((struct parse_node *)((void *)0))) {
      if ((int )current->token.type == 8) {
        current->token.type = 9;
        break;
      }
      current = current->parent;
    }
    if ((unsigned int )current == (unsigned int )((struct parse_node *)((void *)0))) {
      ap_log_rerror("mod_include.c", 2198, 3, 0, (request_rec const   *)r, "Unmatched \')\' in \"%s\" in file %s",
                    expr, r->filename);
      (*was_error) = 1;
      return (retval);
    }
    break;
    case 8: ;
    if ((unsigned int )current == (unsigned int )((struct parse_node *)((void *)0))) {
      current = new;
      root = current;
      break;
    }
    if ((unsigned int )current != (unsigned int )((struct parse_node *)((void *)0))) {
      switch ((int )current->token.type) {
      case 4: ;
      case 5: ;
      case 6: ;
      case 2: ;
      case 3: ;
      case 8: ;
      case 10: ;
      case 12: ;
      case 11: ;
      case 13: ;
      break;
      case 0: ;
      case 1: ;
      case 9: ;
      default: 
      ap_log_rerror("mod_include.c", 2234, 3, 0, (request_rec const   *)r, "Invalid expression \"%s\" in file %s",
                    expr, r->filename);
      (*was_error) = 1;
      return (retval);
      }
    }
    if ((unsigned int )current == (unsigned int )((struct parse_node *)((void *)0))) {
      new->left = root;
      (new->left)->parent = new;
      new->parent = (struct parse_node *)((void *)0);
      root = new;
    } else {
      new->left = current->right;
      current->right = new;
      new->parent = current;
    }
    current = new;
    break;
    default: ;
    break;
    }
  }
  current = root;
  while ((unsigned int )current != (unsigned int )((struct parse_node *)((void *)0))) {
    switch ((int )current->token.type) {
    case 0: 
    buffer = ap_ssi_parse_string(r, ctx, (char const   *)current->token.value, (char *)((void *)0),
                                 8192U, 0);
    current->token.value = buffer;
    current->value = (int )(*(current->token.value + 0)) != 0;
    current->done = 1;
    current = current->parent;
    break;
    case 1: 
    ap_log_rerror("mod_include.c", 2278, 3, 0, (request_rec const   *)r, "No operator before regex of expr \"%s\" in file %s",
                  expr, r->filename);
    (*was_error) = 1;
    return (retval);
    case 2: ;
    case 3: ;
    if ((unsigned int )current->left == (unsigned int )((struct parse_node *)((void *)0))) {
      goto _L;
    } else {
      if ((unsigned int )current->right == (unsigned int )((struct parse_node *)((void *)0))) {
        _L: /* CIL Label */ 
        ap_log_rerror("mod_include.c", 2293, 3, 0, (request_rec const   *)r, "Invalid expression \"%s\" in file %s",
                      expr, r->filename);
        (*was_error) = 1;
        return (retval);
      }
    }
    if (! (current->left)->done) {
      switch ((int )(current->left)->token.type) {
      case 0: 
      buffer = ap_ssi_parse_string(r, ctx, (char const   *)(current->left)->token.value,
                                   (char *)((void *)0), 8192U, 0);
      (current->left)->token.value = buffer;
      (current->left)->value = (int )(*((current->left)->token.value + 0)) != 0;
      (current->left)->done = 1;
      break;
      default: 
      current = current->left;
      continue;
      }
    }
    if (! (current->right)->done) {
      switch ((int )(current->right)->token.type) {
      case 0: 
      buffer = ap_ssi_parse_string(r, ctx, (char const   *)(current->right)->token.value,
                                   (char *)((void *)0), 8192U, 0);
      (current->right)->token.value = buffer;
      (current->right)->value = (int )(*((current->right)->token.value + 0)) != 0;
      (current->right)->done = 1;
      break;
      default: 
      current = current->right;
      continue;
      }
    }
    if ((int )current->token.type == 2) {
      if ((current->left)->value) {
        if ((current->right)->value) {
          tmp___1 = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        tmp___1 = 0;
      }
      current->value = tmp___1;
    } else {
      if ((current->left)->value) {
        goto _L___1;
      } else {
        if ((current->right)->value) {
          _L___1: /* CIL Label */ 
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      }
      current->value = tmp___2;
    }
    current->done = 1;
    current = current->parent;
    break;
    case 5: ;
    case 6: ;
    if ((unsigned int )current->left == (unsigned int )((struct parse_node *)((void *)0))) {
      goto _L___5;
    } else {
      if ((unsigned int )current->right == (unsigned int )((struct parse_node *)((void *)0))) {
        _L___5: /* CIL Label */ 
        goto _L___4;
      } else {
        if ((int )(current->left)->token.type != 0) {
          _L___4: /* CIL Label */ 
          goto _L___2;
        } else {
          if ((int )(current->right)->token.type != 0) {
            if ((int )(current->right)->token.type != 1) {
              _L___2: /* CIL Label */ 
              ap_log_rerror("mod_include.c", 2361, 3, 0, (request_rec const   *)r,
                            "Invalid expression \"%s\" in file %s", expr, r->filename);
              (*was_error) = 1;
              return (retval);
            } else {
              goto _L___3;
            }
          } else {
            _L___3: /* CIL Label */ ;
          }
        }
      }
    }
    buffer = ap_ssi_parse_string(r, ctx, (char const   *)(current->left)->token.value,
                                 (char *)((void *)0), 8192U, 0);
    (current->left)->token.value = buffer;
    buffer = ap_ssi_parse_string(r, ctx, (char const   *)(current->right)->token.value,
                                 (char *)((void *)0), 8192U, 0);
    (current->right)->token.value = buffer;
    if ((int )(current->right)->token.type == 1) {
      current->value = re_check(r, ctx, (current->left)->token.value, (current->right)->token.value);
    } else {
      tmp___3 = strcmp((char const   *)(current->left)->token.value, (char const   *)(current->right)->token.value);
      current->value = tmp___3 == 0;
    }
    if ((int )current->token.type == 6) {
      current->value = ! current->value != 0;
    }
    current->done = 1;
    current = current->parent;
    break;
    case 10: ;
    case 12: ;
    case 11: ;
    case 13: ;
    if ((unsigned int )current->left == (unsigned int )((struct parse_node *)((void *)0))) {
      goto _L___8;
    } else {
      if ((unsigned int )current->right == (unsigned int )((struct parse_node *)((void *)0))) {
        _L___8: /* CIL Label */ 
        goto _L___7;
      } else {
        if ((int )(current->left)->token.type != 0) {
          _L___7: /* CIL Label */ 
          goto _L___6;
        } else {
          if ((int )(current->right)->token.type != 0) {
            _L___6: /* CIL Label */ 
            ap_log_rerror("mod_include.c", 2418, 3, 0, (request_rec const   *)r, "Invalid expression \"%s\" in file %s",
                          expr, r->filename);
            (*was_error) = 1;
            return (retval);
          }
        }
      }
    }
    buffer = ap_ssi_parse_string(r, ctx, (char const   *)(current->left)->token.value,
                                 (char *)((void *)0), 8192U, 0);
    (current->left)->token.value = buffer;
    buffer = ap_ssi_parse_string(r, ctx, (char const   *)(current->right)->token.value,
                                 (char *)((void *)0), 8192U, 0);
    (current->right)->token.value = buffer;
    current->value = strcmp((char const   *)(current->left)->token.value, (char const   *)(current->right)->token.value);
    if ((int )current->token.type == 10) {
      current->value = current->value >= 0;
    } else {
      if ((int )current->token.type == 12) {
        current->value = current->value > 0;
      } else {
        if ((int )current->token.type == 11) {
          current->value = current->value <= 0;
        } else {
          if ((int )current->token.type == 13) {
            current->value = current->value < 0;
          } else {
            current->value = 0;
          }
        }
      }
    }
    current->done = 1;
    current = current->parent;
    break;
    case 4: ;
    if ((unsigned int )current->right != (unsigned int )((struct parse_node *)((void *)0))) {
      if (! (current->right)->done) {
        current = current->right;
        continue;
      }
      current->value = ! (current->right)->value != 0;
    } else {
      current->value = 0;
    }
    current->done = 1;
    current = current->parent;
    break;
    case 9: ;
    if ((unsigned int )current->right != (unsigned int )((struct parse_node *)((void *)0))) {
      if (! (current->right)->done) {
        current = current->right;
        continue;
      }
      current->value = (current->right)->value;
    } else {
      current->value = 1;
    }
    current->done = 1;
    current = current->parent;
    break;
    case 8: 
    ap_log_rerror("mod_include.c", 2501, 3, 0, (request_rec const   *)r, "Unmatched \'(\' in \"%s\" in file %s",
                  expr, r->filename);
    (*was_error) = 1;
    return (retval);
    case 7: 
    ap_log_rerror("mod_include.c", 2508, 3, 0, (request_rec const   *)r, "Unmatched \')\' in \"%s\" in file %s",
                  expr, r->filename);
    (*was_error) = 1;
    return (retval);
    default: 
    ap_log_rerror("mod_include.c", 2515, 3, 0, (request_rec const   *)r, "bad token type");
    (*was_error) = 1;
    return (retval);
    }
  }
  if ((unsigned int )root == (unsigned int )((struct parse_node *)((void *)0))) {
    retval = 0;
  } else {
    retval = root->value;
  }
  return (retval);
}
}
static int handle_if(include_ctx_t *ctx , apr_bucket_brigade **bb , request_rec *r ,
                     ap_filter_t *f , apr_bucket *head_ptr , apr_bucket **inserted_head ) 
{ char *tag ;
  char *tag_val ;
  char *expr ;
  int expr_ret ;
  int was_error ;
  int was_unmatched ;
  apr_bucket *tmp_buck ;
  char debug_buf[10] ;
  apr_size_t tmp ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b ;
  apr_size_t tmp___0 ;
  apr_bucket *ap__a___0 ;
  apr_bucket *ap__b___0 ;
  apr_size_t tmp___1 ;
  apr_bucket *ap__a___1 ;
  apr_bucket *ap__b___1 ;
  int tmp___2 ;

  {
  tag = (char *)((void *)0);
  tag_val = (char *)((void *)0);
  expr = (char *)((void *)0);
  (*inserted_head) = (apr_bucket *)((void *)0);
  if (! (ctx->flags & 1L)) {
    ctx->if_nesting_level ++;
  } else {
    while (1) {
      ap_ssi_get_tag_and_value(ctx, & tag, & tag_val, 0);
      if ((unsigned int )tag == (unsigned int )((void *)0)) {
        if ((unsigned int )expr == (unsigned int )((void *)0)) {
          ap_log_rerror("mod_include.c", 2588, 3, 0, (request_rec const   *)r, "missing expr in if statement: %s",
                        r->filename);
          tmp = strlen((char const   *)ctx->error_str);
          tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp, (void (*)(void *data ))((void *)0),
                                            head_ptr->list);
          while (1) {
            ap__a = head_ptr;
            ap__b = tmp_buck;
            while (1) {
              ap__b->link.next = ap__a;
              ap__b->link.prev = ap__a->link.prev;
              (ap__a->link.prev)->link.next = ap__b;
              ap__a->link.prev = ap__b;
              break;
            }
            break;
          }
          if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
            (*inserted_head) = tmp_buck;
          }
          return (1);
        }
        expr_ret = parse_expr(r, ctx, (char const   *)expr, & was_error, & was_unmatched,
                              debug_buf);
        if (was_error) {
          tmp___0 = strlen((char const   *)ctx->error_str);
          tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp___0,
                                            (void (*)(void *data ))((void *)0), head_ptr->list);
          while (1) {
            ap__a___0 = head_ptr;
            ap__b___0 = tmp_buck;
            while (1) {
              ap__b___0->link.next = ap__a___0;
              ap__b___0->link.prev = ap__a___0->link.prev;
              (ap__a___0->link.prev)->link.next = ap__b___0;
              ap__a___0->link.prev = ap__b___0;
              break;
            }
            break;
          }
          if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
            (*inserted_head) = tmp_buck;
          }
          return (1);
        }
        if (was_unmatched) {

        }
        if (expr_ret) {
          ctx->flags |= 3L;
        } else {
          ctx->flags = (long )((unsigned long )ctx->flags & 4294967292UL);
        }
        ctx->if_nesting_level = 0;
        return (0);
      } else {
        tmp___2 = strcmp((char const   *)tag, "expr");
        if (tmp___2) {
          ap_log_rerror("mod_include.c", 2637, 3, 0, (request_rec const   *)r, "unknown parameter \"%s\" to tag if in %s",
                        tag, r->filename);
          tmp___1 = strlen((char const   *)ctx->error_str);
          tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp___1,
                                            (void (*)(void *data ))((void *)0), head_ptr->list);
          while (1) {
            ap__a___1 = head_ptr;
            ap__b___1 = tmp_buck;
            while (1) {
              ap__b___1->link.next = ap__a___1;
              ap__b___1->link.prev = ap__a___1->link.prev;
              (ap__a___1->link.prev)->link.next = ap__b___1;
              ap__a___1->link.prev = ap__b___1;
              break;
            }
            break;
          }
          if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
            (*inserted_head) = tmp_buck;
          }
        } else {
          expr = tag_val;
        }
      }
    }
  }
  return (0);
}
}
static int handle_elif(include_ctx_t *ctx , apr_bucket_brigade **bb , request_rec *r ,
                       ap_filter_t *f , apr_bucket *head_ptr , apr_bucket **inserted_head ) 
{ char *tag ;
  char *tag_val ;
  char *expr ;
  int expr_ret ;
  int was_error ;
  int was_unmatched ;
  apr_bucket *tmp_buck ;
  char debug_buf[10] ;
  apr_size_t tmp ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b ;
  apr_size_t tmp___0 ;
  apr_bucket *ap__a___0 ;
  apr_bucket *ap__b___0 ;
  apr_size_t tmp___1 ;
  apr_bucket *ap__a___1 ;
  apr_bucket *ap__b___1 ;
  int tmp___2 ;

  {
  tag = (char *)((void *)0);
  tag_val = (char *)((void *)0);
  expr = (char *)((void *)0);
  (*inserted_head) = (apr_bucket *)((void *)0);
  if (! ctx->if_nesting_level) {
    while (1) {
      ap_ssi_get_tag_and_value(ctx, & tag, & tag_val, 0);
      if ((unsigned int )tag == (unsigned int )((char *)0)) {
        if (ctx->flags & 2L) {
          ctx->flags = (long )((unsigned long )ctx->flags & 4294967294UL);
          return (0);
        }
        if ((unsigned int )expr == (unsigned int )((void *)0)) {
          ap_log_rerror("mod_include.c", 2672, 3, 0, (request_rec const   *)r, "missing expr in elif statement: %s",
                        r->filename);
          tmp = strlen((char const   *)ctx->error_str);
          tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp, (void (*)(void *data ))((void *)0),
                                            head_ptr->list);
          while (1) {
            ap__a = head_ptr;
            ap__b = tmp_buck;
            while (1) {
              ap__b->link.next = ap__a;
              ap__b->link.prev = ap__a->link.prev;
              (ap__a->link.prev)->link.next = ap__b;
              ap__a->link.prev = ap__b;
              break;
            }
            break;
          }
          if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
            (*inserted_head) = tmp_buck;
          }
          return (1);
        }
        expr_ret = parse_expr(r, ctx, (char const   *)expr, & was_error, & was_unmatched,
                              debug_buf);
        if (was_error) {
          tmp___0 = strlen((char const   *)ctx->error_str);
          tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp___0,
                                            (void (*)(void *data ))((void *)0), head_ptr->list);
          while (1) {
            ap__a___0 = head_ptr;
            ap__b___0 = tmp_buck;
            while (1) {
              ap__b___0->link.next = ap__a___0;
              ap__b___0->link.prev = ap__a___0->link.prev;
              (ap__a___0->link.prev)->link.next = ap__b___0;
              ap__a___0->link.prev = ap__b___0;
              break;
            }
            break;
          }
          if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
            (*inserted_head) = tmp_buck;
          }
          return (1);
        }
        if (was_unmatched) {

        }
        if (expr_ret) {
          ctx->flags |= 3L;
        } else {
          ctx->flags = (long )((unsigned long )ctx->flags & 4294967292UL);
        }
        return (0);
      } else {
        tmp___2 = strcmp((char const   *)tag, "expr");
        if (tmp___2) {
          ap_log_rerror("mod_include.c", 2720, 3, 0, (request_rec const   *)r, "unknown parameter \"%s\" to tag if in %s",
                        tag, r->filename);
          tmp___1 = strlen((char const   *)ctx->error_str);
          tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp___1,
                                            (void (*)(void *data ))((void *)0), head_ptr->list);
          while (1) {
            ap__a___1 = head_ptr;
            ap__b___1 = tmp_buck;
            while (1) {
              ap__b___1->link.next = ap__a___1;
              ap__b___1->link.prev = ap__a___1->link.prev;
              (ap__a___1->link.prev)->link.next = ap__b___1;
              ap__a___1->link.prev = ap__b___1;
              break;
            }
            break;
          }
          if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
            (*inserted_head) = tmp_buck;
          }
        } else {
          expr = tag_val;
        }
      }
    }
  }
  return (0);
}
}
static int handle_else(include_ctx_t *ctx , apr_bucket_brigade **bb , request_rec *r ,
                       ap_filter_t *f , apr_bucket *head_ptr , apr_bucket **inserted_head ) 
{ char *tag ;
  char *tag_val ;
  apr_bucket *tmp_buck ;
  apr_size_t tmp ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b ;

  {
  tag = (char *)((void *)0);
  tag_val = (char *)((void *)0);
  (*inserted_head) = (apr_bucket *)((void *)0);
  if (! ctx->if_nesting_level) {
    ap_ssi_get_tag_and_value(ctx, & tag, & tag_val, 1);
    if ((unsigned int )tag != (unsigned int )((void *)0)) {
      goto _L;
    } else {
      if ((unsigned int )tag_val != (unsigned int )((void *)0)) {
        _L: /* CIL Label */ 
        ap_log_rerror("mod_include.c", 2742, 3, 0, (request_rec const   *)r, "else directive does not take tags in %s",
                      r->filename);
        if (ctx->flags & 1L) {
          tmp = strlen((char const   *)ctx->error_str);
          tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp, (void (*)(void *data ))((void *)0),
                                            head_ptr->list);
          while (1) {
            ap__a = head_ptr;
            ap__b = tmp_buck;
            while (1) {
              ap__b->link.next = ap__a;
              ap__b->link.prev = ap__a->link.prev;
              (ap__a->link.prev)->link.next = ap__b;
              ap__a->link.prev = ap__b;
              break;
            }
            break;
          }
          if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
            (*inserted_head) = tmp_buck;
          }
        }
        return (-1);
      } else {
        if (ctx->flags & 2L) {
          ctx->flags = (long )((unsigned long )ctx->flags & 4294967294UL);
        } else {
          ctx->flags |= 3L;
        }
        return (0);
      }
    }
  }
  return (0);
}
}
static int handle_endif(include_ctx_t *ctx , apr_bucket_brigade **bb , request_rec *r ,
                        ap_filter_t *f , apr_bucket *head_ptr , apr_bucket **inserted_head ) 
{ char *tag ;
  char *tag_val ;
  apr_bucket *tmp_buck ;
  apr_size_t tmp ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b ;

  {
  tag = (char *)((void *)0);
  tag_val = (char *)((void *)0);
  (*inserted_head) = (apr_bucket *)((void *)0);
  if (! ctx->if_nesting_level) {
    ap_ssi_get_tag_and_value(ctx, & tag, & tag_val, 1);
    if ((unsigned int )tag != (unsigned int )((void *)0)) {
      goto _L;
    } else {
      if ((unsigned int )tag_val != (unsigned int )((void *)0)) {
        _L: /* CIL Label */ 
        ap_log_rerror("mod_include.c", 2776, 3, 0, (request_rec const   *)r, "endif directive does not take tags in %s",
                      r->filename);
        tmp = strlen((char const   *)ctx->error_str);
        tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp, (void (*)(void *data ))((void *)0),
                                          head_ptr->list);
        while (1) {
          ap__a = head_ptr;
          ap__b = tmp_buck;
          while (1) {
            ap__b->link.next = ap__a;
            ap__b->link.prev = ap__a->link.prev;
            (ap__a->link.prev)->link.next = ap__b;
            ap__a->link.prev = ap__b;
            break;
          }
          break;
        }
        if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
          (*inserted_head) = tmp_buck;
        }
        return (-1);
      } else {
        ctx->flags |= 3L;
        return (0);
      }
    }
  } else {
    ctx->if_nesting_level --;
    return (0);
  }
}
}
static int handle_set(include_ctx_t *ctx , apr_bucket_brigade **bb , request_rec *r ,
                      ap_filter_t *f , apr_bucket *head_ptr , apr_bucket **inserted_head ) 
{ char *tag ;
  char *tag_val ;
  char *var ;
  apr_bucket *tmp_buck ;
  char *parsed_string ;
  request_rec *sub ;
  apr_pool_t *p ;
  apr_size_t tmp ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  apr_size_t tmp___2 ;
  apr_bucket *ap__a___0 ;
  apr_bucket *ap__b___0 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  tag = (char *)((void *)0);
  tag_val = (char *)((void *)0);
  var = (char *)((void *)0);
  sub = r->main;
  p = r->pool;
  while (sub) {
    p = sub->pool;
    sub = sub->main;
  }
  (*inserted_head) = (apr_bucket *)((void *)0);
  if (ctx->flags & 1L) {
    while (1) {
      ap_ssi_get_tag_and_value(ctx, & tag, & tag_val, 1);
      if ((unsigned int )tag == (unsigned int )((void *)0)) {
        if ((unsigned int )tag_val == (unsigned int )((void *)0)) {
          return (0);
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        if ((unsigned int )tag_val == (unsigned int )((void *)0)) {
          return (1);
        } else {
          tmp___4 = strcmp((char const   *)tag, "var");
          if (tmp___4) {
            tmp___3 = strcmp((char const   *)tag, "value");
            if (tmp___3) {
              ap_log_rerror("mod_include.c", 2842, 3, 0, (request_rec const   *)r,
                            "Invalid tag for set directive in %s", r->filename);
              tmp___2 = strlen((char const   *)ctx->error_str);
              tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp___2,
                                                (void (*)(void *data ))((void *)0),
                                                head_ptr->list);
              while (1) {
                ap__a___0 = head_ptr;
                ap__b___0 = tmp_buck;
                while (1) {
                  ap__b___0->link.next = ap__a___0;
                  ap__b___0->link.prev = ap__a___0->link.prev;
                  (ap__a___0->link.prev)->link.next = ap__b___0;
                  ap__a___0->link.prev = ap__b___0;
                  break;
                }
                break;
              }
              if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
                (*inserted_head) = tmp_buck;
              }
              return (-1);
            } else {
              if ((unsigned int )var == (unsigned int )((char *)((void *)0))) {
                ap_log_rerror("mod_include.c", 2829, 3, 0, (request_rec const   *)r,
                              "variable must precede value in set directive in %s",
                              r->filename);
                tmp = strlen((char const   *)ctx->error_str);
                tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str,
                                                  tmp, (void (*)(void *data ))((void *)0),
                                                  head_ptr->list);
                while (1) {
                  ap__a = head_ptr;
                  ap__b = tmp_buck;
                  while (1) {
                    ap__b->link.next = ap__a;
                    ap__b->link.prev = ap__a->link.prev;
                    (ap__a->link.prev)->link.next = ap__b;
                    ap__a->link.prev = ap__b;
                    break;
                  }
                  break;
                }
                if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
                  (*inserted_head) = tmp_buck;
                }
                return (-1);
              }
              parsed_string = ap_ssi_parse_string(r, ctx, (char const   *)tag_val,
                                                  (char *)((void *)0), 8192U, 0);
              tmp___0 = apr_pstrdup(p, (char const   *)parsed_string);
              tmp___1 = apr_pstrdup(p, (char const   *)var);
              apr_table_setn(r->subprocess_env, tmp___1, tmp___0);
            }
          } else {
            var = ap_ssi_parse_string(r, ctx, (char const   *)tag_val, (char *)((void *)0),
                                      8192U, 0);
          }
        }
      }
    }
  }
  return (0);
}
}
static int handle_printenv(include_ctx_t *ctx , apr_bucket_brigade **bb , request_rec *r ,
                           ap_filter_t *f , apr_bucket *head_ptr , apr_bucket **inserted_head ) 
{ char *tag ;
  char *tag_val ;
  apr_bucket *tmp_buck ;
  apr_array_header_t const   *arr ;
  apr_array_header_t const   *tmp ;
  apr_table_entry_t const   *elts ;
  int i ;
  char const   *key_text ;
  char const   *val_text ;
  char *key_val ;
  char *next ;
  apr_size_t k_len ;
  apr_size_t v_len ;
  apr_size_t kv_length ;
  char *tmp___0 ;
  char *tmp___1 ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b ;
  apr_size_t tmp___2 ;
  apr_bucket *ap__a___0 ;
  apr_bucket *ap__b___0 ;

  {
  tag = (char *)((void *)0);
  tag_val = (char *)((void *)0);
  if (ctx->flags & 1L) {
    ap_ssi_get_tag_and_value(ctx, & tag, & tag_val, 1);
    if ((unsigned int )tag == (unsigned int )((void *)0)) {
      if ((unsigned int )tag_val == (unsigned int )((void *)0)) {
        tmp = apr_table_elts((apr_table_t const   *)r->subprocess_env);
        arr = tmp;
        elts = (apr_table_entry_t const   *)arr->elts;
        (*inserted_head) = (apr_bucket *)((void *)0);
        i = 0;
        while (i < arr->nelts) {
          key_text = ap_escape_html(r->pool, (char const   *)(elts + i)->key);
          val_text = (char const   *)(elts + i)->val;
          if ((unsigned int )val_text == (unsigned int )(& lazy_eval_sentinel)) {
            val_text = add_include_vars_lazy(r, (char const   *)(elts + i)->key);
          }
          val_text = ap_escape_html(r->pool, (char const   *)(elts + i)->val);
          k_len = strlen(key_text);
          v_len = strlen(val_text);
          kv_length = (k_len + v_len) + sizeof("=\n");
          key_val = (char *)apr_palloc(r->pool, kv_length);
          next = key_val;
          memcpy((void * __restrict  )next, (void const   * __restrict  )key_text,
                 k_len);
          next += k_len;
          tmp___0 = next;
          next ++;
          (*tmp___0) = (char )'=';
          memcpy((void * __restrict  )next, (void const   * __restrict  )val_text,
                 v_len);
          next += v_len;
          tmp___1 = next;
          next ++;
          (*tmp___1) = (char )'\n';
          (*next) = (char)0;
          tmp_buck = apr_bucket_pool_create((char const   *)key_val, kv_length - 1U,
                                            r->pool, (r->connection)->bucket_alloc);
          while (1) {
            ap__a = head_ptr;
            ap__b = tmp_buck;
            while (1) {
              ap__b->link.next = ap__a;
              ap__b->link.prev = ap__a->link.prev;
              (ap__a->link.prev)->link.next = ap__b;
              ap__a->link.prev = ap__b;
              break;
            }
            break;
          }
          if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
            (*inserted_head) = tmp_buck;
          }
          i ++;
        }
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      ap_log_rerror("mod_include.c", 2901, 3, 0, (request_rec const   *)r, "printenv directive does not take tags in %s",
                    r->filename);
      tmp___2 = strlen((char const   *)ctx->error_str);
      tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp___2, (void (*)(void *data ))((void *)0),
                                        head_ptr->list);
      while (1) {
        ap__a___0 = head_ptr;
        ap__b___0 = tmp_buck;
        while (1) {
          ap__b___0->link.next = ap__a___0;
          ap__b___0->link.prev = ap__a___0->link.prev;
          (ap__a___0->link.prev)->link.next = ap__b___0;
          ap__a___0->link.prev = ap__b___0;
          break;
        }
        break;
      }
      if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
        (*inserted_head) = tmp_buck;
      }
      return (-1);
    }
  }
  return (0);
}
}
static apr_status_t send_parsed_content(apr_bucket_brigade **bb , request_rec *r ,
                                        ap_filter_t *f ) 
{ include_ctx_t *ctx ;
  apr_bucket *dptr ;
  apr_bucket *tmp_dptr ;
  apr_bucket_brigade *tag_and_after ;
  apr_status_t rv ;
  char *arg_copy ;
  char *tmp ;
  char const   *tmp___0 ;
  int do_cleanup ;
  apr_size_t cleanup_bytes ;
  apr_bucket *tmp_bkt ;
  apr_bucket *ap__b ;
  apr_bucket *free_bucket ;
  apr_bucket *ap__b___0 ;
  apr_bucket *tmp___1 ;
  apr_bucket_brigade *tag_plus ;
  apr_bucket *ap__b___1 ;
  apr_bucket *tmp___2 ;
  apr_bucket *content_head ;
  apr_bucket *tmp_bkt___0 ;
  apr_size_t tmp_i ;
  char tmp_buf[1024] ;
  int (*handle_func)(include_ctx_t * , apr_bucket_brigade ** , request_rec * , ap_filter_t * ,
                     apr_bucket * , apr_bucket ** ) ;
  apr_size_t tmp___3 ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b___2 ;
  apr_status_t tmp___4 ;
  apr_size_t tmp___6 ;
  apr_bucket *ap__a___0 ;
  apr_bucket *ap__b___3 ;
  apr_status_t tmp___7 ;
  apr_status_t tmp___8 ;
  apr_bucket *free_bucket___0 ;
  apr_bucket *content_head___0 ;
  apr_bucket *tmp_bkt___1 ;
  apr_size_t tmp___9 ;
  apr_bucket *ap__a___1 ;
  apr_bucket *ap__b___4 ;
  apr_bucket *last ;
  apr_bucket *b ;
  apr_bucket *err_bucket ;
  apr_size_t tmp___10 ;
  apr_bucket *ap__a___2 ;
  apr_bucket *ap__b___5 ;

  {
  ctx = (include_ctx_t *)f->ctx;
  dptr = ((*bb))->list.next;
  rv = 0;
  if (r->args) {
    tmp = apr_pstrdup(r->pool, (char const   *)r->args);
    arg_copy = tmp;
    apr_table_setn(r->subprocess_env, "QUERY_STRING", (char const   *)r->args);
    ap_unescape_url(arg_copy);
    tmp___0 = ap_escape_shell_cmd(r->pool, (char const   *)arg_copy);
    apr_table_setn(r->subprocess_env, "QUERY_STRING_UNESCAPED", tmp___0);
  }
  while (1) {
    if ((unsigned int )dptr != (unsigned int )((struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                     (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                             (char *)((void *)0))))) {
      if (! (! ((unsigned int )dptr->type == (unsigned int )(& apr_bucket_type_eos)))) {
        goto _L___15;
      }
    } else {
      _L___15: /* CIL Label */ 
      break;
    }
    if ((int )ctx->state == 0) {
      goto _L___6;
    } else {
      if ((int )ctx->state == 1) {
        _L___6: /* CIL Label */ 
        do_cleanup = 0;
        cleanup_bytes = ctx->parse_pos;
        tmp_dptr = find_start_sequence(dptr, ctx, (*bb), & do_cleanup);
        if (! (ctx->status == 0)) {
          return (ctx->status);
        }
        if (do_cleanup) {
          if (! ((unsigned int )(ctx->ssi_tag_brigade)->list.next == (unsigned int )((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                                                           (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                                   (char *)((void *)0)))))) {
            tmp_bkt = apr_bucket_immortal_create((char const   *)ctx->start_seq, cleanup_bytes,
                                                 (r->connection)->bucket_alloc);
            while (1) {
              ap__b = tmp_bkt;
              while (1) {
                ap__b->link.prev = (struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                         (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0)));
                ap__b->link.next = ((struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                          (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                  (char *)((void *)0))))->link.next;
                (((struct apr_bucket *)((char *)(& ((*bb))->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                            (char *)((void *)0))))->link.next)->link.prev = ap__b;
                ((struct apr_bucket *)((char *)(& ((*bb))->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                           (char *)((void *)0))))->link.next = ap__b;
                break;
              }
              break;
            }
            apr_brigade_cleanup((void *)ctx->ssi_tag_brigade);
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ ;
        }
        if (! (ctx->flags & 1L)) {
          if ((unsigned int )tmp_dptr != (unsigned int )((void *)0)) {
            if ((unsigned int )dptr != (unsigned int )((struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                             (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                     (char *)((void *)0))))) {
              while (1) {
                if ((unsigned int )dptr != (unsigned int )((struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                                 (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                         (char *)((void *)0))))) {
                  if (! ((unsigned int )dptr != (unsigned int )tmp_dptr)) {
                    goto _L___0;
                  }
                } else {
                  _L___0: /* CIL Label */ 
                  break;
                }
                free_bucket = dptr;
                dptr = dptr->link.next;
                while (1) {
                  while (1) {
                    (free_bucket->link.prev)->link.next = free_bucket->link.next;
                    (free_bucket->link.next)->link.prev = free_bucket->link.prev;
                    break;
                  }
                  while (1) {
                    ((*((free_bucket->type)->destroy)))(free_bucket->data);
                    ((*(free_bucket->free)))((void *)free_bucket);
                    break;
                  }
                  break;
                }
              }
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ ;
        }
        if ((unsigned int )tmp_dptr != (unsigned int )((void *)0)) {
          if ((int )ctx->state == 2) {
            if ((unsigned int )ctx->tag_start_bucket != (unsigned int )((void *)0)) {
              dptr = ctx->tag_start_bucket;
            } else {
              dptr = (struct apr_bucket *)((char *)(& ((*bb))->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                               (char *)((void *)0)));
            }
          } else {
            goto _L___5;
          }
        } else {
          _L___5: /* CIL Label */ 
          if ((unsigned int )tmp_dptr != (unsigned int )((void *)0)) {
            if (ctx->output_now) {
              goto _L___4;
            } else {
              if (ctx->bytes_parsed >= 8000) {
                _L___4: /* CIL Label */ 
                tag_and_after = apr_brigade_split((*bb), tmp_dptr);
                if (ctx->output_flush) {
                  while (1) {
                    tmp___1 = apr_bucket_flush_create(((*bb))->bucket_alloc);
                    ap__b___0 = tmp___1;
                    while (1) {
                      ap__b___0->link.next = (struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                   (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                           (char *)((void *)0)));
                      ap__b___0->link.prev = ((struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                    (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                            (char *)((void *)0))))->link.prev;
                      (((struct apr_bucket *)((char *)(& ((*bb))->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                  (char *)((void *)0))))->link.prev)->link.next = ap__b___0;
                      ((struct apr_bucket *)((char *)(& ((*bb))->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                 (char *)((void *)0))))->link.prev = ap__b___0;
                      break;
                    }
                    break;
                  }
                }
                rv = ap_pass_brigade(f->next, (*bb));
                if (rv != 0) {
                  return (rv);
                }
                (*bb) = tag_and_after;
                dptr = tmp_dptr;
                ctx->output_flush = 0;
                ctx->bytes_parsed = 0;
                ctx->output_now = 0;
              } else {
                goto _L___3;
              }
            }
          } else {
            _L___3: /* CIL Label */ 
            if ((unsigned int )tmp_dptr == (unsigned int )((void *)0)) {
              dptr = (struct apr_bucket *)((char *)(& ((*bb))->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                               (char *)((void *)0)));
            }
          }
        }
      }
    }
    if ((int )ctx->state == 2) {
      goto _L___11;
    } else {
      if ((int )ctx->state == 3) {
        _L___11: /* CIL Label */ 
        goto _L___10;
      } else {
        if ((int )ctx->state == 4) {
          _L___10: /* CIL Label */ 
          if ((unsigned int )dptr != (unsigned int )((struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                           (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                   (char *)((void *)0))))) {
            tmp_dptr = find_end_sequence(dptr, ctx, (*bb));
            if (! (ctx->status == 0)) {
              return (ctx->status);
            }
            if ((unsigned int )tmp_dptr != (unsigned int )((void *)0)) {
              dptr = tmp_dptr;
              if (! ((unsigned int )(ctx->ssi_tag_brigade)->list.next == (unsigned int )((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                                                               (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                                       (char *)((void *)0)))))) {
                tag_and_after = apr_brigade_split((*bb), dptr);
                while (1) {
                  if (! ((unsigned int )((*bb))->list.next == (unsigned int )((struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                                                    (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                            (char *)((void *)0)))))) {
                    while (1) {
                      (((*bb))->list.prev)->link.next = (struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                              (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                      (char *)((void *)0)));
                      (((*bb))->list.next)->link.prev = ((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                               (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0))))->link.prev;
                      (((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                              (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                      (char *)((void *)0))))->link.prev)->link.next = ((*bb))->list.next;
                      ((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                             (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                     (char *)((void *)0))))->link.prev = ((*bb))->list.prev;
                      break;
                    }
                    while (1) {
                      ((*bb))->list.next = (struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                 (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                         (char *)((void *)0)));
                      ((*bb))->list.prev = (struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                 (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                         (char *)((void *)0)));
                      break;
                    }
                  }
                  break;
                }
                (*bb) = tag_and_after;
              } else {
                if (ctx->output_now) {
                  goto _L___8;
                } else {
                  if (ctx->bytes_parsed >= 8000) {
                    _L___8: /* CIL Label */ 
                    if ((unsigned int )(ctx->ssi_tag_brigade)->list.next == (unsigned int )((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                                                                  (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                                          (char *)((void *)0))))) {
                      if ((unsigned int )ctx->head_start_bucket != (unsigned int )((void *)0)) {
                        tag_plus = apr_brigade_split((*bb), ctx->head_start_bucket);
                        if (ctx->output_flush) {
                          while (1) {
                            tmp___2 = apr_bucket_flush_create(((*bb))->bucket_alloc);
                            ap__b___1 = tmp___2;
                            while (1) {
                              ap__b___1->link.next = (struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                           (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                   (char *)((void *)0)));
                              ap__b___1->link.prev = ((struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                            (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                    (char *)((void *)0))))->link.prev;
                              (((struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                      (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                              (char *)((void *)0))))->link.prev)->link.next = ap__b___1;
                              ((struct apr_bucket *)((char *)(& ((*bb))->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                         (char *)((void *)0))))->link.prev = ap__b___1;
                              break;
                            }
                            break;
                          }
                        }
                        rv = ap_pass_brigade(f->next, (*bb));
                        ctx->bytes_parsed = 0;
                        (*bb) = tag_plus;
                      } else {
                        goto _L___7;
                      }
                    } else {
                      _L___7: /* CIL Label */ ;
                    }
                    if (rv != 0) {
                      return (rv);
                    }
                    ctx->output_flush = 0;
                    ctx->output_now = 0;
                  }
                }
              }
            } else {
              dptr = (struct apr_bucket *)((char *)(& ((*bb))->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                               (char *)((void *)0)));
            }
          } else {
            goto _L___9;
          }
        } else {
          _L___9: /* CIL Label */ ;
        }
      }
    }
    if ((int )ctx->state == 5) {
      content_head = (apr_bucket *)((void *)0);
      tmp___4 = get_combined_directive(ctx, r, (*bb), tmp_buf, 1024U);
      if (tmp___4 != 0) {
        ap_log_rerror("mod_include.c", 3067, 3, 0, (request_rec const   *)r, "mod_include: error copying directive in %s",
                      r->filename);
        tmp___3 = strlen((char const   *)ctx->error_str);
        tmp_bkt___0 = apr_bucket_heap_create((char const   *)ctx->error_str, tmp___3,
                                             (void (*)(void *data ))((void *)0), dptr->list);
        while (1) {
          ap__a = dptr;
          ap__b___2 = tmp_bkt___0;
          while (1) {
            ap__b___2->link.next = ap__a;
            ap__b___2->link.prev = ap__a->link.prev;
            (ap__a->link.prev)->link.next = ap__b___2;
            ap__a->link.prev = ap__b___2;
            break;
          }
          break;
        }
        if ((unsigned int )content_head == (unsigned int )((void *)0)) {
          content_head = tmp_bkt___0;
        }
        tmp_dptr = ctx->head_start_bucket;
        if (! ((unsigned int )(ctx->ssi_tag_brigade)->list.next == (unsigned int )((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                                                         (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                                 (char *)((void *)0)))))) {
          apr_brigade_cleanup((void *)ctx->ssi_tag_brigade);
        } else {
          while (1) {
            tmp_bkt___0 = tmp_dptr;
            tmp_dptr = tmp_dptr->link.next;
            while (1) {
              while (1) {
                (tmp_bkt___0->link.prev)->link.next = tmp_bkt___0->link.next;
                (tmp_bkt___0->link.next)->link.prev = tmp_bkt___0->link.prev;
                break;
              }
              while (1) {
                ((*((tmp_bkt___0->type)->destroy)))(tmp_bkt___0->data);
                ((*(tmp_bkt___0->free)))((void *)tmp_bkt___0);
                break;
              }
              break;
            }
            if ((unsigned int )tmp_dptr != (unsigned int )dptr) {
              if (! ((unsigned int )tmp_dptr != (unsigned int )((struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                                      (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                              (char *)((void *)0)))))) {
                goto _L___12;
              }
            } else {
              _L___12: /* CIL Label */ 
              break;
            }
          }
        }
        return (0);
      }
      tmp_i = 0U;
      while (tmp_i < ctx->directive_length) {
        (*(ctx->combined_tag + tmp_i)) = (char )tolower((int )((unsigned char )(*(ctx->combined_tag +
                                                                                  tmp_i))));
        tmp_i ++;
      }
      (*(ctx->combined_tag + ctx->directive_length)) = (char )'\000';
      ctx->curr_tag_pos = ctx->combined_tag + (ctx->directive_length + 1U);
      handle_func = (int (*)(include_ctx_t * , apr_bucket_brigade ** , request_rec * ,
                             ap_filter_t * , apr_bucket * , apr_bucket ** ))apr_hash_get(include_hash,
                                                                                         (void const   *)ctx->combined_tag,
                                                                                         (int )ctx->directive_length);
      if ((unsigned int )handle_func != (unsigned int )((void *)0)) {
        rv = ((*handle_func))(ctx, bb, r, f, dptr, & content_head);
        if (rv != 0) {
          if (rv != 1) {
            return (rv);
          } else {
            goto _L___13;
          }
        } else {
          _L___13: /* CIL Label */ ;
        }
      } else {
        ap_log_rerror("mod_include.c", 3117, 3, 0, (request_rec const   *)r, "unknown directive \"%s\" in parsed doc %s",
                      ctx->combined_tag, r->filename);
        tmp___6 = strlen((char const   *)ctx->error_str);
        tmp_bkt___0 = apr_bucket_heap_create((char const   *)ctx->error_str, tmp___6,
                                             (void (*)(void *data ))((void *)0), dptr->list);
        while (1) {
          ap__a___0 = dptr;
          ap__b___3 = tmp_bkt___0;
          while (1) {
            ap__b___3->link.next = ap__a___0;
            ap__b___3->link.prev = ap__a___0->link.prev;
            (ap__a___0->link.prev)->link.next = ap__b___3;
            ap__a___0->link.prev = ap__b___3;
            break;
          }
          break;
        }
        if ((unsigned int )content_head == (unsigned int )((void *)0)) {
          content_head = tmp_bkt___0;
        }
      }
      if ((unsigned int )content_head == (unsigned int )((void *)0)) {
        content_head = dptr;
      }
      tmp_dptr = ctx->head_start_bucket;
      if (! ((unsigned int )(ctx->ssi_tag_brigade)->list.next == (unsigned int )((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                                                       (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                               (char *)((void *)0)))))) {
        apr_brigade_cleanup((void *)ctx->ssi_tag_brigade);
      } else {
        while (1) {
          tmp_bkt___0 = tmp_dptr;
          tmp_dptr = tmp_dptr->link.next;
          while (1) {
            while (1) {
              (tmp_bkt___0->link.prev)->link.next = tmp_bkt___0->link.next;
              (tmp_bkt___0->link.next)->link.prev = tmp_bkt___0->link.prev;
              break;
            }
            while (1) {
              ((*((tmp_bkt___0->type)->destroy)))(tmp_bkt___0->data);
              ((*(tmp_bkt___0->free)))((void *)tmp_bkt___0);
              break;
            }
            break;
          }
          if ((unsigned int )tmp_dptr != (unsigned int )content_head) {
            if (! ((unsigned int )tmp_dptr != (unsigned int )((struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                                    (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                            (char *)((void *)0)))))) {
              goto _L___14;
            }
          } else {
            _L___14: /* CIL Label */ 
            break;
          }
        }
      }
      if ((unsigned int )ctx->combined_tag == (unsigned int )(tmp_buf)) {
        ctx->combined_tag = (char *)((void *)0);
      }
      ctx->parse_pos = 0U;
      ctx->head_start_bucket = (apr_bucket *)((void *)0);
      ctx->head_start_index = 0U;
      ctx->tag_start_bucket = (apr_bucket *)((void *)0);
      ctx->tag_start_index = 0U;
      ctx->tail_start_bucket = (apr_bucket *)((void *)0);
      ctx->tail_start_index = 0U;
      ctx->curr_tag_pos = (char *)((void *)0);
      ctx->tag_length = 0U;
      ctx->directive_length = 0U;
      if (! ((unsigned int )(ctx->ssi_tag_brigade)->list.next == (unsigned int )((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                                                       (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                               (char *)((void *)0)))))) {
        apr_brigade_cleanup((void *)ctx->ssi_tag_brigade);
      }
      ctx->state = 0;
    }
  }
  if ((unsigned int )dptr != (unsigned int )((struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                   (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                           (char *)((void *)0))))) {
    if ((unsigned int )dptr->type == (unsigned int )(& apr_bucket_type_eos)) {
      if (! ((unsigned int )(ctx->ssi_tag_brigade)->list.next == (unsigned int )((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                                                       (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                               (char *)((void *)0)))))) {
        while (1) {
          if (! ((unsigned int )((*bb))->list.next == (unsigned int )((struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                                            (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                    (char *)((void *)0)))))) {
            while (1) {
              (((*bb))->list.prev)->link.next = (struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                      (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                              (char *)((void *)0)));
              (((*bb))->list.next)->link.prev = ((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                       (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                               (char *)((void *)0))))->link.prev;
              (((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                         (char *)((void *)0))))->link.prev)->link.next = ((*bb))->list.next;
              ((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                        (char *)((void *)0))))->link.prev = ((*bb))->list.prev;
              break;
            }
            while (1) {
              ((*bb))->list.next = (struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                         (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0)));
              ((*bb))->list.prev = (struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                         (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0)));
              break;
            }
          }
          break;
        }
        tmp___7 = ap_pass_brigade(f->next, ctx->ssi_tag_brigade);
        return (tmp___7);
      }
      tmp___8 = ap_pass_brigade(f->next, (*bb));
      return (tmp___8);
    } else {
      goto _L___16;
    }
  } else {
    _L___16: /* CIL Label */ ;
  }
  if ((int )ctx->state == 0) {
    if ((unsigned int )dptr != (unsigned int )((struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                     (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                             (char *)((void *)0))))) {
      if (! (ctx->flags & 1L)) {
        while (1) {
          free_bucket___0 = dptr;
          dptr = dptr->link.next;
          while (1) {
            while (1) {
              (free_bucket___0->link.prev)->link.next = free_bucket___0->link.next;
              (free_bucket___0->link.next)->link.prev = free_bucket___0->link.prev;
              break;
            }
            while (1) {
              ((*((free_bucket___0->type)->destroy)))(free_bucket___0->data);
              ((*(free_bucket___0->free)))((void *)free_bucket___0);
              break;
            }
            break;
          }
          if (! ((unsigned int )dptr != (unsigned int )((struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                              (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                      (char *)((void *)0)))))) {
            break;
          }
        }
      } else {
        goto _L___17;
      }
    } else {
      _L___17: /* CIL Label */ 
      rv = ap_pass_brigade(f->next, (*bb));
      if (rv != 0) {
        return (rv);
      }
      ctx->bytes_parsed = 0;
    }
  } else {
    if ((int )ctx->state == 5) {
      content_head___0 = (apr_bucket *)((void *)0);
      ap_log_rerror("mod_include.c", 3222, 3, 0, (request_rec const   *)r, "Invalid mod_include state during file %s",
                    r->filename);
      tmp___9 = strlen((char const   *)ctx->error_str);
      tmp_bkt___1 = apr_bucket_heap_create((char const   *)ctx->error_str, tmp___9,
                                           (void (*)(void *data ))((void *)0), (((*bb))->list.next)->list);
      while (1) {
        ap__a___1 = ((*bb))->list.next;
        ap__b___4 = tmp_bkt___1;
        while (1) {
          ap__b___4->link.next = ap__a___1;
          ap__b___4->link.prev = ap__a___1->link.prev;
          (ap__a___1->link.prev)->link.next = ap__b___4;
          ap__a___1->link.prev = ap__b___4;
          break;
        }
        break;
      }
      if ((unsigned int )content_head___0 == (unsigned int )((void *)0)) {
        content_head___0 = tmp_bkt___1;
      }
    } else {
      if (! ((unsigned int )(ctx->ssi_tag_brigade)->list.next == (unsigned int )((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                                                       (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                               (char *)((void *)0)))))) {
        while (1) {
          if (! ((unsigned int )((*bb))->list.next == (unsigned int )((struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                                            (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                    (char *)((void *)0)))))) {
            while (1) {
              (((*bb))->list.prev)->link.next = (struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                      (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                              (char *)((void *)0)));
              (((*bb))->list.next)->link.prev = ((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                       (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                               (char *)((void *)0))))->link.prev;
              (((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                         (char *)((void *)0))))->link.prev)->link.next = ((*bb))->list.next;
              ((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                        (char *)((void *)0))))->link.prev = ((*bb))->list.prev;
              break;
            }
            while (1) {
              ((*bb))->list.next = (struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                         (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0)));
              ((*bb))->list.prev = (struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                         (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0)));
              break;
            }
          }
          break;
        }
      } else {
        if (ctx->head_start_index > 0U) {
          ((*(((ctx->head_start_bucket)->type)->split)))(ctx->head_start_bucket, ctx->head_start_index);
          ctx->head_start_bucket = (ctx->head_start_bucket)->link.next;
          ctx->head_start_index = 0U;
        }
        tag_and_after = apr_brigade_split((*bb), ctx->head_start_bucket);
        rv = ap_pass_brigade(f->next, (*bb));
        if (rv != 0) {
          return (rv);
        }
        last = tag_and_after->list.prev;
        if ((unsigned int )last->type == (unsigned int )(& apr_bucket_type_eos)) {
          err_bucket = (apr_bucket *)((void *)0);
          b = tag_and_after->list.next;
          while (! ((unsigned int )b->type == (unsigned int )(& apr_bucket_type_eos))) {
            while (1) {
              (b->link.prev)->link.next = b->link.next;
              (b->link.next)->link.prev = b->link.prev;
              break;
            }
            while (1) {
              ((*((b->type)->destroy)))(b->data);
              ((*(b->free)))((void *)b);
              break;
            }
            b = tag_and_after->list.next;
          }
          tmp___10 = strlen((char const   *)ctx->error_str);
          err_bucket = apr_bucket_heap_create((char const   *)ctx->error_str, tmp___10,
                                              (void (*)(void *data ))((void *)0),
                                              b->list);
          while (1) {
            ap__a___2 = b;
            ap__b___5 = err_bucket;
            while (1) {
              ap__b___5->link.next = ap__a___2;
              ap__b___5->link.prev = ap__a___2->link.prev;
              (ap__a___2->link.prev)->link.next = ap__b___5;
              ap__a___2->link.prev = ap__b___5;
              break;
            }
            break;
          }
          if ((unsigned int )err_bucket == (unsigned int )((void *)0)) {
            err_bucket = err_bucket;
          }
          rv = ap_pass_brigade(f->next, tag_and_after);
        } else {
          ap_save_brigade(f, & ctx->ssi_tag_brigade, & tag_and_after, r->pool);
        }
        if (rv != 0) {
          return (rv);
        }
        ctx->bytes_parsed = 0;
      }
    }
  }
  return (0);
}
}
static void *create_includes_dir_config(apr_pool_t *p , char *dummy ) 
{ include_dir_config *result ;
  include_dir_config *tmp ;
  enum xbithack *xbh ;
  enum xbithack *tmp___0 ;

  {
  tmp = (include_dir_config *)apr_palloc(p, sizeof(include_dir_config ));
  result = tmp;
  tmp___0 = (enum xbithack *)apr_palloc(p, sizeof(enum xbithack ));
  xbh = tmp___0;
  (*xbh) = 0;
  result->default_error_msg = (char *)"[an error occurred while processing this directive]";
  result->default_time_fmt = (char *)"%A, %d-%b-%Y %H:%M:%S %Z";
  result->xbithack = xbh;
  return ((void *)result);
}
}
static void *create_includes_server_config(apr_pool_t *p , server_rec *server ) 
{ include_server_config *result ;
  include_server_config *tmp ;

  {
  tmp = (include_server_config *)apr_palloc(p, sizeof(include_server_config ));
  result = tmp;
  result->default_end_tag = (char *)"-->";
  result->default_start_tag = (char *)"<!--#";
  result->start_tag_len = (int )(sizeof("<!--#") - 1U);
  bndm_compile(& result->start_seq_pat, (char const   *)result->default_start_tag,
               (unsigned int )result->start_tag_len);
  result->undefinedEcho = apr_pstrdup(p, "(none)");
  result->undefinedEchoLen = (int )strlen((char const   *)result->undefinedEcho);
  return ((void *)result);
}
}
static char const   *set_xbithack(cmd_parms *cmd , void *xbp , char const   *arg ) 
{ include_dir_config *conf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  conf = (include_dir_config *)xbp;
  tmp___1 = strcasecmp(arg, "off");
  if (tmp___1) {
    tmp___0 = strcasecmp(arg, "on");
    if (tmp___0) {
      tmp = strcasecmp(arg, "full");
      if (tmp) {
        return ("XBitHack must be set to Off, On, or Full");
      } else {
        (*(conf->xbithack)) = 2;
      }
    } else {
      (*(conf->xbithack)) = 1;
    }
  } else {
    (*(conf->xbithack)) = 0;
  }
  return ((char const   *)((void *)0));
}
}
static int includes_setup(ap_filter_t *f ) 
{ include_dir_config *conf ;

  {
  conf = (include_dir_config *)(*((void **)(f->r)->per_dir_config + include_module.module_index));
  if ((int )(*(conf->xbithack)) != 2) {
    goto _L___0;
  } else {
    if (! ((f->r)->finfo.valid & 2097152)) {
      _L___0: /* CIL Label */ 
      goto _L;
    } else {
      if (! ((f->r)->finfo.protection & 16)) {
        _L: /* CIL Label */ 
        (f->r)->no_local_copy = 1;
      }
    }
  }
  return (0);
}
}
static apr_status_t includes_filter(ap_filter_t *f , apr_bucket_brigade *b ) 
{ request_rec *r ;
  include_ctx_t *ctx ;
  request_rec *parent ;
  include_dir_config *conf ;
  include_server_config *sconf ;
  apr_status_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  apr_status_t tmp___3 ;

  {
  r = f->r;
  ctx = (include_ctx_t *)f->ctx;
  conf = (include_dir_config *)(*((void **)r->per_dir_config + include_module.module_index));
  sconf = (include_server_config *)(*((void **)(r->server)->module_config + include_module.module_index));
  tmp___0 = ap_allow_options(r);
  if (! (tmp___0 & 2)) {
    tmp = ap_pass_brigade(f->next, b);
    return (tmp);
  }
  if (! f->ctx) {
    tmp___1 = apr_palloc((f->c)->pool, sizeof((*ctx)));
    ctx = (include_ctx_t *)memset(tmp___1, 0, sizeof((*ctx)));
    f->ctx = (void *)ctx;
    ctx->state = 0;
    ctx->flags = 3L;
    tmp___2 = ap_allow_options(r);
    if (tmp___2 & 32) {
      ctx->flags |= 8L;
    }
    ctx->ssi_tag_brigade = apr_brigade_create((f->c)->pool, (f->c)->bucket_alloc);
    ctx->status = 0;
    ctx->error_str = conf->default_error_msg;
    ctx->time_str = conf->default_time_fmt;
    ctx->pool = (f->c)->pool;
    ctx->start_seq_pat = & sconf->start_seq_pat;
    ctx->start_seq = sconf->default_start_tag;
    ctx->start_seq_len = sconf->start_tag_len;
    ctx->end_seq = sconf->default_end_tag;
  } else {
    ctx->bytes_parsed = 0;
  }
  parent = (request_rec *)(*((void **)r->request_config + include_module.module_index));
  if (parent) {
    r->subprocess_env = (r->main)->subprocess_env;
    r->finfo.mtime = (r->main)->finfo.mtime;
  } else {
    ap_add_common_vars(r);
    ap_add_cgi_vars(r);
    add_include_vars(r, conf->default_time_fmt);
  }
  apr_table_unset((f->r)->headers_out, "Content-Length");
  apr_table_unset((f->r)->headers_out, "ETag");
  if ((int )(*(conf->xbithack)) == 2) {
    if (r->finfo.valid & 2097152) {
      if (r->finfo.protection & 16) {
        ap_update_mtime(r, r->finfo.mtime);
        ap_set_last_modified(r);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    apr_table_unset((f->r)->headers_out, "Last-Modified");
  }
  tmp___3 = send_parsed_content(& b, r, f);
  return (tmp___3);
}
}
static void ap_register_include_handler(char *tag , include_handler_fn_t *func ) 
{ apr_ssize_t tmp ;

  {
  tmp = (apr_ssize_t )strlen((char const   *)tag);
  apr_hash_set(include_hash, (void const   *)tag, tmp, (void const   *)func);
  return;
}
}
static int include_post_config(apr_pool_t *p , apr_pool_t *plog , apr_pool_t *ptemp ,
                               server_rec *s ) 
{ 

  {
  include_hash = apr_hash_make(p);
  ssi_pfn_register = (apr_OFN_ap_register_include_handler_t *)apr_dynamic_fn_retrieve("ap_register_include_handler");
  if (ssi_pfn_register) {
    ((*ssi_pfn_register))((char *)"if", & handle_if);
    ((*ssi_pfn_register))((char *)"set", & handle_set);
    ((*ssi_pfn_register))((char *)"else", & handle_else);
    ((*ssi_pfn_register))((char *)"elif", & handle_elif);
    ((*ssi_pfn_register))((char *)"echo", & handle_echo);
    ((*ssi_pfn_register))((char *)"endif", & handle_endif);
    ((*ssi_pfn_register))((char *)"fsize", & handle_fsize);
    ((*ssi_pfn_register))((char *)"config", & handle_config);
    ((*ssi_pfn_register))((char *)"include", & handle_include);
    ((*ssi_pfn_register))((char *)"flastmod", & handle_flastmod);
    ((*ssi_pfn_register))((char *)"printenv", & handle_printenv);
  }
  return (0);
}
}
static char const   *set_default_error_msg(cmd_parms *cmd , void *mconfig , char const   *msg ) 
{ include_dir_config *conf ;

  {
  conf = (include_dir_config *)mconfig;
  conf->default_error_msg = apr_pstrdup(cmd->pool, msg);
  return ((char const   *)((void *)0));
}
}
static char const   *set_default_start_tag(cmd_parms *cmd , void *mconfig , char const   *msg ) 
{ include_server_config *conf ;

  {
  conf = (include_server_config *)(*((void **)(cmd->server)->module_config + include_module.module_index));
  conf->default_start_tag = apr_pstrdup(cmd->pool, msg);
  conf->start_tag_len = (int )strlen((char const   *)conf->default_start_tag);
  bndm_compile(& conf->start_seq_pat, (char const   *)conf->default_start_tag, (unsigned int )conf->start_tag_len);
  return ((char const   *)((void *)0));
}
}
static char const   *set_undefined_echo(cmd_parms *cmd , void *mconfig , char const   *msg ) 
{ include_server_config *conf ;

  {
  conf = (include_server_config *)(*((void **)(cmd->server)->module_config + include_module.module_index));
  conf->undefinedEcho = apr_pstrdup(cmd->pool, msg);
  conf->undefinedEchoLen = (int )strlen(msg);
  return ((char const   *)((void *)0));
}
}
static char const   *set_default_end_tag(cmd_parms *cmd , void *mconfig , char const   *msg ) 
{ include_server_config *conf ;

  {
  conf = (include_server_config *)(*((void **)(cmd->server)->module_config + include_module.module_index));
  conf->default_end_tag = apr_pstrdup(cmd->pool, msg);
  return ((char const   *)((void *)0));
}
}
static char const   *set_default_time_fmt(cmd_parms *cmd , void *mconfig , char const   *fmt ) 
{ include_dir_config *conf ;

  {
  conf = (include_dir_config *)mconfig;
  conf->default_time_fmt = apr_pstrdup(cmd->pool, fmt);
  return ((char const   *)((void *)0));
}
}
static command_rec const   includes_cmds[7]  = {      {"XBitHack", {& set_xbithack}, (void *)0, 2, 1, "Off, On, or Full"}, 
        {"SSIErrorMsg", {& set_default_error_msg}, (void *)0, 31, 1, "a string"}, 
        {"SSITimeFormat", {& set_default_time_fmt}, (void *)0, 31, 1, "a strftime(3) formatted string"}, 
        {"SSIStartTag",
      {& set_default_start_tag}, (void *)0, 128, 1, "SSI Start String Tag"}, 
        {"SSIEndTag", {& set_default_end_tag}, (void *)0, 128, 1, "SSI End String Tag"}, 
        {"SSIUndefinedEcho",
      {& set_undefined_echo}, (void *)0, 128, 1, "SSI Start String Tag"}, 
        {(char const   *)((void *)0), {.no_args = (char const   *(*)(cmd_parms *parms ,
                                                                  void *mconfig ))0},
      (void *)0, 0, 0, (char const   *)0}};
static int include_fixup(request_rec *r ) 
{ include_dir_config *conf ;
  int tmp ;
  int tmp___0 ;

  {
  conf = (include_dir_config *)(*((void **)r->per_dir_config + include_module.module_index));
  if (r->handler) {
    tmp___0 = strcmp(r->handler, "server-parsed");
    if (tmp___0 == 0) {
      if (! r->content_type) {
        goto _L;
      } else {
        if (! (*(r->content_type))) {
          _L: /* CIL Label */ 
          ap_set_content_type(r, "text/html");
        }
      }
      r->handler = "default-handler";
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    if ((int )(*(conf->xbithack)) == 0) {
      return (-1);
    }
    if (! (r->finfo.protection & 256)) {
      return (-1);
    }
    if (! r->content_type) {
      goto _L___0;
    } else {
      tmp = strcmp(r->content_type, "text/html");
      if (tmp) {
        _L___0: /* CIL Label */ 
        return (-1);
      }
    }
  }
  ap_add_output_filter("INCLUDES", (void *)0, r, r->connection);
  return (-1);
}
}
static void register_hooks___1(apr_pool_t *p ) 
{ 

  {
  ((*((void (*)(char const   * , apr_OFN_ap_ssi_get_tag_and_value_t * ))(& apr_dynamic_fn_register))))("ap_ssi_get_tag_and_value",
                                                                                                       & ap_ssi_get_tag_and_value);
  ((*((void (*)(char const   * , apr_OFN_ap_ssi_parse_string_t * ))(& apr_dynamic_fn_register))))("ap_ssi_parse_string",
                                                                                                  & ap_ssi_parse_string);
  ((*((void (*)(char const   * , apr_OFN_ap_register_include_handler_t * ))(& apr_dynamic_fn_register))))("ap_register_include_handler",
                                                                                                          & ap_register_include_handler);
  ap_hook_post_config(& include_post_config, (char const   * const  *)((void *)0),
                      (char const   * const  *)((void *)0), -10);
  ap_hook_fixups(& include_fixup, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                 20);
  ap_register_output_filter("INCLUDES", & includes_filter, & includes_setup, 10);
  return;
}
}
struct module_struct include_module  = 
     {20020903, 0, -1, "mod_include.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, (void (*)(process_rec *process ))((void *)0), & create_includes_dir_config,
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), & create_includes_server_config,
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), includes_cmds,
    & register_hooks___1};
#pragma merger(0,"/tmp/cil-8314ktu1.i","-g -pthread")
extern char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__)) ;
void apr_pool_cleanup_register(apr_pool_t *p , void const   *data , apr_status_t (*plain_cleanup_fn)(void *data ) ,
                               apr_status_t (*child_cleanup_fn)(void *data ) ) ;
char *( /* format attribute */  apr_psprintf)(apr_pool_t *p , char const   *fmt  , ...) ;
char *apr_itoa(apr_pool_t *p , int n ) ;
char *apr_off_t_toa(apr_pool_t *p , apr_off_t n ) ;
apr_table_t *apr_table_overlay(apr_pool_t *p , apr_table_t const   *overlay , apr_table_t const   *base ) ;
char const   apr_month_snames[12][4] ;
apr_time_t apr_time_now(void) ;
apr_status_t apr_strftime(char *s , apr_size_t *retsize , apr_size_t max , char const   *format ,
                          apr_time_exp_t *xt ) ;
apr_status_t apr_file_open(apr_file_t **new , char const   *fname , apr_int32_t flag ,
                           apr_fileperms_t perm , apr_pool_t *pool ) ;
apr_status_t apr_file_write(apr_file_t *thefile , void const   *buf , apr_size_t *nbytes ) ;
apr_status_t apr_file_inherit_set(apr_file_t *thefile ) ;
char *apr_uri_unparse(apr_pool_t *p , apr_uri_t const   *uptr , unsigned int flags ) ;
char *ap_field_noparam(apr_pool_t *p , char const   *intype ) ;
char *ap_server_root_relative(apr_pool_t *p , char const   *file ) ;
void ap_hook_pre_config(ap_HOOK_pre_config_t *pf , char const   * const  *aszPre___1 ,
                        char const   * const  *aszSucc___2 , int nOrder ) ;
void ap_hook_open_logs(ap_HOOK_open_logs_t *pf , char const   * const  *aszPre___1 ,
                       char const   * const  *aszSucc___2 , int nOrder ) ;
void ap_hook_child_init(ap_HOOK_child_init_t *pf , char const   * const  *aszPre___1 ,
                        char const   * const  *aszSucc___2 , int nOrder ) ;
char const   *ap_get_remote_logname(request_rec *r ) ;
char const   *ap_get_server_name(request_rec *r ) ;
void ( /* format attribute */  ap_log_error)(char const   *file , int line , int level ,
                                             apr_status_t status , server_rec const   *s ,
                                             char const   *fmt  , ...) ;
piped_log *ap_open_piped_log(apr_pool_t *p , char const   *program ) ;
void ap_hook_log_transaction(ap_HOOK_log_transaction_t *pf , char const   * const  *aszPre___1 ,
                             char const   * const  *aszSucc___2 , int nOrder ) ;
unsigned short ap_run_default_port(request_rec const   *r ) ;
apr_status_t ap_explode_recent_localtime(apr_time_exp_t *tm , apr_time_t t ) ;
extern __pid_t getpid(void) ;
static int xfer_flags  =    14;
static int xfer_perms  =    4095;
static apr_hash_t *log_hash  ;
static apr_status_t ap_default_log_writer(request_rec *r , void *handle , char const   **strs ,
                                          int *strl , int nelts , apr_size_t len ) ;
static apr_status_t ap_buffered_log_writer(request_rec *r , void *handle , char const   **strs ,
                                           int *strl , int nelts , apr_size_t len ) ;
static void *ap_default_log_writer_init(apr_pool_t *p , server_rec *s , char const   *name ) ;
static void *ap_buffered_log_writer_init(apr_pool_t *p , server_rec *s , char const   *name ) ;
static void ap_log_set_writer_init(ap_log_writer_init *handle ) ;
static void ap_log_set_writer(ap_log_writer *handle ) ;
static ap_log_writer *log_writer  =    & ap_default_log_writer;
static ap_log_writer_init *log_writer_init  =    & ap_default_log_writer_init;
static int buffered_logs  =    0;
static char *format_integer(apr_pool_t *p , int i ) 
{ char *tmp ;

  {
  tmp = apr_itoa(p, i);
  return (tmp);
}
}
static char *pfmt(apr_pool_t *p , int i ) 
{ char *tmp ;

  {
  if (i <= 0) {
    return ((char *)"-");
  } else {
    tmp = format_integer(p, i);
    return (tmp);
  }
}
}
static char const   *constant_item(request_rec *dummy , char *stuff ) 
{ 

  {
  return ((char const   *)stuff);
}
}
static char const   *log_remote_host(request_rec *r , char *a ) 
{ char const   *tmp ;

  {
  tmp = ap_get_remote_host(r->connection, (void *)r->per_dir_config, 1, (int *)((void *)0));
  return (tmp);
}
}
static char const   *log_remote_address(request_rec *r , char *a ) 
{ 

  {
  return ((char const   *)(r->connection)->remote_ip);
}
}
static char const   *log_local_address(request_rec *r , char *a ) 
{ 

  {
  return ((char const   *)(r->connection)->local_ip);
}
}
static char const   *log_remote_logname(request_rec *r , char *a ) 
{ char const   *tmp ;

  {
  tmp = ap_get_remote_logname(r);
  return (tmp);
}
}
static char const   *log_remote_user(request_rec *r , char *a ) 
{ char *rvalue ;
  size_t tmp ;

  {
  rvalue = r->user;
  if ((unsigned int )rvalue == (unsigned int )((void *)0)) {
    rvalue = (char *)"-";
  } else {
    tmp = strlen((char const   *)rvalue);
    if (tmp == 0U) {
      rvalue = (char *)"\"\"";
    }
  }
  return ((char const   *)rvalue);
}
}
static char const   *log_request_line(request_rec *r , char *a ) 
{ char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;

  {
  if (r->parsed_uri.password) {
    if (r->assbackwards) {
      tmp___3 = (char const   *)((void *)0);
    } else {
      tmp___3 = " ";
    }
    tmp___4 = apr_uri_unparse(r->pool, (apr_uri_t const   *)(& r->parsed_uri), 0U);
    tmp___2 = apr_pstrcat(r->pool, r->method, " ", tmp___4, tmp___3, r->protocol,
                          (void *)0);
  } else {
    tmp___2 = r->the_request;
  }
  return ((char const   *)tmp___2);
}
}
static char const   *log_request_file(request_rec *r , char *a ) 
{ 

  {
  return ((char const   *)r->filename);
}
}
static char const   *log_request_uri(request_rec *r , char *a ) 
{ 

  {
  return ((char const   *)r->uri);
}
}
static char const   *log_request_method(request_rec *r , char *a ) 
{ 

  {
  return (r->method);
}
}
static char const   *log_request_protocol(request_rec *r , char *a ) 
{ 

  {
  return ((char const   *)r->protocol);
}
}
static char const   *log_request_query(request_rec *r , char *a ) 
{ char const   *tmp___0 ;

  {
  if ((unsigned int )r->args != (unsigned int )((void *)0)) {
    tmp___0 = apr_pstrcat(r->pool, "?", r->args, (void *)0);
  } else {
    tmp___0 = "";
  }
  return (tmp___0);
}
}
static char const   *log_status(request_rec *r , char *a ) 
{ char const   *tmp ;

  {
  tmp = pfmt(r->pool, r->status);
  return (tmp);
}
}
static char const   *clf_log_bytes_sent(request_rec *r , char *a ) 
{ char const   *tmp ;

  {
  if (! r->sent_bodyct) {
    return ("-");
  } else {
    tmp = apr_off_t_toa(r->pool, r->bytes_sent);
    return (tmp);
  }
}
}
static char const   *log_bytes_sent(request_rec *r , char *a ) 
{ char const   *tmp ;

  {
  if (! r->sent_bodyct) {
    return ("0");
  } else {
    tmp = apr_psprintf(r->pool, "%ld", r->bytes_sent);
    return (tmp);
  }
}
}
static char const   *log_header_in(request_rec *r , char *a ) 
{ char const   *tmp ;

  {
  tmp = apr_table_get((apr_table_t const   *)r->headers_in, (char const   *)a);
  return (tmp);
}
}
static char const   *log_header_out(request_rec *r , char *a ) 
{ char const   *cp ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  tmp = apr_table_get((apr_table_t const   *)r->headers_out, (char const   *)a);
  cp = tmp;
  tmp___0 = strcasecmp((char const   *)a, "Content-type");
  if (tmp___0) {
    _L: /* CIL Label */ ;
  } else {
    if (r->content_type) {
      cp = ap_field_noparam(r->pool, r->content_type);
    } else {
      goto _L;
    }
  }
  if (cp) {
    return (cp);
  }
  tmp___1 = apr_table_get((apr_table_t const   *)r->err_headers_out, (char const   *)a);
  return (tmp___1);
}
}
static char const   *log_note(request_rec *r , char *a ) 
{ char const   *tmp ;

  {
  tmp = apr_table_get((apr_table_t const   *)r->notes, (char const   *)a);
  return (tmp);
}
}
static char const   *log_env_var(request_rec *r , char *a ) 
{ char const   *tmp ;

  {
  tmp = apr_table_get((apr_table_t const   *)r->subprocess_env, (char const   *)a);
  return (tmp);
}
}
static char const   *log_cookie(request_rec *r , char *a ) 
{ char const   *cookies ;
  char const   *start_cookie ;
  char *cookie ;
  char *end_cookie ;
  size_t tmp ;

  {
  cookies = apr_table_get((apr_table_t const   *)r->headers_in, "Cookie");
  if (cookies) {
    start_cookie = strstr(cookies, (char const   *)a);
    if (start_cookie) {
      tmp = strlen((char const   *)a);
      start_cookie += tmp + 1U;
      cookie = apr_pstrdup(r->pool, start_cookie);
      end_cookie = strchr((char const   *)cookie, ';');
      if (end_cookie) {
        (*end_cookie) = (char )'\000';
      }
      return ((char const   *)cookie);
    }
  }
  return ((char const   *)((void *)0));
}
}
static char const   *log_request_time_custom(request_rec *r , char *a , apr_time_exp_t *xt ) 
{ apr_size_t retcode ;
  char tstr[8192] ;
  char const   *tmp ;

  {
  apr_strftime(tstr, & retcode, sizeof(tstr), (char const   *)a, xt);
  tmp = apr_pstrdup(r->pool, (char const   *)(tstr));
  return (tmp);
}
}
static cached_request_time request_time_cache[4]  ;
static char const   *log_request_time(request_rec *r , char *a ) 
{ apr_time_exp_t xt ;
  char const   *tmp ;
  cached_request_time *cached_time ;
  cached_request_time *tmp___0 ;
  apr_time_t request_time ;
  unsigned int t_seconds ;
  unsigned int i ;
  char sign ;
  int timz ;

  {
  if (a) {
    if ((*a)) {
      ap_explode_recent_localtime(& xt, r->request_time);
      tmp = log_request_time_custom(r, a, & xt);
      return (tmp);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    tmp___0 = (cached_request_time *)apr_palloc(r->pool, sizeof((*cached_time)));
    cached_time = tmp___0;
    request_time = r->request_time;
    t_seconds = (unsigned int )(request_time / 1000000LL);
    i = t_seconds & 3U;
    memcpy((void * __restrict  )cached_time, (void const   * __restrict  )(& request_time_cache[i]),
           sizeof((*cached_time)));
    if (t_seconds != cached_time->t) {
      goto _L;
    } else {
      if (t_seconds != cached_time->t_validate) {
        _L: /* CIL Label */ 
        ap_explode_recent_localtime(& xt, r->request_time);
        timz = xt.tm_gmtoff;
        if (timz < 0) {
          timz = - timz;
          sign = (char )'-';
        } else {
          sign = (char )'+';
        }
        cached_time->t = t_seconds;
        apr_snprintf(cached_time->timestr, 32U, "[%02d/%s/%d:%02d:%02d:%02d %c%.2d%.2d]",
                     xt.tm_mday, apr_month_snames[xt.tm_mon], xt.tm_year + 1900, xt.tm_hour,
                     xt.tm_min, xt.tm_sec, sign, timz / 3600, timz % 3600);
        cached_time->t_validate = t_seconds;
        memcpy((void * __restrict  )(& request_time_cache[i]), (void const   * __restrict  )cached_time,
               sizeof((*cached_time)));
      }
    }
    return ((char const   *)(cached_time->timestr));
  }
}
}
static char const   *log_request_duration(request_rec *r , char *a ) 
{ apr_time_t duration ;
  apr_time_t tmp ;
  char const   *tmp___0 ;

  {
  tmp = apr_time_now();
  duration = tmp - r->request_time;
  tmp___0 = apr_psprintf(r->pool, "%lld", duration / 1000000LL);
  return (tmp___0);
}
}
static char const   *log_request_duration_microseconds(request_rec *r , char *a ) 
{ apr_time_t tmp ;
  char const   *tmp___0 ;

  {
  tmp = apr_time_now();
  tmp___0 = apr_psprintf(r->pool, "%lld", tmp - r->request_time);
  return (tmp___0);
}
}
static char const   *log_virtual_host(request_rec *r , char *a ) 
{ 

  {
  return ((char const   *)(r->server)->server_hostname);
}
}
static char const   *log_server_port(request_rec *r , char *a ) 
{ int tmp___0 ;
  char const   *tmp___1 ;

  {
  if ((r->server)->port) {
    tmp___0 = (int )(r->server)->port;
  } else {
    tmp___0 = (int )ap_run_default_port((request_rec const   *)r);
  }
  tmp___1 = apr_psprintf(r->pool, "%u", tmp___0);
  return (tmp___1);
}
}
static char const   *log_server_name(request_rec *r , char *a ) 
{ char const   *tmp ;

  {
  tmp = ap_get_server_name(r);
  return (tmp);
}
}
static char const   *log_child_pid(request_rec *r , char *a ) 
{ __pid_t tmp ;
  char const   *tmp___0 ;

  {
  tmp = getpid();
  tmp___0 = apr_psprintf(r->pool, "%ld", (long )tmp);
  return (tmp___0);
}
}
static char const   *log_connection_status(request_rec *r , char *a ) 
{ 

  {
  if ((r->connection)->aborted) {
    return ("X");
  }
  if ((int )(r->connection)->keepalive == 2) {
    if (! (r->server)->keep_alive_max) {
      goto _L___0;
    } else {
      if ((r->server)->keep_alive_max - (r->connection)->keepalives > 0) {
        _L___0: /* CIL Label */ 
        return ("+");
      } else {
        goto _L;
      }
    }
  } else {
    _L: /* CIL Label */ ;
  }
  return ("-");
}
}
static char *parse_log_misc_string(apr_pool_t *p , log_format_item *it , char const   **sa ) 
{ char const   *s ;
  char *d ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  it->func = & constant_item;
  it->conditions = (apr_array_header_t *)((void *)0);
  s = (*sa);
  while (1) {
    if ((*s)) {
      if (! ((int const   )(*s) != 37)) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      break;
    }
    s ++;
  }
  it->arg = (char *)apr_palloc(p, (unsigned int )((s - (*sa)) + 1));
  d = it->arg;
  s = (*sa);
  while (1) {
    if ((*s)) {
      if (! ((int const   )(*s) != 37)) {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      break;
    }
    if ((int const   )(*s) != 92) {
      tmp = d;
      d ++;
      tmp___0 = s;
      s ++;
      (*tmp) = (char )(*tmp___0);
    } else {
      s ++;
      switch ((int )(*s)) {
      case 92: 
      tmp___1 = d;
      d ++;
      (*tmp___1) = (char )'\\';
      s ++;
      break;
      case 114: 
      tmp___2 = d;
      d ++;
      (*tmp___2) = (char )'\r';
      s ++;
      break;
      case 110: 
      tmp___3 = d;
      d ++;
      (*tmp___3) = (char )'\n';
      s ++;
      break;
      case 116: 
      tmp___4 = d;
      d ++;
      (*tmp___4) = (char )'\t';
      s ++;
      break;
      default: 
      tmp___5 = d;
      d ++;
      (*tmp___5) = (char )'\\';
      break;
      }
    }
  }
  (*d) = (char )'\000';
  (*sa) = s;
  return ((char *)((void *)0));
}
}
static char *parse_log_item(apr_pool_t *p , log_format_item *it , char const   **sa ) 
{ char const   *s ;
  ap_log_handler *handler ;
  char *tmp ;
  int i ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char dummy[2] ;
  char *tmp___4 ;

  {
  s = (*sa);
  if ((int const   )(*s) != 37) {
    tmp = parse_log_misc_string(p, it, sa);
    return (tmp);
  }
  s ++;
  it->condition_sense = 0;
  it->conditions = (apr_array_header_t *)((void *)0);
  if ((int const   )(*s) == 37) {
    it->arg = (char *)"%";
    it->func = & constant_item;
    s ++;
    (*sa) = s;
    return ((char *)((void *)0));
  }
  it->want_orig = -1;
  it->arg = (char *)"";
  while ((*s)) {
    switch ((int )(*s)) {
    case 33: 
    s ++;
    it->condition_sense = ! it->condition_sense != 0;
    break;
    case 60: 
    s ++;
    it->want_orig = 1;
    break;
    case 62: 
    s ++;
    it->want_orig = 0;
    break;
    case 44: 
    s ++;
    break;
    case 123: 
    s ++;
    it->arg = ap_getword(p, & s, (char )'}');
    break;
    case 48: ;
    case 49: ;
    case 50: ;
    case 51: ;
    case 52: ;
    case 53: ;
    case 54: ;
    case 55: ;
    case 56: ;
    case 57: 
    i = (int )((int const   )(*s) - 48);
    while (1) {
      tmp___0 = __ctype_b_loc();
      s ++;
      if (! ((int const   )(*((*tmp___0) + (int )((unsigned char )(*s)))) & 2048)) {
        break;
      }
      i = (i * 10 + (int )(*s)) - 48;
    }
    if (! it->conditions) {
      it->conditions = apr_array_make(p, 4, (int )sizeof(int ));
    }
    tmp___1 = apr_array_push(it->conditions);
    (*((int *)tmp___1)) = i;
    break;
    default: 
    tmp___2 = s;
    s ++;
    handler = (ap_log_handler *)apr_hash_get(log_hash, (void const   *)tmp___2, 1);
    if (! handler) {
      dummy[0] = (char )(*(s + -1));
      dummy[1] = (char )'\000';
      tmp___4 = apr_pstrcat(p, "Unrecognized LogFormat directive %", dummy, (void *)0);
      return (tmp___4);
    }
    it->func = handler->func;
    if (it->want_orig == -1) {
      it->want_orig = handler->want_orig_default;
    }
    (*sa) = s;
    return ((char *)((void *)0));
    }
  }
  return ((char *)"Ran off end of LogFormat parsing args to some directive");
}
}
static apr_array_header_t *parse_log_string(apr_pool_t *p , char const   *s , char const   **err ) 
{ apr_array_header_t *a ;
  apr_array_header_t *tmp ;
  char *res ;
  log_format_item *tmp___0 ;
  log_format_item *tmp___1 ;

  {
  tmp = apr_array_make(p, 30, (int )sizeof(log_format_item ));
  a = tmp;
  while ((*s)) {
    tmp___0 = (log_format_item *)apr_array_push(a);
    res = parse_log_item(p, tmp___0, & s);
    if (res) {
      (*err) = (char const   *)res;
      return ((apr_array_header_t *)((void *)0));
    }
  }
  s = "\n";
  tmp___1 = (log_format_item *)apr_array_push(a);
  parse_log_item(p, tmp___1, & s);
  return (a);
}
}
static char const   *process_item(request_rec *r , request_rec *orig , log_format_item *item ) 
{ char const   *cp ;
  int i ;
  int *conds ;
  int in_list ;
  request_rec *tmp ;
  char const   *tmp___0 ;

  {
  if (item->conditions) {
    if ((item->conditions)->nelts != 0) {
      conds = (int *)(item->conditions)->elts;
      in_list = 0;
      i = 0;
      while (i < (item->conditions)->nelts) {
        if (r->status == (*(conds + i))) {
          in_list = 1;
          break;
        }
        i ++;
      }
      if (item->condition_sense) {
        if (in_list) {
          goto _L;
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        if (! item->condition_sense) {
          if (! in_list) {
            _L: /* CIL Label */ 
            return ("-");
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ ;
        }
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ ;
  }
  if (item->want_orig) {
    tmp = orig;
  } else {
    tmp = r;
  }
  cp = ((*(item->func)))(tmp, item->arg);
  if (cp) {
    tmp___0 = cp;
  } else {
    tmp___0 = "-";
  }
  return (tmp___0);
}
}
static void flush_log(buffered_log *buf ) 
{ 

  {
  if (buf->outcnt) {
    if ((unsigned int )buf->handle != (unsigned int )((void *)0)) {
      apr_file_write(buf->handle, (void const   *)(buf->outbuf), & buf->outcnt);
      buf->outcnt = 0U;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  return;
}
}
static int config_log_transaction(request_rec *r , config_log_state *cls , apr_array_header_t *default_format ) 
{ log_format_item *items ;
  char const   **strs ;
  int *strl ;
  request_rec *orig ;
  int i ;
  apr_size_t len ;
  apr_array_header_t *format ;
  char *envar ;
  apr_status_t rv ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  len = (apr_size_t )0;
  if ((unsigned int )cls->fname == (unsigned int )((void *)0)) {
    return (-1);
  }
  if ((unsigned int )cls->condition_var != (unsigned int )((void *)0)) {
    envar = cls->condition_var;
    if ((int )(*envar) != 33) {
      tmp = apr_table_get((apr_table_t const   *)r->subprocess_env, (char const   *)envar);
      if ((unsigned int )tmp == (unsigned int )((void *)0)) {
        return (-1);
      }
    } else {
      tmp___0 = apr_table_get((apr_table_t const   *)r->subprocess_env, (char const   *)(envar +
                                                                                         1));
      if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
        return (-1);
      }
    }
  }
  if (cls->format) {
    format = cls->format;
  } else {
    format = default_format;
  }
  strs = (char const   **)apr_palloc(r->pool, sizeof(char *) * (unsigned int )format->nelts);
  strl = (int *)apr_palloc(r->pool, sizeof(int ) * (unsigned int )format->nelts);
  items = (log_format_item *)format->elts;
  orig = r;
  while (orig->prev) {
    orig = orig->prev;
  }
  while (r->next) {
    r = r->next;
  }
  i = 0;
  while (i < format->nelts) {
    (*(strs + i)) = process_item(r, orig, items + i);
    i ++;
  }
  i = 0;
  while (i < format->nelts) {
    (*(strl + i)) = (int )strlen((*(strs + i)));
    len += (apr_size_t )(*(strl + i));
    i ++;
  }
  if (! log_writer) {
    ap_log_rerror("mod_log_config.c", 903, 3, 20014, (request_rec const   *)r, "log writer isn\'t correctly setup");
    return (500);
  }
  rv = ((*log_writer))(r, cls->log_writer, strs, strl, format->nelts, len);
  return (0);
}
}
static int multi_log_transaction(request_rec *r ) 
{ multi_log_state *mls ;
  config_log_state *clsarray ;
  int i ;
  config_log_state *cls ;
  config_log_state *cls___0 ;

  {
  mls = (multi_log_state *)(*((void **)(r->server)->module_config + log_config_module.module_index));
  if ((mls->config_logs)->nelts) {
    clsarray = (config_log_state *)(mls->config_logs)->elts;
    i = 0;
    while (i < (mls->config_logs)->nelts) {
      cls = clsarray + i;
      config_log_transaction(r, cls, mls->default_format);
      i ++;
    }
  } else {
    if (mls->server_config_logs) {
      clsarray = (config_log_state *)(mls->server_config_logs)->elts;
      i = 0;
      while (i < (mls->server_config_logs)->nelts) {
        cls___0 = clsarray + i;
        config_log_transaction(r, cls___0, mls->default_format);
        i ++;
      }
    }
  }
  return (0);
}
}
static void *make_config_log_state(apr_pool_t *p , server_rec *s ) 
{ multi_log_state *mls ;

  {
  mls = (multi_log_state *)apr_palloc(p, sizeof(multi_log_state ));
  mls->config_logs = apr_array_make(p, 1, (int )sizeof(config_log_state ));
  mls->default_format_string = (char const   *)((void *)0);
  mls->default_format = (apr_array_header_t *)((void *)0);
  mls->server_config_logs = (apr_array_header_t *)((void *)0);
  mls->formats = apr_table_make(p, 4);
  apr_table_setn(mls->formats, "CLF", "%h %l %u %t \"%r\" %>s %b");
  return ((void *)mls);
}
}
static void *merge_config_log_state(apr_pool_t *p , void *basev , void *addv ) 
{ multi_log_state *base ;
  multi_log_state *add ;

  {
  base = (multi_log_state *)basev;
  add = (multi_log_state *)addv;
  add->server_config_logs = base->config_logs;
  if (! add->default_format) {
    add->default_format_string = base->default_format_string;
    add->default_format = base->default_format;
  }
  add->formats = apr_table_overlay(p, (apr_table_t const   *)base->formats, (apr_table_t const   *)add->formats);
  return ((void *)add);
}
}
static char const   *log_format(cmd_parms *cmd , void *dummy , char const   *fmt ,
                                char const   *name ) 
{ char const   *err_string ;
  multi_log_state *mls ;

  {
  err_string = (char const   *)((void *)0);
  mls = (multi_log_state *)(*((void **)(cmd->server)->module_config + log_config_module.module_index));
  if ((unsigned int )name != (unsigned int )((void *)0)) {
    parse_log_string(cmd->pool, fmt, & err_string);
    if ((unsigned int )err_string == (unsigned int )((void *)0)) {
      apr_table_setn(mls->formats, name, fmt);
    }
  } else {
    mls->default_format_string = fmt;
    mls->default_format = parse_log_string(cmd->pool, fmt, & err_string);
  }
  return (err_string);
}
}
static char const   *add_custom_log(cmd_parms *cmd , void *dummy , char const   *fn ,
                                    char const   *fmt , char const   *envclause ) 
{ char const   *err_string ;
  multi_log_state *mls ;
  config_log_state *cls ;
  int tmp___0 ;

  {
  err_string = (char const   *)((void *)0);
  mls = (multi_log_state *)(*((void **)(cmd->server)->module_config + log_config_module.module_index));
  cls = (config_log_state *)apr_array_push(mls->config_logs);
  cls->condition_var = (char *)((void *)0);
  if ((unsigned int )envclause != (unsigned int )((void *)0)) {
    tmp___0 = strncasecmp(envclause, "env=", 4U);
    if (tmp___0 != 0) {
      return ("error in condition clause");
    }
    if ((int const   )(*(envclause + 4)) == 0) {
      goto _L;
    } else {
      if ((int const   )(*(envclause + 4)) == 33) {
        if ((int const   )(*(envclause + 5)) == 0) {
          _L: /* CIL Label */ 
          return ("missing environment variable name");
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ ;
      }
    }
    cls->condition_var = apr_pstrdup(cmd->pool, envclause + 4);
  }
  cls->fname = fn;
  cls->format_string = fmt;
  if ((unsigned int )fmt == (unsigned int )((void *)0)) {
    cls->format = (apr_array_header_t *)((void *)0);
  } else {
    cls->format = parse_log_string(cmd->pool, fmt, & err_string);
  }
  cls->log_writer = (void *)0;
  return (err_string);
}
}
static char const   *set_transfer_log(cmd_parms *cmd , void *dummy , char const   *fn ) 
{ char const   *tmp ;

  {
  tmp = add_custom_log(cmd, dummy, fn, (char const   *)((void *)0), (char const   *)((void *)0));
  return (tmp);
}
}
static char const   *set_cookie_log(cmd_parms *cmd , void *dummy , char const   *fn ) 
{ char const   *tmp ;

  {
  tmp = add_custom_log(cmd, dummy, fn, "%{Cookie}n \"%r\" %t", (char const   *)((void *)0));
  return (tmp);
}
}
static char const   *set_buffered_logs_on(cmd_parms *parms , void *dummy , int flag ) 
{ 

  {
  buffered_logs = flag;
  ap_log_set_writer_init(& ap_buffered_log_writer_init);
  ap_log_set_writer(& ap_buffered_log_writer);
  return ((char const   *)((void *)0));
}
}
static command_rec const   config_log_cmds[6]  = {      {"CustomLog", {& add_custom_log}, (void *)0, 128, 9, "a file name, a custom log format string or format name, and an optional \"env=\" clause (see docs)"}, 
        {"TransferLog",
      {& set_transfer_log}, (void *)0, 128, 1, "the filename of the access log"}, 
        {"LogFormat", {& log_format}, (void *)0, 128, 7, "a log format string (see docs) and an optional format name"}, 
        {"CookieLog",
      {& set_cookie_log}, (void *)0, 128, 1, "the filename of the cookie log"}, 
        {"BufferedLogs", {& set_buffered_logs_on}, (void *)0, 128, 5, "Enable Buffered Logging (experimental)"}, 
        {(char const   *)((void *)0),
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))0}, (void *)0,
      0, 0, (char const   *)0}};
static config_log_state *open_config_log(server_rec *s , apr_pool_t *p , config_log_state *cls ,
                                         apr_array_header_t *default_format ) 
{ 

  {
  if ((unsigned int )cls->log_writer != (unsigned int )((void *)0)) {
    return (cls);
  }
  if ((unsigned int )cls->fname == (unsigned int )((void *)0)) {
    return (cls);
  }
  cls->log_writer = ((*log_writer_init))(p, s, cls->fname);
  if ((unsigned int )cls->log_writer == (unsigned int )((void *)0)) {
    return ((config_log_state *)((void *)0));
  }
  return (cls);
}
}
static int open_multi_logs(server_rec *s , apr_pool_t *p ) 
{ int i ;
  multi_log_state *mls ;
  config_log_state *clsarray ;
  char const   *dummy ;
  char const   *format ;
  config_log_state *cls ;
  config_log_state *tmp ;
  config_log_state *cls___0 ;
  config_log_state *tmp___0 ;

  {
  mls = (multi_log_state *)(*((void **)s->module_config + log_config_module.module_index));
  if (mls->default_format_string) {
    format = apr_table_get((apr_table_t const   *)mls->formats, mls->default_format_string);
    if (format) {
      mls->default_format = parse_log_string(p, format, & dummy);
    }
  }
  if (! mls->default_format) {
    mls->default_format = parse_log_string(p, "%h %l %u %t \"%r\" %>s %b", & dummy);
  }
  if ((mls->config_logs)->nelts) {
    clsarray = (config_log_state *)(mls->config_logs)->elts;
    i = 0;
    while (i < (mls->config_logs)->nelts) {
      cls = clsarray + i;
      if (cls->format_string) {
        format = apr_table_get((apr_table_t const   *)mls->formats, cls->format_string);
        if (format) {
          cls->format = parse_log_string(p, format, & dummy);
        }
      }
      tmp = open_config_log(s, p, cls, mls->default_format);
      if (! tmp) {
        return (-2);
      }
      i ++;
    }
  } else {
    if (mls->server_config_logs) {
      clsarray = (config_log_state *)(mls->server_config_logs)->elts;
      i = 0;
      while (i < (mls->server_config_logs)->nelts) {
        cls___0 = clsarray + i;
        if (cls___0->format_string) {
          format = apr_table_get((apr_table_t const   *)mls->formats, cls___0->format_string);
          if (format) {
            cls___0->format = parse_log_string(p, format, & dummy);
          }
        }
        tmp___0 = open_config_log(s, p, cls___0, mls->default_format);
        if (! tmp___0) {
          return (-2);
        }
        i ++;
      }
    }
  }
  return (0);
}
}
static apr_status_t flush_all_logs(void *data ) 
{ server_rec *s ;
  multi_log_state *mls ;
  apr_array_header_t *log_list ;
  config_log_state *clsarray ;
  buffered_log *buf ;
  int i ;

  {
  s = (server_rec *)data;
  if (! buffered_logs) {
    return (0);
  }
  while (s) {
    mls = (multi_log_state *)(*((void **)s->module_config + log_config_module.module_index));
    log_list = (apr_array_header_t *)((void *)0);
    if ((mls->config_logs)->nelts) {
      log_list = mls->config_logs;
    } else {
      if (mls->server_config_logs) {
        log_list = mls->server_config_logs;
      }
    }
    if (log_list) {
      clsarray = (config_log_state *)log_list->elts;
      i = 0;
      while (i < log_list->nelts) {
        buf = (buffered_log *)(clsarray + i)->log_writer;
        flush_log(buf);
        i ++;
      }
    }
    s = s->next;
  }
  return (0);
}
}
static int init_config_log(apr_pool_t *pc , apr_pool_t *p , apr_pool_t *pt , server_rec *s ) 
{ int res ;
  int tmp ;

  {
  tmp = open_multi_logs(s, p);
  res = tmp;
  s = s->next;
  while (1) {
    if (res == 0) {
      if (! s) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      break;
    }
    res = open_multi_logs(s, p);
    s = s->next;
  }
  return (res);
}
}
static void init_child(apr_pool_t *p , server_rec *s ) 
{ 

  {
  if (buffered_logs) {
    apr_pool_cleanup_register(p, (void const   *)s, & flush_all_logs, & flush_all_logs);
  }
  return;
}
}
static void ap_register_log_handler(apr_pool_t *p , char *tag , ap_log_handler_fn_t *handler ,
                                    int def ) 
{ ap_log_handler *log_struct ;
  ap_log_handler *tmp ;

  {
  tmp = (ap_log_handler *)apr_palloc(p, sizeof((*log_struct)));
  log_struct = tmp;
  log_struct->func = handler;
  log_struct->want_orig_default = def;
  apr_hash_set(log_hash, (void const   *)tag, 1, (void const   *)log_struct);
  return;
}
}
static void ap_log_set_writer_init(ap_log_writer_init *handle ) 
{ 

  {
  log_writer_init = handle;
  return;
}
}
static void ap_log_set_writer(ap_log_writer *handle ) 
{ 

  {
  log_writer = handle;
  return;
}
}
static apr_status_t ap_default_log_writer(request_rec *r , void *handle , char const   **strs ,
                                          int *strl , int nelts , apr_size_t len ) 
{ char *str ;
  char *s ;
  int i ;
  apr_status_t rv ;

  {
  str = (char *)apr_palloc(r->pool, len + 1U);
  i = 0;
  s = str;
  while (i < nelts) {
    memcpy((void * __restrict  )s, (void const   * __restrict  )(*(strs + i)), (unsigned int )(*(strl +
                                                                                                 i)));
    s += (*(strl + i));
    i ++;
  }
  rv = apr_file_write((apr_file_t *)handle, (void const   *)str, & len);
  return (rv);
}
}
static void *ap_default_log_writer_init(apr_pool_t *p , server_rec *s , char const   *name ) 
{ piped_log *pl ;
  char const   *fname ;
  char const   *tmp ;
  apr_file_t *fd ;
  apr_status_t rv ;

  {
  if ((int const   )(*name) == 124) {
    pl = ap_open_piped_log(p, name + 1);
    if ((unsigned int )pl == (unsigned int )((void *)0)) {
      return ((void *)0);
    }
    return ((void *)pl->fds[1]);
  } else {
    tmp = ap_server_root_relative(p, name);
    fname = tmp;
    if (! fname) {
      ap_log_error("mod_log_config.c", 1277, 3, 20024, (server_rec const   *)s, "invalid transfer log path %s.",
                   name);
      return ((void *)0);
    }
    rv = apr_file_open(& fd, fname, xfer_flags, xfer_perms, p);
    if (rv != 0) {
      ap_log_error("mod_log_config.c", 1283, 3, rv, (server_rec const   *)s, "could not open transfer log file %s.",
                   fname);
      return ((void *)0);
    }
    apr_file_inherit_set(fd);
    return ((void *)fd);
  }
}
}
static void *ap_buffered_log_writer_init(apr_pool_t *p , server_rec *s , char const   *name ) 
{ buffered_log *b ;

  {
  b = (buffered_log *)apr_palloc(p, sizeof(buffered_log ));
  b->handle = (apr_file_t *)ap_default_log_writer_init(p, s, name);
  b->outcnt = 0U;
  if (b->handle) {
    return ((void *)b);
  } else {
    return ((void *)0);
  }
}
}
static apr_status_t ap_buffered_log_writer(request_rec *r , void *handle , char const   **strs ,
                                           int *strl , int nelts , apr_size_t len ) 
{ char *str ;
  char *s ;
  int i ;
  apr_status_t rv ;
  buffered_log *buf ;
  apr_size_t w ;

  {
  buf = (buffered_log *)handle;
  if (len + buf->outcnt > 4096U) {
    flush_log(buf);
  }
  if (len >= 4096U) {
    str = (char *)apr_palloc(r->pool, len + 1U);
    i = 0;
    s = str;
    while (i < nelts) {
      memcpy((void * __restrict  )s, (void const   * __restrict  )(*(strs + i)), (unsigned int )(*(strl +
                                                                                                   i)));
      s += (*(strl + i));
      i ++;
    }
    w = len;
    rv = apr_file_write(buf->handle, (void const   *)str, & w);
  } else {
    i = 0;
    s = & buf->outbuf[buf->outcnt];
    while (i < nelts) {
      memcpy((void * __restrict  )s, (void const   * __restrict  )(*(strs + i)), (unsigned int )(*(strl +
                                                                                                   i)));
      s += (*(strl + i));
      i ++;
    }
    buf->outcnt += len;
    rv = 0;
  }
  return (rv);
}
}
static apr_OFN_ap_register_log_handler_t *log_pfn_register  ;
static int log_pre_config(apr_pool_t *p , apr_pool_t *plog , apr_pool_t *ptemp ) 
{ 

  {
  log_pfn_register = (apr_OFN_ap_register_log_handler_t *)apr_dynamic_fn_retrieve("ap_register_log_handler");
  if (log_pfn_register) {
    ((*log_pfn_register))(p, (char *)"h", & log_remote_host, 0);
    ((*log_pfn_register))(p, (char *)"a", & log_remote_address, 0);
    ((*log_pfn_register))(p, (char *)"A", & log_local_address, 0);
    ((*log_pfn_register))(p, (char *)"l", & log_remote_logname, 0);
    ((*log_pfn_register))(p, (char *)"u", & log_remote_user, 0);
    ((*log_pfn_register))(p, (char *)"t", & log_request_time, 0);
    ((*log_pfn_register))(p, (char *)"f", & log_request_file, 0);
    ((*log_pfn_register))(p, (char *)"b", & clf_log_bytes_sent, 0);
    ((*log_pfn_register))(p, (char *)"B", & log_bytes_sent, 0);
    ((*log_pfn_register))(p, (char *)"i", & log_header_in, 0);
    ((*log_pfn_register))(p, (char *)"o", & log_header_out, 0);
    ((*log_pfn_register))(p, (char *)"n", & log_note, 0);
    ((*log_pfn_register))(p, (char *)"e", & log_env_var, 0);
    ((*log_pfn_register))(p, (char *)"V", & log_server_name, 0);
    ((*log_pfn_register))(p, (char *)"v", & log_virtual_host, 0);
    ((*log_pfn_register))(p, (char *)"p", & log_server_port, 0);
    ((*log_pfn_register))(p, (char *)"P", & log_child_pid, 0);
    ((*log_pfn_register))(p, (char *)"H", & log_request_protocol, 0);
    ((*log_pfn_register))(p, (char *)"m", & log_request_method, 0);
    ((*log_pfn_register))(p, (char *)"q", & log_request_query, 0);
    ((*log_pfn_register))(p, (char *)"X", & log_connection_status, 0);
    ((*log_pfn_register))(p, (char *)"C", & log_cookie, 0);
    ((*log_pfn_register))(p, (char *)"r", & log_request_line, 1);
    ((*log_pfn_register))(p, (char *)"D", & log_request_duration_microseconds, 1);
    ((*log_pfn_register))(p, (char *)"T", & log_request_duration, 1);
    ((*log_pfn_register))(p, (char *)"U", & log_request_uri, 1);
    ((*log_pfn_register))(p, (char *)"s", & log_status, 1);
  }
  return (0);
}
}
static void register_hooks___2(apr_pool_t *p ) 
{ 

  {
  ap_hook_pre_config(& log_pre_config, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                     -10);
  ap_hook_child_init(& init_child, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                     10);
  ap_hook_open_logs(& init_config_log, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                    10);
  ap_hook_log_transaction(& multi_log_transaction, (char const   * const  *)((void *)0),
                          (char const   * const  *)((void *)0), 10);
  log_hash = apr_hash_make(p);
  ((*((void (*)(char const   * , apr_OFN_ap_register_log_handler_t * ))(& apr_dynamic_fn_register))))("ap_register_log_handler",
                                                                                                      & ap_register_log_handler);
  ((*((void (*)(char const   * , apr_OFN_ap_log_set_writer_init_t * ))(& apr_dynamic_fn_register))))("ap_log_set_writer_init",
                                                                                                     & ap_log_set_writer_init);
  ((*((void (*)(char const   * , apr_OFN_ap_log_set_writer_t * ))(& apr_dynamic_fn_register))))("ap_log_set_writer",
                                                                                                & ap_log_set_writer);
  return;
}
}
struct module_struct log_config_module  = 
     {20020903, 0, -1, "mod_log_config.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, (void (*)(process_rec *process ))((void *)0), (void *(*)(apr_pool_t *p ,
                                                                           char *dir ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), & make_config_log_state,
    & merge_config_log_state, config_log_cmds, & register_hooks___2};
#pragma merger(0,"/tmp/cil-nbi0lENS.i","-g -pthread")
extern char *getenv(char const   *__name ) ;
apr_table_t *apr_table_copy(apr_pool_t *p , apr_table_t const   *t ) ;
void apr_table_set(apr_table_t *t , char const   *key , char const   *val ) ;
static void *create_env_dir_config(apr_pool_t *p , char *dummy ) 
{ env_dir_config_rec *conf ;
  env_dir_config_rec *tmp ;

  {
  tmp = (env_dir_config_rec *)apr_palloc(p, sizeof((*conf)));
  conf = tmp;
  conf->vars = apr_table_make(p, 10);
  conf->unsetenv = apr_table_make(p, 10);
  return ((void *)conf);
}
}
static void *merge_env_dir_configs(apr_pool_t *p , void *basev , void *addv ) 
{ env_dir_config_rec *base ;
  env_dir_config_rec *add ;
  env_dir_config_rec *res ;
  env_dir_config_rec *tmp ;
  apr_table_entry_t const   *elts ;
  apr_array_header_t const   *arr ;
  int i ;

  {
  base = (env_dir_config_rec *)basev;
  add = (env_dir_config_rec *)addv;
  tmp = (env_dir_config_rec *)apr_palloc(p, sizeof((*res)));
  res = tmp;
  res->vars = apr_table_copy(p, (apr_table_t const   *)base->vars);
  res->unsetenv = (apr_table_t *)((void *)0);
  arr = apr_table_elts((apr_table_t const   *)add->unsetenv);
  if (arr) {
    elts = (apr_table_entry_t const   *)arr->elts;
    i = 0;
    while (i < arr->nelts) {
      apr_table_unset(res->vars, (char const   *)(elts + i)->key);
      i ++;
    }
  }
  arr = apr_table_elts((apr_table_t const   *)add->vars);
  if (arr) {
    elts = (apr_table_entry_t const   *)arr->elts;
    i = 0;
    while (i < arr->nelts) {
      apr_table_setn(res->vars, (char const   *)(elts + i)->key, (char const   *)(elts +
                                                                                  i)->val);
      i ++;
    }
  }
  return ((void *)res);
}
}
static char const   *add_env_module_vars_passed(cmd_parms *cmd , void *sconf_ , char const   *arg ) 
{ env_dir_config_rec *sconf ;
  apr_table_t *vars ;
  char const   *env_var ;
  char const   *tmp ;

  {
  sconf = (env_dir_config_rec *)sconf_;
  vars = sconf->vars;
  env_var = getenv(arg);
  if ((unsigned int )env_var != (unsigned int )((void *)0)) {
    tmp = apr_pstrdup(cmd->pool, env_var);
    apr_table_setn(vars, arg, tmp);
  } else {
    ap_log_error("mod_env.c", 146, 4, 0, (server_rec const   *)cmd->server, "PassEnv variable %s was undefined",
                 arg);
  }
  return ((char const   *)((void *)0));
}
}
static char const   *add_env_module_vars_set(cmd_parms *cmd , void *sconf_ , char const   *name ,
                                             char const   *value ) 
{ env_dir_config_rec *sconf ;

  {
  sconf = (env_dir_config_rec *)sconf_;
  apr_table_setn(sconf->vars, name, value);
  return ((char const   *)((void *)0));
}
}
static char const   *add_env_module_vars_unset(cmd_parms *cmd , void *sconf_ , char const   *arg ) 
{ env_dir_config_rec *sconf ;

  {
  sconf = (env_dir_config_rec *)sconf_;
  apr_table_set(sconf->unsetenv, arg, (char const   *)((void *)0));
  apr_table_unset(sconf->vars, arg);
  return ((char const   *)((void *)0));
}
}
static command_rec const   env_module_cmds[4]  = {      {"PassEnv", {& add_env_module_vars_passed}, (void *)0, 4, 3, "a list of environment variables to pass to CGI."}, 
        {"SetEnv",
      {& add_env_module_vars_set}, (void *)0, 4, 7, "an environment variable name and optional value to pass to CGI."}, 
        {"UnsetEnv",
      {& add_env_module_vars_unset}, (void *)0, 4, 3, "a list of variables to remove from the CGI environment."}, 
        {(char const   *)((void *)0),
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))0}, (void *)0,
      0, 0, (char const   *)0}};
static int fixup_env_module(request_rec *r ) 
{ apr_table_t *e ;
  env_dir_config_rec *sconf ;
  apr_table_t *vars ;
  apr_array_header_t const   *tmp ;

  {
  e = r->subprocess_env;
  sconf = (env_dir_config_rec *)(*((void **)r->per_dir_config + env_module.module_index));
  vars = sconf->vars;
  tmp = apr_table_elts((apr_table_t const   *)sconf->vars);
  if (! tmp->nelts) {
    return (-1);
  }
  r->subprocess_env = apr_table_overlay(r->pool, (apr_table_t const   *)e, (apr_table_t const   *)vars);
  return (0);
}
}
static void register_hooks___3(apr_pool_t *p ) 
{ 

  {
  ap_hook_fixups(& fixup_env_module, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                 10);
  return;
}
}
struct module_struct env_module  = 
     {20020903, 0, -1, "mod_env.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, (void (*)(process_rec *process ))((void *)0), & create_env_dir_config,
    & merge_env_dir_configs, (void *(*)(apr_pool_t *p , server_rec *s ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), env_module_cmds,
    & register_hooks___3};
#pragma merger(0,"/tmp/cil-Be1hcpyF.i","-g -pthread")
apr_strmatch_pattern const   *apr_strmatch_precompile(apr_pool_t *p , char const   *s ,
                                                      int case_sensitive ) ;
apr_array_header_t *apr_array_append(apr_pool_t *p , apr_array_header_t const   *first ,
                                     apr_array_header_t const   *second ) ;
void ap_hook_header_parser(ap_HOOK_header_parser_t *pf , char const   * const  *aszPre___1 ,
                           char const   * const  *aszSucc___2 , int nOrder ) ;
void ap_hook_post_read_request(ap_HOOK_post_read_request_t *pf , char const   * const  *aszPre___1 ,
                               char const   * const  *aszSucc___2 , int nOrder ) ;
static void *create_setenvif_config(apr_pool_t *p ) 
{ sei_cfg_rec *new ;
  sei_cfg_rec *tmp ;

  {
  tmp = (sei_cfg_rec *)apr_palloc(p, sizeof(sei_cfg_rec ));
  new = tmp;
  new->conditionals = apr_array_make(p, 20, (int )sizeof(sei_entry ));
  return ((void *)new);
}
}
static void *create_setenvif_config_svr(apr_pool_t *p , server_rec *dummy ) 
{ void *tmp ;

  {
  tmp = create_setenvif_config(p);
  return (tmp);
}
}
static void *create_setenvif_config_dir(apr_pool_t *p , char *dummy ) 
{ void *tmp ;

  {
  tmp = create_setenvif_config(p);
  return (tmp);
}
}
static void *merge_setenvif_config(apr_pool_t *p , void *basev , void *overridesv ) 
{ sei_cfg_rec *a ;
  void *tmp ;
  sei_cfg_rec *tmp___0 ;
  sei_cfg_rec *base ;
  sei_cfg_rec *overrides ;

  {
  tmp = apr_palloc(p, sizeof(sei_cfg_rec ));
  tmp___0 = (sei_cfg_rec *)memset(tmp, 0, sizeof(sei_cfg_rec ));
  a = tmp___0;
  base = (sei_cfg_rec *)basev;
  overrides = (sei_cfg_rec *)overridesv;
  a->conditionals = apr_array_append(p, (apr_array_header_t const   *)base->conditionals,
                                     (apr_array_header_t const   *)overrides->conditionals);
  return ((void *)a);
}
}
static int is_header_regex(apr_pool_t *p , char const   *name ) 
{ regex_t *preg ;
  regex_t *tmp ;
  int tmp___0 ;

  {
  tmp = ap_pregcomp(p, "^[-A-Za-z0-9_]*$", 0);
  preg = tmp;
  if (preg) {
    tmp___0 = ap_regexec(preg, name, 0U, (regmatch_t *)((void *)0), 0);
    if (tmp___0) {
      return (1);
    }
  }
  return (0);
}
}
static char const   *non_regex_pattern(apr_pool_t *p , char const   *s ) 
{ char const   *src ;
  int escapes_found ;
  int in_escape ;
  char *unescaped ;
  char *tmp ;
  char *dst ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
  src = s;
  escapes_found = 0;
  in_escape = 0;
  while ((*src)) {
    if (in_escape) {
      in_escape = 0;
    } else {
      switch ((int )(*src)) {
      case 94: ;
      case 46: ;
      case 36: ;
      case 124: ;
      case 40: ;
      case 41: ;
      case 91: ;
      case 93: ;
      case 42: ;
      case 43: ;
      case 63: ;
      case 123: ;
      case 125: ;
      return ((char const   *)((void *)0));
      case 92: 
      in_escape = 1;
      escapes_found = 1;
      }
    }
    src ++;
  }
  if (! escapes_found) {
    return (s);
  } else {
    tmp = (char *)apr_palloc(p, (unsigned int )((src - s) + 1));
    unescaped = tmp;
    dst = unescaped;
    src = s;
    while (1) {
      if ((int const   )(*src) == 92) {
        src ++;
      }
      tmp___0 = dst;
      dst ++;
      tmp___1 = src;
      src ++;
      (*tmp___0) = (char )(*tmp___1);
      if (! (*tmp___0)) {
        break;
      }
    }
    return ((char const   *)unescaped);
  }
}
}
static char const   *add_setenvif_core(cmd_parms *cmd , void *mconfig , char *fname ,
                                       char const   *args ) 
{ char *regex ;
  char const   *simple_pattern ;
  char const   *feature ;
  sei_cfg_rec *sconf ;
  sei_entry *new ;
  sei_entry *entries ;
  char *var ;
  int i ;
  int beenhere ;
  int icase ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;

  {
  beenhere = 0;
  if ((unsigned int )cmd->path != (unsigned int )((void *)0)) {
    sconf = (sei_cfg_rec *)mconfig;
  } else {
    sconf = (sei_cfg_rec *)(*((void **)(cmd->server)->module_config + setenvif_module.module_index));
  }
  entries = (sei_entry *)(sconf->conditionals)->elts;
  regex = ap_getword_conf(cmd->pool, & args);
  if (! (*regex)) {
    tmp = apr_pstrcat(cmd->pool, "Missing regular expression for ", (cmd->cmd)->name,
                      (void *)0);
    return (tmp);
  }
  i = 0;
  while (i < (sconf->conditionals)->nelts) {
    new = entries + i;
    tmp___0 = strcasecmp((char const   *)new->name, (char const   *)fname);
    if (! tmp___0) {
      fname = new->name;
      break;
    }
    i ++;
  }
  i = (sconf->conditionals)->nelts - 1;
  icase = (unsigned int )cmd->info == (unsigned int )((void *)(& setenvif_module));
  if (i < 0) {
    goto _L___1;
  } else {
    if ((unsigned int )(entries + i)->name != (unsigned int )fname) {
      _L___1: /* CIL Label */ 
      goto _L___0;
    } else {
      if ((entries + i)->icase != icase) {
        _L___0: /* CIL Label */ 
        goto _L;
      } else {
        tmp___14 = strcmp((char const   *)(entries + i)->regex, (char const   *)regex);
        if (tmp___14) {
          _L: /* CIL Label */ 
          new = (sei_entry *)apr_array_push(sconf->conditionals);
          new->name = fname;
          new->regex = regex;
          new->icase = icase;
          simple_pattern = non_regex_pattern(cmd->pool, (char const   *)regex);
          if (simple_pattern) {
            new->pattern = apr_strmatch_precompile(cmd->pool, simple_pattern, ! icase !=
                                                                              0);
            if ((unsigned int )new->pattern == (unsigned int )((void *)0)) {
              tmp___1 = apr_pstrcat(cmd->pool, (cmd->cmd)->name, " pattern could not be compiled.",
                                    (void *)0);
              return (tmp___1);
            }
            new->preg = (regex_t *)((void *)0);
          } else {
            if (icase) {
              tmp___2 = 1;
            } else {
              tmp___2 = 0;
            }
            new->preg = ap_pregcomp(cmd->pool, (char const   *)regex, 0 | tmp___2);
            if ((unsigned int )new->preg == (unsigned int )((void *)0)) {
              tmp___3 = apr_pstrcat(cmd->pool, (cmd->cmd)->name, " regex could not be compiled.",
                                    (void *)0);
              return (tmp___3);
            }
            new->pattern = (apr_strmatch_pattern const   *)((void *)0);
          }
          new->features = apr_table_make(cmd->pool, 2);
          tmp___13 = strcasecmp((char const   *)fname, "remote_addr");
          if (tmp___13) {
            tmp___12 = strcasecmp((char const   *)fname, "remote_host");
            if (tmp___12) {
              tmp___11 = strcasecmp((char const   *)fname, "remote_user");
              if (tmp___11) {
                tmp___10 = strcasecmp((char const   *)fname, "request_uri");
                if (tmp___10) {
                  tmp___9 = strcasecmp((char const   *)fname, "request_method");
                  if (tmp___9) {
                    tmp___8 = strcasecmp((char const   *)fname, "request_protocol");
                    if (tmp___8) {
                      tmp___7 = strcasecmp((char const   *)fname, "server_addr");
                      if (tmp___7) {
                        new->special_type = 0;
                        tmp___6 = is_header_regex(cmd->pool, (char const   *)fname);
                        if (tmp___6) {
                          if (icase) {
                            tmp___4 = 1;
                          } else {
                            tmp___4 = 0;
                          }
                          new->pnamereg = ap_pregcomp(cmd->pool, (char const   *)fname,
                                                      0 | tmp___4);
                          if ((unsigned int )new->pnamereg == (unsigned int )((void *)0)) {
                            tmp___5 = apr_pstrcat(cmd->pool, (cmd->cmd)->name, "Header name regex could not be compiled.",
                                                  (void *)0);
                            return (tmp___5);
                          }
                        } else {
                          new->pnamereg = (regex_t *)((void *)0);
                        }
                      } else {
                        new->special_type = 7;
                      }
                    } else {
                      new->special_type = 6;
                    }
                  } else {
                    new->special_type = 5;
                  }
                } else {
                  new->special_type = 4;
                }
              } else {
                new->special_type = 3;
              }
            } else {
              new->special_type = 2;
            }
          } else {
            new->special_type = 1;
          }
        } else {
          new = entries + i;
        }
      }
    }
  }
  while (1) {
    feature = ap_getword_conf(cmd->pool, & args);
    if (! (*feature)) {
      break;
    }
    beenhere ++;
    var = ap_getword(cmd->pool, & feature, (char )'=');
    if ((*feature)) {
      apr_table_setn(new->features, (char const   *)var, feature);
    } else {
      if ((int )(*var) == 33) {
        apr_table_setn(new->features, (char const   *)(var + 1), "!");
      } else {
        apr_table_setn(new->features, (char const   *)var, "1");
      }
    }
  }
  if (! beenhere) {
    tmp___15 = apr_pstrcat(cmd->pool, "Missing envariable expression for ", (cmd->cmd)->name,
                           (void *)0);
    return (tmp___15);
  }
  return ((char const   *)((void *)0));
}
}
static char const   *add_setenvif(cmd_parms *cmd , void *mconfig , char const   *args ) 
{ char *fname ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  fname = ap_getword_conf(cmd->pool, & args);
  if (! (*fname)) {
    tmp = apr_pstrcat(cmd->pool, "Missing header-field name for ", (cmd->cmd)->name,
                      (void *)0);
    return (tmp);
  }
  tmp___0 = add_setenvif_core(cmd, mconfig, fname, args);
  return (tmp___0);
}
}
static char const   *add_browser(cmd_parms *cmd , void *mconfig , char const   *args ) 
{ char const   *tmp ;

  {
  tmp = add_setenvif_core(cmd, mconfig, (char *)"User-Agent", args);
  return (tmp);
}
}
static command_rec const   setenvif_module_cmds[5]  = {      {"SetEnvIf", {& add_setenvif}, (void *)0, 4, 0, "A header-name, regex and a list of variables."}, 
        {"SetEnvIfNoCase",
      {& add_setenvif}, (void *)(& setenvif_module), 4, 0, "a header-name, regex and a list of variables."}, 
        {"BrowserMatch",
      {& add_browser}, (void *)0, 4, 0, "A browser regex and a list of variables."}, 
        {"BrowserMatchNoCase",
      {& add_browser}, (void *)(& setenvif_module), 4, 0, "A browser regex and a list of variables."}, 
        {(char const   *)((void *)0),
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))0}, (void *)0,
      0, 0, (char const   *)0}};
static int match_headers(request_rec *r ) 
{ sei_cfg_rec *sconf ;
  sei_entry *entries ;
  apr_table_entry_t const   *elts ;
  char const   *val ;
  apr_size_t val_len ;
  int i ;
  int j ;
  char *last_name ;
  sei_entry *b ;
  apr_array_header_t const   *arr ;
  apr_array_header_t const   *tmp ;
  int tmp___0 ;
  apr_array_header_t const   *arr___0 ;
  apr_array_header_t const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
  val_len = (apr_size_t )0;
  if (! (*((void **)r->request_config + setenvif_module.module_index))) {
    (*((void **)r->request_config + setenvif_module.module_index)) = (void *)"setenvif-phase-flag";
    sconf = (sei_cfg_rec *)(*((void **)(r->server)->module_config + setenvif_module.module_index));
  } else {
    sconf = (sei_cfg_rec *)(*((void **)r->per_dir_config + setenvif_module.module_index));
  }
  entries = (sei_entry *)(sconf->conditionals)->elts;
  last_name = (char *)((void *)0);
  val = (char const   *)((void *)0);
  i = 0;
  while (i < (sconf->conditionals)->nelts) {
    b = entries + i;
    if ((unsigned int )b->name != (unsigned int )last_name) {
      last_name = b->name;
      switch ((int )b->special_type) {
      case 1: 
      val = (char const   *)(r->connection)->remote_ip;
      break;
      case 7: 
      val = (char const   *)(r->connection)->local_ip;
      break;
      case 2: 
      val = ap_get_remote_host(r->connection, (void *)r->per_dir_config, 1, (int *)((void *)0));
      break;
      case 3: 
      val = (char const   *)r->user;
      break;
      case 4: 
      val = (char const   *)r->uri;
      break;
      case 5: 
      val = r->method;
      break;
      case 6: 
      val = (char const   *)r->protocol;
      break;
      case 0: ;
      if (b->pnamereg) {
        tmp = apr_table_elts((apr_table_t const   *)r->headers_in);
        arr = tmp;
        elts = (apr_table_entry_t const   *)arr->elts;
        val = (char const   *)((void *)0);
        j = 0;
        while (j < arr->nelts) {
          tmp___0 = ap_regexec(b->pnamereg, (char const   *)(elts + j)->key, 0U, (regmatch_t *)((void *)0),
                               0);
          if (! tmp___0) {
            val = (char const   *)(elts + j)->val;
          }
          j ++;
        }
      } else {
        val = apr_table_get((apr_table_t const   *)r->headers_in, (char const   *)b->name);
        if ((unsigned int )val == (unsigned int )((void *)0)) {
          val = apr_table_get((apr_table_t const   *)r->subprocess_env, (char const   *)b->name);
        }
      }
      }
      if (val) {
        val_len = strlen(val);
      } else {
        val_len = 0U;
      }
    }
    if ((unsigned int )val == (unsigned int )((void *)0)) {
      val = "";
      val_len = 0U;
    }
    if (b->pattern) {
      tmp___3 = ((*((b->pattern)->compare)))(b->pattern, val, val_len);
      if (tmp___3) {
        goto _L;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      if (! b->pattern) {
        tmp___4 = ap_regexec(b->preg, val, 0U, (regmatch_t *)((void *)0), 0);
        if (tmp___4) {
          goto _L___0;
        } else {
          _L: /* CIL Label */ 
          tmp___2 = apr_table_elts((apr_table_t const   *)b->features);
          arr___0 = tmp___2;
          elts = (apr_table_entry_t const   *)arr___0->elts;
          j = 0;
          while (j < arr___0->nelts) {
            if ((int )(*((elts + j)->val)) == 33) {
              apr_table_unset(r->subprocess_env, (char const   *)(elts + j)->key);
            } else {
              apr_table_setn(r->subprocess_env, (char const   *)(elts + j)->key, (char const   *)(elts +
                                                                                                  j)->val);
            }
            j ++;
          }
        }
      } else {
        _L___0: /* CIL Label */ ;
      }
    }
    i ++;
  }
  return (-1);
}
}
static void register_hooks___4(apr_pool_t *p ) 
{ 

  {
  ap_hook_header_parser(& match_headers, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                        10);
  ap_hook_post_read_request(& match_headers, (char const   * const  *)((void *)0),
                            (char const   * const  *)((void *)0), 10);
  return;
}
}
struct module_struct setenvif_module  = 
     {20020903, 0, -1, "mod_setenvif.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, (void (*)(process_rec *process ))((void *)0), & create_setenvif_config_dir,
    & merge_setenvif_config, & create_setenvif_config_svr, & merge_setenvif_config,
    setenvif_module_cmds, & register_hooks___4};
#pragma merger(0,"/tmp/cil-FNstIsIb.i","-g -pthread")
apr_status_t apr_socket_opt_set(apr_socket_t *sock , apr_int32_t opt , apr_int32_t on ) ;
struct apr_bucket_type_t  const  apr_bucket_type_flush ;
apr_bucket *apr_bucket_transient_create(char const   *buf , apr_size_t length , apr_bucket_alloc_t *list ) ;
char const   *ap_check_cmd_context(cmd_parms *cmd , unsigned int forbidden ) ;
void ap_hook_process_connection(ap_HOOK_process_connection_t *pf , char const   * const  *aszPre___1 ,
                                char const   * const  *aszSucc___2 , int nOrder ) ;
ap_filter_rec_t *ap_register_input_filter(char const   *name , apr_status_t (*filter_func)(ap_filter_t *f ,
                                                                                           apr_bucket_brigade *b ,
                                                                                           ap_input_mode_t mode ,
                                                                                           apr_read_type_e block ,
                                                                                           apr_off_t readbytes ) ,
                                          int (*filter_init)(ap_filter_t *f ) , ap_filter_type ftype ) ;
ap_filter_t *ap_add_output_filter_handle(ap_filter_rec_t *f , void *ctx , request_rec *r ,
                                         conn_rec *c ) ;
ap_filter_rec_t *ap_content_length_filter_handle ;
request_rec *ap_read_request(conn_rec *conn ) ;
void ap_method_registry_init(apr_pool_t *p ) ;
void ap_hook_http_method(ap_HOOK_http_method_t *pf , char const   * const  *aszPre___1 ,
                         char const   * const  *aszSucc___2 , int nOrder ) ;
void ap_hook_default_port(ap_HOOK_default_port_t *pf , char const   * const  *aszPre___1 ,
                          char const   * const  *aszSucc___2 , int nOrder ) ;
apr_status_t ap_byterange_filter(ap_filter_t *f , apr_bucket_brigade *bb ) ;
apr_status_t ap_http_header_filter(ap_filter_t *f , apr_bucket_brigade *b ) ;
void ap_process_request(request_rec *r ) ;
void ap_hook_create_request(ap_HOOK_create_request_t *pf , char const   * const  *aszPre___1 ,
                            char const   * const  *aszSucc___2 , int nOrder ) ;
void ap_hook_map_to_storage(ap_HOOK_map_to_storage_t *pf , char const   * const  *aszPre___1 ,
                            char const   * const  *aszSucc___2 , int nOrder ) ;
int ap_graceful_stop_signalled(void) ;
void ap_increment_counts(ap_sb_handle_t *sb , request_rec *r ) ;
int ap_update_child_status(ap_sb_handle_t *sbh , int status , request_rec *r ) ;
int ap_extended_status ;
ap_filter_rec_t *ap_http_input_filter_handle  ;
ap_filter_rec_t *ap_http_header_filter_handle  ;
ap_filter_rec_t *ap_chunk_filter_handle  ;
ap_filter_rec_t *ap_byterange_filter_handle  ;
apr_status_t ap_http_filter(ap_filter_t *f , apr_bucket_brigade *b , ap_input_mode_t mode ,
                            apr_read_type_e block , apr_off_t readbytes ) ;
int ap_send_http_trace(request_rec *r ) ;
static char const   *set_keep_alive_timeout(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;
  int tmp___0 ;

  {
  tmp = ap_check_cmd_context(cmd, 30U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  tmp___0 = atoi(arg);
  (cmd->server)->keep_alive_timeout = (long long )tmp___0 * 1000000LL;
  return ((char const   *)((void *)0));
}
}
static char const   *set_keep_alive(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = ap_check_cmd_context(cmd, 30U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  tmp___0 = strcasecmp(arg, "off");
  if (tmp___0) {
    tmp___1 = strcmp(arg, "0");
    if (tmp___1) {
      (cmd->server)->keep_alive = 1;
    } else {
      _L: 
      (cmd->server)->keep_alive = 0;
    }
  } else {
    goto _L;
  }
  return ((char const   *)((void *)0));
}
}
static char const   *set_keep_alive_max(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;

  {
  tmp = ap_check_cmd_context(cmd, 30U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  (cmd->server)->keep_alive_max = atoi(arg);
  return ((char const   *)((void *)0));
}
}
static command_rec const   http_cmds[4]  = {      {"KeepAliveTimeout", {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_keep_alive_timeout)},
      (void *)0, 128, (enum cmd_how )1, "Keep-Alive timeout duration (sec)"}, 
        {"MaxKeepAliveRequests", {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_keep_alive_max)},
      (void *)0, 128, (enum cmd_how )1, "Maximum number of Keep-Alive requests per connection, or 0 for infinite"}, 
        {"KeepAlive",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_keep_alive)},
      (void *)0, 128, (enum cmd_how )1, "Whether persistent connections should be On or Off"}, 
        {(char const   *)((void *)0),
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))0}, (void *)0,
      0, (enum cmd_how )0, (char const   *)0}};
static apr_status_t chunk_filter(ap_filter_t *f , apr_bucket_brigade *b ) 
{ conn_rec *c ;
  apr_bucket_brigade *more ;
  apr_bucket *e ;
  apr_status_t rv ;
  apr_off_t bytes ;
  apr_bucket *eos ;
  apr_bucket *flush ;
  char chunk_hdr[20] ;
  char const   *data ;
  apr_size_t len ;
  apr_size_t hdr_len ;
  apr_bucket *ap__b ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b___0 ;
  apr_bucket *ap__a___0 ;
  apr_bucket *ap__b___1 ;
  apr_bucket *ap__b___2 ;
  apr_bucket *ap__a___1 ;
  apr_bucket *ap__b___3 ;

  {
  c = (f->r)->connection;
  more = (apr_bucket_brigade *)((void *)0);
  while (b) {
    bytes = 0L;
    eos = (apr_bucket *)((void *)0);
    flush = (apr_bucket *)((void *)0);
    e = b->list.next;
    while ((unsigned int )e != (unsigned int )((struct apr_bucket *)((char *)(& b->list) -
                                                                     (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                             (char *)((void *)0))))) {
      if ((unsigned int )e->type == (unsigned int )(& apr_bucket_type_eos)) {
        eos = e;
        break;
      }
      if ((unsigned int )e->type == (unsigned int )(& apr_bucket_type_flush)) {
        flush = e;
      } else {
        if (e->length == 4294967295U) {
          rv = ((*((e->type)->read)))(e, & data, & len, (enum __anonenum_apr_read_type_e_60 )0);
          if (rv != 0) {
            return (rv);
          }
          if (len > 0U) {
            bytes = (long )((unsigned long )bytes + (unsigned long )len);
            more = apr_brigade_split(b, e->link.next);
            break;
          } else {
            goto __Cont;
          }
        } else {
          bytes = (long )((unsigned long )bytes + (unsigned long )e->length);
        }
      }
      __Cont: 
      e = e->link.next;
    }
    if (bytes > 0L) {
      hdr_len = (apr_size_t )apr_snprintf(chunk_hdr, sizeof(chunk_hdr), "%qx\r\n",
                                          (unsigned long long )bytes);
      e = apr_bucket_transient_create((char const   *)(chunk_hdr), hdr_len, c->bucket_alloc);
      while (1) {
        ap__b = e;
        while (1) {
          ap__b->link.prev = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                 (char *)((void *)0)));
          ap__b->link.next = ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                  (char *)((void *)0))))->link.next;
          (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0))))->link.next)->link.prev = ap__b;
          ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                               (char *)((void *)0))))->link.next = ap__b;
          break;
        }
        break;
      }
      e = apr_bucket_immortal_create("\r\n", 2U, c->bucket_alloc);
      if ((unsigned int )eos != (unsigned int )((void *)0)) {
        while (1) {
          ap__a = eos;
          ap__b___0 = e;
          while (1) {
            ap__b___0->link.next = ap__a;
            ap__b___0->link.prev = ap__a->link.prev;
            (ap__a->link.prev)->link.next = ap__b___0;
            ap__a->link.prev = ap__b___0;
            break;
          }
          break;
        }
      } else {
        if ((unsigned int )flush != (unsigned int )((void *)0)) {
          while (1) {
            ap__a___0 = flush;
            ap__b___1 = e;
            while (1) {
              ap__b___1->link.next = ap__a___0;
              ap__b___1->link.prev = ap__a___0->link.prev;
              (ap__a___0->link.prev)->link.next = ap__b___1;
              ap__a___0->link.prev = ap__b___1;
              break;
            }
            break;
          }
        } else {
          while (1) {
            ap__b___2 = e;
            while (1) {
              ap__b___2->link.next = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                         (char *)((void *)0)));
              ap__b___2->link.prev = ((struct apr_bucket *)((char *)(& b->list) -
                                                            (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                    (char *)((void *)0))))->link.prev;
              (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                    (char *)((void *)0))))->link.prev)->link.next = ap__b___2;
              ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                   (char *)((void *)0))))->link.prev = ap__b___2;
              break;
            }
            break;
          }
        }
      }
    }
    if ((unsigned int )eos != (unsigned int )((void *)0)) {
      e = apr_bucket_immortal_create("0\r\n\r\n", 5U, c->bucket_alloc);
      while (1) {
        ap__a___1 = eos;
        ap__b___3 = e;
        while (1) {
          ap__b___3->link.next = ap__a___1;
          ap__b___3->link.prev = ap__a___1->link.prev;
          (ap__a___1->link.prev)->link.next = ap__b___3;
          ap__a___1->link.prev = ap__b___3;
          break;
        }
        break;
      }
    }
    rv = ap_pass_brigade(f->next, b);
    if (rv != 0) {
      goto _L;
    } else {
      if ((unsigned int )eos != (unsigned int )((void *)0)) {
        _L: 
        return (rv);
      }
    }
    b = more;
    more = (apr_bucket_brigade *)((void *)0);
  }
  return (0);
}
}
static char const   *http_method(request_rec const   *r ) 
{ 

  {
  return ("http");
}
}
static apr_port_t http_port(request_rec const   *r ) 
{ 

  {
  return ((unsigned short)80);
}
}
static int ap_process_http_connection(conn_rec *c ) 
{ request_rec *r ;
  int csd_set ;
  apr_socket_t *csd ;
  int tmp ;

  {
  csd_set = 0;
  csd = (apr_socket_t *)((void *)0);
  ap_update_child_status((ap_sb_handle_t *)c->sbh, 3, (request_rec *)((void *)0));
  while (1) {
    r = ap_read_request(c);
    if (! ((unsigned int )r != (unsigned int )((void *)0))) {
      break;
    }
    c->keepalive = (enum __anonenum_ap_conn_keepalive_e_69 )0;
    ap_update_child_status((ap_sb_handle_t *)c->sbh, 4, r);
    if (r->status == 200) {
      ap_process_request(r);
    }
    if (ap_extended_status) {
      ap_increment_counts((ap_sb_handle_t *)c->sbh, r);
    }
    if ((int )c->keepalive != 2) {
      goto _L;
    } else {
      if (c->aborted) {
        _L: 
        break;
      }
    }
    ap_update_child_status((ap_sb_handle_t *)c->sbh, 5, r);
    apr_pool_destroy(r->pool);
    tmp = ap_graceful_stop_signalled();
    if (tmp) {
      break;
    }
    if (! csd_set) {
      csd = (apr_socket_t *)(*((void **)c->conn_config + core_module.module_index));
      csd_set = 1;
    }
    apr_socket_opt_set(csd, 4096, 1);
  }
  return (0);
}
}
static int http_create_request(request_rec *r ) 
{ 

  {
  if (! r->main) {
    if (! r->prev) {
      ap_add_output_filter_handle(ap_byterange_filter_handle, (void *)0, r, r->connection);
      ap_add_output_filter_handle(ap_content_length_filter_handle, (void *)0, r, r->connection);
      ap_add_output_filter_handle(ap_http_header_filter_handle, (void *)0, r, r->connection);
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  return (0);
}
}
static void register_hooks___5(apr_pool_t *p ) 
{ 

  {
  ap_hook_process_connection(& ap_process_http_connection, (char const   * const  *)((void *)0),
                             (char const   * const  *)((void *)0), 30);
  ap_hook_map_to_storage(& ap_send_http_trace, (char const   * const  *)((void *)0),
                         (char const   * const  *)((void *)0), 10);
  ap_hook_http_method(& http_method, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                      30);
  ap_hook_default_port(& http_port, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                       30);
  ap_hook_create_request(& http_create_request, (char const   * const  *)((void *)0),
                         (char const   * const  *)((void *)0), 30);
  ap_http_input_filter_handle = ap_register_input_filter("HTTP_IN", & ap_http_filter,
                                                         (int (*)(ap_filter_t *f ))((void *)0),
                                                         (enum __anonenum_ap_filter_type_71 )30);
  ap_http_header_filter_handle = ap_register_output_filter("HTTP_HEADER", & ap_http_header_filter,
                                                           (int (*)(ap_filter_t *f ))((void *)0),
                                                           (enum __anonenum_ap_filter_type_71 )30);
  ap_chunk_filter_handle = ap_register_output_filter("CHUNK", & chunk_filter, (int (*)(ap_filter_t *f ))((void *)0),
                                                     (enum __anonenum_ap_filter_type_71 )40);
  ap_byterange_filter_handle = ap_register_output_filter("BYTERANGE", & ap_byterange_filter,
                                                         (int (*)(ap_filter_t *f ))((void *)0),
                                                         (enum __anonenum_ap_filter_type_71 )30);
  ap_method_registry_init(p);
  return;
}
}
struct module_struct http_module  = 
     {20020903, 0, -1, "http_core.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, (void (*)(process_rec *process ))((void *)0), (void *(*)(apr_pool_t *p ,
                                                                           char *dir ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), (void *(*)(apr_pool_t *p ,
                                                                                          server_rec *s ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), http_cmds,
    & register_hooks___5};
#pragma merger(0,"/tmp/cil-eCWRx3rv.i","-g -pthread")
extern int *__errno_location(void)  __attribute__((__const__)) ;
extern int memcmp(void const   *__s1 , void const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
apr_status_t apr_pool_cleanup_null(void *data ) ;
apr_int64_t apr_atoi64(char const   *buf ) ;
apr_status_t apr_brigade_destroy(apr_bucket_brigade *b ) ;
apr_status_t apr_brigade_partition(apr_bucket_brigade *b , apr_off_t point , apr_bucket **after_point ) ;
apr_status_t apr_brigade_length(apr_bucket_brigade *bb , int read_all , apr_off_t *length ) ;
apr_status_t apr_brigade_flatten(apr_bucket_brigade *bb , char *c , apr_size_t *len ) ;
apr_status_t apr_brigade_write(apr_bucket_brigade *b , apr_status_t (*flush)(apr_bucket_brigade *bb ,
                                                                             void *ctx ) ,
                               void *ctx , char const   *str , apr_size_t nbyte ) ;
apr_status_t apr_brigade_writev(apr_bucket_brigade *b , apr_status_t (*flush)(apr_bucket_brigade *bb ,
                                                                              void *ctx ) ,
                                void *ctx , struct iovec  const  *vec , apr_size_t nvec ) ;
apr_status_t apr_brigade_puts(apr_bucket_brigade *bb , apr_status_t (*flush)(apr_bucket_brigade *bb ,
                                                                             void *ctx ) ,
                              void *ctx , char const   *str ) ;
apr_status_t apr_brigade_putstrs(apr_bucket_brigade *b , apr_status_t (*flush)(apr_bucket_brigade *bb ,
                                                                               void *ctx ) ,
                                 void *ctx  , ...) ;
apr_bucket *apr_bucket_eos_create(apr_bucket_alloc_t *list ) ;
int apr_is_empty_table(apr_table_t const   *t ) ;
int apr_is_empty_array(apr_array_header_t const   *a ) ;
char *apr_array_pstrcat(apr_pool_t *p , apr_array_header_t const   *arr , char sep ) ;
void apr_table_clear(apr_table_t *t ) ;
void apr_table_mergen(apr_table_t *t , char const   *key , char const   *val ) ;
void apr_table_addn(apr_table_t *t , char const   *key , char const   *val ) ;
int apr_table_do(apr_table_do_callback_fn_t *comp , void *rec , apr_table_t const   *t 
                 , ...) ;
extern long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                   int __base ) ;
char const   *ap_get_server_version(void) ;
int ap_find_list_item(apr_pool_t *p , char const   *line , char const   *tok ) ;
int ap_find_token(apr_pool_t *p , char const   *line , char const   *tok ) ;
int ap_find_last_token(apr_pool_t *p , char const   *line , char const   *tok ) ;
char const   *ap_psignature(char const   *prefix , request_rec *r ) ;
apr_status_t ap_get_brigade(ap_filter_t *next , apr_bucket_brigade *bb , ap_input_mode_t mode ,
                            apr_read_type_e block , apr_off_t readbytes ) ;
void ap_remove_output_filter(ap_filter_t *f ) ;
apr_hash_index_t *apr_hash_first(apr_pool_t *p , apr_hash_t *ht ) ;
apr_hash_index_t *apr_hash_next(apr_hash_index_t *hi ) ;
void apr_hash_this(apr_hash_index_t *hi , void const   **key , apr_ssize_t *klen ,
                   void **val ) ;
apr_off_t ap_get_limit_req_body(request_rec const   *r ) ;
void ap_add_output_filters_by_type(request_rec *r ) ;
void ap_get_mime_headers(request_rec *r ) ;
void ap_finalize_request_protocol(request_rec *r ) ;
void ap_send_error_response(request_rec *r , int recursive_error ) ;
int ap_set_keepalive(request_rec *r ) ;
char const   *ap_make_content_type(request_rec *r , char const   *type ) ;
char *ap_make_etag(request_rec *r , int force_weak ) ;
void ap_set_etag(request_rec *r ) ;
int ap_meets_conditions(request_rec *r ) ;
int ap_method_register(apr_pool_t *p , char const   *methname ) ;
ap_method_list_t *ap_make_method_list(apr_pool_t *p , int nelts ) ;
void ap_copy_method_list(ap_method_list_t *dest , ap_method_list_t *src ) ;
void ap_method_list_do(int (*comp)(void *urec , char const   *mname , int mnum ) ,
                       void *rec , ap_method_list_t const   *ml  , ...) ;
void ap_method_list_vdo(int (*comp)(void *mrec , char const   *mname , int mnum ) ,
                        void *rec , ap_method_list_t const   *ml , va_list vp ) ;
int ap_method_in_list(ap_method_list_t *l , char const   *method ) ;
void ap_method_list_add(ap_method_list_t *l , char const   *method ) ;
void ap_method_list_remove(ap_method_list_t *l , char const   *method ) ;
void ap_clear_method_list(ap_method_list_t *l ) ;
int ap_rputs(char const   *str , request_rec *r ) ;
int ap_rvputs(request_rec *r  , ...) ;
int ap_index_of_response(int status ) ;
char const   *ap_get_status_line(int status ) ;
int ap_setup_client_block(request_rec *r , int read_policy ) ;
int ap_should_client_block(request_rec *r ) ;
long ap_get_client_block(request_rec *r , char *buffer , apr_size_t bufsiz ) ;
int ap_discard_request_body(request_rec *r ) ;
int ap_method_number_of(char const   *method ) ;
char const   *ap_method_name_of(apr_pool_t *p , int methnum ) ;
struct apr_bucket_type_t  const  ap_bucket_type_error ;
apr_bucket *ap_bucket_error_create(int error , char const   *buf , apr_pool_t *p ,
                                   apr_bucket_alloc_t *list ) ;
void ap_die(int type , request_rec *r ) ;
void ( /* format attribute */  ap_log_perror)(char const   *file , int line , int level ,
                                              apr_status_t status , apr_pool_t *p ,
                                              char const   *fmt  , ...) ;
apr_time_t apr_date_parse_http(char const   *date ) ;
apr_status_t ap_recent_rfc822_date(char *date_str , apr_time_t t ) ;
char *ap_response_code_string(request_rec *r , int error_index ) ;
void ap_basic_http_header(request_rec *r , apr_bucket_brigade *bb ) ;
int ap_send_http_options(request_rec *r ) ;
static char const   * const  status_lines[57]  = 
  {      (char const   * const  )"100 Continue",      (char const   * const  )"101 Switching Protocols",      (char const   * const  )"102 Processing",      (char const   * const  )"200 OK", 
        (char const   * const  )"201 Created",      (char const   * const  )"202 Accepted",      (char const   * const  )"203 Non-Authoritative Information",      (char const   * const  )"204 No Content", 
        (char const   * const  )"205 Reset Content",      (char const   * const  )"206 Partial Content",      (char const   * const  )"207 Multi-Status",      (char const   * const  )"300 Multiple Choices", 
        (char const   * const  )"301 Moved Permanently",      (char const   * const  )"302 Found",      (char const   * const  )"303 See Other",      (char const   * const  )"304 Not Modified", 
        (char const   * const  )"305 Use Proxy",      (char const   * const  )"306 unused",      (char const   * const  )"307 Temporary Redirect",      (char const   * const  )"400 Bad Request", 
        (char const   * const  )"401 Authorization Required",      (char const   * const  )"402 Payment Required",      (char const   * const  )"403 Forbidden",      (char const   * const  )"404 Not Found", 
        (char const   * const  )"405 Method Not Allowed",      (char const   * const  )"406 Not Acceptable",      (char const   * const  )"407 Proxy Authentication Required",      (char const   * const  )"408 Request Time-out", 
        (char const   * const  )"409 Conflict",      (char const   * const  )"410 Gone",      (char const   * const  )"411 Length Required",      (char const   * const  )"412 Precondition Failed", 
        (char const   * const  )"413 Request Entity Too Large",      (char const   * const  )"414 Request-URI Too Large",      (char const   * const  )"415 Unsupported Media Type",      (char const   * const  )"416 Requested Range Not Satisfiable", 
        (char const   * const  )"417 Expectation Failed",      (char const   * const  )"418 unused",      (char const   * const  )"419 unused",      (char const   * const  )"420 unused", 
        (char const   * const  )"421 unused",      (char const   * const  )"422 Unprocessable Entity",      (char const   * const  )"423 Locked",      (char const   * const  )"424 Failed Dependency", 
        (char const   * const  )"425 No code",      (char const   * const  )"426 Upgrade Required",      (char const   * const  )"500 Internal Server Error",      (char const   * const  )"501 Method Not Implemented", 
        (char const   * const  )"502 Bad Gateway",      (char const   * const  )"503 Service Temporarily Unavailable",      (char const   * const  )"504 Gateway Time-out",      (char const   * const  )"505 HTTP Version Not Supported", 
        (char const   * const  )"506 Variant Also Negotiates",      (char const   * const  )"507 Insufficient Storage",      (char const   * const  )"508 unused",      (char const   * const  )"509 unused", 
        (char const   * const  )"510 Not Extended"};
int ap_set_keepalive(request_rec *r ) 
{ int ka_sent ;
  int wimpy ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *conn ;
  char const   *tmp___1 ;
  int left ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
  ka_sent = 0;
  tmp = apr_table_get((apr_table_t const   *)r->headers_out, "Connection");
  tmp___0 = ap_find_token(r->pool, tmp, "close");
  wimpy = tmp___0;
  tmp___1 = apr_table_get((apr_table_t const   *)r->headers_in, "Connection");
  conn = tmp___1;
  if ((int )(r->connection)->keepalive != 1) {
    if (r->status == 304) {
      goto _L___23;
    } else {
      if (r->status == 204) {
        _L___23: 
        goto _L___22;
      } else {
        if (r->header_only) {
          _L___22: 
          goto _L___21;
        } else {
          tmp___4 = apr_table_get((apr_table_t const   *)r->headers_out, "Content-Length");
          if (tmp___4) {
            _L___21: 
            goto _L___20;
          } else {
            tmp___5 = apr_table_get((apr_table_t const   *)r->headers_out, "Transfer-Encoding");
            tmp___6 = ap_find_last_token(r->pool, tmp___5, "chunked");
            if (tmp___6) {
              _L___20: 
              goto _L___18;
            } else {
              if (r->proto_num >= 1001) {
                r->chunked = 1;
                if (r->chunked) {
                  _L___18: 
                  if ((r->server)->keep_alive) {
                    if ((r->server)->keep_alive_timeout > 0LL) {
                      if ((r->server)->keep_alive_max == 0) {
                        goto _L___14;
                      } else {
                        if ((r->server)->keep_alive_max > (r->connection)->keepalives) {
                          _L___14: 
                          if (r->status == 400) {
                            goto _L___12;
                          } else {
                            if (r->status == 408) {
                              _L___12: 
                              goto _L___11;
                            } else {
                              if (r->status == 411) {
                                _L___11: 
                                goto _L___10;
                              } else {
                                if (r->status == 413) {
                                  _L___10: 
                                  goto _L___9;
                                } else {
                                  if (r->status == 414) {
                                    _L___9: 
                                    goto _L___8;
                                  } else {
                                    if (r->status == 500) {
                                      _L___8: 
                                      goto _L___7;
                                    } else {
                                      if (r->status == 503) {
                                        _L___7: 
                                        goto _L___6;
                                      } else {
                                        if (r->status == 501) {
                                          _L___6: 
                                          goto _L___17;
                                        } else {
                                          if (! wimpy) {
                                            tmp___7 = ap_find_token(r->pool, conn,
                                                                    "close");
                                            if (tmp___7) {
                                              goto _L___17;
                                            } else {
                                              tmp___8 = apr_table_get((apr_table_t const   *)r->subprocess_env,
                                                                      "nokeepalive");
                                              if (tmp___8) {
                                                tmp___9 = apr_table_get((apr_table_t const   *)r->headers_in,
                                                                        "Via");
                                                if (tmp___9) {
                                                  _L___2: 
                                                  ka_sent = ap_find_token(r->pool,
                                                                          conn, "keep-alive");
                                                  if (ka_sent) {
                                                    goto _L___0;
                                                  } else {
                                                    if (r->proto_num >= 1001) {
                                                      _L___0: 
                                                      left = (r->server)->keep_alive_max -
                                                             (r->connection)->keepalives;
                                                      (r->connection)->keepalive = (enum __anonenum_ap_conn_keepalive_e_69 )2;
                                                      (r->connection)->keepalives = (r->connection)->keepalives +
                                                                                    1;
                                                      if (ka_sent) {
                                                        if ((r->server)->keep_alive_max) {
                                                          tmp___2 = apr_psprintf(r->pool,
                                                                                 "timeout=%d, max=%d",
                                                                                 (int )((r->server)->keep_alive_timeout /
                                                                                        1000000LL),
                                                                                 left);
                                                          apr_table_setn(r->headers_out,
                                                                         "Keep-Alive",
                                                                         tmp___2);
                                                        } else {
                                                          tmp___3 = apr_psprintf(r->pool,
                                                                                 "timeout=%d",
                                                                                 (int )((r->server)->keep_alive_timeout /
                                                                                        1000000LL));
                                                          apr_table_setn(r->headers_out,
                                                                         "Keep-Alive",
                                                                         tmp___3);
                                                        }
                                                        apr_table_mergen(r->headers_out,
                                                                         "Connection",
                                                                         "Keep-Alive");
                                                      }
                                                      return (1);
                                                    } else {
                                                      goto _L___17;
                                                    }
                                                  }
                                                } else {
                                                  goto _L___17;
                                                }
                                              } else {
                                                goto _L___2;
                                              }
                                            }
                                          } else {
                                            goto _L___17;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          goto _L___17;
                        }
                      }
                    } else {
                      goto _L___17;
                    }
                  } else {
                    goto _L___17;
                  }
                } else {
                  goto _L___19;
                }
              } else {
                _L___19: 
                goto _L___17;
              }
            }
          }
        }
      }
    }
  } else {
    _L___17: ;
  }
  if (! wimpy) {
    apr_table_mergen(r->headers_out, "Connection", "close");
  }
  (r->connection)->keepalive = (enum __anonenum_ap_conn_keepalive_e_69 )1;
  return (0);
}
}
int ap_meets_conditions(request_rec *r ) 
{ char const   *etag ;
  char const   *if_match ;
  char const   *if_modified_since ;
  char const   *if_unmodified ;
  char const   *if_nonematch ;
  apr_time_t tmp_time ;
  apr_int64_t mtime ;
  int tmp___0 ;
  apr_time_t ius ;
  apr_time_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  apr_time_t ims_time ;
  apr_int64_t ims ;
  apr_int64_t reqtime ;

  {
  if (r->status >= 200) {
    if (r->status < 300) {
      if (r->no_local_copy) {
        _L: 
        return (0);
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    goto _L;
  }
  etag = apr_table_get((apr_table_t const   *)r->headers_out, "ETag");
  if (r->mtime != 0LL) {
    tmp_time = r->mtime;
  } else {
    tmp_time = apr_time_now();
  }
  mtime = tmp_time / 1000000LL;
  if_match = apr_table_get((apr_table_t const   *)r->headers_in, "If-Match");
  if ((unsigned int )if_match != (unsigned int )((void *)0)) {
    if ((int const   )(*(if_match + 0)) != 42) {
      if ((unsigned int )etag == (unsigned int )((void *)0)) {
        goto _L___3;
      } else {
        if ((int const   )(*(etag + 0)) == 87) {
          _L___3: 
          goto _L___2;
        } else {
          tmp___0 = ap_find_list_item(r->pool, if_match, etag);
          if (tmp___0) {
            goto _L___1;
          } else {
            _L___2: 
            return (412);
          }
        }
      }
    } else {
      _L___1: ;
    }
  } else {
    if_unmodified = apr_table_get((apr_table_t const   *)r->headers_in, "If-Unmodified-Since");
    if ((unsigned int )if_unmodified != (unsigned int )((void *)0)) {
      tmp___1 = apr_date_parse_http(if_unmodified);
      ius = tmp___1;
      if (ius != 0LL) {
        if (mtime > ius / 1000000LL) {
          return (412);
        } else {
          goto _L___4;
        }
      } else {
        _L___4: ;
      }
    }
  }
  if_nonematch = apr_table_get((apr_table_t const   *)r->headers_in, "If-None-Match");
  if ((unsigned int )if_nonematch != (unsigned int )((void *)0)) {
    if (r->method_number == 0) {
      if ((int const   )(*(if_nonematch + 0)) == 42) {
        return (304);
      }
      if ((unsigned int )etag != (unsigned int )((void *)0)) {
        tmp___4 = apr_table_get((apr_table_t const   *)r->headers_in, "Range");
        if (tmp___4) {
          if ((int const   )(*(etag + 0)) != 87) {
            tmp___2 = ap_find_list_item(r->pool, if_nonematch, etag);
            if (tmp___2) {
              return (304);
            } else {
              goto _L___5;
            }
          } else {
            _L___5: ;
          }
        } else {
          tmp___3 = strstr(if_nonematch, etag);
          if (tmp___3) {
            return (304);
          }
        }
      }
    } else {
      if ((int const   )(*(if_nonematch + 0)) == 42) {
        goto _L___6;
      } else {
        if ((unsigned int )etag != (unsigned int )((void *)0)) {
          tmp___5 = ap_find_list_item(r->pool, if_nonematch, etag);
          if (tmp___5) {
            _L___6: 
            return (412);
          } else {
            goto _L___7;
          }
        } else {
          _L___7: ;
        }
      }
    }
  } else {
    if (r->method_number == 0) {
      if_modified_since = apr_table_get((apr_table_t const   *)r->headers_in, "If-Modified-Since");
      if ((unsigned int )if_modified_since != (unsigned int )((void *)0)) {
        ims_time = apr_date_parse_http(if_modified_since);
        ims = ims_time / 1000000LL;
        reqtime = r->request_time / 1000000LL;
        if (ims >= mtime) {
          if (ims <= reqtime) {
            return (304);
          } else {
            goto _L___8;
          }
        } else {
          _L___8: ;
        }
      } else {
        goto _L___9;
      }
    } else {
      _L___9: ;
    }
  }
  return (0);
}
}
static apr_hash_t *methods_registry  =    (apr_hash_t *)((void *)0);
static int cur_method_number  =    27;
static void register_one_method(apr_pool_t *p , char const   *methname , int methnum ) 
{ int *pnum ;
  int *tmp ;

  {
  tmp = (int *)apr_palloc(p, sizeof((*pnum)));
  pnum = tmp;
  (*pnum) = methnum;
  apr_hash_set(methods_registry, (void const   *)methname, -1, (void const   *)pnum);
  return;
}
}
static apr_status_t ap_method_registry_destroy(void *notused ) 
{ 

  {
  methods_registry = (apr_hash_t *)((void *)0);
  cur_method_number = 27;
  return (0);
}
}
void ap_method_registry_init(apr_pool_t *p ) 
{ 

  {
  methods_registry = apr_hash_make(p);
  apr_pool_cleanup_register(p, (void const   *)((void *)0), & ap_method_registry_destroy,
                            & apr_pool_cleanup_null);
  register_one_method(p, "GET", 0);
  register_one_method(p, "PUT", 1);
  register_one_method(p, "POST", 2);
  register_one_method(p, "DELETE", 3);
  register_one_method(p, "CONNECT", 4);
  register_one_method(p, "OPTIONS", 5);
  register_one_method(p, "TRACE", 6);
  register_one_method(p, "PATCH", 7);
  register_one_method(p, "PROPFIND", 8);
  register_one_method(p, "PROPPATCH", 9);
  register_one_method(p, "MKCOL", 10);
  register_one_method(p, "COPY", 11);
  register_one_method(p, "MOVE", 12);
  register_one_method(p, "LOCK", 13);
  register_one_method(p, "UNLOCK", 14);
  register_one_method(p, "VERSION-CONTROL", 15);
  register_one_method(p, "CHECKOUT", 16);
  register_one_method(p, "UNCHECKOUT", 17);
  register_one_method(p, "CHECKIN", 18);
  register_one_method(p, "UPDATE", 19);
  register_one_method(p, "LABEL", 20);
  register_one_method(p, "REPORT", 21);
  register_one_method(p, "MKWORKSPACE", 22);
  register_one_method(p, "MKACTIVITY", 23);
  register_one_method(p, "BASELINE-CONTROL", 24);
  register_one_method(p, "MERGE", 25);
  return;
}
}
int ap_method_register(apr_pool_t *p , char const   *methname ) 
{ int *methnum ;
  int tmp___0 ;

  {
  if ((unsigned int )methods_registry == (unsigned int )((void *)0)) {
    ap_method_registry_init(p);
  }
  if ((unsigned int )methname == (unsigned int )((void *)0)) {
    return (26);
  }
  methnum = (int *)apr_hash_get(methods_registry, (void const   *)methname, -1);
  if ((unsigned int )methnum != (unsigned int )((void *)0)) {
    return ((*methnum));
  }
  if (cur_method_number > 62) {
    ap_log_perror("http_protocol.c", 506, 3, 0, p, "Maximum new request methods %d reached while registering method %s.",
                  62, methname);
    return (26);
  }
  register_one_method(p, methname, cur_method_number);
  tmp___0 = cur_method_number;
  cur_method_number ++;
  return (tmp___0);
}
}
static int lookup_builtin_method(char const   *method , apr_size_t len ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___64 ;
  int tmp___65 ;

  {
  switch ((int )len) {
  case 3: ;
  switch ((int )(*(method + 0))) {
  case 80: ;
  if ((int const   )(*(method + 1)) == 85) {
    if ((int const   )(*(method + 2)) == 84) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else {
    _L: 
    tmp = -1;
  }
  return (tmp);
  case 71: ;
  if ((int const   )(*(method + 1)) == 69) {
    if ((int const   )(*(method + 2)) == 84) {
      tmp___0 = 0;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    tmp___0 = -1;
  }
  return (tmp___0);
  default: ;
  return (-1);
  }
  case 4: ;
  switch ((int )(*(method + 0))) {
  case 72: ;
  if ((int const   )(*(method + 1)) == 69) {
    if ((int const   )(*(method + 2)) == 65) {
      if ((int const   )(*(method + 3)) == 68) {
        tmp___1 = 0;
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: 
    tmp___1 = -1;
  }
  return (tmp___1);
  case 80: ;
  if ((int const   )(*(method + 1)) == 79) {
    if ((int const   )(*(method + 2)) == 83) {
      if ((int const   )(*(method + 3)) == 84) {
        tmp___2 = 2;
      } else {
        goto _L___4;
      }
    } else {
      goto _L___4;
    }
  } else {
    _L___4: 
    tmp___2 = -1;
  }
  return (tmp___2);
  case 77: ;
  if ((int const   )(*(method + 1)) == 79) {
    if ((int const   )(*(method + 2)) == 86) {
      if ((int const   )(*(method + 3)) == 69) {
        tmp___3 = 12;
      } else {
        goto _L___6;
      }
    } else {
      goto _L___6;
    }
  } else {
    _L___6: 
    tmp___3 = -1;
  }
  return (tmp___3);
  case 76: ;
  if ((int const   )(*(method + 1)) == 79) {
    if ((int const   )(*(method + 2)) == 67) {
      if ((int const   )(*(method + 3)) == 75) {
        tmp___4 = 13;
      } else {
        goto _L___8;
      }
    } else {
      goto _L___8;
    }
  } else {
    _L___8: 
    tmp___4 = -1;
  }
  return (tmp___4);
  case 67: ;
  if ((int const   )(*(method + 1)) == 79) {
    if ((int const   )(*(method + 2)) == 80) {
      if ((int const   )(*(method + 3)) == 89) {
        tmp___5 = 11;
      } else {
        goto _L___10;
      }
    } else {
      goto _L___10;
    }
  } else {
    _L___10: 
    tmp___5 = -1;
  }
  return (tmp___5);
  default: ;
  return (-1);
  }
  case 5: ;
  switch ((int )(*(method + 2))) {
  case 84: 
  tmp___8 = memcmp((void const   *)method, (void const   *)"PATCH", 5U);
  if (tmp___8 == 0) {
    tmp___7 = 7;
  } else {
    tmp___7 = -1;
  }
  return (tmp___7);
  case 82: 
  tmp___11 = memcmp((void const   *)method, (void const   *)"MERGE", 5U);
  if (tmp___11 == 0) {
    tmp___10 = 25;
  } else {
    tmp___10 = -1;
  }
  return (tmp___10);
  case 67: 
  tmp___14 = memcmp((void const   *)method, (void const   *)"MKCOL", 5U);
  if (tmp___14 == 0) {
    tmp___13 = 10;
  } else {
    tmp___13 = -1;
  }
  return (tmp___13);
  case 66: 
  tmp___17 = memcmp((void const   *)method, (void const   *)"LABEL", 5U);
  if (tmp___17 == 0) {
    tmp___16 = 20;
  } else {
    tmp___16 = -1;
  }
  return (tmp___16);
  case 65: 
  tmp___20 = memcmp((void const   *)method, (void const   *)"TRACE", 5U);
  if (tmp___20 == 0) {
    tmp___19 = 6;
  } else {
    tmp___19 = -1;
  }
  return (tmp___19);
  default: ;
  return (-1);
  }
  case 6: ;
  switch ((int )(*(method + 0))) {
  case 85: ;
  switch ((int )(*(method + 5))) {
  case 75: 
  tmp___23 = memcmp((void const   *)method, (void const   *)"UNLOCK", 6U);
  if (tmp___23 == 0) {
    tmp___22 = 14;
  } else {
    tmp___22 = -1;
  }
  return (tmp___22);
  case 69: 
  tmp___26 = memcmp((void const   *)method, (void const   *)"UPDATE", 6U);
  if (tmp___26 == 0) {
    tmp___25 = 19;
  } else {
    tmp___25 = -1;
  }
  return (tmp___25);
  default: ;
  return (-1);
  }
  case 82: 
  tmp___29 = memcmp((void const   *)method, (void const   *)"REPORT", 6U);
  if (tmp___29 == 0) {
    tmp___28 = 21;
  } else {
    tmp___28 = -1;
  }
  return (tmp___28);
  case 68: 
  tmp___32 = memcmp((void const   *)method, (void const   *)"DELETE", 6U);
  if (tmp___32 == 0) {
    tmp___31 = 3;
  } else {
    tmp___31 = -1;
  }
  return (tmp___31);
  default: ;
  return (-1);
  }
  case 7: ;
  switch ((int )(*(method + 1))) {
  case 80: 
  tmp___35 = memcmp((void const   *)method, (void const   *)"OPTIONS", 7U);
  if (tmp___35 == 0) {
    tmp___34 = 5;
  } else {
    tmp___34 = -1;
  }
  return (tmp___34);
  case 79: 
  tmp___38 = memcmp((void const   *)method, (void const   *)"CONNECT", 7U);
  if (tmp___38 == 0) {
    tmp___37 = 4;
  } else {
    tmp___37 = -1;
  }
  return (tmp___37);
  case 72: 
  tmp___41 = memcmp((void const   *)method, (void const   *)"CHECKIN", 7U);
  if (tmp___41 == 0) {
    tmp___40 = 18;
  } else {
    tmp___40 = -1;
  }
  return (tmp___40);
  default: ;
  return (-1);
  }
  case 8: ;
  switch ((int )(*(method + 0))) {
  case 80: 
  tmp___44 = memcmp((void const   *)method, (void const   *)"PROPFIND", 8U);
  if (tmp___44 == 0) {
    tmp___43 = 8;
  } else {
    tmp___43 = -1;
  }
  return (tmp___43);
  case 67: 
  tmp___47 = memcmp((void const   *)method, (void const   *)"CHECKOUT", 8U);
  if (tmp___47 == 0) {
    tmp___46 = 16;
  } else {
    tmp___46 = -1;
  }
  return (tmp___46);
  default: ;
  return (-1);
  }
  case 9: 
  tmp___50 = memcmp((void const   *)method, (void const   *)"PROPPATCH", 9U);
  if (tmp___50 == 0) {
    tmp___49 = 9;
  } else {
    tmp___49 = -1;
  }
  return (tmp___49);
  case 10: ;
  switch ((int )(*(method + 0))) {
  case 85: 
  tmp___53 = memcmp((void const   *)method, (void const   *)"UNCHECKOUT", 10U);
  if (tmp___53 == 0) {
    tmp___52 = 17;
  } else {
    tmp___52 = -1;
  }
  return (tmp___52);
  case 77: 
  tmp___56 = memcmp((void const   *)method, (void const   *)"MKACTIVITY", 10U);
  if (tmp___56 == 0) {
    tmp___55 = 23;
  } else {
    tmp___55 = -1;
  }
  return (tmp___55);
  default: ;
  return (-1);
  }
  case 11: 
  tmp___59 = memcmp((void const   *)method, (void const   *)"MKWORKSPACE", 11U);
  if (tmp___59 == 0) {
    tmp___58 = 22;
  } else {
    tmp___58 = -1;
  }
  return (tmp___58);
  case 15: 
  tmp___62 = memcmp((void const   *)method, (void const   *)"VERSION-CONTROL", 15U);
  if (tmp___62 == 0) {
    tmp___61 = 15;
  } else {
    tmp___61 = -1;
  }
  return (tmp___61);
  case 16: 
  tmp___65 = memcmp((void const   *)method, (void const   *)"BASELINE-CONTROL", 16U);
  if (tmp___65 == 0) {
    tmp___64 = 24;
  } else {
    tmp___64 = -1;
  }
  return (tmp___64);
  default: ;
  return (-1);
  }
}
}
int ap_method_number_of(char const   *method ) 
{ int len ;
  int tmp ;
  int which ;
  int tmp___0 ;
  int *methnum ;
  int *tmp___1 ;

  {
  tmp = (int )strlen(method);
  len = tmp;
  tmp___0 = lookup_builtin_method(method, (unsigned int )len);
  which = tmp___0;
  if (which != -1) {
    return (which);
  }
  if ((unsigned int )methods_registry != (unsigned int )((void *)0)) {
    tmp___1 = (int *)apr_hash_get(methods_registry, (void const   *)method, len);
    methnum = tmp___1;
    if ((unsigned int )methnum != (unsigned int )((void *)0)) {
      return ((*methnum));
    }
  }
  return (26);
}
}
char const   *ap_method_name_of(apr_pool_t *p , int methnum ) 
{ apr_hash_index_t *hi ;
  apr_hash_index_t *tmp ;
  void const   *key ;
  void *val ;

  {
  tmp = apr_hash_first(p, methods_registry);
  hi = tmp;
  while (hi) {
    apr_hash_this(hi, & key, (apr_ssize_t *)((void *)0), & val);
    if ((*((int *)val)) == methnum) {
      return ((char const   *)key);
    }
    hi = apr_hash_next(hi);
  }
  return ((char const   *)((void *)0));
}
}
static long get_chunk_size(char *b ) ;
apr_status_t ap_http_filter(ap_filter_t *f , apr_bucket_brigade *b , ap_input_mode_t mode ,
                            apr_read_type_e block , apr_off_t readbytes ) 
{ apr_bucket *e ;
  http_ctx_t *ctx ;
  apr_status_t rv ;
  apr_off_t totalread ;
  apr_status_t tmp ;
  char const   *tenc ;
  char const   *lenp ;
  int tmp___0 ;
  int conversion_error ;
  char *endstr ;
  int *tmp___1 ;
  int *tmp___2 ;
  apr_bucket_brigade *bb ;
  apr_bucket *ap__b ;
  apr_bucket *ap__b___0 ;
  apr_status_t tmp___3 ;
  apr_bucket_brigade *bb___0 ;
  apr_bucket *ap__b___1 ;
  apr_bucket *ap__b___2 ;
  apr_status_t tmp___4 ;
  apr_bucket *ap__b___3 ;
  char *tmp___5 ;
  apr_bucket_brigade *bb___1 ;
  apr_size_t tmp___6 ;
  apr_bucket *ap__b___4 ;
  apr_bucket *ap__b___5 ;
  char line[30] ;
  apr_bucket_brigade *bb___2 ;
  apr_size_t len ;
  apr_bucket *ap__b___6 ;
  apr_bucket *ap__b___7 ;
  apr_status_t tmp___7 ;
  apr_bucket *ap__b___8 ;
  apr_bucket *ap__b___9 ;
  apr_bucket *ap__b___10 ;
  char line___0[30] ;
  apr_bucket_brigade *bb___3 ;
  apr_size_t len___0 ;
  apr_bucket *ap__b___11 ;
  apr_bucket *ap__b___12 ;
  apr_status_t tmp___8 ;
  apr_bucket *ap__b___13 ;
  apr_bucket *ap__b___14 ;
  apr_bucket_brigade *bb___4 ;
  apr_bucket *ap__b___15 ;
  apr_bucket *ap__b___16 ;
  apr_status_t tmp___9 ;

  {
  ctx = (http_ctx_t *)f->ctx;
  if ((int )mode != 0) {
    if ((int )mode != 1) {
      tmp = ap_get_brigade(f->next, b, mode, block, readbytes);
      return (tmp);
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if (! ctx) {
    ctx = (http_ctx_t *)apr_palloc((f->r)->pool, sizeof((*ctx)));
    f->ctx = (void *)ctx;
    ctx->state = (enum __anonenum_state_98 )0;
    ctx->remaining = 0L;
    ctx->limit_used = 0L;
    ctx->eos_sent = 0;
    if (! (f->r)->proxyreq) {
      ctx->limit = ap_get_limit_req_body((request_rec const   *)f->r);
    } else {
      ctx->limit = 0L;
    }
    tenc = apr_table_get((apr_table_t const   *)(f->r)->headers_in, "Transfer-Encoding");
    lenp = apr_table_get((apr_table_t const   *)(f->r)->headers_in, "Content-Length");
    if (tenc) {
      tmp___0 = strcasecmp(tenc, "chunked");
      if (! tmp___0) {
        ctx->state = (enum __anonenum_state_98 )2;
      }
    } else {
      if (lenp) {
        conversion_error = 0;
        ctx->state = (enum __anonenum_state_98 )1;
        tmp___1 = __errno_location();
        (*tmp___1) = 0;
        ctx->remaining = strtol((char const   * __restrict  )lenp, (char ** __restrict  )(& endstr),
                                10);
        tmp___2 = __errno_location();
        if ((*tmp___2)) {
          goto _L___1;
        } else {
          if (endstr) {
            if ((*endstr)) {
              _L___1: 
              goto _L___0;
            } else {
              goto _L___2;
            }
          } else {
            _L___2: 
            if (ctx->remaining < 0L) {
              _L___0: 
              conversion_error = 1;
            }
          }
        }
        if (conversion_error) {
          ap_log_rerror("http_protocol.c", 824, 3, 0, (request_rec const   *)f->r,
                        "Invalid Content-Length");
          bb = apr_brigade_create((f->r)->pool, (f->c)->bucket_alloc);
          e = ap_bucket_error_create(413, (char const   *)((void *)0), (f->r)->pool,
                                     (f->c)->bucket_alloc);
          while (1) {
            ap__b = e;
            while (1) {
              ap__b->link.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                      (char *)((void *)0)));
              ap__b->link.prev = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0))))->link.prev;
              (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                     (char *)((void *)0))))->link.prev)->link.next = ap__b;
              ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                    (char *)((void *)0))))->link.prev = ap__b;
              break;
            }
            break;
          }
          e = apr_bucket_eos_create((f->c)->bucket_alloc);
          while (1) {
            ap__b___0 = e;
            while (1) {
              ap__b___0->link.next = (struct apr_bucket *)((char *)(& bb->list) -
                                                           (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                   (char *)((void *)0)));
              ap__b___0->link.prev = ((struct apr_bucket *)((char *)(& bb->list) -
                                                            (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                    (char *)((void *)0))))->link.prev;
              (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                     (char *)((void *)0))))->link.prev)->link.next = ap__b___0;
              ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                    (char *)((void *)0))))->link.prev = ap__b___0;
              break;
            }
            break;
          }
          ctx->eos_sent = 1;
          tmp___3 = ap_pass_brigade((f->r)->output_filters, bb);
          return (tmp___3);
        }
        if (ctx->limit) {
          if (ctx->limit < ctx->remaining) {
            ap_log_rerror("http_protocol.c", 842, 3, 0, (request_rec const   *)f->r,
                          "Requested content-length of %ld is larger than the configured limit of %ld",
                          ctx->remaining, ctx->limit);
            bb___0 = apr_brigade_create((f->r)->pool, (f->c)->bucket_alloc);
            e = ap_bucket_error_create(413, (char const   *)((void *)0), (f->r)->pool,
                                       (f->c)->bucket_alloc);
            while (1) {
              ap__b___1 = e;
              while (1) {
                ap__b___1->link.next = (struct apr_bucket *)((char *)(& bb___0->list) -
                                                             (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                     (char *)((void *)0)));
                ap__b___1->link.prev = ((struct apr_bucket *)((char *)(& bb___0->list) -
                                                              (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                      (char *)((void *)0))))->link.prev;
                (((struct apr_bucket *)((char *)(& bb___0->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                           (char *)((void *)0))))->link.prev)->link.next = ap__b___1;
                ((struct apr_bucket *)((char *)(& bb___0->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                          (char *)((void *)0))))->link.prev = ap__b___1;
                break;
              }
              break;
            }
            e = apr_bucket_eos_create((f->c)->bucket_alloc);
            while (1) {
              ap__b___2 = e;
              while (1) {
                ap__b___2->link.next = (struct apr_bucket *)((char *)(& bb___0->list) -
                                                             (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                     (char *)((void *)0)));
                ap__b___2->link.prev = ((struct apr_bucket *)((char *)(& bb___0->list) -
                                                              (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                      (char *)((void *)0))))->link.prev;
                (((struct apr_bucket *)((char *)(& bb___0->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                           (char *)((void *)0))))->link.prev)->link.next = ap__b___2;
                ((struct apr_bucket *)((char *)(& bb___0->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                          (char *)((void *)0))))->link.prev = ap__b___2;
                break;
              }
              break;
            }
            ctx->eos_sent = 1;
            tmp___4 = ap_pass_brigade((f->r)->output_filters, bb___0);
            return (tmp___4);
          } else {
            goto _L___3;
          }
        } else {
          _L___3: ;
        }
      }
    }
    if ((int )ctx->state == 0) {
      if ((f->r)->proxyreq != 3) {
        e = apr_bucket_eos_create((f->c)->bucket_alloc);
        while (1) {
          ap__b___3 = e;
          while (1) {
            ap__b___3->link.next = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0)));
            ap__b___3->link.prev = ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                        (char *)((void *)0))))->link.prev;
            (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                  (char *)((void *)0))))->link.prev)->link.next = ap__b___3;
            ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0))))->link.prev = ap__b___3;
            break;
          }
          break;
        }
        ctx->eos_sent = 1;
        return (0);
      } else {
        goto _L___4;
      }
    } else {
      _L___4: ;
    }
    if ((int )ctx->state == 2) {
      goto _L___7;
    } else {
      if ((int )ctx->state == 1) {
        if (ctx->remaining > 0L) {
          _L___7: 
          if ((f->r)->expecting_100) {
            if ((f->r)->proto_num >= 1001) {
              tmp___5 = apr_pstrcat((f->r)->pool, "HTTP/1.1", " ", status_lines[0],
                                    "\r\n\r\n", (void *)0);
              bb___1 = apr_brigade_create((f->r)->pool, (f->c)->bucket_alloc);
              tmp___6 = strlen((char const   *)tmp___5);
              e = apr_bucket_pool_create((char const   *)tmp___5, tmp___6, (f->r)->pool,
                                         (f->c)->bucket_alloc);
              while (1) {
                ap__b___4 = e;
                while (1) {
                  ap__b___4->link.prev = (struct apr_bucket *)((char *)(& bb___1->list) -
                                                               (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                       (char *)((void *)0)));
                  ap__b___4->link.next = ((struct apr_bucket *)((char *)(& bb___1->list) -
                                                                (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                        (char *)((void *)0))))->link.next;
                  (((struct apr_bucket *)((char *)(& bb___1->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                             (char *)((void *)0))))->link.next)->link.prev = ap__b___4;
                  ((struct apr_bucket *)((char *)(& bb___1->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                            (char *)((void *)0))))->link.next = ap__b___4;
                  break;
                }
                break;
              }
              e = apr_bucket_flush_create((f->c)->bucket_alloc);
              while (1) {
                ap__b___5 = e;
                while (1) {
                  ap__b___5->link.next = (struct apr_bucket *)((char *)(& bb___1->list) -
                                                               (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                       (char *)((void *)0)));
                  ap__b___5->link.prev = ((struct apr_bucket *)((char *)(& bb___1->list) -
                                                                (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                        (char *)((void *)0))))->link.prev;
                  (((struct apr_bucket *)((char *)(& bb___1->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                             (char *)((void *)0))))->link.prev)->link.next = ap__b___5;
                  ((struct apr_bucket *)((char *)(& bb___1->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                            (char *)((void *)0))))->link.prev = ap__b___5;
                  break;
                }
                break;
              }
              ap_pass_brigade((f->c)->output_filters, bb___1);
            } else {
              goto _L___8;
            }
          } else {
            goto _L___8;
          }
        } else {
          goto _L___8;
        }
      } else {
        _L___8: ;
      }
    }
    if ((int )ctx->state == 2) {
      len = 30U;
      bb___2 = apr_brigade_create((f->r)->pool, (f->c)->bucket_alloc);
      rv = ap_get_brigade(f->next, bb___2, (enum __anonenum_ap_input_mode_t_70 )1,
                          (enum __anonenum_apr_read_type_e_60 )0, 0L);
      if (rv == 0) {
        rv = apr_brigade_flatten(bb___2, line, & len);
        if (rv == 0) {
          ctx->remaining = get_chunk_size(line);
        }
      }
      apr_brigade_cleanup((void *)bb___2);
      if (rv != 0) {
        goto _L___9;
      } else {
        if (ctx->remaining < 0L) {
          _L___9: 
          ctx->remaining = 0L;
          e = ap_bucket_error_create(413, (char const   *)((void *)0), (f->r)->pool,
                                     (f->c)->bucket_alloc);
          while (1) {
            ap__b___6 = e;
            while (1) {
              ap__b___6->link.next = (struct apr_bucket *)((char *)(& bb___2->list) -
                                                           (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                   (char *)((void *)0)));
              ap__b___6->link.prev = ((struct apr_bucket *)((char *)(& bb___2->list) -
                                                            (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                    (char *)((void *)0))))->link.prev;
              (((struct apr_bucket *)((char *)(& bb___2->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                         (char *)((void *)0))))->link.prev)->link.next = ap__b___6;
              ((struct apr_bucket *)((char *)(& bb___2->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                        (char *)((void *)0))))->link.prev = ap__b___6;
              break;
            }
            break;
          }
          e = apr_bucket_eos_create((f->c)->bucket_alloc);
          while (1) {
            ap__b___7 = e;
            while (1) {
              ap__b___7->link.next = (struct apr_bucket *)((char *)(& bb___2->list) -
                                                           (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                   (char *)((void *)0)));
              ap__b___7->link.prev = ((struct apr_bucket *)((char *)(& bb___2->list) -
                                                            (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                    (char *)((void *)0))))->link.prev;
              (((struct apr_bucket *)((char *)(& bb___2->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                         (char *)((void *)0))))->link.prev)->link.next = ap__b___7;
              ((struct apr_bucket *)((char *)(& bb___2->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                        (char *)((void *)0))))->link.prev = ap__b___7;
              break;
            }
            break;
          }
          ctx->eos_sent = 1;
          tmp___7 = ap_pass_brigade((f->r)->output_filters, bb___2);
          return (tmp___7);
        }
      }
      if (! ctx->remaining) {
        ctx->state = (enum __anonenum_state_98 )0;
        ap_get_mime_headers(f->r);
        e = apr_bucket_eos_create((f->c)->bucket_alloc);
        while (1) {
          ap__b___8 = e;
          while (1) {
            ap__b___8->link.next = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0)));
            ap__b___8->link.prev = ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                        (char *)((void *)0))))->link.prev;
            (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                  (char *)((void *)0))))->link.prev)->link.next = ap__b___8;
            ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0))))->link.prev = ap__b___8;
            break;
          }
          break;
        }
        ctx->eos_sent = 1;
        return (0);
      }
    }
  }
  if (ctx->eos_sent) {
    e = apr_bucket_eos_create((f->c)->bucket_alloc);
    while (1) {
      ap__b___9 = e;
      while (1) {
        ap__b___9->link.next = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                   (char *)((void *)0)));
        ap__b___9->link.prev = ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                    (char *)((void *)0))))->link.prev;
        (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                              (char *)((void *)0))))->link.prev)->link.next = ap__b___9;
        ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                             (char *)((void *)0))))->link.prev = ap__b___9;
        break;
      }
      break;
    }
    return (0);
  }
  if (! ctx->remaining) {
    switch ((int )ctx->state) {
    case 0: ;
    break;
    case 1: 
    e = apr_bucket_eos_create((f->c)->bucket_alloc);
    while (1) {
      ap__b___10 = e;
      while (1) {
        ap__b___10->link.next = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                    (char *)((void *)0)));
        ap__b___10->link.prev = ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                     (char *)((void *)0))))->link.prev;
        (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                              (char *)((void *)0))))->link.prev)->link.next = ap__b___10;
        ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                             (char *)((void *)0))))->link.prev = ap__b___10;
        break;
      }
      break;
    }
    ctx->eos_sent = 1;
    return (0);
    case 2: 
    len___0 = 30U;
    bb___3 = apr_brigade_create((f->r)->pool, (f->c)->bucket_alloc);
    rv = ap_get_brigade(f->next, bb___3, (enum __anonenum_ap_input_mode_t_70 )1, (enum __anonenum_apr_read_type_e_60 )0,
                        0L);
    apr_brigade_cleanup((void *)bb___3);
    if (rv == 0) {
      rv = ap_get_brigade(f->next, bb___3, (enum __anonenum_ap_input_mode_t_70 )1,
                          (enum __anonenum_apr_read_type_e_60 )0, 0L);
      if (rv == 0) {
        rv = apr_brigade_flatten(bb___3, line___0, & len___0);
        if (rv == 0) {
          ctx->remaining = get_chunk_size(line___0);
        }
      }
      apr_brigade_cleanup((void *)bb___3);
    }
    if (rv != 0) {
      goto _L___10;
    } else {
      if (ctx->remaining < 0L) {
        _L___10: 
        ctx->remaining = 0L;
        e = ap_bucket_error_create(413, (char const   *)((void *)0), (f->r)->pool,
                                   (f->c)->bucket_alloc);
        while (1) {
          ap__b___11 = e;
          while (1) {
            ap__b___11->link.next = (struct apr_bucket *)((char *)(& bb___3->list) -
                                                          (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                  (char *)((void *)0)));
            ap__b___11->link.prev = ((struct apr_bucket *)((char *)(& bb___3->list) -
                                                           (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                   (char *)((void *)0))))->link.prev;
            (((struct apr_bucket *)((char *)(& bb___3->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                       (char *)((void *)0))))->link.prev)->link.next = ap__b___11;
            ((struct apr_bucket *)((char *)(& bb___3->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                      (char *)((void *)0))))->link.prev = ap__b___11;
            break;
          }
          break;
        }
        e = apr_bucket_eos_create((f->c)->bucket_alloc);
        while (1) {
          ap__b___12 = e;
          while (1) {
            ap__b___12->link.next = (struct apr_bucket *)((char *)(& bb___3->list) -
                                                          (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                  (char *)((void *)0)));
            ap__b___12->link.prev = ((struct apr_bucket *)((char *)(& bb___3->list) -
                                                           (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                   (char *)((void *)0))))->link.prev;
            (((struct apr_bucket *)((char *)(& bb___3->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                       (char *)((void *)0))))->link.prev)->link.next = ap__b___12;
            ((struct apr_bucket *)((char *)(& bb___3->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                      (char *)((void *)0))))->link.prev = ap__b___12;
            break;
          }
          break;
        }
        ctx->eos_sent = 1;
        tmp___8 = ap_pass_brigade((f->r)->output_filters, bb___3);
        return (tmp___8);
      }
    }
    if (! ctx->remaining) {
      ctx->state = (enum __anonenum_state_98 )0;
      ap_get_mime_headers(f->r);
      e = apr_bucket_eos_create((f->c)->bucket_alloc);
      while (1) {
        ap__b___13 = e;
        while (1) {
          ap__b___13->link.next = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                      (char *)((void *)0)));
          ap__b___13->link.prev = ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0))))->link.prev)->link.next = ap__b___13;
          ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                               (char *)((void *)0))))->link.prev = ap__b___13;
          break;
        }
        break;
      }
      ctx->eos_sent = 1;
      return (0);
    }
    break;
    }
  }
  if ((int )ctx->state == 1) {
    goto _L___11;
  } else {
    if ((int )ctx->state == 2) {
      _L___11: 
      if (ctx->remaining < readbytes) {
        readbytes = ctx->remaining;
      }
    }
  }
  rv = ap_get_brigade(f->next, b, mode, block, readbytes);
  if (rv != 0) {
    return (rv);
  }
  apr_brigade_length(b, 0, & totalread);
  if ((int )ctx->state != 0) {
    ctx->remaining -= totalread;
  }
  if ((int )ctx->state == 1) {
    if (ctx->remaining == 0L) {
      e = apr_bucket_eos_create((f->c)->bucket_alloc);
      while (1) {
        ap__b___14 = e;
        while (1) {
          ap__b___14->link.next = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                      (char *)((void *)0)));
          ap__b___14->link.prev = ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0))))->link.prev)->link.next = ap__b___14;
          ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                               (char *)((void *)0))))->link.prev = ap__b___14;
          break;
        }
        break;
      }
    } else {
      goto _L___12;
    }
  } else {
    _L___12: ;
  }
  if (ctx->limit) {
    ctx->limit_used += totalread;
    if (ctx->limit < ctx->limit_used) {
      ap_log_rerror("http_protocol.c", 1050, 3, 0, (request_rec const   *)f->r, "Read content-length of %ld is larger than the configured limit of %ld",
                    ctx->limit_used, ctx->limit);
      bb___4 = apr_brigade_create((f->r)->pool, (f->c)->bucket_alloc);
      e = ap_bucket_error_create(413, (char const   *)((void *)0), (f->r)->pool, (f->c)->bucket_alloc);
      while (1) {
        ap__b___15 = e;
        while (1) {
          ap__b___15->link.next = (struct apr_bucket *)((char *)(& bb___4->list) -
                                                        (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0)));
          ap__b___15->link.prev = ((struct apr_bucket *)((char *)(& bb___4->list) -
                                                         (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& bb___4->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                     (char *)((void *)0))))->link.prev)->link.next = ap__b___15;
          ((struct apr_bucket *)((char *)(& bb___4->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                    (char *)((void *)0))))->link.prev = ap__b___15;
          break;
        }
        break;
      }
      e = apr_bucket_eos_create((f->c)->bucket_alloc);
      while (1) {
        ap__b___16 = e;
        while (1) {
          ap__b___16->link.next = (struct apr_bucket *)((char *)(& bb___4->list) -
                                                        (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0)));
          ap__b___16->link.prev = ((struct apr_bucket *)((char *)(& bb___4->list) -
                                                         (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& bb___4->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                     (char *)((void *)0))))->link.prev)->link.next = ap__b___16;
          ((struct apr_bucket *)((char *)(& bb___4->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                    (char *)((void *)0))))->link.prev = ap__b___16;
          break;
        }
        break;
      }
      ctx->eos_sent = 1;
      tmp___9 = ap_pass_brigade((f->r)->output_filters, bb___4);
      return (tmp___9);
    }
  }
  return (0);
}
}
static int shortcut[6]  = {      0,      3,      11,      19, 
        46,      57};
int ap_index_of_response(int status ) 
{ int i ;
  int pos ;

  {
  if (status < 100) {
    return (46);
  }
  i = 0;
  while (i < 5) {
    status -= 100;
    if (status < 100) {
      pos = status + shortcut[i];
      if (pos < shortcut[i + 1]) {
        return (pos);
      } else {
        return (46);
      }
    }
    i ++;
  }
  return (46);
}
}
char const   *ap_get_status_line(int status ) 
{ int tmp ;

  {
  tmp = ap_index_of_response(status);
  return ((char const   *)status_lines[tmp]);
}
}
static int form_header_field(header_struct *h , char const   *fieldname , char const   *fieldval ) 
{ struct iovec vec[4] ;
  struct iovec *v ;

  {
  v = vec;
  v->iov_base = (void *)fieldname;
  v->iov_len = strlen(fieldname);
  v ++;
  v->iov_base = (void *)": ";
  v->iov_len = sizeof(": ") - 1U;
  v ++;
  v->iov_base = (void *)fieldval;
  v->iov_len = strlen(fieldval);
  v ++;
  v->iov_base = (void *)"\r\n";
  v->iov_len = sizeof("\r\n") - 1U;
  apr_brigade_writev(h->bb, (apr_status_t (*)(apr_bucket_brigade *bb , void *ctx ))((void *)0),
                     (void *)0, (struct iovec  const  *)(vec), 4U);
  return (1);
}
}
static apr_status_t send_all_header_fields(header_struct *h , request_rec const   *r ) 
{ apr_array_header_t const   *elts ;
  apr_table_entry_t const   *t_elt ;
  apr_table_entry_t const   *t_end ;
  struct iovec *vec ;
  struct iovec *vec_next ;
  apr_status_t tmp___0 ;

  {
  elts = apr_table_elts((apr_table_t const   *)r->headers_out);
  if (elts->nelts == 0) {
    return (0);
  }
  t_elt = (apr_table_entry_t const   *)elts->elts;
  t_end = t_elt + elts->nelts;
  vec = (struct iovec *)apr_palloc(h->pool, (unsigned int )(4 * elts->nelts) * sizeof(struct iovec ));
  vec_next = vec;
  while (1) {
    vec_next->iov_base = (void *)t_elt->key;
    vec_next->iov_len = strlen((char const   *)t_elt->key);
    vec_next ++;
    vec_next->iov_base = (void *)": ";
    vec_next->iov_len = sizeof(": ") - 1U;
    vec_next ++;
    vec_next->iov_base = (void *)t_elt->val;
    vec_next->iov_len = strlen((char const   *)t_elt->val);
    vec_next ++;
    vec_next->iov_base = (void *)"\r\n";
    vec_next->iov_len = sizeof("\r\n") - 1U;
    vec_next ++;
    t_elt ++;
    if (! ((unsigned int )t_elt < (unsigned int )t_end)) {
      break;
    }
  }
  tmp___0 = apr_brigade_writev(h->bb, (apr_status_t (*)(apr_bucket_brigade *bb , void *ctx ))((void *)0),
                               (void *)0, (struct iovec  const  *)vec, (unsigned int )(vec_next -
                                                                                       vec));
  return (tmp___0);
}
}
static void basic_http_header_check(request_rec *r , char const   **protocol ) 
{ int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  if (r->assbackwards) {
    return;
  }
  if (! r->status_line) {
    tmp = ap_index_of_response(r->status);
    r->status_line = (char const   *)status_lines[tmp];
  }
  if (r->proto_num > 1000) {
    tmp___0 = apr_table_get((apr_table_t const   *)r->subprocess_env, "downgrade-1.0");
    if (tmp___0) {
      r->proto_num = 1000;
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if (r->proto_num == 1000) {
    tmp___1 = apr_table_get((apr_table_t const   *)r->subprocess_env, "force-response-1.0");
    if (tmp___1) {
      (*protocol) = "HTTP/1.0";
      (r->connection)->keepalive = (enum __anonenum_ap_conn_keepalive_e_69 )1;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    (*protocol) = "HTTP/1.1";
  }
  return;
}
}
static void basic_http_header(request_rec *r , apr_bucket_brigade *bb , char const   *protocol ) 
{ char *date ;
  char const   *server ;
  header_struct h ;
  struct iovec vec[4] ;
  char const   *tmp ;

  {
  if (r->assbackwards) {
    return;
  }
  vec[0].iov_base = (void *)protocol;
  vec[0].iov_len = strlen(protocol);
  vec[1].iov_base = (void *)" ";
  vec[1].iov_len = sizeof(" ") - 1U;
  vec[2].iov_base = (void *)r->status_line;
  vec[2].iov_len = strlen(r->status_line);
  vec[3].iov_base = (void *)"\r\n";
  vec[3].iov_len = sizeof("\r\n") - 1U;
  apr_brigade_writev(bb, (apr_status_t (*)(apr_bucket_brigade *bb , void *ctx ))((void *)0),
                     (void *)0, (struct iovec  const  *)(vec), 4U);
  date = (char *)apr_palloc(r->pool, 30U);
  ap_recent_rfc822_date(date, r->request_time);
  h.pool = r->pool;
  h.bb = bb;
  form_header_field(& h, "Date", (char const   *)date);
  server = apr_table_get((apr_table_t const   *)r->headers_out, "Server");
  if ((unsigned int )server != (unsigned int )((void *)0)) {
    form_header_field(& h, "Server", server);
  } else {
    tmp = ap_get_server_version();
    form_header_field(& h, "Server", tmp);
  }
  apr_table_unset(r->headers_out, "Date");
  apr_table_unset(r->headers_out, "Server");
  return;
}
}
void ap_basic_http_header(request_rec *r , apr_bucket_brigade *bb ) 
{ char const   *protocol ;

  {
  basic_http_header_check(r, & protocol);
  basic_http_header(r, bb, protocol);
  return;
}
}
static void terminate_header(apr_bucket_brigade *bb ) 
{ char tmp[27] ;
  char crlf[3] ;
  apr_off_t len ;
  apr_size_t buflen ;

  {
  tmp[0] = (char )'X';
  tmp[1] = (char )'-';
  tmp[2] = (char )'P';
  tmp[3] = (char )'a';
  tmp[4] = (char )'d';
  tmp[5] = (char )':';
  tmp[6] = (char )' ';
  tmp[7] = (char )'a';
  tmp[8] = (char )'v';
  tmp[9] = (char )'o';
  tmp[10] = (char )'i';
  tmp[11] = (char )'d';
  tmp[12] = (char )' ';
  tmp[13] = (char )'b';
  tmp[14] = (char )'r';
  tmp[15] = (char )'o';
  tmp[16] = (char )'w';
  tmp[17] = (char )'s';
  tmp[18] = (char )'e';
  tmp[19] = (char )'r';
  tmp[20] = (char )' ';
  tmp[21] = (char )'b';
  tmp[22] = (char )'u';
  tmp[23] = (char )'g';
  tmp[24] = (char )'\r';
  tmp[25] = (char )'\n';
  tmp[26] = (char )'\000';
  crlf[0] = (char )'\r';
  crlf[1] = (char )'\n';
  crlf[2] = (char )'\000';
  apr_brigade_length(bb, 1, & len);
  if (len >= 255L) {
    if (len <= 257L) {
      buflen = strlen((char const   *)(tmp));
      apr_brigade_write(bb, (apr_status_t (*)(apr_bucket_brigade *bb , void *ctx ))((void *)0),
                        (void *)0, (char const   *)(tmp), buflen);
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  buflen = strlen((char const   *)(crlf));
  apr_brigade_write(bb, (apr_status_t (*)(apr_bucket_brigade *bb , void *ctx ))((void *)0),
                    (void *)0, (char const   *)(crlf), buflen);
  return;
}
}
static char *make_allow(request_rec *r ) 
{ char *list ;
  apr_int64_t mask ;
  apr_array_header_t *allow ;
  apr_array_header_t *tmp ;
  apr_hash_index_t *hi ;
  apr_hash_index_t *tmp___0 ;
  void const   *key ;
  void *val ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int i ;
  char **xmethod ;

  {
  tmp = apr_array_make(r->pool, 10, (int )sizeof(char *));
  allow = tmp;
  tmp___0 = apr_hash_first(r->pool, methods_registry);
  hi = tmp___0;
  mask = (r->allowed_methods)->method_mask;
  while (hi) {
    apr_hash_this(hi, & key, (apr_ssize_t *)((void *)0), & val);
    if ((mask & (1LL << (*((int *)val)))) != 0LL) {
      tmp___1 = apr_array_push(allow);
      (*((char const   **)tmp___1)) = (char const   *)key;
      if ((*((int *)val)) == 0) {
        tmp___2 = apr_array_push(allow);
        (*((char const   **)tmp___2)) = "HEAD";
      }
    }
    hi = apr_hash_next(hi);
  }
  tmp___3 = apr_array_push(allow);
  (*((char const   **)tmp___3)) = "TRACE";
  list = apr_array_pstrcat(r->pool, (apr_array_header_t const   *)allow, (char )',');
  if (mask & 67108864LL) {
    if ((unsigned int )(r->allowed_methods)->method_list != (unsigned int )((void *)0)) {
      if (((r->allowed_methods)->method_list)->nelts != 0) {
        xmethod = (char **)((r->allowed_methods)->method_list)->elts;
        i = 0;
        while (i < ((r->allowed_methods)->method_list)->nelts) {
          list = apr_pstrcat(r->pool, list, ",", (*(xmethod + i)), (void *)0);
          i ++;
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
  }
  return (list);
}
}
int ap_send_http_trace(request_rec *r ) 
{ int rv ;
  apr_bucket_brigade *b ;
  header_struct h ;

  {
  if (r->method_number != 6) {
    return (-1);
  }
  while (r->prev) {
    r = r->prev;
  }
  rv = ap_setup_client_block(r, 0);
  if (rv) {
    return (rv);
  }
  ap_set_content_type(r, "message/http");
  b = apr_brigade_create(r->pool, (r->connection)->bucket_alloc);
  apr_brigade_putstrs(b, (apr_status_t (*)(apr_bucket_brigade *bb , void *ctx ))((void *)0),
                      (void *)0, r->the_request, "\r\n", (void *)0);
  h.pool = r->pool;
  h.bb = b;
  apr_table_do((int (*)(void * , char const   * , char const   * ))(& form_header_field),
               (void *)(& h), (apr_table_t const   *)r->headers_in, (void *)0);
  apr_brigade_puts(b, (apr_status_t (*)(apr_bucket_brigade *bb , void *ctx ))((void *)0),
                   (void *)0, "\r\n");
  ap_pass_brigade(r->output_filters, b);
  return (-2);
}
}
int ap_send_http_options(request_rec *r ) 
{ char const   *tmp ;

  {
  if (r->assbackwards) {
    return (-1);
  }
  tmp = make_allow(r);
  apr_table_setn(r->headers_out, "Allow", tmp);
  return (0);
}
}
static int uniq_field_values(void *d , char const   *key , char const   *val ) 
{ apr_array_header_t *values ;
  char *start ;
  char *e ;
  char **strpp ;
  int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  values = (apr_array_header_t *)d;
  e = apr_pstrdup(values->pool, val);
  while (1) {
    while (1) {
      if ((int )(*e) == 44) {
        goto _L;
      } else {
        tmp = __ctype_b_loc();
        if ((int const   )(*((*tmp) + (int )((unsigned char )(*e)))) & 8192) {
          _L: ;
        } else {
          break;
        }
      }
      e ++;
    }
    if ((int )(*e) == 0) {
      break;
    }
    start = e;
    while (1) {
      if ((int )(*e) != 0) {
        if ((int )(*e) != 44) {
          tmp___0 = __ctype_b_loc();
          if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*e)))) & 8192) {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        _L___1: 
        break;
      }
      e ++;
    }
    if ((int )(*e) != 0) {
      tmp___1 = e;
      e ++;
      (*tmp___1) = (char )'\000';
    }
    i = 0;
    strpp = (char **)values->elts;
    while (i < values->nelts) {
      if ((*strpp)) {
        tmp___2 = strcasecmp((char const   *)(*strpp), (char const   *)start);
        if (tmp___2 == 0) {
          break;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: ;
      }
      i ++;
      strpp ++;
    }
    if (i == values->nelts) {
      tmp___3 = apr_array_push(values);
      (*((char **)tmp___3)) = start;
    }
    if (! ((int )(*e) != 0)) {
      break;
    }
  }
  return (1);
}
}
static void fixup_vary(request_rec *r ) 
{ apr_array_header_t *varies ;
  char const   *tmp ;

  {
  varies = apr_array_make(r->pool, 5, (int )sizeof(char *));
  apr_table_do(& uniq_field_values, (void *)varies, (apr_table_t const   *)r->headers_out,
               "Vary", (void *)0);
  if (varies->nelts > 0) {
    tmp = apr_array_pstrcat(r->pool, (apr_array_header_t const   *)varies, (char )',');
    apr_table_setn(r->headers_out, "Vary", tmp);
  }
  return;
}
}
void ap_set_content_type(request_rec *r , char const   *ct ) 
{ int tmp ;

  {
  if (! ct) {
    r->content_type = (char const   *)((void *)0);
  } else {
    if (! r->content_type) {
      goto _L;
    } else {
      tmp = strcmp(r->content_type, ct);
      if (tmp) {
        _L: 
        r->content_type = ct;
        ap_add_output_filters_by_type(r);
      }
    }
  }
  return;
}
}
apr_status_t ap_http_header_filter(ap_filter_t *f , apr_bucket_brigade *b ) 
{ request_rec *r ;
  conn_rec *c ;
  char const   *clheader ;
  char const   *protocol ;
  apr_bucket *e ;
  apr_bucket_brigade *b2 ;
  header_struct h ;
  header_filter_ctx *ctx ;
  void *tmp ;
  ap_bucket_error *eb ;
  apr_status_t tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int i ;
  char **languages ;
  int tmp___5 ;
  char *date ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  apr_status_t tmp___9 ;

  {
  r = f->r;
  c = r->connection;
  ctx = (header_filter_ctx *)f->ctx;
  if (r->header_only) {
    if (! ctx) {
      tmp = apr_palloc(r->pool, sizeof(header_filter_ctx ));
      f->ctx = memset(tmp, 0, sizeof(header_filter_ctx ));
      ctx = (header_filter_ctx *)f->ctx;
    } else {
      if (ctx->headers_sent) {
        apr_brigade_destroy(b);
        return (0);
      }
    }
  }
  e = b->list.next;
  while ((unsigned int )e != (unsigned int )((struct apr_bucket *)((char *)(& b->list) -
                                                                   (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                           (char *)((void *)0))))) {
    if ((unsigned int )e->type == (unsigned int )(& ap_bucket_type_error)) {
      eb = (ap_bucket_error *)e->data;
      ap_die(eb->status, r);
      return (-3);
    }
    e = e->link.next;
  }
  if (r->assbackwards) {
    r->sent_bodyct = 1L;
    ap_remove_output_filter(f);
    tmp___0 = ap_pass_brigade(f->next, b);
    return (tmp___0);
  }
  tmp___1 = apr_is_empty_table((apr_table_t const   *)r->err_headers_out);
  if (! tmp___1) {
    r->headers_out = apr_table_overlay(r->pool, (apr_table_t const   *)r->err_headers_out,
                                       (apr_table_t const   *)r->headers_out);
  }
  tmp___2 = apr_table_get((apr_table_t const   *)r->subprocess_env, "force-no-vary");
  if ((unsigned int )tmp___2 != (unsigned int )((void *)0)) {
    apr_table_unset(r->headers_out, "Vary");
    r->proto_num = 1000;
    apr_table_set(r->subprocess_env, "force-response-1.0", "1");
  } else {
    fixup_vary(r);
  }
  tmp___3 = apr_table_get((apr_table_t const   *)r->notes, "no-etag");
  if ((unsigned int )tmp___3 != (unsigned int )((void *)0)) {
    apr_table_unset(r->headers_out, "ETag");
  }
  basic_http_header_check(r, & protocol);
  ap_set_keepalive(r);
  if (r->chunked) {
    apr_table_mergen(r->headers_out, "Transfer-Encoding", "chunked");
    apr_table_unset(r->headers_out, "Content-Length");
  }
  tmp___4 = ap_make_content_type(r, r->content_type);
  apr_table_setn(r->headers_out, "Content-Type", tmp___4);
  if (r->content_encoding) {
    apr_table_setn(r->headers_out, "Content-Encoding", r->content_encoding);
  }
  tmp___5 = apr_is_empty_array((apr_array_header_t const   *)r->content_languages);
  if (! tmp___5) {
    languages = (char **)(r->content_languages)->elts;
    i = 0;
    while (i < (r->content_languages)->nelts) {
      apr_table_mergen(r->headers_out, "Content-Language", (char const   *)(*(languages +
                                                                              i)));
      i ++;
    }
  }
  if (r->no_cache) {
    tmp___7 = apr_table_get((apr_table_t const   *)r->headers_out, "Expires");
    if (tmp___7) {
      goto _L;
    } else {
      tmp___6 = (char *)apr_palloc(r->pool, 30U);
      date = tmp___6;
      ap_recent_rfc822_date(date, r->request_time);
      apr_table_addn(r->headers_out, "Expires", (char const   *)date);
    }
  } else {
    _L: ;
  }
  if (r->header_only) {
    clheader = apr_table_get((apr_table_t const   *)r->headers_out, "Content-Length");
    if (clheader) {
      tmp___8 = strcmp(clheader, "0");
      if (tmp___8) {
        goto _L___1;
      } else {
        apr_table_unset(r->headers_out, "Content-Length");
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: ;
  }
  b2 = apr_brigade_create(r->pool, c->bucket_alloc);
  basic_http_header(r, b2, protocol);
  h.pool = r->pool;
  h.bb = b2;
  if (r->status == 304) {
    apr_table_do((int (*)(void * , char const   * , char const   * ))(& form_header_field),
                 (void *)(& h), (apr_table_t const   *)r->headers_out, "Connection",
                 "Keep-Alive", "ETag", "Content-Location", "Expires", "Cache-Control",
                 "Vary", "Warning", "WWW-Authenticate", "Proxy-Authenticate", (void *)0);
  } else {
    send_all_header_fields(& h, (request_rec const   *)r);
  }
  terminate_header(b2);
  ap_pass_brigade(f->next, b2);
  if (r->header_only) {
    apr_brigade_destroy(b);
    ctx->headers_sent = 1;
    return (0);
  }
  r->sent_bodyct = 1L;
  if (r->chunked) {
    ap_add_output_filter("CHUNK", (void *)0, r, r->connection);
  }
  ap_remove_output_filter(f);
  tmp___9 = ap_pass_brigade(f->next, b);
  return (tmp___9);
}
}
int ap_setup_client_block(request_rec *r , int read_policy ) 
{ char const   *tenc ;
  char const   *tmp ;
  char const   *lenp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int conversion_error ;
  char *endstr ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  tmp = apr_table_get((apr_table_t const   *)r->headers_in, "Transfer-Encoding");
  tenc = tmp;
  tmp___0 = apr_table_get((apr_table_t const   *)r->headers_in, "Content-Length");
  lenp = tmp___0;
  r->read_body = read_policy;
  r->read_chunked = 0;
  r->remaining = 0L;
  if (tenc) {
    tmp___1 = strcasecmp(tenc, "chunked");
    if (tmp___1) {
      ap_log_rerror("http_protocol.c", 1768, 3, 0, (request_rec const   *)r, "Unknown Transfer-Encoding %s",
                    tenc);
      return (501);
    }
    if (r->read_body == 1) {
      ap_log_rerror("http_protocol.c", 1773, 3, 0, (request_rec const   *)r, "chunked Transfer-Encoding forbidden: %s",
                    r->uri);
      if (lenp) {
        tmp___2 = 400;
      } else {
        tmp___2 = 411;
      }
      return (tmp___2);
    }
    r->read_chunked = 1;
  } else {
    if (lenp) {
      conversion_error = 0;
      tmp___3 = __errno_location();
      (*tmp___3) = 0;
      r->remaining = strtol((char const   * __restrict  )lenp, (char ** __restrict  )(& endstr),
                            10);
      tmp___4 = __errno_location();
      if ((*tmp___4)) {
        goto _L___0;
      } else {
        if (endstr) {
          if ((*endstr)) {
            _L___0: 
            goto _L;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          if (r->remaining < 0L) {
            _L: 
            conversion_error = 1;
          }
        }
      }
      if (conversion_error) {
        ap_log_rerror("http_protocol.c", 1793, 3, 0, (request_rec const   *)r, "Invalid Content-Length");
        return (400);
      }
    }
  }
  if (r->read_body == 0) {
    if (r->read_chunked) {
      goto _L___3;
    } else {
      if (r->remaining > 0L) {
        _L___3: 
        ap_log_rerror("http_protocol.c", 1801, 3, 0, (request_rec const   *)r, "%s with body is not allowed for %s",
                      r->method, r->uri);
        return (413);
      } else {
        goto _L___2;
      }
    }
  } else {
    _L___2: ;
  }
  return (0);
}
}
int ap_should_client_block(request_rec *r ) 
{ 

  {
  if (r->read_length) {
    goto _L;
  } else {
    if (! r->read_chunked) {
      if (r->remaining <= 0L) {
        _L: 
        return (0);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
  }
  return (1);
}
}
static long get_chunk_size(char *b ) 
{ long chunksize ;
  size_t chunkbits ;
  int xvalue ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  chunksize = 0L;
  chunkbits = sizeof(long ) * 8U;
  while ((int )(*b) == 48) {
    b ++;
  }
  while (1) {
    tmp = __ctype_b_loc();
    if ((int const   )(*((*tmp) + (int )((unsigned char )(*b)))) & 4096) {
      if (! (chunkbits > 0U)) {
        goto _L___2;
      }
    } else {
      _L___2: 
      break;
    }
    xvalue = 0;
    if ((int )(*b) >= 48) {
      if ((int )(*b) <= 57) {
        xvalue = (int )(*b) - 48;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if ((int )(*b) >= 65) {
        if ((int )(*b) <= 70) {
          xvalue = ((int )(*b) - 65) + 10;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
        if ((int )(*b) >= 97) {
          if ((int )(*b) <= 102) {
            xvalue = ((int )(*b) - 97) + 10;
          } else {
            goto _L;
          }
        } else {
          _L: ;
        }
      }
    }
    chunksize = (chunksize << 4) | (long )xvalue;
    chunkbits -= 4U;
    b ++;
  }
  tmp___0 = __ctype_b_loc();
  if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*b)))) & 4096) {
    if (chunkbits <= 0U) {
      return (-1L);
    } else {
      goto _L___3;
    }
  } else {
    _L___3: ;
  }
  return (chunksize);
}
}
long ap_get_client_block(request_rec *r , char *buffer , apr_size_t bufsiz ) 
{ apr_status_t rv ;
  apr_bucket_brigade *bb ;

  {
  bb = apr_brigade_create(r->pool, (r->connection)->bucket_alloc);
  if ((unsigned int )bb == (unsigned int )((void *)0)) {
    (r->connection)->keepalive = (enum __anonenum_ap_conn_keepalive_e_69 )1;
    return (-1L);
  }
  rv = ap_get_brigade(r->input_filters, bb, (enum __anonenum_ap_input_mode_t_70 )0,
                      (enum __anonenum_apr_read_type_e_60 )0, (long )bufsiz);
  if (rv != 0) {
    (r->connection)->keepalive = (enum __anonenum_ap_conn_keepalive_e_69 )1;
    apr_brigade_destroy(bb);
    return (-1L);
  }
  rv = apr_brigade_flatten(bb, buffer, & bufsiz);
  if (rv != 0) {
    apr_brigade_destroy(bb);
    return (-1L);
  }
  r->read_length = (long )((unsigned long )r->read_length + (unsigned long )bufsiz);
  apr_brigade_destroy(bb);
  return ((long )bufsiz);
}
}
int ap_discard_request_body(request_rec *r ) 
{ apr_bucket_brigade *bb ;
  int rv ;
  int seen_eos ;
  apr_bucket *bucket ;
  char const   *data ;
  apr_size_t len ;

  {
  if (r->main) {
    goto _L___7;
  } else {
    if ((int )(r->connection)->keepalive == 1) {
      _L___7: 
      goto _L___0;
    } else {
      if (r->status == 400) {
        goto _L___6;
      } else {
        if (r->status == 408) {
          _L___6: 
          goto _L___5;
        } else {
          if (r->status == 411) {
            _L___5: 
            goto _L___4;
          } else {
            if (r->status == 413) {
              _L___4: 
              goto _L___3;
            } else {
              if (r->status == 414) {
                _L___3: 
                goto _L___2;
              } else {
                if (r->status == 500) {
                  _L___2: 
                  goto _L___1;
                } else {
                  if (r->status == 503) {
                    _L___1: 
                    goto _L___0;
                  } else {
                    if (r->status == 501) {
                      _L___0: 
                      return (0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  bb = apr_brigade_create(r->pool, (r->connection)->bucket_alloc);
  seen_eos = 0;
  while (1) {
    rv = ap_get_brigade(r->input_filters, bb, (enum __anonenum_ap_input_mode_t_70 )0,
                        (enum __anonenum_apr_read_type_e_60 )0, 8192L);
    if (rv != 0) {
      if (rv == -3) {
        apr_brigade_destroy(bb);
        return (rv);
      } else {
        apr_brigade_destroy(bb);
        return (400);
      }
    }
    bucket = bb->list.next;
    while ((unsigned int )bucket != (unsigned int )((struct apr_bucket *)((char *)(& bb->list) -
                                                                          (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                  (char *)((void *)0))))) {
      if ((unsigned int )bucket->type == (unsigned int )(& apr_bucket_type_eos)) {
        seen_eos = 1;
        break;
      }
      if (bucket->length == 0U) {
        goto __Cont;
      }
      rv = ((*((bucket->type)->read)))(bucket, & data, & len, (enum __anonenum_apr_read_type_e_60 )0);
      if (rv != 0) {
        apr_brigade_destroy(bb);
        return (400);
      }
      __Cont: 
      bucket = bucket->link.next;
    }
    apr_brigade_cleanup((void *)bb);
    if (! (! seen_eos)) {
      break;
    }
  }
  return (0);
}
}
static char const   *add_optional_notes(request_rec *r , char const   *prefix , char const   *key ,
                                        char const   *suffix ) 
{ char const   *notes ;
  char const   *result ;

  {
  notes = apr_table_get((apr_table_t const   *)r->notes, key);
  if ((unsigned int )notes == (unsigned int )((void *)0)) {
    result = apr_pstrcat(r->pool, prefix, suffix, (void *)0);
  } else {
    result = apr_pstrcat(r->pool, prefix, notes, suffix, (void *)0);
  }
  return (result);
}
}
static char const   *get_canned_error_string(int status , request_rec *r , char const   *location ) 
{ apr_pool_t *p ;
  char const   *error_notes ;
  char const   *h1 ;
  char const   *s1 ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char *tmp___22 ;
  char const   *tmp___23 ;
  char *tmp___24 ;
  char const   *tmp___25 ;
  char *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;
  char *tmp___32 ;
  char const   *tmp___33 ;
  int tmp___34 ;

  {
  p = r->pool;
  switch (status) {
  case 301: ;
  case 302: ;
  case 307: 
  tmp = ap_escape_html(r->pool, location);
  tmp___0 = apr_pstrcat(p, "<p>The document has moved <a href=\"", tmp, "\">here</a>.</p>\n",
                        (void *)0);
  return (tmp___0);
  case 303: 
  tmp___1 = ap_escape_html(r->pool, location);
  tmp___2 = apr_pstrcat(p, "<p>The answer to your request is located <a href=\"",
                        tmp___1, "\">here</a>.</p>\n", (void *)0);
  return (tmp___2);
  case 305: 
  tmp___3 = ap_escape_html(r->pool, location);
  tmp___4 = apr_pstrcat(p, "<p>This resource is only accessible through the proxy\n",
                        tmp___3, "<br />\nYou will need to configure your client to use that proxy.</p>\n",
                        (void *)0);
  return (tmp___4);
  case 407: ;
  case 401: ;
  return ("<p>This server could not verify that you\nare authorized to access the document\nrequested.  Either you supplied the wrong\ncredentials (e.g., bad password), or your\nbrowser doesn\'t understand how to supply\nthe credentials required.</p>\n");
  case 400: 
  tmp___5 = add_optional_notes(r, "<p>Your browser sent a request that this server could not understand.<br />\n",
                               "error-notes", "</p>\n");
  return (tmp___5);
  case 403: 
  tmp___6 = ap_escape_html(r->pool, (char const   *)r->uri);
  tmp___7 = apr_pstrcat(p, "<p>You don\'t have permission to access ", tmp___6, "\non this server.</p>\n",
                        (void *)0);
  return (tmp___7);
  case 404: 
  tmp___8 = ap_escape_html(r->pool, (char const   *)r->uri);
  tmp___9 = apr_pstrcat(p, "<p>The requested URL ", tmp___8, " was not found on this server.</p>\n",
                        (void *)0);
  return (tmp___9);
  case 405: 
  tmp___10 = ap_escape_html(r->pool, (char const   *)r->uri);
  tmp___11 = apr_pstrcat(p, "<p>The requested method ", r->method, " is not allowed for the URL ",
                         tmp___10, ".</p>\n", (void *)0);
  return (tmp___11);
  case 406: 
  tmp___12 = ap_escape_html(r->pool, (char const   *)r->uri);
  s1 = apr_pstrcat(p, "<p>An appropriate representation of the requested resource ",
                   tmp___12, " could not be found on this server.</p>\n", (void *)0);
  tmp___13 = add_optional_notes(r, s1, "variant-list", "");
  return (tmp___13);
  case 300: 
  tmp___14 = add_optional_notes(r, "", "variant-list", "");
  return (tmp___14);
  case 411: 
  s1 = apr_pstrcat(p, "<p>A request of the requested method ", r->method, " requires a valid Content-length.<br />\n",
                   (void *)0);
  tmp___15 = add_optional_notes(r, s1, "error-notes", "</p>\n");
  return (tmp___15);
  case 412: 
  tmp___16 = ap_escape_html(r->pool, (char const   *)r->uri);
  tmp___17 = apr_pstrcat(p, "<p>The precondition on the request for the URL ", tmp___16,
                         " evaluated to false.</p>\n", (void *)0);
  return (tmp___17);
  case 501: 
  tmp___18 = ap_escape_html(r->pool, (char const   *)r->uri);
  tmp___19 = ap_escape_html(r->pool, r->method);
  s1 = apr_pstrcat(p, "<p>", tmp___19, " to ", tmp___18, " not supported.<br />\n",
                   (void *)0);
  tmp___20 = add_optional_notes(r, s1, "error-notes", "</p>\n");
  return (tmp___20);
  case 502: 
  s1 = "<p>The proxy server received an invalid\r\nresponse from an upstream server.<br />\r\n";
  tmp___21 = add_optional_notes(r, s1, "error-notes", "</p>\n");
  return (tmp___21);
  case 506: 
  tmp___22 = ap_escape_html(r->pool, (char const   *)r->uri);
  tmp___23 = apr_pstrcat(p, "<p>A variant for the requested resource\n<pre>\n", tmp___22,
                         "\n</pre>\nis itself a negotiable resource. This indicates a configuration error.</p>\n",
                         (void *)0);
  return (tmp___23);
  case 408: ;
  return ("<p>Server timeout waiting for the HTTP request from the client.</p>\n");
  case 410: 
  tmp___24 = ap_escape_html(r->pool, (char const   *)r->uri);
  tmp___25 = apr_pstrcat(p, "<p>The requested resource<br />", tmp___24, "<br />\nis no longer available on this server and there is no forwarding address.\nPlease remove all references to this resource.</p>\n",
                         (void *)0);
  return (tmp___25);
  case 413: 
  tmp___26 = ap_escape_html(r->pool, (char const   *)r->uri);
  tmp___27 = apr_pstrcat(p, "The requested resource<br />", tmp___26, "<br />\n",
                         "does not allow request data with ", r->method, " requests, or the amount of data provided in\nthe request exceeds the capacity limit.\n",
                         (void *)0);
  return (tmp___27);
  case 414: 
  s1 = "<p>The requested URL\'s length exceeds the capacity\nlimit for this server.<br />\n";
  tmp___28 = add_optional_notes(r, s1, "error-notes", "</p>\n");
  return (tmp___28);
  case 415: ;
  return ("<p>The supplied request data is not in a format\nacceptable for processing by this resource.</p>\n");
  case 416: ;
  return ("<p>None of the range-specifier values in the Range\nrequest-header field overlap the current extent\nof the selected resource.</p>\n");
  case 417: 
  tmp___29 = apr_table_get((apr_table_t const   *)r->headers_in, "Expect");
  tmp___30 = apr_pstrcat(p, "<p>The expectation given in the Expect request-header\nfield could not be met by this server.</p>\n<p>The client sent<pre>\n    Expect: ",
                         tmp___29, "\n</pre>\nbut we only allow the 100-continue expectation.</p>\n",
                         (void *)0);
  return (tmp___30);
  case 422: ;
  return ("<p>The server understands the media type of the\nrequest entity, but was unable to process the\ncontained instructions.</p>\n");
  case 423: ;
  return ("<p>The requested resource is currently locked.\nThe lock must be released or proper identification\ngiven before the method can be applied.</p>\n");
  case 424: ;
  return ("<p>The method could not be performed on the resource\nbecause the requested action depended on another\naction and that other action failed.</p>\n");
  case 426: ;
  return ("<p>The requested resource can only be retrieved\nusing SSL.  The server is willing to upgrade the current\nconnection to SSL, but your client doesn\'t support it.\nEither upgrade your client, or try requesting the page\nusing https://\n");
  case 507: ;
  return ("<p>The method could not be performed on the resource\nbecause the server is unable to store the\nrepresentation needed to successfully complete the\nrequest.  There is insufficient free space left in\nyour storage allocation.</p>\n");
  case 503: ;
  return ("<p>The server is temporarily unable to service your\nrequest due to maintenance downtime or capacity\nproblems. Please try again later.</p>\n");
  case 504: ;
  return ("<p>The proxy server did not receive a timely response\nfrom the upstream server.</p>\n");
  case 510: ;
  return ("<p>A mandatory extension policy in the request is not\naccepted by the server for this resource.</p>\n");
  default: 
  error_notes = apr_table_get((apr_table_t const   *)r->notes, "error-notes");
  if ((unsigned int )error_notes != (unsigned int )((void *)0)) {
    h1 = apr_table_get((apr_table_t const   *)r->notes, "verbose-error-to");
    if ((unsigned int )h1 != (unsigned int )((void *)0)) {
      tmp___34 = strcmp(h1, "*");
      if (tmp___34 == 0) {
        tmp___31 = apr_pstrcat(p, error_notes, "<p />\n", (void *)0);
        return (tmp___31);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    tmp___32 = ap_escape_html(r->pool, (char const   *)(r->server)->server_admin);
    tmp___33 = apr_pstrcat(p, "<p>The server encountered an internal error or\nmisconfiguration and was unable to complete\nyour request.</p>\n<p>Please contact the server administrator,\n ",
                           tmp___32, " and inform them of the time the error occurred,\nand anything you might have done that may have\ncaused the error.</p>\n<p>More information about this error may be available\nin the server error log.</p>\n",
                           (void *)0);
    return (tmp___33);
  }
  }
}
}
void ap_send_error_response(request_rec *r , int recursive_error ) 
{ int status ;
  int idx ;
  int tmp ;
  char *custom_response ;
  char const   *location ;
  char const   *tmp___0 ;
  apr_table_t *tmp___1 ;
  char const   *tmp___2 ;
  char const   *title ;
  char const   *h1 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;

  {
  status = r->status;
  tmp = ap_index_of_response(status);
  idx = tmp;
  tmp___0 = apr_table_get((apr_table_t const   *)r->headers_out, "Location");
  location = tmp___0;
  r->eos_sent = 0;
  r->output_filters = r->proto_output_filters;
  if ((unsigned int )location == (unsigned int )((void *)0)) {
    location = apr_table_get((apr_table_t const   *)r->err_headers_out, "Location");
  }
  if (status == 304) {
    ap_finalize_request_protocol(r);
    return;
  }
  if (status == 204) {
    ap_finalize_request_protocol(r);
    return;
  }
  if (! r->assbackwards) {
    tmp___1 = r->headers_out;
    r->headers_out = r->err_headers_out;
    r->err_headers_out = tmp___1;
    apr_table_clear(r->err_headers_out);
    if (status >= 300) {
      if (status < 400) {
        goto _L___0;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if (status == 201) {
        _L___0: 
        if ((unsigned int )location != (unsigned int )((void *)0)) {
          if ((*location)) {
            apr_table_setn(r->headers_out, "Location", location);
          } else {
            goto _L;
          }
        } else {
          _L: 
          location = "";
        }
      }
    }
    r->content_languages = (apr_array_header_t *)((void *)0);
    r->content_encoding = (char const   *)((void *)0);
    r->clength = 0L;
    ap_set_content_type(r, "text/html; charset=iso-8859-1");
    if (status == 405) {
      goto _L___2;
    } else {
      if (status == 501) {
        _L___2: 
        tmp___2 = make_allow(r);
        apr_table_setn(r->headers_out, "Allow", tmp___2);
      }
    }
    if (r->header_only) {
      ap_finalize_request_protocol(r);
      return;
    }
  }
  custom_response = ap_response_code_string(r, idx);
  if (custom_response) {
    if ((int )(*(custom_response + 0)) == 34) {
      ap_rputs((char const   *)(custom_response + 1), r);
      ap_finalize_request_protocol(r);
      return;
    }
  }
  title = (char const   *)status_lines[idx];
  if ((unsigned int )r->status_line != (unsigned int )((void *)0)) {
    tmp___3 = strlen(r->status_line);
    if (tmp___3 > 4U) {
      tmp___4 = __ctype_b_loc();
      if ((int const   )(*((*tmp___4) + (int )((unsigned char )(*(r->status_line +
                                                                  0))))) & 2048) {
        tmp___5 = __ctype_b_loc();
        if ((int const   )(*((*tmp___5) + (int )((unsigned char )(*(r->status_line +
                                                                    1))))) & 2048) {
          tmp___6 = __ctype_b_loc();
          if ((int const   )(*((*tmp___6) + (int )((unsigned char )(*(r->status_line +
                                                                      2))))) & 2048) {
            tmp___7 = __ctype_b_loc();
            if ((int const   )(*((*tmp___7) + (int )((unsigned char )(*(r->status_line +
                                                                        3))))) & 8192) {
              tmp___8 = __ctype_b_loc();
              if ((int const   )(*((*tmp___8) + (int )((unsigned char )(*(r->status_line +
                                                                          4))))) &
                  8) {
                title = r->status_line;
              } else {
                goto _L___8;
              }
            } else {
              goto _L___8;
            }
          } else {
            goto _L___8;
          }
        } else {
          goto _L___8;
        }
      } else {
        goto _L___8;
      }
    } else {
      goto _L___8;
    }
  } else {
    _L___8: ;
  }
  h1 = title + 4;
  ap_rvputs(r, "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<html><head>\n<title>",
            title, "</title>\n</head><body>\n<h1>", h1, "</h1>\n", (void *)0);
  tmp___9 = get_canned_error_string(status, r, location);
  ap_rvputs(r, tmp___9, (void *)0);
  if (recursive_error) {
    tmp___10 = ap_index_of_response(recursive_error);
    ap_rvputs(r, "<p>Additionally, a ", status_lines[tmp___10], "\nerror was encountered while trying to use an ErrorDocument to handle the request.</p>\n",
              (void *)0);
  }
  tmp___11 = ap_psignature("<hr />\n", r);
  ap_rvputs(r, tmp___11, (void *)0);
  ap_rvputs(r, "</body></html>\n", (void *)0);
  ap_finalize_request_protocol(r);
  return;
}
}
ap_method_list_t *ap_make_method_list(apr_pool_t *p , int nelts ) 
{ ap_method_list_t *ml ;

  {
  ml = (ap_method_list_t *)apr_palloc(p, sizeof(ap_method_list_t ));
  ml->method_mask = 0LL;
  ml->method_list = apr_array_make(p, (int )sizeof(char *), nelts);
  return (ml);
}
}
void ap_copy_method_list(ap_method_list_t *dest , ap_method_list_t *src ) 
{ int i ;
  char **imethods ;
  char **omethods ;

  {
  dest->method_mask = src->method_mask;
  imethods = (char **)(src->method_list)->elts;
  i = 0;
  while (i < (src->method_list)->nelts) {
    omethods = (char **)apr_array_push(dest->method_list);
    (*omethods) = apr_pstrdup((dest->method_list)->pool, (char const   *)(*(imethods +
                                                                            i)));
    i ++;
  }
  return;
}
}
void ap_method_list_do(int (*comp)(void *urec , char const   *mname , int mnum ) ,
                       void *rec , ap_method_list_t const   *ml  , ...) 
{ va_list vp ;

  {
  __builtin_stdarg_start(vp, ml);
  ap_method_list_vdo(comp, rec, ml, vp);
  __builtin_va_end(vp);
  return;
}
}
void ap_method_list_vdo(int (*comp)(void *mrec , char const   *mname , int mnum ) ,
                        void *rec , ap_method_list_t const   *ml , va_list vp ) 
{ 

  {
  return;
}
}
int ap_method_in_list(ap_method_list_t *l , char const   *method ) 
{ int methnum ;
  int i ;
  char **methods ;
  int tmp ;

  {
  methnum = ap_method_number_of(method);
  if (methnum != 26) {
    return ((! (! (l->method_mask & (1LL << methnum))) != 0) != 0);
  }
  if ((unsigned int )l->method_list == (unsigned int )((void *)0)) {
    goto _L;
  } else {
    if ((l->method_list)->nelts == 0) {
      _L: 
      return (0);
    }
  }
  methods = (char **)(l->method_list)->elts;
  i = 0;
  while (i < (l->method_list)->nelts) {
    tmp = strcmp(method, (char const   *)(*(methods + i)));
    if (tmp == 0) {
      return (1);
    }
    i ++;
  }
  return (0);
}
}
void ap_method_list_add(ap_method_list_t *l , char const   *method ) 
{ int methnum ;
  int i ;
  char const   **xmethod ;
  char **methods ;
  int tmp ;

  {
  methnum = ap_method_number_of(method);
  l->method_mask = l->method_mask | (1LL << methnum);
  if (methnum != 26) {
    return;
  }
  if ((l->method_list)->nelts != 0) {
    methods = (char **)(l->method_list)->elts;
    i = 0;
    while (i < (l->method_list)->nelts) {
      tmp = strcmp(method, (char const   *)(*(methods + i)));
      if (tmp == 0) {
        return;
      }
      i ++;
    }
  }
  xmethod = (char const   **)apr_array_push(l->method_list);
  (*xmethod) = method;
  return;
}
}
void ap_method_list_remove(ap_method_list_t *l , char const   *method ) 
{ int methnum ;
  char **methods ;
  register int i ;
  register int j ;
  register int k ;
  int tmp ;

  {
  methnum = ap_method_number_of(method);
  l->method_mask = l->method_mask | ~ (1LL << methnum);
  if (methnum != 26) {
    return;
  }
  if ((l->method_list)->nelts != 0) {
    methods = (char **)(l->method_list)->elts;
    i = 0;
    while (i < (l->method_list)->nelts) {
      tmp = strcmp(method, (char const   *)(*(methods + i)));
      if (tmp == 0) {
        j = i;
        k = i + 1;
        while (k < (l->method_list)->nelts) {
          (*(methods + j)) = (*(methods + k));
          j ++;
          k ++;
        }
        (l->method_list)->nelts = (l->method_list)->nelts - 1;
      } else {
        i ++;
      }
    }
  }
  return;
}
}
void ap_clear_method_list(ap_method_list_t *l ) 
{ 

  {
  l->method_mask = 0LL;
  (l->method_list)->nelts = 0;
  return;
}
}
static char *etag_ulong_to_hex(char *next , unsigned long u___0 ) 
{ int printing ;
  int shift ;
  unsigned long next_digit ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  printing = 0;
  shift = (int )(sizeof(unsigned long ) * 8U - 4U);
  while (1) {
    next_digit = (u___0 >> shift) & 15UL;
    if (next_digit) {
      tmp = next;
      next ++;
      (*tmp) = (char )(*("0123456789abcdef" + next_digit));
      printing = 1;
    } else {
      if (printing) {
        tmp___0 = next;
        next ++;
        (*tmp___0) = (char )(*("0123456789abcdef" + next_digit));
      }
    }
    shift -= 4;
    if (! shift) {
      break;
    }
  }
  tmp___1 = next;
  next ++;
  (*tmp___1) = (char )(*("0123456789abcdef" + (u___0 & 15UL)));
  return (next);
}
}
char *ap_make_etag(request_rec *r , int force_weak ) 
{ char *weak ;
  apr_size_t weak_len ;
  char *etag ;
  char *next ;
  core_dir_config *cfg ;
  etag_components_t etag_bits ;
  etag_components_t bits_added ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  cfg = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  etag_bits = (cfg->etag_bits & ~ cfg->etag_remove) | cfg->etag_add;
  if (etag_bits & 1UL) {
    apr_table_setn(r->notes, "no-etag", "omit");
    return ((char *)"");
  }
  if (etag_bits == 0UL) {
    etag_bits = 14UL;
  }
  if (r->request_time - r->mtime > 1000000LL) {
    if (! force_weak) {
      weak = (char *)((void *)0);
      weak_len = 0U;
    } else {
      goto _L;
    }
  } else {
    _L: 
    weak = (char *)"W/";
    weak_len = sizeof("W/");
  }
  if ((int )r->finfo.filetype != 0) {
    etag = (char *)apr_palloc(r->pool, ((weak_len + sizeof("\"--\"")) + 3U * (sizeof(unsigned long ) *
                                                                              2U)) +
                                       1U);
    next = etag;
    if (weak) {
      while ((*weak)) {
        tmp = next;
        next ++;
        tmp___0 = weak;
        weak ++;
        (*tmp) = (*tmp___0);
      }
    }
    tmp___1 = next;
    next ++;
    (*tmp___1) = (char )'\"';
    bits_added = 0UL;
    if (etag_bits & 4UL) {
      next = etag_ulong_to_hex(next, r->finfo.inode);
      bits_added |= 4UL;
    }
    if (etag_bits & 8UL) {
      if (bits_added != 0UL) {
        tmp___2 = next;
        next ++;
        (*tmp___2) = (char )'-';
      }
      next = etag_ulong_to_hex(next, (unsigned long )r->finfo.size);
      bits_added |= 8UL;
    }
    if (etag_bits & 2UL) {
      if (bits_added != 0UL) {
        tmp___3 = next;
        next ++;
        (*tmp___3) = (char )'-';
      }
      next = etag_ulong_to_hex(next, (unsigned long )r->mtime);
    }
    tmp___4 = next;
    next ++;
    (*tmp___4) = (char )'\"';
    (*next) = (char )'\000';
  } else {
    etag = (char *)apr_palloc(r->pool, ((weak_len + sizeof("\"\"")) + sizeof(unsigned long ) *
                                                                      2U) + 1U);
    next = etag;
    if (weak) {
      while ((*weak)) {
        tmp___5 = next;
        next ++;
        tmp___6 = weak;
        weak ++;
        (*tmp___5) = (*tmp___6);
      }
    }
    tmp___7 = next;
    next ++;
    (*tmp___7) = (char )'\"';
    next = etag_ulong_to_hex(next, (unsigned long )r->mtime);
    tmp___8 = next;
    next ++;
    (*tmp___8) = (char )'\"';
    (*next) = (char )'\000';
  }
  return (etag);
}
}
void ap_set_etag(request_rec *r ) 
{ char *etag ;
  char *variant_etag ;
  char *vlv ;
  int vlv_weak ;
  size_t tmp ;

  {
  if (! r->vlist_validator) {
    etag = ap_make_etag(r, 0);
    if (! (*(etag + 0))) {
      return;
    }
  } else {
    vlv = r->vlist_validator;
    vlv_weak = (int )(*(vlv + 0)) == 87;
    variant_etag = ap_make_etag(r, vlv_weak);
    if (! (*(variant_etag + 0))) {
      return;
    }
    tmp = strlen((char const   *)variant_etag);
    (*(variant_etag + (tmp - 1U))) = (char )'\000';
    if (vlv_weak) {
      vlv += 3;
    } else {
      vlv ++;
    }
    etag = apr_pstrcat(r->pool, variant_etag, ";", vlv, (void *)0);
  }
  apr_table_setn(r->headers_out, "ETag", (char const   *)etag);
  return;
}
}
static int parse_byterange(char *range , apr_off_t clength , apr_off_t *start , apr_off_t *end ) 
{ char *dash ;
  char *tmp ;
  apr_int64_t tmp___0 ;
  int tmp___1 ;

  {
  tmp = strchr((char const   *)range, '-');
  dash = tmp;
  if (! dash) {
    return (0);
  }
  if ((unsigned int )dash == (unsigned int )range) {
    tmp___0 = apr_atoi64((char const   *)(dash + 1));
    (*start) = (long )((long long )clength - tmp___0);
    (*end) = clength - 1L;
  } else {
    (*dash) = (char )'\000';
    dash ++;
    (*start) = (apr_off_t )apr_atoi64((char const   *)range);
    if ((*dash)) {
      (*end) = (apr_off_t )apr_atoi64((char const   *)dash);
    } else {
      (*end) = clength - 1L;
    }
  }
  if ((*start) < 0L) {
    (*start) = 0L;
  }
  if ((*end) >= clength) {
    (*end) = clength - 1L;
  }
  if ((*start) > (*end)) {
    return (-1);
  }
  if ((*start) > 0L) {
    goto _L;
  } else {
    if ((*end) < clength) {
      _L: 
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  }
  return (tmp___1);
}
}
static int ap_set_byterange(request_rec *r ) ;
static int use_range_x(request_rec *r ) 
{ char const   *ua ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  tmp = apr_table_get((apr_table_t const   *)r->headers_in, "Request-Range");
  if (tmp) {
    goto _L;
  } else {
    ua = apr_table_get((apr_table_t const   *)r->headers_in, "User-Agent");
    if (ua) {
      tmp___0 = strstr(ua, "MSIE 3");
      if (tmp___0) {
        _L: 
        tmp___1 = 1;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      tmp___1 = 0;
    }
  }
  return (tmp___1);
}
}
apr_status_t ap_byterange_filter(ap_filter_t *f , apr_bucket_brigade *bb ) 
{ request_rec *r ;
  conn_rec *c ;
  byterange_ctx *ctx ;
  apr_bucket *e ;
  apr_bucket_brigade *bsend ;
  apr_off_t range_start ;
  apr_off_t range_end ;
  char *current ;
  apr_off_t bb_length ;
  apr_off_t clength ;
  apr_status_t rv ;
  int found ;
  int num_ranges ;
  int tmp ;
  apr_status_t tmp___0 ;
  void *tmp___1 ;
  char const   *orig_ct ;
  char const   *tmp___2 ;
  __pid_t tmp___3 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  apr_bucket *e2 ;
  apr_bucket *ec ;
  char const   *tmp___8 ;
  char *ts ;
  apr_size_t tmp___9 ;
  apr_bucket *ap__b ;
  apr_size_t tmp___10 ;
  apr_bucket *ap__b___0 ;
  apr_bucket *foo ;
  char const   *str ;
  apr_size_t len ;
  apr_status_t tmp___11 ;
  apr_bucket *ap__b___1 ;
  apr_bucket *ap__b___2 ;
  apr_bucket *ap__b___3 ;
  apr_status_t tmp___12 ;
  char *end ;
  apr_size_t tmp___13 ;
  apr_bucket *ap__b___4 ;
  apr_bucket *ap__b___5 ;
  apr_status_t tmp___14 ;

  {
  r = f->r;
  c = r->connection;
  ctx = (byterange_ctx *)f->ctx;
  clength = 0L;
  found = 0;
  if (! ctx) {
    tmp = ap_set_byterange(r);
    num_ranges = tmp;
    if (num_ranges == 0) {
      ap_remove_output_filter(f);
      tmp___0 = ap_pass_brigade(f->next, bb);
      return (tmp___0);
    }
    tmp___1 = apr_palloc(r->pool, sizeof((*ctx)));
    f->ctx = memset(tmp___1, 0, sizeof((*ctx)));
    ctx = (byterange_ctx *)f->ctx;
    ctx->num_ranges = num_ranges;
    ctx->bb = apr_brigade_create(r->pool, c->bucket_alloc);
    if (ctx->num_ranges > 1) {
      tmp___2 = ap_make_content_type(r, r->content_type);
      orig_ct = tmp___2;
      tmp___3 = getpid();
      ctx->boundary = apr_psprintf(r->pool, "%qx%lx", r->request_time, (long )tmp___3);
      tmp___6 = use_range_x(r);
      if (tmp___6) {
        tmp___5 = "/x-";
      } else {
        tmp___5 = "/";
      }
      tmp___7 = apr_pstrcat(r->pool, "multipart", tmp___5, "byteranges; boundary=",
                            ctx->boundary, (void *)0);
      ap_set_content_type(r, tmp___7);
      ctx->bound_head = apr_pstrcat(r->pool, "\r\n--", ctx->boundary, "\r\nContent-type: ",
                                    orig_ct, "\r\nContent-range: bytes ", (void *)0);
    }
  }
  if (! ((unsigned int )(bb->list.prev)->type == (unsigned int )(& apr_bucket_type_eos))) {
    ap_save_brigade(f, & ctx->bb, & bb, r->pool);
    return (0);
  }
  while (1) {
    if (! ((unsigned int )(ctx->bb)->list.next == (unsigned int )((struct apr_bucket *)((char *)(& (ctx->bb)->list) -
                                                                                        (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                (char *)((void *)0)))))) {
      while (1) {
        ((ctx->bb)->list.next)->link.prev = (struct apr_bucket *)((char *)(& bb->list) -
                                                                  (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                          (char *)((void *)0)));
        ((ctx->bb)->list.prev)->link.next = ((struct apr_bucket *)((char *)(& bb->list) -
                                                                   (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                           (char *)((void *)0))))->link.next;
        (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                               (char *)((void *)0))))->link.next)->link.prev = (ctx->bb)->list.prev;
        ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                              (char *)((void *)0))))->link.next = (ctx->bb)->list.next;
        break;
      }
      while (1) {
        (ctx->bb)->list.next = (struct apr_bucket *)((char *)(& (ctx->bb)->list) -
                                                     (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                             (char *)((void *)0)));
        (ctx->bb)->list.prev = (struct apr_bucket *)((char *)(& (ctx->bb)->list) -
                                                     (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                             (char *)((void *)0)));
        break;
      }
    }
    break;
  }
  apr_brigade_length(bb, 1, & bb_length);
  clength = bb_length;
  bsend = apr_brigade_create(r->pool, c->bucket_alloc);
  while (1) {
    current = ap_getword(r->pool, & r->range, (char )',');
    if (current) {
      rv = parse_byterange(current, clength, & range_start, & range_end);
      if (! rv) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
    if (rv == -1) {
      continue;
    }
    rv = apr_brigade_partition(bb, range_start, & ec);
    if (rv != 0) {
      ap_log_rerror("http_protocol.c", 2951, 3, rv, (request_rec const   *)r, "apr_brigade_partition() failed [%ld,%ld]",
                    range_start, clength);
      continue;
    }
    rv = apr_brigade_partition(bb, range_end + 1L, & e2);
    if (rv != 0) {
      ap_log_rerror("http_protocol.c", 2956, 3, rv, (request_rec const   *)r, "apr_brigade_partition() failed [%ld,%ld]",
                    range_end + 1L, clength);
      continue;
    }
    found = 1;
    if (ctx->num_ranges == 1) {
      tmp___8 = apr_psprintf(r->pool, "bytes %ld-%ld/%ld", range_start, range_end,
                             clength);
      apr_table_setn(r->headers_out, "Content-Range", tmp___8);
    } else {
      tmp___9 = strlen((char const   *)ctx->bound_head);
      e = apr_bucket_pool_create((char const   *)ctx->bound_head, tmp___9, r->pool,
                                 c->bucket_alloc);
      while (1) {
        ap__b = e;
        while (1) {
          ap__b->link.next = (struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                     (char *)((void *)0)));
          ap__b->link.prev = ((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                      (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                    (char *)((void *)0))))->link.prev)->link.next = ap__b;
          ((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                   (char *)((void *)0))))->link.prev = ap__b;
          break;
        }
        break;
      }
      ts = apr_psprintf(r->pool, "%ld-%ld/%ld\r\n\r\n", range_start, range_end, clength);
      tmp___10 = strlen((char const   *)ts);
      e = apr_bucket_pool_create((char const   *)ts, tmp___10, r->pool, c->bucket_alloc);
      while (1) {
        ap__b___0 = e;
        while (1) {
          ap__b___0->link.next = (struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                         (char *)((void *)0)));
          ap__b___0->link.prev = ((struct apr_bucket *)((char *)(& bsend->list) -
                                                        (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                    (char *)((void *)0))))->link.prev)->link.next = ap__b___0;
          ((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                   (char *)((void *)0))))->link.prev = ap__b___0;
          break;
        }
        break;
      }
    }
    while (1) {
      tmp___11 = ((*((ec->type)->copy)))(ec, & foo);
      if (tmp___11 != 0) {
        ((*((ec->type)->read)))(ec, & str, & len, (enum __anonenum_apr_read_type_e_60 )0);
        ((*((ec->type)->copy)))(ec, & foo);
      }
      while (1) {
        ap__b___1 = foo;
        while (1) {
          ap__b___1->link.next = (struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                         (char *)((void *)0)));
          ap__b___1->link.prev = ((struct apr_bucket *)((char *)(& bsend->list) -
                                                        (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                    (char *)((void *)0))))->link.prev)->link.next = ap__b___1;
          ((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                   (char *)((void *)0))))->link.prev = ap__b___1;
          break;
        }
        break;
      }
      ec = ec->link.next;
      if (! ((unsigned int )ec != (unsigned int )e2)) {
        break;
      }
    }
  }
  if (found == 0) {
    ap_remove_output_filter(f);
    r->status = 200;
    e = ap_bucket_error_create(416, (char const   *)((void *)0), r->pool, c->bucket_alloc);
    while (1) {
      ap__b___2 = e;
      while (1) {
        ap__b___2->link.next = (struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0)));
        ap__b___2->link.prev = ((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                        (char *)((void *)0))))->link.prev;
        (((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                  (char *)((void *)0))))->link.prev)->link.next = ap__b___2;
        ((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0))))->link.prev = ap__b___2;
        break;
      }
      break;
    }
    e = apr_bucket_eos_create(c->bucket_alloc);
    while (1) {
      ap__b___3 = e;
      while (1) {
        ap__b___3->link.next = (struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0)));
        ap__b___3->link.prev = ((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                        (char *)((void *)0))))->link.prev;
        (((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                  (char *)((void *)0))))->link.prev)->link.next = ap__b___3;
        ((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0))))->link.prev = ap__b___3;
        break;
      }
      break;
    }
    tmp___12 = ap_pass_brigade(f->next, bsend);
    return (tmp___12);
  }
  if (ctx->num_ranges > 1) {
    end = apr_pstrcat(r->pool, "\r\n--", ctx->boundary, "--\r\n", (void *)0);
    tmp___13 = strlen((char const   *)end);
    e = apr_bucket_pool_create((char const   *)end, tmp___13, r->pool, c->bucket_alloc);
    while (1) {
      ap__b___4 = e;
      while (1) {
        ap__b___4->link.next = (struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0)));
        ap__b___4->link.prev = ((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                        (char *)((void *)0))))->link.prev;
        (((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                  (char *)((void *)0))))->link.prev)->link.next = ap__b___4;
        ((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0))))->link.prev = ap__b___4;
        break;
      }
      break;
    }
  }
  e = apr_bucket_eos_create(c->bucket_alloc);
  while (1) {
    ap__b___5 = e;
    while (1) {
      ap__b___5->link.next = (struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                     (char *)((void *)0)));
      ap__b___5->link.prev = ((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                      (char *)((void *)0))))->link.prev;
      (((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0))))->link.prev)->link.next = ap__b___5;
      ((struct apr_bucket *)((char *)(& bsend->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                               (char *)((void *)0))))->link.prev = ap__b___5;
      break;
    }
    break;
  }
  apr_brigade_destroy(bb);
  tmp___14 = ap_pass_brigade(f->next, bsend);
  return (tmp___14);
}
}
static int ap_set_byterange(request_rec *r ) 
{ char const   *range ;
  char const   *if_range ;
  char const   *match___0 ;
  char const   *ct ;
  int num_ranges ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  if (r->assbackwards) {
    return (0);
  }
  range = apr_table_get((apr_table_t const   *)r->headers_in, "Range");
  if (! range) {
    range = apr_table_get((apr_table_t const   *)r->headers_in, "Request-Range");
  }
  if (! range) {
    goto _L___0;
  } else {
    tmp = strncasecmp(range, "bytes=", 6U);
    if (tmp) {
      _L___0: 
      goto _L;
    } else {
      if (r->status != 200) {
        _L: 
        return (0);
      }
    }
  }
  tmp___0 = apr_table_get((apr_table_t const   *)r->headers_out, "Content-Range");
  if (tmp___0) {
    return (0);
  }
  ct = apr_table_get((apr_table_t const   *)r->headers_out, "Content-Type");
  if (ct) {
    tmp___1 = strncasecmp(ct, "multipart/byteranges", 20U);
    if (tmp___1) {
      tmp___2 = strncasecmp(ct, "multipart/x-byteranges", 22U);
      if (tmp___2) {
        goto _L___1;
      } else {
        _L___2: 
        return (0);
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___1: ;
  }
  if_range = apr_table_get((apr_table_t const   *)r->headers_in, "If-Range");
  if (if_range) {
    if ((int const   )(*(if_range + 0)) == 34) {
      match___0 = apr_table_get((apr_table_t const   *)r->headers_out, "Etag");
      if (match___0) {
        tmp___3 = strcmp(if_range, match___0);
        if (tmp___3 != 0) {
          _L___3: 
          return (0);
        }
      } else {
        goto _L___3;
      }
    } else {
      match___0 = apr_table_get((apr_table_t const   *)r->headers_out, "Last-Modified");
      if (match___0) {
        tmp___4 = strcmp(if_range, match___0);
        if (tmp___4 != 0) {
          _L___4: 
          return (0);
        }
      } else {
        goto _L___4;
      }
    }
  }
  tmp___5 = strchr(range, ',');
  if (tmp___5) {
    num_ranges = 2;
  } else {
    num_ranges = 1;
  }
  r->status = 206;
  r->range = range + 6;
  return (num_ranges);
}
}
#pragma merger(0,"/tmp/cil-S4u4zaiI.i","-g -pthread")
int ap_is_url(char const   *u___0 ) ;
ap_conf_vector_t *ap_create_request_config(apr_pool_t *p ) ;
int ap_invoke_handler(request_rec *r ) ;
int ap_run_quick_handler(request_rec *r , int lookup ) ;
int ap_process_request_internal(request_rec *r ) ;
void ap_internal_redirect(char const   *new_uri , request_rec *r ) ;
void ap_internal_redirect_handler(char const   *new_uri , request_rec *r ) ;
void ap_internal_fast_redirect(request_rec *rr , request_rec *r ) ;
void ap_allow_methods(request_rec *r , int reset  , ...) ;
void ap_allow_standard_methods(request_rec *r , int reset  , ...) ;
int ap_run_create_request(request_rec *r ) ;
ap_filter_rec_t *ap_subreq_core_filter_handle ;
void ap_parse_uri(request_rec *r , char const   *uri ) ;
int ap_run_post_read_request(request_rec *r ) ;
int ap_run_log_transaction(request_rec *r ) ;
static void update_r_in_filters(ap_filter_t *f , request_rec *from , request_rec *to ) 
{ 

  {
  while (f) {
    if ((unsigned int )f->r == (unsigned int )from) {
      f->r = to;
    }
    f = f->next;
  }
  return;
}
}
void ap_die(int type , request_rec *r ) 
{ int error_index ;
  int tmp ;
  char *custom_response ;
  char *tmp___0 ;
  int recursive_error ;
  request_rec *r_1st_err ;
  char const   *error_notes ;
  int tmp___1 ;

  {
  tmp = ap_index_of_response(type);
  error_index = tmp;
  tmp___0 = ap_response_code_string(r, error_index);
  custom_response = tmp___0;
  recursive_error = 0;
  r_1st_err = r;
  if (type == -3) {
    return;
  }
  if (type == -2) {
    ap_finalize_request_protocol(r);
    return;
  }
  if (r->status != 200) {
    recursive_error = type;
    while (1) {
      if (r_1st_err->prev) {
        if (! ((r_1st_err->prev)->status != 200)) {
          goto _L;
        }
      } else {
        _L: 
        break;
      }
      r_1st_err = r_1st_err->prev;
    }
    if ((unsigned int )r_1st_err != (unsigned int )r) {
      update_r_in_filters(r_1st_err->proto_output_filters, r, r_1st_err);
      update_r_in_filters(r_1st_err->input_filters, r, r_1st_err);
    }
    custom_response = (char *)((void *)0);
  }
  r->status = type;
  if (401 == r->status) {
    if (1 == r->proxyreq) {
      r->status = 407;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
  }
  if (r->status == 400) {
    goto _L___7;
  } else {
    if (r->status == 408) {
      _L___7: 
      goto _L___6;
    } else {
      if (r->status == 411) {
        _L___6: 
        goto _L___5;
      } else {
        if (r->status == 413) {
          _L___5: 
          goto _L___4;
        } else {
          if (r->status == 414) {
            _L___4: 
            goto _L___3;
          } else {
            if (r->status == 500) {
              _L___3: 
              goto _L___2;
            } else {
              if (r->status == 503) {
                _L___2: 
                goto _L___1;
              } else {
                if (r->status == 501) {
                  _L___1: 
                  (r->connection)->keepalive = (enum __anonenum_ap_conn_keepalive_e_69 )1;
                }
              }
            }
          }
        }
      }
    }
  }
  if (custom_response) {
    if ((int )(*(custom_response + 0)) != 34) {
      tmp___1 = ap_is_url((char const   *)custom_response);
      if (tmp___1) {
        r->status = 302;
        apr_table_setn(r->headers_out, "Location", (char const   *)custom_response);
      } else {
        if ((int )(*(custom_response + 0)) == 47) {
          r->no_local_copy = 1;
          apr_table_setn(r->subprocess_env, "REQUEST_METHOD", r->method);
          error_notes = apr_table_get((apr_table_t const   *)r->notes, "error-notes");
          if ((unsigned int )error_notes != (unsigned int )((void *)0)) {
            apr_table_setn(r->subprocess_env, "ERROR_NOTES", error_notes);
          }
          r->method = apr_pstrdup(r->pool, "GET");
          r->method_number = 0;
          ap_internal_redirect((char const   *)custom_response, r);
          return;
        } else {
          recursive_error = 500;
          ap_log_rerror("http_request.c", 227, 3, 0, (request_rec const   *)r, "Invalid error redirection directive: %s",
                        custom_response);
        }
      }
    } else {
      goto _L___8;
    }
  } else {
    _L___8: ;
  }
  ap_send_error_response(r_1st_err, recursive_error);
  return;
}
}
static void check_pipeline_flush(request_rec *r ) 
{ conn_rec *c ;
  apr_bucket_brigade *bb ;
  apr_bucket_brigade *tmp ;
  apr_bucket *e ;
  apr_bucket *tmp___0 ;
  apr_bucket *ap__b ;
  apr_status_t tmp___1 ;

  {
  c = r->connection;
  tmp = apr_brigade_create(r->pool, c->bucket_alloc);
  bb = tmp;
  if ((int )(r->connection)->keepalive == 1) {
    goto _L;
  } else {
    tmp___1 = ap_get_brigade(r->input_filters, bb, (enum __anonenum_ap_input_mode_t_70 )2,
                             (enum __anonenum_apr_read_type_e_60 )1, 0L);
    if (tmp___1 != 0) {
      _L: 
      tmp___0 = apr_bucket_flush_create(c->bucket_alloc);
      e = tmp___0;
      while (1) {
        ap__b = e;
        while (1) {
          ap__b->link.prev = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                  (char *)((void *)0)));
          ap__b->link.next = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                   (char *)((void *)0))))->link.next;
          (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0))))->link.next)->link.prev = ap__b;
          ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0))))->link.next = ap__b;
          break;
        }
        break;
      }
      ap_pass_brigade((r->connection)->output_filters, bb);
    }
  }
  return;
}
}
void ap_process_request(request_rec *r ) 
{ int access_status ;

  {
  access_status = ap_run_quick_handler(r, 0);
  if (access_status == -1) {
    access_status = ap_process_request_internal(r);
    if (access_status == 0) {
      access_status = ap_invoke_handler(r);
    }
  }
  if (access_status == -2) {
    access_status = 0;
  }
  if (access_status == 0) {
    ap_finalize_request_protocol(r);
  } else {
    ap_die(access_status, r);
  }
  check_pipeline_flush(r);
  ap_run_log_transaction(r);
  return;
}
}
static apr_table_t *rename_original_env(apr_pool_t *p , apr_table_t *t ) 
{ apr_array_header_t const   *env_arr ;
  apr_array_header_t const   *tmp ;
  apr_table_entry_t const   *elts ;
  apr_table_t *new ;
  apr_table_t *tmp___0 ;
  int i ;
  char const   *tmp___1 ;

  {
  tmp = apr_table_elts((apr_table_t const   *)t);
  env_arr = tmp;
  elts = (apr_table_entry_t const   *)env_arr->elts;
  tmp___0 = apr_table_make(p, env_arr->nalloc);
  new = tmp___0;
  i = 0;
  while (i < env_arr->nelts) {
    if (! (elts + i)->key) {
      goto __Cont;
    }
    tmp___1 = apr_pstrcat(p, "REDIRECT_", (elts + i)->key, (void *)0);
    apr_table_setn(new, tmp___1, (char const   *)(elts + i)->val);
    __Cont: 
    i ++;
  }
  return (new);
}
}
static request_rec *internal_internal_redirect(char const   *new_uri , request_rec *r ) 
{ int access_status ;
  request_rec *new ;
  void *tmp ;
  request_rec *tmp___0 ;
  char const   *tmp___1 ;

  {
  tmp = apr_palloc(r->pool, sizeof(request_rec ));
  tmp___0 = (request_rec *)memset(tmp, 0, sizeof(request_rec ));
  new = tmp___0;
  new->connection = r->connection;
  new->server = r->server;
  new->pool = r->pool;
  new->method = r->method;
  new->method_number = r->method_number;
  new->allowed_methods = ap_make_method_list(new->pool, 2);
  ap_parse_uri(new, new_uri);
  new->request_config = ap_create_request_config(r->pool);
  new->per_dir_config = (r->server)->lookup_defaults;
  new->prev = r;
  r->next = new;
  ap_run_create_request(new);
  new->the_request = r->the_request;
  new->allowed = r->allowed;
  new->status = r->status;
  new->assbackwards = r->assbackwards;
  new->header_only = r->header_only;
  new->protocol = r->protocol;
  new->proto_num = r->proto_num;
  new->hostname = r->hostname;
  new->request_time = r->request_time;
  new->main = r->main;
  new->headers_in = r->headers_in;
  new->headers_out = apr_table_make(r->pool, 12);
  new->err_headers_out = r->err_headers_out;
  new->subprocess_env = rename_original_env(r->pool, r->subprocess_env);
  new->notes = apr_table_make(r->pool, 5);
  new->allowed_methods = ap_make_method_list(new->pool, 2);
  new->htaccess = r->htaccess;
  new->no_cache = r->no_cache;
  new->expecting_100 = r->expecting_100;
  new->no_local_copy = r->no_local_copy;
  new->read_length = r->read_length;
  new->vlist_validator = r->vlist_validator;
  new->proto_output_filters = r->proto_output_filters;
  new->proto_input_filters = r->proto_input_filters;
  new->output_filters = new->proto_output_filters;
  new->input_filters = new->proto_input_filters;
  update_r_in_filters(new->input_filters, r, new);
  update_r_in_filters(new->output_filters, r, new);
  tmp___1 = apr_itoa(r->pool, r->status);
  apr_table_setn(new->subprocess_env, "REDIRECT_STATUS", tmp___1);
  access_status = ap_run_post_read_request(new);
  if (access_status) {
    ap_die(access_status, new);
    return ((request_rec *)((void *)0));
  }
  return (new);
}
}
void ap_internal_fast_redirect(request_rec *rr , request_rec *r ) 
{ 

  {
  r->mtime = rr->mtime;
  r->uri = rr->uri;
  r->filename = rr->filename;
  r->canonical_filename = rr->canonical_filename;
  r->path_info = rr->path_info;
  r->args = rr->args;
  r->finfo = rr->finfo;
  r->handler = rr->handler;
  ap_set_content_type(r, rr->content_type);
  r->content_encoding = rr->content_encoding;
  r->content_languages = rr->content_languages;
  r->per_dir_config = rr->per_dir_config;
  r->notes = apr_table_overlay(r->pool, (apr_table_t const   *)rr->notes, (apr_table_t const   *)r->notes);
  r->headers_out = apr_table_overlay(r->pool, (apr_table_t const   *)rr->headers_out,
                                     (apr_table_t const   *)r->headers_out);
  r->err_headers_out = apr_table_overlay(r->pool, (apr_table_t const   *)rr->err_headers_out,
                                         (apr_table_t const   *)r->err_headers_out);
  r->subprocess_env = apr_table_overlay(r->pool, (apr_table_t const   *)rr->subprocess_env,
                                        (apr_table_t const   *)r->subprocess_env);
  r->output_filters = rr->output_filters;
  r->input_filters = rr->input_filters;
  if (r->main) {
    ap_add_output_filter_handle(ap_subreq_core_filter_handle, (void *)0, r, r->connection);
  } else {
    if ((unsigned int )(r->output_filters)->frec == (unsigned int )ap_subreq_core_filter_handle) {
      ap_remove_output_filter(r->output_filters);
      r->output_filters = (r->output_filters)->next;
    }
  }
  update_r_in_filters(r->input_filters, rr, r);
  update_r_in_filters(r->output_filters, rr, r);
  return;
}
}
void ap_internal_redirect(char const   *new_uri , request_rec *r ) 
{ request_rec *new ;
  request_rec *tmp ;
  int access_status ;
  int tmp___0 ;

  {
  tmp = internal_internal_redirect(new_uri, r);
  new = tmp;
  tmp___0 = ap_process_request_internal(new);
  access_status = tmp___0;
  if (access_status == 0) {
    access_status = ap_invoke_handler(new);
    if (access_status != 0) {
      ap_die(access_status, new);
      return;
    }
    ap_finalize_request_protocol(new);
  } else {
    ap_die(access_status, new);
  }
  return;
}
}
void ap_internal_redirect_handler(char const   *new_uri , request_rec *r ) 
{ int access_status ;
  request_rec *new ;
  request_rec *tmp ;

  {
  tmp = internal_internal_redirect(new_uri, r);
  new = tmp;
  if (r->handler) {
    ap_set_content_type(new, r->content_type);
  }
  access_status = ap_process_request_internal(new);
  if (access_status == 0) {
    access_status = ap_invoke_handler(new);
    if (access_status != 0) {
      ap_die(access_status, new);
      return;
    }
    ap_finalize_request_protocol(new);
  } else {
    ap_die(access_status, new);
  }
  return;
}
}
void ap_allow_methods(request_rec *r , int reset  , ...) 
{ char const   *method ;
  va_list methods ;

  {
  if (reset) {
    ap_clear_method_list(r->allowed_methods);
  }
  __builtin_stdarg_start(methods, reset);
  while (1) {
    method = __builtin_va_arg(methods, char const   *);
    if (! ((unsigned int )method != (unsigned int )((void *)0))) {
      break;
    }
    ap_method_list_add(r->allowed_methods, method);
  }
  return;
}
}
void ap_allow_standard_methods(request_rec *r , int reset  , ...) 
{ int method ;
  va_list methods ;
  apr_int64_t mask ;

  {
  if (reset) {
    ap_clear_method_list(r->allowed_methods);
  }
  mask = 0LL;
  __builtin_stdarg_start(methods, reset);
  while (1) {
    method = __builtin_va_arg(methods, int );
    if (! (method != -1)) {
      break;
    }
    mask |= 1LL << method;
  }
  __builtin_va_end(methods);
  (r->allowed_methods)->method_mask = (r->allowed_methods)->method_mask | mask;
  return;
}
}
#pragma merger(0,"/tmp/cil-gKuxEvKh.i","-g -pthread")
apr_hash_t *apr_hash_copy(apr_pool_t *pool , apr_hash_t const   *orig ) ;
apr_hash_t *apr_hash_merge(apr_pool_t *p , apr_hash_t const   *overlay , apr_hash_t const   *base ,
                           void *(*merger)(apr_pool_t *p , void const   *key , apr_ssize_t klen ,
                                           void const   *h1_val , void const   *h2_val ,
                                           void const   *data ) , void const   *data ) ;
void ap_str_tolower(char *str ) ;
char const   *ap_set_string_slot(cmd_parms *cmd , void *struct_ptr , char const   *arg ) ;
ap_filter_t *ap_add_input_filter(char const   *name , void *ctx , request_rec *r ,
                                 conn_rec *c ) ;
void ap_hook_type_checker(ap_HOOK_type_checker_t *pf , char const   * const  *aszPre___1 ,
                          char const   * const  *aszSucc___2 , int nOrder ) ;
static char tspecial[16]  = 
  {      (char )'(',      (char )')',      (char )'<',      (char )'>', 
        (char )'@',      (char )',',      (char )';',      (char )':', 
        (char )'\\',      (char )'\"',      (char )'/',      (char )'[', 
        (char )']',      (char )'?',      (char )'=',      (char )'\000'};
static void *create_mime_dir_config(apr_pool_t *p , char *dummy ) 
{ mime_dir_config *new ;
  mime_dir_config *tmp ;

  {
  tmp = (mime_dir_config *)apr_palloc(p, sizeof(mime_dir_config ));
  new = tmp;
  new->extension_mappings = (apr_hash_t *)((void *)0);
  new->remove_mappings = (apr_array_header_t *)((void *)0);
  new->default_language = (char *)((void *)0);
  new->multimatch = 0;
  new->use_path_info = 2;
  return ((void *)new);
}
}
static void *overlay_extension_mappings(apr_pool_t *p , void const   *key , apr_ssize_t klen ,
                                        void const   *overlay_val , void const   *base_val ,
                                        void const   *data ) 
{ extension_info *new_info ;
  extension_info *tmp ;
  extension_info const   *overlay_info ;
  extension_info const   *base_info ;

  {
  tmp = (extension_info *)apr_palloc(p, sizeof(extension_info ));
  new_info = tmp;
  overlay_info = (extension_info const   *)overlay_val;
  base_info = (extension_info const   *)base_val;
  memcpy((void * __restrict  )new_info, (void const   * __restrict  )base_info, sizeof(extension_info ));
  if (overlay_info->forced_type) {
    new_info->forced_type = overlay_info->forced_type;
  }
  if (overlay_info->encoding_type) {
    new_info->encoding_type = overlay_info->encoding_type;
  }
  if (overlay_info->language_type) {
    new_info->language_type = overlay_info->language_type;
  }
  if (overlay_info->handler) {
    new_info->handler = overlay_info->handler;
  }
  if (overlay_info->charset_type) {
    new_info->charset_type = overlay_info->charset_type;
  }
  if (overlay_info->input_filters) {
    new_info->input_filters = overlay_info->input_filters;
  }
  if (overlay_info->output_filters) {
    new_info->output_filters = overlay_info->output_filters;
  }
  return ((void *)new_info);
}
}
static void remove_items(apr_pool_t *p , apr_array_header_t *remove___0 , apr_hash_t *mappings ) 
{ attrib_info *suffix ;
  int i ;
  extension_info *exinfo ;
  extension_info *tmp ;
  extension_info *copyinfo ;

  {
  suffix = (attrib_info *)remove___0->elts;
  i = 0;
  while (i < remove___0->nelts) {
    tmp = (extension_info *)apr_hash_get(mappings, (void const   *)(suffix + i)->name,
                                         -1);
    exinfo = tmp;
    if (exinfo) {
      if ((*((char const   **)((char *)exinfo + (suffix + i)->offset)))) {
        copyinfo = exinfo;
        exinfo = (extension_info *)apr_palloc(p, sizeof((*exinfo)));
        apr_hash_set(mappings, (void const   *)(suffix + i)->name, -1, (void const   *)exinfo);
        memcpy((void * __restrict  )exinfo, (void const   * __restrict  )copyinfo,
               sizeof((*exinfo)));
        (*((char const   **)((char *)exinfo + (suffix + i)->offset))) = (char const   *)((void *)0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
    i ++;
  }
  return;
}
}
static void *merge_mime_dir_configs(apr_pool_t *p , void *basev , void *addv ) 
{ mime_dir_config *base ;
  mime_dir_config *add ;
  mime_dir_config *new ;
  mime_dir_config *tmp ;

  {
  base = (mime_dir_config *)basev;
  add = (mime_dir_config *)addv;
  tmp = (mime_dir_config *)apr_palloc(p, sizeof(mime_dir_config ));
  new = tmp;
  if (base->extension_mappings) {
    if (add->extension_mappings) {
      new->extension_mappings = apr_hash_merge(p, (apr_hash_t const   *)add->extension_mappings,
                                               (apr_hash_t const   *)base->extension_mappings,
                                               & overlay_extension_mappings, (void const   *)((void *)0));
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if ((unsigned int )base->extension_mappings == (unsigned int )((void *)0)) {
      new->extension_mappings = add->extension_mappings;
    } else {
      new->extension_mappings = base->extension_mappings;
    }
    if (new->extension_mappings) {
      if (add->remove_mappings) {
        new->extension_mappings = apr_hash_copy(p, (apr_hash_t const   *)new->extension_mappings);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
  }
  if (new->extension_mappings) {
    if (add->remove_mappings) {
      remove_items(p, add->remove_mappings, new->extension_mappings);
    }
  }
  new->remove_mappings = (apr_array_header_t *)((void *)0);
  if (add->default_language) {
    new->default_language = add->default_language;
  } else {
    new->default_language = base->default_language;
  }
  if (add->multimatch != 0) {
    new->multimatch = add->multimatch;
  } else {
    new->multimatch = base->multimatch;
  }
  if ((add->use_path_info & 2) == 0) {
    new->use_path_info = add->use_path_info;
  } else {
    new->use_path_info = base->use_path_info;
  }
  return ((void *)new);
}
}
static char const   *add_extension_info(cmd_parms *cmd , void *m_ , char const   *value_ ,
                                        char const   *ext ) 
{ mime_dir_config *m ;
  extension_info *exinfo ;
  int offset ;
  char *key ;
  char *tmp ;
  char *value ;
  char *tmp___0 ;
  void *tmp___2 ;

  {
  m = (mime_dir_config *)m_;
  offset = (int )((long )cmd->info);
  tmp = apr_pstrdup(cmd->temp_pool, ext);
  key = tmp;
  tmp___0 = apr_pstrdup(cmd->pool, value_);
  value = tmp___0;
  ap_str_tolower(value);
  ap_str_tolower(key);
  if ((int )(*key) == 46) {
    key ++;
  }
  if (! m->extension_mappings) {
    m->extension_mappings = apr_hash_make(cmd->pool);
    exinfo = (extension_info *)((void *)0);
  } else {
    exinfo = (extension_info *)apr_hash_get(m->extension_mappings, (void const   *)key,
                                            -1);
  }
  if (! exinfo) {
    tmp___2 = apr_palloc(cmd->pool, sizeof(extension_info ));
    exinfo = (extension_info *)memset(tmp___2, 0, sizeof(extension_info ));
    key = apr_pstrdup(cmd->pool, (char const   *)key);
    apr_hash_set(m->extension_mappings, (void const   *)key, -1, (void const   *)exinfo);
  }
  (*((char const   **)((char *)exinfo + offset))) = (char const   *)value;
  return ((char const   *)((void *)0));
}
}
static char const   *remove_extension_info(cmd_parms *cmd , void *m_ , char const   *ext ) 
{ mime_dir_config *m ;
  attrib_info *suffix ;

  {
  m = (mime_dir_config *)m_;
  if ((int const   )(*ext) == 46) {
    ext ++;
  }
  if (! m->remove_mappings) {
    m->remove_mappings = apr_array_make(cmd->pool, 4, (int )sizeof((*suffix)));
  }
  suffix = (attrib_info *)apr_array_push(m->remove_mappings);
  suffix->name = apr_pstrdup(cmd->pool, ext);
  ap_str_tolower(suffix->name);
  suffix->offset = (int )((long )cmd->info);
  return ((char const   *)((void *)0));
}
}
static char const   *set_types_config(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ 

  {
  (*((void **)(cmd->server)->module_config + mime_module.module_index)) = (void *)arg;
  return ((char const   *)((void *)0));
}
}
static char const   *multiviews_match(cmd_parms *cmd , void *m_ , char const   *include ) 
{ mime_dir_config *m ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  m = (mime_dir_config *)m_;
  tmp___2 = strcasecmp(include, "Any");
  if (tmp___2 == 0) {
    if (m->multimatch) {
      if (m->multimatch & -2) {
        return ("Any is incompatible with NegotiatedOnly, Filters and Handlers");
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
    m->multimatch |= 1;
  } else {
    tmp___1 = strcasecmp(include, "NegotiatedOnly");
    if (tmp___1 == 0) {
      if (m->multimatch) {
        if (m->multimatch & -3) {
          return ("Any is incompatible with NegotiatedOnly, Filters and Handlers");
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ ;
      }
      m->multimatch |= 2;
    } else {
      tmp___0 = strcasecmp(include, "Filters");
      if (tmp___0 == 0) {
        if (m->multimatch) {
          if (m->multimatch & 3) {
            return ("Filters is incompatible with Any and NegotiatedOnly");
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ ;
        }
        m->multimatch |= 8;
      } else {
        tmp = strcasecmp(include, "Handlers");
        if (tmp == 0) {
          if (m->multimatch) {
            if (m->multimatch & 3) {
              return ("Handlers is incompatible with Any and NegotiatedOnly");
            } else {
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ ;
          }
          m->multimatch |= 4;
        } else {
          return ("Unrecognized option");
        }
      }
    }
  }
  return ((char const   *)((void *)0));
}
}
static command_rec const   mime_cmds[19]  = 
  {      {"AddCharset", {& add_extension_info}, (void *)((long )((char *)(& ((extension_info *)((void *)0))->charset_type) -
                                                             (char *)((void *)0))),
      4, 4, "a charset (e.g., iso-2022-jp), followed by one or more file extensions"}, 
        {"AddEncoding",
      {& add_extension_info}, (void *)((long )((char *)(& ((extension_info *)((void *)0))->encoding_type) -
                                               (char *)((void *)0))), 4, 4, "an encoding (e.g., gzip), followed by one or more file extensions"}, 
        {"AddHandler",
      {& add_extension_info}, (void *)((long )((char *)(& ((extension_info *)((void *)0))->handler) -
                                               (char *)((void *)0))), 4, 4, "a handler name followed by one or more file extensions"}, 
        {"AddInputFilter",
      {& add_extension_info}, (void *)((long )((char *)(& ((extension_info *)((void *)0))->input_filters) -
                                               (char *)((void *)0))), 4, 4, "input filter name (or ; delimited names) followed by one or more file extensions"}, 
        {"AddLanguage",
      {& add_extension_info}, (void *)((long )((char *)(& ((extension_info *)((void *)0))->language_type) -
                                               (char *)((void *)0))), 4, 4, "a language (e.g., fr), followed by one or more file extensions"}, 
        {"AddOutputFilter",
      {& add_extension_info}, (void *)((long )((char *)(& ((extension_info *)((void *)0))->output_filters) -
                                               (char *)((void *)0))), 4, 4, "output filter name (or ; delimited names) followed by one or more file extensions"}, 
        {"AddType",
      {& add_extension_info}, (void *)((long )((char *)(& ((extension_info *)((void *)0))->forced_type) -
                                               (char *)((void *)0))), 4, 4, "a mime type followed by one or more file extensions"}, 
        {"DefaultLanguage",
      {& ap_set_string_slot}, (void *)((long )((char *)(& ((mime_dir_config *)((void *)0))->default_language) -
                                               (char *)((void *)0))), 4, 1, "language to use for documents with no other language file extension"}, 
        {"MultiviewsMatch",
      {& multiviews_match}, (void *)0, 4, 3, "NegotiatedOnly (default), Handlers and/or Filters, or Any"}, 
        {"RemoveCharset",
      {& remove_extension_info}, (void *)((long )((char *)(& ((extension_info *)((void *)0))->charset_type) -
                                                  (char *)((void *)0))), 4, 3, "one or more file extensions"}, 
        {"RemoveEncoding",
      {& remove_extension_info}, (void *)((long )((char *)(& ((extension_info *)((void *)0))->encoding_type) -
                                                  (char *)((void *)0))), 4, 3, "one or more file extensions"}, 
        {"RemoveHandler",
      {& remove_extension_info}, (void *)((long )((char *)(& ((extension_info *)((void *)0))->handler) -
                                                  (char *)((void *)0))), 4, 3, "one or more file extensions"}, 
        {"RemoveInputFilter",
      {& remove_extension_info}, (void *)((long )((char *)(& ((extension_info *)((void *)0))->input_filters) -
                                                  (char *)((void *)0))), 4, 3, "one or more file extensions"}, 
        {"RemoveLanguage",
      {& remove_extension_info}, (void *)((long )((char *)(& ((extension_info *)((void *)0))->language_type) -
                                                  (char *)((void *)0))), 4, 3, "one or more file extensions"}, 
        {"RemoveOutputFilter",
      {& remove_extension_info}, (void *)((long )((char *)(& ((extension_info *)((void *)0))->output_filters) -
                                                  (char *)((void *)0))), 4, 3, "one or more file extensions"}, 
        {"RemoveType",
      {& remove_extension_info}, (void *)((long )((char *)(& ((extension_info *)((void *)0))->forced_type) -
                                                  (char *)((void *)0))), 4, 3, "one or more file extensions"}, 
        {"TypesConfig",
      {& set_types_config}, (void *)0, 128, 1, "the MIME types config file"}, 
        {"ModMimeUsePathInfo", {& ap_set_flag_slot}, (void *)((long )((char *)(& ((mime_dir_config *)((void *)0))->use_path_info) -
                                                                   (char *)((void *)0))),
      64, 5, "Set to \'yes\' to allow mod_mime to use path info for type checking"}, 
        {(char const   *)((void *)0),
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))0}, (void *)0,
      0, 0, (char const   *)0}};
static apr_hash_t *mime_type_extensions  ;
static int mime_post_config(apr_pool_t *p , apr_pool_t *plog , apr_pool_t *ptemp ,
                            server_rec *s ) 
{ ap_configfile_t *f ;
  char l[8192] ;
  char const   *types_confname ;
  apr_status_t status ;
  char const   *ll ;
  char const   *ct ;
  char *ext ;
  char *tmp ;
  int tmp___0 ;

  {
  types_confname = (char const   *)(*((void **)s->module_config + mime_module.module_index));
  if (! types_confname) {
    types_confname = "conf/mime.types";
  }
  types_confname = ap_server_root_relative(p, types_confname);
  if (! types_confname) {
    ap_log_error("mod_mime.c", 470, 3, 20024, (server_rec const   *)s, "Invalid mime types config path %s",
                 (char const   *)(*((void **)s->module_config + mime_module.module_index)));
    return (500);
  }
  status = ap_pcfg_openfile(& f, ptemp, types_confname);
  if (status != 0) {
    ap_log_error("mod_mime.c", 478, 3, status, (server_rec const   *)s, "could not open mime types config file %s.",
                 types_confname);
    return (500);
  }
  mime_type_extensions = apr_hash_make(p);
  while (1) {
    tmp___0 = ap_cfg_getline(l, 8192U, f);
    if (tmp___0) {
      break;
    }
    ll = (char const   *)(l);
    if ((int )l[0] == 35) {
      continue;
    }
    ct = ap_getword_conf(p, & ll);
    while ((*(ll + 0))) {
      tmp = ap_getword_conf(p, & ll);
      ext = tmp;
      ap_str_tolower(ext);
      apr_hash_set(mime_type_extensions, (void const   *)ext, -1, (void const   *)ct);
    }
  }
  ap_cfg_closefile(f);
  return (0);
}
}
static char const   *zap_sp(char const   *s ) 
{ 

  {
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    return ((char const   *)((void *)0));
  }
  if ((int const   )(*s) == 0) {
    return (s);
  }
  while (1) {
    if ((int const   )(*s) == 32) {
      goto _L___0;
    } else {
      if ((int const   )(*s) == 9) {
        _L___0: /* CIL Label */ 
        goto _L;
      } else {
        if ((int const   )(*s) == 10) {
          _L: /* CIL Label */ ;
        } else {
          break;
        }
      }
    }
    s ++;
  }
  return (s);
}
}
static char *zap_sp_and_dup(apr_pool_t *p , char const   *start , char const   *end ,
                            apr_size_t *len ) 
{ unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;

  {
  while (1) {
    if ((unsigned int )start < (unsigned int )end) {
      tmp = __ctype_b_loc();
      if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*start)))) & 8192)) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      break;
    }
    start ++;
  }
  while (1) {
    if ((unsigned int )end > (unsigned int )start) {
      tmp___0 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___0) + (int )((unsigned char )(*(end - 1))))) &
             8192)) {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      break;
    }
    end --;
  }
  if (len) {
    (*len) = (unsigned int )(end - start);
  }
  tmp___1 = apr_pstrmemdup(p, start, (unsigned int )(end - start));
  return (tmp___1);
}
}
static int is_token(char c ) 
{ int res ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;

  {
  if (((int )((unsigned char )c) & -128) == 0) {
    tmp___1 = __ctype_b_loc();
    if ((int const   )(*((*tmp___1) + (int )((unsigned char )c))) & 32768) {
      tmp___2 = strchr((char const   *)(tspecial), (int )c);
      if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
        res = 1;
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    res = -1;
  }
  return (res);
}
}
static int is_qtext(char c ) 
{ int res ;

  {
  if (((int )((unsigned char )c) & -128) == 0) {
    if ((int )c != 34) {
      if ((int )c != 92) {
        if ((int )c != 10) {
          res = 1;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    res = -1;
  }
  return (res);
}
}
static int is_quoted_pair(char const   *s ) 
{ int res ;
  int c ;

  {
  res = -1;
  if ((unsigned int )(s + 1) != (unsigned int )((void *)0)) {
    if ((int const   )(*s) == 92) {
      c = (int )(*(s + 1));
      if (((int )((unsigned char )c) & -128) == 0) {
        res = 1;
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  return (res);
}
}
static content_type *analyze_ct(request_rec *r , char const   *s ) 
{ char const   *cp ;
  char const   *mp ;
  char *attribute ;
  char *value ;
  int quoted ;
  server_rec *ss ;
  apr_pool_t *p ;
  content_type *ctp ;
  param *pp ;
  param *npp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  quoted = 0;
  ss = r->server;
  p = r->pool;
  ctp = (content_type *)apr_palloc(p, sizeof(content_type ));
  ctp->type = (char const   *)((void *)0);
  ctp->subtype = (char const   *)((void *)0);
  ctp->param = (param *)((void *)0);
  mp = s;
  cp = mp;
  while (1) {
    tmp___0 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___0) + (int )((unsigned char )(*cp)))) & 8192)) {
      break;
    }
    cp ++;
  }
  if (! (*cp)) {
    ap_log_error("mod_mime.c", 592, 4, 0, (server_rec const   *)ss, "mod_mime: analyze_ct: cannot get media type from \'%s\'",
                 mp);
    return ((content_type *)((void *)0));
  }
  ctp->type = cp;
  while (1) {
    cp ++;
    if ((*cp)) {
      if ((int const   )(*cp) != 47) {
        tmp___1 = __ctype_b_loc();
        if ((int const   )(*((*tmp___1) + (int )((unsigned char )(*cp)))) & 8192) {
          goto _L___1;
        } else {
          if (! ((int const   )(*cp) != 59)) {
            goto _L___1;
          }
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      break;
    }
  }
  if (! (*cp)) {
    goto _L___2;
  } else {
    if ((int const   )(*cp) == 59) {
      _L___2: /* CIL Label */ 
      ap_log_error("mod_mime.c", 602, 4, 0, (server_rec const   *)ss, "Cannot get media type from \'%s\'",
                   mp);
      return ((content_type *)((void *)0));
    }
  }
  while (1) {
    tmp___2 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___2) + (int )((unsigned char )(*cp)))) & 8192)) {
      break;
    }
    cp ++;
  }
  if ((int const   )(*cp) != 47) {
    ap_log_error("mod_mime.c", 611, 4, 0, (server_rec const   *)ss, "mod_mime: analyze_ct: cannot get media type from \'%s\'",
                 mp);
    return ((content_type *)((void *)0));
  }
  ctp->type_len = (unsigned int )(cp - ctp->type);
  cp ++;
  while (1) {
    tmp___3 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___3) + (int )((unsigned char )(*cp)))) & 8192)) {
      break;
    }
    cp ++;
  }
  if (! (*cp)) {
    ap_log_error("mod_mime.c", 625, 4, 0, (server_rec const   *)ss, "Cannot get media subtype.");
    return ((content_type *)((void *)0));
  }
  ctp->subtype = cp;
  while (1) {
    cp ++;
    if ((*cp)) {
      tmp___4 = __ctype_b_loc();
      if ((int const   )(*((*tmp___4) + (int )((unsigned char )(*cp)))) & 8192) {
        goto _L___4;
      } else {
        if (! ((int const   )(*cp) != 59)) {
          goto _L___4;
        }
      }
    } else {
      _L___4: /* CIL Label */ 
      break;
    }
  }
  ctp->subtype_len = (unsigned int )(cp - ctp->subtype);
  while (1) {
    tmp___5 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___5) + (int )((unsigned char )(*cp)))) & 8192)) {
      break;
    }
    cp ++;
  }
  if ((int const   )(*cp) == 0) {
    return (ctp);
  }
  cp ++;
  cp = zap_sp(cp);
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto _L___5;
  } else {
    if ((int const   )(*cp) == 0) {
      _L___5: /* CIL Label */ 
      ap_log_error("mod_mime.c", 646, 4, 0, (server_rec const   *)ss, "Cannot get media parameter.");
      return ((content_type *)((void *)0));
    }
  }
  mp = cp;
  attribute = (char *)((void *)0);
  value = (char *)((void *)0);
  while (1) {
    if ((unsigned int )cp != (unsigned int )((void *)0)) {
      if (! ((int const   )(*cp) != 0)) {
        goto _L___16;
      }
    } else {
      _L___16: /* CIL Label */ 
      break;
    }
    if ((unsigned int )attribute == (unsigned int )((void *)0)) {
      tmp___6 = is_token((char )(*cp));
      if (tmp___6 > 0) {
        cp ++;
        continue;
      } else {
        if ((int const   )(*cp) == 32) {
          goto _L___9;
        } else {
          if ((int const   )(*cp) == 9) {
            _L___9: /* CIL Label */ 
            goto _L___8;
          } else {
            if ((int const   )(*cp) == 10) {
              _L___8: /* CIL Label */ 
              cp ++;
              continue;
            } else {
              if ((int const   )(*cp) == 61) {
                attribute = zap_sp_and_dup(p, mp, cp, (apr_size_t *)((void *)0));
                if ((unsigned int )attribute == (unsigned int )((void *)0)) {
                  goto _L___6;
                } else {
                  if ((int )(*attribute) == 0) {
                    _L___6: /* CIL Label */ 
                    ap_log_error("mod_mime.c", 667, 4, 0, (server_rec const   *)ss,
                                 "Cannot get media parameter.");
                    return ((content_type *)((void *)0));
                  }
                }
                cp ++;
                cp = zap_sp(cp);
                if ((unsigned int )cp == (unsigned int )((void *)0)) {
                  goto _L___7;
                } else {
                  if ((int const   )(*cp) == 0) {
                    _L___7: /* CIL Label */ 
                    ap_log_error("mod_mime.c", 674, 4, 0, (server_rec const   *)ss,
                                 "Cannot get media parameter.");
                    return ((content_type *)((void *)0));
                  }
                }
                mp = cp;
                continue;
              } else {
                ap_log_error("mod_mime.c", 682, 4, 0, (server_rec const   *)ss, "Cannot get media parameter.");
                return ((content_type *)((void *)0));
              }
            }
          }
        }
      }
    } else {
      if ((unsigned int )mp == (unsigned int )cp) {
        if ((int const   )(*cp) == 34) {
          quoted = 1;
          cp ++;
        } else {
          quoted = 0;
        }
      }
      if (quoted > 0) {
        while (1) {
          if (quoted) {
            if (! ((int const   )(*cp) != 0)) {
              goto _L___13;
            }
          } else {
            _L___13: /* CIL Label */ 
            break;
          }
          tmp___8 = is_qtext((char )(*cp));
          if (tmp___8 > 0) {
            cp ++;
          } else {
            tmp___7 = is_quoted_pair(cp);
            if (tmp___7 > 0) {
              cp += 2;
            } else {
              if ((int const   )(*cp) == 34) {
                cp ++;
                while (1) {
                  if ((int const   )(*cp) == 32) {
                    goto _L___11;
                  } else {
                    if ((int const   )(*cp) == 9) {
                      _L___11: /* CIL Label */ 
                      goto _L___10;
                    } else {
                      if ((int const   )(*cp) == 10) {
                        _L___10: /* CIL Label */ ;
                      } else {
                        break;
                      }
                    }
                  }
                  cp ++;
                }
                if ((int const   )(*cp) != 59) {
                  if ((int const   )(*cp) != 0) {
                    ap_log_error("mod_mime.c", 711, 4, 0, (server_rec const   *)ss,
                                 "Cannot get media parameter.");
                    return ((content_type *)((void *)0));
                  } else {
                    goto _L___12;
                  }
                } else {
                  _L___12: /* CIL Label */ ;
                }
                quoted = 0;
              } else {
                ap_log_error("mod_mime.c", 718, 4, 0, (server_rec const   *)ss, "Cannot get media parameter.");
                return ((content_type *)((void *)0));
              }
            }
          }
        }
      } else {
        while (1) {
          tmp___9 = is_token((char )(*cp));
          if (tmp___9 > 0) {
            cp ++;
          } else {
            if ((int const   )(*cp) == 0) {
              goto _L___14;
            } else {
              if ((int const   )(*cp) == 59) {
                _L___14: /* CIL Label */ 
                break;
              } else {
                ap_log_error("mod_mime.c", 733, 4, 0, (server_rec const   *)ss, "Cannot get media parameter.");
                return ((content_type *)((void *)0));
              }
            }
          }
        }
      }
      value = zap_sp_and_dup(p, mp, cp, (apr_size_t *)((void *)0));
      if ((unsigned int )value == (unsigned int )((void *)0)) {
        goto _L___15;
      } else {
        if ((int )(*value) == 0) {
          _L___15: /* CIL Label */ 
          ap_log_error("mod_mime.c", 741, 4, 0, (server_rec const   *)ss, "Cannot get media parameter.");
          return ((content_type *)((void *)0));
        }
      }
      pp = (param *)apr_palloc(p, sizeof(param ));
      pp->attr = attribute;
      pp->val = value;
      pp->next = (struct param_s *)((void *)0);
      if ((unsigned int )ctp->param == (unsigned int )((void *)0)) {
        ctp->param = pp;
      } else {
        npp = ctp->param;
        while (npp->next) {
          npp = npp->next;
        }
        npp->next = pp;
      }
      quoted = 0;
      attribute = (char *)((void *)0);
      value = (char *)((void *)0);
      if ((int const   )(*cp) == 0) {
        break;
      }
      cp ++;
      mp = cp;
    }
  }
  return (ctp);
}
}
static int find_ct(request_rec *r ) 
{ mime_dir_config *conf ;
  apr_array_header_t *exception_list ;
  char *ext ;
  char const   *fn ;
  char const   *type ;
  char const   *charset ;
  char const   *resource_name ;
  int found_metadata ;
  void *tmp ;
  extension_info const   *exinfo ;
  int found ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *filter ;
  char const   *filters ;
  char const   *filter___0 ;
  char const   *filters___0 ;
  void *tmp___2 ;
  content_type *ctp ;
  int override ;
  param *pp ;
  char *base_content_type ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   **new ;

  {
  charset = (char const   *)((void *)0);
  found_metadata = 0;
  if ((int )r->finfo.filetype == 2) {
    ap_set_content_type(r, "httpd/unix-directory");
    return (0);
  }
  if (! r->filename) {
    return (-1);
  }
  conf = (mime_dir_config *)(*((void **)r->per_dir_config + mime_module.module_index));
  exception_list = apr_array_make(r->pool, 2, (int )sizeof(char *));
  if (conf->use_path_info & 1) {
    resource_name = apr_pstrcat(r->pool, r->filename, r->path_info, (void *)0);
  } else {
    resource_name = (char const   *)r->filename;
  }
  fn = strrchr(resource_name, '/');
  if ((unsigned int )fn == (unsigned int )((void *)0)) {
    fn = resource_name;
  } else {
    fn ++;
  }
  ext = ap_getword(r->pool, & fn, (char )'.');
  tmp = apr_array_push(exception_list);
  (*((char const   **)tmp)) = (char const   *)ext;
  while (1) {
    if ((*fn)) {
      ext = ap_getword(r->pool, & fn, (char )'.');
      if (! ext) {
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
      break;
    }
    exinfo = (extension_info const   *)((void *)0);
    if ((int )(*ext) == 0) {
      continue;
    }
    found = 0;
    ap_str_tolower(ext);
    if ((unsigned int )conf->extension_mappings != (unsigned int )((void *)0)) {
      tmp___0 = apr_hash_get(conf->extension_mappings, (void const   *)ext, -1);
      exinfo = (extension_info const   *)((extension_info *)tmp___0);
    }
    if ((unsigned int )exinfo == (unsigned int )((void *)0)) {
      goto _L;
    } else {
      if (! exinfo->forced_type) {
        _L: /* CIL Label */ 
        type = (char const   *)apr_hash_get(mime_type_extensions, (void const   *)ext,
                                            -1);
        if ((unsigned int )type != (unsigned int )((void *)0)) {
          ap_set_content_type(r, (char const   *)((char *)type));
          found = 1;
        }
      }
    }
    if ((unsigned int )exinfo != (unsigned int )((void *)0)) {
      if (exinfo->forced_type) {
        ap_set_content_type(r, (char const   *)exinfo->forced_type);
        found = 1;
      }
      if (exinfo->charset_type) {
        charset = (char const   *)exinfo->charset_type;
        found = 1;
      }
      if (exinfo->language_type) {
        if (! r->content_languages) {
          r->content_languages = apr_array_make(r->pool, 2, (int )sizeof(char *));
        }
        tmp___1 = apr_array_push(r->content_languages);
        (*((char const   **)tmp___1)) = (char const   *)exinfo->language_type;
        found = 1;
      }
      if (exinfo->encoding_type) {
        if (! r->content_encoding) {
          r->content_encoding = (char const   *)exinfo->encoding_type;
        } else {
          r->content_encoding = apr_pstrcat(r->pool, r->content_encoding, ", ", exinfo->encoding_type,
                                            (void *)0);
        }
        found = 1;
      }
      if (exinfo->handler) {
        if (r->proxyreq == 0) {
          r->handler = (char const   *)exinfo->handler;
          if (conf->multimatch & 4) {
            found = 1;
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ ;
      }
      if (exinfo->input_filters) {
        if (r->proxyreq == 0) {
          filters = (char const   *)exinfo->input_filters;
          while (1) {
            if ((*filters)) {
              filter = ap_getword(r->pool, & filters, (char )';');
              if (! filter) {
                goto _L___1;
              }
            } else {
              _L___1: /* CIL Label */ 
              break;
            }
            ap_add_input_filter(filter, (void *)0, r, r->connection);
          }
          if (conf->multimatch & 8) {
            found = 1;
          }
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ ;
      }
      if (exinfo->output_filters) {
        if (r->proxyreq == 0) {
          filters___0 = (char const   *)exinfo->output_filters;
          while (1) {
            if ((*filters___0)) {
              filter___0 = ap_getword(r->pool, & filters___0, (char )';');
              if (! filter___0) {
                goto _L___3;
              }
            } else {
              _L___3: /* CIL Label */ 
              break;
            }
            ap_add_output_filter(filter___0, (void *)0, r, r->connection);
          }
          if (conf->multimatch & 8) {
            found = 1;
          }
        } else {
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ ;
      }
    }
    if (found) {
      goto _L___5;
    } else {
      if (conf->multimatch & 1) {
        _L___5: /* CIL Label */ 
        found_metadata = 1;
      } else {
        tmp___2 = apr_array_push(exception_list);
        (*((char const   **)tmp___2)) = (char const   *)ext;
      }
    }
  }
  if (found_metadata) {
    apr_table_setn(r->notes, "ap-mime-exceptions-list", (char const   *)((void *)exception_list));
  }
  if (r->content_type) {
    override = 0;
    ctp = analyze_ct(r, r->content_type);
    if (ctp) {
      pp = ctp->param;
      tmp___3 = (char *)apr_palloc(r->pool, (ctp->type_len + ctp->subtype_len) + sizeof("/"));
      base_content_type = tmp___3;
      tmp___4 = base_content_type;
      memcpy((void * __restrict  )tmp___4, (void const   * __restrict  )ctp->type,
             ctp->type_len);
      tmp___4 += ctp->type_len;
      tmp___5 = tmp___4;
      tmp___4 ++;
      (*tmp___5) = (char )'/';
      memcpy((void * __restrict  )tmp___4, (void const   * __restrict  )ctp->subtype,
             ctp->subtype_len);
      tmp___4 += ctp->subtype_len;
      (*tmp___4) = (char)0;
      ap_set_content_type(r, (char const   *)base_content_type);
      while ((unsigned int )pp != (unsigned int )((void *)0)) {
        if (charset) {
          tmp___8 = strcmp((char const   *)pp->attr, "charset");
          if (tmp___8) {
            goto _L___7;
          } else {
            if (! override) {
              tmp___6 = apr_pstrcat(r->pool, r->content_type, "; charset=", charset,
                                    (void *)0);
              ap_set_content_type(r, tmp___6);
              override = 1;
            }
          }
        } else {
          _L___7: /* CIL Label */ 
          tmp___7 = apr_pstrcat(r->pool, r->content_type, "; ", pp->attr, "=", pp->val,
                                (void *)0);
          ap_set_content_type(r, tmp___7);
        }
        pp = pp->next;
      }
      if (charset) {
        if (! override) {
          tmp___9 = apr_pstrcat(r->pool, r->content_type, "; charset=", charset, (void *)0);
          ap_set_content_type(r, tmp___9);
        } else {
          goto _L___8;
        }
      } else {
        _L___8: /* CIL Label */ ;
      }
    }
  }
  if (! r->content_languages) {
    if (conf->default_language) {
      if (! r->content_languages) {
        r->content_languages = apr_array_make(r->pool, 2, (int )sizeof(char *));
      }
      new = (char const   **)apr_array_push(r->content_languages);
      (*new) = (char const   *)conf->default_language;
    } else {
      goto _L___9;
    }
  } else {
    _L___9: /* CIL Label */ ;
  }
  if (! r->content_type) {
    return (-1);
  }
  return (0);
}
}
static void register_hooks___6(apr_pool_t *p ) 
{ 

  {
  ap_hook_post_config(& mime_post_config, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                      10);
  ap_hook_type_checker(& find_ct, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                       10);
  return;
}
}
struct module_struct mime_module  = 
     {20020903, 0, -1, "mod_mime.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, (void (*)(process_rec *process ))((void *)0), & create_mime_dir_config,
    & merge_mime_dir_configs, (void *(*)(apr_pool_t *p , server_rec *s ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), mime_cmds,
    & register_hooks___6};
#pragma merger(0,"/tmp/cil-NqP2YoGU.i","-g -pthread")
extern long atol(char const   *__nptr )  __attribute__((__pure__)) ;
char const   *ap_get_server_built(void) ;
void ap_hook_handler(ap_HOOK_handler_t *pf , char const   * const  *aszPre___1 , char const   * const  *aszSucc___2 ,
                     int nOrder ) ;
int ap_rputc(int c , request_rec *r ) ;
int ( /* format attribute */  ap_rprintf)(request_rec *r , char const   *fmt  , ...) ;
apr_status_t ap_mpm_query(int query_code , int *result ) ;
int ap_exists_scoreboard_image(void) ;
worker_score *ap_get_scoreboard_worker(int x , int y ) ;
process_score *ap_get_scoreboard_process(int x ) ;
scoreboard *ap_scoreboard_image ;
int volatile   ap_my_generation ;
extern long sysconf(int __name )  __attribute__((__const__)) ;
int server_limit  ;
int thread_limit  ;
static char const   *set_extended_status(cmd_parms *cmd , void *dummy , int arg ) 
{ char const   *err ;
  char const   *tmp ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  ap_extended_status = arg;
  return ((char const   *)((void *)0));
}
}
static command_rec const   status_module_cmds[2]  = {      {"ExtendedStatus", {& set_extended_status}, (void *)0, 128, 5, "\"On\" to enable extended status information, \"Off\" to disable"}, 
        {(char const   *)((void *)0),
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))0}, (void *)0,
      0, 0, (char const   *)0}};
static void format_byte_out(request_rec *r , apr_off_t bytes ) 
{ 

  {
  if (bytes < 5120L) {
    ap_rprintf(r, "%d B", (int )bytes);
  } else {
    if (bytes < 524288L) {
      ap_rprintf(r, "%.1f kB", (float )bytes / (float )1024);
    } else {
      if (bytes < 536870912L) {
        ap_rprintf(r, "%.1f MB", (float )bytes / (float )1048576L);
      } else {
        ap_rprintf(r, "%.1f GB", (float )bytes / (float )1073741824L);
      }
    }
  }
  return;
}
}
static void format_kbyte_out(request_rec *r , apr_off_t kbytes ) 
{ 

  {
  if (kbytes < 1024L) {
    ap_rprintf(r, "%d kB", (int )kbytes);
  } else {
    if (kbytes < 1048576L) {
      ap_rprintf(r, "%.1f MB", (float )kbytes / (float )1024);
    } else {
      ap_rprintf(r, "%.1f GB", (float )kbytes / (float )1048576L);
    }
  }
  return;
}
}
static void show_time(request_rec *r , apr_interval_time_t tsecs ) 
{ int days ;
  int hrs ;
  int mins ;
  int secs ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  secs = (int )(tsecs % 60LL);
  tsecs /= 60LL;
  mins = (int )(tsecs % 60LL);
  tsecs /= 60LL;
  hrs = (int )(tsecs % 24LL);
  days = (int )(tsecs / 24LL);
  if (days) {
    if (days == 1) {
      tmp = "";
    } else {
      tmp = "s";
    }
    ap_rprintf(r, " %d day%s", days, tmp);
  }
  if (hrs) {
    if (hrs == 1) {
      tmp___0 = "";
    } else {
      tmp___0 = "s";
    }
    ap_rprintf(r, " %d hour%s", hrs, tmp___0);
  }
  if (mins) {
    if (mins == 1) {
      tmp___1 = "";
    } else {
      tmp___1 = "s";
    }
    ap_rprintf(r, " %d minute%s", mins, tmp___1);
  }
  if (secs) {
    if (secs == 1) {
      tmp___2 = "";
    } else {
      tmp___2 = "s";
    }
    ap_rprintf(r, " %d second%s", secs, tmp___2);
  }
  return;
}
}
static struct stat_opt  const  status_options[4]  = {      {0, "refresh", "Refresh"}, 
        {1, "notable", (char const   *)((void *)0)}, 
        {2, "auto", (char const   *)((void *)0)}, 
        {-1, (char const   *)((void *)0), (char const   *)((void *)0)}};
static char status_flags[11]  ;
static int status_handler(request_rec *r ) 
{ char const   *loc ;
  apr_time_t nowtime ;
  apr_interval_time_t up_time ;
  int j ;
  int i ;
  int res ;
  int ready ;
  int busy ;
  unsigned long count ;
  unsigned long lres ;
  unsigned long my_lres ;
  unsigned long conn_lres ;
  apr_off_t bytes ;
  apr_off_t my_bytes ;
  apr_off_t conn_bytes ;
  apr_off_t bcount ;
  apr_off_t kbcount ;
  long req_time ;
  float tick ;
  int short_report ;
  int no_table_report ;
  worker_score *ws_record ;
  process_score *ps_record ;
  char *stat_buffer ;
  pid_t *pid_buffer ;
  clock_t tu ;
  clock_t ts ;
  clock_t tcu ;
  clock_t tcs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  long tmp___5 ;
  int indx ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int indx___0 ;
  int j___0 ;
  int k ;
  int indx___1 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;

  {
  tmp = strcmp(r->handler, "application/x-httpd-status");
  if (tmp) {
    tmp___0 = strcmp(r->handler, "server-status");
    if (tmp___0) {
      return (-1);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  tick = (float )sysconf(2);
  ready = 0;
  busy = 0;
  count = 0UL;
  bcount = 0L;
  kbcount = 0L;
  short_report = 0;
  no_table_report = 0;
  pid_buffer = (pid_t *)apr_palloc(r->pool, (unsigned int )server_limit * sizeof(pid_t ));
  stat_buffer = (char *)apr_palloc(r->pool, (unsigned int )(server_limit * thread_limit) *
                                            sizeof(char ));
  nowtime = apr_time_now();
  tcs = 0L;
  tcu = tcs;
  ts = tcu;
  tu = ts;
  tmp___1 = ap_exists_scoreboard_image();
  if (! tmp___1) {
    ap_log_rerror("mod_status.c", 289, 3, 0, (request_rec const   *)r, "Server status unavailable in inetd mode");
    return (500);
  }
  r->allowed = 1LL;
  if (r->method_number != 0) {
    return (-1);
  }
  ap_set_content_type(r, "text/html");
  if (r->args) {
    i = 0;
    while (status_options[i].id != -1) {
      loc = strstr((char const   *)r->args, status_options[i].form_data_str);
      if ((unsigned int )loc != (unsigned int )((void *)0)) {
        switch (status_options[i].id) {
        case 0: 
        tmp___3 = strlen(status_options[i].form_data_str);
        if ((int const   )(*(loc + tmp___3)) == 61) {
          tmp___4 = strlen(status_options[i].form_data_str);
          tmp___5 = atol((loc + tmp___4) + 1);
          if (tmp___5 > 0L) {
            tmp___2 = strlen(status_options[i].hdr_out_str);
            apr_table_set(r->headers_out, status_options[i].hdr_out_str, (loc + tmp___2) +
                                                                         1);
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          apr_table_set(r->headers_out, status_options[i].hdr_out_str, "1");
        }
        break;
        case 1: 
        no_table_report = 1;
        break;
        case 2: 
        ap_set_content_type(r, "text/plain");
        short_report = 1;
        break;
        }
      }
      i ++;
    }
  }
  i = 0;
  while (i < server_limit) {
    ps_record = ap_get_scoreboard_process(i);
    j = 0;
    while (j < thread_limit) {
      indx = i * thread_limit + j;
      ws_record = ap_get_scoreboard_worker(i, j);
      res = (int )ws_record->status;
      (*(stat_buffer + indx)) = status_flags[res];
      if (! ps_record->quiescing) {
        if (ps_record->pid) {
          if (res == 2) {
            if (ps_record->generation == (ap_generation_t )ap_my_generation) {
              ready ++;
            } else {
              goto _L___3;
            }
          } else {
            _L___3: /* CIL Label */ 
            if (res != 0) {
              if (res != 1) {
                if (res != 10) {
                  busy ++;
                } else {
                  goto _L___2;
                }
              } else {
                goto _L___2;
              }
            } else {
              _L___2: /* CIL Label */ ;
            }
          }
        } else {
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ ;
      }
      if (ap_extended_status) {
        lres = ws_record->access_count;
        bytes = ws_record->bytes_served;
        if (lres != 0UL) {
          goto _L___5;
        } else {
          if (res != 2) {
            if (res != 0) {
              _L___5: /* CIL Label */ 
              tu += ws_record->times.tms_utime;
              ts += ws_record->times.tms_stime;
              tcu += ws_record->times.tms_cutime;
              tcs += ws_record->times.tms_cstime;
              count += lres;
              bcount += bytes;
              if (bcount >= 1024L) {
                kbcount += bcount >> 10;
                bcount = bcount & 1023L;
              }
            } else {
              goto _L___6;
            }
          } else {
            _L___6: /* CIL Label */ ;
          }
        }
      }
      j ++;
    }
    (*(pid_buffer + i)) = ps_record->pid;
    i ++;
  }
  up_time = (long long )((unsigned int )((nowtime - (ap_scoreboard_image->global)->restart_time) /
                                         1000000LL));
  if (! short_report) {
    ap_rputs("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n<html><head>\n<title>Apache Status</title>\n</head><body>\n",
             r);
    ap_rputs("<h1>Apache Server Status for ", r);
    tmp___6 = ap_get_server_name(r);
    ap_rvputs(r, tmp___6, "</h1>\n\n", (void *)0);
    tmp___7 = ap_get_server_version();
    ap_rvputs(r, "<dl><dt>Server Version: ", tmp___7, "</dt>\n", (void *)0);
    tmp___8 = ap_get_server_built();
    ap_rvputs(r, "<dt>Server Built: ", tmp___8, "\n</dt></dl><hr /><dl>\n", (void *)0);
    tmp___9 = ap_ht_time(r->pool, nowtime, "%A, %d-%b-%Y %H:%M:%S %Z", 0);
    ap_rvputs(r, "<dt>Current Time: ", tmp___9, "</dt>\n", (void *)0);
    tmp___10 = ap_ht_time(r->pool, (ap_scoreboard_image->global)->restart_time, "%A, %d-%b-%Y %H:%M:%S %Z",
                          0);
    ap_rvputs(r, "<dt>Restart Time: ", tmp___10, "</dt>\n", (void *)0);
    ap_rprintf(r, "<dt>Parent Server Generation: %d</dt>\n", ap_my_generation);
    ap_rputs("<dt>Server uptime: ", r);
    show_time(r, up_time);
    ap_rputs("</dt>\n", r);
  }
  if (ap_extended_status) {
    if (short_report) {
      ap_rprintf(r, "Total Accesses: %lu\nTotal kBytes: %ld\n", count, kbcount);
      if (ts) {
        goto _L___9;
      } else {
        if (tu) {
          _L___9: /* CIL Label */ 
          goto _L___8;
        } else {
          if (tcu) {
            _L___8: /* CIL Label */ 
            goto _L___7;
          } else {
            if (tcs) {
              _L___7: /* CIL Label */ 
              ap_rprintf(r, "CPULoad: %g\n", (double )(((float )(((tu + ts) + tcu) +
                                                                 tcs) / tick) / (float )up_time) *
                                             100.);
            }
          }
        }
      }
      ap_rprintf(r, "Uptime: %ld\n", (long )up_time);
      if (up_time > 0LL) {
        ap_rprintf(r, "ReqPerSec: %g\n", (float )count / (float )up_time);
      }
      if (up_time > 0LL) {
        ap_rprintf(r, "BytesPerSec: %g\n", ((float )1024 * (float )kbcount) / (float )up_time);
      }
      if (count > 0UL) {
        ap_rprintf(r, "BytesPerReq: %g\n", ((float )1024 * (float )kbcount) / (float )count);
      }
    } else {
      ap_rprintf(r, "<dt>Total accesses: %lu - Total Traffic: ", count);
      format_kbyte_out(r, kbcount);
      ap_rputs("</dt>\n", r);
      ap_rprintf(r, "<dt>CPU Usage: u%g s%g cu%g cs%g", (float )tu / tick, (float )ts /
                                                                           tick, (float )tcu /
                                                                                 tick,
                 (float )tcs / tick);
      if (ts) {
        goto _L___12;
      } else {
        if (tu) {
          _L___12: /* CIL Label */ 
          goto _L___11;
        } else {
          if (tcu) {
            _L___11: /* CIL Label */ 
            goto _L___10;
          } else {
            if (tcs) {
              _L___10: /* CIL Label */ 
              ap_rprintf(r, " - %.3g%% CPU load</dt>\n", (double )(((float )(((tu +
                                                                               ts) +
                                                                              tcu) +
                                                                             tcs) /
                                                                    tick) / (float )up_time) *
                                                         100.);
            }
          }
        }
      }
      if (up_time > 0LL) {
        ap_rprintf(r, "<dt>%.3g requests/sec - ", (float )count / (float )up_time);
      }
      if (up_time > 0LL) {
        format_byte_out(r, (long )((unsigned long )(((float )1024 * (float )kbcount) /
                                                    (float )up_time)));
        ap_rputs("/second - ", r);
      }
      if (count > 0UL) {
        format_byte_out(r, (long )((unsigned long )(((float )1024 * (float )kbcount) /
                                                    (float )count)));
        ap_rputs("/request", r);
      }
      ap_rputs("</dt>\n", r);
    }
  }
  if (! short_report) {
    ap_rprintf(r, "<dt>%d requests currently being processed, %d idle workers</dt>\n",
               busy, ready);
  } else {
    ap_rprintf(r, "BusyWorkers: %d\nIdleWorkers: %d\n", busy, ready);
  }
  if (! short_report) {
    ap_rputs("</dl><pre>", r);
  } else {
    ap_rputs("Scoreboard: ", r);
  }
  i = 0;
  while (i < server_limit) {
    j = 0;
    while (j < thread_limit) {
      indx___0 = i * thread_limit + j;
      ap_rputc((int )(*(stat_buffer + indx___0)), r);
      if (indx___0 % 64 == 63) {
        if (! short_report) {
          ap_rputs("\n", r);
        } else {
          goto _L___13;
        }
      } else {
        _L___13: /* CIL Label */ ;
      }
      j ++;
    }
    i ++;
  }
  if (short_report) {
    ap_rputs("\n", r);
  } else {
    ap_rputs("</pre>\n", r);
    ap_rputs("<p>Scoreboard Key:<br />\n", r);
    ap_rputs("\"<b><code>_</code></b>\" Waiting for Connection, \n", r);
    ap_rputs("\"<b><code>S</code></b>\" Starting up, \n", r);
    ap_rputs("\"<b><code>R</code></b>\" Reading Request,<br />\n", r);
    ap_rputs("\"<b><code>W</code></b>\" Sending Reply, \n", r);
    ap_rputs("\"<b><code>K</code></b>\" Keepalive (read), \n", r);
    ap_rputs("\"<b><code>D</code></b>\" DNS Lookup,<br />\n", r);
    ap_rputs("\"<b><code>C</code></b>\" Closing connection, \n", r);
    ap_rputs("\"<b><code>L</code></b>\" Logging, \n", r);
    ap_rputs("\"<b><code>G</code></b>\" Gracefully finishing,<br /> \n", r);
    ap_rputs("\"<b><code>I</code></b>\" Idle cleanup of worker, \n", r);
    ap_rputs("\"<b><code>.</code></b>\" Open slot with no current process</p>\n",
             r);
    ap_rputs("<p />\n", r);
    if (! ap_extended_status) {
      k = 0;
      ap_rputs("PID Key: <br />\n", r);
      ap_rputs("<pre>\n", r);
      i = 0;
      while (i < server_limit) {
        j___0 = 0;
        while (j___0 < thread_limit) {
          indx___1 = i * thread_limit + j___0;
          if ((int )(*(stat_buffer + indx___1)) != 46) {
            ap_rprintf(r, "   %d in state: %c ", (*(pid_buffer + i)), (*(stat_buffer +
                                                                         indx___1)));
            k ++;
            if (k >= 3) {
              ap_rputs("\n", r);
              k = 0;
            } else {
              ap_rputs(",", r);
            }
          }
          j___0 ++;
        }
        i ++;
      }
      ap_rputs("\n", r);
      ap_rputs("</pre>\n", r);
    }
  }
  if (ap_extended_status) {
    if (! short_report) {
      if (no_table_report) {
        ap_rputs("<hr /><h2>Server Details</h2>\n\n", r);
      } else {
        ap_rputs("\n\n<table border=\"0\"><tr><th>Srv</th><th>PID</th><th>Acc</th><th>M</th><th>CPU\n</th><th>SS</th><th>Req</th><th>Conn</th><th>Child</th><th>Slot</th><th>Client</th><th>VHost</th><th>Request</th></tr>\n\n",
                 r);
      }
      i = 0;
      while (i < server_limit) {
        j = 0;
        while (j < thread_limit) {
          ws_record = ap_get_scoreboard_worker(i, j);
          if (ws_record->access_count == 0UL) {
            if ((int )ws_record->status == 2) {
              goto _L___15;
            } else {
              if ((int )ws_record->status == 0) {
                _L___15: /* CIL Label */ 
                goto __Cont;
              } else {
                goto _L___14;
              }
            }
          } else {
            _L___14: /* CIL Label */ ;
          }
          ps_record = ap_get_scoreboard_process(i);
          if (ws_record->start_time == 0LL) {
            req_time = 0L;
          } else {
            req_time = (long )((ws_record->stop_time - ws_record->start_time) / 1000LL);
          }
          if (req_time < 0L) {
            req_time = 0L;
          }
          lres = ws_record->access_count;
          my_lres = ws_record->my_access_count;
          conn_lres = (unsigned long )ws_record->conn_count;
          bytes = ws_record->bytes_served;
          my_bytes = ws_record->my_bytes_served;
          conn_bytes = ws_record->conn_bytes;
          if (no_table_report) {
            if ((int )ws_record->status == 0) {
              ap_rprintf(r, "<b>Server %d-%d</b> (-): %d|%lu|%lu [", i, ps_record->generation,
                         (int )conn_lres, my_lres, lres);
            } else {
              ap_rprintf(r, "<b>Server %d-%d</b> (%d): %d|%lu|%lu [", i, ps_record->generation,
                         ps_record->pid, (int )conn_lres, my_lres, lres);
            }
            switch ((int )ws_record->status) {
            case 2: 
            ap_rputs("Ready", r);
            break;
            case 1: 
            ap_rputs("Starting", r);
            break;
            case 3: 
            ap_rputs("<b>Read</b>", r);
            break;
            case 4: 
            ap_rputs("<b>Write</b>", r);
            break;
            case 5: 
            ap_rputs("<b>Keepalive</b>", r);
            break;
            case 6: 
            ap_rputs("<b>Logging</b>", r);
            break;
            case 7: 
            ap_rputs("<b>DNS lookup</b>", r);
            break;
            case 8: 
            ap_rputs("<b>Closing</b>", r);
            break;
            case 0: 
            ap_rputs("Dead", r);
            break;
            case 9: 
            ap_rputs("Graceful", r);
            break;
            case 10: 
            ap_rputs("Dying", r);
            break;
            default: 
            ap_rputs("?STATE?", r);
            break;
            }
            ap_rprintf(r, "] u%g s%g cu%g cs%g\n %ld %ld (", (float )ws_record->times.tms_utime /
                                                             tick, (float )ws_record->times.tms_stime /
                                                                   tick, (float )ws_record->times.tms_cutime /
                                                                         tick, (float )ws_record->times.tms_cstime /
                                                                               tick,
                       (long )((nowtime - ws_record->last_used) / 1000000LL), req_time);
            format_byte_out(r, conn_bytes);
            ap_rputs("|", r);
            format_byte_out(r, my_bytes);
            ap_rputs("|", r);
            format_byte_out(r, bytes);
            ap_rputs(")\n", r);
            tmp___11 = ap_escape_html(r->pool, (char const   *)(ws_record->vhost));
            tmp___12 = ap_escape_html(r->pool, (char const   *)(ws_record->request));
            tmp___13 = ap_escape_html(r->pool, (char const   *)(ws_record->client));
            ap_rprintf(r, " <i>%s {%s}</i> <b>[%s]</b><br />\n\n", tmp___13, tmp___12,
                       tmp___11);
          } else {
            if ((int )ws_record->status == 0) {
              ap_rprintf(r, "<tr><td><b>%d-%d</b></td><td>-</td><td>%d/%lu/%lu", i,
                         ps_record->generation, (int )conn_lres, my_lres, lres);
            } else {
              ap_rprintf(r, "<tr><td><b>%d-%d</b></td><td>%d</td><td>%d/%lu/%lu",
                         i, ps_record->generation, ps_record->pid, (int )conn_lres,
                         my_lres, lres);
            }
            switch ((int )ws_record->status) {
            case 2: 
            ap_rputs("</td><td>_", r);
            break;
            case 1: 
            ap_rputs("</td><td><b>S</b>", r);
            break;
            case 3: 
            ap_rputs("</td><td><b>R</b>", r);
            break;
            case 4: 
            ap_rputs("</td><td><b>W</b>", r);
            break;
            case 5: 
            ap_rputs("</td><td><b>K</b>", r);
            break;
            case 6: 
            ap_rputs("</td><td><b>L</b>", r);
            break;
            case 7: 
            ap_rputs("</td><td><b>D</b>", r);
            break;
            case 8: 
            ap_rputs("</td><td><b>C</b>", r);
            break;
            case 0: 
            ap_rputs("</td><td>.", r);
            break;
            case 9: 
            ap_rputs("</td><td>G", r);
            break;
            case 10: 
            ap_rputs("</td><td>I", r);
            break;
            default: 
            ap_rputs("</td><td>?", r);
            break;
            }
            ap_rprintf(r, "\n</td><td>%.2f</td><td>%ld</td><td>%ld", (float )(((ws_record->times.tms_utime +
                                                                                ws_record->times.tms_stime) +
                                                                               ws_record->times.tms_cutime) +
                                                                              ws_record->times.tms_cstime) /
                                                                     tick, (long )((nowtime -
                                                                                    ws_record->last_used) /
                                                                                   1000000LL),
                       req_time);
            ap_rprintf(r, "</td><td>%-1.1f</td><td>%-2.2f</td><td>%-2.2f\n", (float )conn_bytes /
                                                                             (float )1024,
                       (float )my_bytes / (float )1048576L, (float )bytes / (float )1048576L);
            if ((int )ws_record->status == 3) {
              ap_rprintf(r, "</td><td>?</td><td nowrap>?</td><td nowrap>..reading.. </td></tr>\n\n");
            } else {
              tmp___14 = ap_escape_html(r->pool, (char const   *)(ws_record->request));
              tmp___15 = ap_escape_html(r->pool, (char const   *)(ws_record->vhost));
              tmp___16 = ap_escape_html(r->pool, (char const   *)(ws_record->client));
              ap_rprintf(r, "</td><td>%s</td><td nowrap>%s</td><td nowrap>%s</td></tr>\n\n",
                         tmp___16, tmp___15, tmp___14);
            }
          }
          __Cont: /* CIL Label */ 
          j ++;
        }
        i ++;
      }
      if (! no_table_report) {
        ap_rputs("</table>\n <hr /> <table>\n <tr><th>Srv</th><td>Child Server number - generation</td></tr>\n <tr><th>PID</th><td>OS process ID</td></tr>\n <tr><th>Acc</th><td>Number of accesses this connection / this child / this slot</td></tr>\n <tr><th>M</th><td>Mode of operation</td></tr>\n<tr><th>CPU</th><td>CPU usage, number of seconds</td></tr>\n<tr><th>SS</th><td>Seconds since beginning of most recent request</td></tr>\n <tr><th>Req</th><td>Milliseconds required to process most recent request</td></tr>\n <tr><th>Conn</th><td>Kilobytes transferred this connection</td></tr>\n <tr><th>Child</th><td>Megabytes transferred this child</td></tr>\n <tr><th>Slot</th><td>Total megabytes transferred this slot</td></tr>\n </table>\n",
                 r);
      }
    } else {
      goto _L___16;
    }
  } else {
    _L___16: /* CIL Label */ 
    if (! short_report) {
      ap_rputs("<hr />To obtain a full report with current status information you need to use the <code>ExtendedStatus On</code> directive.\n",
               r);
    }
  }
  if (! short_report) {
    tmp___17 = ap_psignature("<hr />\n", r);
    ap_rputs(tmp___17, r);
    ap_rputs("</body></html>\n", r);
  }
  return (0);
}
}
static int status_init(apr_pool_t *p , apr_pool_t *plog , apr_pool_t *ptemp , server_rec *s ) 
{ 

  {
  status_flags[0] = (char )'.';
  status_flags[2] = (char )'_';
  status_flags[1] = (char )'S';
  status_flags[3] = (char )'R';
  status_flags[4] = (char )'W';
  status_flags[5] = (char )'K';
  status_flags[6] = (char )'L';
  status_flags[7] = (char )'D';
  status_flags[8] = (char )'C';
  status_flags[9] = (char )'G';
  status_flags[10] = (char )'I';
  ap_mpm_query(5, & thread_limit);
  ap_mpm_query(4, & server_limit);
  return (0);
}
}
static void register_hooks___7(apr_pool_t *p ) 
{ 

  {
  ap_hook_handler(& status_handler, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                  10);
  ap_hook_post_config(& status_init, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                      10);
  return;
}
}
struct module_struct status_module  = 
     {20020903, 0, -1, "mod_status.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, (void (*)(process_rec *process ))((void *)0), (void *(*)(apr_pool_t *p ,
                                                                           char *dir ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), (void *(*)(apr_pool_t *p ,
                                                                                          server_rec *s ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), status_module_cmds,
    & register_hooks___7};
#pragma merger(0,"/tmp/cil-ubdJ25bb.i","-g -pthread")
extern char *strcpy(char * __restrict  __dest , char const   * __restrict  __src ) ;
int apr_strnatcmp(char const   *a , char const   *b ) ;
int apr_strnatcasecmp(char const   *a , char const   *b ) ;
char *apr_pstrndup(apr_pool_t *a , char const   *s , apr_size_t n ) ;
char *apr_cpystrn(char *dst , char const   *src , apr_size_t dst_size ) ;
apr_status_t apr_fnmatch(char const   *pattern , char const   *string , int flags ) ;
int apr_fnmatch_test(char const   *pattern ) ;
extern int toupper(int __c ) ;
apr_status_t apr_time_exp_lt(apr_time_exp_t *result , apr_time_t input ) ;
apr_status_t apr_dir_open(apr_dir_t **new , char const   *dirname , apr_pool_t *pool ) ;
apr_status_t apr_dir_close(apr_dir_t *thedir ) ;
apr_status_t apr_dir_read(apr_finfo_t *finfo , apr_int32_t wanted , apr_dir_t *thedir ) ;
apr_status_t apr_file_close(apr_file_t *file ) ;
apr_status_t apr_file_eof(apr_file_t *fptr ) ;
apr_status_t apr_file_read(apr_file_t *thefile , void *buf , apr_size_t *nbytes ) ;
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) ) ;
char *ap_getword_nc(apr_pool_t *atrans , char **line , char stop ) ;
char *ap_make_full_path(apr_pool_t *a , char const   *src1 , char const   *src2 ) ;
int ap_is_matchexp(char const   *str ) ;
int ap_strcmp_match(char const   *str , char const   *exp ) ;
int ap_strcasecmp_match(char const   *str , char const   *exp ) ;
int ap_ind(char const   *s , char c ) ;
char const   *ap_set_deprecated(cmd_parms *cmd , void *struct_ptr , char const   *arg ) ;
request_rec *ap_sub_req_lookup_dirent(apr_finfo_t const   *dirent , request_rec const   *r ,
                                      int subtype , ap_filter_t *next_filter ) ;
static char c_by_encoding  ;
static char c_by_type  ;
static char c_by_path  ;
static void emit_preamble(request_rec *r , char *title ) 
{ 

  {
  ap_rvputs(r, "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n", "<html>\n <head>\n  <title>Index of ",
            title, "</title>\n </head>\n <body>\n", (void *)0);
  return;
}
}
static void push_item(apr_array_header_t *arr , char *type , char const   *to , char const   *path ,
                      char const   *data ) 
{ struct item *p ;
  struct item *tmp ;
  int tmp___1 ;

  {
  tmp = (struct item *)apr_array_push(arr);
  p = tmp;
  if (! to) {
    to = "";
  }
  if (! path) {
    path = "";
  }
  p->type = type;
  if (data) {
    p->data = apr_pstrdup(arr->pool, data);
  } else {
    p->data = (char *)((void *)0);
  }
  p->apply_path = apr_pstrcat(arr->pool, path, "*", (void *)0);
  if ((unsigned int )type == (unsigned int )(& c_by_path)) {
    tmp___1 = ap_is_matchexp(to);
    if (tmp___1) {
      goto _L;
    } else {
      p->apply_to = apr_pstrcat(arr->pool, "*", to, (void *)0);
    }
  } else {
    _L: /* CIL Label */ 
    if (to) {
      p->apply_to = apr_pstrdup(arr->pool, to);
    } else {
      p->apply_to = (char *)((void *)0);
    }
  }
  return;
}
}
static char const   *add_alt(cmd_parms *cmd , void *d , char const   *alt , char const   *to ) 
{ int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  if ((unsigned int )cmd->info == (unsigned int )(& c_by_path)) {
    tmp = strcmp(to, "**DIRECTORY**");
    if (! tmp) {
      to = "^^DIRECTORY^^";
    }
  }
  if ((unsigned int )cmd->info == (unsigned int )(& c_by_encoding)) {
    tmp___1 = apr_pstrdup(cmd->pool, to);
    tmp___0 = tmp___1;
    ap_str_tolower(tmp___0);
    to = (char const   *)tmp___0;
  }
  push_item(((autoindex_config_rec *)d)->alt_list, (char *)cmd->info, to, (char const   *)cmd->path,
            alt);
  return ((char const   *)((void *)0));
}
}
static char const   *add_icon(cmd_parms *cmd , void *d , char const   *icon , char const   *to ) 
{ char *iconbak ;
  char *tmp ;
  char *alt ;
  char *cl ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  tmp = apr_pstrdup(cmd->pool, icon);
  iconbak = tmp;
  if ((int const   )(*(icon + 0)) == 40) {
    tmp___0 = strchr((char const   *)iconbak, ')');
    cl = tmp___0;
    if ((unsigned int )cl == (unsigned int )((void *)0)) {
      return ("missing closing paren");
    }
    alt = ap_getword_nc(cmd->pool, & iconbak, (char )',');
    (*cl) = (char )'\000';
    add_alt(cmd, d, (char const   *)(alt + 1), to);
  }
  if ((unsigned int )cmd->info == (unsigned int )(& c_by_path)) {
    tmp___1 = strcmp(to, "**DIRECTORY**");
    if (! tmp___1) {
      to = "^^DIRECTORY^^";
    }
  }
  if ((unsigned int )cmd->info == (unsigned int )(& c_by_encoding)) {
    tmp___3 = apr_pstrdup(cmd->pool, to);
    tmp___2 = tmp___3;
    ap_str_tolower(tmp___2);
    to = (char const   *)tmp___2;
  }
  push_item(((autoindex_config_rec *)d)->icon_list, (char *)cmd->info, to, (char const   *)cmd->path,
            (char const   *)iconbak);
  return ((char const   *)((void *)0));
}
}
static char const   *add_desc(cmd_parms *cmd , void *d , char const   *desc , char const   *to ) 
{ autoindex_config_rec *dcfg ;
  ai_desc_t *desc_entry ;
  char *prefix ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  dcfg = (autoindex_config_rec *)d;
  prefix = (char *)"";
  desc_entry = (ai_desc_t *)apr_array_push(dcfg->desc_list);
  tmp___1 = strchr(to, '/');
  if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
    desc_entry->full_path = 0;
  } else {
    desc_entry->full_path = 1;
  }
  if (desc_entry->full_path) {
    goto _L;
  } else {
    tmp___2 = apr_fnmatch_test(to);
    if (tmp___2) {
      _L: /* CIL Label */ 
      tmp___3 = 1;
    } else {
      tmp___3 = 0;
    }
  }
  desc_entry->wildcards = tmp___3;
  if (desc_entry->wildcards) {
    if (desc_entry->full_path) {
      prefix = (char *)"*/";
    } else {
      prefix = (char *)"*";
    }
    desc_entry->pattern = apr_pstrcat((dcfg->desc_list)->pool, prefix, to, "*", (void *)0);
  } else {
    desc_entry->pattern = apr_pstrdup((dcfg->desc_list)->pool, to);
  }
  desc_entry->description = apr_pstrdup((dcfg->desc_list)->pool, desc);
  return ((char const   *)((void *)0));
}
}
static char const   *add_ignore(cmd_parms *cmd , void *d , char const   *ext ) 
{ 

  {
  push_item(((autoindex_config_rec *)d)->ign_list, (char *)0, ext, (char const   *)cmd->path,
            (char const   *)((void *)0));
  return ((char const   *)((void *)0));
}
}
static char const   *add_header(cmd_parms *cmd , void *d , char const   *name ) 
{ 

  {
  push_item(((autoindex_config_rec *)d)->hdr_list, (char *)0, (char const   *)((void *)0),
            (char const   *)cmd->path, name);
  return ((char const   *)((void *)0));
}
}
static char const   *add_readme(cmd_parms *cmd , void *d , char const   *name ) 
{ 

  {
  push_item(((autoindex_config_rec *)d)->rdme_list, (char *)0, (char const   *)((void *)0),
            (char const   *)cmd->path, name);
  return ((char const   *)((void *)0));
}
}
static char const   *add_opts(cmd_parms *cmd , void *d , char const   *optstr ) 
{ char *w ;
  apr_int32_t opts ;
  apr_int32_t opts_add ;
  apr_int32_t opts_remove ;
  char action ;
  autoindex_config_rec *d_cfg ;
  int option ;
  char *tmp ;
  int width ;
  int tmp___0 ;
  int width___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;

  {
  d_cfg = (autoindex_config_rec *)d;
  opts = d_cfg->opts;
  opts_add = d_cfg->incremented_opts;
  opts_remove = d_cfg->decremented_opts;
  while ((*(optstr + 0))) {
    option = 0;
    w = ap_getword_conf(cmd->pool, & optstr);
    if ((int )(*w) == 43) {
      goto _L;
    } else {
      if ((int )(*w) == 45) {
        _L: /* CIL Label */ 
        tmp = w;
        w ++;
        action = (*tmp);
      } else {
        action = (char )'\000';
      }
    }
    tmp___26 = strcasecmp((char const   *)w, "FancyIndexing");
    if (tmp___26) {
      tmp___25 = strcasecmp((char const   *)w, "FoldersFirst");
      if (tmp___25) {
        tmp___24 = strcasecmp((char const   *)w, "HTMLTable");
        if (tmp___24) {
          tmp___23 = strcasecmp((char const   *)w, "IconsAreLinks");
          if (tmp___23) {
            tmp___22 = strcasecmp((char const   *)w, "IgnoreCase");
            if (tmp___22) {
              tmp___21 = strcasecmp((char const   *)w, "IgnoreClient");
              if (tmp___21) {
                tmp___20 = strcasecmp((char const   *)w, "ScanHTMLTitles");
                if (tmp___20) {
                  tmp___19 = strcasecmp((char const   *)w, "SuppressColumnSorting");
                  if (tmp___19) {
                    tmp___18 = strcasecmp((char const   *)w, "SuppressDescription");
                    if (tmp___18) {
                      tmp___17 = strcasecmp((char const   *)w, "SuppressHTMLPreamble");
                      if (tmp___17) {
                        tmp___16 = strcasecmp((char const   *)w, "SuppressIcon");
                        if (tmp___16) {
                          tmp___15 = strcasecmp((char const   *)w, "SuppressLastModified");
                          if (tmp___15) {
                            tmp___14 = strcasecmp((char const   *)w, "SuppressSize");
                            if (tmp___14) {
                              tmp___13 = strcasecmp((char const   *)w, "SuppressRules");
                              if (tmp___13) {
                                tmp___12 = strcasecmp((char const   *)w, "TrackModified");
                                if (tmp___12) {
                                  tmp___11 = strcasecmp((char const   *)w, "VersionSort");
                                  if (tmp___11) {
                                    tmp___10 = strcasecmp((char const   *)w, "None");
                                    if (tmp___10) {
                                      tmp___9 = strcasecmp((char const   *)w, "IconWidth");
                                      if (tmp___9) {
                                        tmp___8 = strncasecmp((char const   *)w, "IconWidth=",
                                                              10U);
                                        if (tmp___8) {
                                          tmp___7 = strcasecmp((char const   *)w,
                                                               "IconHeight");
                                          if (tmp___7) {
                                            tmp___6 = strncasecmp((char const   *)w,
                                                                  "IconHeight=", 11U);
                                            if (tmp___6) {
                                              tmp___5 = strcasecmp((char const   *)w,
                                                                   "NameWidth");
                                              if (tmp___5) {
                                                tmp___4 = strncasecmp((char const   *)w,
                                                                      "NameWidth=",
                                                                      10U);
                                                if (tmp___4) {
                                                  tmp___3 = strcasecmp((char const   *)w,
                                                                       "DescriptionWidth");
                                                  if (tmp___3) {
                                                    tmp___2 = strncasecmp((char const   *)w,
                                                                          "DescriptionWidth=",
                                                                          17U);
                                                    if (tmp___2) {
                                                      return ("Invalid directory indexing option");
                                                    } else {
                                                      if ((int )action == 45) {
                                                        return ("Cannot combine \'-\' with DescriptionWidth=n");
                                                      }
                                                      if ((int )(*(w + 17)) == 42) {
                                                        d_cfg->desc_adjust = 1;
                                                      } else {
                                                        tmp___1 = atoi((char const   *)(w +
                                                                                        17));
                                                        width___0 = tmp___1;
                                                        if (width___0) {
                                                          if (width___0 < 12) {
                                                            return ("DescriptionWidth value must be greater than 12");
                                                          } else {
                                                            goto _L___1;
                                                          }
                                                        } else {
                                                          _L___1: /* CIL Label */ ;
                                                        }
                                                        d_cfg->desc_width = width___0;
                                                        d_cfg->desc_adjust = 0;
                                                      }
                                                    }
                                                  } else {
                                                    if ((int )action != 45) {
                                                      return ("DescriptionWidth with no value may only appear as \'-DescriptionWidth\'");
                                                    }
                                                    d_cfg->desc_width = 23;
                                                    d_cfg->desc_adjust = 0;
                                                  }
                                                } else {
                                                  if ((int )action == 45) {
                                                    return ("Cannot combine \'-\' with NameWidth=n");
                                                  }
                                                  if ((int )(*(w + 10)) == 42) {
                                                    d_cfg->name_adjust = 1;
                                                  } else {
                                                    tmp___0 = atoi((char const   *)(w +
                                                                                    10));
                                                    width = tmp___0;
                                                    if (width) {
                                                      if (width < 5) {
                                                        return ("NameWidth value must be greater than 5");
                                                      } else {
                                                        goto _L___0;
                                                      }
                                                    } else {
                                                      _L___0: /* CIL Label */ ;
                                                    }
                                                    d_cfg->name_width = width;
                                                    d_cfg->name_adjust = 0;
                                                  }
                                                }
                                              } else {
                                                if ((int )action != 45) {
                                                  return ("NameWidth with no value may only appear as \'-NameWidth\'");
                                                }
                                                d_cfg->name_width = 23;
                                                d_cfg->name_adjust = 0;
                                              }
                                            } else {
                                              if ((int )action == 45) {
                                                return ("Cannot combine \'-\' with IconHeight=n");
                                              }
                                              d_cfg->icon_height = atoi((char const   *)(w +
                                                                                         11));
                                            }
                                          } else {
                                            if ((int )action != 45) {
                                              d_cfg->icon_height = 22;
                                            } else {
                                              d_cfg->icon_height = 0;
                                            }
                                          }
                                        } else {
                                          if ((int )action == 45) {
                                            return ("Cannot combine \'-\' with IconWidth=n");
                                          }
                                          d_cfg->icon_width = atoi((char const   *)(w +
                                                                                    10));
                                        }
                                      } else {
                                        if ((int )action != 45) {
                                          d_cfg->icon_width = 20;
                                        } else {
                                          d_cfg->icon_width = 0;
                                        }
                                      }
                                    } else {
                                      if ((int )action != 0) {
                                        return ("Cannot combine \'+\' or \'-\' with \'None\' keyword");
                                      }
                                      opts = 1;
                                      opts_add = 0;
                                      opts_remove = 0;
                                    }
                                  } else {
                                    option = 2048;
                                  }
                                } else {
                                  option = 4096;
                                }
                              } else {
                                option = 512;
                              }
                            } else {
                              option = 32;
                            }
                          } else {
                            option = 16;
                          }
                        } else {
                          option = 8;
                        }
                      } else {
                        option = 128;
                      }
                    } else {
                      option = 64;
                    }
                  } else {
                    option = 256;
                  }
                } else {
                  option = 4;
                }
              } else {
                option = 32768;
              }
            } else {
              option = 65536;
            }
          } else {
            option = 2;
          }
        } else {
          option = 16384;
        }
      } else {
        option = 1024;
      }
    } else {
      option = 8192;
    }
    if ((int )action == 0) {
      opts |= option;
      opts_add = 0;
      opts_remove = 0;
    } else {
      if ((int )action == 43) {
        opts_add |= option;
        opts_remove &= ~ option;
      } else {
        opts_remove |= option;
        opts_add &= ~ option;
      }
    }
  }
  if (opts & 1) {
    if (opts & -2) {
      return ("Cannot combine other IndexOptions keywords with \'None\'");
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ ;
  }
  d_cfg->incremented_opts = opts_add;
  d_cfg->decremented_opts = opts_remove;
  d_cfg->opts = opts;
  return ((char const   *)((void *)0));
}
}
static char const   *set_default_order(cmd_parms *cmd , void *m , char const   *direction ,
                                       char const   *key ) 
{ autoindex_config_rec *d_cfg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  d_cfg = (autoindex_config_rec *)m;
  tmp___0 = strcasecmp(direction, "Ascending");
  if (tmp___0) {
    tmp = strcasecmp(direction, "Descending");
    if (tmp) {
      return ("First keyword must be \'Ascending\' or \'Descending\'");
    } else {
      d_cfg->default_direction = (char )'D';
    }
  } else {
    d_cfg->default_direction = (char )'A';
  }
  tmp___4 = strcasecmp(key, "Name");
  if (tmp___4) {
    tmp___3 = strcasecmp(key, "Date");
    if (tmp___3) {
      tmp___2 = strcasecmp(key, "Size");
      if (tmp___2) {
        tmp___1 = strcasecmp(key, "Description");
        if (tmp___1) {
          return ("Second keyword must be \'Name\', \'Date\', \'Size\', or \'Description\'");
        } else {
          d_cfg->default_keyid = (char )'D';
        }
      } else {
        d_cfg->default_keyid = (char )'S';
      }
    } else {
      d_cfg->default_keyid = (char )'M';
    }
  } else {
    d_cfg->default_keyid = (char )'N';
  }
  return ((char const   *)((void *)0));
}
}
static command_rec const   autoindex_cmds[15]  = 
  {      {"AddIcon", {& add_icon}, (void *)(& c_by_path), 16, 4, "an icon URL followed by one or more filenames"}, 
        {"AddIconByType",
      {& add_icon}, (void *)(& c_by_type), 16, 4, "an icon URL followed by one or more MIME types"}, 
        {"AddIconByEncoding",
      {& add_icon}, (void *)(& c_by_encoding), 16, 4, "an icon URL followed by one or more content encodings"}, 
        {"AddAlt",
      {& add_alt}, (void *)(& c_by_path), 16, 4, "alternate descriptive text followed by one or more filenames"}, 
        {"AddAltByType",
      {& add_alt}, (void *)(& c_by_type), 16, 4, "alternate descriptive text followed by one or more MIME types"}, 
        {"AddAltByEncoding",
      {& add_alt}, (void *)(& c_by_encoding), 16, 4, "alternate descriptive text followed by one or more content encodings"}, 
        {"IndexOptions",
      {& add_opts}, (void *)0, 16, 0, "one or more index options [+|-][]"}, 
        {"IndexOrderDefault", {& set_default_order}, (void *)0, 16, 2, "{Ascending,Descending} {Name,Size,Description,Date}"}, 
        {"IndexIgnore",
      {& add_ignore}, (void *)0, 16, 3, "one or more file extensions"}, 
        {"AddDescription", {& add_desc}, (void *)(& c_by_path), 16, 4, "Descriptive text followed by one or more filenames"}, 
        {"HeaderName",
      {& add_header}, (void *)0, 16, 1, "a filename"}, 
        {"ReadmeName", {& add_readme}, (void *)0, 16, 1, "a filename"}, 
        {"FancyIndexing", {& ap_set_deprecated}, (void *)0, 31, 0, "The FancyIndexing directive is no longer supported.  Use IndexOptions FancyIndexing."}, 
        {"DefaultIcon",
      {& ap_set_string_slot}, (void *)((long )((char *)(& ((autoindex_config_rec *)((void *)0))->default_icon) -
                                               (char *)((void *)0))), 16, 1, "an icon URL"}, 
        {(char const   *)((void *)0),
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))0}, (void *)0,
      0, 0, (char const   *)0}};
static void *create_autoindex_config(apr_pool_t *p , char *dummy ) 
{ autoindex_config_rec *new ;
  void *tmp ;
  autoindex_config_rec *tmp___0 ;

  {
  tmp = apr_palloc(p, sizeof(autoindex_config_rec ));
  tmp___0 = (autoindex_config_rec *)memset(tmp, 0, sizeof(autoindex_config_rec ));
  new = tmp___0;
  new->icon_width = 0;
  new->icon_height = 0;
  new->name_width = 23;
  new->name_adjust = 2;
  new->desc_width = 23;
  new->desc_adjust = 2;
  new->icon_list = apr_array_make(p, 4, (int )sizeof(struct item ));
  new->alt_list = apr_array_make(p, 4, (int )sizeof(struct item ));
  new->desc_list = apr_array_make(p, 4, (int )sizeof(ai_desc_t ));
  new->ign_list = apr_array_make(p, 4, (int )sizeof(struct item ));
  new->hdr_list = apr_array_make(p, 4, (int )sizeof(struct item ));
  new->rdme_list = apr_array_make(p, 4, (int )sizeof(struct item ));
  new->opts = 0;
  new->incremented_opts = 0;
  new->decremented_opts = 0;
  new->default_keyid = (char )'\000';
  new->default_direction = (char )'\000';
  return ((void *)new);
}
}
static void *merge_autoindex_configs(apr_pool_t *p , void *basev , void *addv ) 
{ autoindex_config_rec *new ;
  autoindex_config_rec *base ;
  autoindex_config_rec *add ;
  void *tmp ;

  {
  base = (autoindex_config_rec *)basev;
  add = (autoindex_config_rec *)addv;
  tmp = apr_palloc(p, sizeof(autoindex_config_rec ));
  new = (autoindex_config_rec *)memset(tmp, 0, sizeof(autoindex_config_rec ));
  if (add->default_icon) {
    new->default_icon = add->default_icon;
  } else {
    new->default_icon = base->default_icon;
  }
  if (add->icon_height) {
    new->icon_height = add->icon_height;
  } else {
    new->icon_height = base->icon_height;
  }
  if (add->icon_width) {
    new->icon_width = add->icon_width;
  } else {
    new->icon_width = base->icon_width;
  }
  new->alt_list = apr_array_append(p, (apr_array_header_t const   *)add->alt_list,
                                   (apr_array_header_t const   *)base->alt_list);
  new->ign_list = apr_array_append(p, (apr_array_header_t const   *)add->ign_list,
                                   (apr_array_header_t const   *)base->ign_list);
  new->hdr_list = apr_array_append(p, (apr_array_header_t const   *)add->hdr_list,
                                   (apr_array_header_t const   *)base->hdr_list);
  new->desc_list = apr_array_append(p, (apr_array_header_t const   *)add->desc_list,
                                    (apr_array_header_t const   *)base->desc_list);
  new->icon_list = apr_array_append(p, (apr_array_header_t const   *)add->icon_list,
                                    (apr_array_header_t const   *)base->icon_list);
  new->rdme_list = apr_array_append(p, (apr_array_header_t const   *)add->rdme_list,
                                    (apr_array_header_t const   *)base->rdme_list);
  if (add->opts & 1) {
    new->opts = 1;
    new->incremented_opts = 0;
    new->decremented_opts = 0;
  } else {
    if (add->opts == 0) {
      new->incremented_opts = (base->incremented_opts | add->incremented_opts) & ~ add->decremented_opts;
      new->decremented_opts = base->decremented_opts | add->decremented_opts;
      new->opts = base->opts & -2;
    } else {
      new->opts = add->opts;
    }
    new->opts |= new->incremented_opts;
    new->opts &= ~ new->decremented_opts;
  }
  if (add->name_adjust == 2) {
    new->name_width = base->name_width;
    new->name_adjust = base->name_adjust;
  } else {
    new->name_width = add->name_width;
    new->name_adjust = add->name_adjust;
  }
  if (add->desc_adjust == 2) {
    new->desc_width = base->desc_width;
    new->desc_adjust = base->desc_adjust;
  } else {
    new->desc_width = add->desc_width;
    new->desc_adjust = add->desc_adjust;
  }
  if (add->default_keyid) {
    new->default_keyid = add->default_keyid;
  } else {
    new->default_keyid = base->default_keyid;
  }
  if (add->default_direction) {
    new->default_direction = add->default_direction;
  } else {
    new->default_direction = base->default_direction;
  }
  return ((void *)new);
}
}
static char *find_item(request_rec *r , apr_array_header_t *list , int path_only ) 
{ char const   *content_type ;
  char const   *tmp ;
  char const   *content_encoding ;
  char *path ;
  struct item *items ;
  int i ;
  struct item *p ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = ap_field_noparam(r->pool, r->content_type);
  content_type = tmp;
  content_encoding = r->content_encoding;
  path = r->filename;
  items = (struct item *)list->elts;
  i = 0;
  while (i < list->nelts) {
    p = items + i;
    if ((int )(*(path + 0)) == 94) {
      goto _L___1;
    } else {
      tmp___3 = ap_strcmp_match((char const   *)path, (char const   *)p->apply_path);
      if (! tmp___3) {
        _L___1: /* CIL Label */ 
        if (! (*(p->apply_to))) {
          return (p->data);
        } else {
          if ((unsigned int )p->type == (unsigned int )(& c_by_path)) {
            goto _L___0;
          } else {
            if ((int )(*(path + 0)) == 94) {
              _L___0: /* CIL Label */ 
              tmp___0 = ap_strcmp_match((char const   *)path, (char const   *)p->apply_to);
              if (! tmp___0) {
                return (p->data);
              }
            } else {
              if (! path_only) {
                if (! content_encoding) {
                  if ((unsigned int )p->type == (unsigned int )(& c_by_type)) {
                    if (content_type) {
                      tmp___1 = ap_strcasecmp_match(content_type, (char const   *)p->apply_to);
                      if (tmp___1) {
                        goto _L;
                      } else {
                        return (p->data);
                      }
                    } else {
                      _L: /* CIL Label */ ;
                    }
                  }
                } else {
                  if ((unsigned int )p->type == (unsigned int )(& c_by_encoding)) {
                    tmp___2 = ap_strcasecmp_match(content_encoding, (char const   *)p->apply_to);
                    if (! tmp___2) {
                      return (p->data);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    i ++;
  }
  return ((char *)((void *)0));
}
}
static char *find_default_item(char *bogus_name , apr_array_header_t *list ) 
{ request_rec r ;
  char *tmp ;

  {
  r.filename = bogus_name;
  r.content_encoding = (char const   *)((void *)0);
  r.content_type = r.content_encoding;
  tmp = find_item(& r, list, 1);
  return (tmp);
}
}
static char *find_desc(autoindex_config_rec *dcfg , char const   *filename_full ) 
{ int i ;
  ai_desc_t *list ;
  char const   *filename_only ;
  char const   *filename ;
  ai_desc_t *tuple ;
  int found ;
  apr_status_t tmp ;
  char *tmp___0 ;

  {
  list = (ai_desc_t *)(dcfg->desc_list)->elts;
  filename_only = strrchr(filename_full, '/');
  if ((unsigned int )filename_only == (unsigned int )((void *)0)) {
    filename_only = filename_full;
  } else {
    filename_only ++;
  }
  i = 0;
  while (i < (dcfg->desc_list)->nelts) {
    tuple = list + i;
    if (tuple->full_path) {
      filename = filename_full;
    } else {
      filename = filename_only;
    }
    if (tuple->wildcards) {
      tmp = apr_fnmatch((char const   *)tuple->pattern, filename, 0);
      found = tmp == 0;
    } else {
      tmp___0 = strstr(filename, (char const   *)tuple->pattern);
      found = (unsigned int )tmp___0 != (unsigned int )((void *)0);
    }
    if (found) {
      return (tuple->description);
    }
    i ++;
  }
  return ((char *)((void *)0));
}
}
static int ignore_entry(autoindex_config_rec *d , char *path ) 
{ apr_array_header_t *list ;
  struct item *items ;
  char *tt ;
  int i ;
  struct item *p ;
  char *ap ;
  int tmp ;
  int tmp___0 ;

  {
  list = d->ign_list;
  items = (struct item *)list->elts;
  tt = strrchr((char const   *)path, '/');
  if ((unsigned int )tt == (unsigned int )((void *)0)) {
    tt = path;
  } else {
    tt ++;
  }
  i = 0;
  while (i < list->nelts) {
    p = items + i;
    ap = strrchr((char const   *)p->apply_to, '/');
    if ((unsigned int )ap == (unsigned int )((void *)0)) {
      ap = p->apply_to;
    } else {
      ap ++;
    }
    tmp = ap_strcmp_match((char const   *)path, (char const   *)p->apply_path);
    if (tmp) {
      _L: /* CIL Label */ ;
    } else {
      tmp___0 = ap_strcmp_match((char const   *)tt, (char const   *)ap);
      if (tmp___0) {
        goto _L;
      } else {
        return (1);
      }
    }
    i ++;
  }
  return (0);
}
}
static void do_emit_plain(request_rec *r , apr_file_t *f ) 
{ char buf[8193] ;
  int ch ;
  apr_size_t i ;
  apr_size_t c ;
  apr_size_t n ;
  apr_status_t rv ;
  apr_status_t tmp ;

  {
  ap_rputs("<pre>\n", r);
  while (1) {
    tmp = apr_file_eof(f);
    if (tmp) {
      break;
    }
    while (1) {
      n = sizeof(char ) * 8192U;
      rv = apr_file_read(f, (void *)(buf), & n);
      if (! (rv == 4)) {
        break;
      }
    }
    if (n == 0U) {
      goto _L;
    } else {
      if (rv != 0) {
        _L: /* CIL Label */ 
        break;
      }
    }
    buf[n] = (char )'\000';
    c = 0U;
    while (c < n) {
      i = c;
      while (i < n) {
        if ((int )buf[i] == 60) {
          goto _L___1;
        } else {
          if ((int )buf[i] == 62) {
            _L___1: /* CIL Label */ 
            goto _L___0;
          } else {
            if ((int )buf[i] == 38) {
              _L___0: /* CIL Label */ 
              break;
            }
          }
        }
        i ++;
      }
      ch = (int )buf[i];
      buf[i] = (char )'\000';
      ap_rputs((char const   *)(& buf[c]), r);
      if (ch == 60) {
        ap_rputs("&lt;", r);
      } else {
        if (ch == 62) {
          ap_rputs("&gt;", r);
        } else {
          if (ch == 38) {
            ap_rputs("&amp;", r);
          }
        }
      }
      c = i + 1U;
    }
  }
  ap_rputs("</pre>\n", r);
  return;
}
}
static void emit_head(request_rec *r , char *header_fname , int suppress_amble , char *title ) 
{ apr_table_t *hdrs ;
  apr_file_t *f ;
  request_rec *rr ;
  int emit_amble ;
  int emit_H1 ;
  char const   *r_accept ;
  char const   *r_accept_enc ;
  ap_filter_t *f___0 ;
  int tmp ;
  apr_status_t tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  hdrs = r->headers_in;
  f = (apr_file_t *)((void *)0);
  rr = (request_rec *)((void *)0);
  emit_amble = 1;
  emit_H1 = 1;
  r_accept = apr_table_get((apr_table_t const   *)hdrs, "Accept");
  r_accept_enc = apr_table_get((apr_table_t const   *)hdrs, "Accept-Encoding");
  apr_table_setn(hdrs, "Accept", "text/html, text/plain");
  apr_table_unset(hdrs, "Accept-Encoding");
  if ((unsigned int )header_fname != (unsigned int )((void *)0)) {
    if (r->args) {
      header_fname = apr_pstrcat(r->pool, header_fname, "?", r->args, (void *)0);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  if ((unsigned int )header_fname != (unsigned int )((void *)0)) {
    rr = ap_sub_req_lookup_uri((char const   *)header_fname, (request_rec const   *)r,
                               r->output_filters);
    if (rr) {
      if (rr->status == 200) {
        if ((unsigned int )rr->filename != (unsigned int )((void *)0)) {
          if ((int )rr->finfo.filetype == 1) {
            if ((unsigned int )rr->content_type != (unsigned int )((void *)0)) {
              tmp___2 = ap_field_noparam(r->pool, rr->content_type);
              tmp___3 = strcasecmp(tmp___2, "text/html");
              if (tmp___3) {
                tmp___1 = strncasecmp("text/", rr->content_type, 5U);
                if (! tmp___1) {
                  tmp___0 = apr_file_open(& f, (char const   *)rr->filename, 1, 4095,
                                          r->pool);
                  if (tmp___0 == 0) {
                    emit_preamble(r, title);
                    emit_amble = 0;
                    do_emit_plain(r, f);
                    apr_file_close(f);
                    emit_H1 = 0;
                  }
                }
              } else {
                emit_amble = 0;
                emit_H1 = 0;
                if (! suppress_amble) {
                  emit_preamble(r, title);
                }
                f___0 = rr->output_filters;
                while ((unsigned int )f___0->frec != (unsigned int )ap_subreq_core_filter_handle) {
                  f___0 = f___0->next;
                }
                f___0->next = r->output_filters;
                tmp = ap_run_sub_req(rr);
                if (tmp != 0) {
                  emit_amble = suppress_amble;
                  emit_H1 = 1;
                }
              }
            }
          } else {
            goto _L___3;
          }
        } else {
          goto _L___3;
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ ;
  }
  if (r_accept) {
    apr_table_setn(hdrs, "Accept", r_accept);
  } else {
    apr_table_unset(hdrs, "Accept");
  }
  if (r_accept_enc) {
    apr_table_setn(hdrs, "Accept-Encoding", r_accept_enc);
  }
  if (emit_amble) {
    emit_preamble(r, title);
  }
  if (emit_H1) {
    ap_rvputs(r, "<h1>Index of ", title, "</h1>\n", (void *)0);
  }
  if ((unsigned int )rr != (unsigned int )((void *)0)) {
    ap_destroy_sub_req(rr);
  }
  return;
}
}
static void emit_tail(request_rec *r , char *readme_fname , int suppress_amble ) 
{ apr_file_t *f ;
  request_rec *rr ;
  int suppress_post ;
  int suppress_sig ;
  ap_filter_t *f___0 ;
  int tmp ;
  apr_status_t tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
  f = (apr_file_t *)((void *)0);
  rr = (request_rec *)((void *)0);
  suppress_post = 0;
  suppress_sig = 0;
  if ((unsigned int )readme_fname != (unsigned int )((void *)0)) {
    rr = ap_sub_req_lookup_uri((char const   *)readme_fname, (request_rec const   *)r,
                               r->output_filters);
    if (rr) {
      if (rr->status == 200) {
        if ((unsigned int )rr->filename != (unsigned int )((void *)0)) {
          if ((int )rr->finfo.filetype == 1) {
            if ((unsigned int )rr->content_type != (unsigned int )((void *)0)) {
              tmp___2 = ap_field_noparam(r->pool, rr->content_type);
              tmp___3 = strcasecmp(tmp___2, "text/html");
              if (tmp___3) {
                tmp___1 = strncasecmp("text/", rr->content_type, 5U);
                if (! tmp___1) {
                  tmp___0 = apr_file_open(& f, (char const   *)rr->filename, 1, 4095,
                                          r->pool);
                  if (tmp___0 == 0) {
                    do_emit_plain(r, f);
                    apr_file_close(f);
                    suppress_sig = 1;
                  }
                }
              } else {
                f___0 = rr->output_filters;
                while ((unsigned int )f___0->frec != (unsigned int )ap_subreq_core_filter_handle) {
                  f___0 = f___0->next;
                }
                f___0->next = r->output_filters;
                tmp = ap_run_sub_req(rr);
                if (tmp == 0) {
                  suppress_sig = 1;
                  suppress_post = suppress_amble;
                }
              }
            }
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ ;
  }
  if (! suppress_sig) {
    tmp___4 = ap_psignature("", r);
    ap_rputs(tmp___4, r);
  }
  if (! suppress_post) {
    ap_rputs("</body></html>\n", r);
  }
  if ((unsigned int )rr != (unsigned int )((void *)0)) {
    ap_destroy_sub_req(rr);
  }
  return;
}
}
static char *find_title(request_rec *r ) 
{ char titlebuf[8192] ;
  char *find ;
  apr_file_t *thefile ;
  int x ;
  int y ;
  int p ;
  apr_size_t n ;
  apr_status_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  find = (char *)"<title>";
  thefile = (apr_file_t *)((void *)0);
  if (r->status != 200) {
    return ((char *)((void *)0));
  }
  if ((unsigned int )r->content_type != (unsigned int )((void *)0)) {
    tmp___2 = ap_field_noparam(r->pool, r->content_type);
    tmp___3 = strcasecmp(tmp___2, "text/html");
    if (tmp___3) {
      tmp___4 = strcmp(r->content_type, "text/x-server-parsed-html");
      if (tmp___4) {
        goto _L___1;
      } else {
        _L___2: /* CIL Label */ 
        if (! r->content_encoding) {
          tmp = apr_file_open(& thefile, (char const   *)r->filename, 1, 4095, r->pool);
          if (tmp != 0) {
            return ((char *)((void *)0));
          }
          n = sizeof(char ) * 8191U;
          apr_file_read(thefile, (void *)(titlebuf), & n);
          if (n <= 0U) {
            apr_file_close(thefile);
            return ((char *)((void *)0));
          }
          titlebuf[n] = (char )'\000';
          x = 0;
          p = 0;
          while (titlebuf[x]) {
            tmp___1 = tolower((int )((unsigned char )titlebuf[x]));
            if (tmp___1 == (int )(*(find + p))) {
              p ++;
              if (! (*(find + p))) {
                x ++;
                p = ap_ind((char const   *)(& titlebuf[x]), (char )'<');
                if (p != -1) {
                  titlebuf[x + p] = (char )'\000';
                }
                y = x;
                while (titlebuf[y]) {
                  if ((int )titlebuf[y] == 13) {
                    goto _L;
                  } else {
                    if ((int )titlebuf[y] == 10) {
                      _L: /* CIL Label */ 
                      if (y == x) {
                        x ++;
                      } else {
                        titlebuf[y] = (char )' ';
                      }
                    }
                  }
                  y ++;
                }
                apr_file_close(thefile);
                tmp___0 = apr_pstrdup(r->pool, (char const   *)(& titlebuf[x]));
                return (tmp___0);
              }
            } else {
              p = 0;
            }
            x ++;
          }
          apr_file_close(thefile);
        } else {
          goto _L___1;
        }
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
  return ((char *)((void *)0));
}
}
static struct ent *make_parent_entry(apr_int32_t autoindex_opts , autoindex_config_rec *d ,
                                     request_rec *r , char keyid , char direction ) 
{ struct ent *p ;
  void *tmp ;
  struct ent *tmp___0 ;
  char *testpath ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = apr_palloc(r->pool, sizeof(struct ent ));
  tmp___0 = (struct ent *)memset(tmp, 0, sizeof(struct ent ));
  p = tmp___0;
  p->name = ap_make_full_path(r->pool, (char const   *)r->uri, "../");
  if (! p->name) {
    return ((struct ent *)((void *)0));
  }
  ap_getparents(p->name);
  if (! (*(p->name))) {
    return ((struct ent *)((void *)0));
  }
  testpath = ap_make_full_path(r->pool, (char const   *)r->filename, "..");
  tmp___1 = ignore_entry(d, testpath);
  if (tmp___1) {
    return ((struct ent *)((void *)0));
  }
  p->size = -1L;
  p->lm = -1LL;
  p->key = (char )toupper((int )((unsigned char )keyid));
  tmp___2 = toupper((int )((unsigned char )direction));
  p->ascending = tmp___2 == 65;
  p->version_sort = autoindex_opts & 2048;
  if (autoindex_opts & 8192) {
    p->icon = find_default_item(testpath, d->icon_list);
    if (! p->icon) {
      p->icon = find_default_item((char *)"^^DIRECTORY^^", d->icon_list);
    }
    p->alt = find_default_item(testpath, d->alt_list);
    if (! p->alt) {
      p->alt = find_default_item((char *)"^^DIRECTORY^^", d->alt_list);
      if (! p->alt) {
        p->alt = (char *)"DIR";
      }
    }
    p->desc = find_desc(d, (char const   *)testpath);
  }
  return (p);
}
}
static struct ent *make_autoindex_entry(apr_finfo_t const   *dirent , int autoindex_opts ,
                                        autoindex_config_rec *d , request_rec *r ,
                                        char keyid , char direction , char const   *pattern ) 
{ request_rec *rr ;
  struct ent *p ;
  apr_status_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___5 ;
  char const   *tmp___6 ;

  {
  if ((int const   )(*(dirent->name + 0)) == 46) {
    if (! (*(dirent->name + 1))) {
      goto _L___0;
    } else {
      if ((int const   )(*(dirent->name + 1)) == 46) {
        if (! (*(dirent->name + 2))) {
          _L___0: /* CIL Label */ 
          return ((struct ent *)((void *)0));
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        goto _L;
      }
    }
  } else {
    _L: /* CIL Label */ ;
  }
  if (pattern) {
    tmp = apr_fnmatch(pattern, dirent->name, 5);
    if (tmp != 0) {
      return ((struct ent *)((void *)0));
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ ;
  }
  tmp___0 = ap_make_full_path(r->pool, (char const   *)r->filename, dirent->name);
  tmp___1 = ignore_entry(d, tmp___0);
  if (tmp___1) {
    return ((struct ent *)((void *)0));
  }
  rr = ap_sub_req_lookup_dirent(dirent, (request_rec const   *)r, 0, (ap_filter_t *)((void *)0));
  if (! rr) {
    return ((struct ent *)((void *)0));
  }
  if ((int )rr->finfo.filetype != 2) {
    if ((int )rr->finfo.filetype != 1) {
      goto _L___5;
    } else {
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ 
    if (rr->status == 0) {
      goto _L___6;
    } else {
      if (rr->status >= 200) {
        if (rr->status < 300) {
          _L___6: /* CIL Label */ 
          goto _L___4;
        } else {
          goto _L___7;
        }
      } else {
        _L___7: /* CIL Label */ 
        if (rr->status >= 300) {
          if (rr->status < 400) {
            _L___4: /* CIL Label */ ;
          } else {
            goto _L___5;
          }
        } else {
          _L___5: /* CIL Label */ 
          ap_destroy_sub_req(rr);
          return ((struct ent *)((void *)0));
        }
      }
    }
  }
  if ((int )rr->finfo.filetype == 2) {
    tmp___2 = strlen((char const   *)rr->filename);
    (*(rr->filename + (tmp___2 - 1U))) = (char )'\000';
  }
  tmp___3 = apr_palloc(r->pool, sizeof(struct ent ));
  p = (struct ent *)memset(tmp___3, 0, sizeof(struct ent ));
  if ((int )dirent->filetype == 2) {
    p->name = apr_pstrcat(r->pool, dirent->name, "/", (void *)0);
  } else {
    p->name = apr_pstrdup(r->pool, dirent->name);
  }
  p->size = -1L;
  p->icon = (char *)((void *)0);
  p->alt = (char *)((void *)0);
  p->desc = (char *)((void *)0);
  p->lm = -1LL;
  p->isdir = 0;
  p->key = (char )toupper((int )((unsigned char )keyid));
  tmp___5 = toupper((int )((unsigned char )direction));
  p->ascending = tmp___5 == 65;
  p->version_sort = ! (! (autoindex_opts & 2048)) != 0;
  p->ignore_case = ! (! (autoindex_opts & 65536)) != 0;
  if (autoindex_opts & 24576) {
    p->lm = rr->finfo.mtime;
    if ((int )dirent->filetype == 2) {
      if (autoindex_opts & 1024) {
        p->isdir = 1;
      }
      p->icon = find_item(rr, d->icon_list, 1);
      if (! p->icon) {
        p->icon = find_default_item((char *)"^^DIRECTORY^^", d->icon_list);
      }
      p->alt = find_item(rr, d->alt_list, 1);
      if (! p->alt) {
        p->alt = find_default_item((char *)"^^DIRECTORY^^", d->alt_list);
        if (! p->alt) {
          p->alt = (char *)"DIR";
        }
      }
    } else {
      p->icon = find_item(rr, d->icon_list, 0);
      p->alt = find_item(rr, d->alt_list, 0);
      p->size = rr->finfo.size;
    }
    p->desc = find_desc(d, (char const   *)rr->filename);
    if (! p->desc) {
      if (autoindex_opts & 4) {
        tmp___6 = find_title(rr);
        p->desc = apr_pstrdup(r->pool, tmp___6);
      } else {
        goto _L___9;
      }
    } else {
      _L___9: /* CIL Label */ ;
    }
  }
  ap_destroy_sub_req(rr);
  if ((int )keyid == 77) {
    if (p->lm < 0LL) {
      p->lm = 0LL;
    }
  }
  return (p);
}
}
static char *terminate_description(autoindex_config_rec *d , char *desc , apr_int32_t autoindex_opts ,
                                   int desc_width ) 
{ int maxsize ;
  register int x ;

  {
  maxsize = desc_width;
  if (d->desc_adjust == 2) {
    if (autoindex_opts & 8) {
      maxsize += 6;
    }
    if (autoindex_opts & 16) {
      maxsize += 19;
    }
    if (autoindex_opts & 32) {
      maxsize += 7;
    }
  }
  x = 0;
  while (1) {
    if ((*(desc + x))) {
      if (maxsize > 0) {
        goto _L___0;
      } else {
        if ((int )(*(desc + x)) == 60) {
          _L___0: /* CIL Label */ ;
        } else {
          goto _L;
        }
      }
    } else {
      _L: /* CIL Label */ 
      break;
    }
    if ((int )(*(desc + x)) == 60) {
      while ((int )(*(desc + x)) != 62) {
        if (! (*(desc + x))) {
          maxsize = 0;
          break;
        }
        x ++;
      }
    } else {
      if ((int )(*(desc + x)) == 38) {
        maxsize --;
        while ((int )(*(desc + x)) != 59) {
          if ((int )(*(desc + x)) == 0) {
            maxsize = 0;
            break;
          }
          x ++;
        }
      } else {
        maxsize --;
      }
    }
    x ++;
  }
  if (! maxsize) {
    if ((int )(*(desc + x)) != 0) {
      (*(desc + (x - 1))) = (char )'>';
      (*(desc + x)) = (char )'\000';
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
  return (desc);
}
}
static void emit_link(request_rec *r , char const   *anchor , char column , char curkey ,
                      char curdirection , char const   *colargs , int nosort ) 
{ char qvalue[13] ;
  int reverse___0 ;
  int tmp ;
  char const   *tmp___0 ;

  {
  if (! nosort) {
    if ((int )curkey == (int )column) {
      if ((int )curdirection == 65) {
        tmp = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      tmp = 0;
    }
    reverse___0 = tmp;
    qvalue[0] = (char )'?';
    qvalue[1] = (char )'C';
    qvalue[2] = (char )'=';
    qvalue[3] = column;
    qvalue[4] = (char )'&';
    qvalue[5] = (char )'a';
    qvalue[6] = (char )'m';
    qvalue[7] = (char )'p';
    qvalue[8] = (char )';';
    qvalue[9] = (char )'O';
    qvalue[10] = (char )'=';
    if (reverse___0) {
      qvalue[11] = (char )'D';
    } else {
      qvalue[11] = (char )'A';
    }
    qvalue[12] = (char )'\000';
    if (colargs) {
      tmp___0 = colargs;
    } else {
      tmp___0 = "";
    }
    ap_rvputs(r, "<a href=\"", qvalue, tmp___0, "\">", anchor, "</a>", (void *)0);
  } else {
    ap_rputs(anchor, r);
  }
  return;
}
}
static void output_directories(struct ent **ar , int n , autoindex_config_rec *d ,
                               request_rec *r , apr_int32_t autoindex_opts , char keyid ,
                               char direction , char const   *colargs ) 
{ int x ;
  apr_size_t rv ;
  char *name ;
  char *tp ;
  int static_columns ;
  apr_pool_t *scratch ;
  int name_width ;
  int desc_width ;
  char *name_scratch ;
  char *pad_scratch ;
  char *breakrow ;
  int t ;
  int tmp ;
  int t___0 ;
  int tmp___0 ;
  int cols ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *anchor ;
  char *t___1 ;
  char *t2 ;
  int nwidth ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char time_str[8192] ;
  apr_time_exp_t ts ;
  char buf[5] ;
  char *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char time_str___0[8192] ;
  apr_time_exp_t ts___0 ;
  char buf___0[5] ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;

  {
  name = r->uri;
  static_columns = ! (! (autoindex_opts & 256)) != 0;
  breakrow = (char *)"";
  apr_pool_create_ex(& scratch, r->pool, (int (*)(int retcode ))((void *)0), (apr_allocator_t *)((void *)0));
  if ((int )(*(name + 0)) == 0) {
    name = (char *)"/";
  }
  name_width = d->name_width;
  desc_width = d->desc_width;
  if ((autoindex_opts & 24576) == 8192) {
    if (d->name_adjust == 1) {
      x = 0;
      while (x < n) {
        tmp = (int )strlen((char const   *)((*(ar + x)))->name);
        t = tmp;
        if (t > name_width) {
          name_width = t;
        }
        x ++;
      }
    }
    if (d->desc_adjust == 1) {
      x = 0;
      while (x < n) {
        if ((unsigned int )((*(ar + x)))->desc != (unsigned int )((void *)0)) {
          tmp___0 = (int )strlen((char const   *)((*(ar + x)))->desc);
          t___0 = tmp___0;
          if (t___0 > desc_width) {
            desc_width = t___0;
          }
        }
        x ++;
      }
    }
  }
  name_scratch = (char *)apr_palloc(r->pool, (unsigned int )(name_width + 1));
  pad_scratch = (char *)apr_palloc(r->pool, (unsigned int )(name_width + 1));
  memset((void *)pad_scratch, ' ', (unsigned int )name_width);
  (*(pad_scratch + name_width)) = (char )'\000';
  if (autoindex_opts & 16384) {
    cols = 1;
    ap_rputs("<table><tr>", r);
    if (! (autoindex_opts & 8)) {
      ap_rputs("<th>", r);
      tp = find_default_item((char *)"^^BLANKICON^^", d->icon_list);
      if (tp) {
        tmp___1 = ap_escape_html(scratch, (char const   *)tp);
        ap_rvputs(r, "<img src=\"", tmp___1, "\" alt=\"[ICO]\"", (void *)0);
        if (d->icon_width) {
          ap_rprintf(r, " width=\"%d\"", d->icon_width);
        }
        if (d->icon_height) {
          ap_rprintf(r, " height=\"%d\"", d->icon_height);
        }
        ap_rputs(" /></th>", r);
      } else {
        ap_rputs("&nbsp;</th>", r);
      }
      cols ++;
    }
    ap_rputs("<th>", r);
    emit_link(r, "Name", (char )'N', keyid, direction, colargs, static_columns);
    if (! (autoindex_opts & 16)) {
      ap_rputs("</th><th>", r);
      emit_link(r, "Last modified", (char )'M', keyid, direction, colargs, static_columns);
      cols ++;
    }
    if (! (autoindex_opts & 32)) {
      ap_rputs("</th><th>", r);
      emit_link(r, "Size", (char )'S', keyid, direction, colargs, static_columns);
      cols ++;
    }
    if (! (autoindex_opts & 64)) {
      ap_rputs("</th><th>", r);
      emit_link(r, "Description", (char )'D', keyid, direction, colargs, static_columns);
      cols ++;
    }
    if (! (autoindex_opts & 512)) {
      breakrow = apr_psprintf(r->pool, "<tr><th colspan=\"%d\"><hr /></th></tr>\n",
                              cols);
    }
    ap_rvputs(r, "</th></tr>", breakrow, (void *)0);
  } else {
    if (autoindex_opts & 8192) {
      ap_rputs("<pre>", r);
      if (! (autoindex_opts & 8)) {
        tp = find_default_item((char *)"^^BLANKICON^^", d->icon_list);
        if (tp) {
          tmp___2 = ap_escape_html(scratch, (char const   *)tp);
          ap_rvputs(r, "<img src=\"", tmp___2, "\" alt=\"Icon \"", (void *)0);
          if (d->icon_width) {
            ap_rprintf(r, " width=\"%d\"", d->icon_width);
          }
          if (d->icon_height) {
            ap_rprintf(r, " height=\"%d\"", d->icon_height);
          }
          ap_rputs(" /> ", r);
        } else {
          ap_rputs("      ", r);
        }
      }
      emit_link(r, "Name", (char )'N', keyid, direction, colargs, static_columns);
      ap_rputs((char const   *)(pad_scratch + 4), r);
      ap_rputs(" ", r);
      if (! (autoindex_opts & 16)) {
        emit_link(r, "Last modified", (char )'M', keyid, direction, colargs, static_columns);
        ap_rputs("      ", r);
      }
      if (! (autoindex_opts & 32)) {
        emit_link(r, "Size", (char )'S', keyid, direction, colargs, static_columns);
        ap_rputs("  ", r);
      }
      if (! (autoindex_opts & 64)) {
        emit_link(r, "Description", (char )'D', keyid, direction, colargs, static_columns);
      }
      if (! (autoindex_opts & 512)) {
        ap_rputs("<hr />", r);
      } else {
        ap_rputc('\n', r);
      }
    } else {
      ap_rputs("<ul>", r);
    }
  }
  x = 0;
  while (x < n) {
    apr_pool_clear(scratch);
    t___1 = ((*(ar + x)))->name;
    tmp___3 = ap_os_escape_path(scratch, (char const   *)t___1, 0);
    anchor = ap_escape_html(scratch, tmp___3);
    if (! x) {
      if ((int )(*(t___1 + 0)) == 47) {
        t2 = (char *)"Parent Directory";
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      t2 = t___1;
    }
    if (autoindex_opts & 16384) {
      if (! (autoindex_opts & 8)) {
        ap_rputs("<tr><td valign=\"top\">", r);
        if (autoindex_opts & 2) {
          ap_rvputs(r, "<a href=\"", anchor, "\">", (void *)0);
        }
        if (((*(ar + x)))->icon) {
          goto _L___0;
        } else {
          if (d->default_icon) {
            _L___0: /* CIL Label */ 
            if (((*(ar + x)))->alt) {
              tmp___4 = (char const   *)((*(ar + x)))->alt;
            } else {
              tmp___4 = "   ";
            }
            if (((*(ar + x)))->icon) {
              tmp___5 = ((*(ar + x)))->icon;
            } else {
              tmp___5 = d->default_icon;
            }
            tmp___6 = ap_escape_html(scratch, (char const   *)tmp___5);
            ap_rvputs(r, "<img src=\"", tmp___6, "\" alt=\"[", tmp___4, "]\"", (void *)0);
            if (d->icon_width) {
              ap_rprintf(r, " width=\"%d\"", d->icon_width);
            }
            if (d->icon_height) {
              ap_rprintf(r, " height=\"%d\"", d->icon_height);
            }
            ap_rputs(" />", r);
          } else {
            ap_rputs("&nbsp;", r);
          }
        }
        if (autoindex_opts & 2) {
          ap_rputs("</a></td>", r);
        } else {
          ap_rputs("</td>", r);
        }
      }
      if (d->name_adjust == 1) {
        tmp___7 = ap_escape_html(scratch, (char const   *)t2);
        ap_rvputs(r, "<td><a href=\"", anchor, "\">", tmp___7, "</a>", (void *)0);
      } else {
        nwidth = (int )strlen((char const   *)t2);
        if (nwidth > name_width) {
          memcpy((void * __restrict  )name_scratch, (void const   * __restrict  )t2,
                 (unsigned int )(name_width - 3));
          (*(name_scratch + (name_width - 3))) = (char )'.';
          (*(name_scratch + (name_width - 2))) = (char )'.';
          (*(name_scratch + (name_width - 1))) = (char )'>';
          (*(name_scratch + name_width)) = (char)0;
          t2 = name_scratch;
          nwidth = name_width;
        }
        tmp___8 = ap_escape_html(scratch, (char const   *)t2);
        ap_rvputs(r, "<td><a href=\"", anchor, "\">", tmp___8, "</a>", pad_scratch +
                                                                       nwidth, (void *)0);
      }
      if (! (autoindex_opts & 16)) {
        if (((*(ar + x)))->lm != -1LL) {
          apr_time_exp_lt(& ts, ((*(ar + x)))->lm);
          apr_strftime(time_str, & rv, 8192U, "</td><td align=\"right\">%d-%b-%Y %H:%M  ",
                       & ts);
          ap_rputs((char const   *)(time_str), r);
        } else {
          ap_rputs("</td><td>&nbsp;", r);
        }
      }
      if (! (autoindex_opts & 32)) {
        tmp___9 = apr_strfsize(((*(ar + x)))->size, buf);
        ap_rvputs(r, "</td><td align=\"right\">", tmp___9, (void *)0);
      }
      if (! (autoindex_opts & 64)) {
        if (((*(ar + x)))->desc) {
          if (d->desc_adjust == 1) {
            ap_rvputs(r, "</td><td>", ((*(ar + x)))->desc, (void *)0);
          } else {
            tmp___10 = terminate_description(d, ((*(ar + x)))->desc, autoindex_opts,
                                             desc_width);
            ap_rvputs(r, "</td><td>", tmp___10, (void *)0);
          }
        }
      } else {
        ap_rputs("</td><td>&nbsp;", r);
      }
      ap_rputs("</td></tr>\n", r);
    } else {
      if (autoindex_opts & 8192) {
        if (! (autoindex_opts & 8)) {
          if (autoindex_opts & 2) {
            ap_rvputs(r, "<a href=\"", anchor, "\">", (void *)0);
          }
          if (((*(ar + x)))->icon) {
            goto _L___1;
          } else {
            if (d->default_icon) {
              _L___1: /* CIL Label */ 
              if (((*(ar + x)))->alt) {
                tmp___11 = (char const   *)((*(ar + x)))->alt;
              } else {
                tmp___11 = "   ";
              }
              if (((*(ar + x)))->icon) {
                tmp___12 = ((*(ar + x)))->icon;
              } else {
                tmp___12 = d->default_icon;
              }
              tmp___13 = ap_escape_html(scratch, (char const   *)tmp___12);
              ap_rvputs(r, "<img src=\"", tmp___13, "\" alt=\"[", tmp___11, "]\"",
                        (void *)0);
              if (d->icon_width) {
                ap_rprintf(r, " width=\"%d\"", d->icon_width);
              }
              if (d->icon_height) {
                ap_rprintf(r, " height=\"%d\"", d->icon_height);
              }
              ap_rputs(" />", r);
            } else {
              ap_rputs("     ", r);
            }
          }
          if (autoindex_opts & 2) {
            ap_rputs("</a> ", r);
          } else {
            ap_rputc(' ', r);
          }
        }
        nwidth = (int )strlen((char const   *)t2);
        if (nwidth > name_width) {
          memcpy((void * __restrict  )name_scratch, (void const   * __restrict  )t2,
                 (unsigned int )(name_width - 3));
          (*(name_scratch + (name_width - 3))) = (char )'.';
          (*(name_scratch + (name_width - 2))) = (char )'.';
          (*(name_scratch + (name_width - 1))) = (char )'>';
          (*(name_scratch + name_width)) = (char)0;
          t2 = name_scratch;
          nwidth = name_width;
        }
        tmp___14 = ap_escape_html(scratch, (char const   *)t2);
        ap_rvputs(r, "<a href=\"", anchor, "\">", tmp___14, "</a>", pad_scratch +
                                                                    nwidth, (void *)0);
        ap_rputs(" ", r);
        if (! (autoindex_opts & 16)) {
          if (((*(ar + x)))->lm != -1LL) {
            apr_time_exp_lt(& ts___0, ((*(ar + x)))->lm);
            apr_strftime(time_str___0, & rv, 8192U, "%d-%b-%Y %H:%M  ", & ts___0);
            ap_rputs((char const   *)(time_str___0), r);
          } else {
            ap_rputs("                   ", r);
          }
        }
        if (! (autoindex_opts & 32)) {
          tmp___15 = apr_strfsize(((*(ar + x)))->size, buf___0);
          ap_rputs(tmp___15, r);
          ap_rputs("  ", r);
        }
        if (! (autoindex_opts & 64)) {
          if (((*(ar + x)))->desc) {
            tmp___16 = terminate_description(d, ((*(ar + x)))->desc, autoindex_opts,
                                             desc_width);
            ap_rputs(tmp___16, r);
          }
        }
        ap_rputc('\n', r);
      } else {
        ap_rvputs(r, "<li><a href=\"", anchor, "\"> ", t2, "</a></li>\n", (void *)0);
      }
    }
    x ++;
  }
  if (autoindex_opts & 16384) {
    ap_rvputs(r, breakrow, "</table>\n", (void *)0);
  } else {
    if (autoindex_opts & 8192) {
      if (! (autoindex_opts & 512)) {
        ap_rputs("<hr /></pre>\n", r);
      } else {
        ap_rputs("</pre>\n", r);
      }
    } else {
      ap_rputs("</ul>\n", r);
    }
  }
  return;
}
}
static int dsortf(struct ent **e1 , struct ent **e2 ) 
{ struct ent *c1 ;
  struct ent *c2 ;
  int result ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  result = 0;
  if ((int )(*(((*e1))->name + 0)) == 47) {
    return (-1);
  }
  if ((int )(*(((*e2))->name + 0)) == 47) {
    return (1);
  }
  if (((*e1))->isdir != ((*e2))->isdir) {
    if (((*e1))->isdir) {
      tmp = -1;
    } else {
      tmp = 1;
    }
    return (tmp);
  }
  if (((*e1))->ascending) {
    c1 = (*e1);
    c2 = (*e2);
  } else {
    c1 = (*e2);
    c2 = (*e1);
  }
  switch ((int )c1->key) {
  case 77: ;
  if (c1->lm > c2->lm) {
    return (1);
  } else {
    if (c1->lm < c2->lm) {
      return (-1);
    }
  }
  break;
  case 83: ;
  if (c1->size > c2->size) {
    return (1);
  } else {
    if (c1->size < c2->size) {
      return (-1);
    }
  }
  break;
  case 68: ;
  if (c1->version_sort) {
    if (c2->desc) {
      tmp___0 = (char const   *)c2->desc;
    } else {
      tmp___0 = "";
    }
    if (c1->desc) {
      tmp___1 = (char const   *)c1->desc;
    } else {
      tmp___1 = "";
    }
    result = apr_strnatcmp(tmp___1, tmp___0);
  } else {
    if (c2->desc) {
      tmp___2 = (char const   *)c2->desc;
    } else {
      tmp___2 = "";
    }
    if (c1->desc) {
      tmp___3 = (char const   *)c1->desc;
    } else {
      tmp___3 = "";
    }
    result = strcmp(tmp___3, tmp___2);
  }
  if (result) {
    return (result);
  }
  break;
  }
  if (c1->version_sort) {
    if (c1->ignore_case) {
      result = apr_strnatcasecmp((char const   *)c1->name, (char const   *)c2->name);
    }
    if (! result) {
      result = apr_strnatcmp((char const   *)c1->name, (char const   *)c2->name);
    }
  }
  if (! result) {
    if (c1->ignore_case) {
      result = strcasecmp((char const   *)c1->name, (char const   *)c2->name);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  if (! result) {
    result = strcmp((char const   *)c1->name, (char const   *)c2->name);
  }
  return (result);
}
}
static int index_directory(request_rec *r , autoindex_config_rec *autoindex_conf ) 
{ char *title_name ;
  char *tmp ;
  char *title_endp ;
  char *name ;
  char *pstring___0 ;
  apr_finfo_t dirent ;
  apr_dir_t *thedir ;
  apr_status_t status ;
  int num_ent ;
  int x ;
  struct ent *head ;
  struct ent *p ;
  struct ent **ar ;
  char const   *qstring ;
  apr_int32_t autoindex_opts ;
  char keyid ;
  char direction ;
  char *colargs ;
  char *fullpath ;
  apr_size_t dirpathlen ;
  char fval[5] ;
  char vval[5] ;
  char *ppre ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *eos ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char const   *savename ;
  apr_finfo_t fi ;
  apr_status_t tmp___10 ;
  int tmp___12 ;
  char *tmp___13 ;

  {
  tmp = ap_escape_html(r->pool, (char const   *)r->uri);
  title_name = tmp;
  name = r->filename;
  pstring___0 = (char *)((void *)0);
  num_ent = 0;
  ar = (struct ent **)((void *)0);
  autoindex_opts = autoindex_conf->opts;
  status = apr_dir_open(& thedir, (char const   *)name, r->pool);
  if (status != 0) {
    ap_log_rerror("mod_autoindex.c", 1960, 3, status, (request_rec const   *)r, "Can\'t open directory for index: %s",
                  r->filename);
    return (403);
  }
  ap_set_content_type(r, "text/html");
  if (autoindex_opts & 4096) {
    ap_update_mtime(r, r->finfo.mtime);
    ap_set_last_modified(r);
    ap_set_etag(r);
  }
  if (r->header_only) {
    apr_dir_close(thedir);
    return (0);
  }
  if (autoindex_conf->default_keyid) {
    keyid = autoindex_conf->default_keyid;
  } else {
    keyid = (char )'N';
  }
  if (autoindex_conf->default_direction) {
    direction = autoindex_conf->default_direction;
  } else {
    direction = (char )'A';
  }
  if (autoindex_opts & 32768) {
    qstring = (char const   *)((void *)0);
    autoindex_opts |= 256;
    colargs = (char *)"";
  } else {
    ppre = (char *)"";
    fval[0] = (char )'\000';
    vval[0] = (char )'\000';
    qstring = (char const   *)r->args;
    while (1) {
      if (qstring) {
        if (! (*qstring)) {
          goto _L___20;
        }
      } else {
        _L___20: /* CIL Label */ 
        break;
      }
      if ((int const   )(*(qstring + 0)) == 67) {
        if ((int const   )(*(qstring + 1)) == 61) {
          if ((*(qstring + 2))) {
            tmp___6 = strchr("NMSD", (int )(*(qstring + 2)));
            if (tmp___6) {
              if ((int const   )(*(qstring + 3)) == 38) {
                goto _L___16;
              } else {
                if (! (*(qstring + 3))) {
                  _L___16: /* CIL Label */ 
                  keyid = (char )(*(qstring + 2));
                  if ((*(qstring + 3))) {
                    tmp___0 = 4;
                  } else {
                    tmp___0 = 3;
                  }
                  qstring += tmp___0;
                } else {
                  goto _L___19;
                }
              }
            } else {
              goto _L___19;
            }
          } else {
            goto _L___19;
          }
        } else {
          goto _L___19;
        }
      } else {
        _L___19: /* CIL Label */ 
        if ((int const   )(*(qstring + 0)) == 79) {
          if ((int const   )(*(qstring + 1)) == 61) {
            if ((int const   )(*(qstring + 2)) == 65) {
              goto _L___13;
            } else {
              if ((int const   )(*(qstring + 2)) == 68) {
                _L___13: /* CIL Label */ 
                if ((int const   )(*(qstring + 3)) == 38) {
                  goto _L___11;
                } else {
                  if (! (*(qstring + 3))) {
                    _L___11: /* CIL Label */ 
                    direction = (char )(*(qstring + 2));
                    if ((*(qstring + 3))) {
                      tmp___1 = 4;
                    } else {
                      tmp___1 = 3;
                    }
                    qstring += tmp___1;
                  } else {
                    goto _L___14;
                  }
                }
              } else {
                goto _L___14;
              }
            }
          } else {
            goto _L___14;
          }
        } else {
          _L___14: /* CIL Label */ 
          if ((int const   )(*(qstring + 0)) == 70) {
            if ((int const   )(*(qstring + 1)) == 61) {
              if ((*(qstring + 2))) {
                tmp___5 = strchr("012", (int )(*(qstring + 2)));
                if (tmp___5) {
                  if ((int const   )(*(qstring + 3)) == 38) {
                    goto _L___6;
                  } else {
                    if (! (*(qstring + 3))) {
                      _L___6: /* CIL Label */ 
                      if ((int const   )(*(qstring + 2)) == 48) {
                        autoindex_opts &= -24577;
                      } else {
                        if ((int const   )(*(qstring + 2)) == 49) {
                          autoindex_opts = (autoindex_opts | 8192) & -16385;
                        } else {
                          if ((int const   )(*(qstring + 2)) == 50) {
                            autoindex_opts |= 24576;
                          }
                        }
                      }
                      strcpy((char * __restrict  )(fval), (char const   * __restrict  )"&F= ");
                      fval[3] = (char )(*(qstring + 2));
                      if ((*(qstring + 3))) {
                        tmp___2 = 4;
                      } else {
                        tmp___2 = 3;
                      }
                      qstring += tmp___2;
                    } else {
                      goto _L___9;
                    }
                  }
                } else {
                  goto _L___9;
                }
              } else {
                goto _L___9;
              }
            } else {
              goto _L___9;
            }
          } else {
            _L___9: /* CIL Label */ 
            if ((int const   )(*(qstring + 0)) == 86) {
              if ((int const   )(*(qstring + 1)) == 61) {
                if ((int const   )(*(qstring + 2)) == 48) {
                  goto _L___3;
                } else {
                  if ((int const   )(*(qstring + 2)) == 49) {
                    _L___3: /* CIL Label */ 
                    if ((int const   )(*(qstring + 3)) == 38) {
                      goto _L___1;
                    } else {
                      if (! (*(qstring + 3))) {
                        _L___1: /* CIL Label */ 
                        if ((int const   )(*(qstring + 2)) == 48) {
                          autoindex_opts &= -2049;
                        } else {
                          if ((int const   )(*(qstring + 2)) == 49) {
                            autoindex_opts |= 2048;
                          }
                        }
                        strcpy((char * __restrict  )(fval), (char const   * __restrict  )"&V= ");
                        vval[3] = (char )(*(qstring + 2));
                        if ((*(qstring + 3))) {
                          tmp___3 = 4;
                        } else {
                          tmp___3 = 3;
                        }
                        qstring += tmp___3;
                      } else {
                        goto _L___4;
                      }
                    }
                  } else {
                    goto _L___4;
                  }
                }
              } else {
                goto _L___4;
              }
            } else {
              _L___4: /* CIL Label */ 
              if ((int const   )(*(qstring + 0)) == 80) {
                if ((int const   )(*(qstring + 1)) == 61) {
                  tmp___4 = strchr(qstring, '&');
                  eos = tmp___4;
                  if (eos) {
                    pstring___0 = apr_pstrndup(r->pool, qstring + 2, (unsigned int )((eos -
                                                                                      qstring) -
                                                                                     2));
                    qstring = eos + 1;
                  } else {
                    pstring___0 = apr_pstrdup(r->pool, qstring + 2);
                    qstring = (char const   *)((void *)0);
                  }
                  if ((*pstring___0)) {
                    ppre = (char *)"&P=";
                  } else {
                    pstring___0 = (char *)((void *)0);
                  }
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
                qstring = (char const   *)((void *)0);
              }
            }
          }
        }
      }
    }
    colargs = apr_pstrcat(r->pool, fval, vval, ppre, pstring___0, (void *)0);
  }
  tmp___7 = strlen((char const   *)title_name);
  title_endp = (title_name + tmp___7) - 1;
  while (1) {
    if ((unsigned int )title_endp > (unsigned int )title_name) {
      if (! ((int )(*title_endp) == 47)) {
        goto _L___21;
      }
    } else {
      _L___21: /* CIL Label */ 
      break;
    }
    tmp___8 = title_endp;
    title_endp --;
    (*tmp___8) = (char )'\000';
  }
  tmp___9 = find_item(r, autoindex_conf->hdr_list, 0);
  emit_head(r, tmp___9, autoindex_opts & 128, title_name);
  head = (struct ent *)((void *)0);
  p = make_parent_entry(autoindex_opts, autoindex_conf, r, keyid, direction);
  if ((unsigned int )p != (unsigned int )((void *)0)) {
    p->next = head;
    head = p;
    num_ent ++;
  }
  fullpath = (char *)apr_palloc(r->pool, 4096U);
  dirpathlen = strlen((char const   *)name);
  memcpy((void * __restrict  )fullpath, (void const   * __restrict  )name, dirpathlen);
  while (1) {
    tmp___10 = apr_dir_read(& dirent, 33587568, thedir);
    if (! (tmp___10 == 0)) {
      break;
    }
    if ((int )dirent.filetype == 6) {
      savename = dirent.name;
      apr_cpystrn(fullpath + dirpathlen, dirent.name, 4096U - dirpathlen);
      status = apr_stat(& fi, (char const   *)fullpath, dirent.valid & -33554433,
                        r->pool);
      if (status != 0) {
        continue;
      }
      memcpy((void * __restrict  )(& dirent), (void const   * __restrict  )(& fi),
             sizeof(fi));
      dirent.name = savename;
      dirent.valid = dirent.valid | 33554432;
    }
    p = make_autoindex_entry((apr_finfo_t const   *)(& dirent), autoindex_opts, autoindex_conf,
                             r, keyid, direction, (char const   *)pstring___0);
    if ((unsigned int )p != (unsigned int )((void *)0)) {
      p->next = head;
      head = p;
      num_ent ++;
    }
  }
  if (num_ent > 0) {
    ar = (struct ent **)apr_palloc(r->pool, (unsigned int )num_ent * sizeof(struct ent *));
    p = head;
    x = 0;
    while (p) {
      tmp___12 = x;
      x ++;
      (*(ar + tmp___12)) = p;
      p = p->next;
    }
    qsort((void *)ar, (unsigned int )num_ent, sizeof(struct ent *), (int (*)(void const   * ,
                                                                             void const   * ))(& dsortf));
  }
  output_directories(ar, num_ent, autoindex_conf, r, autoindex_opts, keyid, direction,
                     (char const   *)colargs);
  apr_dir_close(thedir);
  tmp___13 = find_item(r, autoindex_conf->rdme_list, 0);
  emit_tail(r, tmp___13, autoindex_opts & 128);
  return (0);
}
}
static int handle_autoindex(request_rec *r ) 
{ autoindex_config_rec *d ;
  int allow_opts ;
  int tmp ;
  int errstatus ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  tmp = strcmp(r->handler, "httpd/unix-directory");
  if (tmp) {
    return (-1);
  }
  allow_opts = ap_allow_options(r);
  d = (autoindex_config_rec *)(*((void **)r->per_dir_config + autoindex_module.module_index));
  r->allowed = r->allowed | 1LL;
  if (r->method_number != 0) {
    return (-1);
  }
  if (allow_opts & 1) {
    errstatus = ap_discard_request_body(r);
    if (errstatus != 0) {
      return (errstatus);
    }
    tmp___0 = strlen((char const   *)r->filename);
    if ((int )(*(r->filename + (tmp___0 - 1U))) != 47) {
      r->filename = apr_pstrcat(r->pool, r->filename, "/", (void *)0);
    }
    tmp___1 = index_directory(r, d);
    return (tmp___1);
  } else {
    ap_log_rerror("mod_autoindex.c", 2190, 3, 0, (request_rec const   *)r, "Directory index forbidden by rule: %s",
                  r->filename);
    return (403);
  }
}
}
static void register_hooks___8(apr_pool_t *p ) 
{ 

  {
  ap_hook_handler(& handle_autoindex, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                  10);
  return;
}
}
struct module_struct autoindex_module  = 
     {20020903, 0, -1, "mod_autoindex.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, (void (*)(process_rec *process ))((void *)0), & create_autoindex_config,
    & merge_autoindex_configs, (void *(*)(apr_pool_t *p , server_rec *s ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), autoindex_cmds,
    & register_hooks___8};
#pragma merger(0,"/tmp/cil-ZOyXNlA6.i","-g -pthread")
apr_status_t apr_file_seek(apr_file_t *thefile , apr_seek_where_t where , apr_off_t *offset ) ;
apr_bucket *apr_bucket_file_create(apr_file_t *fd , apr_off_t offset , apr_size_t len ,
                                   apr_pool_t *p , apr_bucket_alloc_t *list ) ;
int ap_scan_script_header_err(request_rec *r , apr_file_t *f , char *buffer ) ;
static int asis_handler(request_rec *r ) 
{ conn_rec *c ;
  apr_file_t *f ;
  apr_status_t rv ;
  char const   *location ;
  int tmp ;
  int tmp___0 ;
  apr_bucket_brigade *bb ;
  apr_bucket *b ;
  apr_off_t pos ;
  apr_bucket *ap__b ;
  apr_bucket *ap__b___0 ;

  {
  c = r->connection;
  f = (apr_file_t *)((void *)0);
  tmp = strcmp(r->handler, "httpd/send-as-is");
  if (tmp) {
    tmp___0 = strcmp(r->handler, "send-as-is");
    if (tmp___0) {
      return (-1);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  r->allowed = r->allowed | 1LL;
  if (r->method_number != 0) {
    return (-1);
  }
  if ((int )r->finfo.filetype == 0) {
    ap_log_rerror("mod_asis.c", 87, 3, 0, (request_rec const   *)r, "File does not exist: %s",
                  r->filename);
    return (404);
  }
  rv = apr_file_open(& f, (char const   *)r->filename, 1, 4095, r->pool);
  if (rv != 0) {
    ap_log_rerror("mod_asis.c", 94, 3, rv, (request_rec const   *)r, "file permissions deny server access: %s",
                  r->filename);
    return (403);
  }
  ap_scan_script_header_err(r, f, (char *)((void *)0));
  location = apr_table_get((apr_table_t const   *)r->headers_out, "Location");
  if (location) {
    if ((int const   )(*(location + 0)) == 47) {
      if (r->status == 200) {
        goto _L___1;
      } else {
        if (r->status >= 300) {
          if (r->status < 400) {
            _L___1: /* CIL Label */ 
            apr_file_close(f);
            r->status = 200;
            r->method = apr_pstrdup(r->pool, "GET");
            r->method_number = 0;
            ap_internal_redirect_handler(location, r);
            return (0);
          } else {
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
          goto _L___3;
        }
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ ;
  }
  if (! r->header_only) {
    pos = (apr_off_t )0;
    rv = apr_file_seek(f, 1, & pos);
    if (rv != 0) {
      ap_log_rerror("mod_asis.c", 127, 3, rv, (request_rec const   *)r, "mod_asis: failed to find end-of-headers position for %s",
                    r->filename);
      apr_file_close(f);
      return (500);
    }
    bb = apr_brigade_create(r->pool, c->bucket_alloc);
    b = apr_bucket_file_create(f, pos, (unsigned int )(r->finfo.size - pos), r->pool,
                               c->bucket_alloc);
    while (1) {
      ap__b = b;
      while (1) {
        ap__b->link.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                (char *)((void *)0)));
        ap__b->link.prev = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                 (char *)((void *)0))))->link.prev;
        (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                               (char *)((void *)0))))->link.prev)->link.next = ap__b;
        ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                              (char *)((void *)0))))->link.prev = ap__b;
        break;
      }
      break;
    }
    b = apr_bucket_eos_create(c->bucket_alloc);
    while (1) {
      ap__b___0 = b;
      while (1) {
        ap__b___0->link.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                    (char *)((void *)0)));
        ap__b___0->link.prev = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                     (char *)((void *)0))))->link.prev;
        (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                               (char *)((void *)0))))->link.prev)->link.next = ap__b___0;
        ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                              (char *)((void *)0))))->link.prev = ap__b___0;
        break;
      }
      break;
    }
    rv = ap_pass_brigade(r->output_filters, bb);
    if (rv != 0) {
      ap_log_rerror("mod_asis.c", 161, 3, rv, (request_rec const   *)r, "mod_asis: ap_pass_brigade failed for file %s",
                    r->filename);
      return (500);
    }
  } else {
    apr_file_close(f);
  }
  return (0);
}
}
static void register_hooks___9(apr_pool_t *p ) 
{ 

  {
  ap_hook_handler(& asis_handler, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                  10);
  return;
}
}
struct module_struct asis_module  = 
     {20020903, 0, -1, "mod_asis.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, (void (*)(process_rec *process ))((void *)0), (void *(*)(apr_pool_t *p ,
                                                                           char *dir ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), (void *(*)(apr_pool_t *p ,
                                                                                          server_rec *s ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), (command_rec const   *)((void *)0),
    & register_hooks___9};
#pragma merger(0,"/tmp/cil-ElejWFTJ.i","-g -pthread")
apr_status_t apr_ctime(char *date_str , apr_time_t t ) ;
apr_status_t apr_file_write_full(apr_file_t *thefile , void const   *buf , apr_size_t nbytes ,
                                 apr_size_t *bytes_written ) ;
apr_status_t apr_file_gets(char *str , int len , apr_file_t *thefile ) ;
apr_status_t apr_file_puts(char const   *str , apr_file_t *thefile ) ;
apr_status_t apr_file_flush(apr_file_t *thefile ) ;
apr_status_t apr_file_pipe_timeout_set(apr_file_t *thepipe , apr_interval_time_t timeout ) ;
int ( /* format attribute */  apr_file_printf)(apr_file_t *fptr , char const   *format 
                                               , ...) ;
apr_status_t apr_procattr_create(apr_procattr_t **new , apr_pool_t *pool ) ;
apr_status_t apr_procattr_io_set(apr_procattr_t *attr , apr_int32_t in , apr_int32_t out ,
                                 apr_int32_t err ) ;
apr_status_t apr_procattr_dir_set(apr_procattr_t *attr , char const   *dir ) ;
apr_status_t apr_procattr_cmdtype_set(apr_procattr_t *attr , apr_cmdtype_e cmd ) ;
apr_status_t apr_procattr_detach_set(apr_procattr_t *attr , apr_int32_t detach ) ;
apr_status_t apr_procattr_limit_set(apr_procattr_t *attr , apr_int32_t what , struct rlimit *limit ) ;
void apr_pool_note_subprocess(apr_pool_t *pool , apr_proc_t *pid , apr_kill_conditions_e how ) ;
apr_bucket *apr_bucket_pipe_create(apr_file_t *p , apr_bucket_alloc_t *list ) ;
char const   *apr_filename_of_pathname(char const   *pathname ) ;
char *ap_getword_nulls(apr_pool_t *atrans , char const   **line , char stop ) ;
char *ap_make_dirstr_parent(apr_pool_t *p , char const   *s ) ;
char **ap_create_environment(apr_pool_t *p , apr_table_t *t ) ;
int ap_scan_script_header_err_brigade(request_rec *r , apr_bucket_brigade *bb , char *buffer ) ;
apr_status_t ap_os_create_privileged_process(request_rec const   *r , apr_proc_t *newproc ,
                                             char const   *progname , char const   * const  *args ,
                                             char const   * const  *env , apr_procattr_t *attr ,
                                             apr_pool_t *p ) ;
static apr_OFN_ap_register_include_handler_t *cgi_pfn_reg_with_ssi  ;
static apr_OFN_ap_ssi_get_tag_and_value_t *cgi_pfn_gtv  ;
static apr_OFN_ap_ssi_parse_string_t *cgi_pfn_ps  ;
static apr_OFN_ap_cgi_build_command_t *cgi_build_command  ;
static void discard_script_output(apr_bucket_brigade *bb ) ;
static int is_scriptaliased(request_rec *r ) 
{ char const   *t ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = apr_table_get((apr_table_t const   *)r->notes, "alias-forced-type");
  t = tmp;
  if (t) {
    tmp___0 = strcasecmp(t, "cgi-script");
    if (tmp___0) {
      goto _L;
    } else {
      tmp___1 = 1;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
static void *create_cgi_config(apr_pool_t *p , server_rec *s ) 
{ cgi_server_conf *c ;
  void *tmp ;
  cgi_server_conf *tmp___0 ;

  {
  tmp = apr_palloc(p, sizeof(cgi_server_conf ));
  tmp___0 = (cgi_server_conf *)memset(tmp, 0, sizeof(cgi_server_conf ));
  c = tmp___0;
  c->logname = (char const   *)((void *)0);
  c->logbytes = 10385760L;
  c->bufbytes = 1024U;
  return ((void *)c);
}
}
static void *merge_cgi_config(apr_pool_t *p , void *basev , void *overridesv ) 
{ cgi_server_conf *base ;
  cgi_server_conf *overrides ;
  cgi_server_conf *tmp ;

  {
  base = (cgi_server_conf *)basev;
  overrides = (cgi_server_conf *)overridesv;
  if (overrides->logname) {
    tmp = overrides;
  } else {
    tmp = base;
  }
  return ((void *)tmp);
}
}
static char const   *set_scriptlog(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ server_rec *s ;
  cgi_server_conf *conf ;
  char const   *tmp ;

  {
  s = cmd->server;
  conf = (cgi_server_conf *)(*((void **)s->module_config + cgi_module.module_index));
  conf->logname = ap_server_root_relative(cmd->pool, arg);
  if (! conf->logname) {
    tmp = apr_pstrcat(cmd->pool, "Invalid ScriptLog path ", arg, (void *)0);
    return (tmp);
  }
  return ((char const   *)((void *)0));
}
}
static char const   *set_scriptlog_length(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ server_rec *s ;
  cgi_server_conf *conf ;

  {
  s = cmd->server;
  conf = (cgi_server_conf *)(*((void **)s->module_config + cgi_module.module_index));
  conf->logbytes = atol(arg);
  return ((char const   *)((void *)0));
}
}
static char const   *set_scriptlog_buffer(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ server_rec *s ;
  cgi_server_conf *conf ;

  {
  s = cmd->server;
  conf = (cgi_server_conf *)(*((void **)s->module_config + cgi_module.module_index));
  conf->bufbytes = (apr_size_t )atoi(arg);
  return ((char const   *)((void *)0));
}
}
static command_rec const   cgi_cmds[4]  = {      {"ScriptLog", {& set_scriptlog}, (void *)0, 128, 1, "the name of a log for script debugging info"}, 
        {"ScriptLogLength",
      {& set_scriptlog_length}, (void *)0, 128, 1, "the maximum length (in bytes) of the script debug log"}, 
        {"ScriptLogBuffer",
      {& set_scriptlog_buffer}, (void *)0, 128, 1, "the maximum size (in bytes) to record of a POST request"}, 
        {(char const   *)((void *)0),
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))0}, (void *)0,
      0, 0, (char const   *)0}};
static int log_scripterror(request_rec *r , cgi_server_conf *conf , int ret , apr_status_t rv ,
                           char *error ) 
{ apr_file_t *f ;
  apr_finfo_t finfo ;
  char time_str[25] ;
  int log_flags ;
  int tmp ;
  apr_status_t tmp___0 ;
  apr_status_t tmp___1 ;
  apr_time_t tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
  f = (apr_file_t *)((void *)0);
  if (rv) {
    tmp = 3;
  } else {
    tmp = 3;
  }
  log_flags = tmp;
  ap_log_rerror("mod_cgi.c", 208, log_flags, rv, (request_rec const   *)r, "%s: %s",
                error, r->filename);
  if (! conf->logname) {
    goto _L___0;
  } else {
    tmp___0 = apr_stat(& finfo, conf->logname, 256, r->pool);
    if (tmp___0 == 0) {
      if (finfo.size > conf->logbytes) {
        _L___0: /* CIL Label */ 
        goto _L;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      tmp___1 = apr_file_open(& f, conf->logname, 14, 4095, r->pool);
      if (tmp___1 != 0) {
        _L: /* CIL Label */ 
        return (ret);
      }
    }
  }
  tmp___2 = apr_time_now();
  apr_ctime(time_str, tmp___2);
  if (r->args) {
    tmp___3 = (char const   *)r->args;
  } else {
    tmp___3 = "";
  }
  if (r->args) {
    tmp___4 = "?";
  } else {
    tmp___4 = "";
  }
  apr_file_printf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri, tmp___4,
                  tmp___3, r->protocol);
  apr_file_printf(f, "%%%% %d %s\n", ret, r->filename);
  apr_file_printf(f, "%%error\n%s\n", error);
  apr_file_close(f);
  return (ret);
}
}
static void log_script_err(request_rec *r , apr_file_t *script_err ) 
{ char argsbuffer[8192] ;
  char *newline ;
  apr_status_t tmp ;

  {
  while (1) {
    tmp = apr_file_gets(argsbuffer, 8192, script_err);
    if (! (tmp == 0)) {
      break;
    }
    newline = strchr((char const   *)(argsbuffer), '\n');
    if (newline) {
      (*newline) = (char )'\000';
    }
    ap_log_rerror("mod_cgi.c", 248, 3, 0, (request_rec const   *)r, "%s", argsbuffer);
  }
  return;
}
}
static int log_script(request_rec *r , cgi_server_conf *conf , int ret , char *dbuf ,
                      char const   *sbuf , apr_bucket_brigade *bb , apr_file_t *script_err ) 
{ apr_array_header_t const   *hdrs_arr ;
  apr_array_header_t const   *tmp ;
  apr_table_entry_t const   *hdrs ;
  char argsbuffer[8192] ;
  apr_file_t *f ;
  apr_bucket *e ;
  char const   *buf ;
  apr_size_t len ;
  apr_status_t rv ;
  int first ;
  int i ;
  apr_finfo_t finfo ;
  char time_str[25] ;
  apr_status_t tmp___0 ;
  apr_status_t tmp___1 ;
  apr_time_t tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  apr_status_t tmp___5 ;
  apr_status_t tmp___6 ;

  {
  tmp = apr_table_elts((apr_table_t const   *)r->headers_in);
  hdrs_arr = tmp;
  hdrs = (apr_table_entry_t const   *)hdrs_arr->elts;
  f = (apr_file_t *)((void *)0);
  if (! conf->logname) {
    goto _L___0;
  } else {
    tmp___0 = apr_stat(& finfo, conf->logname, 256, r->pool);
    if (tmp___0 == 0) {
      if (finfo.size > conf->logbytes) {
        _L___0: /* CIL Label */ 
        goto _L;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      tmp___1 = apr_file_open(& f, conf->logname, 14, 4095, r->pool);
      if (tmp___1 != 0) {
        _L: /* CIL Label */ 
        discard_script_output(bb);
        log_script_err(r, script_err);
        return (ret);
      }
    }
  }
  tmp___2 = apr_time_now();
  apr_ctime(time_str, tmp___2);
  if (r->args) {
    tmp___3 = (char const   *)r->args;
  } else {
    tmp___3 = "";
  }
  if (r->args) {
    tmp___4 = "?";
  } else {
    tmp___4 = "";
  }
  apr_file_printf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri, tmp___4,
                  tmp___3, r->protocol);
  apr_file_printf(f, "%%%% %d %s\n", ret, r->filename);
  apr_file_puts("%request\n", f);
  i = 0;
  while (i < hdrs_arr->nelts) {
    if (! (hdrs + i)->key) {
      goto __Cont;
    }
    apr_file_printf(f, "%s: %s\n", (hdrs + i)->key, (hdrs + i)->val);
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (r->method_number == 2) {
    goto _L___3;
  } else {
    if (r->method_number == 1) {
      _L___3: /* CIL Label */ 
      if ((*dbuf)) {
        apr_file_printf(f, "\n%s\n", dbuf);
      } else {
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ ;
    }
  }
  apr_file_puts("%response\n", f);
  hdrs_arr = apr_table_elts((apr_table_t const   *)r->err_headers_out);
  hdrs = (apr_table_entry_t const   *)hdrs_arr->elts;
  i = 0;
  while (i < hdrs_arr->nelts) {
    if (! (hdrs + i)->key) {
      goto __Cont___0;
    }
    apr_file_printf(f, "%s: %s\n", (hdrs + i)->key, (hdrs + i)->val);
    __Cont___0: /* CIL Label */ 
    i ++;
  }
  if (sbuf) {
    if ((*sbuf)) {
      apr_file_printf(f, "%s\n", sbuf);
    } else {
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ ;
  }
  first = 1;
  e = bb->list.next;
  while ((unsigned int )e != (unsigned int )((struct apr_bucket *)((char *)(& bb->list) -
                                                                   (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                           (char *)((void *)0))))) {
    if ((unsigned int )e->type == (unsigned int )(& apr_bucket_type_eos)) {
      break;
    }
    rv = ((*((e->type)->read)))(e, & buf, & len, 0);
    if (rv != 0) {
      goto _L___5;
    } else {
      if (len == 0U) {
        _L___5: /* CIL Label */ 
        break;
      }
    }
    if (first) {
      apr_file_puts("%stdout\n", f);
      first = 0;
    }
    apr_file_write(f, (void const   *)buf, & len);
    apr_file_puts("\n", f);
    e = e->link.next;
  }
  tmp___6 = apr_file_gets(argsbuffer, 8192, script_err);
  if (tmp___6 == 0) {
    apr_file_puts("%stderr\n", f);
    apr_file_puts((char const   *)(argsbuffer), f);
    while (1) {
      tmp___5 = apr_file_gets(argsbuffer, 8192, script_err);
      if (! (tmp___5 == 0)) {
        break;
      }
      apr_file_puts((char const   *)(argsbuffer), f);
    }
    apr_file_puts("\n", f);
  }
  apr_brigade_destroy(bb);
  apr_file_close(script_err);
  apr_file_close(f);
  return (ret);
}
}
static void add_ssi_vars(request_rec *r ) 
{ apr_table_t *e ;
  request_rec *pa_req ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *arg_copy ;
  char *tmp___2 ;
  char const   *tmp___3 ;

  {
  e = r->subprocess_env;
  if (r->path_info) {
    if ((int )(*(r->path_info + 0)) != 0) {
      tmp = ap_escape_shell_cmd(r->pool, (char const   *)r->path_info);
      apr_table_setn(e, "PATH_INFO", tmp);
      tmp___0 = ap_os_escape_path(r->pool, (char const   *)r->path_info, 1);
      pa_req = ap_sub_req_lookup_uri(tmp___0, (request_rec const   *)r, (ap_filter_t *)((void *)0));
      if (pa_req->filename) {
        tmp___1 = apr_pstrcat(r->pool, pa_req->filename, pa_req->path_info, (void *)0);
        apr_table_setn(e, "PATH_TRANSLATED", tmp___1);
      }
      ap_destroy_sub_req(pa_req);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  if (r->args) {
    tmp___2 = apr_pstrdup(r->pool, (char const   *)r->args);
    arg_copy = tmp___2;
    apr_table_setn(e, "QUERY_STRING", (char const   *)r->args);
    ap_unescape_url(arg_copy);
    tmp___3 = ap_escape_shell_cmd(r->pool, (char const   *)arg_copy);
    apr_table_setn(e, "QUERY_STRING_UNESCAPED", tmp___3);
  }
  return;
}
}
static apr_status_t run_cgi_child(apr_file_t **script_out , apr_file_t **script_in ,
                                  apr_file_t **script_err , char const   *command ,
                                  char const   * const  *argv , request_rec *r , apr_pool_t *p ,
                                  cgi_exec_info_t *e_info ) 
{ char const   * const  *env ;
  apr_procattr_t *procattr ;
  apr_proc_t *procnew ;
  apr_status_t rc ;
  core_dir_config *conf ;
  void *tmp___0 ;
  apr_bucket_brigade *tag_plus ;
  apr_bucket *ap__b ;
  apr_bucket *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  rc = 0;
  conf = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  env = ap_create_environment(p, r->subprocess_env);
  rc = apr_procattr_create(& procattr, p);
  if (rc != 0) {
    goto _L___6;
  } else {
    rc = apr_procattr_io_set(procattr, e_info->in_pipe, e_info->out_pipe, e_info->err_pipe);
    if (rc != 0) {
      _L___6: /* CIL Label */ 
      goto _L___5;
    } else {
      tmp___3 = ap_make_dirstr_parent(r->pool, (char const   *)r->filename);
      rc = apr_procattr_dir_set(procattr, tmp___3);
      if (rc != 0) {
        _L___5: /* CIL Label */ 
        goto _L___4;
      } else {
        rc = apr_procattr_limit_set(procattr, 0, conf->limit_cpu);
        if (rc != 0) {
          _L___4: /* CIL Label */ 
          goto _L___3;
        } else {
          rc = apr_procattr_limit_set(procattr, 1, conf->limit_mem);
          if (rc != 0) {
            _L___3: /* CIL Label */ 
            goto _L___2;
          } else {
            rc = apr_procattr_limit_set(procattr, 2, conf->limit_nproc);
            if (rc != 0) {
              _L___2: /* CIL Label */ 
              goto _L___1;
            } else {
              rc = apr_procattr_cmdtype_set(procattr, e_info->cmd_type);
              if (rc != 0) {
                _L___1: /* CIL Label */ 
                goto _L___0;
              } else {
                rc = apr_procattr_detach_set(procattr, e_info->detached);
                if (rc != 0) {
                  _L___0: /* CIL Label */ 
                  ap_log_rerror("mod_cgi.c", 457, 3, rc, (request_rec const   *)r,
                                "couldn\'t set child process attributes: %s", r->filename);
                } else {
                  tmp___0 = apr_palloc(p, sizeof((*procnew)));
                  procnew = (apr_proc_t *)memset(tmp___0, 0, sizeof((*procnew)));
                  if ((int )e_info->prog_type == 0) {
                    if ((unsigned int )((e_info->ctx)->ssi_tag_brigade)->list.next ==
                        (unsigned int )((struct apr_bucket *)((char *)(& ((e_info->ctx)->ssi_tag_brigade)->list) -
                                                              (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                      (char *)((void *)0))))) {
                      if ((unsigned int )(e_info->ctx)->head_start_bucket != (unsigned int )((void *)0)) {
                        tag_plus = apr_brigade_split((*(e_info->bb)), (e_info->ctx)->head_start_bucket);
                        if ((e_info->ctx)->output_flush) {
                          while (1) {
                            tmp___1 = apr_bucket_flush_create(((*(e_info->bb)))->bucket_alloc);
                            ap__b = tmp___1;
                            while (1) {
                              ap__b->link.next = (struct apr_bucket *)((char *)(& ((*(e_info->bb)))->list) -
                                                                       (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                               (char *)((void *)0)));
                              ap__b->link.prev = ((struct apr_bucket *)((char *)(& ((*(e_info->bb)))->list) -
                                                                        (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                (char *)((void *)0))))->link.prev;
                              (((struct apr_bucket *)((char *)(& ((*(e_info->bb)))->list) -
                                                      (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                              (char *)((void *)0))))->link.prev)->link.next = ap__b;
                              ((struct apr_bucket *)((char *)(& ((*(e_info->bb)))->list) -
                                                     (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                             (char *)((void *)0))))->link.prev = ap__b;
                              break;
                            }
                            break;
                          }
                        }
                        rc = ap_pass_brigade(e_info->next, (*(e_info->bb)));
                        (e_info->ctx)->bytes_parsed = 0;
                        (*(e_info->bb)) = tag_plus;
                      } else {
                        goto _L;
                      }
                    } else {
                      _L: /* CIL Label */ ;
                    }
                    if (rc != 0) {
                      return (rc);
                    }
                  }
                  rc = ap_os_create_privileged_process((request_rec const   *)r, procnew,
                                                       command, argv, env, procattr,
                                                       p);
                  if (rc != 0) {
                    tmp___2 = apr_filename_of_pathname((char const   *)r->filename);
                    ap_log_rerror("mod_cgi.c", 475, 19, rc, (request_rec const   *)r,
                                  "couldn\'t create child process: %d: %s", rc, tmp___2);
                  } else {
                    apr_pool_note_subprocess(p, procnew, 2);
                    (*script_in) = procnew->out;
                    if (! (*script_in)) {
                      return (9);
                    }
                    apr_file_pipe_timeout_set((*script_in), (r->server)->timeout);
                    if ((int )e_info->prog_type == 1) {
                      (*script_out) = procnew->in;
                      if (! (*script_out)) {
                        return (9);
                      }
                      apr_file_pipe_timeout_set((*script_out), (r->server)->timeout);
                      (*script_err) = procnew->err;
                      if (! (*script_err)) {
                        return (9);
                      }
                      apr_file_pipe_timeout_set((*script_err), (r->server)->timeout);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return (rc);
}
}
static apr_status_t default_build_command(char const   **cmd , char const   ***argv ,
                                          request_rec *r , apr_pool_t *p , cgi_exec_info_t *e_info ) 
{ int numwords ;
  int x ;
  int idx ;
  char *w ;
  char const   *args ;
  char *tmp ;
  int tmp___0 ;

  {
  args = (char const   *)((void *)0);
  if (e_info->process_cgi) {
    (*cmd) = (char const   *)r->filename;
    if (r->args) {
      if ((*(r->args + 0))) {
        tmp = strchr((char const   *)r->args, '=');
        if (tmp) {
          goto _L___0;
        } else {
          args = (char const   *)r->args;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
  }
  if (! args) {
    numwords = 1;
  } else {
    x = 0;
    numwords = 2;
    while ((*(args + x))) {
      if ((int const   )(*(args + x)) == 43) {
        numwords ++;
      }
      x ++;
    }
  }
  if (numwords > 4095) {
    numwords = 4095;
  }
  (*argv) = (char const   **)apr_palloc(p, (unsigned int )(numwords + 2) * sizeof(char *));
  (*((*argv) + 0)) = (*cmd);
  x = 1;
  idx = 1;
  while (x < numwords) {
    w = ap_getword_nulls(p, & args, (char )'+');
    ap_unescape_url(w);
    tmp___0 = idx;
    idx ++;
    (*((*argv) + tmp___0)) = ap_escape_shell_cmd(p, (char const   *)w);
    x ++;
  }
  (*((*argv) + idx)) = (char const   *)((void *)0);
  return (0);
}
}
static void discard_script_output(apr_bucket_brigade *bb ) 
{ apr_bucket *e ;
  char const   *buf ;
  apr_size_t len ;
  apr_status_t rv ;

  {
  e = bb->list.next;
  while ((unsigned int )e != (unsigned int )((struct apr_bucket *)((char *)(& bb->list) -
                                                                   (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                           (char *)((void *)0))))) {
    if ((unsigned int )e->type == (unsigned int )(& apr_bucket_type_eos)) {
      break;
    }
    rv = ((*((e->type)->read)))(e, & buf, & len, 0);
    if (rv != 0) {
      break;
    }
    e = e->link.next;
  }
  return;
}
}
static int cgi_handler(request_rec *r ) 
{ int nph ;
  apr_size_t dbpos ;
  char const   *argv0 ;
  char const   *command ;
  char const   **argv ;
  char *dbuf ;
  apr_file_t *script_out ;
  apr_file_t *script_in ;
  apr_file_t *script_err ;
  apr_bucket_brigade *bb ;
  apr_bucket *b ;
  int is_included ;
  int seen_eos ;
  int child_stopped_reading ;
  apr_pool_t *p ;
  cgi_server_conf *conf ;
  apr_status_t rv ;
  cgi_exec_info_t e_info ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  apr_bucket *bucket ;
  char const   *data ;
  apr_size_t len ;
  int cursize ;
  conn_rec *c ;
  char const   *location ;
  char sbuf[8192] ;
  int ret ;
  apr_bucket *ap__b ;
  apr_bucket *ap__b___0 ;
  int tmp___12 ;
  conn_rec *c___0 ;
  struct ap_filter_t *cur ;
  apr_bucket *ap__b___1 ;
  apr_bucket *ap__b___2 ;

  {
  dbpos = (apr_size_t )0;
  dbuf = (char *)((void *)0);
  script_out = (apr_file_t *)((void *)0);
  script_in = (apr_file_t *)((void *)0);
  script_err = (apr_file_t *)((void *)0);
  tmp = strcmp(r->handler, "application/x-httpd-cgi");
  if (tmp) {
    tmp___0 = strcmp(r->handler, "cgi-script");
    if (tmp___0) {
      return (-1);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  tmp___1 = strcmp((char const   *)r->protocol, "INCLUDED");
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  is_included = tmp___2;
  if (r->main) {
    p = (r->main)->pool;
  } else {
    p = r->pool;
  }
  if (r->method_number == 5) {
    r->allowed = r->allowed | 1LL;
    r->allowed = r->allowed | 4LL;
    return (-1);
  }
  argv0 = apr_filename_of_pathname((char const   *)r->filename);
  tmp___3 = strncmp(argv0, "nph-", 4U);
  if (tmp___3) {
    tmp___4 = 0;
  } else {
    tmp___4 = 1;
  }
  nph = tmp___4;
  conf = (cgi_server_conf *)(*((void **)(r->server)->module_config + cgi_module.module_index));
  tmp___6 = ap_allow_options(r);
  if (tmp___6 & 8) {
    _L___0: /* CIL Label */ ;
  } else {
    tmp___7 = is_scriptaliased(r);
    if (tmp___7) {
      goto _L___0;
    } else {
      tmp___5 = log_scripterror(r, conf, 403, 0, (char *)"Options ExecCGI is off in this directory");
      return (tmp___5);
    }
  }
  if (nph) {
    if (is_included) {
      tmp___8 = log_scripterror(r, conf, 403, 0, (char *)"attempt to include NPH CGI script");
      return (tmp___8);
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
  if ((int )r->finfo.filetype == 0) {
    tmp___9 = log_scripterror(r, conf, 404, 0, (char *)"script not found or unable to stat");
    return (tmp___9);
  }
  if ((int )r->finfo.filetype == 2) {
    tmp___10 = log_scripterror(r, conf, 403, 0, (char *)"attempt to invoke directory as script");
    return (tmp___10);
  }
  if (r->used_path_info == 1) {
    if (r->path_info) {
      if ((*(r->path_info))) {
        tmp___11 = log_scripterror(r, conf, 404, 0, (char *)"AcceptPathInfo off disallows user\'s path");
        return (tmp___11);
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ ;
  }
  ap_add_common_vars(r);
  ap_add_cgi_vars(r);
  e_info.process_cgi = 1;
  e_info.cmd_type = 1;
  e_info.detached = 0;
  e_info.in_pipe = 4;
  e_info.out_pipe = 4;
  e_info.err_pipe = 4;
  e_info.prog_type = 1;
  e_info.bb = (apr_bucket_brigade **)((void *)0);
  e_info.ctx = (include_ctx_t *)((void *)0);
  e_info.next = (ap_filter_t *)((void *)0);
  rv = ((*cgi_build_command))(& command, & argv, r, p, & e_info);
  if (rv != 0) {
    ap_log_rerror("mod_cgi.c", 651, 3, rv, (request_rec const   *)r, "don\'t know how to spawn child process: %s",
                  r->filename);
    return (500);
  }
  rv = run_cgi_child(& script_out, & script_in, & script_err, command, (char const   * const  *)argv,
                     r, p, & e_info);
  if (rv != 0) {
    ap_log_rerror("mod_cgi.c", 660, 3, rv, (request_rec const   *)r, "couldn\'t spawn child process: %s",
                  r->filename);
    return (500);
  }
  bb = apr_brigade_create(r->pool, (r->connection)->bucket_alloc);
  seen_eos = 0;
  child_stopped_reading = 0;
  if (conf->logname) {
    dbuf = (char *)apr_palloc(r->pool, conf->bufbytes + 1U);
    dbpos = 0U;
  }
  while (1) {
    rv = ap_get_brigade(r->input_filters, bb, 0, 0, 8192L);
    if (rv != 0) {
      return (rv);
    }
    bucket = bb->list.next;
    while ((unsigned int )bucket != (unsigned int )((struct apr_bucket *)((char *)(& bb->list) -
                                                                          (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                  (char *)((void *)0))))) {
      if ((unsigned int )bucket->type == (unsigned int )(& apr_bucket_type_eos)) {
        seen_eos = 1;
        break;
      }
      if ((unsigned int )bucket->type == (unsigned int )(& apr_bucket_type_flush)) {
        goto __Cont;
      }
      if (child_stopped_reading) {
        goto __Cont;
      }
      ((*((bucket->type)->read)))(bucket, & data, & len, 0);
      if (conf->logname) {
        if (dbpos < conf->bufbytes) {
          if (dbpos + len > conf->bufbytes) {
            cursize = (int )(conf->bufbytes - dbpos);
          } else {
            cursize = (int )len;
          }
          memcpy((void * __restrict  )(dbuf + dbpos), (void const   * __restrict  )data,
                 (unsigned int )cursize);
          dbpos += (apr_size_t )cursize;
        } else {
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ ;
      }
      rv = apr_file_write_full(script_out, (void const   *)data, len, (apr_size_t *)((void *)0));
      if (rv != 0) {
        child_stopped_reading = 1;
      }
      __Cont: /* CIL Label */ 
      bucket = bucket->link.next;
    }
    apr_brigade_cleanup((void *)bb);
    if (! (! seen_eos)) {
      break;
    }
  }
  if (conf->logname) {
    (*(dbuf + dbpos)) = (char )'\000';
  }
  apr_file_flush(script_out);
  apr_file_close(script_out);
  if (script_in) {
    if (! nph) {
      c = r->connection;
      b = apr_bucket_pipe_create(script_in, c->bucket_alloc);
      while (1) {
        ap__b = b;
        while (1) {
          ap__b->link.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                  (char *)((void *)0)));
          ap__b->link.prev = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                   (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0))))->link.prev)->link.next = ap__b;
          ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0))))->link.prev = ap__b;
          break;
        }
        break;
      }
      b = apr_bucket_eos_create(c->bucket_alloc);
      while (1) {
        ap__b___0 = b;
        while (1) {
          ap__b___0->link.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                      (char *)((void *)0)));
          ap__b___0->link.prev = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0))))->link.prev)->link.next = ap__b___0;
          ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0))))->link.prev = ap__b___0;
          break;
        }
        break;
      }
      ret = ap_scan_script_header_err_brigade(r, bb, sbuf);
      if (ret) {
        tmp___12 = log_script(r, conf, ret, dbuf, (char const   *)(sbuf), bb, script_err);
        return (tmp___12);
      }
      location = apr_table_get((apr_table_t const   *)r->headers_out, "Location");
      if (location) {
        if ((int const   )(*(location + 0)) == 47) {
          if (r->status == 200) {
            discard_script_output(bb);
            apr_brigade_destroy(bb);
            log_script_err(r, script_err);
            r->method = apr_pstrdup(r->pool, "GET");
            r->method_number = 0;
            apr_table_unset(r->headers_in, "Content-Length");
            ap_internal_redirect_handler(location, r);
            return (0);
          } else {
            goto _L___7;
          }
        } else {
          goto _L___7;
        }
      } else {
        _L___7: /* CIL Label */ 
        if (location) {
          if (r->status == 200) {
            discard_script_output(bb);
            apr_brigade_destroy(bb);
            return (302);
          } else {
            goto _L___5;
          }
        } else {
          _L___5: /* CIL Label */ ;
        }
      }
      rv = ap_pass_brigade(r->output_filters, bb);
      if (rv == 0) {
        if (! (r->connection)->aborted) {
          log_script_err(r, script_err);
        } else {
          goto _L___8;
        }
      } else {
        _L___8: /* CIL Label */ ;
      }
      apr_file_close(script_err);
    } else {
      goto _L___9;
    }
  } else {
    _L___9: /* CIL Label */ ;
  }
  if (script_in) {
    if (nph) {
      c___0 = r->connection;
      cur = r->proto_output_filters;
      while (1) {
        if (cur) {
          if (! ((int )(cur->frec)->ftype < 50)) {
            goto _L___10;
          }
        } else {
          _L___10: /* CIL Label */ 
          break;
        }
        cur = cur->next;
      }
      r->proto_output_filters = cur;
      r->output_filters = r->proto_output_filters;
      bb = apr_brigade_create(r->pool, c___0->bucket_alloc);
      b = apr_bucket_pipe_create(script_in, c___0->bucket_alloc);
      while (1) {
        ap__b___1 = b;
        while (1) {
          ap__b___1->link.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                      (char *)((void *)0)));
          ap__b___1->link.prev = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0))))->link.prev)->link.next = ap__b___1;
          ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0))))->link.prev = ap__b___1;
          break;
        }
        break;
      }
      b = apr_bucket_eos_create(c___0->bucket_alloc);
      while (1) {
        ap__b___2 = b;
        while (1) {
          ap__b___2->link.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                      (char *)((void *)0)));
          ap__b___2->link.prev = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0))))->link.prev)->link.next = ap__b___2;
          ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0))))->link.prev = ap__b___2;
          break;
        }
        break;
      }
      ap_pass_brigade(r->output_filters, bb);
    } else {
      goto _L___11;
    }
  } else {
    _L___11: /* CIL Label */ ;
  }
  return (0);
}
}
static int include_cgi(char *s , request_rec *r , ap_filter_t *next , apr_bucket *head_ptr ,
                       apr_bucket **inserted_head ) 
{ request_rec *rr ;
  request_rec *tmp ;
  int rr_status ;
  apr_bucket *tmp_buck ;
  apr_bucket *tmp2_buck ;
  apr_size_t len_loc ;
  char const   *location ;
  char const   *tmp___0 ;
  conn_rec *c ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b ;
  apr_bucket *ap__a___0 ;
  apr_bucket *ap__b___0 ;
  apr_bucket *ap__a___1 ;
  apr_bucket *ap__b___1 ;
  apr_bucket *ap__a___2 ;
  apr_bucket *ap__b___2 ;
  apr_bucket *ap__a___3 ;
  apr_bucket *ap__b___3 ;

  {
  tmp = ap_sub_req_lookup_uri((char const   *)s, (request_rec const   *)r, next);
  rr = tmp;
  if (rr->status != 200) {
    ap_destroy_sub_req(rr);
    return (-1);
  }
  if (rr->path_info) {
    if ((*(rr->path_info + 0))) {
      goto _L;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (rr->args) {
      _L: /* CIL Label */ 
      ap_destroy_sub_req(rr);
      return (-1);
    }
  }
  if ((int )rr->finfo.filetype != 1) {
    ap_destroy_sub_req(rr);
    return (-1);
  }
  rr->path_info = r->path_info;
  rr->args = r->args;
  ap_set_content_type(rr, "application/x-httpd-cgi");
  rr_status = ap_run_sub_req(rr);
  if (rr_status >= 300) {
    if (rr_status < 400) {
      tmp___0 = apr_table_get((apr_table_t const   *)rr->headers_out, "Location");
      location = tmp___0;
      c = r->connection;
      location = ap_escape_html(rr->pool, location);
      len_loc = strlen(location);
      tmp_buck = apr_bucket_immortal_create("<A HREF=\"", sizeof("<A HREF=\"") - 1U,
                                            c->bucket_alloc);
      while (1) {
        ap__a = head_ptr;
        ap__b = tmp_buck;
        while (1) {
          ap__b->link.next = ap__a;
          ap__b->link.prev = ap__a->link.prev;
          (ap__a->link.prev)->link.next = ap__b;
          ap__a->link.prev = ap__b;
          break;
        }
        break;
      }
      tmp2_buck = apr_bucket_heap_create(location, len_loc, (void (*)(void *data ))((void *)0),
                                         c->bucket_alloc);
      while (1) {
        ap__a___0 = head_ptr;
        ap__b___0 = tmp2_buck;
        while (1) {
          ap__b___0->link.next = ap__a___0;
          ap__b___0->link.prev = ap__a___0->link.prev;
          (ap__a___0->link.prev)->link.next = ap__b___0;
          ap__a___0->link.prev = ap__b___0;
          break;
        }
        break;
      }
      tmp2_buck = apr_bucket_immortal_create("\">", sizeof("\">") - 1U, c->bucket_alloc);
      while (1) {
        ap__a___1 = head_ptr;
        ap__b___1 = tmp2_buck;
        while (1) {
          ap__b___1->link.next = ap__a___1;
          ap__b___1->link.prev = ap__a___1->link.prev;
          (ap__a___1->link.prev)->link.next = ap__b___1;
          ap__a___1->link.prev = ap__b___1;
          break;
        }
        break;
      }
      tmp2_buck = apr_bucket_heap_create(location, len_loc, (void (*)(void *data ))((void *)0),
                                         c->bucket_alloc);
      while (1) {
        ap__a___2 = head_ptr;
        ap__b___2 = tmp2_buck;
        while (1) {
          ap__b___2->link.next = ap__a___2;
          ap__b___2->link.prev = ap__a___2->link.prev;
          (ap__a___2->link.prev)->link.next = ap__b___2;
          ap__a___2->link.prev = ap__b___2;
          break;
        }
        break;
      }
      tmp2_buck = apr_bucket_immortal_create("</A>", sizeof("</A>") - 1U, c->bucket_alloc);
      while (1) {
        ap__a___3 = head_ptr;
        ap__b___3 = tmp2_buck;
        while (1) {
          ap__b___3->link.next = ap__a___3;
          ap__b___3->link.prev = ap__a___3->link.prev;
          (ap__a___3->link.prev)->link.next = ap__b___3;
          ap__a___3->link.prev = ap__b___3;
          break;
        }
        break;
      }
      if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
        (*inserted_head) = tmp_buck;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
  ap_destroy_sub_req(rr);
  return (0);
}
}
static int include_cmd(include_ctx_t *ctx , apr_bucket_brigade **bb , char const   *command ,
                       request_rec *r , ap_filter_t *f ) 
{ cgi_exec_info_t e_info ;
  char const   **argv ;
  apr_file_t *script_out ;
  apr_file_t *script_in ;
  apr_file_t *script_err ;
  apr_bucket_brigade *bcgi ;
  apr_bucket *b ;
  apr_status_t rv ;
  apr_bucket *ap__b ;

  {
  script_out = (apr_file_t *)((void *)0);
  script_in = (apr_file_t *)((void *)0);
  script_err = (apr_file_t *)((void *)0);
  add_ssi_vars(r);
  e_info.process_cgi = 0;
  e_info.cmd_type = 0;
  e_info.detached = 0;
  e_info.in_pipe = 0;
  e_info.out_pipe = 1;
  e_info.err_pipe = 0;
  e_info.prog_type = 0;
  e_info.bb = bb;
  e_info.ctx = ctx;
  e_info.next = f->next;
  rv = ((*cgi_build_command))(& command, & argv, r, r->pool, & e_info);
  if (rv != 0) {
    ap_log_rerror("mod_cgi.c", 935, 3, rv, (request_rec const   *)r, "don\'t know how to spawn cmd child process: %s",
                  r->filename);
    return (500);
  }
  rv = run_cgi_child(& script_out, & script_in, & script_err, command, (char const   * const  *)argv,
                     r, r->pool, & e_info);
  if (rv != 0) {
    ap_log_rerror("mod_cgi.c", 945, 3, rv, (request_rec const   *)r, "couldn\'t spawn child process: %s",
                  r->filename);
    return (500);
  }
  bcgi = apr_brigade_create(r->pool, (f->c)->bucket_alloc);
  b = apr_bucket_pipe_create(script_in, (f->c)->bucket_alloc);
  while (1) {
    ap__b = b;
    while (1) {
      ap__b->link.next = (struct apr_bucket *)((char *)(& bcgi->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                (char *)((void *)0)));
      ap__b->link.prev = ((struct apr_bucket *)((char *)(& bcgi->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                 (char *)((void *)0))))->link.prev;
      (((struct apr_bucket *)((char *)(& bcgi->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                               (char *)((void *)0))))->link.prev)->link.next = ap__b;
      ((struct apr_bucket *)((char *)(& bcgi->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                              (char *)((void *)0))))->link.prev = ap__b;
      break;
    }
    break;
  }
  ap_pass_brigade(f->next, bcgi);
  return (0);
}
}
static int handle_exec(include_ctx_t *ctx , apr_bucket_brigade **bb , request_rec *r ,
                       ap_filter_t *f , apr_bucket *head_ptr , apr_bucket **inserted_head ) 
{ char *tag ;
  char *tag_val ;
  char *file ;
  apr_bucket *tmp_buck ;
  char parsed_string[8192] ;
  apr_size_t tmp ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b ;
  apr_size_t tmp___0 ;
  apr_bucket *ap__a___0 ;
  apr_bucket *ap__b___0 ;
  int tmp___1 ;
  apr_status_t retval ;
  apr_bucket_brigade *tag_plus ;
  apr_bucket *ap__b___1 ;
  apr_bucket *tmp___2 ;
  apr_size_t tmp___3 ;
  apr_bucket *ap__a___1 ;
  apr_bucket *ap__b___2 ;
  int tmp___4 ;
  apr_size_t tmp___5 ;
  apr_bucket *ap__a___2 ;
  apr_bucket *ap__b___3 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  tag = (char *)((void *)0);
  tag_val = (char *)((void *)0);
  file = r->filename;
  (*inserted_head) = (apr_bucket *)((void *)0);
  if (ctx->flags & 1L) {
    if (ctx->flags & 8L) {
      ap_log_rerror("mod_cgi.c", 976, 3, 0, (request_rec const   *)r, "exec used but not allowed in %s",
                    r->filename);
      tmp = strlen((char const   *)ctx->error_str);
      tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp, (void (*)(void *data ))((void *)0),
                                        head_ptr->list);
      while (1) {
        ap__a = head_ptr;
        ap__b = tmp_buck;
        while (1) {
          ap__b->link.next = ap__a;
          ap__b->link.prev = ap__a->link.prev;
          (ap__a->link.prev)->link.next = ap__b;
          ap__a->link.prev = ap__b;
          break;
        }
        break;
      }
      if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
        (*inserted_head) = tmp_buck;
      }
    } else {
      while (1) {
        ((*cgi_pfn_gtv))(ctx, & tag, & tag_val, 1);
        if ((unsigned int )tag_val == (unsigned int )((void *)0)) {
          if ((unsigned int )tag == (unsigned int )((void *)0)) {
            return (0);
          } else {
            return (1);
          }
        }
        tmp___7 = strcmp((char const   *)tag, "cmd");
        if (tmp___7) {
          tmp___6 = strcmp((char const   *)tag, "cgi");
          if (tmp___6) {
            ap_log_rerror("mod_cgi.c", 1023, 3, 0, (request_rec const   *)r, "unknown parameter \"%s\" to tag exec in %s",
                          tag, file);
            tmp___5 = strlen((char const   *)ctx->error_str);
            tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp___5,
                                              (void (*)(void *data ))((void *)0),
                                              head_ptr->list);
            while (1) {
              ap__a___2 = head_ptr;
              ap__b___3 = tmp_buck;
              while (1) {
                ap__b___3->link.next = ap__a___2;
                ap__b___3->link.prev = ap__a___2->link.prev;
                (ap__a___2->link.prev)->link.next = ap__b___3;
                ap__a___2->link.prev = ap__b___3;
                break;
              }
              break;
            }
            if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
              (*inserted_head) = tmp_buck;
            }
          } else {
            retval = 0;
            ((*cgi_pfn_ps))(r, ctx, (char const   *)tag_val, parsed_string, sizeof(parsed_string),
                            0);
            if ((unsigned int )(ctx->ssi_tag_brigade)->list.next == (unsigned int )((struct apr_bucket *)((char *)(& (ctx->ssi_tag_brigade)->list) -
                                                                                                          (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                                  (char *)((void *)0))))) {
              if ((unsigned int )ctx->head_start_bucket != (unsigned int )((void *)0)) {
                tag_plus = apr_brigade_split((*bb), ctx->head_start_bucket);
                if (ctx->output_flush) {
                  while (1) {
                    tmp___2 = apr_bucket_flush_create(((*bb))->bucket_alloc);
                    ap__b___1 = tmp___2;
                    while (1) {
                      ap__b___1->link.next = (struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                   (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                           (char *)((void *)0)));
                      ap__b___1->link.prev = ((struct apr_bucket *)((char *)(& ((*bb))->list) -
                                                                    (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                            (char *)((void *)0))))->link.prev;
                      (((struct apr_bucket *)((char *)(& ((*bb))->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                  (char *)((void *)0))))->link.prev)->link.next = ap__b___1;
                      ((struct apr_bucket *)((char *)(& ((*bb))->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                 (char *)((void *)0))))->link.prev = ap__b___1;
                      break;
                    }
                    break;
                  }
                }
                retval = ap_pass_brigade(f->next, (*bb));
                ctx->bytes_parsed = 0;
                (*bb) = tag_plus;
              } else {
                goto _L;
              }
            } else {
              _L: /* CIL Label */ ;
            }
            if (retval != 0) {
              return (retval);
            }
            tmp___4 = include_cgi(parsed_string, r, f->next, head_ptr, inserted_head);
            if (tmp___4 == -1) {
              ap_log_rerror("mod_cgi.c", 1015, 3, 0, (request_rec const   *)r, "invalid CGI ref \"%s\" in %s",
                            tag_val, file);
              tmp___3 = strlen((char const   *)ctx->error_str);
              tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp___3,
                                                (void (*)(void *data ))((void *)0),
                                                head_ptr->list);
              while (1) {
                ap__a___1 = head_ptr;
                ap__b___2 = tmp_buck;
                while (1) {
                  ap__b___2->link.next = ap__a___1;
                  ap__b___2->link.prev = ap__a___1->link.prev;
                  (ap__a___1->link.prev)->link.next = ap__b___2;
                  ap__a___1->link.prev = ap__b___2;
                  break;
                }
                break;
              }
              if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
                (*inserted_head) = tmp_buck;
              }
            }
          }
        } else {
          ((*cgi_pfn_ps))(r, ctx, (char const   *)tag_val, parsed_string, sizeof(parsed_string),
                          1);
          tmp___1 = include_cmd(ctx, bb, (char const   *)(parsed_string), r, f);
          if (tmp___1 == -1) {
            ap_log_rerror("mod_cgi.c", 995, 3, 0, (request_rec const   *)r, "execution failure for parameter \"%s\" to tag exec in file %s",
                          tag, r->filename);
            tmp___0 = strlen((char const   *)ctx->error_str);
            tmp_buck = apr_bucket_heap_create((char const   *)ctx->error_str, tmp___0,
                                              (void (*)(void *data ))((void *)0),
                                              head_ptr->list);
            while (1) {
              ap__a___0 = head_ptr;
              ap__b___0 = tmp_buck;
              while (1) {
                ap__b___0->link.next = ap__a___0;
                ap__b___0->link.prev = ap__a___0->link.prev;
                (ap__a___0->link.prev)->link.next = ap__b___0;
                ap__a___0->link.prev = ap__b___0;
                break;
              }
              break;
            }
            if ((unsigned int )(*inserted_head) == (unsigned int )((void *)0)) {
              (*inserted_head) = tmp_buck;
            }
          }
        }
      }
    }
  }
  return (0);
}
}
static int cgi_post_config(apr_pool_t *p , apr_pool_t *plog , apr_pool_t *ptemp ,
                           server_rec *s ) 
{ 

  {
  cgi_pfn_reg_with_ssi = (apr_OFN_ap_register_include_handler_t *)apr_dynamic_fn_retrieve("ap_register_include_handler");
  cgi_pfn_gtv = (apr_OFN_ap_ssi_get_tag_and_value_t *)apr_dynamic_fn_retrieve("ap_ssi_get_tag_and_value");
  cgi_pfn_ps = (apr_OFN_ap_ssi_parse_string_t *)apr_dynamic_fn_retrieve("ap_ssi_parse_string");
  if (cgi_pfn_reg_with_ssi) {
    if (cgi_pfn_gtv) {
      if (cgi_pfn_ps) {
        ((*cgi_pfn_reg_with_ssi))((char *)"exec", & handle_exec);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
  cgi_build_command = (apr_OFN_ap_cgi_build_command_t *)apr_dynamic_fn_retrieve("ap_cgi_build_command");
  if (! cgi_build_command) {
    cgi_build_command = & default_build_command;
  }
  return (0);
}
}
static void register_hooks___10(apr_pool_t *p ) ;
static char const   * const  aszPre[2]  = {      (char const   * const  )"mod_include.c",      (char const   * const  )((void *)0)};
static void register_hooks___10(apr_pool_t *p ) 
{ 

  {
  ap_hook_handler(& cgi_handler, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                  10);
  ap_hook_post_config(& cgi_post_config, aszPre, (char const   * const  *)((void *)0),
                      -10);
  return;
}
}
struct module_struct cgi_module  = 
     {20020903, 0, -1, "mod_cgi.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, (void (*)(process_rec *process ))((void *)0), (void *(*)(apr_pool_t *p ,
                                                                           char *dir ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), & create_cgi_config,
    & merge_cgi_config, cgi_cmds, & register_hooks___10};
#pragma merger(0,"/tmp/cil-KjIqMEv6.i","-g -pthread")
apr_status_t apr_file_getc(char *ch , apr_file_t *thefile ) ;
apr_status_t apr_file_ungetc(char ch , apr_file_t *thefile ) ;
apr_array_header_t *apr_array_copy(apr_pool_t *p , apr_array_header_t const   *arr ) ;
extern double atof(char const   *__nptr )  __attribute__((__pure__)) ;
char *ap_get_list_item(apr_pool_t *p , char const   **field ) ;
char *ap_get_token(apr_pool_t *p , char const   **accept_line , int accept_white ) ;
int ap_os_is_path_absolute(apr_pool_t *p , char const   *dir ) ;
void ap_set_content_length(request_rec *r , apr_off_t clength ) ;
int ap_find_path_info(char const   *uri , char const   *path_info ) ;
static void *create_neg_dir_config(apr_pool_t *p , char *dummy ) 
{ neg_dir_config *new ;
  neg_dir_config *tmp ;

  {
  tmp = (neg_dir_config *)apr_palloc(p, sizeof(neg_dir_config ));
  new = tmp;
  new->forcelangpriority = 0;
  new->language_priority = (apr_array_header_t *)((void *)0);
  return ((void *)new);
}
}
static void *merge_neg_dir_configs(apr_pool_t *p , void *basev , void *addv ) 
{ neg_dir_config *base ;
  neg_dir_config *add ;
  neg_dir_config *new ;
  neg_dir_config *tmp ;

  {
  base = (neg_dir_config *)basev;
  add = (neg_dir_config *)addv;
  tmp = (neg_dir_config *)apr_palloc(p, sizeof(neg_dir_config ));
  new = tmp;
  if (add->forcelangpriority != 0) {
    new->forcelangpriority = add->forcelangpriority;
  } else {
    new->forcelangpriority = base->forcelangpriority;
  }
  if (add->language_priority) {
    new->language_priority = add->language_priority;
  } else {
    new->language_priority = base->language_priority;
  }
  return ((void *)new);
}
}
static char const   *set_language_priority(cmd_parms *cmd , void *n_ , char const   *lang ) 
{ neg_dir_config *n ;
  char const   **langp ;

  {
  n = (neg_dir_config *)n_;
  if (! n->language_priority) {
    n->language_priority = apr_array_make(cmd->pool, 4, (int )sizeof(char *));
  }
  langp = (char const   **)apr_array_push(n->language_priority);
  (*langp) = lang;
  return ((char const   *)((void *)0));
}
}
static char const   *set_force_priority(cmd_parms *cmd , void *n_ , char const   *w ) 
{ neg_dir_config *n ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  n = (neg_dir_config *)n_;
  tmp___2 = strcasecmp(w, "None");
  if (tmp___2) {
    tmp___1 = strcasecmp(w, "Prefer");
    if (tmp___1) {
      tmp___0 = strcasecmp(w, "Fallback");
      if (tmp___0) {
        tmp = apr_pstrcat(cmd->pool, "Invalid ForceLanguagePriority option ", w, (void *)0);
        return (tmp);
      } else {
        if (n->forcelangpriority & 1) {
          return ("Cannot combine ForceLanguagePriority options None and Fallback");
        }
        n->forcelangpriority |= 4;
      }
    } else {
      if (n->forcelangpriority & 1) {
        return ("Cannot combine ForceLanguagePriority options None and Prefer");
      }
      n->forcelangpriority |= 2;
    }
  } else {
    if (n->forcelangpriority & -2) {
      return ("Cannot combine ForceLanguagePriority options with None");
    }
    n->forcelangpriority = 1;
  }
  return ((char const   *)((void *)0));
}
}
static char const   *cache_negotiated_docs(cmd_parms *cmd , void *dummy , int arg ) 
{ 

  {
  if (arg) {
    (*((void **)(cmd->server)->module_config + negotiation_module.module_index)) = (void *)"Cache";
  } else {
    (*((void **)(cmd->server)->module_config + negotiation_module.module_index)) = (void *)0;
  }
  return ((char const   *)((void *)0));
}
}
static int do_cache_negotiated_docs(server_rec *s ) 
{ 

  {
  return ((unsigned int )(*((void **)s->module_config + negotiation_module.module_index)) !=
          (unsigned int )((void *)0));
}
}
static command_rec const   negotiation_cmds[4]  = {      {"CacheNegotiatedDocs", {& cache_negotiated_docs}, (void *)0, 128, 5, "Either \'on\' or \'off\' (default)"}, 
        {"LanguagePriority",
      {& set_language_priority}, (void *)0, 4, 3, "space-delimited list of MIME language abbreviations"}, 
        {"ForceLanguagePriority",
      {& set_force_priority}, (void *)0, 4, 3, "Force LanguagePriority elections, either None, or Fallback and/or Prefer"}, 
        {(char const   *)((void *)0),
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))0}, (void *)0,
      0, 0, (char const   *)0}};
static void clean_var_rec(var_rec *mime_info ) 
{ 

  {
  mime_info->sub_req = (request_rec *)((void *)0);
  mime_info->mime_type = "";
  mime_info->file_name = "";
  mime_info->body = 0L;
  mime_info->content_encoding = (char const   *)((void *)0);
  mime_info->content_languages = (apr_array_header_t *)((void *)0);
  mime_info->content_charset = "";
  mime_info->description = "";
  mime_info->is_pseudo_html = 0;
  mime_info->level = 0.0f;
  mime_info->level_matched = 0.0f;
  mime_info->bytes = -1L;
  mime_info->lang_index = -1;
  mime_info->mime_stars = 0;
  mime_info->definite = 1;
  mime_info->charset_quality = 1.0f;
  mime_info->encoding_quality = 1.0f;
  mime_info->lang_quality = 1.0f;
  mime_info->mime_type_quality = 1.0f;
  mime_info->source_quality = 0.0f;
  return;
}
}
static void set_mime_fields(var_rec *var , accept_rec *mime_info ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  var->mime_type = (char const   *)mime_info->name;
  var->source_quality = mime_info->quality;
  var->level = mime_info->level;
  var->content_charset = (char const   *)mime_info->charset;
  tmp = strcmp(var->mime_type, "text/html");
  if (tmp) {
    tmp___0 = strcmp(var->mime_type, "text/x-server-parsed-html");
    if (tmp___0) {
      tmp___1 = strcmp(var->mime_type, "text/x-server-parsed-html3");
      if (tmp___1) {
        tmp___2 = 0;
      } else {
        _L: /* CIL Label */ 
        tmp___2 = 1;
      }
    } else {
      _L___0: /* CIL Label */ 
      goto _L;
    }
  } else {
    goto _L___0;
  }
  var->is_pseudo_html = tmp___2;
  return;
}
}
static void set_vlist_validator(request_rec *r , request_rec *vlistr ) 
{ 

  {
  ap_update_mtime(vlistr, vlistr->finfo.mtime);
  r->vlist_validator = ap_make_etag(vlistr, 0);
  return;
}
}
static char const   *get_entry(apr_pool_t *p , accept_rec *result , char const   *accept_line ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *parm ;
  char *cp ;
  char *end ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  result->quality = 1.0f;
  result->level = 0.0f;
  result->charset = (char *)"";
  result->name = ap_get_token(p, & accept_line, 0);
  ap_str_tolower(result->name);
  tmp___1 = strcmp((char const   *)result->name, "text/html");
  if (tmp___1) {
    _L: /* CIL Label */ 
    tmp___0 = strcmp((char const   *)result->name, "text/x-server-parsed-html");
    if (tmp___0) {
      tmp = strcmp((char const   *)result->name, "text/x-server-parsed-html3");
      if (! tmp) {
        result->level = 3.0f;
      }
    } else {
      result->level = 2.0f;
    }
  } else {
    if ((double )result->level == 0.0) {
      result->level = 2.0f;
    } else {
      goto _L;
    }
  }
  while ((int const   )(*accept_line) == 59) {
    accept_line ++;
    parm = ap_get_token(p, & accept_line, 1);
    cp = parm;
    while (1) {
      if ((*cp)) {
        tmp___2 = __ctype_b_loc();
        if ((int const   )(*((*tmp___2) + (int )((unsigned char )(*cp)))) & 8192) {
          goto _L___1;
        } else {
          if (! ((int )(*cp) != 61)) {
            goto _L___1;
          }
        }
      } else {
        _L___1: /* CIL Label */ 
        break;
      }
      (*cp) = (char )tolower((int )((unsigned char )(*cp)));
      cp ++;
    }
    if (! (*cp)) {
      continue;
    }
    tmp___3 = cp;
    cp ++;
    (*tmp___3) = (char )'\000';
    while (1) {
      if ((*cp)) {
        tmp___4 = __ctype_b_loc();
        if ((int const   )(*((*tmp___4) + (int )((unsigned char )(*cp)))) & 8192) {
          goto _L___3;
        } else {
          if ((int )(*cp) == 61) {
            _L___3: /* CIL Label */ ;
          } else {
            goto _L___2;
          }
        }
      } else {
        _L___2: /* CIL Label */ 
        break;
      }
      cp ++;
    }
    if ((int )(*cp) == 34) {
      cp ++;
      end = cp;
      while (1) {
        if ((*end)) {
          if ((int )(*end) != 10) {
            if ((int )(*end) != 13) {
              if (! ((int )(*end) != 34)) {
                goto _L___6;
              }
            } else {
              goto _L___6;
            }
          } else {
            goto _L___6;
          }
        } else {
          _L___6: /* CIL Label */ 
          break;
        }
        end ++;
      }
    } else {
      end = cp;
      while (1) {
        if ((*end)) {
          tmp___5 = __ctype_b_loc();
          if ((int const   )(*((*tmp___5) + (int )((unsigned char )(*end)))) & 8192) {
            goto _L___7;
          }
        } else {
          _L___7: /* CIL Label */ 
          break;
        }
        end ++;
      }
    }
    if ((*end)) {
      (*end) = (char )'\000';
    }
    ap_str_tolower(cp);
    if ((int )(*(parm + 0)) == 113) {
      if ((int )(*(parm + 1)) == 0) {
        goto _L___10;
      } else {
        if ((int )(*(parm + 1)) == 115) {
          if ((int )(*(parm + 2)) == 0) {
            _L___10: /* CIL Label */ 
            result->quality = (float )atof((char const   *)cp);
          } else {
            goto _L___11;
          }
        } else {
          _L___11: /* CIL Label */ 
          goto _L___9;
        }
      }
    } else {
      _L___9: /* CIL Label */ 
      if ((int )(*(parm + 0)) == 108) {
        tmp___9 = strcmp((char const   *)(parm + 1), "evel");
        if (tmp___9) {
          goto _L___8;
        } else {
          result->level = (float )atof((char const   *)cp);
        }
      } else {
        _L___8: /* CIL Label */ 
        tmp___8 = strcmp((char const   *)parm, "charset");
        if (! tmp___8) {
          result->charset = cp;
        }
      }
    }
  }
  if ((int const   )(*accept_line) == 44) {
    accept_line ++;
  }
  return (accept_line);
}
}
static apr_array_header_t *do_header_line(apr_pool_t *p , char const   *accept_line ) 
{ apr_array_header_t *accept_recs ;
  accept_rec *new ;
  accept_rec *tmp ;

  {
  if (! accept_line) {
    return ((apr_array_header_t *)((void *)0));
  }
  accept_recs = apr_array_make(p, 40, (int )sizeof(accept_rec ));
  while ((*accept_line)) {
    tmp = (accept_rec *)apr_array_push(accept_recs);
    new = tmp;
    accept_line = get_entry(p, new, accept_line);
  }
  return (accept_recs);
}
}
static apr_array_header_t *do_languages_line(apr_pool_t *p , char const   **lang_line ) 
{ apr_array_header_t *lang_recs ;
  apr_array_header_t *tmp ;
  char **new ;
  char **tmp___0 ;

  {
  tmp = apr_array_make(p, 2, (int )sizeof(char *));
  lang_recs = tmp;
  if (! lang_line) {
    return (lang_recs);
  }
  while ((*((*lang_line)))) {
    tmp___0 = (char **)apr_array_push(lang_recs);
    new = tmp___0;
    (*new) = ap_get_token(p, lang_line, 0);
    ap_str_tolower((*new));
    if ((int const   )(*((*lang_line))) == 44) {
      goto _L;
    } else {
      if ((int const   )(*((*lang_line))) == 59) {
        _L: /* CIL Label */ 
        (*lang_line) ++;
      }
    }
  }
  return (lang_recs);
}
}
static negotiation_state *parse_accept_headers(request_rec *r ) 
{ negotiation_state *new ;
  void *tmp ;
  negotiation_state *tmp___0 ;
  accept_rec *elts ;
  apr_table_t *hdrs ;
  int i ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
  tmp = apr_palloc(r->pool, sizeof(negotiation_state ));
  tmp___0 = (negotiation_state *)memset(tmp, 0, sizeof(negotiation_state ));
  new = tmp___0;
  hdrs = r->headers_in;
  new->pool = r->pool;
  new->r = r;
  new->conf = (neg_dir_config *)(*((void **)r->per_dir_config + negotiation_module.module_index));
  new->dir_name = ap_make_dirstr_parent(r->pool, (char const   *)r->filename);
  tmp___1 = apr_table_get((apr_table_t const   *)hdrs, "Accept");
  new->accepts = do_header_line(r->pool, tmp___1);
  if (new->accepts) {
    elts = (accept_rec *)(new->accepts)->elts;
    i = 0;
    while (i < (new->accepts)->nelts) {
      if ((double )(elts + i)->quality < 1.0) {
        new->accept_q = 1;
      }
      i ++;
    }
  }
  tmp___2 = apr_table_get((apr_table_t const   *)hdrs, "Accept-Encoding");
  new->accept_encodings = do_header_line(r->pool, tmp___2);
  tmp___3 = apr_table_get((apr_table_t const   *)hdrs, "Accept-Language");
  new->accept_langs = do_header_line(r->pool, tmp___3);
  tmp___4 = apr_table_get((apr_table_t const   *)hdrs, "Accept-Charset");
  new->accept_charsets = do_header_line(r->pool, tmp___4);
  new->avail_vars = apr_array_make(r->pool, 40, (int )sizeof(var_rec ));
  return (new);
}
}
static void parse_negotiate_header(request_rec *r , negotiation_state *neg ) 
{ char const   *negotiate ;
  char const   *tmp ;
  char *tok ;
  char const   *ua ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;

  {
  tmp = apr_table_get((apr_table_t const   *)r->headers_in, "Negotiate");
  negotiate = tmp;
  neg->ua_supports_trans = 0;
  neg->send_alternates = 0;
  neg->may_choose = 1;
  neg->use_rvsa = 0;
  neg->dont_fiddle_headers = 0;
  if (! negotiate) {
    return;
  }
  tmp___2 = strcmp(negotiate, "trans");
  if (tmp___2 == 0) {
    tmp___0 = apr_table_get((apr_table_t const   *)r->headers_in, "User-Agent");
    ua = tmp___0;
    if (ua) {
      tmp___1 = strncmp(ua, "Lynx", 4U);
      if (tmp___1 == 0) {
        return;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
  }
  neg->may_choose = 0;
  while (1) {
    tok = ap_get_list_item(neg->pool, & negotiate);
    if (! ((unsigned int )tok != (unsigned int )((void *)0))) {
      break;
    }
    tmp___4 = strcmp((char const   *)tok, "trans");
    if (tmp___4 == 0) {
      goto _L___3;
    } else {
      tmp___5 = strcmp((char const   *)tok, "vlist");
      if (tmp___5 == 0) {
        _L___3: /* CIL Label */ 
        goto _L___2;
      } else {
        tmp___6 = strcmp((char const   *)tok, "guess-small");
        if (tmp___6 == 0) {
          _L___2: /* CIL Label */ 
          goto _L___1;
        } else {
          tmp___7 = __ctype_b_loc();
          if ((int const   )(*((*tmp___7) + (int )((unsigned char )(*(tok + 0))))) &
              2048) {
            _L___1: /* CIL Label */ 
            goto _L___0;
          } else {
            tmp___8 = strcmp((char const   *)tok, "*");
            if (tmp___8 == 0) {
              _L___0: /* CIL Label */ 
              neg->ua_supports_trans = 1;
              neg->send_alternates = 1;
              tmp___3 = strcmp((char const   *)tok, "1.0");
              if (tmp___3 == 0) {
                neg->may_choose = 1;
                neg->use_rvsa = 1;
                neg->dont_fiddle_headers = 1;
              } else {
                if ((int )(*(tok + 0)) == 42) {
                  neg->may_choose = 1;
                  neg->dont_fiddle_headers = 1;
                }
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
static void maybe_add_default_accepts(negotiation_state *neg , int prefer_scripts ) 
{ accept_rec *new_accept ;

  {
  if (! neg->accepts) {
    neg->accepts = apr_array_make(neg->pool, 4, (int )sizeof(accept_rec ));
    new_accept = (accept_rec *)apr_array_push(neg->accepts);
    new_accept->name = (char *)"*/*";
    new_accept->quality = 1.0f;
    new_accept->level = 0.0f;
  }
  new_accept = (accept_rec *)apr_array_push(neg->accepts);
  new_accept->name = (char *)"application/x-httpd-cgi";
  if (neg->use_rvsa) {
    new_accept->quality = (float )0;
  } else {
    if (prefer_scripts) {
      new_accept->quality = 2.0f;
    } else {
      new_accept->quality = 0.001f;
    }
  }
  new_accept->level = 0.0f;
  return;
}
}
static enum header_state get_header_line(char *buffer , int len , apr_file_t *map ) 
{ char *buf_end ;
  char *cp ;
  char c ;
  apr_status_t tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  apr_status_t tmp___3 ;
  apr_status_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  apr_status_t tmp___7 ;
  char *tmp___8 ;
  unsigned short const   **tmp___9 ;
  apr_status_t tmp___10 ;

  {
  buf_end = buffer + len;
  while (1) {
    tmp = apr_file_gets(buffer, 8192, map);
    if (tmp != 0) {
      return (0);
    }
    if (! ((int )(*(buffer + 0)) == 35)) {
      break;
    }
  }
  cp = buffer;
  while (1) {
    if ((*cp)) {
      tmp___0 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___0) + (int )((unsigned char )(*cp)))) & 8192)) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      break;
    }
    goto __Cont;
    __Cont: /* CIL Label */ 
    cp ++;
  }
  if ((int )(*cp) == 0) {
    return (2);
  }
  tmp___1 = strlen((char const   *)cp);
  cp += tmp___1;
  tmp___2 = strncasecmp((char const   *)buffer, "Body:", 5U);
  if (! tmp___2) {
    return (1);
  }
  while (1) {
    tmp___10 = apr_file_getc(& c, map);
    if (! (tmp___10 != 70014)) {
      break;
    }
    if ((int )c == 35) {
      while (1) {
        tmp___3 = apr_file_getc(& c, map);
        if (tmp___3 != 70014) {
          if (! ((int )c != 10)) {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          break;
        }
        continue;
      }
    } else {
      tmp___9 = __ctype_b_loc();
      if ((int const   )(*((*tmp___9) + (int )((unsigned char )c))) & 8192) {
        while (1) {
          if ((int )c != 10) {
            tmp___5 = __ctype_b_loc();
            if (! ((int const   )(*((*tmp___5) + (int )((unsigned char )c))) & 8192)) {
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
            break;
          }
          tmp___4 = apr_file_getc(& c, map);
          if (tmp___4 != 0) {
            break;
          }
        }
        apr_file_ungetc(c, map);
        if ((int )c == 10) {
          return (1);
        }
        while (1) {
          if ((unsigned int )cp < (unsigned int )(buf_end - 2)) {
            tmp___7 = apr_file_getc(& c, map);
            if (tmp___7 != 70014) {
              if (! ((int )c != 10)) {
                goto _L___3;
              }
            } else {
              goto _L___3;
            }
          } else {
            _L___3: /* CIL Label */ 
            break;
          }
          tmp___6 = cp;
          cp ++;
          (*tmp___6) = c;
        }
        tmp___8 = cp;
        cp ++;
        (*tmp___8) = (char )'\n';
        (*cp) = (char )'\000';
      } else {
        apr_file_ungetc(c, map);
        return (1);
      }
    }
  }
  return (1);
}
}
static apr_off_t get_body(char *buffer , apr_size_t *len , char const   *tag , apr_file_t *map ) 
{ char *endbody ;
  int bodylen ;
  int taglen ;
  apr_off_t pos ;
  apr_status_t tmp ;
  size_t tmp___0 ;
  apr_status_t tmp___1 ;

  {
  taglen = (int )strlen(tag);
  (*len) -= (apr_size_t )taglen;
  tmp = apr_file_read(map, (void *)buffer, len);
  if (tmp != 0) {
    return (-1L);
  }
  memcpy((void * __restrict  )(buffer + (*len)), (void const   * __restrict  )tag,
         (unsigned int )taglen);
  endbody = strstr((char const   *)buffer, tag);
  if ((unsigned int )endbody == (unsigned int )(buffer + (*len))) {
    return (-1L);
  }
  bodylen = endbody - buffer;
  tmp___0 = strlen(tag);
  endbody += tmp___0;
  while ((*endbody)) {
    if ((int )(*endbody) == 10) {
      endbody ++;
      break;
    }
    endbody ++;
  }
  pos = - ((long )((*len) - (apr_size_t )(endbody - buffer)));
  tmp___1 = apr_file_seek(map, 1, & pos);
  if (tmp___1 != 0) {
    return (-1L);
  }
  (*len) = (unsigned int )bodylen;
  return (pos - (apr_off_t )(endbody - buffer));
}
}
static void strip_paren_comments(char *hdr ) 
{ char *tmp ;
  char *tmp___0 ;

  {
  while ((*hdr)) {
    if ((int )(*hdr) == 34) {
      hdr = strchr((char const   *)hdr, '\"');
      if ((unsigned int )hdr == (unsigned int )((void *)0)) {
        return;
      }
      hdr ++;
    } else {
      if ((int )(*hdr) == 40) {
        while (1) {
          if ((*hdr)) {
            if (! ((int )(*hdr) != 41)) {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            break;
          }
          tmp = hdr;
          hdr ++;
          (*tmp) = (char )' ';
        }
        if ((*hdr)) {
          tmp___0 = hdr;
          hdr ++;
          (*tmp___0) = (char )' ';
        }
      } else {
        hdr ++;
      }
    }
  }
  return;
}
}
static char *lcase_header_name_return_body(char *header , request_rec *r ) 
{ char *cp ;
  unsigned short const   **tmp ;

  {
  cp = header;
  while (1) {
    if ((*cp)) {
      if (! ((int )(*cp) != 58)) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      break;
    }
    (*cp) = (char )tolower((int )((unsigned char )(*cp)));
    cp ++;
  }
  if (! (*cp)) {
    ap_log_rerror("mod_negotiation.c", 884, 3, 0, (request_rec const   *)r, "Syntax error in type map, no \':\' in %s for header %s",
                  r->filename, header);
    return ((char *)((void *)0));
  }
  while (1) {
    cp ++;
    if ((*cp)) {
      tmp = __ctype_b_loc();
      if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*cp)))) & 8192)) {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      break;
    }
  }
  if (! (*cp)) {
    ap_log_rerror("mod_negotiation.c", 895, 3, 0, (request_rec const   *)r, "Syntax error in type map --- no header body: %s for %s",
                  r->filename, header);
    return ((char *)((void *)0));
  }
  return (cp);
}
}
static int read_type_map(apr_file_t **map , negotiation_state *neg , request_rec *rr ) 
{ request_rec *r ;
  apr_file_t *map_ ;
  apr_status_t status ;
  char buffer[8192] ;
  enum header_state hstate ;
  struct var_rec mime_info ;
  int has_content ;
  char *body1 ;
  char *tmp ;
  char const   *body ;
  struct accept_rec accept_info ;
  char *desc ;
  char *tmp___0 ;
  char *cp ;
  char *tag ;
  char *tmp___1 ;
  char *eol ;
  char *tmp___2 ;
  apr_size_t len ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *new_var ;
  void *tmp___11 ;

  {
  r = neg->r;
  map_ = (apr_file_t *)((void *)0);
  if (! map) {
    map = & map_;
  }
  neg->count_multiviews_variants = 0;
  status = apr_file_open(map, (char const   *)rr->filename, 129, 4095, neg->pool);
  if (status != 0) {
    ap_log_rerror("mod_negotiation.c", 922, 3, status, (request_rec const   *)r, "cannot access type map file: %s",
                  rr->filename);
    return (403);
  }
  clean_var_rec(& mime_info);
  has_content = 0;
  while (1) {
    hstate = get_header_line(buffer, 8192, (*map));
    if ((int )hstate == 1) {
      tmp = lcase_header_name_return_body(buffer, neg->r);
      body1 = tmp;
      if ((unsigned int )body1 == (unsigned int )((void *)0)) {
        return (500);
      }
      strip_paren_comments(body1);
      body = (char const   *)body1;
      tmp___10 = strncmp((char const   *)(buffer), "uri:", 4U);
      if (tmp___10) {
        tmp___9 = strncmp((char const   *)(buffer), "content-type:", 13U);
        if (tmp___9) {
          tmp___8 = strncmp((char const   *)(buffer), "content-length:", 15U);
          if (tmp___8) {
            tmp___7 = strncmp((char const   *)(buffer), "content-language:", 17U);
            if (tmp___7) {
              tmp___6 = strncmp((char const   *)(buffer), "content-encoding:", 17U);
              if (tmp___6) {
                tmp___5 = strncmp((char const   *)(buffer), "description:", 12U);
                if (tmp___5) {
                  tmp___4 = strncmp((char const   *)(buffer), "body:", 5U);
                  if (! tmp___4) {
                    tmp___1 = apr_pstrdup(neg->pool, body);
                    tag = tmp___1;
                    tmp___2 = strchr((char const   *)tag, '\000');
                    eol = tmp___2;
                    len = (apr_size_t )8192;
                    while (1) {
                      eol --;
                      if ((unsigned int )eol >= (unsigned int )tag) {
                        tmp___3 = __ctype_b_loc();
                        if (! ((int const   )(*((*tmp___3) + (int )((unsigned char )(*eol)))) &
                               8192)) {
                          goto _L;
                        }
                      } else {
                        _L: /* CIL Label */ 
                        break;
                      }
                      (*eol) = (char )'\000';
                    }
                    mime_info.body = get_body(buffer, & len, (char const   *)tag,
                                              (*map));
                    if (mime_info.body < 0L) {
                      ap_log_rerror("mod_negotiation.c", 984, 3, 0, (request_rec const   *)r,
                                    "Syntax error in type map, no end tag \'%s\'found in %s for Body: content.",
                                    tag, r->filename);
                      break;
                    }
                    mime_info.bytes = (long )len;
                    mime_info.file_name = apr_filename_of_pathname((char const   *)rr->filename);
                  }
                } else {
                  tmp___0 = apr_pstrdup(neg->pool, body);
                  desc = tmp___0;
                  cp = desc;
                  while ((*cp)) {
                    if ((int )(*cp) == 10) {
                      (*cp) = (char )' ';
                    }
                    cp ++;
                  }
                  if ((unsigned int )cp > (unsigned int )desc) {
                    (*(cp - 1)) = (char)0;
                  }
                  mime_info.description = (char const   *)desc;
                }
              } else {
                mime_info.content_encoding = ap_get_token(neg->pool, & body, 0);
                has_content = 1;
              }
            } else {
              mime_info.content_languages = do_languages_line(neg->pool, & body);
              has_content = 1;
            }
          } else {
            mime_info.bytes = (apr_off_t )apr_atoi64((char const   *)((char *)body));
            has_content = 1;
          }
        } else {
          get_entry(neg->pool, & accept_info, body);
          set_mime_fields(& mime_info, & accept_info);
          has_content = 1;
        }
      } else {
        mime_info.file_name = ap_get_token(neg->pool, & body, 0);
      }
    } else {
      if ((*(mime_info.file_name))) {
        if (has_content) {
          tmp___11 = apr_array_push(neg->avail_vars);
          new_var = tmp___11;
          memcpy((void * __restrict  )new_var, (void const   * __restrict  )((void *)(& mime_info)),
                 sizeof(var_rec ));
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ ;
      }
      clean_var_rec(& mime_info);
      has_content = 0;
    }
    if (! ((int )hstate != 0)) {
      break;
    }
  }
  if (map_) {
    apr_file_close(map_);
  }
  set_vlist_validator(r, rr);
  return (0);
}
}
static int variantsortf(var_rec *a , var_rec *b ) 
{ int tmp ;

  {
  if (a->source_quality < b->source_quality) {
    return (1);
  }
  if (a->source_quality > b->source_quality) {
    return (-1);
  }
  tmp = strcmp(a->file_name, b->file_name);
  return (tmp);
}
}
static int read_types_multi(negotiation_state *neg ) 
{ request_rec *r ;
  char *filp ;
  int prefix_len ;
  apr_dir_t *dirp ;
  apr_finfo_t dirent ;
  apr_status_t status ;
  struct var_rec mime_info ;
  struct accept_rec accept_info ;
  void *new_var ;
  int anymatch ;
  int tmp ;
  apr_array_header_t *exception_list ;
  request_rec *sub_req ;
  int tmp___0 ;
  int nexcept ;
  char **cur_except ;
  char *segstart ;
  char *segend ;
  char saveend ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  apr_status_t tmp___6 ;

  {
  r = neg->r;
  anymatch = 0;
  clean_var_rec(& mime_info);
  if (r->proxyreq) {
    goto _L___0;
  } else {
    if (! r->filename) {
      _L___0: /* CIL Label */ 
      goto _L;
    } else {
      tmp = ap_os_is_path_absolute(neg->pool, (char const   *)r->filename);
      if (! tmp) {
        _L: /* CIL Label */ 
        return (-1);
      }
    }
  }
  filp = strrchr((char const   *)r->filename, '/');
  if (! filp) {
    return (-1);
  }
  filp ++;
  prefix_len = (int )strlen((char const   *)filp);
  status = apr_dir_open(& dirp, (char const   *)neg->dir_name, neg->pool);
  if (status != 0) {
    ap_log_rerror("mod_negotiation.c", 1068, 3, status, (request_rec const   *)r,
                  "cannot read directory for multi: %s", neg->dir_name);
    return (403);
  }
  while (1) {
    tmp___6 = apr_dir_read(& dirent, 33554432, dirp);
    if (! (tmp___6 == 0)) {
      break;
    }
    tmp___0 = strncmp(dirent.name, (char const   *)filp, (unsigned int )prefix_len);
    if (tmp___0) {
      continue;
    }
    if ((int const   )(*(dirent.name + prefix_len)) != 46) {
      continue;
    }
    if (dirent.valid & 32768) {
      if ((int )dirent.filetype == 2) {
        continue;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ ;
    }
    anymatch = 1;
    sub_req = ap_sub_req_lookup_dirent((apr_finfo_t const   *)(& dirent), (request_rec const   *)r,
                                       1, (ap_filter_t *)((void *)0));
    if ((int )sub_req->finfo.filetype != 1) {
      continue;
    }
    if (sub_req->handler) {
      if (! sub_req->content_type) {
        ap_set_content_type(sub_req, "application/x-httpd-cgi");
      } else {
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ ;
    }
    exception_list = (apr_array_header_t *)apr_table_get((apr_table_t const   *)sub_req->notes,
                                                         "ap-mime-exceptions-list");
    if (! exception_list) {
      ap_destroy_sub_req(sub_req);
      continue;
    }
    nexcept = exception_list->nelts;
    cur_except = (char **)exception_list->elts;
    segstart = filp;
    while (1) {
      if ((*segstart)) {
        if (! nexcept) {
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
        break;
      }
      segend = strchr((char const   *)segstart, '.');
      if (! segend) {
        segend = strchr((char const   *)segstart, '\000');
      }
      saveend = (*segend);
      (*segend) = (char )'\000';
      tmp___2 = strcmp((char const   *)segstart, (char const   *)(*cur_except));
      if (tmp___2 == 0) {
        nexcept --;
        cur_except ++;
      }
      if (! saveend) {
        break;
      }
      (*segend) = saveend;
      segstart = segend + 1;
    }
    if (nexcept) {
      ap_destroy_sub_req(sub_req);
      continue;
    }
    if (sub_req->status != 200) {
      goto _L___4;
    } else {
      if (! sub_req->content_type) {
        _L___4: /* CIL Label */ 
        ap_destroy_sub_req(sub_req);
        continue;
      }
    }
    if (sub_req->content_type) {
      tmp___4 = strcmp(sub_req->content_type, "application/x-type-map");
      if (tmp___4) {
        goto _L___7;
      } else {
        goto _L___5;
      }
    } else {
      _L___7: /* CIL Label */ 
      if (sub_req->handler) {
        tmp___5 = strcmp(sub_req->handler, "type-map");
        if (tmp___5) {
          goto _L___6;
        } else {
          _L___5: /* CIL Label */ 
          apr_dir_close(dirp);
          (neg->avail_vars)->nelts = 0;
          if (sub_req->status != 200) {
            return (sub_req->status);
          }
          tmp___3 = read_type_map((apr_file_t **)((void *)0), neg, sub_req);
          return (tmp___3);
        }
      } else {
        _L___6: /* CIL Label */ ;
      }
    }
    mime_info.sub_req = sub_req;
    mime_info.file_name = apr_pstrdup(neg->pool, dirent.name);
    if (sub_req->content_encoding) {
      mime_info.content_encoding = sub_req->content_encoding;
    }
    if (sub_req->content_languages) {
      mime_info.content_languages = sub_req->content_languages;
    }
    get_entry(neg->pool, & accept_info, sub_req->content_type);
    set_mime_fields(& mime_info, & accept_info);
    new_var = apr_array_push(neg->avail_vars);
    memcpy((void * __restrict  )new_var, (void const   * __restrict  )((void *)(& mime_info)),
           sizeof(var_rec ));
    neg->count_multiviews_variants ++;
    clean_var_rec(& mime_info);
  }
  apr_dir_close(dirp);
  if (anymatch) {
    if (! (neg->avail_vars)->nelts) {
      ap_log_rerror("mod_negotiation.c", 1239, 3, 0, (request_rec const   *)r, "Negotiation: discovered file(s) matching request: %s (None could be negotiated).",
                    r->filename);
      return (404);
    } else {
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ ;
  }
  set_vlist_validator(r, r);
  qsort((void *)(neg->avail_vars)->elts, (unsigned int )(neg->avail_vars)->nelts,
        sizeof(var_rec ), (int (*)(void const   * , void const   * ))(& variantsortf));
  return (0);
}
}
static int mime_match(accept_rec *accept_r , var_rec *avail ) 
{ char const   *accept_type ;
  char const   *avail_type ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  accept_type = (char const   *)accept_r->name;
  avail_type = avail->mime_type;
  tmp = (int )strlen(accept_type);
  len = tmp;
  if ((int const   )(*(accept_type + 0)) == 42) {
    if (avail->mime_stars < 1) {
      avail->mime_stars = 1;
    }
    return (1);
  } else {
    if ((int const   )(*(accept_type + (len - 1))) == 42) {
      tmp___4 = strncmp(accept_type, avail_type, (unsigned int )(len - 2));
      if (tmp___4) {
        goto _L___2;
      } else {
        if (avail->mime_stars < 2) {
          avail->mime_stars = 2;
        }
        return (1);
      }
    } else {
      _L___2: /* CIL Label */ 
      tmp___0 = strcmp(accept_type, avail_type);
      if (tmp___0) {
        tmp___1 = strcmp(accept_type, "text/html");
        if (tmp___1) {
          _L___0: /* CIL Label */ ;
        } else {
          tmp___2 = strcmp(avail_type, "text/x-server-parsed-html");
          if (tmp___2) {
            tmp___3 = strcmp(avail_type, "text/x-server-parsed-html3");
            if (tmp___3) {
              goto _L___0;
            } else {
              _L___1: /* CIL Label */ 
              if (accept_r->level >= avail->level) {
                avail->level_matched = avail->level;
                avail->mime_stars = 3;
                return (1);
              }
            }
          } else {
            goto _L___1;
          }
        }
      } else {
        goto _L___1;
      }
    }
  }
  return (0);
}
}
static int level_cmp(var_rec *var1 , var_rec *var2 ) 
{ int tmp ;

  {
  if (var1->is_pseudo_html) {
    if (! var2->is_pseudo_html) {
      return (0);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  if (! var1->is_pseudo_html) {
    tmp = strcmp(var1->mime_type, var2->mime_type);
    if (tmp) {
      return (0);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
  if (var1->level_matched > var2->level_matched) {
    return (1);
  }
  if (var1->level_matched < var2->level_matched) {
    return (-1);
  }
  if (var1->level < var2->level) {
    return (1);
  }
  if (var1->level > var2->level) {
    return (-1);
  }
  return (0);
}
}
static int find_lang_index(apr_array_header_t *accept_langs , char *lang ) 
{ char const   **alang ;
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
  if (! lang) {
    goto _L;
  } else {
    if (! accept_langs) {
      _L: /* CIL Label */ 
      return (-1);
    }
  }
  alang = (char const   **)accept_langs->elts;
  i = 0;
  while (i < accept_langs->nelts) {
    tmp = strlen((*alang));
    tmp___0 = strncmp((char const   *)lang, (*alang), tmp);
    if (! tmp___0) {
      return (i);
    }
    alang += (unsigned int )accept_langs->elt_size / sizeof(char *);
    i ++;
  }
  return (-1);
}
}
static void set_default_lang_quality(negotiation_state *neg ) 
{ var_rec *avail_recs ;
  int j ;
  var_rec *variant ;

  {
  avail_recs = (var_rec *)(neg->avail_vars)->elts;
  if (! neg->dont_fiddle_headers) {
    j = 0;
    while (j < (neg->avail_vars)->nelts) {
      variant = avail_recs + j;
      if (variant->content_languages) {
        if ((variant->content_languages)->nelts) {
          neg->default_lang_quality = 0.0001f;
          return;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ ;
      }
      j ++;
    }
  }
  neg->default_lang_quality = 1.0f;
  return;
}
}
static void set_language_quality(negotiation_state *neg , var_rec *variant ) 
{ int forcepriority ;
  accept_rec *accs ;
  accept_rec *best ;
  accept_rec *star ;
  accept_rec *bestthistag ;
  char *lang ;
  char *p ;
  float fiddle_q ;
  int any_match_on_star ;
  int i ;
  int j ;
  apr_size_t alen ;
  apr_size_t longest_lang_range_len ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int plen ;
  int tmp___2 ;
  int bestidx ;
  int j___0 ;
  char *lang___0 ;
  int idx ;

  {
  forcepriority = (neg->conf)->forcelangpriority;
  if (forcepriority == 0) {
    forcepriority = 2;
  }
  if (! variant->content_languages) {
    goto _L___9;
  } else {
    if (! (variant->content_languages)->nelts) {
      _L___9: /* CIL Label */ 
      if (! neg->dont_fiddle_headers) {
        variant->lang_quality = neg->default_lang_quality;
      }
      if (! neg->accept_langs) {
        return;
      }
      return;
    } else {
      if (! neg->accept_langs) {
        variant->definite = 0;
      } else {
        accs = (accept_rec *)(neg->accept_langs)->elts;
        best = (accept_rec *)((void *)0);
        star = (accept_rec *)((void *)0);
        fiddle_q = 0.0f;
        any_match_on_star = 0;
        j = 0;
        while (j < (variant->content_languages)->nelts) {
          p = (char *)((void *)0);
          bestthistag = (accept_rec *)((void *)0);
          longest_lang_range_len = 0U;
          alen = 0U;
          lang = (*((char **)(variant->content_languages)->elts + j));
          i = 0;
          while (i < (neg->accept_langs)->nelts) {
            tmp = strcmp((char const   *)(accs + i)->name, "*");
            if (! tmp) {
              if (! star) {
                star = accs + i;
              }
              goto __Cont;
            }
            alen = strlen((char const   *)(accs + i)->name);
            tmp___0 = strlen((char const   *)lang);
            if (tmp___0 >= alen) {
              tmp___1 = strncmp((char const   *)lang, (char const   *)(accs + i)->name,
                                alen);
              if (tmp___1) {
                goto _L___1;
              } else {
                if ((int )(*(lang + alen)) == 0) {
                  goto _L___0;
                } else {
                  if ((int )(*(lang + alen)) == 45) {
                    _L___0: /* CIL Label */ 
                    if (alen > longest_lang_range_len) {
                      longest_lang_range_len = alen;
                      bestthistag = accs + i;
                    }
                  } else {
                    goto _L___1;
                  }
                }
              }
            } else {
              _L___1: /* CIL Label */ ;
            }
            if (! bestthistag) {
              if (! neg->dont_fiddle_headers) {
                p = strchr((char const   *)(accs + i)->name, '-');
                if (p) {
                  plen = p - (accs + i)->name;
                  tmp___2 = strncmp((char const   *)lang, (char const   *)(accs +
                                                                           i)->name,
                                    (unsigned int )plen);
                  if (! tmp___2) {
                    fiddle_q = 0.001f;
                  }
                }
              } else {
                goto _L___2;
              }
            } else {
              _L___2: /* CIL Label */ ;
            }
            __Cont: /* CIL Label */ 
            i ++;
          }
          if (! best) {
            goto _L___3;
          } else {
            if (bestthistag) {
              if (bestthistag->quality > best->quality) {
                _L___3: /* CIL Label */ 
                best = bestthistag;
              } else {
                goto _L___4;
              }
            } else {
              _L___4: /* CIL Label */ ;
            }
          }
          if (! bestthistag) {
            if (star) {
              any_match_on_star = 1;
            } else {
              goto _L___5;
            }
          } else {
            _L___5: /* CIL Label */ ;
          }
          j ++;
        }
        if (any_match_on_star) {
          if (best) {
            if (star->quality > best->quality) {
              goto _L___7;
            } else {
              goto _L___8;
            }
          } else {
            _L___8: /* CIL Label */ 
            if (! best) {
              _L___7: /* CIL Label */ 
              best = star;
              variant->definite = 0;
            } else {
              goto _L___6;
            }
          }
        } else {
          _L___6: /* CIL Label */ ;
        }
        if (best) {
          variant->lang_quality = best->quality;
        } else {
          variant->lang_quality = fiddle_q;
        }
      }
    }
  }
  if (forcepriority & 2) {
    if (variant->lang_index < 0) {
      goto _L___12;
    } else {
      goto _L___14;
    }
  } else {
    _L___14: /* CIL Label */ 
    if (forcepriority & 4) {
      if (! variant->lang_quality) {
        _L___12: /* CIL Label */ 
        bestidx = -1;
        j___0 = 0;
        while (j___0 < (variant->content_languages)->nelts) {
          lang___0 = (*((char **)(variant->content_languages)->elts + j___0));
          idx = -1;
          idx = find_lang_index((neg->conf)->language_priority, lang___0);
          if (idx >= 0) {
            if (bestidx == -1) {
              goto _L___11;
            } else {
              if (idx < bestidx) {
                _L___11: /* CIL Label */ 
                bestidx = idx;
              } else {
                goto _L___10;
              }
            }
          } else {
            _L___10: /* CIL Label */ ;
          }
          j___0 ++;
        }
        if (bestidx >= 0) {
          if (variant->lang_quality) {
            if (forcepriority & 2) {
              variant->lang_index = bestidx;
            }
          } else {
            if (forcepriority & 4) {
              variant->lang_index = bestidx;
              variant->lang_quality = .0001f;
              variant->definite = 0;
            }
          }
        }
      } else {
        goto _L___13;
      }
    } else {
      _L___13: /* CIL Label */ ;
    }
  }
  return;
}
}
static apr_off_t find_content_length(negotiation_state *neg , var_rec *variant ) 
{ apr_finfo_t statb ;
  char *fullname ;
  char *tmp ;
  apr_status_t tmp___0 ;

  {
  if (variant->bytes < 0L) {
    if (variant->sub_req) {
      if ((variant->sub_req)->finfo.valid & 256) {
        variant->bytes = (variant->sub_req)->finfo.size;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      tmp = ap_make_full_path(neg->pool, (char const   *)neg->dir_name, variant->file_name);
      fullname = tmp;
      tmp___0 = apr_stat(& statb, (char const   *)fullname, 256, neg->pool);
      if (tmp___0 == 0) {
        variant->bytes = statb.size;
      }
    }
  }
  return (variant->bytes);
}
}
static void set_accept_quality(negotiation_state *neg , var_rec *variant ) 
{ int i ;
  accept_rec *accept_recs ;
  float q ;
  int q_definite ;
  accept_rec *type ;
  int prev_mime_stars ;
  int tmp ;
  int tmp___0 ;

  {
  q = 0.0f;
  q_definite = 1;
  if (! neg->accepts) {
    if (variant->mime_type) {
      if ((*(variant->mime_type))) {
        variant->definite = 0;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
    return;
  }
  accept_recs = (accept_rec *)(neg->accepts)->elts;
  i = 0;
  while (i < (neg->accepts)->nelts) {
    type = accept_recs + i;
    prev_mime_stars = variant->mime_stars;
    tmp = mime_match(type, variant);
    if (tmp) {
      if (prev_mime_stars == variant->mime_stars) {
        goto __Cont;
      }
    } else {
      goto __Cont;
    }
    if (! neg->dont_fiddle_headers) {
      if (! neg->accept_q) {
        if (variant->mime_stars == 1) {
          q = 0.01f;
        } else {
          goto _L___3;
        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      if (! neg->dont_fiddle_headers) {
        if (! neg->accept_q) {
          if (variant->mime_stars == 2) {
            q = 0.02f;
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        q = type->quality;
      }
    }
    q_definite = variant->mime_stars == 3;
    __Cont: /* CIL Label */ 
    i ++;
  }
  variant->mime_type_quality = q;
  if (variant->definite) {
    if (q_definite) {
      tmp___0 = 1;
    } else {
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ 
    tmp___0 = 0;
  }
  variant->definite = tmp___0;
  return;
}
}
static void set_charset_quality(negotiation_state *neg , var_rec *variant ) 
{ int i ;
  accept_rec *accept_recs ;
  char const   *charset ;
  accept_rec *star ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  accept_rec *type ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  charset = variant->content_charset;
  star = (accept_rec *)((void *)0);
  if (! neg->accept_charsets) {
    if (charset) {
      if ((*charset)) {
        variant->definite = 0;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
    return;
  }
  accept_recs = (accept_rec *)(neg->accept_charsets)->elts;
  if ((unsigned int )charset == (unsigned int )((void *)0)) {
    goto _L___2;
  } else {
    if (! (*charset)) {
      _L___2: /* CIL Label */ 
      tmp = strncmp(variant->mime_type, "text/", 5U);
      if (tmp) {
        tmp___0 = strcmp(variant->mime_type, "text/x-server-parsed-html");
        if (tmp___0) {
          tmp___1 = strcmp(variant->mime_type, "text/x-server-parsed-html3");
          if (tmp___1) {
            return;
          } else {
            _L___0: /* CIL Label */ ;
          }
        } else {
          _L___1: /* CIL Label */ 
          goto _L___0;
        }
      } else {
        goto _L___1;
      }
      if (neg->dont_fiddle_headers) {
        return;
      }
      charset = "iso-8859-1";
    }
  }
  i = 0;
  while (i < (neg->accept_charsets)->nelts) {
    type = accept_recs + i;
    tmp___3 = strcmp((char const   *)type->name, charset);
    if (tmp___3) {
      tmp___2 = strcmp((char const   *)type->name, "*");
      if (tmp___2 == 0) {
        star = type;
      }
    } else {
      variant->charset_quality = type->quality;
      return;
    }
    i ++;
  }
  if (star) {
    variant->charset_quality = star->quality;
    variant->definite = 0;
    return;
  }
  tmp___4 = strcmp(charset, "iso-8859-1");
  if (tmp___4 == 0) {
    variant->charset_quality = 1.0f;
  } else {
    variant->charset_quality = 0.0f;
  }
  return;
}
}
static int is_identity_encoding(char const   *enc ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (! enc) {
    goto _L___2;
  } else {
    if (! (*(enc + 0))) {
      _L___2: /* CIL Label */ 
      goto _L___1;
    } else {
      tmp = strcmp(enc, "7bit");
      if (tmp) {
        tmp___0 = strcmp(enc, "8bit");
        if (tmp___0) {
          tmp___1 = strcmp(enc, "binary");
          if (tmp___1) {
            tmp___2 = 0;
          } else {
            _L: /* CIL Label */ 
            tmp___2 = 1;
          }
        } else {
          _L___0: /* CIL Label */ 
          goto _L;
        }
      } else {
        _L___1: /* CIL Label */ 
        goto _L___0;
      }
    }
  }
  return (tmp___2);
}
}
static void set_encoding_quality(negotiation_state *neg , var_rec *variant ) 
{ accept_rec *accept_recs ;
  char const   *enc ;
  accept_rec *star ;
  float value_if_not_found ;
  int i ;
  int tmp ;
  int tmp___0 ;
  char *name ;
  int tmp___1 ;
  int tmp___2 ;

  {
  enc = variant->content_encoding;
  star = (accept_rec *)((void *)0);
  value_if_not_found = 0.0f;
  if (! neg->accept_encodings) {
    if (! enc) {
      goto _L;
    } else {
      tmp = is_identity_encoding(enc);
      if (tmp) {
        _L: /* CIL Label */ 
        variant->encoding_quality = 1.0f;
      } else {
        variant->encoding_quality = 0.5f;
      }
    }
    return;
  }
  if (! enc) {
    goto _L___0;
  } else {
    tmp___0 = is_identity_encoding(enc);
    if (tmp___0) {
      _L___0: /* CIL Label */ 
      enc = "identity";
      value_if_not_found = 0.0001f;
    }
  }
  accept_recs = (accept_rec *)(neg->accept_encodings)->elts;
  if ((int const   )(*(enc + 0)) == 120) {
    if ((int const   )(*(enc + 1)) == 45) {
      enc += 2;
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
  i = 0;
  while (i < (neg->accept_encodings)->nelts) {
    name = (accept_recs + i)->name;
    if ((int )(*(name + 0)) == 120) {
      if ((int )(*(name + 1)) == 45) {
        name += 2;
      } else {
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ ;
    }
    tmp___1 = strcmp((char const   *)name, enc);
    if (! tmp___1) {
      variant->encoding_quality = (accept_recs + i)->quality;
      return;
    }
    tmp___2 = strcmp((char const   *)name, "*");
    if (tmp___2 == 0) {
      star = accept_recs + i;
    }
    i ++;
  }
  if (star) {
    variant->encoding_quality = star->quality;
    return;
  }
  variant->encoding_quality = value_if_not_found;
  return;
}
}
static int is_variant_better_rvsa(negotiation_state *neg , var_rec *variant , var_rec *best ,
                                  float *p_bestq ) 
{ float bestq ;
  float q ;

  {
  bestq = (*p_bestq);
  if (variant->encoding_quality == 0.0f) {
    return (0);
  }
  q = ((variant->mime_type_quality * variant->source_quality) * variant->charset_quality) *
      variant->lang_quality;
  if (q <= 0.0f) {
    return (0);
  }
  if (q > bestq) {
    (*p_bestq) = q;
    return (1);
  }
  if (q == bestq) {
    if (variant->encoding_quality > best->encoding_quality) {
      (*p_bestq) = q;
      return (1);
    }
  }
  return (0);
}
}
static int is_variant_better(negotiation_state *neg , var_rec *variant , var_rec *best ,
                             float *p_bestq ) 
{ float bestq ;
  float q ;
  int levcmp ;
  int tmp ;
  int tmp___0 ;
  apr_off_t tmp___1 ;
  apr_off_t tmp___2 ;

  {
  bestq = (*p_bestq);
  if (variant->encoding_quality == 0.0f) {
    goto _L___2;
  } else {
    if (variant->lang_quality == 0.0f) {
      _L___2: /* CIL Label */ 
      goto _L___1;
    } else {
      if (variant->source_quality == 0.0f) {
        _L___1: /* CIL Label */ 
        goto _L___0;
      } else {
        if (variant->charset_quality == 0.0f) {
          _L___0: /* CIL Label */ 
          goto _L;
        } else {
          if (variant->mime_type_quality == 0.0f) {
            _L: /* CIL Label */ 
            return (0);
          }
        }
      }
    }
  }
  q = variant->mime_type_quality * variant->source_quality;
  if ((double )q == 0.0) {
    goto _L___3;
  } else {
    if (q < bestq) {
      _L___3: /* CIL Label */ 
      return (0);
    }
  }
  if (q > bestq) {
    goto _L___4;
  } else {
    if (! best) {
      _L___4: /* CIL Label */ 
      (*p_bestq) = q;
      return (1);
    }
  }
  if (variant->lang_quality < best->lang_quality) {
    return (0);
  }
  if (variant->lang_quality > best->lang_quality) {
    (*p_bestq) = q;
    return (1);
  }
  if (best->lang_index != -1) {
    if (variant->lang_index == -1) {
      goto _L___6;
    } else {
      if (variant->lang_index > best->lang_index) {
        _L___6: /* CIL Label */ 
        return (0);
      } else {
        goto _L___5;
      }
    }
  } else {
    _L___5: /* CIL Label */ ;
  }
  if (variant->lang_index != -1) {
    if (best->lang_index == -1) {
      goto _L___8;
    } else {
      if (variant->lang_index < best->lang_index) {
        _L___8: /* CIL Label */ 
        (*p_bestq) = q;
        return (1);
      } else {
        goto _L___7;
      }
    }
  } else {
    _L___7: /* CIL Label */ ;
  }
  levcmp = level_cmp(variant, best);
  if (levcmp == -1) {
    return (0);
  }
  if (levcmp == 1) {
    (*p_bestq) = q;
    return (1);
  }
  if (variant->charset_quality < best->charset_quality) {
    return (0);
  }
  if (variant->charset_quality > best->charset_quality) {
    goto _L___11;
  } else {
    if ((unsigned int )variant->content_charset != (unsigned int )((void *)0)) {
      if ((int const   )(*(variant->content_charset)) != 0) {
        tmp = strcmp(variant->content_charset, "iso-8859-1");
        if (tmp != 0) {
          if ((unsigned int )best->content_charset == (unsigned int )((void *)0)) {
            goto _L___12;
          } else {
            if ((int const   )(*(best->content_charset)) == 0) {
              _L___12: /* CIL Label */ 
              goto _L___11;
            } else {
              tmp___0 = strcmp(best->content_charset, "iso-8859-1");
              if (tmp___0 == 0) {
                _L___11: /* CIL Label */ 
                (*p_bestq) = q;
                return (1);
              } else {
                goto _L___14;
              }
            }
          }
        } else {
          goto _L___14;
        }
      } else {
        goto _L___14;
      }
    } else {
      _L___14: /* CIL Label */ ;
    }
  }
  if (variant->encoding_quality < best->encoding_quality) {
    return (0);
  }
  if (variant->encoding_quality > best->encoding_quality) {
    (*p_bestq) = q;
    return (1);
  }
  tmp___1 = find_content_length(neg, variant);
  tmp___2 = find_content_length(neg, best);
  if (tmp___1 >= tmp___2) {
    return (0);
  }
  (*p_bestq) = q;
  return (1);
}
}
static int best_match(negotiation_state *neg , var_rec **pbest ) 
{ int j ;
  var_rec *best ;
  float bestq ;
  enum algorithm_results algorithm_result ;
  var_rec *avail_recs ;
  var_rec *variant ;
  int tmp ;
  int tmp___0 ;

  {
  best = (var_rec *)((void *)0);
  bestq = 0.0f;
  avail_recs = (var_rec *)(neg->avail_vars)->elts;
  set_default_lang_quality(neg);
  j = 0;
  while (j < (neg->avail_vars)->nelts) {
    variant = avail_recs + j;
    set_accept_quality(neg, variant);
    set_language_quality(neg, variant);
    set_encoding_quality(neg, variant);
    set_charset_quality(neg, variant);
    if (neg->may_choose) {
      if (neg->use_rvsa) {
        tmp = is_variant_better_rvsa(neg, variant, best, & bestq);
        if (tmp) {
          best = variant;
        }
      } else {
        tmp___0 = is_variant_better(neg, variant, best, & bestq);
        if (tmp___0) {
          best = variant;
        }
      }
    }
    j ++;
  }
  if (neg->use_rvsa) {
    if (best) {
      if (best->definite) {
        if (bestq > (float )0) {
          algorithm_result = 1;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      algorithm_result = 2;
    }
  } else {
    if (bestq > (float )0) {
      algorithm_result = 1;
    } else {
      algorithm_result = 2;
    }
  }
  (*pbest) = best;
  return ((int )algorithm_result);
}
}
static void set_neg_headers(request_rec *r , negotiation_state *neg , int alg_result ) 
{ apr_table_t *hdrs ;
  var_rec *avail_recs ;
  char const   *sample_type ;
  char const   *sample_language ;
  char const   *sample_encoding ;
  char const   *sample_charset ;
  char *lang ;
  char *qstr ;
  char *lenstr ;
  apr_off_t len ;
  apr_array_header_t *arr ;
  int max_vlist_array ;
  int first_variant ;
  int vary_by_type ;
  int vary_by_language ;
  int vary_by_charset ;
  int vary_by_encoding ;
  int j ;
  var_rec *variant ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  void *tmp___29 ;
  void *tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  char const   *tmp___36 ;
  char const   *tmp___37 ;
  char const   *tmp___38 ;
  char const   *tmp___39 ;
  char *tmp___40 ;
  char const   *tmp___41 ;

  {
  avail_recs = (var_rec *)(neg->avail_vars)->elts;
  sample_type = (char const   *)((void *)0);
  sample_language = (char const   *)((void *)0);
  sample_encoding = (char const   *)((void *)0);
  sample_charset = (char const   *)((void *)0);
  max_vlist_array = (neg->avail_vars)->nelts * 21;
  first_variant = 1;
  vary_by_type = 0;
  vary_by_language = 0;
  vary_by_charset = 0;
  vary_by_encoding = 0;
  if (neg->send_alternates) {
    if ((neg->avail_vars)->nelts) {
      arr = apr_array_make(r->pool, max_vlist_array, (int )sizeof(char *));
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    arr = (apr_array_header_t *)((void *)0);
  }
  hdrs = r->err_headers_out;
  j = 0;
  while (j < (neg->avail_vars)->nelts) {
    variant = avail_recs + j;
    if (variant->content_languages) {
      if ((variant->content_languages)->nelts) {
        lang = apr_array_pstrcat(r->pool, (apr_array_header_t const   *)variant->content_languages,
                                 (char )',');
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      lang = (char *)((void *)0);
    }
    if (first_variant) {
      sample_type = variant->mime_type;
      sample_charset = variant->content_charset;
      sample_language = (char const   *)lang;
      sample_encoding = variant->content_encoding;
    } else {
      if (! vary_by_type) {
        if (variant->mime_type) {
          tmp = variant->mime_type;
        } else {
          tmp = "";
        }
        if (sample_type) {
          tmp___0 = sample_type;
        } else {
          tmp___0 = "";
        }
        tmp___1 = strcmp(tmp___0, tmp);
        if (tmp___1) {
          vary_by_type = 1;
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ ;
      }
      if (! vary_by_charset) {
        if (variant->content_charset) {
          tmp___2 = variant->content_charset;
        } else {
          tmp___2 = "";
        }
        if (sample_charset) {
          tmp___3 = sample_charset;
        } else {
          tmp___3 = "";
        }
        tmp___4 = strcmp(tmp___3, tmp___2);
        if (tmp___4) {
          vary_by_charset = 1;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ ;
      }
      if (! vary_by_language) {
        if (lang) {
          tmp___5 = (char const   *)lang;
        } else {
          tmp___5 = "";
        }
        if (sample_language) {
          tmp___6 = sample_language;
        } else {
          tmp___6 = "";
        }
        tmp___7 = strcmp(tmp___6, tmp___5);
        if (tmp___7) {
          vary_by_language = 1;
        } else {
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ ;
      }
      if (! vary_by_encoding) {
        if (variant->content_encoding) {
          tmp___8 = variant->content_encoding;
        } else {
          tmp___8 = "";
        }
        if (sample_encoding) {
          tmp___9 = sample_encoding;
        } else {
          tmp___9 = "";
        }
        tmp___10 = strcmp(tmp___9, tmp___8);
        if (tmp___10) {
          vary_by_encoding = 1;
        } else {
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ ;
      }
    }
    first_variant = 0;
    if (! neg->send_alternates) {
      goto __Cont;
    }
    tmp___11 = apr_array_push(arr);
    (*((char const   **)tmp___11)) = "{\"";
    tmp___12 = apr_array_push(arr);
    (*((char const   **)tmp___12)) = variant->file_name;
    tmp___13 = apr_array_push(arr);
    (*((char const   **)tmp___13)) = "\" ";
    qstr = (char *)apr_palloc(r->pool, 6U);
    apr_snprintf(qstr, 6U, "%1.3f", variant->source_quality);
    if ((int )(*(qstr + 4)) == 48) {
      (*(qstr + 4)) = (char )'\000';
      if ((int )(*(qstr + 3)) == 48) {
        (*(qstr + 3)) = (char )'\000';
        if ((int )(*(qstr + 2)) == 48) {
          (*(qstr + 1)) = (char )'\000';
        }
      }
    }
    tmp___15 = apr_array_push(arr);
    (*((char const   **)tmp___15)) = (char const   *)qstr;
    if (variant->mime_type) {
      if ((*(variant->mime_type))) {
        tmp___16 = apr_array_push(arr);
        (*((char const   **)tmp___16)) = " {type ";
        tmp___17 = apr_array_push(arr);
        (*((char const   **)tmp___17)) = variant->mime_type;
        tmp___18 = apr_array_push(arr);
        (*((char const   **)tmp___18)) = "}";
      } else {
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ ;
    }
    if (variant->content_charset) {
      if ((*(variant->content_charset))) {
        tmp___19 = apr_array_push(arr);
        (*((char const   **)tmp___19)) = " {charset ";
        tmp___20 = apr_array_push(arr);
        (*((char const   **)tmp___20)) = variant->content_charset;
        tmp___21 = apr_array_push(arr);
        (*((char const   **)tmp___21)) = "}";
      } else {
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ ;
    }
    if (lang) {
      tmp___22 = apr_array_push(arr);
      (*((char const   **)tmp___22)) = " {language ";
      tmp___23 = apr_array_push(arr);
      (*((char const   **)tmp___23)) = (char const   *)lang;
      tmp___24 = apr_array_push(arr);
      (*((char const   **)tmp___24)) = "}";
    }
    if (variant->content_encoding) {
      if ((*(variant->content_encoding))) {
        tmp___25 = apr_array_push(arr);
        (*((char const   **)tmp___25)) = " {encoding ";
        tmp___26 = apr_array_push(arr);
        (*((char const   **)tmp___26)) = variant->content_encoding;
        tmp___27 = apr_array_push(arr);
        (*((char const   **)tmp___27)) = "}";
      } else {
        goto _L___7;
      }
    } else {
      _L___7: /* CIL Label */ ;
    }
    if (variant->sub_req) {
      if ((variant->sub_req)->handler) {
        _L___8: /* CIL Label */ ;
      } else {
        goto _L___9;
      }
    } else {
      _L___9: /* CIL Label */ 
      len = find_content_length(neg, variant);
      if (len >= 0L) {
        lenstr = (char *)apr_palloc(r->pool, 22U);
        apr_snprintf(lenstr, 22U, "%ld", len);
        tmp___29 = apr_array_push(arr);
        (*((char const   **)tmp___29)) = " {length ";
        tmp___30 = apr_array_push(arr);
        (*((char const   **)tmp___30)) = (char const   *)lenstr;
        tmp___31 = apr_array_push(arr);
        (*((char const   **)tmp___31)) = "}";
      } else {
        goto _L___8;
      }
    }
    tmp___32 = apr_array_push(arr);
    (*((char const   **)tmp___32)) = "}";
    tmp___33 = apr_array_push(arr);
    (*((char const   **)tmp___33)) = ", ";
    __Cont: /* CIL Label */ 
    j ++;
  }
  if (neg->send_alternates) {
    if ((neg->avail_vars)->nelts) {
      arr->nelts = arr->nelts - 1;
      tmp___34 = apr_array_pstrcat(r->pool, (apr_array_header_t const   *)arr, (char )'\000');
      apr_table_mergen(hdrs, "Alternates", tmp___34);
    } else {
      goto _L___10;
    }
  } else {
    _L___10: /* CIL Label */ ;
  }
  if (neg->is_transparent) {
    goto _L___15;
  } else {
    if (vary_by_type) {
      _L___15: /* CIL Label */ 
      goto _L___14;
    } else {
      if (vary_by_language) {
        _L___14: /* CIL Label */ 
        goto _L___13;
      } else {
        if (vary_by_language) {
          _L___13: /* CIL Label */ 
          goto _L___12;
        } else {
          if (vary_by_charset) {
            _L___12: /* CIL Label */ 
            goto _L___11;
          } else {
            if (vary_by_encoding) {
              _L___11: /* CIL Label */ 
              if (vary_by_encoding) {
                tmp___35 = ", accept-encoding";
              } else {
                tmp___35 = "";
              }
              if (vary_by_charset) {
                tmp___36 = ", accept-charset";
              } else {
                tmp___36 = "";
              }
              if (vary_by_language) {
                tmp___37 = ", accept-language";
              } else {
                tmp___37 = "";
              }
              if (vary_by_type) {
                tmp___38 = ", accept";
              } else {
                tmp___38 = "";
              }
              if (neg->is_transparent) {
                tmp___39 = ", negotiate";
              } else {
                tmp___39 = "";
              }
              tmp___40 = apr_pstrcat(r->pool, tmp___39, tmp___38, tmp___37, tmp___36,
                                     tmp___35, (void *)0);
              apr_table_mergen(hdrs, "Vary", (char const   *)(tmp___40 + 2));
            }
          }
        }
      }
    }
  }
  if (neg->is_transparent) {
    if (alg_result == 2) {
      tmp___41 = "list";
    } else {
      tmp___41 = "choice";
    }
    apr_table_setn(hdrs, "TCN", tmp___41);
  }
  return;
}
}
static char *make_variant_list(request_rec *r , negotiation_state *neg ) 
{ apr_array_header_t *arr ;
  int i ;
  int max_vlist_array ;
  void *tmp ;
  var_rec *variant ;
  char const   *filename ;
  char const   *tmp___0 ;
  apr_array_header_t *languages ;
  char const   *description ;
  char const   *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  char *tmp___18 ;

  {
  max_vlist_array = (neg->avail_vars)->nelts * 15 + 2;
  arr = apr_array_make(r->pool, max_vlist_array, (int )sizeof(char *));
  tmp = apr_array_push(arr);
  (*((char const   **)tmp)) = "Available variants:\n<ul>\n";
  i = 0;
  while (i < (neg->avail_vars)->nelts) {
    variant = (var_rec *)(neg->avail_vars)->elts + i;
    if (variant->file_name) {
      tmp___0 = variant->file_name;
    } else {
      tmp___0 = "";
    }
    filename = tmp___0;
    languages = variant->content_languages;
    if (variant->description) {
      tmp___1 = variant->description;
    } else {
      tmp___1 = "";
    }
    description = tmp___1;
    tmp___2 = apr_array_push(arr);
    (*((char const   **)tmp___2)) = "<li><a href=\"";
    tmp___3 = apr_array_push(arr);
    (*((char const   **)tmp___3)) = filename;
    tmp___4 = apr_array_push(arr);
    (*((char const   **)tmp___4)) = "\">";
    tmp___5 = apr_array_push(arr);
    (*((char const   **)tmp___5)) = filename;
    tmp___6 = apr_array_push(arr);
    (*((char const   **)tmp___6)) = "</a> ";
    tmp___7 = apr_array_push(arr);
    (*((char const   **)tmp___7)) = description;
    if (variant->mime_type) {
      if ((*(variant->mime_type))) {
        tmp___8 = apr_array_push(arr);
        (*((char const   **)tmp___8)) = ", type ";
        tmp___9 = apr_array_push(arr);
        (*((char const   **)tmp___9)) = variant->mime_type;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
    if (languages) {
      if (languages->nelts) {
        tmp___10 = apr_array_push(arr);
        (*((char const   **)tmp___10)) = ", language ";
        tmp___11 = apr_array_push(arr);
        (*((char const   **)tmp___11)) = apr_array_pstrcat(r->pool, (apr_array_header_t const   *)languages,
                                                           (char )',');
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
    if (variant->content_charset) {
      if ((*(variant->content_charset))) {
        tmp___12 = apr_array_push(arr);
        (*((char const   **)tmp___12)) = ", charset ";
        tmp___13 = apr_array_push(arr);
        (*((char const   **)tmp___13)) = variant->content_charset;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ ;
    }
    if (variant->content_encoding) {
      tmp___14 = apr_array_push(arr);
      (*((char const   **)tmp___14)) = ", encoding ";
      tmp___15 = apr_array_push(arr);
      (*((char const   **)tmp___15)) = variant->content_encoding;
    }
    tmp___16 = apr_array_push(arr);
    (*((char const   **)tmp___16)) = "</li>\n";
    i ++;
  }
  tmp___17 = apr_array_push(arr);
  (*((char const   **)tmp___17)) = "</ul>\n";
  tmp___18 = apr_array_pstrcat(r->pool, (apr_array_header_t const   *)arr, (char )'\000');
  return (tmp___18);
}
}
static void store_variant_list(request_rec *r , negotiation_state *neg ) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
  if ((unsigned int )r->main == (unsigned int )((void *)0)) {
    tmp = make_variant_list(r, neg);
    apr_table_setn(r->notes, "variant-list", tmp);
  } else {
    tmp___0 = make_variant_list(r->main, neg);
    apr_table_setn((r->main)->notes, "variant-list", tmp___0);
  }
  return;
}
}
static int setup_choice_response(request_rec *r , negotiation_state *neg , var_rec *variant ) 
{ request_rec *sub_req ;
  char const   *sub_vary ;
  int status ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
  if (! variant->sub_req) {
    sub_req = ap_sub_req_lookup_file(variant->file_name, (request_rec const   *)r,
                                     (ap_filter_t *)((void *)0));
    status = sub_req->status;
    if (status != 200) {
      tmp = apr_table_get((apr_table_t const   *)sub_req->err_headers_out, "TCN");
      if (tmp) {
        goto _L;
      } else {
        ap_destroy_sub_req(sub_req);
        return (status);
      }
    } else {
      _L: /* CIL Label */ ;
    }
    variant->sub_req = sub_req;
  } else {
    sub_req = variant->sub_req;
  }
  if (neg->is_transparent) {
    tmp___0 = apr_table_get((apr_table_t const   *)sub_req->err_headers_out, "TCN");
    if (tmp___0) {
      return (506);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
  if (sub_req->handler) {
    tmp___1 = strcmp(sub_req->handler, "type-map");
    if (tmp___1 == 0) {
      return (506);
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
  sub_vary = apr_table_get((apr_table_t const   *)sub_req->err_headers_out, "Vary");
  if ((unsigned int )sub_vary != (unsigned int )((void *)0)) {
    apr_table_setn(r->err_headers_out, "Variant-Vary", sub_vary);
    apr_table_setn(r->err_headers_out, "Vary", sub_vary);
    apr_table_unset(sub_req->err_headers_out, "Vary");
  }
  tmp___2 = apr_pstrdup(r->pool, variant->file_name);
  apr_table_setn(r->err_headers_out, "Content-Location", tmp___2);
  set_neg_headers(r, neg, 1);
  return (0);
}
}
static int do_negotiation(request_rec *r , negotiation_state *neg , var_rec **bestp ,
                          int prefer_scripts ) 
{ var_rec *avail_recs ;
  int alg_result ;
  int res ;
  int j ;
  var_rec *variant ;
  char *tmp ;
  int tmp___0 ;

  {
  avail_recs = (var_rec *)(neg->avail_vars)->elts;
  if (r->method_number == 0) {
    neg->is_transparent = 1;
    if (r->path_info) {
      if ((*(r->path_info))) {
        neg->is_transparent = 0;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
    j = 0;
    while (j < (neg->avail_vars)->nelts) {
      variant = avail_recs + j;
      tmp = strchr(variant->file_name, '/');
      if (tmp) {
        neg->is_transparent = 0;
      }
      if (variant->body) {
        neg->is_transparent = 0;
      }
      j ++;
    }
  }
  if (neg->is_transparent) {
    parse_negotiate_header(r, neg);
  } else {
    neg->may_choose = 1;
  }
  maybe_add_default_accepts(neg, prefer_scripts);
  alg_result = best_match(neg, bestp);
  if (alg_result == 2) {
    neg->send_alternates = 1;
    set_neg_headers(r, neg, alg_result);
    store_variant_list(r, neg);
    if (neg->is_transparent) {
      if (neg->ua_supports_trans) {
        return (300);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
    if (! (*bestp)) {
      ap_log_rerror("mod_negotiation.c", 2745, 3, 0, (request_rec const   *)r, "no acceptable variant: %s",
                    r->filename);
      return (406);
    }
  }
  if (neg->is_transparent) {
    res = setup_choice_response(r, neg, (*bestp));
    if (res != 0) {
      return (res);
    }
  } else {
    set_neg_headers(r, neg, alg_result);
  }
  tmp___0 = do_cache_negotiated_docs(r->server);
  if (tmp___0) {
    _L___2: /* CIL Label */ ;
  } else {
    if (r->proto_num < 1001) {
      if (neg->count_multiviews_variants != 1) {
        r->no_cache = 1;
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  }
  return (0);
}
}
static int handle_map_file(request_rec *r ) 
{ negotiation_state *neg ;
  apr_file_t *map ;
  var_rec *best ;
  int res ;
  char *udir ;
  int tmp ;
  int tmp___0 ;
  conn_rec *c ;
  apr_bucket_brigade *bb ;
  apr_bucket *e ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  apr_bucket *ap__b ;
  apr_bucket *ap__b___0 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
  tmp = strcmp(r->handler, "application/x-type-map");
  if (tmp) {
    tmp___0 = strcmp(r->handler, "type-map");
    if (tmp___0) {
      return (-1);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  neg = parse_accept_headers(r);
  res = read_type_map(& map, neg, r);
  if (res) {
    return (res);
  }
  res = do_negotiation(r, neg, & best, 0);
  if (res != 0) {
    return (res);
  }
  if (best->body) {
    c = r->connection;
    ap_allow_standard_methods(r, 1, 0, 5, 2, -1);
    if (r->method_number != 0) {
      if (r->method_number != 2) {
        return (405);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
    apr_table_setn(r->headers_out, "Accept-Ranges", "bytes");
    ap_set_content_length(r, best->bytes);
    if (best->mime_type) {
      if ((*(best->mime_type))) {
        if (best->content_charset) {
          if ((*(best->content_charset))) {
            tmp___1 = apr_pstrcat(r->pool, best->mime_type, "; charset=", best->content_charset,
                                  (void *)0);
            ap_set_content_type(r, tmp___1);
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          tmp___2 = apr_pstrdup(r->pool, best->mime_type);
          ap_set_content_type(r, tmp___2);
        }
      } else {
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ ;
    }
    if (best->content_languages) {
      if ((best->content_languages)->nelts) {
        r->content_languages = apr_array_copy(r->pool, (apr_array_header_t const   *)best->content_languages);
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ ;
    }
    if (best->content_encoding) {
      if ((*(best->content_encoding))) {
        r->content_encoding = apr_pstrdup(r->pool, best->content_encoding);
      } else {
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ ;
    }
    res = ap_meets_conditions(r);
    if (res != 0) {
      return (res);
    }
    res = ap_discard_request_body(r);
    if (res != 0) {
      return (res);
    }
    bb = apr_brigade_create(r->pool, c->bucket_alloc);
    e = apr_bucket_file_create(map, best->body, (unsigned int )best->bytes, r->pool,
                               c->bucket_alloc);
    while (1) {
      ap__b = e;
      while (1) {
        ap__b->link.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                (char *)((void *)0)));
        ap__b->link.prev = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                 (char *)((void *)0))))->link.prev;
        (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                               (char *)((void *)0))))->link.prev)->link.next = ap__b;
        ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                              (char *)((void *)0))))->link.prev = ap__b;
        break;
      }
      break;
    }
    e = apr_bucket_eos_create(c->bucket_alloc);
    while (1) {
      ap__b___0 = e;
      while (1) {
        ap__b___0->link.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                    (char *)((void *)0)));
        ap__b___0->link.prev = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                     (char *)((void *)0))))->link.prev;
        (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                               (char *)((void *)0))))->link.prev)->link.next = ap__b___0;
        ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                              (char *)((void *)0))))->link.prev = ap__b___0;
        break;
      }
      break;
    }
    tmp___3 = ap_pass_brigade(r->output_filters, bb);
    return (tmp___3);
  }
  if (r->path_info) {
    if ((*(r->path_info))) {
      tmp___4 = ap_find_path_info((char const   *)r->uri, (char const   *)r->path_info);
      (*(r->uri + tmp___4)) = (char )'\000';
    } else {
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ ;
  }
  udir = ap_make_dirstr_parent(r->pool, (char const   *)r->uri);
  udir = ap_os_escape_path(r->pool, (char const   *)udir, 1);
  tmp___5 = apr_pstrcat(r->pool, udir, best->file_name, r->path_info, (void *)0);
  ap_internal_redirect(tmp___5, r);
  return (0);
}
}
static int handle_multi(request_rec *r ) 
{ negotiation_state *neg ;
  var_rec *best ;
  var_rec *avail_recs ;
  request_rec *sub_req ;
  int res ;
  int j ;
  int tmp ;
  var_rec *variant ;
  int tmp___0 ;
  var_rec *variant___0 ;

  {
  if ((int )r->finfo.filetype != 0) {
    goto _L;
  } else {
    tmp = ap_allow_options(r);
    if (! (tmp & 128)) {
      _L: /* CIL Label */ 
      return (-1);
    }
  }
  neg = parse_accept_headers(r);
  res = read_types_multi(neg);
  if (res) {
    return_from_multi: 
    avail_recs = (var_rec *)(neg->avail_vars)->elts;
    j = 0;
    while (j < (neg->avail_vars)->nelts) {
      variant = avail_recs + j;
      if (variant->sub_req) {
        ap_destroy_sub_req(variant->sub_req);
      }
      j ++;
    }
    return (res);
  }
  if ((neg->avail_vars)->nelts == 0) {
    return (-1);
  }
  if (r->method_number != 0) {
    goto _L___2;
  } else {
    if (r->args) {
      _L___2: /* CIL Label */ 
      goto _L___0;
    } else {
      if (r->path_info) {
        if ((*(r->path_info))) {
          _L___0: /* CIL Label */ 
          tmp___0 = 1;
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        tmp___0 = 0;
      }
    }
  }
  res = do_negotiation(r, neg, & best, tmp___0);
  if (res != 0) {
    goto return_from_multi;
  }
  sub_req = best->sub_req;
  if (! sub_req) {
    sub_req = ap_sub_req_lookup_file(best->file_name, (request_rec const   *)r, (ap_filter_t *)((void *)0));
    if (sub_req->status != 200) {
      res = sub_req->status;
      ap_destroy_sub_req(sub_req);
      goto return_from_multi;
    }
  }
  ap_internal_fast_redirect(sub_req, r);
  r->mtime = 0LL;
  avail_recs = (var_rec *)(neg->avail_vars)->elts;
  j = 0;
  while (j < (neg->avail_vars)->nelts) {
    variant___0 = avail_recs + j;
    if ((unsigned int )variant___0 != (unsigned int )best) {
      if (variant___0->sub_req) {
        ap_destroy_sub_req(variant___0->sub_req);
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ ;
    }
    j ++;
  }
  return (0);
}
}
static int fix_encoding(request_rec *r ) 
{ char const   *enc ;
  char *x_enc ;
  apr_array_header_t *accept_encodings ;
  accept_rec *accept_recs ;
  int i ;
  char const   *tmp ;
  char *name ;
  int tmp___0 ;
  int tmp___1 ;

  {
  enc = r->content_encoding;
  x_enc = (char *)((void *)0);
  if (! enc) {
    goto _L;
  } else {
    if (! (*enc)) {
      _L: /* CIL Label */ 
      return (-1);
    }
  }
  if ((int const   )(*(enc + 0)) == 120) {
    if ((int const   )(*(enc + 1)) == 45) {
      enc += 2;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
  tmp = apr_table_get((apr_table_t const   *)r->headers_in, "Accept-Encoding");
  accept_encodings = do_header_line(r->pool, tmp);
  if ((unsigned int )accept_encodings == (unsigned int )((void *)0)) {
    return (-1);
  }
  accept_recs = (accept_rec *)accept_encodings->elts;
  i = 0;
  while (i < accept_encodings->nelts) {
    name = (accept_recs + i)->name;
    tmp___0 = strcmp((char const   *)name, enc);
    if (! tmp___0) {
      r->content_encoding = (char const   *)name;
      return (0);
    }
    if ((int )(*(name + 0)) == 120) {
      if ((int )(*(name + 1)) == 45) {
        tmp___1 = strcmp((char const   *)(name + 2), enc);
        if (tmp___1) {
          goto _L___2;
        } else {
          x_enc = name;
        }
      } else {
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ ;
    }
    i ++;
  }
  if (x_enc) {
    r->content_encoding = (char const   *)x_enc;
    return (0);
  }
  return (-1);
}
}
static void register_hooks___11(apr_pool_t *p ) 
{ 

  {
  ap_hook_fixups(& fix_encoding, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                 10);
  ap_hook_type_checker(& handle_multi, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                       0);
  ap_hook_handler(& handle_map_file, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                  10);
  return;
}
}
struct module_struct negotiation_module  = 
     {20020903, 0, -1, "mod_negotiation.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, (void (*)(process_rec *process ))((void *)0), & create_neg_dir_config,
    & merge_neg_dir_configs, (void *(*)(apr_pool_t *p , server_rec *s ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), negotiation_cmds,
    & register_hooks___11};
#pragma merger(0,"/tmp/cil-AqkMvxsL.i","-g -pthread")
char *ap_construct_url(apr_pool_t *p , char const   *uri , request_rec *r ) ;
static char const   *add_index(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ dir_config_rec *d ;
  void *tmp ;

  {
  d = (dir_config_rec *)dummy;
  if (! d->index_names) {
    d->index_names = apr_array_make(cmd->pool, 2, (int )sizeof(char *));
  }
  tmp = apr_array_push(d->index_names);
  (*((char const   **)tmp)) = arg;
  return ((char const   *)((void *)0));
}
}
static command_rec const   dir_cmds[2]  = {      {"DirectoryIndex", {& add_index}, (void *)0, 16, 3, "a list of file names"}, 
        {(char const   *)((void *)0), {.no_args = (char const   *(*)(cmd_parms *parms ,
                                                                  void *mconfig ))0},
      (void *)0, 0, 0, (char const   *)0}};
static void *create_dir_config(apr_pool_t *p , char *dummy ) 
{ dir_config_rec *new ;
  void *tmp ;
  dir_config_rec *tmp___0 ;

  {
  tmp = apr_palloc(p, sizeof(dir_config_rec ));
  tmp___0 = (dir_config_rec *)memset(tmp, 0, sizeof(dir_config_rec ));
  new = tmp___0;
  new->index_names = (apr_array_header_t *)((void *)0);
  return ((void *)new);
}
}
static void *merge_dir_configs(apr_pool_t *p , void *basev , void *addv ) 
{ dir_config_rec *new ;
  void *tmp ;
  dir_config_rec *tmp___0 ;
  dir_config_rec *base ;
  dir_config_rec *add ;

  {
  tmp = apr_palloc(p, sizeof(dir_config_rec ));
  tmp___0 = (dir_config_rec *)memset(tmp, 0, sizeof(dir_config_rec ));
  new = tmp___0;
  base = (dir_config_rec *)basev;
  add = (dir_config_rec *)addv;
  if (add->index_names) {
    new->index_names = add->index_names;
  } else {
    new->index_names = base->index_names;
  }
  return ((void *)new);
}
}
static int fixup_dir(request_rec *r ) 
{ dir_config_rec *d ;
  char *dummy_ptr[1] ;
  char **names_ptr ;
  int num_names ;
  int error_notfound ;
  char *ifile ;
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  char *name_ptr ;
  request_rec *rr ;

  {
  error_notfound = 0;
  if ((int )r->finfo.filetype != 2) {
    return (-1);
  }
  if (! r->handler) {
    r->handler = "httpd/unix-directory";
  }
  if (r->path_info) {
    if ((*(r->path_info))) {
      return (-1);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  if ((int )(*(r->uri + 0)) == 0) {
    goto _L___1;
  } else {
    tmp___3 = strlen((char const   *)r->uri);
    if ((int )(*(r->uri + (tmp___3 - 1U))) != 47) {
      _L___1: /* CIL Label */ 
      if (r->method_number != 0) {
        tmp = apr_table_get((apr_table_t const   *)r->subprocess_env, "redirect-carefully");
        if (tmp) {
          return (-1);
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ ;
      }
      if ((unsigned int )r->args != (unsigned int )((void *)0)) {
        tmp___0 = ap_os_escape_path(r->pool, (char const   *)r->uri, 1);
        ifile = apr_pstrcat(r->pool, tmp___0, "/", "?", r->args, (void *)0);
      } else {
        tmp___1 = ap_os_escape_path(r->pool, (char const   *)r->uri, 1);
        ifile = apr_pstrcat(r->pool, tmp___1, "/", (void *)0);
      }
      tmp___2 = ap_construct_url(r->pool, (char const   *)ifile, r);
      apr_table_setn(r->headers_out, "Location", tmp___2);
      return (301);
    }
  }
  tmp___4 = strcmp(r->handler, "httpd/unix-directory");
  if (tmp___4) {
    return (-1);
  }
  d = (dir_config_rec *)(*((void **)r->per_dir_config + dir_module.module_index));
  if (d->index_names) {
    names_ptr = (char **)(d->index_names)->elts;
    num_names = (d->index_names)->nelts;
  } else {
    dummy_ptr[0] = (char *)"index.html";
    names_ptr = dummy_ptr;
    num_names = 1;
  }
  while (num_names) {
    name_ptr = (*names_ptr);
    if ((unsigned int )r->args != (unsigned int )((void *)0)) {
      name_ptr = apr_pstrcat(r->pool, name_ptr, "?", r->args, (void *)0);
    }
    rr = ap_sub_req_lookup_uri((char const   *)name_ptr, (request_rec const   *)r,
                               (ap_filter_t *)((void *)0));
    if (rr->status == 200) {
      if ((int )rr->finfo.filetype == 1) {
        ap_internal_fast_redirect(rr, r);
        return (0);
      } else {
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ ;
    }
    if (rr->status >= 300) {
      if (rr->status < 400) {
        goto _L___5;
      } else {
        goto _L___7;
      }
    } else {
      _L___7: /* CIL Label */ 
      if (rr->status == 406) {
        if (num_names == 1) {
          _L___5: /* CIL Label */ 
          goto _L___3;
        } else {
          goto _L___6;
        }
      } else {
        _L___6: /* CIL Label */ 
        if (rr->status == 401) {
          if (num_names == 1) {
            _L___3: /* CIL Label */ 
            error_notfound = rr->status;
            r->notes = apr_table_overlay(r->pool, (apr_table_t const   *)r->notes,
                                         (apr_table_t const   *)rr->notes);
            r->headers_out = apr_table_overlay(r->pool, (apr_table_t const   *)r->headers_out,
                                               (apr_table_t const   *)rr->headers_out);
            r->err_headers_out = apr_table_overlay(r->pool, (apr_table_t const   *)r->err_headers_out,
                                                   (apr_table_t const   *)rr->err_headers_out);
            return (error_notfound);
          } else {
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ ;
        }
      }
    }
    if (rr->status) {
      if (rr->status != 404) {
        if (rr->status != 200) {
          error_notfound = rr->status;
        } else {
          goto _L___9;
        }
      } else {
        goto _L___9;
      }
    } else {
      _L___9: /* CIL Label */ ;
    }
    ap_destroy_sub_req(rr);
    names_ptr ++;
    num_names --;
  }
  if (error_notfound) {
    return (error_notfound);
  }
  return (-1);
}
}
static void register_hooks___12(apr_pool_t *p ) 
{ 

  {
  ap_hook_fixups(& fixup_dir, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                 20);
  return;
}
}
struct module_struct dir_module  = 
     {20020903, 0, -1, "mod_dir.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, (void (*)(process_rec *process ))((void *)0), & create_dir_config,
    & merge_dir_configs, (void *(*)(apr_pool_t *p , server_rec *s ))((void *)0), (void *(*)(apr_pool_t *p ,
                                                                                            void *base_conf ,
                                                                                            void *new_conf ))((void *)0),
    dir_cmds, & register_hooks___12};
#pragma merger(0,"/tmp/cil-FmT1GiiO.i","-g -pthread")
extern int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                  , ...) ;
extern double strtod(char const   * __restrict  __nptr , char ** __restrict  __endptr ) ;
static void *create_imap_dir_config(apr_pool_t *p , char *dummy ) 
{ imap_conf_rec *icr ;
  imap_conf_rec *tmp ;

  {
  tmp = (imap_conf_rec *)apr_palloc(p, sizeof(imap_conf_rec ));
  icr = tmp;
  icr->imap_menu = (char *)((void *)0);
  icr->imap_default = (char *)((void *)0);
  icr->imap_base = (char *)((void *)0);
  return ((void *)icr);
}
}
static void *merge_imap_dir_configs(apr_pool_t *p , void *basev , void *addv ) 
{ imap_conf_rec *new ;
  void *tmp ;
  imap_conf_rec *tmp___0 ;
  imap_conf_rec *base ;
  imap_conf_rec *add ;

  {
  tmp = apr_palloc(p, sizeof(imap_conf_rec ));
  tmp___0 = (imap_conf_rec *)memset(tmp, 0, sizeof(imap_conf_rec ));
  new = tmp___0;
  base = (imap_conf_rec *)basev;
  add = (imap_conf_rec *)addv;
  if (add->imap_menu) {
    new->imap_menu = add->imap_menu;
  } else {
    new->imap_menu = base->imap_menu;
  }
  if (add->imap_default) {
    new->imap_default = add->imap_default;
  } else {
    new->imap_default = base->imap_default;
  }
  if (add->imap_base) {
    new->imap_base = add->imap_base;
  } else {
    new->imap_base = base->imap_base;
  }
  return ((void *)new);
}
}
static command_rec const   imap_cmds[4]  = {      {"ImapMenu", {& ap_set_string_slot}, (void *)((long )((char *)(& ((imap_conf_rec *)((void *)0))->imap_menu) -
                                                           (char *)((void *)0))),
      16, 1, "the type of menu generated: none, formatted, semiformatted, unformatted"}, 
        {"ImapDefault",
      {& ap_set_string_slot}, (void *)((long )((char *)(& ((imap_conf_rec *)((void *)0))->imap_default) -
                                               (char *)((void *)0))), 16, 1, "the action taken if no match: error, nocontent, referer, menu, URL"}, 
        {"ImapBase",
      {& ap_set_string_slot}, (void *)((long )((char *)(& ((imap_conf_rec *)((void *)0))->imap_base) -
                                               (char *)((void *)0))), 16, 1, "the base for all URL\'s: map, referer, URL (or start of)"}, 
        {(char const   *)((void *)0),
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))0}, (void *)0,
      0, 0, (char const   *)0}};
static int pointinrect(double const   *point , double (*coords)[2] ) 
{ double max[2] ;
  double min[2] ;
  int tmp ;

  {
  if ((*(coords + 0))[0] > (*(coords + 1))[0]) {
    max[0] = (*(coords + 0))[0];
    min[0] = (*(coords + 1))[0];
  } else {
    max[0] = (*(coords + 1))[0];
    min[0] = (*(coords + 0))[0];
  }
  if ((*(coords + 0))[1] > (*(coords + 1))[1]) {
    max[1] = (*(coords + 0))[1];
    min[1] = (*(coords + 1))[1];
  } else {
    max[1] = (*(coords + 1))[1];
    min[1] = (*(coords + 0))[1];
  }
  if ((*(point + 0)) >= (double const   )min[0]) {
    if ((*(point + 0)) <= (double const   )max[0]) {
      if ((*(point + 1)) >= (double const   )min[1]) {
        if ((*(point + 1)) <= (double const   )max[1]) {
          tmp = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    tmp = 0;
  }
  return (tmp);
}
}
static int pointincircle(double const   *point , double (*coords)[2] ) 
{ double radius1 ;
  double radius2 ;

  {
  radius1 = ((*(coords + 0))[1] - (*(coords + 1))[1]) * ((*(coords + 0))[1] - (*(coords +
                                                                                 1))[1]) +
            ((*(coords + 0))[0] - (*(coords + 1))[0]) * ((*(coords + 0))[0] - (*(coords +
                                                                                 1))[0]);
  radius2 = ((*(coords + 0))[1] - (double )(*(point + 1))) * ((*(coords + 0))[1] -
                                                              (double )(*(point +
                                                                          1))) + ((*(coords +
                                                                                     0))[0] -
                                                                                  (double )(*(point +
                                                                                              0))) *
                                                                                 ((*(coords +
                                                                                     0))[0] -
                                                                                  (double )(*(point +
                                                                                              0)));
  return (radius2 <= radius1);
}
}
static int pointinpoly(double const   *point , double (*pgon)[2] ) 
{ int i ;
  int numverts ;
  int crossings ;
  double x ;
  double y ;
  double x1 ;
  double y1 ;
  double x2 ;
  double y2 ;
  double d ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  crossings = 0;
  x = (double )(*(point + 0));
  y = (double )(*(point + 1));
  numverts = 0;
  while (1) {
    if ((*(pgon + numverts))[0] != (double )-1) {
      if (! (numverts < 100)) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      break;
    }
    numverts ++;
  }
  i = 0;
  while (i < numverts) {
    x1 = (*(pgon + i))[0];
    y1 = (*(pgon + i))[1];
    x2 = (*(pgon + (i + 1) % numverts))[0];
    y2 = (*(pgon + (i + 1) % numverts))[1];
    d = (y - y1) * (x2 - x1) - (x - x1) * (y2 - y1);
    if ((y1 >= y) != (y2 >= y)) {
      if (y2 - y1 >= (double )0) {
        tmp = d >= (double )0;
      } else {
        tmp = d <= (double )0;
      }
      crossings += tmp;
    }
    if (! d) {
      if (x1 > x2) {
        tmp___0 = x2;
      } else {
        tmp___0 = x1;
      }
      if (tmp___0 <= x) {
        if (x1 > x2) {
          tmp___1 = x1;
        } else {
          tmp___1 = x2;
        }
        if (x <= tmp___1) {
          if (y1 > y2) {
            tmp___2 = y2;
          } else {
            tmp___2 = y1;
          }
          if (tmp___2 <= y) {
            if (y1 > y2) {
              tmp___3 = y1;
            } else {
              tmp___3 = y2;
            }
            if (y <= tmp___3) {
              return (1);
            } else {
              goto _L___3;
            }
          } else {
            goto _L___3;
          }
        } else {
          goto _L___3;
        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ ;
    }
    i ++;
  }
  return (crossings & 1);
}
}
static int is_closer(double const   *point , double (*coords)[2] , double *closest ) 
{ double dist_squared ;

  {
  dist_squared = (double )(((*(point + 0)) - (double const   )(*(coords + 0))[0]) *
                           ((*(point + 0)) - (double const   )(*(coords + 0))[0]) +
                           ((*(point + 1)) - (double const   )(*(coords + 0))[1]) *
                           ((*(point + 1)) - (double const   )(*(coords + 0))[1]));
  if ((*(point + 0)) < (double const   )0) {
    goto _L;
  } else {
    if ((*(point + 1)) < (double const   )0) {
      _L: /* CIL Label */ 
      return (0);
    }
  }
  if ((*closest) < (double )0) {
    goto _L___0;
  } else {
    if (dist_squared < (*closest)) {
      _L___0: /* CIL Label */ 
      (*closest) = dist_squared;
      return (1);
    }
  }
  return (0);
}
}
static double get_x_coord(char const   *args ) 
{ char *endptr ;
  double x_coord ;
  unsigned short const   **tmp ;

  {
  x_coord = (double )-1;
  if ((unsigned int )args == (unsigned int )((void *)0)) {
    return ((double )-1);
  }
  while (1) {
    if ((*args)) {
      tmp = __ctype_b_loc();
      if ((int const   )(*((*tmp) + (int )((unsigned char )(*args)))) & 2048) {
        goto _L___0;
      } else {
        if (! ((int const   )(*args) != 44)) {
          goto _L___0;
        }
      }
    } else {
      _L___0: /* CIL Label */ 
      break;
    }
    args ++;
  }
  x_coord = strtod((char const   * __restrict  )args, (char ** __restrict  )(& endptr));
  if ((unsigned int )endptr > (unsigned int )args) {
    return (x_coord);
  }
  return ((double )-1);
}
}
static double get_y_coord(char const   *args ) 
{ char *endptr ;
  char const   *start_of_y ;
  double y_coord ;
  unsigned short const   **tmp ;

  {
  start_of_y = (char const   *)((void *)0);
  y_coord = (double )-1;
  if ((unsigned int )args == (unsigned int )((void *)0)) {
    return ((double )-1);
  }
  start_of_y = strchr(args, ',');
  if (start_of_y) {
    start_of_y ++;
    while (1) {
      if ((*start_of_y)) {
        tmp = __ctype_b_loc();
        if ((int const   )(*((*tmp) + (int )((unsigned char )(*start_of_y)))) & 2048) {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        break;
      }
      start_of_y ++;
    }
    y_coord = strtod((char const   * __restrict  )start_of_y, (char ** __restrict  )(& endptr));
    if ((unsigned int )endptr > (unsigned int )start_of_y) {
      return (y_coord);
    }
  }
  return ((double )-1);
}
}
static void read_quoted(char **string , char **quoted_part ) 
{ char *strp ;
  unsigned short const   **tmp ;

  {
  strp = (*string);
  (*quoted_part) = (char *)((void *)0);
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*strp)))) & 8192)) {
      break;
    }
    strp ++;
  }
  if ((int )(*strp) == 34) {
    strp ++;
    (*quoted_part) = strp;
    while (1) {
      if ((*strp)) {
        if (! ((int )(*strp) != 34)) {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        break;
      }
      strp ++;
    }
    (*strp) = (char )'\000';
    strp ++;
    (*string) = strp;
  }
  return;
}
}
static char *imap_url(request_rec *r , char const   *base , char const   *value ) 
{ int slen ;
  int clen ;
  char *string_pos ;
  char const   *string_pos_const ;
  char *directory ;
  char const   *referer ;
  char *my_base ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;

  {
  string_pos = (char *)((void *)0);
  string_pos_const = (char const   *)((void *)0);
  directory = (char *)((void *)0);
  referer = (char const   *)((void *)0);
  tmp___0 = strcasecmp(value, "map");
  if (tmp___0) {
    tmp___1 = strcasecmp(value, "menu");
    if (! tmp___1) {
      _L: /* CIL Label */ 
      tmp = ap_construct_url(r->pool, (char const   *)r->uri, r);
      return (tmp);
    }
  } else {
    goto _L;
  }
  tmp___3 = strcasecmp(value, "nocontent");
  if (tmp___3) {
    tmp___4 = strcasecmp(value, "error");
    if (! tmp___4) {
      _L___0: /* CIL Label */ 
      tmp___2 = apr_pstrdup(r->pool, value);
      return (tmp___2);
    }
  } else {
    goto _L___0;
  }
  tmp___6 = strcasecmp(value, "referer");
  if (! tmp___6) {
    referer = apr_table_get((apr_table_t const   *)r->headers_in, "Referer");
    if (referer) {
      if ((*referer)) {
        tmp___5 = apr_pstrdup(r->pool, referer);
        return (tmp___5);
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      value = "";
    }
  }
  string_pos_const = value;
  while (1) {
    tmp___7 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___7) + (int )((unsigned char )(*string_pos_const)))) &
           1024)) {
      break;
    }
    string_pos_const ++;
  }
  if ((int const   )(*string_pos_const) == 58) {
    tmp___8 = apr_pstrdup(r->pool, value);
    return (tmp___8);
  }
  if (! base) {
    goto _L___3;
  } else {
    if (! (*base)) {
      _L___3: /* CIL Label */ 
      if (value) {
        if ((*value)) {
          tmp___9 = apr_pstrdup(r->pool, value);
          return (tmp___9);
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ ;
      }
      tmp___10 = ap_construct_url(r->pool, "/", r);
      return (tmp___10);
    }
  }
  tmp___11 = strchr(base, '/');
  if ((unsigned int )tmp___11 == (unsigned int )((void *)0)) {
    tmp___12 = strncmp(value, "../", 3U);
    if (tmp___12) {
      tmp___13 = strcmp(value, "..");
      if (tmp___13) {
        goto _L___4;
      } else {
        _L___5: /* CIL Label */ 
        ap_log_rerror("mod_imap.c", 423, 3, 0, (request_rec const   *)r, "invalid base directive in map file: %s",
                      r->uri);
        return ((char *)((void *)0));
      }
    } else {
      goto _L___5;
    }
  } else {
    _L___4: /* CIL Label */ ;
  }
  my_base = apr_pstrdup(r->pool, base);
  string_pos = my_base;
  while ((*string_pos)) {
    if ((int )(*string_pos) == 47) {
      if ((int )(*(string_pos + 1)) == 47) {
        string_pos += 2;
        continue;
      } else {
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ ;
    }
    if ((int )(*string_pos) == 47) {
      if ((int const   )(*(value + 0)) == 47) {
        (*string_pos) = (char )'\000';
      } else {
        directory = string_pos;
        string_pos = strrchr((char const   *)string_pos, '/');
        string_pos ++;
        (*string_pos) = (char )'\000';
      }
      break;
    }
    string_pos ++;
  }
  while (1) {
    tmp___16 = strncmp(value, "../", 3U);
    if (tmp___16) {
      tmp___17 = strcmp(value, "..");
      if (tmp___17) {
        break;
      } else {
        _L___9: /* CIL Label */ ;
      }
    } else {
      goto _L___9;
    }
    if (directory) {
      slen = (int )strlen((char const   *)directory);
      if (slen) {
        clen = slen - 1;
        while (slen - clen == 1) {
          string_pos = strrchr((char const   *)directory, '/');
          if (string_pos) {
            (*string_pos) = (char )'\000';
          }
          clen = (int )strlen((char const   *)directory);
          if (clen == 0) {
            break;
          }
        }
        value += 2;
      } else {
        goto _L___7;
      }
    } else {
      _L___7: /* CIL Label */ 
      if (directory) {
        ap_log_rerror("mod_imap.c", 483, 3, 0, (request_rec const   *)r, "invalid directory name in map file: %s",
                      r->uri);
        return ((char *)((void *)0));
      }
    }
    tmp___14 = strncmp(value, "/../", 4U);
    if (tmp___14) {
      tmp___15 = strcmp(value, "/..");
      if (! tmp___15) {
        _L___8: /* CIL Label */ 
        value ++;
      }
    } else {
      goto _L___8;
    }
  }
  if (value) {
    if ((*value)) {
      tmp___18 = apr_pstrcat(r->pool, my_base, value, (void *)0);
      return (tmp___18);
    } else {
      goto _L___10;
    }
  } else {
    _L___10: /* CIL Label */ ;
  }
  return (my_base);
}
}
static int imap_reply(request_rec *r , char *redirect ) 
{ int tmp ;
  int tmp___0 ;

  {
  tmp = strcasecmp((char const   *)redirect, "error");
  if (! tmp) {
    return (500);
  }
  tmp___0 = strcasecmp((char const   *)redirect, "nocontent");
  if (! tmp___0) {
    return (204);
  }
  if (redirect) {
    if ((*redirect)) {
      apr_table_setn(r->headers_out, "Location", (char const   *)redirect);
      return (302);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  return (500);
}
}
static void menu_header(request_rec *r , char *menu ) 
{ int tmp ;

  {
  ap_set_content_type(r, "text/html");
  ap_rvputs(r, "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n", "<html><head>\n<title>Menu for ",
            r->uri, "</title>\n</head><body>\n", (void *)0);
  tmp = strcasecmp((char const   *)menu, "formatted");
  if (! tmp) {
    ap_rvputs(r, "<h1>Menu for ", r->uri, "</h1>\n<hr />\n\n", (void *)0);
  }
  return;
}
}
static void menu_blank(request_rec *r , char *menu ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = strcasecmp((char const   *)menu, "formatted");
  if (! tmp) {
    ap_rputs("\n", r);
  }
  tmp___0 = strcasecmp((char const   *)menu, "semiformatted");
  if (! tmp___0) {
    ap_rputs("<br />\n", r);
  }
  tmp___1 = strcasecmp((char const   *)menu, "unformatted");
  if (! tmp___1) {
    ap_rputs("\n", r);
  }
  return;
}
}
static void menu_comment(request_rec *r , char *menu , char *comment ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = strcasecmp((char const   *)menu, "formatted");
  if (! tmp) {
    ap_rputs("\n", r);
  }
  tmp___0 = strcasecmp((char const   *)menu, "semiformatted");
  if (tmp___0) {
    _L: /* CIL Label */ ;
  } else {
    if ((*comment)) {
      ap_rvputs(r, comment, "\n", (void *)0);
    } else {
      goto _L;
    }
  }
  tmp___1 = strcasecmp((char const   *)menu, "unformatted");
  if (tmp___1) {
    _L___0: /* CIL Label */ ;
  } else {
    if ((*comment)) {
      ap_rvputs(r, comment, "\n", (void *)0);
    } else {
      goto _L___0;
    }
  }
  return;
}
}
static void menu_default(request_rec *r , char *menu , char *href , char *text ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = strcasecmp((char const   *)href, "error");
  if (tmp) {
    tmp___0 = strcasecmp((char const   *)href, "nocontent");
    if (! tmp___0) {
      _L: /* CIL Label */ 
      return;
    }
  } else {
    goto _L;
  }
  tmp___1 = strcasecmp((char const   *)menu, "formatted");
  if (! tmp___1) {
    ap_rvputs(r, "<pre>(Default) <a href=\"", href, "\">", text, "</a></pre>\n", (void *)0);
  }
  tmp___2 = strcasecmp((char const   *)menu, "semiformatted");
  if (! tmp___2) {
    ap_rvputs(r, "<pre>(Default) <a href=\"", href, "\">", text, "</a></pre>\n", (void *)0);
  }
  tmp___3 = strcasecmp((char const   *)menu, "unformatted");
  if (! tmp___3) {
    ap_rvputs(r, "<a href=\"", href, "\">", text, "</a>", (void *)0);
  }
  return;
}
}
static void menu_directive(request_rec *r , char *menu , char *href , char *text ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = strcasecmp((char const   *)href, "error");
  if (tmp) {
    tmp___0 = strcasecmp((char const   *)href, "nocontent");
    if (! tmp___0) {
      _L: /* CIL Label */ 
      return;
    }
  } else {
    goto _L;
  }
  tmp___1 = strcasecmp((char const   *)menu, "formatted");
  if (! tmp___1) {
    ap_rvputs(r, "<pre>          <a href=\"", href, "\">", text, "</a></pre>\n", (void *)0);
  }
  tmp___2 = strcasecmp((char const   *)menu, "semiformatted");
  if (! tmp___2) {
    ap_rvputs(r, "<pre>          <a href=\"", href, "\">", text, "</a></pre>\n", (void *)0);
  }
  tmp___3 = strcasecmp((char const   *)menu, "unformatted");
  if (! tmp___3) {
    ap_rvputs(r, "<a href=\"", href, "\">", text, "</a>", (void *)0);
  }
  return;
}
}
static void menu_footer(request_rec *r ) 
{ 

  {
  ap_rputs("\n\n</body>\n</html>\n", r);
  return;
}
}
static int imap_handler_internal(request_rec *r ) 
{ char input[8192] ;
  char *directive ;
  char *value ;
  char *href_text ;
  char *base ;
  char *redirect ;
  char *mapdflt ;
  char *closest ;
  double closest_yet ;
  apr_status_t status ;
  double testpoint[2] ;
  double pointarray[101][2] ;
  int vertex ;
  char *string_pos ;
  int showmenu ;
  imap_conf_rec *icr ;
  char *imap_menu ;
  char *imap_default ;
  char *imap_base ;
  ap_configfile_t *imap ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;

  {
  closest = (char *)((void *)0);
  closest_yet = (double )-1;
  showmenu = 0;
  icr = (imap_conf_rec *)(*((void **)r->per_dir_config + imap_module.module_index));
  if (icr->imap_menu) {
    imap_menu = icr->imap_menu;
  } else {
    imap_menu = (char *)"formatted";
  }
  if (icr->imap_default) {
    imap_default = icr->imap_default;
  } else {
    imap_default = (char *)"nocontent";
  }
  if (icr->imap_base) {
    imap_base = icr->imap_base;
  } else {
    imap_base = (char *)"map";
  }
  status = ap_pcfg_openfile(& imap, r->pool, (char const   *)r->filename);
  if (status != 0) {
    return (404);
  }
  base = imap_url(r, (char const   *)((void *)0), (char const   *)imap_base);
  if (! base) {
    return (500);
  }
  mapdflt = imap_url(r, (char const   *)((void *)0), (char const   *)imap_default);
  if (! mapdflt) {
    return (500);
  }
  testpoint[0] = get_x_coord((char const   *)r->args);
  testpoint[1] = get_y_coord((char const   *)r->args);
  if (testpoint[0] == (double )-1) {
    goto _L___1;
  } else {
    if (testpoint[1] == (double )-1) {
      _L___1: /* CIL Label */ 
      goto _L;
    } else {
      if (testpoint[0] == (double )0) {
        if (testpoint[1] == (double )0) {
          _L: /* CIL Label */ 
          testpoint[0] = (double )-1;
          testpoint[1] = (double )-1;
          tmp = strncasecmp((char const   *)imap_menu, "none", 2U);
          if (tmp) {
            showmenu = 1;
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ ;
      }
    }
  }
  if (showmenu) {
    menu_header(r, imap_menu);
  }
  while (1) {
    tmp___26 = ap_cfg_getline(input, sizeof(input), imap);
    if (tmp___26) {
      break;
    }
    if (! input[0]) {
      if (showmenu) {
        menu_blank(r, imap_menu);
      }
      continue;
    }
    if ((int )input[0] == 35) {
      if (showmenu) {
        menu_comment(r, imap_menu, input + 1);
      }
      continue;
    }
    string_pos = input;
    if (! (*string_pos)) {
      goto need_2_fields;
    }
    directive = string_pos;
    while (1) {
      if ((*string_pos)) {
        tmp___0 = __ctype_b_loc();
        if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*string_pos)))) &
            8192) {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
        break;
      }
      string_pos ++;
    }
    if (! (*string_pos)) {
      goto need_2_fields;
    }
    tmp___1 = string_pos;
    string_pos ++;
    (*tmp___1) = (char )'\000';
    if (! (*string_pos)) {
      goto need_2_fields;
    }
    while (1) {
      if ((*string_pos)) {
        tmp___2 = __ctype_b_loc();
        if (! ((int const   )(*((*tmp___2) + (int )((unsigned char )(*string_pos)))) &
               8192)) {
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
        break;
      }
      string_pos ++;
    }
    value = string_pos;
    while (1) {
      if ((*string_pos)) {
        tmp___3 = __ctype_b_loc();
        if ((int const   )(*((*tmp___3) + (int )((unsigned char )(*string_pos)))) &
            8192) {
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
        break;
      }
      string_pos ++;
    }
    tmp___5 = __ctype_b_loc();
    if ((int const   )(*((*tmp___5) + (int )((unsigned char )(*string_pos)))) & 8192) {
      tmp___4 = string_pos;
      string_pos ++;
      (*tmp___4) = (char )'\000';
    } else {
      (*string_pos) = (char )'\000';
    }
    tmp___6 = strncasecmp((char const   *)directive, "base", 4U);
    if (! tmp___6) {
      base = imap_url(r, (char const   *)((void *)0), (char const   *)value);
      if (! base) {
        goto menu_bail;
      }
      continue;
    }
    read_quoted(& string_pos, & href_text);
    tmp___8 = strcasecmp((char const   *)directive, "default");
    if (! tmp___8) {
      mapdflt = imap_url(r, (char const   *)((void *)0), (char const   *)value);
      if (! mapdflt) {
        goto menu_bail;
      }
      if (showmenu) {
        redirect = imap_url(r, (char const   *)base, (char const   *)mapdflt);
        if (! redirect) {
          goto menu_bail;
        }
        if (href_text) {
          tmp___7 = href_text;
        } else {
          tmp___7 = mapdflt;
        }
        menu_default(r, imap_menu, redirect, tmp___7);
      }
      continue;
    }
    vertex = 0;
    while (1) {
      if (vertex < 100) {
        tmp___13 = sscanf((char const   * __restrict  )string_pos, (char const   * __restrict  )"%lf%*[, ]%lf",
                          & pointarray[vertex][0], & pointarray[vertex][1]);
        if (! (tmp___13 == 2)) {
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
        break;
      }
      while (1) {
        tmp___9 = __ctype_b_loc();
        if (! ((int const   )(*((*tmp___9) + (int )((unsigned char )(*string_pos)))) &
               8192)) {
          break;
        }
        string_pos ++;
      }
      while (1) {
        tmp___10 = __ctype_b_loc();
        if (! ((int const   )(*((*tmp___10) + (int )((unsigned char )(*string_pos)))) &
               2048)) {
          break;
        }
        string_pos ++;
      }
      string_pos ++;
      while (1) {
        tmp___11 = __ctype_b_loc();
        if (! ((int const   )(*((*tmp___11) + (int )((unsigned char )(*string_pos)))) &
               8192)) {
          break;
        }
        string_pos ++;
      }
      while (1) {
        tmp___12 = __ctype_b_loc();
        if (! ((int const   )(*((*tmp___12) + (int )((unsigned char )(*string_pos)))) &
               2048)) {
          break;
        }
        string_pos ++;
      }
      vertex ++;
    }
    pointarray[vertex][0] = (double )-1;
    if (showmenu) {
      if (! href_text) {
        read_quoted(& string_pos, & href_text);
      }
      redirect = imap_url(r, (char const   *)base, (char const   *)value);
      if (! redirect) {
        goto menu_bail;
      }
      if (href_text) {
        tmp___14 = href_text;
      } else {
        tmp___14 = value;
      }
      menu_directive(r, imap_menu, redirect, tmp___14);
      continue;
    }
    if (testpoint[0] == (double )-1) {
      goto _L___6;
    } else {
      if (pointarray[0][0] == (double )-1) {
        _L___6: /* CIL Label */ 
        continue;
      }
    }
    tmp___17 = strcasecmp((char const   *)directive, "poly");
    if (! tmp___17) {
      tmp___16 = pointinpoly((double const   *)(testpoint), pointarray);
      if (tmp___16) {
        ap_cfg_closefile(imap);
        redirect = imap_url(r, (char const   *)base, (char const   *)value);
        if (! redirect) {
          return (500);
        }
        tmp___15 = imap_reply(r, redirect);
        return (tmp___15);
      }
      continue;
    }
    tmp___20 = strcasecmp((char const   *)directive, "circle");
    if (! tmp___20) {
      tmp___19 = pointincircle((double const   *)(testpoint), pointarray);
      if (tmp___19) {
        ap_cfg_closefile(imap);
        redirect = imap_url(r, (char const   *)base, (char const   *)value);
        if (! redirect) {
          return (500);
        }
        tmp___18 = imap_reply(r, redirect);
        return (tmp___18);
      }
      continue;
    }
    tmp___23 = strcasecmp((char const   *)directive, "rect");
    if (! tmp___23) {
      tmp___22 = pointinrect((double const   *)(testpoint), pointarray);
      if (tmp___22) {
        ap_cfg_closefile(imap);
        redirect = imap_url(r, (char const   *)base, (char const   *)value);
        if (! redirect) {
          return (500);
        }
        tmp___21 = imap_reply(r, redirect);
        return (tmp___21);
      }
      continue;
    }
    tmp___25 = strcasecmp((char const   *)directive, "point");
    if (! tmp___25) {
      tmp___24 = is_closer((double const   *)(testpoint), pointarray, & closest_yet);
      if (tmp___24) {
        closest = apr_pstrdup(r->pool, (char const   *)value);
      }
      continue;
    }
  }
  ap_cfg_closefile(imap);
  if (showmenu) {
    menu_footer(r);
    return (0);
  }
  if (closest) {
    redirect = imap_url(r, (char const   *)base, (char const   *)closest);
    if (! redirect) {
      return (500);
    }
    tmp___27 = imap_reply(r, redirect);
    return (tmp___27);
  }
  if (mapdflt) {
    redirect = imap_url(r, (char const   *)base, (char const   *)mapdflt);
    if (! redirect) {
      return (500);
    }
    tmp___28 = imap_reply(r, redirect);
    return (tmp___28);
  }
  return (500);
  need_2_fields: 
  ap_log_rerror("mod_imap.c", 890, 3, 0, (request_rec const   *)r, "map file %s, line %d syntax error: requires at least two fields",
                r->uri, imap->line_number);
  menu_bail: 
  ap_cfg_closefile(imap);
  if (showmenu) {
    ap_rputs("\n\n[an internal server error occured]\n", r);
    menu_footer(r);
    return (0);
  }
  return (500);
}
}
static int imap_handler(request_rec *r ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (r->method_number != 0) {
    goto _L;
  } else {
    tmp___0 = strcmp(r->handler, "application/x-httpd-imap");
    if (tmp___0) {
      tmp___1 = strcmp(r->handler, "imap-file");
      if (tmp___1) {
        _L: /* CIL Label */ 
        return (-1);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      tmp = imap_handler_internal(r);
      return (tmp);
    }
  }
}
}
static void register_hooks___13(apr_pool_t *p ) 
{ 

  {
  ap_hook_handler(& imap_handler, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                  10);
  return;
}
}
struct module_struct imap_module  = 
     {20020903, 0, -1, "mod_imap.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, (void (*)(process_rec *process ))((void *)0), & create_imap_dir_config,
    & merge_imap_dir_configs, (void *(*)(apr_pool_t *p , server_rec *s ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), imap_cmds,
    & register_hooks___13};
#pragma merger(0,"/tmp/cil-bJUYWakL.i","-g -pthread")
char const   *ap_default_type(request_rec *r ) ;
static void *create_action_dir_config(apr_pool_t *p , char *dummy ) 
{ action_dir_config *new ;
  void *tmp ;
  action_dir_config *tmp___0 ;

  {
  tmp = apr_palloc(p, sizeof(action_dir_config ));
  tmp___0 = (action_dir_config *)memset(tmp, 0, sizeof(action_dir_config ));
  new = tmp___0;
  new->action_types = apr_table_make(p, 4);
  return ((void *)new);
}
}
static void *merge_action_dir_configs(apr_pool_t *p , void *basev , void *addv ) 
{ action_dir_config *base ;
  action_dir_config *add ;
  action_dir_config *new ;
  action_dir_config *tmp ;
  int i ;
  int tmp___0 ;

  {
  base = (action_dir_config *)basev;
  add = (action_dir_config *)addv;
  tmp = (action_dir_config *)apr_palloc(p, sizeof(action_dir_config ));
  new = tmp;
  new->action_types = apr_table_overlay(p, (apr_table_t const   *)add->action_types,
                                        (apr_table_t const   *)base->action_types);
  i = 0;
  while (i < 64) {
    if (add->scripted[i]) {
      new->scripted[i] = add->scripted[i];
    } else {
      new->scripted[i] = base->scripted[i];
    }
    i ++;
  }
  if (base->configured) {
    goto _L;
  } else {
    if (add->configured) {
      _L: /* CIL Label */ 
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  }
  new->configured = tmp___0;
  return ((void *)new);
}
}
static char const   *add_action(cmd_parms *cmd , void *m_v , char const   *type ,
                                char const   *script ) 
{ action_dir_config *m ;

  {
  m = (action_dir_config *)m_v;
  apr_table_setn(m->action_types, type, script);
  m->configured = 1;
  return ((char const   *)((void *)0));
}
}
static char const   *set_script(cmd_parms *cmd , void *m_v , char const   *method ,
                                char const   *script ) 
{ action_dir_config *m ;
  int methnum ;

  {
  m = (action_dir_config *)m_v;
  methnum = ap_method_number_of(method);
  if (methnum == 6) {
    return ("TRACE not allowed for Script");
  } else {
    if (methnum == 26) {
      return ("Unknown method type for Script");
    } else {
      m->scripted[methnum] = script;
    }
  }
  m->configured = 1;
  return ((char const   *)((void *)0));
}
}
static command_rec const   action_cmds[3]  = {      {"Action", {& add_action}, (void *)0, 4, 2, "a media type followed by a script name"}, 
        {"Script",
      {& set_script}, (void *)0, 192, 2, "a method followed by a script name"}, 
        {(char const   *)((void *)0), {.no_args = (char const   *(*)(cmd_parms *parms ,
                                                                  void *mconfig ))0},
      (void *)0, 0, 0, (char const   *)0}};
static int action_handler(request_rec *r ) 
{ action_dir_config *conf ;
  char const   *t ;
  char const   *action ;
  char const   *script ;
  int i ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;

  {
  conf = (action_dir_config *)(*((void **)r->per_dir_config + actions_module.module_index));
  if (! conf->configured) {
    return (-1);
  }
  i = 0;
  while (i < 64) {
    if (conf->scripted[i]) {
      r->allowed = r->allowed | (1LL << i);
    }
    i ++;
  }
  if (r->method_number == 0) {
    if (r->args) {
      script = conf->scripted[0];
    } else {
      script = (char const   *)((void *)0);
    }
  } else {
    script = conf->scripted[r->method_number];
  }
  if (script) {
    if (r->prev) {
      if ((r->prev)->prev) {
        return (-1);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
  if (r->handler) {
    action = r->handler;
  } else {
    action = ap_field_noparam(r->pool, r->content_type);
  }
  if (action) {
    tmp___1 = action;
  } else {
    tmp___1 = ap_default_type(r);
  }
  t = apr_table_get((apr_table_t const   *)conf->action_types, tmp___1);
  if (t) {
    script = t;
    if ((int )r->finfo.filetype == 0) {
      ap_log_rerror("mod_actions.c", 210, 3, 0, (request_rec const   *)r, "File does not exist: %s",
                    r->filename);
      return (404);
    }
  }
  if ((unsigned int )script == (unsigned int )((void *)0)) {
    return (-1);
  }
  if (r->args) {
    tmp___2 = "?";
  } else {
    tmp___2 = (char const   *)((void *)0);
  }
  tmp___3 = ap_os_escape_path(r->pool, (char const   *)r->uri, 1);
  tmp___4 = apr_pstrcat(r->pool, script, tmp___3, tmp___2, r->args, (void *)0);
  ap_internal_redirect_handler(tmp___4, r);
  return (0);
}
}
static void register_hooks___14(apr_pool_t *p ) 
{ 

  {
  ap_hook_handler(& action_handler, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                  20);
  return;
}
}
struct module_struct actions_module  = 
     {20020903, 0, -1, "mod_actions.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, (void (*)(process_rec *process ))((void *)0), & create_action_dir_config,
    & merge_action_dir_configs, (void *(*)(apr_pool_t *p , server_rec *s ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), action_cmds,
    & register_hooks___14};
#pragma merger(0,"/tmp/cil-c1WxDD4H.i","-g -pthread")
apr_status_t apr_get_userid(apr_uid_t *uid , apr_gid_t *gid , char const   *username ,
                            apr_pool_t *p ) ;
apr_status_t apr_get_home_directory(char **dirname , char const   *username , apr_pool_t *p ) ;
void ap_hook_translate_name(ap_HOOK_translate_name_t *pf , char const   * const  *aszPre___1 ,
                            char const   * const  *aszSucc___2 , int nOrder ) ;
void ap_hook_get_suexec_identity(ap_HOOK_get_suexec_identity_t *pf , char const   * const  *aszPre___1 ,
                                 char const   * const  *aszSucc___2 , int nOrder ) ;
static void *create_userdir_config(apr_pool_t *p , server_rec *s ) 
{ userdir_config *newcfg ;
  void *tmp ;
  userdir_config *tmp___0 ;

  {
  tmp = apr_palloc(p, sizeof((*newcfg)));
  tmp___0 = (userdir_config *)memset(tmp, 0, sizeof((*newcfg)));
  newcfg = tmp___0;
  newcfg->globally_disabled = 0;
  newcfg->userdir = (char *)"public_html";
  newcfg->enabled_users = apr_table_make(p, 4);
  newcfg->disabled_users = apr_table_make(p, 4);
  return ((void *)newcfg);
}
}
static char const   *set_user_dir(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ userdir_config *s_cfg ;
  char *username ;
  char const   *usernames ;
  char *kw ;
  char *tmp ;
  apr_table_t *usertable ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  s_cfg = (userdir_config *)(*((void **)(cmd->server)->module_config + userdir_module.module_index));
  usernames = arg;
  tmp = ap_getword_conf(cmd->pool, & usernames);
  kw = tmp;
  if ((int )(*kw) == 0) {
    return ("UserDir requires an argument.");
  }
  tmp___4 = strcasecmp((char const   *)kw, "disable");
  if (tmp___4) {
    tmp___5 = strcasecmp((char const   *)kw, "disabled");
    if (tmp___5) {
      tmp___2 = strcasecmp((char const   *)kw, "enable");
      if (tmp___2) {
        tmp___3 = strcasecmp((char const   *)kw, "enabled");
        if (tmp___3) {
          s_cfg->userdir = apr_pstrdup(cmd->pool, arg);
          return ((char const   *)((void *)0));
        } else {
          _L: /* CIL Label */ 
          tmp___1 = strlen(usernames);
          if (tmp___1 == 0U) {
            return ("UserDir \"enable\" keyword requires a list of usernames");
          }
          usertable = s_cfg->enabled_users;
        }
      } else {
        goto _L;
      }
    } else {
      _L___0: /* CIL Label */ 
      tmp___0 = strlen(usernames);
      if (tmp___0 == 0U) {
        s_cfg->globally_disabled = 1;
        return ((char const   *)((void *)0));
      }
      usertable = s_cfg->disabled_users;
    }
  } else {
    goto _L___0;
  }
  while ((*usernames)) {
    username = ap_getword_conf(cmd->pool, & usernames);
    apr_table_setn(usertable, (char const   *)username, (char const   *)kw);
  }
  return ((char const   *)((void *)0));
}
}
static command_rec const   userdir_cmds[2]  = {      {"UserDir", {& set_user_dir}, (void *)0, 128, 0, "the public subdirectory in users\' home directories, or \'disabled\', or \'disabled username username...\', or \'enabled username username...\'"}, 
        {(char const   *)((void *)0),
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))0}, (void *)0,
      0, 0, (char const   *)0}};
static int translate_userdir(request_rec *r ) 
{ ap_conf_vector_t *server_conf ;
  userdir_config const   *s_cfg ;
  char *name ;
  char const   *userdirs ;
  char const   *w ;
  char const   *dname ;
  char *redirect ;
  apr_finfo_t statbuf ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *userdir ;
  char const   *tmp___1 ;
  char *filename ;
  char *x ;
  apr_status_t rv ;
  int is_absolute ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *homedir ;
  apr_status_t tmp___5 ;
  char *tmp___6 ;

  {
  name = r->uri;
  if ((int )(*(name + 0)) != 47) {
    goto _L;
  } else {
    if ((int )(*(name + 1)) != 126) {
      _L: /* CIL Label */ 
      return (-1);
    }
  }
  server_conf = (r->server)->module_config;
  s_cfg = (userdir_config const   *)(*((void **)server_conf + userdir_module.module_index));
  userdirs = (char const   *)s_cfg->userdir;
  if ((unsigned int )userdirs == (unsigned int )((void *)0)) {
    return (-1);
  }
  dname = (char const   *)(name + 2);
  w = ap_getword(r->pool, & dname, (char )'/');
  if ((int const   )(*(dname + -1)) == 47) {
    dname --;
  }
  if ((int const   )(*(w + 0)) == 0) {
    goto _L___2;
  } else {
    if ((int const   )(*(w + 1)) == 46) {
      if ((int const   )(*(w + 2)) == 0) {
        goto _L___2;
      } else {
        if ((int const   )(*(w + 2)) == 46) {
          if ((int const   )(*(w + 3)) == 0) {
            _L___2: /* CIL Label */ 
            return (-1);
          } else {
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
          goto _L___1;
        }
      }
    } else {
      _L___1: /* CIL Label */ ;
    }
  }
  tmp = apr_table_get((apr_table_t const   *)s_cfg->disabled_users, w);
  if ((unsigned int )tmp != (unsigned int )((void *)0)) {
    return (-1);
  }
  if (s_cfg->globally_disabled) {
    tmp___0 = apr_table_get((apr_table_t const   *)s_cfg->enabled_users, w);
    if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
      return (-1);
    } else {
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ ;
  }
  while ((*userdirs)) {
    tmp___1 = ap_getword_conf(r->pool, & userdirs);
    userdir = tmp___1;
    filename = (char *)((void *)0);
    x = (char *)((void *)0);
    tmp___2 = ap_os_is_path_absolute(r->pool, userdir);
    is_absolute = tmp___2;
    tmp___3 = strchr(userdir, '*');
    if (tmp___3) {
      x = ap_getword(r->pool, & userdir, (char )'*');
    }
    if ((int const   )(*(userdir + 0)) == 0) {
      goto _L___7;
    } else {
      if (is_absolute) {
        _L___7: /* CIL Label */ 
        if (x) {
          tmp___4 = strchr((char const   *)x, ':');
          if (tmp___4) {
            if (! is_absolute) {
              redirect = apr_pstrcat(r->pool, x, w, userdir, dname, (void *)0);
              apr_table_setn(r->headers_out, "Location", (char const   *)redirect);
              return (302);
            } else {
              goto _L___5;
            }
          } else {
            _L___5: /* CIL Label */ 
            filename = apr_pstrcat(r->pool, x, w, userdir, (void *)0);
          }
        } else {
          filename = apr_pstrcat(r->pool, userdir, "/", w, (void *)0);
        }
      } else {
        if (x) {
          tmp___6 = strchr((char const   *)x, ':');
          if (tmp___6) {
            redirect = apr_pstrcat(r->pool, x, w, dname, (void *)0);
            apr_table_setn(r->headers_out, "Location", (char const   *)redirect);
            return (302);
          } else {
            goto _L___6;
          }
        } else {
          _L___6: /* CIL Label */ 
          tmp___5 = apr_get_home_directory(& homedir, w, r->pool);
          if (tmp___5 == 0) {
            filename = apr_pstrcat(r->pool, homedir, "/", userdir, (void *)0);
          }
        }
      }
    }
    if (filename) {
      if (! (*userdirs)) {
        goto _L___11;
      } else {
        rv = apr_stat(& statbuf, (char const   *)filename, 33136, r->pool);
        if (rv == 0) {
          goto _L___11;
        } else {
          if (rv == 70008) {
            _L___11: /* CIL Label */ 
            r->filename = apr_pstrcat(r->pool, filename, dname, (void *)0);
            if ((*userdirs)) {
              if ((int const   )(*(dname + 0)) == 0) {
                r->finfo = statbuf;
              } else {
                goto _L___8;
              }
            } else {
              _L___8: /* CIL Label */ ;
            }
            apr_table_setn(r->notes, "mod_userdir_user", w);
            return (0);
          } else {
            goto _L___9;
          }
        }
      }
    } else {
      _L___9: /* CIL Label */ ;
    }
  }
  return (-1);
}
}
static ap_unix_identity_t *get_suexec_id_doer(request_rec const   *r ) 
{ ap_unix_identity_t *ugid ;
  char const   *username ;
  char const   *tmp ;
  apr_status_t tmp___0 ;

  {
  ugid = (ap_unix_identity_t *)((void *)0);
  tmp = apr_table_get((apr_table_t const   *)r->notes, "mod_userdir_user");
  username = tmp;
  if ((unsigned int )username == (unsigned int )((void *)0)) {
    return ((ap_unix_identity_t *)((void *)0));
  }
  ugid = (ap_unix_identity_t *)apr_palloc(r->pool, sizeof(ap_unix_identity_t *));
  if ((unsigned int )ugid == (unsigned int )((void *)0)) {
    return ((ap_unix_identity_t *)((void *)0));
  }
  tmp___0 = apr_get_userid(& ugid->uid, & ugid->gid, username, r->pool);
  if (tmp___0 != 0) {
    return ((ap_unix_identity_t *)((void *)0));
  }
  ugid->userdir = 1;
  return (ugid);
}
}
static void register_hooks___15(apr_pool_t *p ) ;
static char const   * const  aszPre___0[2]  = {      (char const   * const  )"mod_alias.c",      (char const   * const  )((void *)0)};
static char const   * const  aszSucc[2]  = {      (char const   * const  )"mod_vhost_alias.c",      (char const   * const  )((void *)0)};
static void register_hooks___15(apr_pool_t *p ) 
{ 

  {
  ap_hook_translate_name(& translate_userdir, aszPre___0, aszSucc, 10);
  ap_hook_get_suexec_identity(& get_suexec_id_doer, (char const   * const  *)((void *)0),
                              (char const   * const  *)((void *)0), 10);
  return;
}
}
struct module_struct userdir_module  = 
     {20020903, 0, -1, "mod_userdir.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, (void (*)(process_rec *process ))((void *)0), (void *(*)(apr_pool_t *p ,
                                                                           char *dir ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), & create_userdir_config,
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), userdir_cmds,
    & register_hooks___15};
#pragma merger(0,"/tmp/cil-39iXqzlv.i","-g -pthread")
int apr_uri_parse(apr_pool_t *p , char const   *uri , apr_uri_t *uptr ) ;
char *ap_pregsub(apr_pool_t *p , char const   *input , char const   *source , size_t nmatch ,
                 regmatch_t *pmatch ) ;
static void *create_alias_config(apr_pool_t *p , server_rec *s ) 
{ alias_server_conf *a ;
  void *tmp ;
  alias_server_conf *tmp___0 ;

  {
  tmp = apr_palloc(p, sizeof(alias_server_conf ));
  tmp___0 = (alias_server_conf *)memset(tmp, 0, sizeof(alias_server_conf ));
  a = tmp___0;
  a->aliases = apr_array_make(p, 20, (int )sizeof(alias_entry ));
  a->redirects = apr_array_make(p, 20, (int )sizeof(alias_entry ));
  return ((void *)a);
}
}
static void *create_alias_dir_config(apr_pool_t *p , char *d ) 
{ alias_dir_conf *a ;
  void *tmp ;
  alias_dir_conf *tmp___0 ;

  {
  tmp = apr_palloc(p, sizeof(alias_dir_conf ));
  tmp___0 = (alias_dir_conf *)memset(tmp, 0, sizeof(alias_dir_conf ));
  a = tmp___0;
  a->redirects = apr_array_make(p, 2, (int )sizeof(alias_entry ));
  return ((void *)a);
}
}
static void *merge_alias_config(apr_pool_t *p , void *basev , void *overridesv ) 
{ alias_server_conf *a ;
  void *tmp ;
  alias_server_conf *tmp___0 ;
  alias_server_conf *base ;
  alias_server_conf *overrides ;

  {
  tmp = apr_palloc(p, sizeof(alias_server_conf ));
  tmp___0 = (alias_server_conf *)memset(tmp, 0, sizeof(alias_server_conf ));
  a = tmp___0;
  base = (alias_server_conf *)basev;
  overrides = (alias_server_conf *)overridesv;
  a->aliases = apr_array_append(p, (apr_array_header_t const   *)overrides->aliases,
                                (apr_array_header_t const   *)base->aliases);
  a->redirects = apr_array_append(p, (apr_array_header_t const   *)overrides->redirects,
                                  (apr_array_header_t const   *)base->redirects);
  return ((void *)a);
}
}
static void *merge_alias_dir_config(apr_pool_t *p , void *basev , void *overridesv ) 
{ alias_dir_conf *a ;
  void *tmp ;
  alias_dir_conf *tmp___0 ;
  alias_dir_conf *base ;
  alias_dir_conf *overrides ;

  {
  tmp = apr_palloc(p, sizeof(alias_dir_conf ));
  tmp___0 = (alias_dir_conf *)memset(tmp, 0, sizeof(alias_dir_conf ));
  a = tmp___0;
  base = (alias_dir_conf *)basev;
  overrides = (alias_dir_conf *)overridesv;
  a->redirects = apr_array_append(p, (apr_array_header_t const   *)overrides->redirects,
                                  (apr_array_header_t const   *)base->redirects);
  return ((void *)a);
}
}
static char const   *add_alias_internal(cmd_parms *cmd , void *dummy , char const   *f ,
                                        char const   *r , int use_regex ) 
{ server_rec *s ;
  alias_server_conf *conf ;
  alias_entry *new ;
  alias_entry *tmp ;

  {
  s = cmd->server;
  conf = (alias_server_conf *)(*((void **)s->module_config + alias_module.module_index));
  tmp = (alias_entry *)apr_array_push(conf->aliases);
  new = tmp;
  if (use_regex) {
    new->regexp = ap_pregcomp(cmd->pool, f, 0);
    if ((unsigned int )new->regexp == (unsigned int )((void *)0)) {
      return ("Regular expression could not be compiled.");
    }
    new->real = r;
  } else {
    new->real = r;
  }
  new->fake = f;
  new->handler = (char *)cmd->info;
  return ((char const   *)((void *)0));
}
}
static char const   *add_alias(cmd_parms *cmd , void *dummy , char const   *f , char const   *r ) 
{ char const   *tmp ;

  {
  tmp = add_alias_internal(cmd, dummy, f, r, 0);
  return (tmp);
}
}
static char const   *add_alias_regex(cmd_parms *cmd , void *dummy , char const   *f ,
                                     char const   *r ) 
{ char const   *tmp ;

  {
  tmp = add_alias_internal(cmd, dummy, f, r, 1);
  return (tmp);
}
}
static char const   *add_redirect_internal(cmd_parms *cmd , alias_dir_conf *dirconf ,
                                           char const   *arg1 , char const   *arg2 ,
                                           char const   *arg3 , int use_regex ) 
{ alias_entry *new ;
  server_rec *s ;
  alias_server_conf *serverconf ;
  int status ;
  regex_t *r ;
  char const   *f ;
  char const   *url ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  s = cmd->server;
  serverconf = (alias_server_conf *)(*((void **)s->module_config + alias_module.module_index));
  status = (int )((long )cmd->info);
  r = (regex_t *)((void *)0);
  f = arg2;
  url = arg3;
  tmp___3 = strcasecmp(arg1, "gone");
  if (tmp___3) {
    tmp___2 = strcasecmp(arg1, "permanent");
    if (tmp___2) {
      tmp___1 = strcasecmp(arg1, "temp");
      if (tmp___1) {
        tmp___0 = strcasecmp(arg1, "seeother");
        if (tmp___0) {
          tmp = __ctype_b_loc();
          if ((int const   )(*((*tmp) + (int )((unsigned char )(*arg1)))) & 2048) {
            status = atoi(arg1);
          } else {
            f = arg1;
            url = arg2;
          }
        } else {
          status = 303;
        }
      } else {
        status = 302;
      }
    } else {
      status = 301;
    }
  } else {
    status = 410;
  }
  if (use_regex) {
    r = ap_pregcomp(cmd->pool, f, 0);
    if ((unsigned int )r == (unsigned int )((void *)0)) {
      return ("Regular expression could not be compiled.");
    }
  }
  if (status >= 300) {
    if (status < 400) {
      if (! url) {
        return ("URL to redirect to is missing");
      }
      if (! use_regex) {
        tmp___4 = ap_is_url(url);
        if (tmp___4) {
          goto _L;
        } else {
          return ("Redirect to non-URL");
        }
      } else {
        _L: /* CIL Label */ ;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (url) {
      return ("Redirect URL not valid for this status");
    }
  }
  if (cmd->path) {
    new = (alias_entry *)apr_array_push(dirconf->redirects);
  } else {
    new = (alias_entry *)apr_array_push(serverconf->redirects);
  }
  new->fake = f;
  new->real = url;
  new->regexp = r;
  new->redir_status = status;
  return ((char const   *)((void *)0));
}
}
static char const   *add_redirect(cmd_parms *cmd , void *dirconf , char const   *arg1 ,
                                  char const   *arg2 , char const   *arg3 ) 
{ char const   *tmp ;

  {
  tmp = add_redirect_internal(cmd, (alias_dir_conf *)dirconf, arg1, arg2, arg3, 0);
  return (tmp);
}
}
static char const   *add_redirect2(cmd_parms *cmd , void *dirconf , char const   *arg1 ,
                                   char const   *arg2 ) 
{ char const   *tmp ;

  {
  tmp = add_redirect_internal(cmd, (alias_dir_conf *)dirconf, arg1, arg2, (char const   *)((void *)0),
                              0);
  return (tmp);
}
}
static char const   *add_redirect_regex(cmd_parms *cmd , void *dirconf , char const   *arg1 ,
                                        char const   *arg2 , char const   *arg3 ) 
{ char const   *tmp ;

  {
  tmp = add_redirect_internal(cmd, (alias_dir_conf *)dirconf, arg1, arg2, arg3, 1);
  return (tmp);
}
}
static command_rec const   alias_cmds[9]  = 
  {      {"Alias", {& add_alias}, (void *)0, 128, 2, "a fakename and a realname"}, 
        {"ScriptAlias", {& add_alias}, (void *)"cgi-script", 128, 2, "a fakename and a realname"}, 
        {"Redirect",
      {& add_redirect}, (void *)302, 4, 9, "an optional status, then document to be redirected and destination URL"}, 
        {"AliasMatch",
      {& add_alias_regex}, (void *)0, 128, 2, "a regular expression and a filename"}, 
        {"ScriptAliasMatch",
      {& add_alias_regex}, (void *)"cgi-script", 128, 2, "a regular expression and a filename"}, 
        {"RedirectMatch",
      {& add_redirect_regex}, (void *)302, 4, 9, "an optional status, then a regular expression and destination URL"}, 
        {"RedirectTemp",
      {& add_redirect2}, (void *)302, 4, 2, "a document to be redirected, then the destination URL"}, 
        {"RedirectPermanent",
      {& add_redirect2}, (void *)301, 4, 2, "a document to be redirected, then the destination URL"}, 
        {(char const   *)((void *)0),
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))0}, (void *)0,
      0, 0, (char const   *)0}};
static int alias_matches(char const   *uri , char const   *alias_fakename ) 
{ char const   *aliasp ;
  char const   *urip ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  aliasp = alias_fakename;
  urip = uri;
  while ((*aliasp)) {
    if ((int const   )(*aliasp) == 47) {
      if ((int const   )(*urip) != 47) {
        return (0);
      }
      while (1) {
        aliasp ++;
        if (! ((int const   )(*aliasp) == 47)) {
          break;
        }
      }
      while (1) {
        urip ++;
        if (! ((int const   )(*urip) == 47)) {
          break;
        }
      }
    } else {
      tmp = urip;
      urip ++;
      tmp___0 = aliasp;
      aliasp ++;
      if ((int const   )(*tmp) != (int const   )(*tmp___0)) {
        return (0);
      }
    }
  }
  if ((int const   )(*(aliasp + -1)) != 47) {
    if ((int const   )(*urip) != 0) {
      if ((int const   )(*urip) != 47) {
        return (0);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
  return (urip - uri);
}
}
static char *try_alias_list(request_rec *r , apr_array_header_t *aliases , int doesc ,
                            int *status ) 
{ alias_entry *entries ;
  regmatch_t regm[10] ;
  char *found ;
  int i ;
  alias_entry *p ;
  int l ;
  apr_uri_t uri ;
  int tmp ;
  char *escurl ;

  {
  entries = (alias_entry *)aliases->elts;
  found = (char *)((void *)0);
  i = 0;
  while (i < aliases->nelts) {
    p = entries + i;
    if (p->regexp) {
      tmp = ap_regexec(p->regexp, (char const   *)r->uri, (p->regexp)->re_nsub + 1U,
                       regm, 0);
      if (! tmp) {
        if (p->real) {
          found = ap_pregsub(r->pool, p->real, (char const   *)r->uri, (p->regexp)->re_nsub +
                                                                       1U, regm);
          if (found) {
            if (doesc) {
              apr_uri_parse(r->pool, (char const   *)found, & uri);
              found = apr_uri_unparse(r->pool, (apr_uri_t const   *)(& uri), 32U);
              found = ap_os_escape_path(r->pool, (char const   *)found, 1);
              if (uri.query) {
                found = apr_pstrcat(r->pool, found, "?", uri.query, (void *)0);
              }
              if (uri.fragment) {
                found = apr_pstrcat(r->pool, found, "#", uri.fragment, (void *)0);
              }
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ ;
          }
        } else {
          found = apr_pstrdup(r->pool, "");
        }
      }
    } else {
      l = alias_matches((char const   *)r->uri, p->fake);
      if (l > 0) {
        if (doesc) {
          escurl = ap_os_escape_path(r->pool, (char const   *)(r->uri + l), 1);
          found = apr_pstrcat(r->pool, p->real, escurl, (void *)0);
        } else {
          found = apr_pstrcat(r->pool, p->real, r->uri + l, (void *)0);
        }
      }
    }
    if (found) {
      if (p->handler) {
        r->handler = (char const   *)p->handler;
        apr_table_setn(r->notes, "alias-forced-type", r->handler);
      }
      if (! doesc) {
        found = ap_server_root_relative(r->pool, (char const   *)found);
      }
      if (found) {
        (*status) = p->redir_status;
      }
      return (found);
    }
    i ++;
  }
  return ((char *)((void *)0));
}
}
static int translate_alias_redir(request_rec *r ) 
{ ap_conf_vector_t *sconf ;
  alias_server_conf *serverconf ;
  char *ret ;
  int status ;

  {
  sconf = (r->server)->module_config;
  serverconf = (alias_server_conf *)(*((void **)sconf + alias_module.module_index));
  if ((int )(*(r->uri + 0)) != 47) {
    if ((int )(*(r->uri + 0)) != 0) {
      return (-1);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  ret = try_alias_list(r, serverconf->redirects, 1, & status);
  if ((unsigned int )ret != (unsigned int )((void *)0)) {
    if (status >= 300) {
      if (status < 400) {
        if (r->args) {
          ret = apr_pstrcat(r->pool, ret, "?", r->args, (void *)0);
        }
        apr_table_setn(r->headers_out, "Location", (char const   *)ret);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
    return (status);
  }
  ret = try_alias_list(r, serverconf->aliases, 0, & status);
  if ((unsigned int )ret != (unsigned int )((void *)0)) {
    r->filename = ret;
    return (0);
  }
  return (-1);
}
}
static int fixup_redir(request_rec *r ) 
{ void *dconf ;
  alias_dir_conf *dirconf ;
  char *ret ;
  int status ;
  char *orig_target ;
  int tmp ;

  {
  dconf = (void *)r->per_dir_config;
  dirconf = (alias_dir_conf *)(*((void **)dconf + alias_module.module_index));
  ret = try_alias_list(r, dirconf->redirects, 1, & status);
  if ((unsigned int )ret != (unsigned int )((void *)0)) {
    if (status >= 300) {
      if (status < 400) {
        if ((int )(*(ret + 0)) == 47) {
          orig_target = ret;
          ret = ap_construct_url(r->pool, (char const   *)ret, r);
          ap_log_rerror("mod_alias.c", 453, 7, 0, (request_rec const   *)r, "incomplete redirection target of \'%s\' for URI \'%s\' modified to \'%s\'",
                        orig_target, r->uri, ret);
        }
        tmp = ap_is_url((char const   *)ret);
        if (tmp) {
          apr_table_setn(r->headers_out, "Location", (char const   *)ret);
        } else {
          status = 500;
          ap_log_rerror("mod_alias.c", 460, 3, 0, (request_rec const   *)r, "cannot redirect \'%s\' to \'%s\'; target is not a valid absoluteURI or abs_path",
                        r->uri, ret);
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
    return (status);
  }
  return (-1);
}
}
static void register_hooks___16(apr_pool_t *p ) ;
static char const   * const  aszSucc___0[3]  = {      (char const   * const  )"mod_userdir.c",      (char const   * const  )"mod_vhost_alias.c",      (char const   * const  )((void *)0)};
static void register_hooks___16(apr_pool_t *p ) 
{ 

  {
  ap_hook_translate_name(& translate_alias_redir, (char const   * const  *)((void *)0),
                         aszSucc___0, 10);
  ap_hook_fixups(& fixup_redir, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                 10);
  return;
}
}
struct module_struct alias_module  = 
     {20020903, 0, -1, "mod_alias.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, (void (*)(process_rec *process ))((void *)0), & create_alias_dir_config,
    & merge_alias_dir_config, & create_alias_config, & merge_alias_config, alias_cmds,
    & register_hooks___16};
#pragma merger(0,"/tmp/cil-xLCPmbPw.i","-g -pthread")
apr_status_t apr_dso_load(apr_dso_handle_t **res_handle , char const   *path , apr_pool_t *pool ) ;
apr_status_t apr_dso_sym(apr_dso_handle_sym_t *ressym , apr_dso_handle_t *handle ,
                         char const   *symname ) ;
char const   *apr_dso_error(apr_dso_handle_t *dso , char *buffer , apr_size_t buflen ) ;
void ap_add_loaded_module(module *mod , apr_pool_t *p ) ;
void ap_remove_loaded_module(module *mod ) ;
void ap_single_module_configure(apr_pool_t *p , server_rec *s , module *m ) ;
static void *so_sconf_create(apr_pool_t *p , server_rec *s ) 
{ so_server_conf *soc ;
  void *tmp ;

  {
  tmp = apr_palloc(p, sizeof(so_server_conf ));
  soc = (so_server_conf *)memset(tmp, 0, sizeof(so_server_conf ));
  soc->loaded_modules = apr_array_make(p, 64, (int )sizeof(moduleinfo ));
  return ((void *)soc);
}
}
static apr_status_t unload_module(void *data ) 
{ moduleinfo *modi ;

  {
  modi = (moduleinfo *)data;
  if ((unsigned int )modi->modp == (unsigned int )((void *)0)) {
    return (0);
  }
  ap_remove_loaded_module(modi->modp);
  modi->modp = (module *)((void *)0);
  modi->name = (char const   *)((void *)0);
  return (0);
}
}
static char const   *load_module(cmd_parms *cmd , void *dummy , char const   *modname ,
                                 char const   *filename ) 
{ apr_dso_handle_t *modhandle ;
  apr_dso_handle_sym_t modsym ;
  module *modp ;
  char const   *szModuleFile ;
  char const   *tmp ;
  so_server_conf *sconf ;
  moduleinfo *modi ;
  moduleinfo *modie ;
  int i ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *preload_name ;
  apr_size_t preload_len ;
  apr_size_t thismod_len ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  char my_error[256] ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  apr_status_t tmp___14 ;
  char my_error___0[256] ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  apr_status_t tmp___17 ;
  char const   *tmp___18 ;

  {
  tmp = ap_server_root_relative(cmd->pool, filename);
  szModuleFile = tmp;
  (*((ap_directive_t **)dummy)) = (ap_directive_t *)((void *)0);
  if (! szModuleFile) {
    tmp___0 = apr_pstrcat(cmd->pool, "Invalid LoadModule path ", filename, (void *)0);
    return (tmp___0);
  }
  sconf = (so_server_conf *)(*((void **)(cmd->server)->module_config + so_module.module_index));
  modie = (moduleinfo *)(sconf->loaded_modules)->elts;
  i = 0;
  while (i < (sconf->loaded_modules)->nelts) {
    modi = modie + i;
    if ((unsigned int )modi->name != (unsigned int )((void *)0)) {
      tmp___1 = strcmp(modi->name, modname);
      if (tmp___1 == 0) {
        ap_log_perror("mod_so.c", 231, 4, 0, cmd->pool, "module %s is already loaded, skipping",
                      modname);
        return ((char const   *)((void *)0));
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
    i ++;
  }
  i = 0;
  while (ap_preloaded_modules[i]) {
    modp = ap_preloaded_modules[i];
    tmp___2 = memcmp((void const   *)modp->name, (void const   *)"mod_", 4U);
    if (tmp___2) {
      goto __Cont;
    }
    tmp___3 = strlen("mod_");
    preload_name = modp->name + tmp___3;
    tmp___4 = strlen(preload_name);
    preload_len = tmp___4 - 2U;
    tmp___5 = strlen(modname);
    tmp___6 = strlen("_module");
    if (tmp___5 <= tmp___6) {
      goto __Cont;
    }
    tmp___7 = strlen(modname);
    tmp___8 = strlen("_module");
    thismod_len = tmp___7 - tmp___8;
    tmp___9 = strcmp(modname + thismod_len, "_module");
    if (tmp___9) {
      goto __Cont;
    }
    if (thismod_len != preload_len) {
      goto __Cont;
    }
    tmp___11 = memcmp((void const   *)modname, (void const   *)preload_name, preload_len);
    if (! tmp___11) {
      tmp___10 = apr_pstrcat(cmd->pool, "module ", modname, " is built-in and can\'t be loaded",
                             (void *)0);
      return (tmp___10);
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  modi = (moduleinfo *)apr_array_push(sconf->loaded_modules);
  modi->name = modname;
  tmp___14 = apr_dso_load(& modhandle, szModuleFile, cmd->pool);
  if (tmp___14 != 0) {
    tmp___12 = apr_dso_error(modhandle, my_error, sizeof(my_error));
    tmp___13 = apr_pstrcat(cmd->pool, "Cannot load ", szModuleFile, " into server: ",
                           tmp___12, (void *)0);
    return (tmp___13);
  }
  ap_log_perror("mod_so.c", 290, 7, 0, cmd->pool, "loaded module %s", modname);
  tmp___17 = apr_dso_sym(& modsym, modhandle, modname);
  if (tmp___17 != 0) {
    tmp___15 = apr_dso_error(modhandle, my_error___0, sizeof(my_error___0));
    tmp___16 = apr_pstrcat(cmd->pool, "Can\'t locate API module structure `", modname,
                           "\' in file ", szModuleFile, ": ", tmp___15, (void *)0);
    return (tmp___16);
  }
  modp = (module *)modsym;
  modp->dynamic_load_handle = (void *)modhandle;
  modi->modp = modp;
  if (modp->magic != 1095774768UL) {
    tmp___18 = apr_pstrcat(cmd->pool, "API module structure `", modname, "\' in file ",
                           szModuleFile, " is garbled - perhaps this is not an Apache module DSO?",
                           (void *)0);
    return (tmp___18);
  }
  ap_add_loaded_module(modp, cmd->pool);
  apr_pool_cleanup_register(cmd->pool, (void const   *)modi, & unload_module, & apr_pool_cleanup_null);
  ap_single_module_configure(cmd->pool, cmd->server, modp);
  return ((char const   *)((void *)0));
}
}
static char const   *load_file(cmd_parms *cmd , void *dummy , char const   *filename ) 
{ apr_dso_handle_t *handle ;
  char const   *file ;
  char const   *tmp ;
  char my_error[256] ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  apr_status_t tmp___2 ;

  {
  file = ap_server_root_relative(cmd->pool, filename);
  if (! file) {
    tmp = apr_pstrcat(cmd->pool, "Invalid LoadFile path ", filename, (void *)0);
    return (tmp);
  }
  tmp___2 = apr_dso_load(& handle, file, cmd->pool);
  if (tmp___2 != 0) {
    tmp___0 = apr_dso_error(handle, my_error, sizeof(my_error));
    tmp___1 = apr_pstrcat(cmd->pool, "Cannot load ", filename, " into server: ", tmp___0,
                          (void *)0);
    return (tmp___1);
  }
  ap_log_error("mod_so.c", 366, 7, 0, (server_rec const   *)((void *)0), "loaded file %s",
               filename);
  return ((char const   *)((void *)0));
}
}
static command_rec const   so_cmds[3]  = {      {"LoadModule", {& load_module}, (void *)0, 384, 2, "a module name and the name of a shared object file to load it from"}, 
        {"LoadFile",
      {& load_file}, (void *)0, 384, 3, "shared object file or library to load into the server at runtime"}, 
        {(char const   *)((void *)0),
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))0}, (void *)0,
      0, 0, (char const   *)0}};
struct module_struct so_module  = 
     {20020903, 0, -1, "mod_so.c", (void *)0, (struct module_struct *)((void *)0), 1095774768UL,
    (void (*)(process_rec *process ))((void *)0), (void *(*)(apr_pool_t *p , char *dir ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), & so_sconf_create,
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), so_cmds,
    (void (*)(apr_pool_t *p ))((void *)0)};
#pragma merger(0,"/tmp/cil-0aJZXuKP.i","-g -pthread")
extern int kill(__pid_t __pid , int __sig ) ;
extern int killpg(__pid_t __pgrp , int __sig ) ;
extern int sigemptyset(sigset_t *__set ) ;
extern int sigaddset(sigset_t *__set , int __signo ) ;
extern int sigaction(int __sig , struct sigaction  const  * __restrict  __act , struct sigaction * __restrict  __oact ) ;
apr_status_t apr_allocator_create(apr_allocator_t **allocator ) ;
void apr_allocator_owner_set(apr_allocator_t *allocator , apr_pool_t *pool ) ;
void apr_allocator_max_free_set(apr_allocator_t *allocator , apr_size_t size ) ;
void apr_pool_tag(apr_pool_t *pool , char const   *tag ) ;
apr_status_t apr_proc_detach(int daemonize ) ;
apr_status_t apr_proc_other_child_read(apr_proc_t *pid , int status ) ;
apr_status_t apr_proc_mutex_create(apr_proc_mutex_t **mutex , char const   *fname ,
                                   apr_lockmech_e mech , apr_pool_t *pool ) ;
apr_status_t apr_proc_mutex_child_init(apr_proc_mutex_t **mutex , char const   *fname ,
                                       apr_pool_t *pool ) ;
apr_status_t apr_proc_mutex_lock(apr_proc_mutex_t *mutex ) ;
apr_status_t apr_proc_mutex_unlock(apr_proc_mutex_t *mutex ) ;
char const   *apr_proc_mutex_name(apr_proc_mutex_t *mutex ) ;
char const   *apr_proc_mutex_defname(void) ;
apr_sigfunc_t *apr_signal(int signo , apr_sigfunc_t *func ) ;
extern unsigned int sleep(unsigned int __seconds ) ;
extern int chdir(char const   *__path ) ;
extern __pid_t getpgrp(void) ;
extern __pid_t fork(void) ;
extern int unlink(char const   *__name ) ;
apr_bucket_alloc_t *apr_bucket_alloc_create(apr_pool_t *p ) ;
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
char const   *ap_server_root ;
void ap_log_pid(apr_pool_t *p , char const   *filename ) ;
void ap_run_child_init(apr_pool_t *pchild___0 , server_rec *s ) ;
int ap_exists_config_define(char const   *name ) ;
void ap_process_connection(conn_rec *c , void *csd ) ;
void ap_lingering_close(conn_rec *c ) ;
conn_rec *ap_run_create_connection(apr_pool_t *p , server_rec *server , apr_socket_t *csd ,
                                   long conn_id , void *sbh , apr_bucket_alloc_t *alloc ) ;
apr_status_t ap_reopen_scoreboard(apr_pool_t *p , apr_shm_t **shm , int detached ) ;
void ap_create_sb_handle(ap_sb_handle_t **new_sbh , apr_pool_t *p , int child_num ,
                         int thread_num ) ;
int find_child_by_pid(apr_proc_t *pid ) ;
int ap_update_child_status_from_indexes(int child_num , int thread_num , int status ,
                                        request_rec *r ) ;
int ap_run_pre_mpm(apr_pool_t *p , ap_scoreboard_e sb_type ) ;
int ap_mpm_run(apr_pool_t *_pconf , apr_pool_t *plog , server_rec *s ) ;
ap_listen_rec *ap_listeners ;
void ap_listen_pre_config(void) ;
int ap_setup_listeners(server_rec *s ) ;
char const   *ap_set_listenbacklog(cmd_parms *cmd , void *dummy , char const   *arg ) ;
char const   *ap_set_listener(cmd_parms *cmd , void *dummy , char const   *ips ) ;
char const   *ap_set_send_buffer_size(cmd_parms *cmd , void *dummy , char const   *arg ) ;
int unixd_setup_child(void) ;
void unixd_pre_config(apr_pool_t *ptemp ) ;
char const   *unixd_set_user(cmd_parms *cmd , void *dummy , char const   *arg ) ;
char const   *unixd_set_group(cmd_parms *cmd , void *dummy , char const   *arg ) ;
apr_status_t unixd_set_proc_mutex_perms(apr_proc_mutex_t *pmutex ) ;
int ap_threads_per_child ;
int ap_max_daemons_limit ;
server_rec *ap_server_conf  ;
void ap_reclaim_child_processes(int terminate ) ;
void ap_wait_or_timeout(apr_exit_why_e *status , int *exitcode , apr_proc_t *ret ,
                        apr_pool_t *p ) ;
int ap_process_child_status(apr_proc_t *pid , apr_exit_why_e why , int status ) ;
apr_status_t ap_mpm_pod_open(apr_pool_t *p , ap_pod_t **pod___0 ) ;
apr_status_t ap_mpm_pod_check(ap_pod_t *pod___0 ) ;
apr_status_t ap_mpm_pod_close(ap_pod_t *pod___0 ) ;
apr_status_t ap_mpm_pod_signal(ap_pod_t *pod___0 ) ;
void ap_mpm_pod_killpg(ap_pod_t *pod___0 , int num ) ;
int ap_max_requests_per_child ;
char const   *ap_pid_fname ;
char const   *ap_lock_fname ;
int ap_accept_lock_mech ;
char ap_coredump_dir[8192] ;
void ap_mpm_rewrite_args(process_rec *process ) ;
unsigned int ap_max_mem_free ;
apr_status_t apr_poll(apr_pollfd_t *aprset , apr_int32_t num , apr_int32_t *nsds ,
                      apr_interval_time_t timeout ) ;
int ap_threads_per_child  =    0;
static apr_proc_mutex_t *accept_mutex  ;
static int ap_daemons_to_start  =    0;
static int ap_daemons_min_free  =    0;
static int ap_daemons_max_free  =    0;
static int ap_daemons_limit  =    0;
static int server_limit___0  =    256;
static int first_server_limit  ;
static int changed_limit_at_restart  ;
static ap_pod_t *pod  ;
int ap_max_daemons_limit  =    -1;
static int one_process  =    0;
static apr_pool_t *pconf  ;
static apr_pool_t *pchild  ;
static pid_t ap_my_pid  ;
static pid_t parent_pid  ;
static int my_child_num  ;
int volatile   ap_my_generation  =    (ap_generation_t volatile   )0;
static int die_now  =    0;
static  __attribute__((__noreturn__)) void clean_child_exit(int code ) ;
static  __attribute__((__noreturn__)) void clean_child_exit(int code ) ;
static void clean_child_exit(int code ) 
{ 

  {
  if (pchild) {
    apr_pool_destroy(pchild);
  }
  ap_mpm_pod_close(pod);
  exit(code);
}
}
static void accept_mutex_on(void) 
{ apr_status_t rv ;
  apr_status_t tmp ;
  char const   *msg ;

  {
  tmp = apr_proc_mutex_lock(accept_mutex);
  rv = tmp;
  if (rv != 0) {
    msg = "couldn\'t grab the accept mutex";
    if (ap_my_generation != (int volatile   )(ap_scoreboard_image->global)->running_generation) {
      ap_log_error("prefork.c", 248, 7, rv, (server_rec const   *)((void *)0), msg);
      clean_child_exit(0);
    } else {
      ap_log_error("prefork.c", 252, 0, rv, (server_rec const   *)((void *)0), msg);
      exit(15);
    }
  }
  return;
}
}
static void accept_mutex_off(void) 
{ apr_status_t rv ;
  apr_status_t tmp ;
  char const   *msg ;

  {
  tmp = apr_proc_mutex_unlock(accept_mutex);
  rv = tmp;
  if (rv != 0) {
    msg = "couldn\'t release the accept mutex";
    if (ap_my_generation != (int volatile   )(ap_scoreboard_image->global)->running_generation) {
      ap_log_error("prefork.c", 266, 7, rv, (server_rec const   *)((void *)0), msg);
    } else {
      ap_log_error("prefork.c", 273, 0, rv, (server_rec const   *)((void *)0), msg);
      exit(15);
    }
  }
  return;
}
}
apr_status_t ap_mpm_query(int query_code , int *result ) 
{ 

  {
  switch (query_code) {
  case 1: 
  (*result) = ap_daemons_limit;
  return (0);
  case 2: 
  (*result) = 0;
  return (0);
  case 3: 
  (*result) = 2;
  return (0);
  case 4: 
  (*result) = server_limit___0;
  return (0);
  case 5: 
  (*result) = 1;
  return (0);
  case 6: 
  (*result) = 0;
  return (0);
  case 7: 
  (*result) = ap_daemons_min_free;
  return (0);
  case 8: 
  (*result) = 0;
  return (0);
  case 9: 
  (*result) = ap_daemons_max_free;
  return (0);
  case 10: 
  (*result) = 0;
  return (0);
  case 11: 
  (*result) = ap_max_requests_per_child;
  return (0);
  case 12: 
  (*result) = server_limit___0;
  return (0);
  }
  return (70023);
}
}
static void sig_coredump(int sig ) 
{ __pid_t tmp ;

  {
  chdir((char const   *)(ap_coredump_dir));
  apr_signal(sig, (void (*)(int  ))0);
  if (ap_my_pid == parent_pid) {
    ap_log_error("prefork.c", 362, 5, 0, (server_rec const   *)ap_server_conf, "seg fault or similar nasty error detected in the parent process");
  }
  tmp = getpid();
  kill(tmp, sig);
  return;
}
}
static void just_die(int sig ) 
{ 

  {
  clean_child_exit(0);
}
}
static int volatile   shutdown_pending  ;
static int volatile   restart_pending  ;
static int volatile   is_graceful  ;
static void sig_term(int sig ) 
{ 

  {
  if (shutdown_pending == 1) {
    return;
  }
  shutdown_pending = (int volatile   )1;
  return;
}
}
static void restart(int sig ) 
{ 

  {
  if (restart_pending == 1) {
    return;
  }
  restart_pending = (int volatile   )1;
  is_graceful = (int volatile   )(sig == 10);
  return;
}
}
static void set_signals(void) 
{ struct sigaction sa ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;

  {
  sigemptyset(& sa.sa_mask);
  sa.sa_flags = 0;
  if (! one_process) {
    sa.__sigaction_handler.sa_handler = & sig_coredump;
    sa.sa_flags = (-0x7FFFFFFF-1);
    tmp___0 = sigaction(11, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
    if (tmp___0 < 0) {
      tmp = __errno_location();
      ap_log_error("prefork.c", 432, 4, (*tmp), (server_rec const   *)ap_server_conf,
                   "sigaction(SIGSEGV)");
    }
    tmp___2 = sigaction(7, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
    if (tmp___2 < 0) {
      tmp___1 = __errno_location();
      ap_log_error("prefork.c", 435, 4, (*tmp___1), (server_rec const   *)ap_server_conf,
                   "sigaction(SIGBUS)");
    }
    tmp___4 = sigaction(6, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
    if (tmp___4 < 0) {
      tmp___3 = __errno_location();
      ap_log_error("prefork.c", 443, 4, (*tmp___3), (server_rec const   *)ap_server_conf,
                   "sigaction(SIGABRT)");
    }
    tmp___6 = sigaction(4, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
    if (tmp___6 < 0) {
      tmp___5 = __errno_location();
      ap_log_error("prefork.c", 447, 4, (*tmp___5), (server_rec const   *)ap_server_conf,
                   "sigaction(SIGILL)");
    }
    sa.sa_flags = 0;
  }
  sa.__sigaction_handler.sa_handler = & sig_term;
  tmp___8 = sigaction(15, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  if (tmp___8 < 0) {
    tmp___7 = __errno_location();
    ap_log_error("prefork.c", 453, 4, (*tmp___7), (server_rec const   *)ap_server_conf,
                 "sigaction(SIGTERM)");
  }
  tmp___10 = sigaction(2, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  if (tmp___10 < 0) {
    tmp___9 = __errno_location();
    ap_log_error("prefork.c", 456, 4, (*tmp___9), (server_rec const   *)ap_server_conf,
                 "sigaction(SIGINT)");
  }
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))0;
  tmp___12 = sigaction(24, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  if (tmp___12 < 0) {
    tmp___11 = __errno_location();
    ap_log_error("prefork.c", 461, 4, (*tmp___11), (server_rec const   *)ap_server_conf,
                 "sigaction(SIGXCPU)");
  }
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))0;
  tmp___14 = sigaction(25, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  if (tmp___14 < 0) {
    tmp___13 = __errno_location();
    ap_log_error("prefork.c", 466, 4, (*tmp___13), (server_rec const   *)ap_server_conf,
                 "sigaction(SIGXFSZ)");
  }
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
  tmp___16 = sigaction(13, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  if (tmp___16 < 0) {
    tmp___15 = __errno_location();
    ap_log_error("prefork.c", 471, 4, (*tmp___15), (server_rec const   *)ap_server_conf,
                 "sigaction(SIGPIPE)");
  }
  sigaddset(& sa.sa_mask, 1);
  sigaddset(& sa.sa_mask, 10);
  sa.__sigaction_handler.sa_handler = & restart;
  tmp___18 = sigaction(1, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  if (tmp___18 < 0) {
    tmp___17 = __errno_location();
    ap_log_error("prefork.c", 480, 4, (*tmp___17), (server_rec const   *)ap_server_conf,
                 "sigaction(SIGHUP)");
  }
  tmp___20 = sigaction(10, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  if (tmp___20 < 0) {
    tmp___19 = __errno_location();
    ap_log_error("prefork.c", 482, 4, (*tmp___19), (server_rec const   *)ap_server_conf,
                 "sigaction(SIGUSR1)");
  }
  return;
}
}
static int requests_this_child  ;
static int num_listensocks  =    0;
static ap_listen_rec *listensocks  ;
int ap_graceful_stop_signalled(void) 
{ 

  {
  return (0);
}
}
static void child_main(int child_num_arg ) 
{ apr_pool_t *ptrans ;
  apr_allocator_t *allocator ;
  conn_rec *current_conn ;
  apr_status_t status ;
  int i ;
  ap_listen_rec *lr ;
  int curr_pollfd ;
  int last_pollfd ;
  apr_pollfd_t *pollset ;
  int offset ;
  void *csd ;
  ap_sb_handle_t *sbh ;
  apr_status_t rv ;
  apr_bucket_alloc_t *bucket_alloc ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  apr_status_t ret ;
  apr_int32_t n ;
  apr_status_t tmp___2 ;

  {
  status = 70022;
  last_pollfd = 0;
  my_child_num = child_num_arg;
  ap_my_pid = getpid();
  csd = (void *)0;
  requests_this_child = 0;
  apr_allocator_create(& allocator);
  apr_allocator_max_free_set(allocator, ap_max_mem_free);
  apr_pool_create_ex(& pchild, pconf, (int (*)(int retcode ))((void *)0), allocator);
  apr_allocator_owner_set(allocator, pchild);
  apr_pool_create_ex(& ptrans, pchild, (int (*)(int retcode ))((void *)0), (apr_allocator_t *)((void *)0));
  apr_pool_tag(ptrans, "transaction");
  ap_reopen_scoreboard(pchild, (apr_shm_t **)((void *)0), 0);
  rv = apr_proc_mutex_child_init(& accept_mutex, ap_lock_fname, pchild);
  if (rv != 0) {
    ap_log_error("prefork.c", 573, 0, rv, (server_rec const   *)ap_server_conf, "Couldn\'t initialize cross-process lock in child");
    clean_child_exit(15);
  }
  tmp = unixd_setup_child();
  if (tmp) {
    clean_child_exit(15);
  }
  ap_run_child_init(pchild, ap_server_conf);
  ap_create_sb_handle(& sbh, pchild, my_child_num, 0);
  ap_update_child_status(sbh, 2, (request_rec *)((void *)0));
  tmp___0 = apr_palloc(pchild, sizeof((*listensocks)) * (unsigned int )num_listensocks);
  listensocks = (ap_listen_rec *)memset(tmp___0, 0, sizeof((*listensocks)) * (unsigned int )num_listensocks);
  lr = ap_listeners;
  i = 0;
  while (i < num_listensocks) {
    (listensocks + i)->accept_func = lr->accept_func;
    (listensocks + i)->sd = lr->sd;
    lr = lr->next;
    i ++;
  }
  pollset = (apr_pollfd_t *)apr_palloc(pchild, sizeof((*pollset)) * (unsigned int )num_listensocks);
  (pollset + 0)->p = pchild;
  i = 0;
  while (i < num_listensocks) {
    (pollset + i)->desc.s = (listensocks + i)->sd;
    (pollset + i)->desc_type = 1;
    (pollset + i)->reqevents = (short)1;
    i ++;
  }
  bucket_alloc = apr_bucket_alloc_create(pchild);
  while (! die_now) {
    current_conn = (conn_rec *)((void *)0);
    apr_pool_clear(ptrans);
    if (ap_max_requests_per_child > 0) {
      tmp___1 = requests_this_child;
      requests_this_child ++;
      if (tmp___1 >= ap_max_requests_per_child) {
        clean_child_exit(0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
    ap_update_child_status(sbh, 2, (request_rec *)((void *)0));
    while (1) {
      if (ap_listeners->next) {
        accept_mutex_on();
      }
      break;
    }
    if (num_listensocks == 1) {
      offset = 0;
    } else {
      while (1) {
        ret = apr_poll(pollset, num_listensocks, & n, -1LL);
        if (ret != 0) {
          if (ret == 4) {
            goto __Cont;
          }
          ap_log_error("prefork.c", 649, 3, ret, (server_rec const   *)ap_server_conf,
                       "apr_poll: (listen)");
          clean_child_exit(1);
        }
        curr_pollfd = last_pollfd;
        while (1) {
          curr_pollfd ++;
          if (curr_pollfd >= num_listensocks) {
            curr_pollfd = 0;
          }
          if ((int )(pollset + curr_pollfd)->rtnevents & 1) {
            last_pollfd = curr_pollfd;
            offset = curr_pollfd;
            goto got_fd;
          }
          if (! (curr_pollfd != last_pollfd)) {
            break;
          }
        }
        goto __Cont;
        __Cont: /* CIL Label */ ;
      }
    }
    got_fd: 
    while (1) {
      status = ((*((listensocks + offset)->accept_func)))(& csd, listensocks + offset,
                                                          ptrans);
      if (status == 0) {
        break;
      }
      if (status == 20014) {
        clean_child_exit(1);
      }
    }
    while (1) {
      if (ap_listeners->next) {
        accept_mutex_off();
      }
      break;
    }
    current_conn = ap_run_create_connection(ptrans, ap_server_conf, (apr_socket_t *)csd,
                                            (long )my_child_num, (void *)sbh, bucket_alloc);
    if (current_conn) {
      ap_process_connection(current_conn, csd);
      ap_lingering_close(current_conn);
    }
    tmp___2 = ap_mpm_pod_check(pod);
    if (tmp___2 == 0) {
      die_now = 1;
    } else {
      if (ap_my_generation != (int volatile   )(ap_scoreboard_image->global)->running_generation) {
        die_now = 1;
      }
    }
  }
  clean_child_exit(0);
}
}
static int make_child(server_rec *s , int slot ) 
{ int pid ;
  int *tmp ;

  {
  if (slot + 1 > ap_max_daemons_limit) {
    ap_max_daemons_limit = slot + 1;
  }
  if (one_process) {
    apr_signal(1, & just_die);
    apr_signal(2, & just_die);
    apr_signal(3, (void (*)(int  ))0);
    apr_signal(15, & just_die);
    child_main(slot);
  }
  ap_update_child_status_from_indexes(slot, 0, 1, (request_rec *)((void *)0));
  pid = fork();
  if (pid == -1) {
    tmp = __errno_location();
    ap_log_error("prefork.c", 751, 3, (*tmp), (server_rec const   *)s, "fork: Unable to fork new process");
    ap_update_child_status_from_indexes(slot, 0, 0, (request_rec *)((void *)0));
    sleep(10U);
    return (-1);
  }
  if (! pid) {
    apr_signal(1, & just_die);
    apr_signal(15, & just_die);
    apr_signal(10, (void (*)(int  ))1);
    child_main(slot);
  }
  (ap_scoreboard_image->parent + slot)->pid = pid;
  return (0);
}
}
static void startup_children(int number_to_start ) 
{ int i ;
  int tmp ;

  {
  i = 0;
  while (1) {
    if (number_to_start) {
      if (! (i < ap_daemons_limit)) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      break;
    }
    if ((int )((*(ap_scoreboard_image->servers + i)) + 0)->status != 0) {
      goto __Cont;
    }
    tmp = make_child(ap_server_conf, i);
    if (tmp < 0) {
      break;
    }
    number_to_start --;
    __Cont: /* CIL Label */ 
    i ++;
  }
  return;
}
}
static int idle_spawn_rate  =    1;
static int hold_off_on_exponential_spawning  ;
static void perform_idle_server_maintenance(apr_pool_t *p ) ;
static int reported  =    0;
static void perform_idle_server_maintenance(apr_pool_t *p ) 
{ int i ;
  int to_kill ;
  int idle_count ;
  worker_score *ws ;
  int free_length ;
  int free_slots[32] ;
  int last_non_dead ;
  int total_non_dead ;
  int status ;

  {
  free_length = 0;
  to_kill = -1;
  idle_count = 0;
  last_non_dead = -1;
  total_non_dead = 0;
  i = 0;
  while (i < ap_daemons_limit) {
    if (i >= ap_max_daemons_limit) {
      if (free_length == idle_spawn_rate) {
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
    ws = (*(ap_scoreboard_image->servers + i)) + 0;
    status = (int )ws->status;
    if (status == 0) {
      if (free_length < idle_spawn_rate) {
        free_slots[free_length] = i;
        free_length ++;
      }
    } else {
      if (status <= 2) {
        idle_count ++;
        to_kill = i;
      }
      total_non_dead ++;
      last_non_dead = i;
    }
    i ++;
  }
  ap_max_daemons_limit = last_non_dead + 1;
  if (idle_count > ap_daemons_max_free) {
    ap_mpm_pod_signal(pod);
    idle_spawn_rate = 1;
  } else {
    if (idle_count < ap_daemons_min_free) {
      if (free_length == 0) {
        if (! reported) {
          ap_log_error("prefork.c", 899, 3, 0, (server_rec const   *)ap_server_conf,
                       "server reached MaxClients setting, consider raising the MaxClients setting");
          reported = 1;
        }
        idle_spawn_rate = 1;
      } else {
        if (idle_spawn_rate >= 8) {
          ap_log_error("prefork.c", 908, 6, 0, (server_rec const   *)ap_server_conf,
                       "server seems busy, (you may need to increase StartServers, or Min/MaxSpareServers), spawning %d children, there are %d idle, and %d total children",
                       idle_spawn_rate, idle_count, total_non_dead);
        }
        i = 0;
        while (i < free_length) {
          make_child(ap_server_conf, free_slots[i]);
          i ++;
        }
        if (hold_off_on_exponential_spawning) {
          hold_off_on_exponential_spawning --;
        } else {
          if (idle_spawn_rate < 32) {
            idle_spawn_rate *= 2;
          }
        }
      }
    } else {
      idle_spawn_rate = 1;
    }
  }
  return;
}
}
int ap_mpm_run(apr_pool_t *_pconf , apr_pool_t *plog , server_rec *s ) 
{ int index___0 ;
  int remaining_children_to_start ;
  apr_status_t rv ;
  char *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int child_slot ;
  apr_exit_why_e exitwhy ;
  int status ;
  int processed_status ;
  apr_proc_t pid ;
  apr_status_t tmp___5 ;
  int *tmp___6 ;
  __pid_t tmp___7 ;
  int tmp___8 ;
  char const   *pidfile ;
  __pid_t tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  __pid_t tmp___12 ;
  int tmp___13 ;

  {
  ap_log_pid(pconf, ap_pid_fname);
  first_server_limit = server_limit___0;
  if (changed_limit_at_restart) {
    ap_log_error("prefork.c", 958, 4, 0, (server_rec const   *)s, "WARNING: Attempt to change ServerLimit ignored during restart");
    changed_limit_at_restart = 0;
  }
  tmp = ap_server_root_relative(_pconf, ap_lock_fname);
  ap_lock_fname = apr_psprintf(_pconf, "%s.%d", tmp, ap_my_pid);
  rv = apr_proc_mutex_create(& accept_mutex, ap_lock_fname, ap_accept_lock_mech, _pconf);
  if (rv != 0) {
    ap_log_error("prefork.c", 972, 0, rv, (server_rec const   *)s, "Couldn\'t create accept lock");
    return (1);
  }
  if ((int )ap_accept_lock_mech == 2) {
    rv = unixd_set_proc_mutex_perms(accept_mutex);
    if (rv != 0) {
      ap_log_error("prefork.c", 985, 0, rv, (server_rec const   *)s, "Couldn\'t set permissions on cross-process lock; check User and Group directives");
      return (1);
    }
  }
  if (! is_graceful) {
    tmp___0 = ap_run_pre_mpm((s->process)->pool, 2);
    if (tmp___0 != 0) {
      return (1);
    }
    (ap_scoreboard_image->global)->running_generation = (int )ap_my_generation;
  }
  set_signals();
  if (one_process) {

  }
  if (ap_daemons_max_free < ap_daemons_min_free + 1) {
    ap_daemons_max_free = ap_daemons_min_free + 1;
  }
  remaining_children_to_start = ap_daemons_to_start;
  if (remaining_children_to_start > ap_daemons_limit) {
    remaining_children_to_start = ap_daemons_limit;
  }
  if (! is_graceful) {
    startup_children(remaining_children_to_start);
    remaining_children_to_start = 0;
  } else {
    hold_off_on_exponential_spawning = 10;
  }
  tmp___1 = ap_get_server_version();
  ap_log_error("prefork.c", 1033, 5, 0, (server_rec const   *)ap_server_conf, "%s configured -- resuming normal operations",
               tmp___1);
  tmp___2 = ap_get_server_built();
  ap_log_error("prefork.c", 1036, 6, 0, (server_rec const   *)ap_server_conf, "Server built: %s",
               tmp___2);
  tmp___3 = apr_proc_mutex_defname();
  tmp___4 = apr_proc_mutex_name(accept_mutex);
  ap_log_error("prefork.c", 1039, 7, 0, (server_rec const   *)ap_server_conf, "AcceptMutex: %s (default: %s)",
               tmp___4, tmp___3);
  shutdown_pending = (int volatile   )0;
  restart_pending = shutdown_pending;
  while (1) {
    if (! restart_pending) {
      if (! (! shutdown_pending)) {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      break;
    }
    ap_wait_or_timeout(& exitwhy, & status, & pid, pconf);
    if (pid.pid != -1) {
      processed_status = ap_process_child_status(& pid, exitwhy, status);
      if (processed_status == 15) {
        return (1);
      }
      child_slot = find_child_by_pid(& pid);
      if (child_slot >= 0) {
        ap_update_child_status_from_indexes(child_slot, 0, 0, (request_rec *)((void *)0));
        if (processed_status == 7) {
          idle_spawn_rate = 1;
        } else {
          if (remaining_children_to_start) {
            if (child_slot < ap_daemons_limit) {
              make_child(ap_server_conf, child_slot);
              remaining_children_to_start --;
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ ;
          }
        }
      } else {
        tmp___5 = apr_proc_other_child_read(& pid, status);
        if (! (tmp___5 == 0)) {
          if (is_graceful) {
            ap_log_error("prefork.c", 1095, 4, 0, (server_rec const   *)ap_server_conf,
                         "long lost child came home! (pid %ld)", (long )pid.pid);
          }
        }
      }
      continue;
    } else {
      if (remaining_children_to_start) {
        startup_children(remaining_children_to_start);
        remaining_children_to_start = 0;
        continue;
      }
    }
    perform_idle_server_maintenance(pconf);
  }
  if (shutdown_pending) {
    tmp___7 = getpgrp();
    tmp___8 = killpg(tmp___7, 15);
    if (tmp___8 < 0) {
      tmp___6 = __errno_location();
      ap_log_error("prefork.c", 1133, 4, (*tmp___6), (server_rec const   *)ap_server_conf,
                   "killpg SIGTERM");
    }
    ap_reclaim_child_processes(1);
    pidfile = (char const   *)((void *)0);
    pidfile = ap_server_root_relative(pconf, ap_pid_fname);
    if ((unsigned int )pidfile != (unsigned int )((void *)0)) {
      tmp___10 = unlink(pidfile);
      if (tmp___10 == 0) {
        tmp___9 = getpid();
        ap_log_error("prefork.c", 1142, 6, 0, (server_rec const   *)ap_server_conf,
                     "removed PID file %s (pid=%ld)", pidfile, (long )tmp___9);
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ ;
    }
    ap_log_error("prefork.c", 1148, 5, 0, (server_rec const   *)ap_server_conf, "caught SIGTERM, shutting down");
    return (1);
  }
  apr_signal(1, (void (*)(int  ))1);
  if (one_process) {
    return (1);
  }
  ap_my_generation = ap_my_generation + 1;
  (ap_scoreboard_image->global)->running_generation = (int )ap_my_generation;
  if (is_graceful) {
    ap_log_error("prefork.c", 1168, 5, 0, (server_rec const   *)ap_server_conf, "Graceful restart requested, doing restart");
    ap_mpm_pod_killpg(pod, ap_daemons_limit);
    index___0 = 0;
    while (index___0 < ap_daemons_limit) {
      if ((int )((*(ap_scoreboard_image->servers + index___0)) + 0)->status != 0) {
        ((*(ap_scoreboard_image->servers + index___0)) + 0)->status = (unsigned char)9;
      }
      index___0 ++;
    }
  } else {
    tmp___12 = getpgrp();
    tmp___13 = killpg(tmp___12, 1);
    if (tmp___13 < 0) {
      tmp___11 = __errno_location();
      ap_log_error("prefork.c", 1188, 4, (*tmp___11), (server_rec const   *)ap_server_conf,
                   "killpg SIGHUP");
    }
    ap_reclaim_child_processes(0);
    ap_log_error("prefork.c", 1191, 5, 0, (server_rec const   *)ap_server_conf, "SIGHUP received.  Attempting to restart");
  }
  return (0);
}
}
static int prefork_open_logs(apr_pool_t *p , apr_pool_t *plog , apr_pool_t *ptemp ,
                             server_rec *s ) 
{ apr_status_t rv ;

  {
  pconf = p;
  ap_server_conf = s;
  num_listensocks = ap_setup_listeners(ap_server_conf);
  if (num_listensocks < 1) {
    ap_log_error("prefork.c", 1209, 33, 0, (server_rec const   *)((void *)0), "no listening sockets available, shutting down");
    return (-2);
  }
  rv = ap_mpm_pod_open(pconf, & pod);
  if (rv) {
    ap_log_error("prefork.c", 1215, 34, rv, (server_rec const   *)((void *)0), "Could not open pipe-of-death.");
    return (-2);
  }
  return (0);
}
}
static int prefork_pre_config(apr_pool_t *p , apr_pool_t *plog , apr_pool_t *ptemp ) ;
static int restart_num  =    0;
static int prefork_pre_config(apr_pool_t *p , apr_pool_t *plog , apr_pool_t *ptemp ) 
{ int no_detach ;
  int debug ;
  int foreground ;
  apr_status_t rv ;
  int tmp ;
  int tmp___0 ;

  {
  debug = ap_exists_config_define("DEBUG");
  if (debug) {
    one_process = 1;
    foreground = one_process;
    no_detach = 0;
  } else {
    no_detach = ap_exists_config_define("NO_DETACH");
    one_process = ap_exists_config_define("ONE_PROCESS");
    foreground = ap_exists_config_define("FOREGROUND");
  }
  tmp___0 = restart_num;
  restart_num ++;
  if (tmp___0 == 1) {
    is_graceful = (int volatile   )0;
    if (! one_process) {
      if (! foreground) {
        if (no_detach) {
          tmp = 0;
        } else {
          tmp = 1;
        }
        rv = apr_proc_detach(tmp);
        if (rv != 0) {
          ap_log_error("prefork.c", 1249, 2, rv, (server_rec const   *)((void *)0),
                       "apr_proc_detach failed");
          return (500);
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
    ap_my_pid = getpid();
    parent_pid = ap_my_pid;
  }
  unixd_pre_config(ptemp);
  ap_listen_pre_config();
  ap_daemons_to_start = 5;
  ap_daemons_min_free = 5;
  ap_daemons_max_free = 10;
  ap_daemons_limit = server_limit___0;
  ap_pid_fname = "logs/httpd.pid";
  ap_lock_fname = "logs/accept.lock";
  ap_max_requests_per_child = 10000;
  ap_extended_status = 0;
  apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
  return (0);
}
}
static void prefork_hooks(apr_pool_t *p ) ;
static char const   * const  aszSucc___1[2]  = {      (char const   * const  )"core.c",      (char const   * const  )((void *)0)};
static void prefork_hooks(apr_pool_t *p ) 
{ 

  {
  ap_hook_open_logs(& prefork_open_logs, (char const   * const  *)((void *)0), aszSucc___1,
                    10);
  ap_hook_pre_config(& prefork_pre_config, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                     10);
  return;
}
}
static char const   *set_daemons_to_start(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  ap_daemons_to_start = atoi(arg);
  return ((char const   *)((void *)0));
}
}
static char const   *set_min_free_servers(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  ap_daemons_min_free = atoi(arg);
  if (ap_daemons_min_free <= 0) {
    ap_log_error("prefork.c", 1310, 32, 0, (server_rec const   *)((void *)0), "WARNING: detected MinSpareServers set to non-positive.");
    ap_log_error("prefork.c", 1312, 32, 0, (server_rec const   *)((void *)0), "Resetting to 1 to avoid almost certain Apache failure.");
    ap_log_error("prefork.c", 1314, 32, 0, (server_rec const   *)((void *)0), "Please read the documentation.");
    ap_daemons_min_free = 1;
  }
  return ((char const   *)((void *)0));
}
}
static char const   *set_max_free_servers(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  ap_daemons_max_free = atoi(arg);
  return ((char const   *)((void *)0));
}
}
static char const   *set_max_clients(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  ap_daemons_limit = atoi(arg);
  if (ap_daemons_limit > server_limit___0) {
    ap_log_error("prefork.c", 1342, 32, 0, (server_rec const   *)((void *)0), "WARNING: MaxClients of %d exceeds ServerLimit value of %d servers,",
                 ap_daemons_limit, server_limit___0);
    ap_log_error("prefork.c", 1345, 32, 0, (server_rec const   *)((void *)0), " lowering MaxClients to %d.  To increase, please see the ServerLimit",
                 server_limit___0);
    ap_log_error("prefork.c", 1348, 32, 0, (server_rec const   *)((void *)0), " directive.");
    ap_daemons_limit = server_limit___0;
  } else {
    if (ap_daemons_limit < 1) {
      ap_log_error("prefork.c", 1353, 32, 0, (server_rec const   *)((void *)0), "WARNING: Require MaxClients > 0, setting to 1");
      ap_daemons_limit = 1;
    }
  }
  return ((char const   *)((void *)0));
}
}
static char const   *set_server_limit(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ int tmp_server_limit ;
  char const   *err ;
  char const   *tmp ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  tmp_server_limit = atoi(arg);
  if (first_server_limit) {
    if (tmp_server_limit != server_limit___0) {
      changed_limit_at_restart = 1;
      return ((char const   *)((void *)0));
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  server_limit___0 = tmp_server_limit;
  if (server_limit___0 > 20000) {
    ap_log_error("prefork.c", 1385, 32, 0, (server_rec const   *)((void *)0), "WARNING: ServerLimit of %d exceeds compile time limit of %d servers,",
                 server_limit___0, 20000);
    ap_log_error("prefork.c", 1388, 32, 0, (server_rec const   *)((void *)0), " lowering ServerLimit to %d.",
                 20000);
    server_limit___0 = 20000;
  } else {
    if (server_limit___0 < 1) {
      ap_log_error("prefork.c", 1393, 32, 0, (server_rec const   *)((void *)0), "WARNING: Require ServerLimit > 0, setting to 1");
      server_limit___0 = 1;
    }
  }
  return ((char const   *)((void *)0));
}
}
static command_rec const   prefork_cmds[11]  = 
  {      {"User", {& unixd_set_user}, (void *)0, 128, 1, "Effective user id for this server"}, 
        {"Group",
      {& unixd_set_group}, (void *)0, 128, 1, "Effective group id for this server"}, 
        {"ListenBacklog",
      {& ap_set_listenbacklog}, (void *)0, 128, 1, "Maximum length of the queue of pending connections, as used by listen(2)"}, 
        {"Listen",
      {& ap_set_listener}, (void *)0, 128, 1, "A port number or a numeric IP address and a port number"}, 
        {"SendBufferSize",
      {& ap_set_send_buffer_size}, (void *)0, 128, 1, "Send buffer size in bytes"}, 
        {"StartServers",
      {& set_daemons_to_start}, (void *)0, 128, 1, "Number of child processes launched at server startup"}, 
        {"MinSpareServers",
      {& set_min_free_servers}, (void *)0, 128, 1, "Minimum number of idle children, to handle request spikes"}, 
        {"MaxSpareServers",
      {& set_max_free_servers}, (void *)0, 128, 1, "Maximum number of idle children"}, 
        {"MaxClients",
      {& set_max_clients}, (void *)0, 128, 1, "Maximum number of children alive at the same time"}, 
        {"ServerLimit",
      {& set_server_limit}, (void *)0, 128, 1, "Maximum value of MaxClients for this run of Apache"}, 
        {(char const   *)((void *)0),
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))0}, (void *)0,
      0, 0, (char const   *)0}};
struct module_struct mpm_prefork_module  = 
     {20020903, 0, -1, "prefork.c", (void *)0, (struct module_struct *)((void *)0),
    1095774768UL, & ap_mpm_rewrite_args, (void *(*)(apr_pool_t *p , char *dir ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), (void *(*)(apr_pool_t *p ,
                                                                                          server_rec *s ))((void *)0),
    (void *(*)(apr_pool_t *p , void *base_conf , void *new_conf ))((void *)0), prefork_cmds,
    & prefork_hooks};
#pragma merger(0,"/tmp/cil-2BaX7p31.i","-g -pthread")
void *apr_pmemdup(apr_pool_t *a , void const   *m , apr_size_t n ) ;
apr_status_t apr_lstat(apr_finfo_t *finfo , char const   *fname , apr_int32_t wanted ,
                       apr_pool_t *pool ) ;
apr_status_t apr_filepath_merge(char **newpath , char const   *rootpath , char const   *addpath ,
                                apr_int32_t flags , apr_pool_t *p ) ;
extern struct _IO_FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
apr_status_t apr_file_open_stderr(apr_file_t **thefile , apr_pool_t *pool ) ;
apr_status_t apr_sockaddr_info_get(apr_sockaddr_t **sa , char const   *hostname ,
                                   apr_int32_t family , apr_port_t port , apr_int32_t flags ,
                                   apr_pool_t *p ) ;
apr_pool_t *apr_hook_global_pool ;
int apr_hook_debug_enabled ;
char const   *apr_hook_debug_current ;
void apr_hook_sort_register(char const   *szHookName , apr_array_header_t **paHooks ) ;
void apr_hook_sort_all(void) ;
void apr_hook_debug_show(char const   *szName , char const   * const  *aszPre___1 ,
                         char const   * const  *aszSucc___2 ) ;
char const   *ap_resolve_env(apr_pool_t *p , char const   *word ) ;
int ap_is_rdirectory(apr_pool_t *p , char const   *path ) ;
 __attribute__((__noreturn__)) void ap_log_assert(char const   *szExp , char const   *szFile ,
                                                  int nLine ) ;
ap_directive_t *ap_conftree ;
ap_directive_t *ap_add_node(ap_directive_t **parent , ap_directive_t *current , ap_directive_t *toadd ,
                            int child ) ;
char const   *ap_set_int_slot(cmd_parms *cmd , void *struct_ptr , char const   *arg ) ;
int ap_method_is_limited(cmd_parms *cmd , char const   *method ) ;
char const   *ap_set_string_slot_lower(cmd_parms *cmd , void *struct_ptr , char const   *arg_ ) ;
void ap_add_module(module *m , apr_pool_t *p ) ;
void ap_remove_module(module *m ) ;
int ap_add_named_module(char const   *name , apr_pool_t *p ) ;
char const   *ap_find_module_name(module *m ) ;
module *ap_find_linked_module(char const   *name ) ;
ap_configfile_t *ap_pcfg_open_custom(apr_pool_t *p , char const   *descr , void *param ,
                                     int (*getch)(void *param ) , void *(*getstr)(void *buf ,
                                                                                  size_t bufsiz ,
                                                                                  void *param ) ,
                                     int (*close_func)(void *param ) ) ;
char const   *ap_soak_end_container(cmd_parms *cmd , char *directive ) ;
char const   *ap_build_cont_config(apr_pool_t *p , apr_pool_t *temp_pool , cmd_parms *parms ,
                                   ap_directive_t **current , ap_directive_t **curr_parent ,
                                   char *orig_directive ) ;
char const   *ap_build_config(cmd_parms *parms , apr_pool_t *p , apr_pool_t *temp_pool ,
                              ap_directive_t **conftree ) ;
char const   *ap_walk_config(ap_directive_t *current , cmd_parms *parms , ap_conf_vector_t *section_vector ) ;
module *ap_top_module ;
module **ap_loaded_modules ;
void ap_setup_prelinked_modules(process_rec *process ) ;
void ap_show_directives(void) ;
void ap_show_modules(void) ;
char const   *ap_show_mpm(void) ;
server_rec *ap_read_config(process_rec *process , apr_pool_t *ptemp , char const   *filename ,
                           ap_directive_t **conftree ) ;
void ap_run_rewrite_args(process_rec *process ) ;
void ap_register_hooks(module *m , apr_pool_t *p ) ;
void ap_fixup_virtual_hosts(apr_pool_t *p , server_rec *main_server ) ;
ap_conf_vector_t *ap_create_per_dir_config(apr_pool_t *p ) ;
ap_conf_vector_t *ap_merge_per_dir_configs(apr_pool_t *p , ap_conf_vector_t *base ,
                                           ap_conf_vector_t *new_conf ) ;
ap_conf_vector_t *ap_create_conn_config(apr_pool_t *p ) ;
int ap_parse_htaccess(ap_conf_vector_t **result , request_rec *r , int override ,
                      char const   *d , char const   *access_name ) ;
char const   *ap_init_virtual_host(apr_pool_t *p , char const   *hostname , server_rec *main_server ,
                                   server_rec **ps ) ;
void ap_process_resource_config(server_rec *s , char const   *fname , ap_directive_t **conftree ,
                                apr_pool_t *p , apr_pool_t *ptemp ) ;
void ap_process_config_tree(server_rec *s , ap_directive_t *conftree , apr_pool_t *p ,
                            apr_pool_t *ptemp ) ;
command_rec const   *ap_find_command(char const   *name , command_rec const   *cmds ) ;
command_rec const   *ap_find_command_in_modules(char const   *cmd_name , module **mod ) ;
void *ap_set_config_vectors(server_rec *server , ap_conf_vector_t *section_vector ,
                            char const   *section , module *mod , apr_pool_t *pconf___0 ) ;
int ap_run_header_parser(request_rec *r ) ;
apr_array_header_t *ap_hook_get_header_parser(void) ;
int ap_run_pre_config(apr_pool_t *pconf___0 , apr_pool_t *plog , apr_pool_t *ptemp ) ;
apr_array_header_t *ap_hook_get_pre_config(void) ;
int ap_run_post_config(apr_pool_t *pconf___0 , apr_pool_t *plog , apr_pool_t *ptemp ,
                       server_rec *s ) ;
apr_array_header_t *ap_hook_get_post_config(void) ;
int ap_run_open_logs(apr_pool_t *pconf___0 , apr_pool_t *plog , apr_pool_t *ptemp ,
                     server_rec *s ) ;
apr_array_header_t *ap_hook_get_open_logs(void) ;
apr_array_header_t *ap_hook_get_child_init(void) ;
int ap_run_handler(request_rec *r ) ;
apr_array_header_t *ap_hook_get_handler(void) ;
void ap_hook_quick_handler(ap_HOOK_quick_handler_t *pf , char const   * const  *aszPre___1 ,
                           char const   * const  *aszSucc___2 , int nOrder ) ;
apr_array_header_t *ap_hook_get_quick_handler(void) ;
void ap_hook_optional_fn_retrieve(ap_HOOK_optional_fn_retrieve_t *pf , char const   * const  *aszPre___1 ,
                                  char const   * const  *aszSucc___2 , int nOrder ) ;
void ap_run_optional_fn_retrieve(void) ;
apr_array_header_t *ap_hook_get_optional_fn_retrieve(void) ;
void ap_core_reorder_directories(apr_pool_t *p , server_rec *s ) ;
void ap_run_insert_filter(request_rec *r ) ;
char const   *ap_server_argv0 ;
apr_array_header_t *ap_server_pre_read_config ;
apr_array_header_t *ap_server_post_read_config ;
apr_array_header_t *ap_server_config_defines ;
void ap_init_vhost_config(apr_pool_t *p ) ;
char const   *ap_parse_vhost_addrs(apr_pool_t *p , char const   *hostname , server_rec *s ) ;
char const   *ap_server_argv0  =    (char const   *)((void *)0);
char const   *ap_server_root  =    (char const   *)((void *)0);
apr_array_header_t *ap_server_pre_read_config  =    (apr_array_header_t *)((void *)0);
apr_array_header_t *ap_server_post_read_config  =    (apr_array_header_t *)((void *)0);
apr_array_header_t *ap_server_config_defines  =    (apr_array_header_t *)((void *)0);
ap_directive_t *ap_conftree  =    (ap_directive_t *)((void *)0);
static struct __anonstruct__hooks_99 _hooks  ;
void ap_hook_header_parser(ap_HOOK_header_parser_t *pf , char const   * const  *aszPre___1 ,
                           char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_header_parser_t *pHook ;

  {
  if (! _hooks.link_header_parser) {
    _hooks.link_header_parser = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_header_parser_t ));
    apr_hook_sort_register("header_parser", & _hooks.link_header_parser);
  }
  pHook = (ap_LINK_header_parser_t *)apr_array_push(_hooks.link_header_parser);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("header_parser", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_header_parser(void) 
{ 

  {
  return (_hooks.link_header_parser);
}
}
int ap_run_header_parser(request_rec *r ) 
{ ap_LINK_header_parser_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks.link_header_parser) {
    return (0);
  }
  pHook = (ap_LINK_header_parser_t *)(_hooks.link_header_parser)->elts;
  n = 0;
  while (n < (_hooks.link_header_parser)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(r);
    if (rv != 0) {
      if (rv != -1) {
        return (rv);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    n ++;
  }
  return (0);
}
}
void ap_hook_pre_config(ap_HOOK_pre_config_t *pf , char const   * const  *aszPre___1 ,
                        char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_pre_config_t *pHook ;

  {
  if (! _hooks.link_pre_config) {
    _hooks.link_pre_config = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_pre_config_t ));
    apr_hook_sort_register("pre_config", & _hooks.link_pre_config);
  }
  pHook = (ap_LINK_pre_config_t *)apr_array_push(_hooks.link_pre_config);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("pre_config", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_pre_config(void) 
{ 

  {
  return (_hooks.link_pre_config);
}
}
int ap_run_pre_config(apr_pool_t *pconf___0 , apr_pool_t *plog , apr_pool_t *ptemp ) 
{ ap_LINK_pre_config_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks.link_pre_config) {
    return (0);
  }
  pHook = (ap_LINK_pre_config_t *)(_hooks.link_pre_config)->elts;
  n = 0;
  while (n < (_hooks.link_pre_config)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(pconf___0, plog, ptemp);
    if (rv != 0) {
      if (rv != -1) {
        return (rv);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    n ++;
  }
  return (0);
}
}
void ap_hook_post_config(ap_HOOK_post_config_t *pf , char const   * const  *aszPre___1 ,
                         char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_post_config_t *pHook ;

  {
  if (! _hooks.link_post_config) {
    _hooks.link_post_config = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_post_config_t ));
    apr_hook_sort_register("post_config", & _hooks.link_post_config);
  }
  pHook = (ap_LINK_post_config_t *)apr_array_push(_hooks.link_post_config);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("post_config", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_post_config(void) 
{ 

  {
  return (_hooks.link_post_config);
}
}
int ap_run_post_config(apr_pool_t *pconf___0 , apr_pool_t *plog , apr_pool_t *ptemp ,
                       server_rec *s ) 
{ ap_LINK_post_config_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks.link_post_config) {
    return (0);
  }
  pHook = (ap_LINK_post_config_t *)(_hooks.link_post_config)->elts;
  n = 0;
  while (n < (_hooks.link_post_config)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(pconf___0, plog, ptemp, s);
    if (rv != 0) {
      if (rv != -1) {
        return (rv);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    n ++;
  }
  return (0);
}
}
void ap_hook_open_logs(ap_HOOK_open_logs_t *pf , char const   * const  *aszPre___1 ,
                       char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_open_logs_t *pHook ;

  {
  if (! _hooks.link_open_logs) {
    _hooks.link_open_logs = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_open_logs_t ));
    apr_hook_sort_register("open_logs", & _hooks.link_open_logs);
  }
  pHook = (ap_LINK_open_logs_t *)apr_array_push(_hooks.link_open_logs);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("open_logs", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_open_logs(void) 
{ 

  {
  return (_hooks.link_open_logs);
}
}
int ap_run_open_logs(apr_pool_t *pconf___0 , apr_pool_t *plog , apr_pool_t *ptemp ,
                     server_rec *s ) 
{ ap_LINK_open_logs_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks.link_open_logs) {
    return (0);
  }
  pHook = (ap_LINK_open_logs_t *)(_hooks.link_open_logs)->elts;
  n = 0;
  while (n < (_hooks.link_open_logs)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(pconf___0, plog, ptemp, s);
    if (rv != 0) {
      if (rv != -1) {
        return (rv);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    n ++;
  }
  return (0);
}
}
void ap_hook_child_init(ap_HOOK_child_init_t *pf , char const   * const  *aszPre___1 ,
                        char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_child_init_t *pHook ;

  {
  if (! _hooks.link_child_init) {
    _hooks.link_child_init = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_child_init_t ));
    apr_hook_sort_register("child_init", & _hooks.link_child_init);
  }
  pHook = (ap_LINK_child_init_t *)apr_array_push(_hooks.link_child_init);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("child_init", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_child_init(void) 
{ 

  {
  return (_hooks.link_child_init);
}
}
void ap_run_child_init(apr_pool_t *pchild___0 , server_rec *s ) 
{ ap_LINK_child_init_t *pHook ;
  int n ;

  {
  if (! _hooks.link_child_init) {
    return;
  }
  pHook = (ap_LINK_child_init_t *)(_hooks.link_child_init)->elts;
  n = 0;
  while (n < (_hooks.link_child_init)->nelts) {
    ((*((pHook + n)->pFunc)))(pchild___0, s);
    n ++;
  }
  return;
}
}
void ap_hook_handler(ap_HOOK_handler_t *pf , char const   * const  *aszPre___1 , char const   * const  *aszSucc___2 ,
                     int nOrder ) 
{ ap_LINK_handler_t *pHook ;

  {
  if (! _hooks.link_handler) {
    _hooks.link_handler = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_handler_t ));
    apr_hook_sort_register("handler", & _hooks.link_handler);
  }
  pHook = (ap_LINK_handler_t *)apr_array_push(_hooks.link_handler);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("handler", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_handler(void) 
{ 

  {
  return (_hooks.link_handler);
}
}
int ap_run_handler(request_rec *r ) 
{ ap_LINK_handler_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks.link_handler) {
    return (-1);
  }
  pHook = (ap_LINK_handler_t *)(_hooks.link_handler)->elts;
  n = 0;
  while (n < (_hooks.link_handler)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(r);
    if (rv != -1) {
      return (rv);
    }
    n ++;
  }
  return (-1);
}
}
void ap_hook_quick_handler(ap_HOOK_quick_handler_t *pf , char const   * const  *aszPre___1 ,
                           char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_quick_handler_t *pHook ;

  {
  if (! _hooks.link_quick_handler) {
    _hooks.link_quick_handler = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_quick_handler_t ));
    apr_hook_sort_register("quick_handler", & _hooks.link_quick_handler);
  }
  pHook = (ap_LINK_quick_handler_t *)apr_array_push(_hooks.link_quick_handler);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("quick_handler", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_quick_handler(void) 
{ 

  {
  return (_hooks.link_quick_handler);
}
}
int ap_run_quick_handler(request_rec *r , int lookup ) 
{ ap_LINK_quick_handler_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks.link_quick_handler) {
    return (-1);
  }
  pHook = (ap_LINK_quick_handler_t *)(_hooks.link_quick_handler)->elts;
  n = 0;
  while (n < (_hooks.link_quick_handler)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(r, lookup);
    if (rv != -1) {
      return (rv);
    }
    n ++;
  }
  return (-1);
}
}
void ap_hook_optional_fn_retrieve(ap_HOOK_optional_fn_retrieve_t *pf , char const   * const  *aszPre___1 ,
                                  char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_optional_fn_retrieve_t *pHook ;

  {
  if (! _hooks.link_optional_fn_retrieve) {
    _hooks.link_optional_fn_retrieve = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_optional_fn_retrieve_t ));
    apr_hook_sort_register("optional_fn_retrieve", & _hooks.link_optional_fn_retrieve);
  }
  pHook = (ap_LINK_optional_fn_retrieve_t *)apr_array_push(_hooks.link_optional_fn_retrieve);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("optional_fn_retrieve", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_optional_fn_retrieve(void) 
{ 

  {
  return (_hooks.link_optional_fn_retrieve);
}
}
void ap_run_optional_fn_retrieve(void) 
{ ap_LINK_optional_fn_retrieve_t *pHook ;
  int n ;

  {
  if (! _hooks.link_optional_fn_retrieve) {
    return;
  }
  pHook = (ap_LINK_optional_fn_retrieve_t *)(_hooks.link_optional_fn_retrieve)->elts;
  n = 0;
  while (n < (_hooks.link_optional_fn_retrieve)->nelts) {
    ((*((pHook + n)->pFunc)))();
    n ++;
  }
  return;
}
}
static int total_modules  =    0;
static int dynamic_modules  =    0;
module *ap_top_module  =    (module *)((void *)0);
module **ap_loaded_modules  =    (module **)((void *)0);
static ap_conf_vector_t *create_empty_config(apr_pool_t *p ) 
{ void *conf_vector ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = apr_palloc(p, sizeof(void *) * (unsigned int )(total_modules + 64));
  tmp___0 = memset(tmp, 0, sizeof(void *) * (unsigned int )(total_modules + 64));
  conf_vector = tmp___0;
  return ((ap_conf_vector_t *)conf_vector);
}
}
static ap_conf_vector_t *create_default_per_dir_config(apr_pool_t *p ) 
{ void **conf_vector ;
  void *tmp ;
  void **tmp___0 ;
  module *modp ;
  void *(*df)(apr_pool_t * , char * ) ;

  {
  tmp = apr_palloc(p, sizeof(void *) * (unsigned int )(total_modules + 64));
  tmp___0 = (void **)memset(tmp, 0, sizeof(void *) * (unsigned int )(total_modules +
                                                                     64));
  conf_vector = tmp___0;
  modp = ap_top_module;
  while (modp) {
    df = modp->create_dir_config;
    if (df) {
      (*(conf_vector + modp->module_index)) = ((*df))(p, (char *)((void *)0));
    }
    modp = modp->next;
  }
  return ((ap_conf_vector_t *)conf_vector);
}
}
ap_conf_vector_t *ap_merge_per_dir_configs(apr_pool_t *p , ap_conf_vector_t *base ,
                                           ap_conf_vector_t *new_conf ) 
{ void **conf_vector ;
  void **tmp ;
  void **base_vector ;
  void **new_vector ;
  module *modp ;
  int i ;
  void *(*df)(apr_pool_t * , void * , void * ) ;

  {
  tmp = (void **)apr_palloc(p, sizeof(void *) * (unsigned int )total_modules);
  conf_vector = tmp;
  base_vector = (void **)base;
  new_vector = (void **)new_conf;
  modp = ap_top_module;
  while (modp) {
    i = modp->module_index;
    if (! (*(new_vector + i))) {
      (*(conf_vector + i)) = (*(base_vector + i));
    } else {
      df = modp->merge_dir_config;
      if (df) {
        if ((*(base_vector + i))) {
          (*(conf_vector + i)) = ((*df))(p, (*(base_vector + i)), (*(new_vector +
                                                                     i)));
        } else {
          goto _L;
        }
      } else {
        _L: 
        (*(conf_vector + i)) = (*(new_vector + i));
      }
    }
    modp = modp->next;
  }
  return ((ap_conf_vector_t *)conf_vector);
}
}
static ap_conf_vector_t *create_server_config(apr_pool_t *p , server_rec *s ) 
{ void **conf_vector ;
  void *tmp ;
  void **tmp___0 ;
  module *modp ;

  {
  tmp = apr_palloc(p, sizeof(void *) * (unsigned int )(total_modules + 64));
  tmp___0 = (void **)memset(tmp, 0, sizeof(void *) * (unsigned int )(total_modules +
                                                                     64));
  conf_vector = tmp___0;
  modp = ap_top_module;
  while (modp) {
    if (modp->create_server_config) {
      (*(conf_vector + modp->module_index)) = ((*(modp->create_server_config)))(p,
                                                                                s);
    }
    modp = modp->next;
  }
  return ((ap_conf_vector_t *)conf_vector);
}
}
static void merge_server_configs(apr_pool_t *p , ap_conf_vector_t *base , ap_conf_vector_t *virt ) 
{ void **base_vector ;
  void **virt_vector ;
  module *modp ;
  void *(*df)(apr_pool_t * , void * , void * ) ;
  int i ;

  {
  base_vector = (void **)base;
  virt_vector = (void **)virt;
  modp = ap_top_module;
  while (modp) {
    df = modp->merge_server_config;
    i = modp->module_index;
    if (! (*(virt_vector + i))) {
      (*(virt_vector + i)) = (*(base_vector + i));
    } else {
      if (df) {
        (*(virt_vector + i)) = ((*df))(p, (*(base_vector + i)), (*(virt_vector + i)));
      }
    }
    modp = modp->next;
  }
  return;
}
}
ap_conf_vector_t *ap_create_request_config(apr_pool_t *p ) 
{ ap_conf_vector_t *tmp ;

  {
  tmp = create_empty_config(p);
  return (tmp);
}
}
ap_conf_vector_t *ap_create_conn_config(apr_pool_t *p ) 
{ ap_conf_vector_t *tmp ;

  {
  tmp = create_empty_config(p);
  return (tmp);
}
}
ap_conf_vector_t *ap_create_per_dir_config(apr_pool_t *p ) 
{ ap_conf_vector_t *tmp ;

  {
  tmp = create_empty_config(p);
  return (tmp);
}
}
static int ap_invoke_filter_init(ap_filter_t *filters ) 
{ int result ;
  int tmp ;

  {
  while (filters) {
    if ((filters->frec)->filter_init_func) {
      tmp = ((*((filters->frec)->filter_init_func)))(filters);
      result = tmp;
      if (result != 0) {
        return (result);
      }
    }
    filters = filters->next;
  }
  return (0);
}
}
int ap_invoke_handler(request_rec *r ) 
{ char const   *handler ;
  char const   *p ;
  int result ;
  char const   *old_handler ;
  char *new_handler ;
  char *tmp___0 ;
  char *p2 ;
  int tmp___1 ;

  {
  old_handler = r->handler;
  ap_run_insert_filter(r);
  result = ap_invoke_filter_init(r->input_filters);
  if (result != 0) {
    return (result);
  }
  result = ap_invoke_filter_init(r->output_filters);
  if (result != 0) {
    return (result);
  }
  if (! r->handler) {
    if (r->content_type) {
      handler = r->content_type;
    } else {
      handler = ap_default_type(r);
    }
    p = strchr(handler, ';');
    if ((unsigned int )p != (unsigned int )((void *)0)) {
      tmp___0 = (char *)apr_pmemdup(r->pool, (void const   *)handler, (unsigned int )((p -
                                                                                       handler) +
                                                                                      1));
      new_handler = tmp___0;
      p2 = new_handler + (p - handler);
      handler = (char const   *)new_handler;
      while (1) {
        if ((unsigned int )p2 > (unsigned int )handler) {
          if (! ((int )(*(p2 + -1)) == 32)) {
            goto _L;
          }
        } else {
          _L: 
          break;
        }
        p2 --;
      }
      (*p2) = (char )'\000';
    }
    r->handler = handler;
  }
  result = ap_run_handler(r);
  r->handler = old_handler;
  if (result == -1) {
    if (r->handler) {
      if (r->filename) {
        ap_log_rerror("config.c", 406, 4, 0, (request_rec const   *)r, "handler \"%s\" not found for: %s",
                      r->handler, r->filename);
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: ;
  }
  if (result == -1) {
    tmp___1 = 500;
  } else {
    tmp___1 = result;
  }
  return (tmp___1);
}
}
int ap_method_is_limited(cmd_parms *cmd , char const   *method ) 
{ int methnum ;
  int tmp ;

  {
  methnum = ap_method_number_of(method);
  if (methnum != 26) {
    if (cmd->limited & (1LL << methnum)) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    return (tmp);
  }
  return (0);
}
}
void ap_register_hooks(module *m , apr_pool_t *p ) 
{ char *tmp ;

  {
  if (m->register_hooks) {
    tmp = getenv("SHOW_HOOKS");
    if (tmp) {
      printf((char const   * __restrict  )"Registering hooks for %s\n", m->name);
      apr_hook_debug_enabled = 1;
    }
    apr_hook_debug_current = m->name;
    ((*(m->register_hooks)))(p);
  }
  return;
}
}
void ap_add_module(module *m , apr_pool_t *p ) 
{ int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  if (m->version != 20020903) {
    ap_log_error("config.c", 453, 32, 0, (server_rec const   *)((void *)0), "%s: module \"%s\" is not compatible with this version of Apache (found %d, need %d).",
                 ap_server_argv0, m->name, m->version, 20020903);
    ap_log_error("config.c", 458, 32, 0, (server_rec const   *)((void *)0), "Please contact the vendor for the correct version.");
    exit(1);
  }
  if ((unsigned int )m->next == (unsigned int )((void *)0)) {
    m->next = ap_top_module;
    ap_top_module = m;
  }
  if (m->module_index == -1) {
    tmp = total_modules;
    total_modules ++;
    m->module_index = tmp;
    dynamic_modules ++;
    if (dynamic_modules > 64) {
      ap_log_error("config.c", 473, 32, 0, (server_rec const   *)((void *)0), "%s: module \"%s\" could not be loaded, because the dynamic",
                   ap_server_argv0, m->name);
      ap_log_error("config.c", 476, 32, 0, (server_rec const   *)((void *)0), "module limit was reached. Please increase DYNAMIC_MODULE_LIMIT and recompile.");
      exit(1);
    }
  }
  tmp___1 = strrchr(m->name, '/');
  if (tmp___1) {
    tmp___0 = strrchr(m->name, '/');
    m->name = (char const   *)(tmp___0 + 1);
  }
  tmp___3 = strrchr(m->name, '\\');
  if (tmp___3) {
    tmp___2 = strrchr(m->name, '\\');
    m->name = (char const   *)(tmp___2 + 1);
  }
  ap_register_hooks(m, p);
  return;
}
}
void ap_remove_module(module *m ) 
{ module *modp ;

  {
  modp = ap_top_module;
  if ((unsigned int )modp == (unsigned int )m) {
    ap_top_module = modp->next;
    m->next = (struct module_struct *)((void *)0);
  } else {
    while (1) {
      if (modp) {
        if (! ((unsigned int )modp->next != (unsigned int )m)) {
          goto _L;
        }
      } else {
        _L: 
        break;
      }
      modp = modp->next;
    }
    if (! modp) {
      ap_log_error("config.c", 542, 3, 0, (server_rec const   *)((void *)0), "Cannot remove module %s: not found in module list",
                   m->name);
      return;
    }
    modp->next = (modp->next)->next;
  }
  m->module_index = -1;
  dynamic_modules --;
  total_modules --;
  return;
}
}
void ap_add_loaded_module(module *mod , apr_pool_t *p ) 
{ module **m ;
  module **tmp ;

  {
  ap_add_module(mod, p);
  m = ap_loaded_modules;
  while ((unsigned int )(*m) != (unsigned int )((void *)0)) {
    m ++;
  }
  tmp = m;
  m ++;
  (*tmp) = mod;
  (*m) = (module *)((void *)0);
  return;
}
}
void ap_remove_loaded_module(module *mod ) 
{ module **m ;
  module **m2 ;
  int done ;
  module **tmp ;

  {
  ap_remove_module(mod);
  m2 = ap_loaded_modules;
  m = m2;
  done = 0;
  while ((unsigned int )(*m2) != (unsigned int )((void *)0)) {
    if ((unsigned int )(*m2) == (unsigned int )mod) {
      if (done == 0) {
        done = 1;
      } else {
        goto _L;
      }
    } else {
      _L: 
      tmp = m;
      m ++;
      (*tmp) = (*m2);
    }
    m2 ++;
  }
  (*m) = (module *)((void *)0);
  return;
}
}
void ap_setup_prelinked_modules(process_rec *process ) 
{ module **m ;
  module **m2 ;
  int tmp ;
  module **tmp___1 ;
  module **tmp___2 ;

  {
  apr_hook_global_pool = process->pconf;
  total_modules = 0;
  m = ap_preloaded_modules;
  while ((unsigned int )(*m) != (unsigned int )((void *)0)) {
    tmp = total_modules;
    total_modules ++;
    ((*m))->module_index = tmp;
    m ++;
  }
  ap_loaded_modules = (module **)apr_palloc(process->pool, sizeof(module *) * (unsigned int )((total_modules +
                                                                                               64) +
                                                                                              1));
  if ((unsigned int )ap_loaded_modules == (unsigned int )((void *)0)) {
    ap_log_error("config.c", 632, 32, 0, (server_rec const   *)((void *)0), "Ouch!  Out of memory in ap_setup_prelinked_modules()!");
  }
  m = ap_preloaded_modules;
  m2 = ap_loaded_modules;
  while ((unsigned int )(*m) != (unsigned int )((void *)0)) {
    tmp___1 = m2;
    m2 ++;
    tmp___2 = m;
    m ++;
    (*tmp___1) = (*tmp___2);
  }
  (*m2) = (module *)((void *)0);
  m = ap_prelinked_modules;
  while ((unsigned int )(*m) != (unsigned int )((void *)0)) {
    ap_add_module((*m), process->pconf);
    m ++;
  }
  apr_hook_sort_all();
  return;
}
}
char const   *ap_find_module_name(module *m ) 
{ 

  {
  return (m->name);
}
}
module *ap_find_linked_module(char const   *name ) 
{ module *modp ;
  int tmp ;

  {
  modp = ap_top_module;
  while (modp) {
    tmp = strcmp(modp->name, name);
    if (tmp == 0) {
      return (modp);
    }
    modp = modp->next;
  }
  return ((module *)((void *)0));
}
}
int ap_add_named_module(char const   *name , apr_pool_t *p ) 
{ module *modp ;
  int i ;
  int tmp ;

  {
  i = 0;
  modp = (*(ap_loaded_modules + i));
  while (modp) {
    tmp = strcmp(modp->name, name);
    if (tmp == 0) {
      if ((unsigned int )modp->next == (unsigned int )((void *)0)) {
        ap_add_module(modp, p);
      }
      return (1);
    }
    i ++;
    modp = (*(ap_loaded_modules + i));
  }
  return (0);
}
}
static char const   *invoke_cmd(command_rec const   *cmd , cmd_parms *parms , void *mconfig ,
                                char const   *args ) 
{ char *w ;
  char *w2 ;
  char *w3 ;
  char const   *errmsg ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  char const   *tmp___36 ;
  char const   *tmp___37 ;

  {
  if ((parms->override & cmd->req_override) == 0) {
    tmp = apr_pstrcat(parms->pool, cmd->name, " not allowed here", (void *)0);
    return (tmp);
  }
  parms->info = cmd->cmd_data;
  parms->cmd = cmd;
  switch ((int )cmd->args_how) {
  case 0: 
  tmp___0 = ((*(cmd->func.raw_args)))(parms, mconfig, args);
  return (tmp___0);
  case 6: ;
  if ((int const   )(*args) != 0) {
    tmp___1 = apr_pstrcat(parms->pool, cmd->name, " takes no arguments", (void *)0);
    return (tmp___1);
  }
  tmp___2 = ((*(cmd->func.no_args)))(parms, mconfig);
  return (tmp___2);
  case 1: 
  w = ap_getword_conf(parms->pool, & args);
  if ((int )(*w) == 0) {
    goto _L;
  } else {
    if ((int const   )(*args) != 0) {
      _L: 
      if (cmd->errmsg) {
        tmp___3 = ", ";
      } else {
        tmp___3 = (char const   *)((void *)0);
      }
      tmp___4 = apr_pstrcat(parms->pool, cmd->name, " takes one argument", tmp___3,
                            cmd->errmsg, (void *)0);
      return (tmp___4);
    }
  }
  tmp___5 = ((*(cmd->func.take1)))(parms, mconfig, (char const   *)w);
  return (tmp___5);
  case 2: 
  w = ap_getword_conf(parms->pool, & args);
  w2 = ap_getword_conf(parms->pool, & args);
  if ((int )(*w) == 0) {
    goto _L___1;
  } else {
    if ((int )(*w2) == 0) {
      _L___1: 
      goto _L___0;
    } else {
      if ((int const   )(*args) != 0) {
        _L___0: 
        if (cmd->errmsg) {
          tmp___6 = ", ";
        } else {
          tmp___6 = (char const   *)((void *)0);
        }
        tmp___7 = apr_pstrcat(parms->pool, cmd->name, " takes two arguments", tmp___6,
                              cmd->errmsg, (void *)0);
        return (tmp___7);
      }
    }
  }
  tmp___8 = ((*(cmd->func.take2)))(parms, mconfig, (char const   *)w, (char const   *)w2);
  return (tmp___8);
  case 7: 
  w = ap_getword_conf(parms->pool, & args);
  w2 = ap_getword_conf(parms->pool, & args);
  if ((int )(*w) == 0) {
    goto _L___2;
  } else {
    if ((int const   )(*args) != 0) {
      _L___2: 
      if (cmd->errmsg) {
        tmp___9 = ", ";
      } else {
        tmp___9 = (char const   *)((void *)0);
      }
      tmp___10 = apr_pstrcat(parms->pool, cmd->name, " takes 1-2 arguments", tmp___9,
                             cmd->errmsg, (void *)0);
      return (tmp___10);
    }
  }
  if ((*w2)) {
    tmp___11 = w2;
  } else {
    tmp___11 = (char *)((void *)0);
  }
  tmp___12 = ((*(cmd->func.take2)))(parms, mconfig, (char const   *)w, (char const   *)tmp___11);
  return (tmp___12);
  case 8: 
  w = ap_getword_conf(parms->pool, & args);
  w2 = ap_getword_conf(parms->pool, & args);
  w3 = ap_getword_conf(parms->pool, & args);
  if ((int )(*w) == 0) {
    goto _L___5;
  } else {
    if ((int )(*w2) == 0) {
      _L___5: 
      goto _L___4;
    } else {
      if ((int )(*w3) == 0) {
        _L___4: 
        goto _L___3;
      } else {
        if ((int const   )(*args) != 0) {
          _L___3: 
          if (cmd->errmsg) {
            tmp___13 = ", ";
          } else {
            tmp___13 = (char const   *)((void *)0);
          }
          tmp___14 = apr_pstrcat(parms->pool, cmd->name, " takes three arguments",
                                 tmp___13, cmd->errmsg, (void *)0);
          return (tmp___14);
        }
      }
    }
  }
  tmp___15 = ((*(cmd->func.take3)))(parms, mconfig, (char const   *)w, (char const   *)w2,
                                    (char const   *)w3);
  return (tmp___15);
  case 9: 
  w = ap_getword_conf(parms->pool, & args);
  w2 = ap_getword_conf(parms->pool, & args);
  if ((*args)) {
    w3 = ap_getword_conf(parms->pool, & args);
  } else {
    w3 = (char *)((void *)0);
  }
  if ((int )(*w) == 0) {
    goto _L___7;
  } else {
    if ((int )(*w2) == 0) {
      _L___7: 
      goto _L___6;
    } else {
      if ((int const   )(*args) != 0) {
        _L___6: 
        if (cmd->errmsg) {
          tmp___17 = ", ";
        } else {
          tmp___17 = (char const   *)((void *)0);
        }
        tmp___18 = apr_pstrcat(parms->pool, cmd->name, " takes two or three arguments",
                               tmp___17, cmd->errmsg, (void *)0);
        return (tmp___18);
      }
    }
  }
  tmp___19 = ((*(cmd->func.take3)))(parms, mconfig, (char const   *)w, (char const   *)w2,
                                    (char const   *)w3);
  return (tmp___19);
  case 10: 
  w = ap_getword_conf(parms->pool, & args);
  if ((*args)) {
    w2 = ap_getword_conf(parms->pool, & args);
  } else {
    w2 = (char *)((void *)0);
  }
  if ((*args)) {
    w3 = ap_getword_conf(parms->pool, & args);
  } else {
    w3 = (char *)((void *)0);
  }
  if ((int )(*w) == 0) {
    goto _L___8;
  } else {
    if ((int const   )(*args) != 0) {
      _L___8: 
      if (cmd->errmsg) {
        tmp___22 = ", ";
      } else {
        tmp___22 = (char const   *)((void *)0);
      }
      tmp___23 = apr_pstrcat(parms->pool, cmd->name, " takes one, two or three arguments",
                             tmp___22, cmd->errmsg, (void *)0);
      return (tmp___23);
    }
  }
  tmp___24 = ((*(cmd->func.take3)))(parms, mconfig, (char const   *)w, (char const   *)w2,
                                    (char const   *)w3);
  return (tmp___24);
  case 11: 
  w = ap_getword_conf(parms->pool, & args);
  if ((*args)) {
    w2 = ap_getword_conf(parms->pool, & args);
  } else {
    w2 = (char *)((void *)0);
  }
  if ((*args)) {
    w3 = ap_getword_conf(parms->pool, & args);
  } else {
    w3 = (char *)((void *)0);
  }
  if ((int )(*w) == 0) {
    goto _L___10;
  } else {
    if (w2) {
      if ((*w2)) {
        if (! w3) {
          _L___10: 
          goto _L___9;
        } else {
          goto _L___12;
        }
      } else {
        goto _L___12;
      }
    } else {
      _L___12: 
      if ((int const   )(*args) != 0) {
        _L___9: 
        if (cmd->errmsg) {
          tmp___27 = ", ";
        } else {
          tmp___27 = (char const   *)((void *)0);
        }
        tmp___28 = apr_pstrcat(parms->pool, cmd->name, " takes one or three arguments",
                               tmp___27, cmd->errmsg, (void *)0);
        return (tmp___28);
      }
    }
  }
  tmp___29 = ((*(cmd->func.take3)))(parms, mconfig, (char const   *)w, (char const   *)w2,
                                    (char const   *)w3);
  return (tmp___29);
  case 3: ;
  while (1) {
    w = ap_getword_conf(parms->pool, & args);
    if (! ((int )(*w) != 0)) {
      break;
    }
    errmsg = ((*(cmd->func.take1)))(parms, mconfig, (char const   *)w);
    if (errmsg) {
      return (errmsg);
    }
  }
  return ((char const   *)((void *)0));
  case 4: 
  w = ap_getword_conf(parms->pool, & args);
  if ((int )(*w) == 0) {
    goto _L___13;
  } else {
    if ((int const   )(*args) == 0) {
      _L___13: 
      if (cmd->errmsg) {
        tmp___30 = ", ";
      } else {
        tmp___30 = (char const   *)((void *)0);
      }
      tmp___31 = apr_pstrcat(parms->pool, cmd->name, " requires at least two arguments",
                             tmp___30, cmd->errmsg, (void *)0);
      return (tmp___31);
    }
  }
  while (1) {
    w2 = ap_getword_conf(parms->pool, & args);
    if (! ((int )(*w2) != 0)) {
      break;
    }
    errmsg = ((*(cmd->func.take2)))(parms, mconfig, (char const   *)w, (char const   *)w2);
    if (errmsg) {
      return (errmsg);
    }
  }
  return ((char const   *)((void *)0));
  case 5: 
  w = ap_getword_conf(parms->pool, & args);
  if ((int )(*w) == 0) {
    goto _L___14;
  } else {
    tmp___33 = strcasecmp((char const   *)w, "on");
    if (tmp___33) {
      tmp___34 = strcasecmp((char const   *)w, "off");
      if (tmp___34) {
        _L___14: 
        tmp___32 = apr_pstrcat(parms->pool, cmd->name, " must be On or Off", (void *)0);
        return (tmp___32);
      } else {
        goto _L___15;
      }
    } else {
      _L___15: ;
    }
  }
  tmp___35 = strcasecmp((char const   *)w, "off");
  tmp___36 = ((*(cmd->func.flag)))(parms, mconfig, tmp___35 != 0);
  return (tmp___36);
  default: 
  tmp___37 = apr_pstrcat(parms->pool, cmd->name, " is improperly configured internally (server bug)",
                         (void *)0);
  return (tmp___37);
  }
}
}
command_rec const   *ap_find_command(char const   *name , command_rec const   *cmds ) 
{ int tmp ;

  {
  while (cmds->name) {
    tmp = strcasecmp(name, cmds->name);
    if (! tmp) {
      return (cmds);
    }
    cmds ++;
  }
  return ((command_rec const   *)((void *)0));
}
}
command_rec const   *ap_find_command_in_modules(char const   *cmd_name , module **mod ) 
{ command_rec const   *cmdp ;
  module *modp ;

  {
  modp = (*mod);
  while (modp) {
    if (modp->cmds) {
      cmdp = ap_find_command(cmd_name, modp->cmds);
      if (cmdp) {
        (*mod) = modp;
        return (cmdp);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    modp = modp->next;
  }
  return ((command_rec const   *)((void *)0));
}
}
void *ap_set_config_vectors(server_rec *server , ap_conf_vector_t *section_vector ,
                            char const   *section , module *mod , apr_pool_t *pconf___0 ) 
{ void *section_config ;
  void *server_config ;

  {
  section_config = (*((void **)section_vector + mod->module_index));
  server_config = (*((void **)server->module_config + mod->module_index));
  if (! section_config) {
    if (mod->create_dir_config) {
      section_config = ((*(mod->create_dir_config)))(pconf___0, (char *)section);
      (*((void **)section_vector + mod->module_index)) = section_config;
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if (! server_config) {
    if (mod->create_server_config) {
      server_config = ((*(mod->create_server_config)))(pconf___0, server);
      (*((void **)server->module_config + mod->module_index)) = server_config;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
  }
  return (section_config);
}
}
static char const   *execute_now(char *cmd_line , char const   *args , cmd_parms *parms ,
                                 apr_pool_t *p , apr_pool_t *ptemp , ap_directive_t **sub_tree ,
                                 ap_directive_t *parent ) ;
static char const   *ap_build_config_sub(apr_pool_t *p , apr_pool_t *temp_pool , char const   *l ,
                                         cmd_parms *parms , ap_directive_t **current ,
                                         ap_directive_t **curr_parent , ap_directive_t **conftree ) 
{ char const   *retval ;
  char const   *args ;
  char *cmd_name ;
  ap_directive_t *newdir ;
  module *mod ;
  command_rec const   *cmd ;
  char *lastc ;
  size_t tmp ;
  void *tmp___0 ;
  ap_directive_t *sub_tree ;
  char const   *tmp___1 ;
  char *bracket ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;

  {
  retval = (char const   *)((void *)0);
  mod = ap_top_module;
  if ((int const   )(*l) == 35) {
    goto _L;
  } else {
    if ((int const   )(*l) == 0) {
      _L: 
      return ((char const   *)((void *)0));
    }
  }
  args = ap_resolve_env(temp_pool, l);
  cmd_name = ap_getword_conf(p, & args);
  if ((int )(*cmd_name) == 0) {
    return ((char const   *)((void *)0));
  }
  if ((int )(*(cmd_name + 1)) != 47) {
    tmp = strlen((char const   *)cmd_name);
    lastc = (cmd_name + tmp) - 1;
    if ((int )(*lastc) == 62) {
      (*lastc) = (char )'\000';
    }
  }
  tmp___0 = apr_palloc(p, sizeof(ap_directive_t ));
  newdir = (ap_directive_t *)memset(tmp___0, 0, sizeof(ap_directive_t ));
  newdir->filename = (parms->config_file)->name;
  newdir->line_num = (int )(parms->config_file)->line_number;
  newdir->directive = (char const   *)cmd_name;
  newdir->args = apr_pstrdup(p, args);
  cmd = ap_find_command_in_modules((char const   *)cmd_name, & mod);
  if ((unsigned int )cmd != (unsigned int )((void *)0)) {
    if (cmd->req_override & 256) {
      sub_tree = (ap_directive_t *)((void *)0);
      parms->err_directive = (ap_directive_t const   *)newdir;
      retval = execute_now(cmd_name, args, parms, p, temp_pool, & sub_tree, (*curr_parent));
      if ((*current)) {
        ((*current))->next = sub_tree;
      } else {
        (*current) = sub_tree;
        if ((*curr_parent)) {
          ((*curr_parent))->first_child = (*current);
        }
        if ((*current)) {
          ((*current))->parent = (*curr_parent);
        }
      }
      if ((*current)) {
        if (! (*conftree)) {
          (*conftree) = (*current);
        }
        while ((unsigned int )((*current))->next != (unsigned int )((void *)0)) {
          (*current) = ((*current))->next;
          ((*current))->parent = (*curr_parent);
        }
      }
      return (retval);
    }
  }
  if ((int )(*(cmd_name + 0)) == 60) {
    if ((int )(*(cmd_name + 1)) != 47) {
      (*current) = ap_add_node(curr_parent, (*current), newdir, 1);
    } else {
      if ((unsigned int )(*curr_parent) == (unsigned int )((void *)0)) {
        parms->err_directive = (ap_directive_t const   *)newdir;
        tmp___1 = apr_pstrcat(p, cmd_name, " without matching <", cmd_name + 2, " section",
                              (void *)0);
        return (tmp___1);
      } else {
        tmp___2 = strlen((char const   *)cmd_name);
        bracket = (cmd_name + tmp___2) - 1;
        if ((int )(*bracket) != 62) {
          parms->err_directive = (ap_directive_t const   *)newdir;
          tmp___3 = apr_pstrcat(p, cmd_name, "> directive missing closing \'>\'",
                                (void *)0);
          return (tmp___3);
        }
        (*bracket) = (char )'\000';
        tmp___5 = strcasecmp((char const   *)(cmd_name + 2), ((*curr_parent))->directive +
                                                             1);
        if (tmp___5 != 0) {
          parms->err_directive = (ap_directive_t const   *)newdir;
          tmp___4 = apr_pstrcat(p, "Expected </", ((*curr_parent))->directive + 1,
                                "> but saw ", cmd_name, ">", (void *)0);
          return (tmp___4);
        }
        (*bracket) = (char )'>';
        (*current) = (*curr_parent);
        (*curr_parent) = ((*current))->parent;
      }
    }
  } else {
    (*current) = ap_add_node(curr_parent, (*current), newdir, 0);
  }
  return (retval);
}
}
char const   *ap_build_cont_config(apr_pool_t *p , apr_pool_t *temp_pool , cmd_parms *parms ,
                                   ap_directive_t **current , ap_directive_t **curr_parent ,
                                   char *orig_directive ) 
{ char l[8192] ;
  char *bracket ;
  char const   *retval ;
  ap_directive_t *sub_tree ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  sub_tree = (ap_directive_t *)((void *)0);
  bracket = apr_pstrcat(p, orig_directive + 1, ">", (void *)0);
  while (1) {
    tmp___1 = ap_cfg_getline(l, 8192U, parms->config_file);
    if (tmp___1) {
      break;
    }
    tmp = memcmp((void const   *)(l), (void const   *)"</", 2U);
    if (tmp) {
      _L___0: ;
    } else {
      tmp___0 = strcasecmp((char const   *)(l + 2), (char const   *)bracket);
      if (tmp___0 == 0) {
        if ((unsigned int )(*curr_parent) == (unsigned int )((void *)0)) {
          break;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    }
    retval = ap_build_config_sub(p, temp_pool, (char const   *)(l), parms, current,
                                 curr_parent, & sub_tree);
    if ((unsigned int )retval != (unsigned int )((void *)0)) {
      return (retval);
    }
    if ((unsigned int )sub_tree == (unsigned int )((void *)0)) {
      if ((unsigned int )curr_parent != (unsigned int )((void *)0)) {
        sub_tree = (*curr_parent);
      } else {
        goto _L___1;
      }
    } else {
      _L___1: ;
    }
    if ((unsigned int )sub_tree == (unsigned int )((void *)0)) {
      if ((unsigned int )current != (unsigned int )((void *)0)) {
        sub_tree = (*current);
      } else {
        goto _L___2;
      }
    } else {
      _L___2: ;
    }
  }
  (*current) = sub_tree;
  return ((char const   *)((void *)0));
}
}
static char const   *ap_walk_config_sub(ap_directive_t const   *current , cmd_parms *parms ,
                                        ap_conf_vector_t *section_vector ) 
{ module *mod ;
  command_rec const   *cmd ;
  char const   *tmp ;
  void *dir_config ;
  void *tmp___0 ;
  char const   *retval ;
  int tmp___1 ;

  {
  mod = ap_top_module;
  while (1) {
    cmd = ap_find_command_in_modules(current->directive, & mod);
    if (cmd) {
      tmp___0 = ap_set_config_vectors(parms->server, section_vector, (char const   *)parms->path,
                                      mod, parms->pool);
      dir_config = tmp___0;
      if (cmd->req_override & 256) {
        return ((char const   *)((void *)0));
      }
      retval = invoke_cmd(cmd, parms, dir_config, current->args);
      if ((unsigned int )retval == (unsigned int )((void *)0)) {
        return ((char const   *)((void *)0));
      }
      tmp___1 = strcmp(retval, "\a\b");
      if (tmp___1 != 0) {
        if (! parms->err_directive) {
          parms->err_directive = current;
        }
        return (retval);
      }
      mod = mod->next;
    } else {
      parms->err_directive = current;
      tmp = apr_pstrcat(parms->pool, "Invalid command \'", current->directive, "\', perhaps mis-spelled or defined by a module not included in the server configuration",
                        (void *)0);
      return (tmp);
    }
  }
  return ((char const   *)0);
}
}
char const   *ap_walk_config(ap_directive_t *current , cmd_parms *parms , ap_conf_vector_t *section_vector ) 
{ ap_conf_vector_t *oldconfig ;
  char const   *errmsg ;

  {
  oldconfig = parms->context;
  parms->context = section_vector;
  while ((unsigned int )current != (unsigned int )((void *)0)) {
    parms->directive = current;
    errmsg = ap_walk_config_sub((ap_directive_t const   *)current, parms, section_vector);
    if ((unsigned int )errmsg != (unsigned int )((void *)0)) {
      parms->context = oldconfig;
      return (errmsg);
    }
    current = current->next;
  }
  parms->context = oldconfig;
  return ((char const   *)((void *)0));
}
}
char const   *ap_build_config(cmd_parms *parms , apr_pool_t *p , apr_pool_t *temp_pool ,
                              ap_directive_t **conftree ) 
{ ap_directive_t *current ;
  ap_directive_t *curr_parent ;
  char l[8192] ;
  char const   *errmsg ;
  int tmp ;
  char const   *tmp___0 ;

  {
  current = (*conftree);
  curr_parent = (ap_directive_t *)((void *)0);
  if ((unsigned int )current != (unsigned int )((void *)0)) {
    while (current->next) {
      current = current->next;
    }
  }
  while (1) {
    tmp = ap_cfg_getline(l, 8192U, parms->config_file);
    if (tmp) {
      break;
    }
    errmsg = ap_build_config_sub(p, temp_pool, (char const   *)(l), parms, & current,
                                 & curr_parent, conftree);
    if ((unsigned int )errmsg != (unsigned int )((void *)0)) {
      return (errmsg);
    }
    if ((unsigned int )(*conftree) == (unsigned int )((void *)0)) {
      if ((unsigned int )curr_parent != (unsigned int )((void *)0)) {
        (*conftree) = curr_parent;
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    if ((unsigned int )(*conftree) == (unsigned int )((void *)0)) {
      if ((unsigned int )current != (unsigned int )((void *)0)) {
        (*conftree) = current;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
  }
  if ((unsigned int )curr_parent != (unsigned int )((void *)0)) {
    errmsg = "";
    while ((unsigned int )curr_parent != (unsigned int )((void *)0)) {
      if ((int const   )(*errmsg) == 0) {
        tmp___0 = "";
      } else {
        tmp___0 = "\n";
      }
      errmsg = apr_psprintf(p, "%s%s%s:%u: %s> was not closed.", errmsg, tmp___0,
                            curr_parent->filename, curr_parent->line_num, curr_parent->directive);
      curr_parent = curr_parent->parent;
    }
    return (errmsg);
  }
  return ((char const   *)((void *)0));
}
}
char const   *ap_set_string_slot(cmd_parms *cmd , void *struct_ptr , char const   *arg ) 
{ int offset ;

  {
  offset = (int )((long )cmd->info);
  (*((char const   **)((char *)struct_ptr + offset))) = arg;
  return ((char const   *)((void *)0));
}
}
char const   *ap_set_int_slot(cmd_parms *cmd , void *struct_ptr , char const   *arg ) 
{ char *endptr ;
  char *error_str ;
  int offset ;

  {
  error_str = (char *)((void *)0);
  offset = (int )((long )cmd->info);
  (*((int *)((char *)struct_ptr + offset))) = (int )strtol((char const   * __restrict  )arg,
                                                           (char ** __restrict  )(& endptr),
                                                           10);
  if ((int const   )(*arg) == 0) {
    goto _L;
  } else {
    if ((int )(*endptr) != 0) {
      _L: 
      error_str = apr_psprintf(cmd->pool, "Invalid value for directive %s, expected integer",
                               (cmd->directive)->directive);
    }
  }
  return ((char const   *)error_str);
}
}
char const   *ap_set_string_slot_lower(cmd_parms *cmd , void *struct_ptr , char const   *arg_ ) 
{ char *arg ;
  char *tmp ;
  int offset ;

  {
  tmp = apr_pstrdup(cmd->pool, arg_);
  arg = tmp;
  offset = (int )((long )cmd->info);
  ap_str_tolower(arg);
  (*((char **)((char *)struct_ptr + offset))) = arg;
  return ((char const   *)((void *)0));
}
}
char const   *ap_set_flag_slot(cmd_parms *cmd , void *struct_ptr_v , int arg ) 
{ int offset ;
  char *struct_ptr ;

  {
  offset = (int )((long )cmd->info);
  struct_ptr = (char *)struct_ptr_v;
  if (arg) {
    (*((int *)(struct_ptr + offset))) = 1;
  } else {
    (*((int *)(struct_ptr + offset))) = 0;
  }
  return ((char const   *)((void *)0));
}
}
char const   *ap_set_file_slot(cmd_parms *cmd , void *struct_ptr , char const   *arg ) 
{ char const   *path ;
  int offset ;
  char const   *tmp ;

  {
  offset = (int )((long )cmd->info);
  path = ap_server_root_relative(cmd->pool, arg);
  if (! path) {
    tmp = apr_pstrcat(cmd->pool, "Invalid file path ", arg, (void *)0);
    return (tmp);
  }
  (*((char const   **)((char *)struct_ptr + offset))) = path;
  return ((char const   *)((void *)0));
}
}
char const   *ap_set_deprecated(cmd_parms *cmd , void *struct_ptr , char const   *arg ) 
{ 

  {
  return ((cmd->cmd)->errmsg);
}
}
static struct cmd_parms_struct default_parms  = 
     {(void *)0, 0, -1LL, (apr_array_header_t *)((void *)0), (ap_method_list_t *)((void *)0),
    (ap_configfile_t *)((void *)0), (ap_directive_t *)((void *)0), (apr_pool_t *)((void *)0),
    (apr_pool_t *)((void *)0), (server_rec *)((void *)0), (char *)((void *)0), (command_rec const   *)((void *)0),
    (struct ap_conf_vector_t *)0, (ap_directive_t const   *)0};
char *ap_server_root_relative(apr_pool_t *p , char const   *file ) 
{ char *newpath ;
  apr_status_t rv ;

  {
  newpath = (char *)((void *)0);
  rv = apr_filepath_merge(& newpath, ap_server_root, file, 32, p);
  if (newpath) {
    if (rv == 0) {
      goto _L___2;
    } else {
      if (rv == 20025) {
        _L___2: 
        goto _L___1;
      } else {
        if (rv == 2) {
          _L___1: 
          goto _L___0;
        } else {
          if (rv == 20) {
            _L___0: 
            return (newpath);
          } else {
            goto _L;
          }
        }
      }
    }
  } else {
    _L: 
    return ((char *)((void *)0));
  }
}
}
char const   *ap_soak_end_container(cmd_parms *cmd , char *directive ) 
{ char l[8192] ;
  char const   *args ;
  char *cmd_name ;
  size_t tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *msg ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
  while (1) {
    tmp___2 = ap_cfg_getline(l, 8192U, cmd->config_file);
    if (tmp___2) {
      break;
    }
    args = ap_resolve_env(cmd->temp_pool, (char const   *)(l));
    cmd_name = ap_getword_conf(cmd->pool, & args);
    if ((int )(*(cmd_name + 0)) == 60) {
      if ((int )(*(cmd_name + 1)) == 47) {
        tmp = strlen((char const   *)cmd_name);
        (*(cmd_name + (tmp - 1U))) = (char )'\000';
        tmp___1 = strcasecmp((char const   *)(cmd_name + 2), (char const   *)(directive +
                                                                              1));
        if (tmp___1 != 0) {
          tmp___0 = apr_pstrcat(cmd->pool, "Expected </", directive + 1, "> but saw ",
                                cmd_name, ">", (void *)0);
          return (tmp___0);
        }
        return ((char const   *)((void *)0));
      } else {
        msg = ap_soak_end_container(cmd, cmd_name);
        if ((unsigned int )msg != (unsigned int )((void *)0)) {
          return (msg);
        }
      }
    }
  }
  tmp___3 = apr_pstrcat(cmd->pool, "Expected </", directive + 1, "> before end of configuration",
                        (void *)0);
  return (tmp___3);
}
}
static char const   *execute_now(char *cmd_line , char const   *args , cmd_parms *parms ,
                                 apr_pool_t *p , apr_pool_t *ptemp , ap_directive_t **sub_tree ,
                                 ap_directive_t *parent ) 
{ module *mod ;
  command_rec const   *cmd ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  mod = ap_top_module;
  cmd = ap_find_command_in_modules((char const   *)cmd_line, & mod);
  if (cmd) {
    tmp___0 = invoke_cmd(cmd, parms, (void *)sub_tree, args);
    return (tmp___0);
  } else {
    tmp = apr_pstrcat(parms->pool, "Invalid command \'", cmd_line, "\', perhaps mis-spelled or defined by a module not included in the server configuration",
                      (void *)0);
    return (tmp);
  }
}
}
static void *arr_elts_getstr(void *buf , size_t bufsiz , void *param ) 
{ arr_elts_param_t *arr_param ;

  {
  arr_param = (arr_elts_param_t *)param;
  arr_param->curr_idx ++;
  if (arr_param->curr_idx > (arr_param->array)->nelts) {
    return ((void *)0);
  }
  apr_cpystrn((char *)buf, (char const   *)(*((char **)(arr_param->array)->elts +
                                              (arr_param->curr_idx - 1))), bufsiz);
  return (buf);
}
}
static int arr_elts_close(void *param ) 
{ arr_elts_param_t *arr_param ;

  {
  arr_param = (arr_elts_param_t *)param;
  arr_param->curr_idx = (arr_param->array)->nelts;
  return (0);
}
}
static void process_command_config(server_rec *s , apr_array_header_t *arr , ap_directive_t **conftree ,
                                   apr_pool_t *p , apr_pool_t *ptemp ) 
{ char const   *errmsg ;
  cmd_parms parms ;
  arr_elts_param_t arr_parms ;

  {
  arr_parms.curr_idx = 0;
  arr_parms.array = arr;
  parms = default_parms;
  parms.pool = p;
  parms.temp_pool = ptemp;
  parms.server = s;
  parms.override = 150;
  parms.config_file = ap_pcfg_open_custom(p, "-c/-C directives", (void *)(& arr_parms),
                                          (int (*)(void * ))((void *)0), & arr_elts_getstr,
                                          & arr_elts_close);
  errmsg = ap_build_config(& parms, p, ptemp, conftree);
  if (errmsg) {
    ap_log_error("config.c", 1422, 32, 0, (server_rec const   *)((void *)0), "Syntax error in -C/-c directive:\n%s",
                 errmsg);
    exit(1);
  }
  ap_cfg_closefile(parms.config_file);
  return;
}
}
static int fname_alphasort(void const   *fn1 , void const   *fn2 ) 
{ fnames const   *f1 ;
  fnames const   *f2 ;
  int tmp ;

  {
  f1 = (fnames const   *)fn1;
  f2 = (fnames const   *)fn2;
  tmp = strcmp((char const   *)f1->fname, (char const   *)f2->fname);
  return (tmp);
}
}
void ap_process_resource_config(server_rec *s , char const   *fname , ap_directive_t **conftree ,
                                apr_pool_t *p , apr_pool_t *ptemp ) 
{ cmd_parms parms ;
  apr_finfo_t finfo ;
  char const   *errmsg ;
  ap_configfile_t *cfp ;
  int ispatt ;
  apr_status_t tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  apr_dir_t *dirp ;
  apr_finfo_t dirent ;
  int current ;
  apr_array_header_t *candidates ;
  fnames *fnew ;
  apr_status_t rv ;
  char errmsg___0[120] ;
  char *path ;
  char *tmp___2 ;
  char *pattern ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___9 ;
  int tmp___10 ;
  apr_status_t tmp___11 ;
  apr_status_t tmp___12 ;
  int tmp___13 ;
  apr_status_t tmp___14 ;

  {
  if (ap_server_pre_read_config->nelts) {
    goto _L___0;
  } else {
    if (ap_server_post_read_config->nelts) {
      _L___0: 
      tmp___0 = ap_server_root_relative(p, "conf/httpd.conf");
      tmp___1 = strcmp(fname, tmp___0);
      if (tmp___1) {
        goto _L;
      } else {
        tmp = apr_lstat(& finfo, fname, 32768, p);
        if (tmp != 0) {
          return;
        }
      }
    } else {
      _L: ;
    }
  }
  ispatt = apr_fnmatch_test(fname);
  if (ispatt) {
    goto _L___4;
  } else {
    tmp___13 = ap_is_rdirectory(p, fname);
    if (tmp___13) {
      _L___4: 
      candidates = (apr_array_header_t *)((void *)0);
      tmp___2 = apr_pstrdup(p, fname);
      path = tmp___2;
      pattern = (char *)((void *)0);
      if (ispatt) {
        pattern = strrchr((char const   *)path, '/');
        tmp___3 = pattern;
        pattern ++;
        (*tmp___3) = (char )'\000';
        tmp___4 = apr_fnmatch_test((char const   *)path);
        if (tmp___4) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: wildcard patterns not allowed in Include %s\n",
                  ap_server_argv0, fname);
          exit(1);
        }
        tmp___5 = ap_is_rdirectory(p, (char const   *)path);
        if (! tmp___5) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Include directory \'%s\' not found",
                  ap_server_argv0, path);
          exit(1);
        }
        tmp___6 = apr_fnmatch_test((char const   *)pattern);
        if (! tmp___6) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: must include a wildcard pattern for Include %s\n",
                  ap_server_argv0, fname);
          exit(1);
        }
      }
      rv = apr_dir_open(& dirp, (char const   *)path, p);
      if (rv != 0) {
        tmp___7 = apr_strerror(rv, errmsg___0, sizeof(errmsg___0));
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: could not open config directory %s: %s\n",
                ap_server_argv0, path, tmp___7);
        exit(1);
      }
      candidates = apr_array_make(p, 1, (int )sizeof(fnames ));
      while (1) {
        tmp___12 = apr_dir_read(& dirent, 33554432, dirp);
        if (! (tmp___12 == 0)) {
          break;
        }
        tmp___9 = strcmp(dirent.name, ".");
        if (tmp___9) {
          tmp___10 = strcmp(dirent.name, "..");
          if (tmp___10) {
            if (! ispatt) {
              goto _L___2;
            } else {
              tmp___11 = apr_fnmatch((char const   *)pattern, dirent.name, 4);
              if (tmp___11 == 0) {
                _L___2: 
                fnew = (fnames *)apr_array_push(candidates);
                fnew->fname = ap_make_full_path(p, (char const   *)path, dirent.name);
              } else {
                goto _L___3;
              }
            }
          } else {
            goto _L___3;
          }
        } else {
          _L___3: ;
        }
      }
      apr_dir_close(dirp);
      if (candidates->nelts != 0) {
        qsort((void *)candidates->elts, (unsigned int )candidates->nelts, sizeof(fnames ),
              & fname_alphasort);
        current = 0;
        while (current < candidates->nelts) {
          fnew = (fnames *)candidates->elts + current;
          ap_process_resource_config(s, (char const   *)fnew->fname, conftree, p,
                                     ptemp);
          current ++;
        }
      }
      return;
    }
  }
  parms = default_parms;
  parms.pool = p;
  parms.temp_pool = ptemp;
  parms.server = s;
  parms.override = 150;
  tmp___14 = ap_pcfg_openfile(& cfp, p, fname);
  if (tmp___14 != 0) {
    ap_log_error("config.c", 1555, 32, 0, (server_rec const   *)((void *)0), "%s: could not open document config file %s",
                 ap_server_argv0, fname);
    exit(1);
  }
  parms.config_file = cfp;
  errmsg = ap_build_config(& parms, p, ptemp, conftree);
  if ((unsigned int )errmsg != (unsigned int )((void *)0)) {
    ap_log_error("config.c", 1566, 32, 0, (server_rec const   *)((void *)0), "Syntax error on line %d of %s:",
                 (parms.err_directive)->line_num, (parms.err_directive)->filename);
    ap_log_error("config.c", 1570, 32, 0, (server_rec const   *)((void *)0), "%s",
                 errmsg);
    exit(1);
  }
  ap_cfg_closefile(cfp);
  return;
}
}
void ap_process_config_tree(server_rec *s , ap_directive_t *conftree , apr_pool_t *p ,
                            apr_pool_t *ptemp ) 
{ char const   *errmsg ;
  cmd_parms parms ;

  {
  parms = default_parms;
  parms.pool = p;
  parms.temp_pool = ptemp;
  parms.server = s;
  parms.override = 150;
  parms.limited = -1LL;
  errmsg = ap_walk_config(conftree, & parms, s->lookup_defaults);
  if (errmsg) {
    ap_log_perror("config.c", 1594, 32, 0, p, "Syntax error on line %d of %s:", (parms.err_directive)->line_num,
                  (parms.err_directive)->filename);
    ap_log_perror("config.c", 1598, 32, 0, p, "%s", errmsg);
    exit(1);
  }
  return;
}
}
int ap_parse_htaccess(ap_conf_vector_t **result , request_rec *r , int override ,
                      char const   *d , char const   *access_name ) 
{ ap_configfile_t *f ;
  cmd_parms parms ;
  char *filename ;
  struct htaccess_result  const  *cache ;
  struct htaccess_result *new ;
  ap_conf_vector_t *dc ;
  apr_status_t status ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *errmsg ;
  ap_directive_t *temptree ;

  {
  f = (ap_configfile_t *)((void *)0);
  filename = (char *)((void *)0);
  dc = (ap_conf_vector_t *)((void *)0);
  cache = r->htaccess;
  while ((unsigned int )cache != (unsigned int )((void *)0)) {
    if (cache->override == override) {
      tmp = strcmp(cache->dir, d);
      if (tmp == 0) {
        (*result) = cache->htaccess;
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    cache = cache->next;
  }
  parms = default_parms;
  parms.override = override;
  parms.pool = r->pool;
  parms.temp_pool = r->pool;
  parms.server = r->server;
  parms.path = apr_pstrdup(r->pool, d);
  while ((*(access_name + 0))) {
    tmp___0 = ap_getword_conf(r->pool, & access_name);
    filename = ap_make_full_path(r->pool, d, tmp___0);
    status = ap_pcfg_openfile(& f, r->pool, (char const   *)filename);
    if (status == 0) {
      temptree = (ap_directive_t *)((void *)0);
      dc = ap_create_per_dir_config(r->pool);
      parms.config_file = f;
      errmsg = ap_build_config(& parms, r->pool, r->pool, & temptree);
      if ((unsigned int )errmsg == (unsigned int )((void *)0)) {
        errmsg = ap_walk_config(temptree, & parms, dc);
      }
      ap_cfg_closefile(f);
      if (errmsg) {
        ap_log_rerror("config.c", 1655, 1, 0, (request_rec const   *)r, "%s: %s",
                      filename, errmsg);
        return (500);
      }
      (*result) = dc;
      break;
    } else {
      if (! (status == 2)) {
        if (! (status == 20)) {
          ap_log_rerror("config.c", 1666, 2, status, (request_rec const   *)r, "%s pcfg_openfile: unable to check htaccess file, ensure it is readable",
                        filename);
          apr_table_setn(r->notes, "error-notes", "Server unable to read htaccess file, denying access to be safe");
          return (403);
        } else {
          goto _L___0;
        }
      } else {
        _L___0: ;
      }
    }
  }
  new = (struct htaccess_result *)apr_palloc(r->pool, sizeof(struct htaccess_result ));
  new->dir = (char const   *)parms.path;
  new->override = override;
  new->htaccess = dc;
  new->next = r->htaccess;
  r->htaccess = (struct htaccess_result  const  *)new;
  return (0);
}
}
char const   *ap_init_virtual_host(apr_pool_t *p , char const   *hostname , server_rec *main_server ,
                                   server_rec **ps ) 
{ server_rec *s ;
  void *tmp ;
  server_rec *tmp___0 ;
  char const   *tmp___1 ;

  {
  tmp = apr_palloc(p, sizeof(server_rec ));
  tmp___0 = (server_rec *)memset(tmp, 0, sizeof(server_rec ));
  s = tmp___0;
  s->process = main_server->process;
  s->server_admin = (char *)((void *)0);
  s->server_hostname = (char *)((void *)0);
  s->error_fname = (char *)((void *)0);
  s->timeout = 0LL;
  s->keep_alive_timeout = 0LL;
  s->keep_alive = -1;
  s->keep_alive_max = -1;
  s->error_log = main_server->error_log;
  s->loglevel = main_server->loglevel;
  s->port = main_server->port;
  s->next = (server_rec *)((void *)0);
  s->is_virtual = 1;
  s->names = apr_array_make(p, 4, (int )sizeof(char **));
  s->wild_names = apr_array_make(p, 4, (int )sizeof(char **));
  s->module_config = create_empty_config(p);
  s->lookup_defaults = ap_create_per_dir_config(p);
  s->limit_req_line = main_server->limit_req_line;
  s->limit_req_fieldsize = main_server->limit_req_fieldsize;
  s->limit_req_fields = main_server->limit_req_fields;
  (*ps) = s;
  tmp___1 = ap_parse_vhost_addrs(p, hostname, s);
  return (tmp___1);
}
}
void ap_fixup_virtual_hosts(apr_pool_t *p , server_rec *main_server ) 
{ server_rec *virt ;

  {
  virt = main_server->next;
  while (virt) {
    merge_server_configs(p, main_server->module_config, virt->module_config);
    virt->lookup_defaults = ap_merge_per_dir_configs(p, main_server->lookup_defaults,
                                                     virt->lookup_defaults);
    if ((unsigned int )virt->server_admin == (unsigned int )((void *)0)) {
      virt->server_admin = main_server->server_admin;
    }
    if (virt->timeout == 0LL) {
      virt->timeout = main_server->timeout;
    }
    if (virt->keep_alive_timeout == 0LL) {
      virt->keep_alive_timeout = main_server->keep_alive_timeout;
    }
    if (virt->keep_alive == -1) {
      virt->keep_alive = main_server->keep_alive;
    }
    if (virt->keep_alive_max == -1) {
      virt->keep_alive_max = main_server->keep_alive_max;
    }
    ap_core_reorder_directories(p, virt);
    virt = virt->next;
  }
  ap_core_reorder_directories(p, main_server);
  return;
}
}
static void init_config_globals(apr_pool_t *p ) 
{ 

  {
  ap_init_vhost_config(p);
  return;
}
}
static server_rec *init_server_config(process_rec *process , apr_pool_t *p ) 
{ apr_status_t rv ;
  server_rec *s ;
  void *tmp ;
  server_rec *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = apr_palloc(p, sizeof(server_rec ));
  tmp___0 = (server_rec *)memset(tmp, 0, sizeof(server_rec ));
  s = tmp___0;
  apr_file_open_stderr(& s->error_log, p);
  s->process = process;
  s->port = (unsigned short)0;
  s->server_admin = (char *)"[no address given]";
  s->server_hostname = (char *)((void *)0);
  s->error_fname = (char *)"logs/error_log";
  s->loglevel = 4;
  s->limit_req_line = 8190;
  s->limit_req_fieldsize = 8190;
  s->limit_req_fields = 100;
  s->timeout = 300000000LL;
  s->keep_alive_timeout = 15000000LL;
  s->keep_alive_max = 100;
  s->keep_alive = 1;
  s->next = (server_rec *)((void *)0);
  tmp___1 = apr_palloc(p, sizeof(server_addr_rec ));
  s->addrs = (server_addr_rec *)memset(tmp___1, 0, sizeof(server_addr_rec ));
  rv = apr_sockaddr_info_get(& (s->addrs)->host_addr, (char const   *)((void *)0),
                             2, (unsigned short)0, 0, p);
  if (! (rv == 0)) {
    ap_log_assert("rv == APR_SUCCESS", "config.c", 1802);
  }
  (s->addrs)->host_port = (unsigned short)0;
  (s->addrs)->virthost = (char *)"";
  s->wild_names = (apr_array_header_t *)((void *)0);
  s->names = s->wild_names;
  s->module_config = create_server_config(p, s);
  s->lookup_defaults = create_default_per_dir_config(p);
  return (s);
}
}
server_rec *ap_read_config(process_rec *process , apr_pool_t *ptemp , char const   *filename ,
                           ap_directive_t **conftree ) 
{ char const   *confname ;
  apr_pool_t *p ;
  server_rec *s ;
  server_rec *tmp ;

  {
  p = process->pconf;
  tmp = init_server_config(process, p);
  s = tmp;
  init_config_globals(p);
  process_command_config(s, ap_server_pre_read_config, conftree, p, ptemp);
  confname = ap_server_root_relative(p, filename);
  if (! confname) {
    ap_log_error("config.c", 1835, 34, 20024, (server_rec const   *)((void *)0), "Invalid config file path %s",
                 filename);
    exit(1);
  }
  ap_process_resource_config(s, confname, conftree, p, ptemp);
  process_command_config(s, ap_server_post_read_config, conftree, p, ptemp);
  return (s);
}
}
void ap_single_module_configure(apr_pool_t *p , server_rec *s , module *m ) 
{ 

  {
  if (m->create_server_config) {
    (*((void **)s->module_config + m->module_index)) = ((*(m->create_server_config)))(p,
                                                                                      s);
  }
  if (m->create_dir_config) {
    (*((void **)s->lookup_defaults + m->module_index)) = ((*(m->create_dir_config)))(p,
                                                                                     (char *)((void *)0));
  }
  return;
}
}
void ap_run_rewrite_args(process_rec *process ) 
{ module *m ;

  {
  m = ap_top_module;
  while (m) {
    if (m->rewrite_args) {
      ((*(m->rewrite_args)))(process);
    }
    m = m->next;
  }
  return;
}
}
static void show_overrides(command_rec const   *pc , module *pm ) 
{ int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  n = 0;
  printf((char const   * __restrict  )"\tAllowed in *.conf ");
  if (pc->req_override & 22) {
    goto _L;
  } else {
    if (pc->req_override & 128) {
      if (pc->req_override & 73) {
        _L: 
        printf((char const   * __restrict  )"anywhere");
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if (pc->req_override & 128) {
        printf((char const   * __restrict  )"only outside <Directory>, <Files> or <Location>");
      } else {
        printf((char const   * __restrict  )"only inside <Directory>, <Files> or <Location>");
      }
    }
  }
  if (pc->req_override & 95) {
    if (! pm->create_dir_config) {
      printf((char const   * __restrict  )" [no per-dir config]");
    } else {
      goto _L___1;
    }
  } else {
    _L___1: ;
  }
  if (pc->req_override & 31) {
    printf((char const   * __restrict  )" and in .htaccess\n\twhen AllowOverride");
    if ((pc->req_override & 31) == 31) {
      printf((char const   * __restrict  )" isn\'t None");
    } else {
      printf((char const   * __restrict  )" includes ");
      if (pc->req_override & 8) {
        tmp = n;
        n ++;
        if (tmp) {
          printf((char const   * __restrict  )" or ");
        }
        printf((char const   * __restrict  )"AuthConfig");
      }
      if (pc->req_override & 1) {
        tmp___0 = n;
        n ++;
        if (tmp___0) {
          printf((char const   * __restrict  )" or ");
        }
        printf((char const   * __restrict  )"Limit");
      }
      if (pc->req_override & 2) {
        tmp___1 = n;
        n ++;
        if (tmp___1) {
          printf((char const   * __restrict  )" or ");
        }
        printf((char const   * __restrict  )"Options");
      }
      if (pc->req_override & 4) {
        tmp___2 = n;
        n ++;
        if (tmp___2) {
          printf((char const   * __restrict  )" or ");
        }
        printf((char const   * __restrict  )"FileInfo");
      }
      if (pc->req_override & 16) {
        tmp___3 = n;
        n ++;
        if (tmp___3) {
          printf((char const   * __restrict  )" or ");
        }
        printf((char const   * __restrict  )"Indexes");
      }
    }
  }
  printf((char const   * __restrict  )"\n");
  return;
}
}
void ap_show_directives(void) 
{ command_rec const   *pc ;
  int n ;

  {
  n = 0;
  while ((*(ap_loaded_modules + n))) {
    pc = ((*(ap_loaded_modules + n)))->cmds;
    while (1) {
      if (pc) {
        if (! pc->name) {
          goto _L;
        }
      } else {
        _L: 
        break;
      }
      printf((char const   * __restrict  )"%s (%s)\n", pc->name, ((*(ap_loaded_modules +
                                                                     n)))->name);
      if (pc->errmsg) {
        printf((char const   * __restrict  )"\t%s\n", pc->errmsg);
      }
      show_overrides(pc, (*(ap_loaded_modules + n)));
      pc ++;
    }
    n ++;
  }
  return;
}
}
void ap_show_modules(void) 
{ int n ;

  {
  printf((char const   * __restrict  )"Compiled in modules:\n");
  n = 0;
  while ((*(ap_loaded_modules + n))) {
    printf((char const   * __restrict  )"  %s\n", ((*(ap_loaded_modules + n)))->name);
    n ++;
  }
  return;
}
}
char const   *ap_show_mpm(void) 
{ 

  {
  return ("Prefork");
}
}
#pragma merger(0,"/tmp/cil-x2UXrSeq.i","-g -pthread")
void apr_pool_cleanup_kill(apr_pool_t *p , void const   *data , apr_status_t (*cleanup_fn)(void * ) ) ;
apr_status_t apr_pool_cleanup_run(apr_pool_t *p , void *data , apr_status_t (*cleanup_fn)(void * ) ) ;
char *apr_pvsprintf(apr_pool_t *pool , char const   *fmt , va_list ap ) ;
apr_status_t apr_tokenize_to_argv(char const   *arg_str , char ***argv_out , apr_pool_t *token_context ) ;
int apr_vsnprintf(char *buf , apr_size_t len , char const   *format , va_list ap ) ;
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
apr_status_t apr_file_read_full(apr_file_t *thefile , void *buf , apr_size_t nbytes ,
                                apr_size_t *bytes_read ) ;
apr_status_t apr_file_dup2(apr_file_t *new_file , apr_file_t *old_file , apr_pool_t *p ) ;
apr_status_t apr_file_pipe_create(apr_file_t **in , apr_file_t **out , apr_pool_t *pool ) ;
apr_status_t apr_procattr_child_in_set(struct apr_procattr_t *attr , apr_file_t *child_in ,
                                       apr_file_t *parent_in ) ;
apr_status_t apr_proc_create(apr_proc_t *new , char const   *progname , char const   * const  *args ,
                             char const   * const  *env , apr_procattr_t *attr , apr_pool_t *pool ) ;
void apr_proc_other_child_register(apr_proc_t *pid , void (*maintenance)(int reason ,
                                                                         void * ,
                                                                         int status ) ,
                                   void *data , apr_file_t *write_fd , apr_pool_t *p ) ;
void apr_proc_other_child_unregister(void *data ) ;
apr_status_t apr_proc_kill(apr_proc_t *proc , int signum ) ;
extern  __attribute__((__noreturn__)) void abort(void) ;
extern void openlog(char const   *__ident , int __option , int __facility ) ;
extern void syslog(int __pri , char const   *__fmt  , ...) ;
int ap_default_loglevel ;
void ap_open_stderr_log(apr_pool_t *p ) ;
apr_status_t ap_replace_stderr_log(apr_pool_t *p , char const   *fname ) ;
int ap_open_logs(apr_pool_t *pconf___0 , apr_pool_t *p , apr_pool_t *ptemp , server_rec *s_main ) ;
void ap_error_log2stderr(server_rec *s ) ;
apr_status_t ap_read_pid(apr_pool_t *p , char const   *filename , pid_t *mypid ) ;
void ap_close_piped_log(piped_log *pl ) ;
void ap_hook_error_log(ap_HOOK_error_log_t *pf , char const   * const  *aszPre___1 ,
                       char const   * const  *aszSucc___2 , int nOrder ) ;
void ap_run_error_log(char const   *file , int line , int level , apr_status_t status ,
                      server_rec const   *s , request_rec const   *r , apr_pool_t *pool ,
                      char const   *errstr ) ;
apr_array_header_t *ap_hook_get_error_log(void) ;
apr_status_t ap_recent_ctime(char *date_str , apr_time_t t ) ;
static struct __anonstruct__hooks_88 _hooks___0  ;
int ap_default_loglevel  =    4;
static TRANS const   facilities[21]  = 
  {      {(char *)"auth", 32}, 
        {(char *)"authpriv", 80}, 
        {(char *)"cron", 72}, 
        {(char *)"daemon", 24}, 
        {(char *)"ftp", 88}, 
        {(char *)"kern", 0}, 
        {(char *)"lpr", 48}, 
        {(char *)"mail", 16}, 
        {(char *)"news", 56}, 
        {(char *)"syslog", 40}, 
        {(char *)"user", 8}, 
        {(char *)"uucp", 64}, 
        {(char *)"local0", 128}, 
        {(char *)"local1", 136}, 
        {(char *)"local2", 144}, 
        {(char *)"local3", 152}, 
        {(char *)"local4", 160}, 
        {(char *)"local5", 168}, 
        {(char *)"local6", 176}, 
        {(char *)"local7", 184}, 
        {(char *)((void *)0), -1}};
static TRANS const   priorities[9]  = 
  {      {(char *)"emerg", 0}, 
        {(char *)"alert", 1}, 
        {(char *)"crit", 2}, 
        {(char *)"error", 3}, 
        {(char *)"warn", 4}, 
        {(char *)"notice", 5}, 
        {(char *)"info", 6}, 
        {(char *)"debug", 7}, 
        {(char *)((void *)0), -1}};
static apr_file_t *stderr_log  =    (apr_file_t *)((void *)0);
void ap_open_stderr_log(apr_pool_t *p ) 
{ 

  {
  apr_file_open_stderr(& stderr_log, p);
  return;
}
}
apr_status_t ap_replace_stderr_log(apr_pool_t *p , char const   *fname ) 
{ apr_file_t *stderr_file ;
  apr_status_t rc ;
  char *filename ;
  char *tmp ;

  {
  tmp = ap_server_root_relative(p, fname);
  filename = tmp;
  if (! filename) {
    ap_log_error("log.c", 197, 34, 20024, (server_rec const   *)((void *)0), "Invalid -E error log file %s",
                 fname);
    return (20024);
  }
  rc = apr_file_open(& stderr_file, (char const   *)filename, 15, 4095, p);
  if (rc != 0) {
    ap_log_error("log.c", 205, 32, rc, (server_rec const   *)((void *)0), "%s: could not open error log file %s.",
                 ap_server_argv0, fname);
    return (rc);
  }
  rc = apr_file_open_stderr(& stderr_log, p);
  if (rc == 0) {
    apr_file_flush(stderr_log);
    rc = apr_file_dup2(stderr_log, stderr_file, p);
    if (rc == 0) {
      apr_file_close(stderr_file);
    }
  }
  if (rc != 0) {
    ap_log_error("log.c", 217, 2, rc, (server_rec const   *)((void *)0), "unable to replace stderr with error_log");
  }
  return (rc);
}
}
static int log_child(apr_pool_t *p , char const   *progname , apr_file_t **fpin ) 
{ apr_status_t rc ;
  apr_procattr_t *procattr ;
  apr_proc_t *procnew ;
  char **args ;
  char const   *pname ;
  void *tmp ;

  {
  rc = apr_procattr_create(& procattr, p);
  if (rc == 0) {
    rc = apr_procattr_io_set(procattr, 1, 0, 0);
    if (rc == 0) {
      apr_tokenize_to_argv(progname, & args, p);
      pname = apr_pstrdup(p, (char const   *)(*(args + 0)));
      tmp = apr_palloc(p, sizeof((*procnew)));
      procnew = (apr_proc_t *)memset(tmp, 0, sizeof((*procnew)));
      rc = apr_proc_create(procnew, pname, (char const   * const  *)args, (char const   * const  *)((void *)0),
                           procattr, p);
      if (rc == 0) {
        apr_pool_note_subprocess(p, procnew, (enum __anonenum_apr_kill_conditions_e_55 )2);
        (*fpin) = procnew->in;
      }
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  return (rc);
}
}
static int open_error_log(server_rec *s , apr_pool_t *p ) 
{ char const   *fname ;
  int rc ;
  apr_file_t *dummy ;
  TRANS const   *fac ;
  int tmp ;
  int tmp___0 ;

  {
  if ((int )(*(s->error_fname)) == 124) {
    dummy = (apr_file_t *)((void *)0);
    rc = log_child(p, (char const   *)(s->error_fname + 1), & dummy);
    if (rc != 0) {
      ap_log_error("log.c", 268, 32, rc, (server_rec const   *)((void *)0), "Couldn\'t start ErrorLog process");
      return (-2);
    }
    s->error_log = dummy;
  } else {
    tmp___0 = strncasecmp((char const   *)s->error_fname, "syslog", 6U);
    if (tmp___0) {
      fname = ap_server_root_relative(p, (char const   *)s->error_fname);
      if (! fname) {
        ap_log_error("log.c", 301, 32, 20024, (server_rec const   *)((void *)0), "%s: Invalid error log path %s.",
                     ap_server_argv0, s->error_fname);
        return (-2);
      }
      rc = apr_file_open(& s->error_log, fname, 15, 4095, p);
      if (rc != 0) {
        ap_log_error("log.c", 309, 32, rc, (server_rec const   *)((void *)0), "%s: could not open error log file %s.",
                     ap_server_argv0, fname);
        return (-2);
      }
      apr_file_inherit_set(s->error_log);
    } else {
      fname = strchr((char const   *)s->error_fname, ':');
      if (fname) {
        fname ++;
        fac = facilities;
        while (fac->t_name) {
          tmp = strcasecmp(fname, (char const   *)fac->t_name);
          if (! tmp) {
            openlog(ap_server_argv0, 11, fac->t_val);
            s->error_log = (apr_file_t *)((void *)0);
            return (0);
          }
          fac ++;
        }
      } else {
        openlog(ap_server_argv0, 11, 184);
      }
      s->error_log = (apr_file_t *)((void *)0);
    }
  }
  return (0);
}
}
int ap_open_logs(apr_pool_t *pconf___0 , apr_pool_t *p , apr_pool_t *ptemp , server_rec *s_main ) 
{ apr_status_t rc ;
  server_rec *virt ;
  server_rec *q ;
  int replace_stderr ;
  apr_file_t *errfile ;
  int tmp ;
  int *tmp___0 ;
  FILE *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  rc = 0;
  errfile = (apr_file_t *)((void *)0);
  tmp = open_error_log(s_main, p);
  if (tmp != 0) {
    return (-2);
  }
  replace_stderr = 1;
  if (s_main->error_log) {
    apr_file_flush(s_main->error_log);
    rc = apr_file_open_stderr(& errfile, p);
    if (rc == 0) {
      rc = apr_file_dup2(errfile, s_main->error_log, p);
    }
    if (rc != 0) {
      ap_log_error("log.c", 341, 2, rc, (server_rec const   *)s_main, "unable to replace stderr with error_log");
    } else {
      replace_stderr = 0;
    }
  }
  if (replace_stderr) {
    tmp___1 = freopen((char const   * __restrict  )"/dev/null", (char const   * __restrict  )"w",
                      (FILE * __restrict  )stderr);
    if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
      tmp___0 = __errno_location();
      ap_log_error("log.c", 354, 2, (*tmp___0), (server_rec const   *)s_main, "unable to replace stderr with /dev/null");
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  virt = s_main->next;
  while (virt) {
    if (virt->error_fname) {
      q = s_main;
      while ((unsigned int )q != (unsigned int )virt) {
        if ((unsigned int )q->error_fname != (unsigned int )((void *)0)) {
          tmp___2 = strcmp((char const   *)q->error_fname, (char const   *)virt->error_fname);
          if (tmp___2 == 0) {
            break;
          } else {
            goto _L___0;
          }
        } else {
          _L___0: ;
        }
        q = q->next;
      }
      if ((unsigned int )q == (unsigned int )virt) {
        tmp___3 = open_error_log(virt, p);
        if (tmp___3 != 0) {
          return (-2);
        }
      } else {
        virt->error_log = q->error_log;
      }
    } else {
      virt->error_log = s_main->error_log;
    }
    virt = virt->next;
  }
  return (0);
}
}
void ap_error_log2stderr(server_rec *s ) 
{ apr_file_t *errfile ;

  {
  errfile = (apr_file_t *)((void *)0);
  apr_file_open_stderr(& errfile, (s->process)->pool);
  if ((unsigned int )s->error_log != (unsigned int )((void *)0)) {
    apr_file_dup2(s->error_log, errfile, (s->process)->pool);
  }
  return;
}
}
static void log_error_core(char const   *file , int line , int level , apr_status_t status ,
                           server_rec const   *s , request_rec const   *r , apr_pool_t *pool ,
                           char const   *fmt , va_list args ) 
{ char errstr[8192] ;
  apr_size_t len ;
  apr_size_t errstrlen ;
  apr_file_t *logf ;
  char const   *referer ;
  int level_and_mask ;
  apr_time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  apr_size_t tmp___8 ;
  apr_size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  logf = (apr_file_t *)((void *)0);
  level_and_mask = level & 7;
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    if (level_and_mask != 5) {
      if (level_and_mask > ap_default_loglevel) {
        return;
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    logf = stderr_log;
  } else {
    if (s->error_log) {
      if (level_and_mask != 5) {
        if (level_and_mask > s->loglevel) {
          return;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: ;
      }
      logf = s->error_log;
    } else {
      if (level_and_mask > s->loglevel) {
        return;
      }
    }
  }
  if (logf) {
    if ((level & 32) != 32) {
      errstr[0] = (char )'[';
      tmp = apr_time_now();
      ap_recent_ctime(errstr + 1, tmp);
      errstr[25] = (char )']';
      errstr[26] = (char )' ';
      len = 27U;
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    len = 0U;
  }
  if ((level & 32) != 32) {
    tmp___0 = apr_snprintf(errstr + len, 8192U - len, "[%s] ", priorities[level_and_mask].t_name);
    len += (unsigned int )tmp___0;
  }
  if (file) {
    if (level_and_mask == 7) {
      tmp___1 = apr_snprintf(errstr + len, 8192U - len, "%s(%d): ", file, line);
      len += (unsigned int )tmp___1;
    } else {
      goto _L___2;
    }
  } else {
    _L___2: ;
  }
  if (r) {
    if (r->connection) {
      tmp___2 = apr_snprintf(errstr + len, 8192U - len, "[client %s] ", (r->connection)->remote_ip);
      len += (unsigned int )tmp___2;
    } else {
      goto _L___3;
    }
  } else {
    _L___3: ;
  }
  if (status != 0) {
    if (status < 670000) {
      tmp___3 = apr_snprintf(errstr + len, 8192U - len, "(%d)", status);
      len += (unsigned int )tmp___3;
    } else {
      if (status < 720000) {
        tmp___4 = apr_snprintf(errstr + len, 8192U - len, "(EAI %d)", status - 670000);
        len += (unsigned int )tmp___4;
      } else {
        if (status < 820000) {
          tmp___5 = apr_snprintf(errstr + len, 8192U - len, "(OS %d)", status - 720000);
          len += (unsigned int )tmp___5;
        } else {
          tmp___6 = apr_snprintf(errstr + len, 8192U - len, "(os 0x%08x)", status -
                                                                           720000);
          len += (unsigned int )tmp___6;
        }
      }
    }
    apr_strerror(status, errstr + len, 8192U - len);
    tmp___7 = strlen((char const   *)(errstr + len));
    len += tmp___7;
    if (8192U - len > 2U) {
      tmp___8 = len;
      len ++;
      errstr[tmp___8] = (char )':';
      tmp___9 = len;
      len ++;
      errstr[tmp___9] = (char )' ';
      errstr[len] = (char )'\000';
    }
  }
  errstrlen = len;
  tmp___10 = apr_vsnprintf(errstr + len, 8192U - len, fmt, args);
  len += (unsigned int )tmp___10;
  if (r) {
    referer = apr_table_get((apr_table_t const   *)r->headers_in, "Referer");
    if (referer) {
      tmp___11 = apr_snprintf(errstr + len, 8192U - len, ", referer: %s", referer);
      len += (unsigned int )tmp___11;
    } else {
      goto _L___4;
    }
  } else {
    _L___4: ;
  }
  if (logf) {
    if (len > 8192U - sizeof("\n")) {
      len = 8192U - sizeof("\n");
    }
    strcpy((char * __restrict  )(errstr + len), (char const   * __restrict  )"\n");
    apr_file_puts((char const   *)(errstr), logf);
    apr_file_flush(logf);
  } else {
    syslog(level_and_mask, "%s", errstr);
  }
  ap_run_error_log(file, line, level, status, s, r, pool, (char const   *)(errstr +
                                                                           errstrlen));
  return;
}
}
void ( /* format attribute */  ap_log_error)(char const   *file , int line , int level ,
                                             apr_status_t status , server_rec const   *s ,
                                             char const   *fmt  , ...) 
{ va_list args ;

  {
  __builtin_stdarg_start(args, fmt);
  log_error_core(file, line, level, status, s, (request_rec const   *)((void *)0),
                 (apr_pool_t *)((void *)0), fmt, args);
  __builtin_va_end(args);
  return;
}
}
void ( /* format attribute */  ap_log_perror)(char const   *file , int line , int level ,
                                              apr_status_t status , apr_pool_t *p ,
                                              char const   *fmt  , ...) 
{ va_list args ;

  {
  __builtin_stdarg_start(args, fmt);
  log_error_core(file, line, level, status, (server_rec const   *)((void *)0), (request_rec const   *)((void *)0),
                 p, fmt, args);
  __builtin_va_end(args);
  return;
}
}
void ( /* format attribute */  ap_log_rerror)(char const   *file , int line , int level ,
                                              apr_status_t status , request_rec const   *r ,
                                              char const   *fmt  , ...) 
{ va_list args ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  __builtin_stdarg_start(args, fmt);
  log_error_core(file, line, level, status, (server_rec const   *)r->server, r, (apr_pool_t *)((void *)0),
                 fmt, args);
  __builtin_va_end(args);
  __builtin_stdarg_start(args, fmt);
  if (level & 16) {
    if ((level & 7) <= 4) {
      tmp___1 = apr_table_get((apr_table_t const   *)r->notes, "error-notes");
      if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
        tmp = apr_pvsprintf(r->pool, fmt, args);
        tmp___0 = ap_escape_html(r->pool, tmp);
        apr_table_setn(r->notes, "error-notes", tmp___0);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
  }
  __builtin_va_end(args);
  return;
}
}
static int saved_pid  =    -1;
void ap_log_pid(apr_pool_t *p , char const   *filename ) 
{ apr_file_t *pid_file ;
  apr_finfo_t finfo ;
  pid_t mypid ;
  apr_status_t rv ;
  char const   *fname ;
  char const   *tmp ;
  apr_status_t tmp___0 ;

  {
  pid_file = (apr_file_t *)((void *)0);
  if (! filename) {
    return;
  }
  fname = ap_server_root_relative(p, filename);
  if (! fname) {
    ap_log_error("log.c", 619, 34, 20024, (server_rec const   *)((void *)0), "Invalid PID file path %s, ignoring.",
                 filename);
    return;
  }
  mypid = getpid();
  if (mypid != saved_pid) {
    tmp___0 = apr_stat(& finfo, fname, 16, p);
    if (tmp___0 == 0) {
      tmp = apr_psprintf(p, "pid file %s overwritten -- Unclean shutdown of previous Apache run?",
                         fname);
      ap_log_perror("log.c", 634, 4, 0, p, tmp);
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  rv = apr_file_open(& pid_file, fname, 22, 1604, p);
  if (rv != 0) {
    ap_log_error("log.c", 644, 3, rv, (server_rec const   *)((void *)0), "could not create %s",
                 fname);
    ap_log_error("log.c", 646, 3, 0, (server_rec const   *)((void *)0), "%s: could not log pid to file %s",
                 ap_server_argv0, fname);
    exit(1);
  }
  apr_file_printf(pid_file, "%ld\n", (long )mypid);
  apr_file_close(pid_file);
  saved_pid = mypid;
  return;
}
}
apr_status_t ap_read_pid(apr_pool_t *p , char const   *filename , pid_t *mypid ) 
{ apr_size_t BUFFER_SIZE ;
  apr_file_t *pid_file ;
  apr_status_t rv ;
  char const   *fname ;
  char *buf ;
  char *endptr ;
  apr_size_t bytes_read ;
  unsigned short const   **tmp ;

  {
  BUFFER_SIZE = sizeof(long ) * 3U + 2U;
  pid_file = (apr_file_t *)((void *)0);
  if (! filename) {
    return (20014);
  }
  fname = ap_server_root_relative(p, filename);
  if (! fname) {
    ap_log_error("log.c", 672, 34, 20024, (server_rec const   *)((void *)0), "Invalid PID file path %s, ignoring.",
                 filename);
    return (20014);
  }
  rv = apr_file_open(& pid_file, fname, 1, 4095, p);
  if (rv != 0) {
    return (rv);
  }
  buf = (char *)apr_palloc(p, BUFFER_SIZE);
  (*(buf + (BUFFER_SIZE - 1U))) = (char )'\000';
  rv = apr_file_read_full(pid_file, (void *)buf, BUFFER_SIZE - 1U, & bytes_read);
  if (rv != 0) {
    if (rv != 70014) {
      return (rv);
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if (bytes_read == BUFFER_SIZE - 1U) {
    goto _L___0;
  } else {
    tmp = __ctype_b_loc();
    if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*buf)))) & 2048)) {
      _L___0: 
      return (20014);
    }
  }
  (*mypid) = (pid_t )strtol((char const   * __restrict  )buf, (char ** __restrict  )(& endptr),
                            10);
  apr_file_close(pid_file);
  return (0);
}
}
 __attribute__((__noreturn__)) void ap_log_assert(char const   *szExp , char const   *szFile ,
                                                  int nLine ) ;
void ap_log_assert(char const   *szExp , char const   *szFile , int nLine ) 
{ char time_str[25] ;
  apr_time_t tmp ;

  {
  tmp = apr_time_now();
  apr_ctime(time_str, tmp);
  ap_log_error("log.c", 709, 2, 0, (server_rec const   *)((void *)0), "[%s] file %s, line %d, assertion \"%s\" failed",
               time_str, szFile, nLine, szExp);
  abort();
}
}
static void piped_log_maintenance(int reason , void *data , int status ) ;
static int piped_log_spawn(piped_log *pl ) 
{ int rc ;
  apr_procattr_t *procattr ;
  apr_proc_t *procnew ;
  apr_status_t status ;
  char buf[120] ;
  char *tmp ;
  char **args ;
  char const   *pname ;
  void *tmp___0 ;

  {
  procnew = (apr_proc_t *)((void *)0);
  status = apr_procattr_create(& procattr, pl->p);
  if (status != 0) {
    goto _L;
  } else {
    status = apr_procattr_child_in_set(procattr, pl->fds[0], pl->fds[1]);
    if (status != 0) {
      _L: 
      tmp = apr_strerror(status, buf, sizeof(buf));
      ap_log_error("log.c", 740, 32, 0, (server_rec const   *)((void *)0), "piped_log_spawn: unable to setup child process \'%s\': %s",
                   pl->program, tmp);
      rc = -1;
    } else {
      apr_tokenize_to_argv((char const   *)pl->program, & args, pl->p);
      pname = apr_pstrdup(pl->p, (char const   *)(*(args + 0)));
      tmp___0 = apr_palloc(pl->p, sizeof(apr_proc_t ));
      procnew = (apr_proc_t *)memset(tmp___0, 0, sizeof(apr_proc_t ));
      rc = apr_proc_create(procnew, pname, (char const   * const  *)args, (char const   * const  *)((void *)0),
                           procattr, pl->p);
      if (rc == 0) {
        pl->pid = procnew;
        pl->fds[1] = procnew->in;
        apr_proc_other_child_register(procnew, & piped_log_maintenance, (void *)pl,
                                      pl->fds[1], pl->p);
      }
    }
  }
  return (0);
}
}
static void piped_log_maintenance(int reason , void *data , int status ) 
{ piped_log *pl ;
  apr_status_t stats ;
  char buf[120] ;
  char *tmp ;

  {
  pl = (piped_log *)data;
  switch (reason) {
  case 0: 
  pl->pid = (apr_proc_t *)((void *)0);
  apr_proc_other_child_unregister((void *)pl);
  if ((unsigned int )pl->program == (unsigned int )((void *)0)) {
    break;
  }
  break;
  case 4: 
  pl->pid = (apr_proc_t *)((void *)0);
  apr_proc_other_child_unregister((void *)pl);
  if ((unsigned int )pl->program == (unsigned int )((void *)0)) {
    break;
  }
  stats = piped_log_spawn(pl);
  if (stats != 0) {
    tmp = apr_strerror(stats, buf, sizeof(buf));
    ap_log_error("log.c", 796, 32, 0, (server_rec const   *)((void *)0), "piped_log_maintenance: unable to respawn \'%s\': %s",
                 pl->program, tmp);
  }
  break;
  case 1: ;
  break;
  case 2: 
  pl->program = (char *)((void *)0);
  if ((unsigned int )pl->pid != (unsigned int )((void *)0)) {
    apr_proc_kill(pl->pid, 15);
  }
  break;
  case 3: ;
  break;
  }
  return;
}
}
static apr_status_t piped_log_cleanup_for_exec(void *data ) 
{ piped_log *pl ;

  {
  pl = (piped_log *)data;
  apr_file_close(pl->fds[0]);
  apr_file_close(pl->fds[1]);
  return (0);
}
}
static apr_status_t piped_log_cleanup(void *data ) 
{ piped_log *pl ;
  apr_status_t tmp ;

  {
  pl = (piped_log *)data;
  if ((unsigned int )pl->pid != (unsigned int )((void *)0)) {
    apr_proc_kill(pl->pid, 15);
  }
  tmp = piped_log_cleanup_for_exec(data);
  return (tmp);
}
}
piped_log *ap_open_piped_log(apr_pool_t *p , char const   *program ) 
{ piped_log *pl ;
  apr_status_t tmp ;
  int save_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  pl = (piped_log *)apr_palloc(p, sizeof((*pl)));
  pl->p = p;
  pl->program = apr_pstrdup(p, program);
  pl->pid = (apr_proc_t *)((void *)0);
  tmp = apr_file_pipe_create(& pl->fds[0], & pl->fds[1], p);
  if (tmp != 0) {
    return ((piped_log *)((void *)0));
  }
  apr_pool_cleanup_register(p, (void const   *)pl, & piped_log_cleanup, & piped_log_cleanup_for_exec);
  tmp___2 = piped_log_spawn(pl);
  if (tmp___2 == -1) {
    tmp___0 = __errno_location();
    save_errno = (*tmp___0);
    apr_pool_cleanup_kill(p, (void const   *)pl, & piped_log_cleanup);
    apr_file_close(pl->fds[0]);
    apr_file_close(pl->fds[1]);
    tmp___1 = __errno_location();
    (*tmp___1) = save_errno;
    return ((piped_log *)((void *)0));
  }
  return (pl);
}
}
void ap_close_piped_log(piped_log *pl ) 
{ 

  {
  apr_pool_cleanup_run(pl->p, (void *)pl, & piped_log_cleanup);
  return;
}
}
void ap_hook_error_log(ap_HOOK_error_log_t *pf , char const   * const  *aszPre___1 ,
                       char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_error_log_t *pHook ;

  {
  if (! _hooks___0.link_error_log) {
    _hooks___0.link_error_log = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_error_log_t ));
    apr_hook_sort_register("error_log", & _hooks___0.link_error_log);
  }
  pHook = (ap_LINK_error_log_t *)apr_array_push(_hooks___0.link_error_log);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("error_log", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_error_log(void) 
{ 

  {
  return (_hooks___0.link_error_log);
}
}
void ap_run_error_log(char const   *file , int line , int level , apr_status_t status ,
                      server_rec const   *s , request_rec const   *r , apr_pool_t *pool ,
                      char const   *errstr ) 
{ ap_LINK_error_log_t *pHook ;
  int n ;

  {
  if (! _hooks___0.link_error_log) {
    return;
  }
  pHook = (ap_LINK_error_log_t *)(_hooks___0.link_error_log)->elts;
  n = 0;
  while (n < (_hooks___0.link_error_log)->nelts) {
    ((*((pHook + n)->pFunc)))(file, line, level, status, s, r, pool, errstr);
    n ++;
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-dOpradsW.i","-g -pthread")
apr_status_t apr_app_initialize(int *argc , char const   * const  **argv , char const   * const  **env ) ;
void apr_terminate(void) ;
apr_status_t apr_getopt_init(apr_getopt_t **os , apr_pool_t *cont , int argc , char const   * const  *argv ) ;
apr_status_t apr_getopt(apr_getopt_t *os , char const   *opts , char *optch , char const   **optarg ) ;
void apr_hook_deregister_all(void) ;
void ap_fini_vhost_config(apr_pool_t *p , server_rec *main_s ) ;
static void show_compile_settings(void) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
  tmp = ap_get_server_version();
  printf((char const   * __restrict  )"Server version: %s\n", tmp);
  tmp___0 = ap_get_server_built();
  printf((char const   * __restrict  )"Server built:   %s\n", tmp___0);
  printf((char const   * __restrict  )"Server\'s Module Magic Number: %u:%u\n", 20020903,
         0);
  printf((char const   * __restrict  )"Architecture:   %ld-bit\n", 8L * (long )sizeof(void *));
  printf((char const   * __restrict  )"Server compiled with....\n");
  printf((char const   * __restrict  )" -D APACHE_MPM_DIR=\"%s\"\n", "server/mpm/prefork");
  printf((char const   * __restrict  )" -D APR_HAS_SENDFILE\n");
  printf((char const   * __restrict  )" -D APR_HAS_MMAP\n");
  printf((char const   * __restrict  )" -D APR_HAVE_IPV6\n");
  printf((char const   * __restrict  )" -D APR_USE_PROC_PTHREAD_SERIALIZE\n");
  printf((char const   * __restrict  )" -D APR_USE_PTHREAD_SERIALIZE\n");
  printf((char const   * __restrict  )" -D SINGLE_LISTEN_UNSERIALIZED_ACCEPT\n");
  printf((char const   * __restrict  )" -D APR_HAS_OTHER_CHILD\n");
  printf((char const   * __restrict  )" -D AP_HAVE_RELIABLE_PIPED_LOGS\n");
  printf((char const   * __restrict  )" -D HTTPD_ROOT=\"/usr/local/apache2\"\n");
  printf((char const   * __restrict  )" -D SUEXEC_BIN=\"/usr/local/apache2/bin/suexec\"\n");
  printf((char const   * __restrict  )" -D DEFAULT_PIDLOG=\"logs/httpd.pid\"\n");
  printf((char const   * __restrict  )" -D DEFAULT_SCOREBOARD=\"logs/apache_runtime_status\"\n");
  printf((char const   * __restrict  )" -D DEFAULT_LOCKFILE=\"logs/accept.lock\"\n");
  printf((char const   * __restrict  )" -D DEFAULT_ERRORLOG=\"logs/error_log\"\n");
  printf((char const   * __restrict  )" -D AP_TYPES_CONFIG_FILE=\"conf/mime.types\"\n");
  printf((char const   * __restrict  )" -D SERVER_CONFIG_FILE=\"conf/httpd.conf\"\n");
  return;
}
}
static void destroy_and_exit_process(process_rec *process , int process_exit_value ) 
{ 

  {
  apr_pool_destroy(process->pool);
  apr_terminate();
  exit(process_exit_value);
}
}
static process_rec *create_process(int argc , char const   * const  *argv ) 
{ process_rec *process ;
  apr_pool_t *cntx ;
  apr_status_t stat___0 ;

  {
  stat___0 = apr_pool_create_ex(& cntx, (apr_pool_t *)((void *)0), (int (*)(int retcode ))((void *)0),
                                (apr_allocator_t *)((void *)0));
  if (stat___0 != 0) {
    ap_log_error("main.c", 262, 3, stat___0, (server_rec const   *)((void *)0), "apr_pool_create() failed to create initial context");
    apr_terminate();
    exit(1);
  }
  apr_pool_tag(cntx, "process");
  ap_open_stderr_log(cntx);
  process = (process_rec *)apr_palloc(cntx, sizeof(process_rec ));
  process->pool = cntx;
  apr_pool_create_ex(& process->pconf, process->pool, (int (*)(int retcode ))((void *)0),
                     (apr_allocator_t *)((void *)0));
  apr_pool_tag(process->pconf, "pconf");
  process->argc = argc;
  process->argv = argv;
  process->short_name = apr_filename_of_pathname((char const   *)(*(argv + 0)));
  return (process);
}
}
static void usage(process_rec *process ) 
{ char const   *bin ;
  char pad[8192] ;
  unsigned int i ;
  size_t tmp ;

  {
  bin = (char const   *)(*(process->argv + 0));
  i = 0U;
  while (1) {
    tmp = strlen(bin);
    if (! (i < tmp)) {
      break;
    }
    pad[i] = (char )' ';
    i ++;
  }
  pad[i] = (char )'\000';
  ap_log_error("main.c", 300, 32, 0, (server_rec const   *)((void *)0), "Usage: %s [-D name] [-d directory] [-f file]",
               bin);
  ap_log_error("main.c", 304, 32, 0, (server_rec const   *)((void *)0), "       %s [-C \"directive\"] [-c \"directive\"]",
               pad);
  ap_log_error("main.c", 315, 32, 0, (server_rec const   *)((void *)0), "       %s [-k start|restart|graceful|stop]",
               pad);
  ap_log_error("main.c", 319, 32, 0, (server_rec const   *)((void *)0), "       %s [-v] [-V] [-h] [-l] [-L] [-t] [-S]",
               pad);
  ap_log_error("main.c", 321, 32, 0, (server_rec const   *)((void *)0), "Options:");
  ap_log_error("main.c", 330, 32, 0, (server_rec const   *)((void *)0), "  -D name           : define a name for use in <IfDefine name> directives");
  ap_log_error("main.c", 333, 32, 0, (server_rec const   *)((void *)0), "  -d directory      : specify an alternate initial ServerRoot");
  ap_log_error("main.c", 336, 32, 0, (server_rec const   *)((void *)0), "  -f file           : specify an alternate ServerConfigFile");
  ap_log_error("main.c", 338, 32, 0, (server_rec const   *)((void *)0), "  -C \"directive\"    : process directive before reading config files");
  ap_log_error("main.c", 341, 32, 0, (server_rec const   *)((void *)0), "  -c \"directive\"    : process directive after reading config files");
  ap_log_error("main.c", 367, 32, 0, (server_rec const   *)((void *)0), "  -e level          : show startup errors of level (see LogLevel)");
  ap_log_error("main.c", 370, 32, 0, (server_rec const   *)((void *)0), "  -E file           : log startup errors to file");
  ap_log_error("main.c", 372, 32, 0, (server_rec const   *)((void *)0), "  -v                : show version number");
  ap_log_error("main.c", 374, 32, 0, (server_rec const   *)((void *)0), "  -V                : show compile settings");
  ap_log_error("main.c", 376, 32, 0, (server_rec const   *)((void *)0), "  -h                : list available command line options (this page)");
  ap_log_error("main.c", 379, 32, 0, (server_rec const   *)((void *)0), "  -l                : list compiled in modules");
  ap_log_error("main.c", 381, 32, 0, (server_rec const   *)((void *)0), "  -L                : list available configuration directives");
  ap_log_error("main.c", 384, 32, 0, (server_rec const   *)((void *)0), "  -t -D DUMP_VHOSTS : show parsed settings (currently only vhost settings)");
  ap_log_error("main.c", 387, 32, 0, (server_rec const   *)((void *)0), "  -S                : a synonym for -t -D DUMP_VHOSTS");
  ap_log_error("main.c", 389, 32, 0, (server_rec const   *)((void *)0), "  -t                : run syntax check for config files");
  destroy_and_exit_process(process, 1);
  return;
}
}
int main(int argc , char const   * const  *argv ) 
{ char c ;
  int configtestonly ;
  char const   *confname ;
  char const   *def_server_root ;
  char const   *temp_error_log ;
  process_rec *process ;
  server_rec *server_conf ;
  apr_pool_t *pglobal ;
  apr_pool_t *pconf___0 ;
  apr_pool_t *plog ;
  apr_pool_t *ptemp ;
  apr_pool_t *pcommands ;
  apr_getopt_t *opt ;
  apr_status_t rv ;
  module **mod ;
  char const   *optarg ;
  apr_OFN_ap_signal_server_t *signal_server ;
  char **new ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___14 ;
  int exit_status ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
  configtestonly = 0;
  confname = "conf/httpd.conf";
  def_server_root = "/usr/local/apache2";
  temp_error_log = (char const   *)((void *)0);
  apr_app_initialize(& argc, & argv, (char const   * const  **)((void *)0));
  process = create_process(argc, argv);
  pglobal = process->pool;
  pconf___0 = process->pconf;
  ap_server_argv0 = process->short_name;
  ap_setup_prelinked_modules(process);
  apr_pool_create_ex(& pcommands, pglobal, (int (*)(int retcode ))((void *)0), (apr_allocator_t *)((void *)0));
  apr_pool_tag(pcommands, "pcommands");
  ap_server_pre_read_config = apr_array_make(pcommands, 1, (int )sizeof(char *));
  ap_server_post_read_config = apr_array_make(pcommands, 1, (int )sizeof(char *));
  ap_server_config_defines = apr_array_make(pcommands, 1, (int )sizeof(char *));
  ap_run_rewrite_args(process);
  apr_getopt_init(& opt, pcommands, process->argc, process->argv);
  while (1) {
    rv = apr_getopt(opt, "C:c:D:d:E:e:f:vVlLtSh?X", & c, & optarg);
    if (! (rv == 0)) {
      break;
    }
    switch ((int )c) {
    case 99: 
    new = (char **)apr_array_push(ap_server_post_read_config);
    (*new) = apr_pstrdup(pcommands, optarg);
    break;
    case 67: 
    new = (char **)apr_array_push(ap_server_pre_read_config);
    (*new) = apr_pstrdup(pcommands, optarg);
    break;
    case 100: 
    def_server_root = optarg;
    break;
    case 68: 
    new = (char **)apr_array_push(ap_server_config_defines);
    (*new) = apr_pstrdup(pcommands, optarg);
    break;
    case 101: 
    tmp___9 = strcasecmp(optarg, "emerg");
    if (tmp___9 == 0) {
      ap_default_loglevel = 0;
    } else {
      tmp___8 = strcasecmp(optarg, "alert");
      if (tmp___8 == 0) {
        ap_default_loglevel = 1;
      } else {
        tmp___7 = strcasecmp(optarg, "crit");
        if (tmp___7 == 0) {
          ap_default_loglevel = 2;
        } else {
          tmp___6 = strncasecmp(optarg, "err", 3U);
          if (tmp___6 == 0) {
            ap_default_loglevel = 3;
          } else {
            tmp___5 = strncasecmp(optarg, "warn", 4U);
            if (tmp___5 == 0) {
              ap_default_loglevel = 4;
            } else {
              tmp___4 = strcasecmp(optarg, "notice");
              if (tmp___4 == 0) {
                ap_default_loglevel = 5;
              } else {
                tmp___3 = strcasecmp(optarg, "info");
                if (tmp___3 == 0) {
                  ap_default_loglevel = 6;
                } else {
                  tmp___2 = strcasecmp(optarg, "debug");
                  if (tmp___2 == 0) {
                    ap_default_loglevel = 7;
                  } else {
                    usage(process);
                  }
                }
              }
            }
          }
        }
      }
    }
    break;
    case 69: 
    temp_error_log = apr_pstrdup(process->pool, optarg);
    break;
    case 88: 
    new = (char **)apr_array_push(ap_server_config_defines);
    (*new) = (char *)"DEBUG";
    break;
    case 102: 
    confname = optarg;
    break;
    case 118: 
    tmp___11 = ap_get_server_version();
    printf((char const   * __restrict  )"Server version: %s\n", tmp___11);
    tmp___12 = ap_get_server_built();
    printf((char const   * __restrict  )"Server built:   %s\n", tmp___12);
    destroy_and_exit_process(process, 0);
    case 86: 
    show_compile_settings();
    destroy_and_exit_process(process, 0);
    case 108: 
    ap_show_modules();
    destroy_and_exit_process(process, 0);
    case 76: 
    ap_show_directives();
    destroy_and_exit_process(process, 0);
    case 116: 
    configtestonly = 1;
    break;
    case 83: 
    configtestonly = 1;
    new = (char **)apr_array_push(ap_server_config_defines);
    (*new) = (char *)"DUMP_VHOSTS";
    break;
    case 104: ;
    case 63: 
    usage(process);
    }
  }
  if (rv != 70014) {
    goto _L;
  } else {
    if (opt->ind < opt->argc) {
      _L: 
      usage(process);
    }
  }
  apr_pool_create_ex(& plog, pglobal, (int (*)(int retcode ))((void *)0), (apr_allocator_t *)((void *)0));
  apr_pool_tag(plog, "plog");
  apr_pool_create_ex(& ptemp, pconf___0, (int (*)(int retcode ))((void *)0), (apr_allocator_t *)((void *)0));
  apr_pool_tag(ptemp, "ptemp");
  ap_server_root = def_server_root;
  if (temp_error_log) {
    ap_replace_stderr_log(process->pool, temp_error_log);
  }
  server_conf = ap_read_config(process, ptemp, confname, & ap_conftree);
  tmp___14 = ap_run_pre_config(pconf___0, plog, ptemp);
  if (tmp___14 != 0) {
    ap_log_error("main.c", 567, 35, 0, (server_rec const   *)((void *)0), "Pre-configuration failed\n");
    destroy_and_exit_process(process, 1);
  }
  ap_process_config_tree(server_conf, ap_conftree, process->pconf, ptemp);
  ap_fixup_virtual_hosts(pconf___0, server_conf);
  ap_fini_vhost_config(pconf___0, server_conf);
  apr_hook_sort_all();
  if (configtestonly) {
    ap_log_error("main.c", 577, 32, 0, (server_rec const   *)((void *)0), "Syntax OK");
    destroy_and_exit_process(process, 0);
  }
  signal_server = (apr_OFN_ap_signal_server_t *)apr_dynamic_fn_retrieve("ap_signal_server");
  if (signal_server) {
    tmp___16 = ((*signal_server))(& exit_status, pconf___0);
    if (tmp___16 != 0) {
      destroy_and_exit_process(process, exit_status);
    }
  }
  apr_pool_clear(plog);
  tmp___17 = ap_run_open_logs(pconf___0, plog, ptemp, server_conf);
  if (tmp___17 != 0) {
    ap_log_error("main.c", 593, 35, 0, (server_rec const   *)((void *)0), "Unable to open logs\n");
    destroy_and_exit_process(process, 1);
  }
  tmp___18 = ap_run_post_config(pconf___0, plog, ptemp, server_conf);
  if (tmp___18 != 0) {
    ap_log_error("main.c", 599, 35, 0, (server_rec const   *)((void *)0), "Configuration Failed\n");
    destroy_and_exit_process(process, 1);
  }
  apr_pool_destroy(ptemp);
  while (1) {
    apr_hook_deregister_all();
    apr_pool_clear(pconf___0);
    mod = ap_prelinked_modules;
    while ((unsigned int )(*mod) != (unsigned int )((void *)0)) {
      ap_register_hooks((*mod), pconf___0);
      mod ++;
    }
    ap_conftree = (ap_directive_t *)((void *)0);
    apr_pool_create_ex(& ptemp, pconf___0, (int (*)(int retcode ))((void *)0), (apr_allocator_t *)((void *)0));
    apr_pool_tag(ptemp, "ptemp");
    ap_server_root = def_server_root;
    server_conf = ap_read_config(process, ptemp, confname, & ap_conftree);
    tmp___19 = ap_run_pre_config(pconf___0, plog, ptemp);
    if (tmp___19 != 0) {
      ap_log_error("main.c", 624, 35, 0, (server_rec const   *)((void *)0), "Pre-configuration failed\n");
      destroy_and_exit_process(process, 1);
    }
    ap_process_config_tree(server_conf, ap_conftree, process->pconf, ptemp);
    ap_fixup_virtual_hosts(pconf___0, server_conf);
    ap_fini_vhost_config(pconf___0, server_conf);
    apr_hook_sort_all();
    apr_pool_clear(plog);
    tmp___20 = ap_run_open_logs(pconf___0, plog, ptemp, server_conf);
    if (tmp___20 != 0) {
      ap_log_error("main.c", 635, 35, 0, (server_rec const   *)((void *)0), "Unable to open logs\n");
      destroy_and_exit_process(process, 1);
    }
    tmp___21 = ap_run_post_config(pconf___0, plog, ptemp, server_conf);
    if (tmp___21 != 0) {
      ap_log_error("main.c", 641, 35, 0, (server_rec const   *)((void *)0), "Configuration Failed\n");
      destroy_and_exit_process(process, 1);
    }
    apr_pool_destroy(ptemp);
    ap_run_optional_fn_retrieve();
    tmp___22 = ap_mpm_run(pconf___0, plog, server_conf);
    if (tmp___22) {
      break;
    }
  }
  destroy_and_exit_process(process, 0);
  return (0);
}
}
void suck_in_apr_password_validate(void) ;
void suck_in_apr_password_validate(void) 
{ 

  {
  apr_password_validate("a", "b");
  return;
}
}
void const   *suck_in_APR(void) ;
void const   *ap_ugly_hack ;
void const   *suck_in_APR(void) 
{ 

  {
  return (ap_ugly_hack);
}
}
#pragma merger(0,"/tmp/cil-2HIbGJzI.i","-g -pthread")
apr_status_t apr_getnameinfo(char **hostname , apr_sockaddr_t *sockaddr , apr_int32_t flags ) ;
apr_status_t apr_parse_addr_port(char **addr , char **scope_id , apr_port_t *port ,
                                 char const   *str , apr_pool_t *p ) ;
apr_status_t apr_sockaddr_port_get(apr_port_t *port , apr_sockaddr_t *sockaddr ) ;
apr_status_t apr_sockaddr_ip_get(char **addr , apr_sockaddr_t *sockaddr ) ;
int apr_sockaddr_equal(apr_sockaddr_t const   *addr1 , apr_sockaddr_t const   *addr2 ) ;
char *ap_get_local_host(apr_pool_t *a ) ;
char const   *ap_set_name_virtual_host(cmd_parms *cmd , void *dummy , char const   *arg ) ;
void ap_update_vhost_given_ip(conn_rec *conn ) ;
void ap_update_vhost_from_headers(request_rec *r ) ;
int ap_matches_request_vhost(request_rec *r , char const   *host , apr_port_t port ) ;
static ipaddr_chain *iphash_table[256]  ;
static ipaddr_chain *default_list  ;
static server_addr_rec *name_vhost_list  ;
static server_addr_rec **name_vhost_list_tail  ;
void ap_init_vhost_config(apr_pool_t *p ) 
{ 

  {
  memset((void *)(iphash_table), 0, sizeof(iphash_table));
  default_list = (ipaddr_chain *)((void *)0);
  name_vhost_list = (server_addr_rec *)((void *)0);
  name_vhost_list_tail = & name_vhost_list;
  return;
}
}
static char const   *get_addresses(apr_pool_t *p , char const   *w_ , server_addr_rec ***paddr ,
                                   apr_port_t default_port ) 
{ apr_sockaddr_t *my_addr ;
  server_addr_rec *sar ;
  char *w ;
  char *host ;
  char *scope_id ;
  int wild_port ;
  apr_size_t wlen ;
  apr_port_t port ;
  apr_status_t rv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  if ((int const   )(*w_) == 0) {
    return ((char const   *)((void *)0));
  }
  w = apr_pstrdup(p, w_);
  wlen = strlen((char const   *)w);
  wild_port = 0;
  if ((int )(*(w + (wlen - 1U))) == 42) {
    if (wlen < 2U) {
      wild_port = 1;
    } else {
      if ((int )(*(w + (wlen - 2U))) == 58) {
        (*(w + (wlen - 2U))) = (char )'\000';
        wild_port = 1;
      }
    }
  }
  rv = apr_parse_addr_port(& host, & scope_id, & port, (char const   *)w, p);
  if (rv != 0) {
    return ("The address or port is invalid");
  }
  if (! host) {
    return ("Missing address for VirtualHost");
  }
  if (scope_id) {
    return ("Scope ids are not supported");
  }
  if (! port) {
    if (! wild_port) {
      port = default_port;
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  tmp___1 = strcmp((char const   *)host, "*");
  if (tmp___1 == 0) {
    rv = apr_sockaddr_info_get(& my_addr, "0.0.0.0", 2, port, 0, p);
    if (! (rv == 0)) {
      ap_log_assert("rv == APR_SUCCESS", "vhost.c", 227);
    }
  } else {
    tmp = strcasecmp((char const   *)host, "_default_");
    if (tmp == 0) {
      goto _L___0;
    } else {
      tmp___0 = strcmp((char const   *)host, "255.255.255.255");
      if (tmp___0 == 0) {
        _L___0: 
        rv = apr_sockaddr_info_get(& my_addr, "255.255.255.255", 2, port, 0, p);
        if (! (rv == 0)) {
          ap_log_assert("rv == APR_SUCCESS", "vhost.c", 232);
        }
      } else {
        rv = apr_sockaddr_info_get(& my_addr, (char const   *)host, 0, port, 0, p);
        if (rv != 0) {
          ap_log_error("vhost.c", 237, 3, rv, (server_rec const   *)((void *)0), "Cannot resolve host name %s --- ignoring!",
                       host);
          return ((char const   *)((void *)0));
        }
      }
    }
  }
  tmp___2 = apr_palloc(p, sizeof(server_addr_rec ));
  sar = (server_addr_rec *)memset(tmp___2, 0, sizeof(server_addr_rec ));
  (*((*paddr))) = sar;
  (*paddr) = & sar->next;
  sar->host_addr = my_addr;
  sar->host_port = port;
  sar->virthost = host;
  return ((char const   *)((void *)0));
}
}
char const   *ap_parse_vhost_addrs(apr_pool_t *p , char const   *hostname , server_rec *s ) 
{ server_addr_rec **addrs ;
  char const   *err ;
  char const   *tmp ;

  {
  addrs = & s->addrs;
  while ((*(hostname + 0))) {
    tmp = ap_getword_conf(p, & hostname);
    err = get_addresses(p, tmp, & addrs, s->port);
    if (err) {
      (*addrs) = (server_addr_rec *)((void *)0);
      return (err);
    }
  }
  (*addrs) = (server_addr_rec *)((void *)0);
  if (s->addrs) {
    if ((s->addrs)->host_port) {
      s->port = (s->addrs)->host_port;
    }
  }
  return ((char const   *)((void *)0));
}
}
char const   *ap_set_name_virtual_host(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *tmp ;

  {
  tmp = get_addresses(cmd->pool, arg, & name_vhost_list_tail, (cmd->server)->port);
  return (tmp);
}
}
__inline static unsigned int hash_inaddr(unsigned int key ) 
{ 

  {
  key ^= key >> 16;
  return (((key >> 8) ^ key) % 256U);
}
}
__inline static unsigned int hash_addr(struct apr_sockaddr_t *sa ) 
{ unsigned int key ;
  unsigned int tmp ;

  {
  key = (*((unsigned int *)(((char *)sa->ipaddr_ptr + sa->ipaddr_len) - 4)));
  tmp = hash_inaddr(key);
  return (tmp);
}
}
static ipaddr_chain *new_ipaddr_chain(apr_pool_t *p , server_rec *s , server_addr_rec *sar ) 
{ ipaddr_chain *new ;

  {
  new = (ipaddr_chain *)apr_palloc(p, sizeof((*new)));
  new->names = (name_chain *)((void *)0);
  new->server = s;
  new->sar = sar;
  new->next = (ipaddr_chain *)((void *)0);
  return (new);
}
}
static name_chain *new_name_chain(apr_pool_t *p , server_rec *s , server_addr_rec *sar ) 
{ name_chain *new ;

  {
  new = (name_chain *)apr_palloc(p, sizeof((*new)));
  new->server = s;
  new->sar = sar;
  new->next = (name_chain *)((void *)0);
  return (new);
}
}
__inline static ipaddr_chain *find_ipaddr(apr_sockaddr_t *sa ) 
{ unsigned int bucket ;
  ipaddr_chain *trav ;
  server_addr_rec *sar ;
  apr_sockaddr_t *cur ;
  int tmp ;

  {
  bucket = hash_addr(sa);
  trav = iphash_table[bucket];
  while (trav) {
    sar = trav->sar;
    cur = sar->host_addr;
    if ((int )cur->port == 0) {
      goto _L___0;
    } else {
      if ((int )sa->port == 0) {
        _L___0: 
        goto _L;
      } else {
        if ((int )cur->port == (int )sa->port) {
          _L: 
          tmp = apr_sockaddr_equal((apr_sockaddr_t const   *)cur, (apr_sockaddr_t const   *)sa);
          if (tmp) {
            return (trav);
          }
        }
      }
    }
    trav = trav->next;
  }
  return ((ipaddr_chain *)((void *)0));
}
}
static ipaddr_chain *find_default_server(apr_port_t port ) 
{ server_addr_rec *sar ;
  ipaddr_chain *trav ;

  {
  trav = default_list;
  while (trav) {
    sar = trav->sar;
    if ((int )sar->host_port == 0) {
      goto _L;
    } else {
      if ((int )sar->host_port == (int )port) {
        _L: 
        return (trav);
      }
    }
    trav = trav->next;
  }
  return ((ipaddr_chain *)((void *)0));
}
}
static void dump_a_vhost(apr_file_t *f , ipaddr_chain *ic ) 
{ name_chain *nc ;
  int len ;
  char buf[8192] ;
  apr_sockaddr_t *ha ;

  {
  ha = (ic->sar)->host_addr;
  if (ha->family == 2) {
    if ((unsigned long )ha->sa.sin.sin_addr.s_addr == 4294967295UL) {
      len = apr_snprintf(buf, sizeof(buf), "_default_:%u", (ic->sar)->host_port);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    if (ha->family == 2) {
      if (ha->sa.sin.sin_addr.s_addr == 0U) {
        len = apr_snprintf(buf, sizeof(buf), "*:%u", (ic->sar)->host_port);
      } else {
        goto _L;
      }
    } else {
      _L: 
      len = apr_snprintf(buf, sizeof(buf), "%pI", ha);
    }
  }
  if ((int )(ic->sar)->host_port == 0) {
    buf[len - 1] = (char )'*';
  }
  if ((unsigned int )ic->names == (unsigned int )((void *)0)) {
    apr_file_printf(f, "%-22s %s (%s:%u)\n", buf, (ic->server)->server_hostname, (ic->server)->defn_name,
                    (ic->server)->defn_line_number);
    return;
  }
  apr_file_printf(f, "%-22s is a NameVirtualHost\n%8s default server %s (%s:%u)\n",
                  buf, "", (ic->server)->server_hostname, (ic->server)->defn_name,
                  (ic->server)->defn_line_number);
  nc = ic->names;
  while (nc) {
    if ((nc->sar)->host_port) {
      apr_file_printf(f, "%8s port %u ", "", (nc->sar)->host_port);
    } else {
      apr_file_printf(f, "%8s port * ", "");
    }
    apr_file_printf(f, "namevhost %s (%s:%u)\n", (nc->server)->server_hostname, (nc->server)->defn_name,
                    (nc->server)->defn_line_number);
    nc = nc->next;
  }
  return;
}
}
static void dump_vhost_config(apr_file_t *f ) 
{ ipaddr_chain *ic ;
  int i ;

  {
  apr_file_printf(f, "VirtualHost configuration:\n");
  i = 0;
  while (i < 256) {
    ic = iphash_table[i];
    while (ic) {
      dump_a_vhost(f, ic);
      ic = ic->next;
    }
    i ++;
  }
  if (default_list) {
    apr_file_printf(f, "wildcard NameVirtualHosts and _default_ servers:\n");
    ic = default_list;
    while (ic) {
      dump_a_vhost(f, ic);
      ic = ic->next;
    }
  }
  return;
}
}
static int add_name_vhost_config(apr_pool_t *p , server_rec *main_s , server_rec *s ,
                                 server_addr_rec *sar , ipaddr_chain *ic ) 
{ name_chain *nc ;
  name_chain *tmp ;

  {
  if (ic->names) {
    goto _L;
  } else {
    if ((unsigned int )ic->server == (unsigned int )((void *)0)) {
      _L: 
      tmp = new_name_chain(p, s, sar);
      nc = tmp;
      nc->next = ic->names;
      ic->names = nc;
      ic->server = s;
      if ((int )sar->host_port != (int )(ic->sar)->host_port) {
        ap_log_error("vhost.c", 520, 3, 0, (server_rec const   *)main_s, "VirtualHost %s:%u -- mixing * ports and non-* ports with a NameVirtualHost address is not supported, proceeding with undefined results",
                     sar->virthost, sar->host_port);
      }
      return (1);
    } else {
      return (0);
    }
  }
}
}
static void remove_unused_name_vhosts(server_rec *main_s , ipaddr_chain **pic ) 
{ ipaddr_chain *ic ;

  {
  while ((*pic)) {
    ic = (*pic);
    if ((unsigned int )ic->server == (unsigned int )((void *)0)) {
      ap_log_error("vhost.c", 541, 4, 0, (server_rec const   *)main_s, "NameVirtualHost %s:%u has no VirtualHosts",
                   (ic->sar)->virthost, (ic->sar)->host_port);
      (*pic) = ic->next;
    } else {
      if ((unsigned int )ic->names == (unsigned int )((void *)0)) {
        break;
      } else {
        pic = & ic->next;
      }
    }
  }
  return;
}
}
void ap_fini_vhost_config(apr_pool_t *p , server_rec *main_s ) 
{ server_addr_rec *sar ;
  int has_default_vhost_addr ;
  server_rec *s ;
  int i ;
  ipaddr_chain **iphash_table_tail[256] ;
  char inaddr_any[16] ;
  unsigned int bucket ;
  unsigned int tmp ;
  ipaddr_chain *ic ;
  ipaddr_chain *tmp___0 ;
  int tmp___1 ;
  ipaddr_chain *ic___0 ;
  char inaddr_any___0[16] ;
  int tmp___2 ;
  unsigned int bucket___0 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  apr_status_t rv ;
  char *hostname ;
  char *ipaddr_str ;
  apr_file_t *thefile ;
  int tmp___6 ;

  {
  (*name_vhost_list_tail) = (server_addr_rec *)((void *)0);
  s = main_s;
  if (! s->server_hostname) {
    s->server_hostname = ap_get_local_host(p);
  }
  i = 0;
  while (i < 256) {
    iphash_table_tail[i] = & iphash_table[i];
    i ++;
  }
  sar = name_vhost_list;
  while (sar) {
    inaddr_any[0] = (char)0;
    inaddr_any[1] = (char)0;
    inaddr_any[2] = (char)0;
    inaddr_any[3] = (char)0;
    inaddr_any[4] = (char)0;
    inaddr_any[5] = (char)0;
    inaddr_any[6] = (char)0;
    inaddr_any[7] = (char)0;
    inaddr_any[8] = (char)0;
    inaddr_any[9] = (char)0;
    inaddr_any[10] = (char)0;
    inaddr_any[11] = (char)0;
    inaddr_any[12] = (char)0;
    inaddr_any[13] = (char)0;
    inaddr_any[14] = (char)0;
    inaddr_any[15] = (char)0;
    tmp = hash_addr(sar->host_addr);
    bucket = tmp;
    tmp___0 = new_ipaddr_chain(p, (server_rec *)((void *)0), sar);
    ic = tmp___0;
    tmp___1 = memcmp((void const   *)(sar->host_addr)->ipaddr_ptr, (void const   *)(inaddr_any),
                     (unsigned int )(sar->host_addr)->ipaddr_len);
    if (tmp___1) {
      (*(iphash_table_tail[bucket])) = ic;
      iphash_table_tail[bucket] = & ic->next;
    } else {
      ic->next = default_list;
      default_list = ic;
    }
    sar = sar->next;
  }
  s = main_s->next;
  while (s) {
    has_default_vhost_addr = 0;
    sar = s->addrs;
    while (sar) {
      inaddr_any___0[0] = (char)0;
      inaddr_any___0[1] = (char)0;
      inaddr_any___0[2] = (char)0;
      inaddr_any___0[3] = (char)0;
      inaddr_any___0[4] = (char)0;
      inaddr_any___0[5] = (char)0;
      inaddr_any___0[6] = (char)0;
      inaddr_any___0[7] = (char)0;
      inaddr_any___0[8] = (char)0;
      inaddr_any___0[9] = (char)0;
      inaddr_any___0[10] = (char)0;
      inaddr_any___0[11] = (char)0;
      inaddr_any___0[12] = (char)0;
      inaddr_any___0[13] = (char)0;
      inaddr_any___0[14] = (char)0;
      inaddr_any___0[15] = (char)0;
      if ((sar->host_addr)->family == 2) {
        if ((unsigned long )(sar->host_addr)->sa.sin.sin_addr.s_addr == 4294967295UL) {
          goto _L___1;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: 
        tmp___5 = memcmp((void const   *)(sar->host_addr)->ipaddr_ptr, (void const   *)(inaddr_any___0),
                         (unsigned int )(sar->host_addr)->ipaddr_len);
        if (tmp___5) {
          ic___0 = find_ipaddr(sar->host_addr);
          if (! ic___0) {
            tmp___3 = hash_addr(sar->host_addr);
            bucket___0 = tmp___3;
            ic___0 = new_ipaddr_chain(p, s, sar);
            ic___0->next = (*(iphash_table_tail[bucket___0]));
            (*(iphash_table_tail[bucket___0])) = ic___0;
          } else {
            tmp___4 = add_name_vhost_config(p, main_s, s, sar, ic___0);
            if (! tmp___4) {
              ap_log_error("vhost.c", 650, 4, 0, (server_rec const   *)main_s, "VirtualHost %s:%u overlaps with VirtualHost %s:%u, the first has precedence, perhaps you need a NameVirtualHost directive",
                           sar->virthost, sar->host_port, (ic___0->sar)->virthost,
                           (ic___0->sar)->host_port);
              ic___0->sar = sar;
              ic___0->server = s;
            }
          }
        } else {
          _L___1: 
          ic___0 = find_default_server(sar->host_port);
          if (! ic___0) {
            goto _L___0;
          } else {
            tmp___2 = add_name_vhost_config(p, main_s, s, sar, ic___0);
            if (! tmp___2) {
              _L___0: 
              if (ic___0) {
                if ((int )(ic___0->sar)->host_port != 0) {
                  ap_log_error("vhost.c", 627, 4, 0, (server_rec const   *)main_s,
                               "_default_ VirtualHost overlap on port %u, the first has precedence",
                               sar->host_port);
                } else {
                  goto _L;
                }
              } else {
                _L: ;
              }
              ic___0 = new_ipaddr_chain(p, s, sar);
              ic___0->next = default_list;
              default_list = ic___0;
            }
          }
          has_default_vhost_addr = 1;
        }
      }
      sar = sar->next;
    }
    if (! s->server_hostname) {
      if (has_default_vhost_addr) {
        s->server_hostname = main_s->server_hostname;
      } else {
        if (! s->addrs) {
          s->server_hostname = apr_pstrdup(p, "bogus_host_without_forward_dns");
        } else {
          rv = apr_getnameinfo(& hostname, (s->addrs)->host_addr, 0);
          if (rv == 0) {
            s->server_hostname = apr_pstrdup(p, (char const   *)hostname);
          } else {
            apr_sockaddr_ip_get(& ipaddr_str, (s->addrs)->host_addr);
            ap_log_error("vhost.c", 693, 3, rv, (server_rec const   *)main_s, "Failed to resolve server name for %s (check DNS) -- or specify an explicit ServerName",
                         ipaddr_str);
            s->server_hostname = apr_pstrdup(p, "bogus_host_without_reverse_dns");
          }
        }
      }
    }
    s = s->next;
  }
  i = 0;
  while (i < 256) {
    remove_unused_name_vhosts(main_s, & iphash_table[i]);
    i ++;
  }
  remove_unused_name_vhosts(main_s, & default_list);
  tmp___6 = ap_exists_config_define("DUMP_VHOSTS");
  if (tmp___6) {
    thefile = (apr_file_t *)((void *)0);
    apr_file_open_stderr(& thefile, p);
    dump_vhost_config(thefile);
  }
  return;
}
}
static void fix_hostname(request_rec *r ) 
{ char *host ;
  char *scope_id ;
  char *dst ;
  apr_port_t port ;
  apr_status_t rv ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  if (! (*(r->hostname))) {
    return;
  }
  rv = apr_parse_addr_port(& host, & scope_id, & port, r->hostname, r->pool);
  if (rv != 0) {
    goto _L;
  } else {
    if (scope_id) {
      _L: 
      goto bad;
    }
  }
  if (! host) {
    if (port) {
      host = apr_itoa(r->pool, (int )port);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    if (port) {
      r->parsed_uri.port = port;
      r->parsed_uri.port_str = apr_itoa(r->pool, (int )port);
    }
  }
  if ((int const   )(*(r->hostname + 0)) != 91) {
    dst = host;
    while ((*dst)) {
      tmp___0 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___0) + (int )((unsigned char )(*dst)))) & 512)) {
        if ((int )(*dst) == 46) {
          if ((int )(*(dst + 1)) == 46) {
            goto bad;
          }
        } else {
          tmp = __ctype_b_loc();
          if ((int const   )(*((*tmp) + (int )((unsigned char )(*dst)))) & 256) {
            (*dst) = (char )tolower((int )((unsigned char )(*dst)));
          } else {
            if ((int )(*dst) == 47) {
              goto _L___1;
            } else {
              if ((int )(*dst) == 92) {
                _L___1: 
                goto bad;
              }
            }
          }
        }
      }
      dst ++;
    }
    if ((unsigned int )dst > (unsigned int )host) {
      if ((int )(*(dst + -1)) == 46) {
        (*(dst + -1)) = (char )'\000';
      } else {
        goto _L___2;
      }
    } else {
      _L___2: ;
    }
  }
  r->hostname = (char const   *)host;
  return;
  bad: 
  r->status = 400;
  ap_log_rerror("vhost.c", 805, 3, 0, (request_rec const   *)r, "Client sent malformed Host header");
  return;
}
}
static int matches_aliases(server_rec *s , char const   *host ) 
{ int i ;
  apr_array_header_t *names ;
  int tmp ;
  char **name ;
  int tmp___0 ;
  char **name___0 ;
  int tmp___1 ;

  {
  tmp = strcasecmp(host, (char const   *)s->server_hostname);
  if (! tmp) {
    return (1);
  }
  names = s->names;
  if (names) {
    name = (char **)names->elts;
    i = 0;
    while (i < names->nelts) {
      if (! (*(name + i))) {
        goto __Cont;
      }
      tmp___0 = strcasecmp(host, (char const   *)(*(name + i)));
      if (! tmp___0) {
        return (1);
      }
      __Cont: 
      i ++;
    }
  }
  names = s->wild_names;
  if (names) {
    name___0 = (char **)names->elts;
    i = 0;
    while (i < names->nelts) {
      if (! (*(name___0 + i))) {
        goto __Cont___0;
      }
      tmp___1 = ap_strcasecmp_match(host, (char const   *)(*(name___0 + i)));
      if (! tmp___1) {
        return (1);
      }
      __Cont___0: 
      i ++;
    }
  }
  return (0);
}
}
int ap_matches_request_vhost(request_rec *r , char const   *host , apr_port_t port ) 
{ server_rec *s ;
  server_addr_rec *sar ;
  int tmp ;
  int tmp___0 ;

  {
  s = r->server;
  sar = s->addrs;
  while (sar) {
    if ((int )sar->host_port == 0) {
      goto _L___0;
    } else {
      if ((int )port == (int )sar->host_port) {
        _L___0: 
        tmp = strcasecmp(host, (char const   *)sar->virthost);
        if (tmp) {
          goto _L;
        } else {
          return (1);
        }
      } else {
        _L: ;
      }
    }
    sar = sar->next;
  }
  if ((int )port != (int )s->port) {
    return (0);
  }
  tmp___0 = matches_aliases(s, host);
  return (tmp___0);
}
}
static void check_hostalias(request_rec *r ) 
{ char const   *host ;
  apr_port_t port ;
  server_rec *s ;
  server_rec *last_s ;
  name_chain *src ;
  server_addr_rec *sar ;
  int tmp ;
  int tmp___0 ;

  {
  host = r->hostname;
  last_s = (server_rec *)((void *)0);
  apr_sockaddr_port_get(& port, (r->connection)->local_addr);
  src = (name_chain *)(r->connection)->vhost_lookup_data;
  while (src) {
    sar = src->sar;
    if ((int )sar->host_port != 0) {
      if ((int )port != (int )sar->host_port) {
        goto __Cont;
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    s = src->server;
    tmp = strcasecmp(host, (char const   *)sar->virthost);
    if (! tmp) {
      goto found;
    }
    if ((unsigned int )s == (unsigned int )last_s) {
      goto __Cont;
    }
    last_s = s;
    tmp___0 = matches_aliases(s, host);
    if (tmp___0) {
      goto found;
    }
    __Cont: 
    src = src->next;
  }
  return;
  found: 
  r->server = s;
  return;
}
}
static void check_serverpath(request_rec *r ) 
{ server_rec *s ;
  server_rec *last_s ;
  name_chain *src ;
  apr_port_t port ;
  int tmp ;

  {
  apr_sockaddr_port_get(& port, (r->connection)->local_addr);
  last_s = (server_rec *)((void *)0);
  src = (name_chain *)(r->connection)->vhost_lookup_data;
  while (src) {
    if ((int )(src->sar)->host_port != 0) {
      if ((int )port != (int )(src->sar)->host_port) {
        goto __Cont;
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    s = src->server;
    if ((unsigned int )s == (unsigned int )last_s) {
      goto __Cont;
    }
    last_s = s;
    if (s->path) {
      tmp = strncmp((char const   *)r->uri, s->path, (unsigned int )s->pathlen);
      if (tmp) {
        goto _L___3;
      } else {
        if ((int const   )(*(s->path + (s->pathlen - 1))) == 47) {
          goto _L___2;
        } else {
          if ((int )(*(r->uri + s->pathlen)) == 47) {
            _L___2: 
            goto _L___1;
          } else {
            if ((int )(*(r->uri + s->pathlen)) == 0) {
              _L___1: 
              r->server = s;
              return;
            } else {
              goto _L___3;
            }
          }
        }
      }
    } else {
      _L___3: ;
    }
    __Cont: 
    src = src->next;
  }
  return;
}
}
void ap_update_vhost_from_headers(request_rec *r ) 
{ 

  {
  if (r->hostname) {
    goto _L;
  } else {
    r->hostname = apr_table_get((apr_table_t const   *)r->headers_in, "Host");
    if (r->hostname) {
      _L: 
      fix_hostname(r);
      if (r->status != 200) {
        return;
      }
    }
  }
  if ((r->connection)->vhost_lookup_data) {
    if (r->hostname) {
      check_hostalias(r);
    } else {
      check_serverpath(r);
    }
  }
  return;
}
}
void ap_update_vhost_given_ip(conn_rec *conn ) 
{ ipaddr_chain *trav ;
  apr_port_t port ;

  {
  trav = find_ipaddr(conn->local_addr);
  if (trav) {
    conn->vhost_lookup_data = (void *)trav->names;
    conn->base_server = trav->server;
    return;
  }
  apr_sockaddr_port_get(& port, conn->local_addr);
  trav = find_default_server(port);
  if (trav) {
    conn->vhost_lookup_data = (void *)trav->names;
    conn->base_server = trav->server;
    return;
  }
  conn->vhost_lookup_data = (void *)0;
  return;
}
}
#pragma merger(0,"/tmp/cil-WqKLO3VT.i","-g -pthread")
extern char *strcat(char * __restrict  __dest , char const   * __restrict  __src ) ;
extern char *strncat(char * __restrict  __dest , char const   * __restrict  __src ,
                     size_t __n ) ;
extern int gethostname(char *__name , size_t __len ) ;
extern struct hostent *gethostbyname(char const   *__name ) ;
int apr_base64_encode_len(int len ) ;
int apr_base64_encode(char *encoded , char const   *string , int len ) ;
int apr_base64_decode_len(char const   *bufcoded ) ;
int apr_base64_decode(char *bufplain , char const   *bufcoded ) ;
apr_status_t apr_time_exp_gmt(apr_time_exp_t *result , apr_time_t input ) ;
apr_status_t apr_filepath_root(char const   **rootpath , char const   **inpath , apr_int32_t flags ,
                               apr_pool_t *p ) ;
apr_status_t apr_file_info_get(apr_finfo_t *finfo , apr_int32_t wanted , apr_file_t *thefile ) ;
int regcomp(regex_t *preg , char const   *pattern , int cflags ) ;
int regexec(regex_t *preg , char const   *string , size_t nmatch , regmatch_t *pmatch ,
            int eflags ) ;
size_t regerror(int errcode , regex_t const   *preg , char *errbuf , size_t errbuf_size ) ;
void regfree(regex_t *preg ) ;
char *ap_getword_white_nc(apr_pool_t *atrans , char **line ) ;
char *ap_getword_nulls_nc(apr_pool_t *atrans , char **line , char stop ) ;
char *ap_getword_conf_nc(apr_pool_t *p , char **line ) ;
char const   *ap_size_list_item(char const   **field , int *len ) ;
void ap_no2slash(char *name ) ;
char *ap_escape_path_segment(apr_pool_t *p , char const   *segment ) ;
char *ap_construct_server(apr_pool_t *p , char const   *hostname , apr_port_t port ,
                          request_rec const   *r ) ;
int ap_count_dirs(char const   *path ) ;
char *ap_make_dirstr_prefix(char *d , char const   *s , int n ) ;
char *ap_strcasestr(char const   *s1 , char const   *s2 ) ;
char const   *ap_stripprefix(char const   *bigstring , char const   *prefix ) ;
char *ap_pbase64decode(apr_pool_t *p , char const   *bufcoded ) ;
char *ap_pbase64encode(apr_pool_t *p , char *string ) ;
size_t ap_regerror(int errcode , regex_t const   *preg , char *errbuf , size_t errbuf_size ) ;
void ap_content_type_tolower(char *str ) ;
int ap_rind(char const   *s , char c ) ;
char *ap_escape_quotes(apr_pool_t *p , char const   *instring ) ;
int ap_is_directory(apr_pool_t *p , char const   *path ) ;
int ap_cfg_getc(ap_configfile_t *cfp ) ;
static unsigned char const   test_char_table[256]  = 
  {      (unsigned char const   )0,      (unsigned char const   )14,      (unsigned char const   )14,      (unsigned char const   )14, 
        (unsigned char const   )14,      (unsigned char const   )14,      (unsigned char const   )14,      (unsigned char const   )14, 
        (unsigned char const   )14,      (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )14, 
        (unsigned char const   )14,      (unsigned char const   )14,      (unsigned char const   )14,      (unsigned char const   )14, 
        (unsigned char const   )14,      (unsigned char const   )14,      (unsigned char const   )14,      (unsigned char const   )14, 
        (unsigned char const   )14,      (unsigned char const   )14,      (unsigned char const   )14,      (unsigned char const   )14, 
        (unsigned char const   )14,      (unsigned char const   )14,      (unsigned char const   )14,      (unsigned char const   )14, 
        (unsigned char const   )14,      (unsigned char const   )14,      (unsigned char const   )14,      (unsigned char const   )14, 
        (unsigned char const   )14,      (unsigned char const   )0,      (unsigned char const   )7,      (unsigned char const   )6, 
        (unsigned char const   )1,      (unsigned char const   )6,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )9,      (unsigned char const   )9,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )10, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )8,      (unsigned char const   )15, 
        (unsigned char const   )15,      (unsigned char const   )8,      (unsigned char const   )15,      (unsigned char const   )15, 
        (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )15, 
        (unsigned char const   )15,      (unsigned char const   )15,      (unsigned char const   )7,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )15, 
        (unsigned char const   )7,      (unsigned char const   )15,      (unsigned char const   )1,      (unsigned char const   )14, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6};
char *ap_field_noparam(apr_pool_t *p , char const   *intype ) 
{ char const   *semi ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;

  {
  if ((unsigned int )intype == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  }
  semi = strchr(intype, ';');
  if ((unsigned int )semi == (unsigned int )((void *)0)) {
    tmp = apr_pstrdup(p, intype);
    return (tmp);
  } else {
    while (1) {
      if ((unsigned int )semi > (unsigned int )intype) {
        tmp___0 = __ctype_b_loc();
        if (! ((int const   )(*((*tmp___0) + (int )((unsigned char )(*(semi + -1))))) &
               8192)) {
          goto _L;
        }
      } else {
        _L: 
        break;
      }
      semi --;
    }
    tmp___1 = apr_pstrndup(p, intype, (unsigned int )(semi - intype));
    return (tmp___1);
  }
}
}
char *ap_ht_time(apr_pool_t *p , apr_time_t t , char const   *fmt , int gmt ) 
{ apr_size_t retcode ;
  char ts[8192] ;
  char tf[8192] ;
  apr_time_exp_t xt ;
  char const   *f ;
  char *strp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  if (gmt) {
    apr_time_exp_gmt(& xt, t);
    strp = tf;
    f = fmt;
    while (1) {
      if ((unsigned int )strp < (unsigned int )((tf + sizeof(tf)) - 6)) {
        (*strp) = (char )(*f);
        if (! (*strp)) {
          goto _L;
        }
      } else {
        _L: 
        break;
      }
      if ((int const   )(*f) != 37) {
        goto __Cont;
      }
      switch ((int )(*(f + 1))) {
      case 37: 
      strp ++;
      f ++;
      (*strp) = (char )(*f);
      break;
      case 90: 
      tmp = strp;
      strp ++;
      (*tmp) = (char )'G';
      tmp___0 = strp;
      strp ++;
      (*tmp___0) = (char )'M';
      (*strp) = (char )'T';
      f ++;
      break;
      case 122: 
      tmp___1 = strp;
      strp ++;
      (*tmp___1) = (char )'+';
      tmp___2 = strp;
      strp ++;
      (*tmp___2) = (char )'0';
      tmp___3 = strp;
      strp ++;
      (*tmp___3) = (char )'0';
      tmp___4 = strp;
      strp ++;
      (*tmp___4) = (char )'0';
      (*strp) = (char )'0';
      f ++;
      break;
      }
      __Cont: 
      f ++;
      strp ++;
    }
    (*strp) = (char )'\000';
    fmt = (char const   *)(tf);
  } else {
    apr_time_exp_lt(& xt, t);
  }
  apr_strftime(ts, & retcode, 8192U, fmt, & xt);
  ts[8191] = (char )'\000';
  tmp___5 = apr_pstrdup(p, (char const   *)(ts));
  return (tmp___5);
}
}
int ap_strcmp_match(char const   *str , char const   *exp ) 
{ int x ;
  int y ;
  int ret ;
  int tmp ;

  {
  x = 0;
  y = 0;
  while ((*(exp + y))) {
    if (! (*(str + x))) {
      if ((int const   )(*(exp + y)) != 42) {
        return (-1);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    if ((int const   )(*(exp + y)) == 42) {
      while (1) {
        y ++;
        if (! ((int const   )(*(exp + y)) == 42)) {
          break;
        }
      }
      if (! (*(exp + y))) {
        return (0);
      }
      while ((*(str + x))) {
        tmp = x;
        x ++;
        ret = ap_strcmp_match(str + tmp, exp + y);
        if (ret != 1) {
          return (ret);
        }
      }
      return (-1);
    } else {
      if ((int const   )(*(exp + y)) != 63) {
        if ((int const   )(*(str + x)) != (int const   )(*(exp + y))) {
          return (1);
        } else {
          goto _L___0;
        }
      } else {
        _L___0: ;
      }
    }
    y ++;
    x ++;
  }
  return ((int const   )(*(str + x)) != 0);
}
}
int ap_strcasecmp_match(char const   *str , char const   *exp ) 
{ int x ;
  int y ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  x = 0;
  y = 0;
  while ((*(exp + y))) {
    if (! (*(str + x))) {
      if ((int const   )(*(exp + y)) != 42) {
        return (-1);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    if ((int const   )(*(exp + y)) == 42) {
      while (1) {
        y ++;
        if (! ((int const   )(*(exp + y)) == 42)) {
          break;
        }
      }
      if (! (*(exp + y))) {
        return (0);
      }
      while ((*(str + x))) {
        tmp = x;
        x ++;
        ret = ap_strcasecmp_match(str + tmp, exp + y);
        if (ret != 1) {
          return (ret);
        }
      }
      return (-1);
    } else {
      if ((int const   )(*(exp + y)) != 63) {
        tmp___0 = tolower((int )((unsigned char )(*(str + x))));
        tmp___1 = tolower((int )((unsigned char )(*(exp + y))));
        if (tmp___0 != tmp___1) {
          return (1);
        } else {
          goto _L___0;
        }
      } else {
        _L___0: ;
      }
    }
    y ++;
    x ++;
  }
  return ((int const   )(*(str + x)) != 0);
}
}
int ap_os_is_path_absolute(apr_pool_t *p , char const   *dir ) 
{ char const   *newpath ;
  char const   *ourdir ;
  apr_status_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  ourdir = dir;
  tmp = apr_filepath_root(& newpath, & dir, 0, p);
  if (tmp != 0) {
    goto _L;
  } else {
    tmp___0 = strlen(newpath);
    tmp___1 = strncmp(newpath, ourdir, tmp___0);
    if (tmp___1 != 0) {
      _L: 
      return (0);
    }
  }
  return (1);
}
}
int ap_is_matchexp(char const   *str ) 
{ register int x ;

  {
  x = 0;
  while ((*(str + x))) {
    if ((int const   )(*(str + x)) == 42) {
      goto _L;
    } else {
      if ((int const   )(*(str + x)) == 63) {
        _L: 
        return (1);
      }
    }
    x ++;
  }
  return (0);
}
}
static apr_status_t regex_cleanup(void *preg ) 
{ 

  {
  regfree((regex_t *)preg);
  return (0);
}
}
regex_t *ap_pregcomp(apr_pool_t *p , char const   *pattern , int cflags ) 
{ regex_t *preg ;
  regex_t *tmp ;
  int tmp___0 ;

  {
  tmp = (regex_t *)apr_palloc(p, sizeof(regex_t ));
  preg = tmp;
  tmp___0 = regcomp(preg, pattern, cflags);
  if (tmp___0) {
    return ((regex_t *)((void *)0));
  }
  apr_pool_cleanup_register(p, (void const   *)((void *)preg), & regex_cleanup, & regex_cleanup);
  return (preg);
}
}
void ap_pregfree(apr_pool_t *p , regex_t *reg ) 
{ 

  {
  regfree(reg);
  apr_pool_cleanup_kill(p, (void const   *)((void *)reg), & regex_cleanup);
  return;
}
}
char *ap_strcasestr(char const   *s1 , char const   *s2 ) 
{ char *p1 ;
  char *p2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((int const   )(*s2) == 0) {
    return ((char *)s1);
  }
  while (1) {
    while (1) {
      if ((int const   )(*s1) != 0) {
        tmp = tolower((int )((unsigned char )(*s1)));
        tmp___0 = tolower((int )((unsigned char )(*s2)));
        if (! (tmp != tmp___0)) {
          goto _L;
        }
      } else {
        _L: 
        break;
      }
      s1 ++;
    }
    if ((int const   )(*s1) == 0) {
      return ((char *)((void *)0));
    }
    p1 = (char *)s1;
    p2 = (char *)s2;
    p1 ++;
    p2 ++;
    while (1) {
      tmp___1 = tolower((int )((unsigned char )(*p1)));
      tmp___2 = tolower((int )((unsigned char )(*p2)));
      if (! (tmp___1 == tmp___2)) {
        break;
      }
      if ((int )(*p1) == 0) {
        return ((char *)s1);
      }
      p1 ++;
      p2 ++;
    }
    if ((int )(*p2) == 0) {
      break;
    }
    s1 ++;
  }
  return ((char *)s1);
}
}
char const   *ap_stripprefix(char const   *bigstring , char const   *prefix ) 
{ char const   *p1 ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  if ((int const   )(*prefix) == 0) {
    return (bigstring);
  }
  p1 = bigstring;
  while (1) {
    if ((*p1)) {
      if (! (*prefix)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
    tmp = p1;
    p1 ++;
    tmp___0 = prefix;
    prefix ++;
    if ((int const   )(*tmp) != (int const   )(*tmp___0)) {
      return (bigstring);
    }
  }
  if ((int const   )(*prefix) == 0) {
    return (p1);
  }
  return (bigstring);
}
}
int ap_regexec(regex_t *preg , char const   *string , size_t nmatch , regmatch_t *pmatch ,
               int eflags ) 
{ int tmp ;

  {
  tmp = regexec(preg, string, nmatch, pmatch, eflags);
  return (tmp);
}
}
size_t ap_regerror(int errcode , regex_t const   *preg , char *errbuf , size_t errbuf_size ) 
{ size_t tmp ;

  {
  tmp = regerror(errcode, preg, errbuf, errbuf_size);
  return (tmp);
}
}
char *ap_pregsub(apr_pool_t *p , char const   *input , char const   *source , size_t nmatch ,
                 regmatch_t *pmatch ) 
{ char const   *src ;
  char *dest ;
  char *dst ;
  char c ;
  size_t no ;
  int len ;
  char *tmp ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  void *tmp___4 ;
  char const   *tmp___5 ;
  unsigned short const   **tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;

  {
  src = input;
  if (! source) {
    return ((char *)((void *)0));
  }
  if (! nmatch) {
    tmp = apr_pstrdup(p, src);
    return (tmp);
  }
  len = 0;
  while (1) {
    tmp___3 = src;
    src ++;
    c = (char )(*tmp___3);
    if (! ((int )c != 0)) {
      break;
    }
    if ((int )c == 38) {
      no = 0U;
    } else {
      if ((int )c == 36) {
        tmp___1 = __ctype_b_loc();
        if ((int const   )(*((*tmp___1) + (int )((unsigned char )(*src)))) & 2048) {
          tmp___0 = src;
          src ++;
          no = (unsigned int )((int const   )(*tmp___0) - 48);
        } else {
          goto _L;
        }
      } else {
        _L: 
        no = 10U;
      }
    }
    if (no > 9U) {
      if ((int )c == 92) {
        if ((int const   )(*src) == 36) {
          goto _L___1;
        } else {
          if ((int const   )(*src) == 38) {
            _L___1: 
            tmp___2 = src;
            src ++;
            c = (char )(*tmp___2);
          } else {
            goto _L___0;
          }
        }
      } else {
        _L___0: ;
      }
      len ++;
    } else {
      if (no < nmatch) {
        if ((pmatch + no)->rm_so < (pmatch + no)->rm_eo) {
          len += (pmatch + no)->rm_eo - (pmatch + no)->rm_so;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: ;
      }
    }
  }
  tmp___4 = apr_palloc(p, (unsigned int )(len + 1));
  dst = (char *)memset(tmp___4, 0, (unsigned int )(len + 1));
  dest = dst;
  src = input;
  while (1) {
    tmp___9 = src;
    src ++;
    c = (char )(*tmp___9);
    if (! ((int )c != 0)) {
      break;
    }
    if ((int )c == 38) {
      no = 0U;
    } else {
      if ((int )c == 36) {
        tmp___6 = __ctype_b_loc();
        if ((int const   )(*((*tmp___6) + (int )((unsigned char )(*src)))) & 2048) {
          tmp___5 = src;
          src ++;
          no = (unsigned int )((int const   )(*tmp___5) - 48);
        } else {
          goto _L___3;
        }
      } else {
        _L___3: 
        no = 10U;
      }
    }
    if (no > 9U) {
      if ((int )c == 92) {
        if ((int const   )(*src) == 36) {
          goto _L___5;
        } else {
          if ((int const   )(*src) == 38) {
            _L___5: 
            tmp___7 = src;
            src ++;
            c = (char )(*tmp___7);
          } else {
            goto _L___4;
          }
        }
      } else {
        _L___4: ;
      }
      tmp___8 = dst;
      dst ++;
      (*tmp___8) = c;
    } else {
      if (no < nmatch) {
        if ((pmatch + no)->rm_so < (pmatch + no)->rm_eo) {
          len = (pmatch + no)->rm_eo - (pmatch + no)->rm_so;
          memcpy((void * __restrict  )dst, (void const   * __restrict  )(source +
                                                                         (pmatch +
                                                                          no)->rm_so),
                 (unsigned int )len);
          dst += len;
        } else {
          goto _L___6;
        }
      } else {
        _L___6: ;
      }
    }
  }
  (*dst) = (char )'\000';
  return (dest);
}
}
void ap_getparents(char *name ) 
{ char *next ;
  int l ;
  int w ;
  int first_dot ;
  int tmp ;
  int tmp___0 ;
  register int m ;
  register int n ;

  {
  next = name;
  while (1) {
    if ((*next)) {
      if (! ((int )(*next) != 46)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
    next ++;
  }
  first_dot = next - name;
  w = first_dot;
  l = w;
  while ((int )(*(name + l)) != 0) {
    if ((int )(*(name + l)) == 46) {
      if ((int )(*(name + (l + 1))) == 47) {
        if (l == 0) {
          goto _L___1;
        } else {
          if ((int )(*(name + (l - 1))) == 47) {
            _L___1: 
            l += 2;
          } else {
            goto _L___2;
          }
        }
      } else {
        goto _L___2;
      }
    } else {
      _L___2: 
      tmp = w;
      w ++;
      tmp___0 = l;
      l ++;
      (*(name + tmp)) = (*(name + tmp___0));
    }
  }
  if (w == 1) {
    if ((int )(*(name + 0)) == 46) {
      w --;
    } else {
      goto _L___5;
    }
  } else {
    _L___5: 
    if (w > 1) {
      if ((int )(*(name + (w - 1))) == 46) {
        if ((int )(*(name + (w - 2))) == 47) {
          w --;
        } else {
          goto _L___4;
        }
      } else {
        goto _L___4;
      }
    } else {
      _L___4: ;
    }
  }
  (*(name + w)) = (char )'\000';
  l = first_dot;
  while ((int )(*(name + l)) != 0) {
    if ((int )(*(name + l)) == 46) {
      if ((int )(*(name + (l + 1))) == 46) {
        if ((int )(*(name + (l + 2))) == 47) {
          if (l == 0) {
            goto _L___8;
          } else {
            if ((int )(*(name + (l - 1))) == 47) {
              _L___8: 
              m = l + 3;
              l = l - 2;
              if (l >= 0) {
                while (1) {
                  if (l >= 0) {
                    if (! (! ((int )(*(name + l)) == 47))) {
                      goto _L___6;
                    }
                  } else {
                    _L___6: 
                    break;
                  }
                  l --;
                }
                l ++;
              } else {
                l = 0;
              }
              n = l;
              while (1) {
                (*(name + n)) = (*(name + m));
                if (! (*(name + n))) {
                  break;
                }
                n ++;
                m ++;
              }
            } else {
              goto _L___10;
            }
          }
        } else {
          goto _L___10;
        }
      } else {
        goto _L___10;
      }
    } else {
      _L___10: 
      l ++;
    }
  }
  if (l == 2) {
    if ((int )(*(name + 0)) == 46) {
      if ((int )(*(name + 1)) == 46) {
        (*(name + 0)) = (char )'\000';
      } else {
        goto _L___16;
      }
    } else {
      goto _L___16;
    }
  } else {
    _L___16: 
    if (l > 2) {
      if ((int )(*(name + (l - 1))) == 46) {
        if ((int )(*(name + (l - 2))) == 46) {
          if ((int )(*(name + (l - 3))) == 47) {
            l = l - 4;
            if (l >= 0) {
              while (1) {
                if (l >= 0) {
                  if (! (! ((int )(*(name + l)) == 47))) {
                    goto _L___11;
                  }
                } else {
                  _L___11: 
                  break;
                }
                l --;
              }
              l ++;
            } else {
              l = 0;
            }
            (*(name + l)) = (char )'\000';
          } else {
            goto _L___14;
          }
        } else {
          goto _L___14;
        }
      } else {
        goto _L___14;
      }
    } else {
      _L___14: ;
    }
  }
  return;
}
}
void ap_no2slash(char *name ) 
{ char *d ;
  char *s ;
  char *tmp ;

  {
  d = name;
  s = d;
  while ((*s)) {
    tmp = d;
    d ++;
    (*tmp) = (*s);
    if ((int )(*tmp) == 47) {
      while (1) {
        s ++;
        if (! ((int )(*s) == 47)) {
          break;
        }
      }
    } else {
      s ++;
    }
  }
  (*d) = (char )'\000';
  return;
}
}
char *ap_make_dirstr_prefix(char *d , char const   *s , int n ) 
{ char *tmp ;
  char const   *tmp___0 ;

  {
  if (n < 1) {
    (*d) = (char )'/';
    d ++;
    (*d) = (char )'\000';
    return (d);
  }
  while (1) {
    if ((int const   )(*s) == 0) {
      goto _L;
    } else {
      if ((int const   )(*s) == 47) {
        n --;
        if (n == 0) {
          _L: 
          (*d) = (char )'/';
          break;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: ;
      }
    }
    tmp = d;
    d ++;
    tmp___0 = s;
    s ++;
    (*tmp) = (char )(*tmp___0);
  }
  d ++;
  (*d) = (char)0;
  return (d);
}
}
char *ap_make_dirstr_parent(apr_pool_t *p , char const   *s ) 
{ char const   *last_slash ;
  char const   *tmp ;
  char *d ;
  int l ;
  char *tmp___0 ;

  {
  tmp = strrchr(s, '/');
  last_slash = tmp;
  if ((unsigned int )last_slash == (unsigned int )((void *)0)) {
    tmp___0 = apr_pstrdup(p, "");
    return (tmp___0);
  }
  l = (last_slash - s) + 1;
  d = (char *)apr_palloc(p, (unsigned int )(l + 1));
  memcpy((void * __restrict  )d, (void const   * __restrict  )s, (unsigned int )l);
  (*(d + l)) = (char)0;
  return (d);
}
}
int ap_count_dirs(char const   *path ) 
{ register int x ;
  register int n ;

  {
  x = 0;
  n = 0;
  while ((*(path + x))) {
    if ((int const   )(*(path + x)) == 47) {
      n ++;
    }
    x ++;
  }
  return (n);
}
}
char *ap_getword_nc(apr_pool_t *atrans , char **line , char stop ) 
{ char *tmp ;

  {
  tmp = ap_getword(atrans, (char const   **)line, stop);
  return (tmp);
}
}
char *ap_getword(apr_pool_t *atrans , char const   **line , char stop ) 
{ char const   *pos ;
  int len ;
  char *res ;

  {
  pos = (*line);
  while (1) {
    if ((int const   )(*pos) != (int const   )stop) {
      if (! (*pos)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
    pos ++;
  }
  len = pos - (*line);
  res = (char *)apr_palloc(atrans, (unsigned int )(len + 1));
  memcpy((void * __restrict  )res, (void const   * __restrict  )(*line), (unsigned int )len);
  (*(res + len)) = (char)0;
  if (stop) {
    while ((int const   )(*pos) == (int const   )stop) {
      pos ++;
    }
  }
  (*line) = pos;
  return (res);
}
}
char *ap_getword_white_nc(apr_pool_t *atrans , char **line ) 
{ char *tmp ;

  {
  tmp = ap_getword_white(atrans, (char const   **)line);
  return (tmp);
}
}
char *ap_getword_white(apr_pool_t *atrans , char const   **line ) 
{ char const   *pos ;
  int len ;
  char *res ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___1 ;

  {
  pos = (*line);
  while (1) {
    tmp = __ctype_b_loc();
    if ((int const   )(*((*tmp) + (int )((unsigned char )(*pos)))) & 8192) {
      _L: 
      break;
    } else {
      if (! (*pos)) {
        goto _L;
      }
    }
    pos ++;
  }
  len = pos - (*line);
  res = (char *)apr_palloc(atrans, (unsigned int )(len + 1));
  memcpy((void * __restrict  )res, (void const   * __restrict  )(*line), (unsigned int )len);
  (*(res + len)) = (char)0;
  while (1) {
    tmp___1 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___1) + (int )((unsigned char )(*pos)))) & 8192)) {
      break;
    }
    pos ++;
  }
  (*line) = pos;
  return (res);
}
}
char *ap_getword_nulls_nc(apr_pool_t *atrans , char **line , char stop ) 
{ char *tmp ;

  {
  tmp = ap_getword_nulls(atrans, (char const   **)line, stop);
  return (tmp);
}
}
char *ap_getword_nulls(apr_pool_t *atrans , char const   **line , char stop ) 
{ char const   *pos ;
  char const   *tmp ;
  char *res ;
  size_t tmp___0 ;

  {
  tmp = strchr((*line), (int )stop);
  pos = tmp;
  if (! pos) {
    res = apr_pstrdup(atrans, (*line));
    tmp___0 = strlen((*line));
    (*line) += tmp___0;
    return (res);
  }
  res = apr_pstrndup(atrans, (*line), (unsigned int )(pos - (*line)));
  pos ++;
  (*line) = pos;
  return (res);
}
}
static char *substring_conf(apr_pool_t *p , char const   *start , int len , char quote ) 
{ char *result ;
  char *tmp ;
  char *resp ;
  int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  tmp = (char *)apr_palloc(p, (unsigned int )(len + 2));
  result = tmp;
  resp = result;
  i = 0;
  while (i < len) {
    if ((int const   )(*(start + i)) == 92) {
      if ((int const   )(*(start + (i + 1))) == 92) {
        goto _L___0;
      } else {
        if (quote) {
          if ((int const   )(*(start + (i + 1))) == (int const   )quote) {
            _L___0: 
            tmp___0 = resp;
            resp ++;
            i ++;
            (*tmp___0) = (char )(*(start + i));
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          goto _L;
        }
      }
    } else {
      _L: 
      tmp___1 = resp;
      resp ++;
      (*tmp___1) = (char )(*(start + i));
    }
    i ++;
  }
  tmp___2 = resp;
  resp ++;
  (*tmp___2) = (char )'\000';
  return (result);
}
}
char *ap_getword_conf_nc(apr_pool_t *p , char **line ) 
{ char *tmp ;

  {
  tmp = ap_getword_conf(p, (char const   **)line);
  return (tmp);
}
}
char *ap_getword_conf(apr_pool_t *p , char const   **line ) 
{ char const   *str ;
  char const   *strend ;
  char *res ;
  char quote ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  str = (*line);
  while (1) {
    if ((*str)) {
      tmp = __ctype_b_loc();
      if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*str)))) & 8192)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
    str ++;
  }
  if (! (*str)) {
    (*line) = str;
    return ((char *)"");
  }
  quote = (char )(*str);
  if ((int )quote == 34) {
    goto _L___4;
  } else {
    if ((int )quote == 39) {
      _L___4: 
      strend = str + 1;
      while (1) {
        if ((*strend)) {
          if (! ((int const   )(*strend) != (int const   )quote)) {
            goto _L___2;
          }
        } else {
          _L___2: 
          break;
        }
        if ((int const   )(*strend) == 92) {
          if ((*(strend + 1))) {
            if ((int const   )(*(strend + 1)) == (int const   )quote) {
              strend += 2;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          strend ++;
        }
      }
      res = substring_conf(p, str + 1, (strend - str) - 1, quote);
      if ((int const   )(*strend) == (int const   )quote) {
        strend ++;
      }
    } else {
      strend = str;
      while (1) {
        if ((*strend)) {
          tmp___0 = __ctype_b_loc();
          if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*strend)))) &
              8192) {
            goto _L___3;
          }
        } else {
          _L___3: 
          break;
        }
        strend ++;
      }
      res = substring_conf(p, str, strend - str, (char)0);
    }
  }
  while (1) {
    if ((*strend)) {
      tmp___1 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___1) + (int )((unsigned char )(*strend)))) & 8192)) {
        goto _L___5;
      }
    } else {
      _L___5: 
      break;
    }
    strend ++;
  }
  (*line) = strend;
  return (res);
}
}
char const   *ap_resolve_env(apr_pool_t *p , char const   *word ) 
{ char tmp[8192] ;
  char const   *s ;
  char const   *e ;
  char const   *e2 ;
  char const   *tmp___0 ;

  {
  tmp[0] = (char )'\000';
  s = strchr(word, '$');
  if (! s) {
    return (word);
  }
  while (1) {
    strncat((char * __restrict  )(tmp), (char const   * __restrict  )word, (unsigned int )(s -
                                                                                           word));
    if ((int const   )(*(s + 1)) == 123) {
      e = strchr(s, '}');
      if (e) {
        e2 = e;
        word = e + 1;
        e = getenv(s + 2);
        if (e) {
          strcat((char * __restrict  )(tmp), (char const   * __restrict  )e);
        } else {
          strncat((char * __restrict  )(tmp), (char const   * __restrict  )s, (unsigned int )(e2 -
                                                                                              s));
          strcat((char * __restrict  )(tmp), (char const   * __restrict  )"}");
        }
      } else {
        goto _L;
      }
    } else {
      _L: 
      word = s + 1;
      strcat((char * __restrict  )(tmp), (char const   * __restrict  )"$");
    }
    s = strchr(word, '$');
    if (! s) {
      break;
    }
  }
  strcat((char * __restrict  )(tmp), (char const   * __restrict  )word);
  tmp___0 = apr_pstrdup(p, (char const   *)(tmp));
  return (tmp___0);
}
}
int ap_cfg_closefile(ap_configfile_t *cfp ) 
{ int tmp___0 ;

  {
  if ((unsigned int )cfp->close == (unsigned int )((void *)0)) {
    tmp___0 = 0;
  } else {
    tmp___0 = ((*(cfp->close)))(cfp->param);
  }
  return (tmp___0);
}
}
static apr_status_t cfg_close(void *param ) 
{ apr_file_t *cfp ;
  apr_status_t tmp ;

  {
  cfp = (apr_file_t *)param;
  tmp = apr_file_close(cfp);
  return (tmp);
}
}
static int cfg_getch(void *param ) 
{ char ch ;
  apr_file_t *cfp ;
  apr_status_t tmp ;

  {
  cfp = (apr_file_t *)param;
  tmp = apr_file_getc(& ch, cfp);
  if (tmp == 0) {
    return ((int )ch);
  }
  return (-1);
}
}
static void *cfg_getstr(void *buf , size_t bufsiz , void *param ) 
{ apr_file_t *cfp ;
  apr_status_t rv ;
  int tmp ;

  {
  cfp = (apr_file_t *)param;
  rv = apr_file_gets((char *)buf, (int )bufsiz, cfp);
  if (rv == 0) {
    goto _L;
  } else {
    if (rv == 70014) {
      tmp = strcmp((char const   *)buf, "");
      if (tmp) {
        _L: 
        return (buf);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
  }
  return ((void *)0);
}
}
apr_status_t ap_pcfg_openfile(ap_configfile_t **ret_cfg , apr_pool_t *p , char const   *name ) 
{ ap_configfile_t *new_cfg ;
  apr_file_t *file ;
  apr_finfo_t finfo ;
  apr_status_t status ;
  int tmp ;

  {
  file = (apr_file_t *)((void *)0);
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    ap_log_error("util.c", 905, 3, 0, (server_rec const   *)((void *)0), "Internal error: pcfg_openfile() called with NULL filename");
    return (9);
  }
  status = apr_file_open(& file, name, 129, 4095, p);
  if (status != 0) {
    return (status);
  }
  status = apr_file_info_get(& finfo, 32768, file);
  if (status != 0) {
    return (status);
  }
  if ((int )finfo.filetype != 1) {
    tmp = strcmp(name, "/dev/null");
    if (tmp != 0) {
      ap_log_error("util.c", 931, 3, 0, (server_rec const   *)((void *)0), "Access to file %s denied by server: not a regular file",
                   name);
      apr_file_close(file);
      return (9);
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  new_cfg = (ap_configfile_t *)apr_palloc(p, sizeof((*new_cfg)));
  new_cfg->param = (void *)file;
  new_cfg->name = apr_pstrdup(p, name);
  new_cfg->getch = & cfg_getch;
  new_cfg->getstr = & cfg_getstr;
  new_cfg->close = & cfg_close;
  new_cfg->line_number = 0U;
  (*ret_cfg) = new_cfg;
  return (0);
}
}
ap_configfile_t *ap_pcfg_open_custom(apr_pool_t *p , char const   *descr , void *param ,
                                     int (*getch)(void *param ) , void *(*getstr)(void *buf ,
                                                                                  size_t bufsiz ,
                                                                                  void *param ) ,
                                     int (*close_func)(void *param ) ) 
{ ap_configfile_t *new_cfg ;
  ap_configfile_t *tmp ;

  {
  tmp = (ap_configfile_t *)apr_palloc(p, sizeof((*new_cfg)));
  new_cfg = tmp;
  new_cfg->param = param;
  new_cfg->name = descr;
  new_cfg->getch = getch;
  new_cfg->getstr = getstr;
  new_cfg->close = close_func;
  new_cfg->line_number = 0U;
  return (new_cfg);
}
}
int ap_cfg_getc(ap_configfile_t *cfp ) 
{ register int ch ;
  int tmp ;

  {
  tmp = ((*(cfp->getch)))(cfp->param);
  ch = tmp;
  if (ch == 10) {
    cfp->line_number = cfp->line_number + 1U;
  }
  return (ch);
}
}
int ap_cfg_getline(char *buf , size_t bufsize , ap_configfile_t *cfp ) 
{ char *src ;
  char *dst ;
  char *cp ;
  char *cbuf ;
  size_t cbufsize ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  register int c ;
  register size_t i ;
  size_t tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
  if ((unsigned int )cfp->getstr != (unsigned int )((void *)0)) {
    cbuf = buf;
    cbufsize = bufsize;
    while (1) {
      cfp->line_number = cfp->line_number + 1U;
      tmp = ((*(cfp->getstr)))((void *)cbuf, cbufsize, cfp->param);
      if ((unsigned int )tmp == (unsigned int )((void *)0)) {
        return (1);
      }
      cp = cbuf;
      while (1) {
        if ((unsigned int )cp < (unsigned int )(cbuf + cbufsize)) {
          if (! ((int )(*cp) != 0)) {
            goto _L;
          }
        } else {
          _L: 
          break;
        }
        cp ++;
      }
      if ((unsigned int )cp > (unsigned int )cbuf) {
        if ((int )(*(cp + -1)) == 10) {
          cp --;
          if ((unsigned int )cp > (unsigned int )cbuf) {
            if ((int )(*(cp + -1)) == 13) {
              cp --;
            } else {
              goto _L___0;
            }
          } else {
            _L___0: ;
          }
          if ((unsigned int )cp > (unsigned int )cbuf) {
            if ((int )(*(cp + -1)) == 92) {
              cp --;
              if ((unsigned int )cp > (unsigned int )cbuf) {
                if ((int )(*(cp + -1)) == 92) {
                  while (1) {
                    if ((unsigned int )cp < (unsigned int )(cbuf + cbufsize)) {
                      if (! ((int )(*cp) != 0)) {
                        goto _L___1;
                      }
                    } else {
                      _L___1: 
                      break;
                    }
                    (*(cp + 0)) = (*(cp + 1));
                    cp ++;
                  }
                } else {
                  goto _L___2;
                }
              } else {
                _L___2: 
                cbufsize -= (unsigned int )(cp - cbuf);
                cbuf = cp;
                continue;
              }
            } else {
              goto _L___3;
            }
          } else {
            _L___3: ;
          }
        } else {
          goto _L___4;
        }
      } else {
        _L___4: ;
      }
      break;
    }
    src = buf;
    while (1) {
      tmp___0 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___0) + (int )((unsigned char )(*src)))) & 8192)) {
        break;
      }
      src ++;
    }
    tmp___1 = strlen((char const   *)src);
    dst = src + tmp___1;
    while (1) {
      dst --;
      if ((unsigned int )dst >= (unsigned int )src) {
        tmp___2 = __ctype_b_loc();
        if (! ((int const   )(*((*tmp___2) + (int )((unsigned char )(*dst)))) & 8192)) {
          goto _L___5;
        }
      } else {
        _L___5: 
        break;
      }
      (*dst) = (char )'\000';
    }
    if ((unsigned int )src != (unsigned int )buf) {
      dst = buf;
      while (1) {
        tmp___3 = dst;
        dst ++;
        tmp___4 = src;
        src ++;
        (*tmp___3) = (*tmp___4);
        if (! ((int )(*tmp___3) != 0)) {
          break;
        }
      }
    }
    return (0);
  } else {
    i = 0U;
    (*(buf + 0)) = (char )'\000';
    while (1) {
      c = ((*(cfp->getch)))(cfp->param);
      if (c == 9) {
        goto _L___6;
      } else {
        if (c == 32) {
          _L___6: ;
        } else {
          break;
        }
      }
    }
    if (c == -1) {
      return (1);
    }
    if (bufsize < 2U) {
      return (1);
    }
    while (1) {
      if (c == 9) {
        goto _L___8;
      } else {
        if (c == 32) {
          _L___8: 
          tmp___5 = i;
          i ++;
          (*(buf + tmp___5)) = (char )' ';
          while (1) {
            if (c == 9) {
              goto _L___7;
            } else {
              if (c == 32) {
                _L___7: ;
              } else {
                break;
              }
            }
            c = ((*(cfp->getch)))(cfp->param);
          }
        }
      }
      if (c == 13) {
        c = ((*(cfp->getch)))(cfp->param);
      }
      if (c == 10) {
        cfp->line_number = cfp->line_number + 1U;
      }
      if (c == -1) {
        goto _L___14;
      } else {
        if (c == 4) {
          _L___14: 
          goto _L___13;
        } else {
          if (c == 10) {
            _L___13: 
            goto _L___12;
          } else {
            if (i >= bufsize - 2U) {
              _L___12: 
              if (i > 0U) {
                if ((int )(*(buf + (i - 1U))) == 92) {
                  i --;
                  if (i > 0U) {
                    if (! ((int )(*(buf + (i - 1U))) == 92)) {
                      goto _L___9;
                    }
                  } else {
                    _L___9: 
                    c = ((*(cfp->getch)))(cfp->param);
                    continue;
                  }
                } else {
                  goto _L___10;
                }
              } else {
                _L___10: ;
              }
              while (1) {
                if (i > 0U) {
                  tmp___6 = __ctype_b_loc();
                  if (! ((int const   )(*((*tmp___6) + (int )((unsigned char )(*(buf +
                                                                                 (i -
                                                                                  1U)))))) &
                         8192)) {
                    goto _L___11;
                  }
                } else {
                  _L___11: 
                  break;
                }
                i --;
              }
              (*(buf + i)) = (char )'\000';
              return (0);
            }
          }
        }
      }
      (*(buf + i)) = (char )c;
      i ++;
      c = ((*(cfp->getch)))(cfp->param);
    }
  }
  return (0);
}
}
char const   *ap_size_list_item(char const   **field , int *len ) 
{ unsigned char const   *ptr ;
  unsigned char const   *token ;
  int in_qpair ;
  int in_qstr ;
  int in_com ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  ptr = (unsigned char const   *)(*field);
  while (1) {
    if ((int const   )(*ptr) == 44) {
      goto _L;
    } else {
      tmp = __ctype_b_loc();
      if ((int const   )(*((*tmp) + (int )((unsigned char )(*ptr)))) & 8192) {
        _L: ;
      } else {
        break;
      }
    }
    ptr ++;
  }
  token = ptr;
  in_com = 0;
  in_qstr = in_com;
  in_qpair = in_qstr;
  while (1) {
    if ((*ptr)) {
      if (in_qpair) {
        goto _L___3;
      } else {
        if (in_qstr) {
          _L___3: 
          goto _L___2;
        } else {
          if (in_com) {
            _L___2: 
            goto _L___1;
          } else {
            if ((int const   )(*ptr) != 44) {
              _L___1: ;
            } else {
              goto _L___0;
            }
          }
        }
      }
    } else {
      _L___0: 
      break;
    }
    if (in_qpair) {
      in_qpair = 0;
    } else {
      switch ((int )(*ptr)) {
      case 92: 
      in_qpair = 1;
      break;
      case 34: ;
      if (! in_com) {
        in_qstr = (! in_qstr != 0) != 0;
      }
      break;
      case 40: ;
      if (! in_qstr) {
        in_com ++;
      }
      break;
      case 41: ;
      if (in_com) {
        in_com --;
      }
      break;
      default: ;
      break;
      }
    }
    ptr ++;
  }
  (*len) = ptr - token;
  if ((*len) == 0) {
    (*field) = (char const   *)ptr;
    return ((char const   *)((void *)0));
  }
  while (1) {
    if ((int const   )(*ptr) == 44) {
      goto _L___4;
    } else {
      tmp___0 = __ctype_b_loc();
      if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*ptr)))) & 8192) {
        _L___4: ;
      } else {
        break;
      }
    }
    ptr ++;
  }
  (*field) = (char const   *)ptr;
  return ((char const   *)token);
}
}
char *ap_get_list_item(apr_pool_t *p , char const   **field ) 
{ char const   *tok_start ;
  unsigned char const   *ptr ;
  unsigned char *pos ;
  char *token ;
  int addspace ;
  int in_qpair ;
  int in_qstr ;
  int in_com ;
  int tok_len ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;

  {
  addspace = 0;
  in_qpair = 0;
  in_qstr = 0;
  in_com = 0;
  tok_len = 0;
  tok_start = ap_size_list_item(field, & tok_len);
  if ((unsigned int )tok_start == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  }
  token = (char *)apr_palloc(p, (unsigned int )(tok_len + 1));
  ptr = (unsigned char const   *)tok_start;
  pos = (unsigned char *)token;
  while (1) {
    if ((*ptr)) {
      if (in_qpair) {
        goto _L___5;
      } else {
        if (in_qstr) {
          _L___5: 
          goto _L___4;
        } else {
          if (in_com) {
            _L___4: 
            goto _L___3;
          } else {
            if ((int const   )(*ptr) != 44) {
              _L___3: ;
            } else {
              goto _L___2;
            }
          }
        }
      }
    } else {
      _L___2: 
      break;
    }
    if (in_qpair) {
      in_qpair = 0;
      tmp = pos;
      pos ++;
      (*tmp) = (unsigned char )(*ptr);
    } else {
      switch ((int )(*ptr)) {
      case 92: 
      in_qpair = 1;
      if (addspace == 1) {
        tmp___0 = pos;
        pos ++;
        (*tmp___0) = (unsigned char )' ';
      }
      tmp___1 = pos;
      pos ++;
      (*tmp___1) = (unsigned char )(*ptr);
      addspace = 0;
      break;
      case 34: ;
      if (! in_com) {
        in_qstr = (! in_qstr != 0) != 0;
      }
      if (addspace == 1) {
        tmp___2 = pos;
        pos ++;
        (*tmp___2) = (unsigned char )' ';
      }
      tmp___3 = pos;
      pos ++;
      (*tmp___3) = (unsigned char )(*ptr);
      addspace = 0;
      break;
      case 40: ;
      if (! in_qstr) {
        in_com ++;
      }
      if (addspace == 1) {
        tmp___4 = pos;
        pos ++;
        (*tmp___4) = (unsigned char )' ';
      }
      tmp___5 = pos;
      pos ++;
      (*tmp___5) = (unsigned char )(*ptr);
      addspace = 0;
      break;
      case 41: ;
      if (in_com) {
        in_com --;
      }
      tmp___6 = pos;
      pos ++;
      (*tmp___6) = (unsigned char )(*ptr);
      addspace = 0;
      break;
      case 32: ;
      case 9: ;
      if (addspace) {
        break;
      }
      if (in_com) {
        goto _L;
      } else {
        if (in_qstr) {
          _L: 
          tmp___7 = pos;
          pos ++;
          (*tmp___7) = (unsigned char )(*ptr);
        } else {
          addspace = 1;
        }
      }
      break;
      case 61: ;
      case 47: ;
      case 59: ;
      if (in_com) {
        goto _L___0;
      } else {
        if (in_qstr) {
          _L___0: ;
        } else {
          addspace = -1;
        }
      }
      tmp___8 = pos;
      pos ++;
      (*tmp___8) = (unsigned char )(*ptr);
      break;
      default: ;
      if (addspace == 1) {
        tmp___9 = pos;
        pos ++;
        (*tmp___9) = (unsigned char )' ';
      }
      tmp___10 = pos;
      pos ++;
      if (in_com) {
        goto _L___1;
      } else {
        if (in_qstr) {
          _L___1: 
          (*tmp___10) = (unsigned char )(*ptr);
        } else {
          (*tmp___10) = (unsigned char )tolower((int )((unsigned char )(*ptr)));
        }
      }
      addspace = 0;
      break;
      }
    }
    ptr ++;
  }
  (*pos) = (unsigned char )'\000';
  return (token);
}
}
int ap_find_list_item(apr_pool_t *p , char const   *line , char const   *tok ) 
{ unsigned char const   *pos ;
  unsigned char const   *ptr ;
  int good ;
  int addspace ;
  int in_qpair ;
  int in_qstr ;
  int in_com ;
  unsigned short const   **tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;
  unsigned char const   *tmp___3 ;
  int tmp___4 ;
  unsigned char const   *tmp___5 ;
  int tmp___6 ;
  unsigned char const   *tmp___7 ;
  int tmp___8 ;
  unsigned char const   *tmp___9 ;
  int tmp___10 ;
  unsigned char const   *tmp___11 ;
  int tmp___12 ;
  unsigned char const   *tmp___13 ;
  int tmp___14 ;
  unsigned char const   *tmp___15 ;
  unsigned char const   *tmp___16 ;
  int tmp___17 ;
  unsigned char const   *tmp___18 ;
  unsigned char const   *tmp___19 ;
  int tmp___20 ;
  unsigned char const   *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
  ptr = (unsigned char const   *)line;
  good = 0;
  addspace = 0;
  in_qpair = 0;
  in_qstr = 0;
  in_com = 0;
  if (! line) {
    goto _L;
  } else {
    if (! tok) {
      _L: 
      return (0);
    }
  }
  while (1) {
    while (1) {
      if ((int const   )(*ptr) == 44) {
        goto _L___0;
      } else {
        tmp = __ctype_b_loc();
        if ((int const   )(*((*tmp) + (int )((unsigned char )(*ptr)))) & 8192) {
          _L___0: ;
        } else {
          break;
        }
      }
      ptr ++;
    }
    if ((*ptr)) {
      good = 1;
    } else {
      break;
    }
    pos = (unsigned char const   *)tok;
    while (1) {
      if ((*ptr)) {
        if (in_qpair) {
          goto _L___18;
        } else {
          if (in_qstr) {
            _L___18: 
            goto _L___17;
          } else {
            if (in_com) {
              _L___17: 
              goto _L___16;
            } else {
              if ((int const   )(*ptr) != 44) {
                _L___16: ;
              } else {
                goto _L___15;
              }
            }
          }
        }
      } else {
        _L___15: 
        break;
      }
      if (in_qpair) {
        in_qpair = 0;
        if (good) {
          tmp___0 = pos;
          pos ++;
          good = (int const   )(*tmp___0) == (int const   )(*ptr);
        }
      } else {
        switch ((int )(*ptr)) {
        case 92: 
        in_qpair = 1;
        if (addspace == 1) {
          if (good) {
            tmp___1 = pos;
            pos ++;
            if ((int const   )(*tmp___1) == 32) {
              tmp___2 = 1;
            } else {
              goto _L___1;
            }
          } else {
            _L___1: 
            tmp___2 = 0;
          }
          good = tmp___2;
        }
        if (good) {
          tmp___3 = pos;
          pos ++;
          if ((int const   )(*tmp___3) == (int const   )(*ptr)) {
            tmp___4 = 1;
          } else {
            goto _L___2;
          }
        } else {
          _L___2: 
          tmp___4 = 0;
        }
        good = tmp___4;
        addspace = 0;
        break;
        case 34: ;
        if (! in_com) {
          in_qstr = (! in_qstr != 0) != 0;
        }
        if (addspace == 1) {
          if (good) {
            tmp___5 = pos;
            pos ++;
            if ((int const   )(*tmp___5) == 32) {
              tmp___6 = 1;
            } else {
              goto _L___3;
            }
          } else {
            _L___3: 
            tmp___6 = 0;
          }
          good = tmp___6;
        }
        if (good) {
          tmp___7 = pos;
          pos ++;
          if ((int const   )(*tmp___7) == (int const   )(*ptr)) {
            tmp___8 = 1;
          } else {
            goto _L___4;
          }
        } else {
          _L___4: 
          tmp___8 = 0;
        }
        good = tmp___8;
        addspace = 0;
        break;
        case 40: ;
        if (! in_qstr) {
          in_com ++;
        }
        if (addspace == 1) {
          if (good) {
            tmp___9 = pos;
            pos ++;
            if ((int const   )(*tmp___9) == 32) {
              tmp___10 = 1;
            } else {
              goto _L___5;
            }
          } else {
            _L___5: 
            tmp___10 = 0;
          }
          good = tmp___10;
        }
        if (good) {
          tmp___11 = pos;
          pos ++;
          if ((int const   )(*tmp___11) == (int const   )(*ptr)) {
            tmp___12 = 1;
          } else {
            goto _L___6;
          }
        } else {
          _L___6: 
          tmp___12 = 0;
        }
        good = tmp___12;
        addspace = 0;
        break;
        case 41: ;
        if (in_com) {
          in_com --;
        }
        if (good) {
          tmp___13 = pos;
          pos ++;
          if ((int const   )(*tmp___13) == (int const   )(*ptr)) {
            tmp___14 = 1;
          } else {
            goto _L___7;
          }
        } else {
          _L___7: 
          tmp___14 = 0;
        }
        good = tmp___14;
        addspace = 0;
        break;
        case 32: ;
        case 9: ;
        if (addspace) {
          goto _L___8;
        } else {
          if (! good) {
            _L___8: 
            break;
          }
        }
        if (in_com) {
          goto _L___9;
        } else {
          if (in_qstr) {
            _L___9: 
            tmp___15 = pos;
            pos ++;
            good = (int const   )(*tmp___15) == (int const   )(*ptr);
          } else {
            addspace = 1;
          }
        }
        break;
        case 61: ;
        case 47: ;
        case 59: ;
        if (in_com) {
          goto _L___10;
        } else {
          if (in_qstr) {
            _L___10: ;
          } else {
            addspace = -1;
          }
        }
        if (good) {
          tmp___16 = pos;
          pos ++;
          if ((int const   )(*tmp___16) == (int const   )(*ptr)) {
            tmp___17 = 1;
          } else {
            goto _L___11;
          }
        } else {
          _L___11: 
          tmp___17 = 0;
        }
        good = tmp___17;
        break;
        default: ;
        if (! good) {
          break;
        }
        if (addspace == 1) {
          tmp___18 = pos;
          pos ++;
          good = (int const   )(*tmp___18) == 32;
        }
        if (in_com) {
          goto _L___14;
        } else {
          if (in_qstr) {
            _L___14: 
            if (good) {
              tmp___19 = pos;
              pos ++;
              if ((int const   )(*tmp___19) == (int const   )(*ptr)) {
                tmp___20 = 1;
              } else {
                goto _L___12;
              }
            } else {
              _L___12: 
              tmp___20 = 0;
            }
            good = tmp___20;
          } else {
            if (good) {
              tmp___21 = pos;
              pos ++;
              tmp___22 = tolower((int )((unsigned char )(*ptr)));
              if ((int const   )(*tmp___21) == (int const   )tmp___22) {
                tmp___23 = 1;
              } else {
                goto _L___13;
              }
            } else {
              _L___13: 
              tmp___23 = 0;
            }
            good = tmp___23;
          }
        }
        addspace = 0;
        break;
        }
      }
      ptr ++;
    }
    if (good) {
      if ((*pos)) {
        good = 0;
      } else {
        goto _L___19;
      }
    } else {
      _L___19: ;
    }
    if ((*ptr)) {
      if (! (! good)) {
        goto _L___20;
      }
    } else {
      _L___20: 
      break;
    }
  }
  return (good);
}
}
char *ap_get_token(apr_pool_t *p , char const   **accept_line , int accept_white ) 
{ char const   *ptr ;
  char const   *tok_start ;
  char *token ;
  int tok_len ;
  unsigned short const   **tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  ptr = (*accept_line);
  while (1) {
    if ((*ptr)) {
      tmp = __ctype_b_loc();
      if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*ptr)))) & 8192)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
    ptr ++;
  }
  tok_start = ptr;
  while (1) {
    if ((*ptr)) {
      if (accept_white) {
        goto _L___3;
      } else {
        tmp___2 = __ctype_b_loc();
        if ((int const   )(*((*tmp___2) + (int )((unsigned char )(*ptr)))) & 8192) {
          goto _L___2;
        } else {
          _L___3: 
          if ((int const   )(*ptr) != 59) {
            if (! ((int const   )(*ptr) != 44)) {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        }
      }
    } else {
      _L___2: 
      break;
    }
    tmp___1 = ptr;
    ptr ++;
    if ((int const   )(*tmp___1) == 34) {
      while ((*ptr)) {
        tmp___0 = ptr;
        ptr ++;
        if ((int const   )(*tmp___0) == 34) {
          break;
        }
      }
    }
  }
  tok_len = ptr - tok_start;
  token = apr_pstrndup(p, tok_start, (unsigned int )tok_len);
  while (1) {
    if ((*ptr)) {
      tmp___3 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___3) + (int )((unsigned char )(*ptr)))) & 8192)) {
        goto _L___4;
      }
    } else {
      _L___4: 
      break;
    }
    ptr ++;
  }
  (*accept_line) = ptr;
  return (token);
}
}
int ap_find_token(apr_pool_t *p , char const   *line , char const   *tok ) 
{ unsigned char const   *start_token ;
  unsigned char const   *s ;
  int tmp ;

  {
  if (! line) {
    return (0);
  }
  s = (unsigned char const   *)line;
  while (1) {
    while ((int const   )test_char_table[(unsigned int )(*s)] & 8) {
      s ++;
    }
    if (! (*s)) {
      return (0);
    }
    start_token = s;
    while (1) {
      if ((*s)) {
        if (! (! ((int const   )test_char_table[(unsigned int )(*s)] & 8))) {
          goto _L;
        }
      } else {
        _L: 
        break;
      }
      s ++;
    }
    tmp = strncasecmp((char const   *)start_token, tok, (unsigned int )(s - start_token));
    if (! tmp) {
      return (1);
    }
    if (! (*s)) {
      return (0);
    }
  }
  return (0);
}
}
int ap_find_last_token(apr_pool_t *p , char const   *line , char const   *tok ) 
{ int llen ;
  int tlen ;
  int lidx ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  if (! line) {
    return (0);
  }
  llen = (int )strlen(line);
  tlen = (int )strlen(tok);
  lidx = llen - tlen;
  if (lidx < 0) {
    goto _L;
  } else {
    if (lidx > 0) {
      tmp = __ctype_b_loc();
      if ((int const   )(*((*tmp) + (int )((unsigned char )(*(line + (lidx - 1)))))) &
          8192) {
        goto _L___1;
      } else {
        if ((int const   )(*(line + (lidx - 1))) == 44) {
          _L___1: 
          goto _L___0;
        } else {
          _L: 
          return (0);
        }
      }
    } else {
      _L___0: ;
    }
  }
  tmp___0 = strncasecmp(line + lidx, tok, (unsigned int )tlen);
  return (tmp___0 == 0);
}
}
char *ap_escape_shell_cmd(apr_pool_t *p , char const   *str ) 
{ char *cmd ;
  unsigned char *d ;
  unsigned char const   *s ;
  size_t tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
  tmp = strlen(str);
  cmd = (char *)apr_palloc(p, 2U * tmp + 1U);
  d = (unsigned char *)cmd;
  s = (unsigned char const   *)str;
  while ((*s)) {
    if ((int const   )test_char_table[(unsigned int )(*s)] & 1) {
      tmp___0 = d;
      d ++;
      (*tmp___0) = (unsigned char )'\\';
    }
    tmp___1 = d;
    d ++;
    (*tmp___1) = (unsigned char )(*s);
    s ++;
  }
  (*d) = (unsigned char )'\000';
  return (cmd);
}
}
static char x2c(char const   *what ) 
{ register char digit ;
  int tmp ;

  {
  if ((int const   )(*(what + 0)) >= 65) {
    digit = (char )((((int const   )(*(what + 0)) & 223) - 65) + 10);
  } else {
    digit = (char )((int const   )(*(what + 0)) - 48);
  }
  digit = (char )((int )digit * 16);
  if ((int const   )(*(what + 1)) >= 65) {
    tmp = (int )((((int const   )(*(what + 1)) & 223) - 65) + 10);
  } else {
    tmp = (int )((int const   )(*(what + 1)) - 48);
  }
  digit = (char )((int )digit + tmp);
  return (digit);
}
}
int ap_unescape_url(char *url ) 
{ register int badesc ;
  register int badpath ;
  char *x ;
  char *y ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  badesc = 0;
  badpath = 0;
  y = strchr((char const   *)url, '%');
  if ((unsigned int )y == (unsigned int )((void *)0)) {
    return (0);
  }
  x = y;
  while ((*y)) {
    if ((int )(*y) != 37) {
      (*x) = (*y);
    } else {
      tmp = __ctype_b_loc();
      if ((int const   )(*((*tmp) + (int )((unsigned char )(*(y + 1))))) & 4096) {
        tmp___0 = __ctype_b_loc();
        if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*(y + 2))))) & 4096) {
          (*x) = x2c((char const   *)(y + 1));
          y += 2;
          if ((int )(*x) == 47) {
            goto _L;
          } else {
            if ((int )(*x) == 0) {
              _L: 
              badpath = 1;
            }
          }
        } else {
          _L___0: 
          badesc = 1;
          (*x) = (char )'%';
        }
      } else {
        goto _L___0;
      }
    }
    x ++;
    y ++;
  }
  (*x) = (char )'\000';
  if (badesc) {
    return (400);
  } else {
    if (badpath) {
      return (404);
    } else {
      return (0);
    }
  }
}
}
char *ap_construct_server(apr_pool_t *p , char const   *hostname , apr_port_t port ,
                          request_rec const   *r ) 
{ char *tmp ;
  char *tmp___0 ;
  apr_port_t tmp___1 ;

  {
  tmp___1 = ap_run_default_port(r);
  if ((int )port == (int )tmp___1) {
    tmp = apr_pstrdup(p, hostname);
    return (tmp);
  } else {
    tmp___0 = apr_psprintf(p, "%s:%u", hostname, port);
    return (tmp___0);
  }
}
}
static char const   c2x_table[17]  = 
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
__inline static unsigned char *c2x(unsigned int what , unsigned char *where ) 
{ unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
  tmp = where;
  where ++;
  (*tmp) = (unsigned char )'%';
  tmp___0 = where;
  where ++;
  (*tmp___0) = (unsigned char )c2x_table[what >> 4];
  tmp___1 = where;
  where ++;
  (*tmp___1) = (unsigned char )c2x_table[what & 15U];
  return (where);
}
}
char *ap_escape_path_segment(apr_pool_t *p , char const   *segment ) 
{ char *copy ;
  size_t tmp ;
  char *tmp___0 ;
  unsigned char const   *s ;
  unsigned char *d ;
  unsigned int c ;
  unsigned char *tmp___1 ;

  {
  tmp = strlen(segment);
  tmp___0 = (char *)apr_palloc(p, 3U * tmp + 1U);
  copy = tmp___0;
  s = (unsigned char const   *)segment;
  d = (unsigned char *)copy;
  while (1) {
    c = (unsigned int )(*s);
    if (! c) {
      break;
    }
    if ((int const   )test_char_table[c] & 2) {
      d = c2x(c, d);
    } else {
      tmp___1 = d;
      d ++;
      (*tmp___1) = (unsigned char )c;
    }
    s ++;
  }
  (*d) = (unsigned char )'\000';
  return (copy);
}
}
char *ap_os_escape_path(apr_pool_t *p , char const   *path , int partial ) 
{ char *copy ;
  size_t tmp ;
  char *tmp___0 ;
  unsigned char const   *s ;
  unsigned char *d ;
  unsigned int c ;
  char const   *colon ;
  char const   *tmp___1 ;
  char const   *slash ;
  char const   *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;

  {
  tmp = strlen(path);
  tmp___0 = (char *)apr_palloc(p, 3U * tmp + 3U);
  copy = tmp___0;
  s = (unsigned char const   *)path;
  d = (unsigned char *)copy;
  if (! partial) {
    tmp___1 = strchr(path, ':');
    colon = tmp___1;
    tmp___2 = strchr(path, '/');
    slash = tmp___2;
    if (colon) {
      if (! slash) {
        goto _L___0;
      } else {
        if ((unsigned int )colon < (unsigned int )slash) {
          _L___0: 
          tmp___3 = d;
          d ++;
          (*tmp___3) = (unsigned char )'.';
          tmp___4 = d;
          d ++;
          (*tmp___4) = (unsigned char )'/';
        } else {
          goto _L;
        }
      }
    } else {
      _L: ;
    }
  }
  while (1) {
    c = (unsigned int )(*s);
    if (! c) {
      break;
    }
    if ((int const   )test_char_table[c] & 4) {
      d = c2x(c, d);
    } else {
      tmp___5 = d;
      d ++;
      (*tmp___5) = (unsigned char )c;
    }
    s ++;
  }
  (*d) = (unsigned char )'\000';
  return (copy);
}
}
char *ap_escape_html(apr_pool_t *p , char const   *s ) 
{ int i ;
  int j ;
  char *x ;
  char *tmp ;

  {
  i = 0;
  j = 0;
  while ((int const   )(*(s + i)) != 0) {
    if ((int const   )(*(s + i)) == 60) {
      goto _L;
    } else {
      if ((int const   )(*(s + i)) == 62) {
        _L: 
        j += 3;
      } else {
        if ((int const   )(*(s + i)) == 38) {
          j += 4;
        }
      }
    }
    i ++;
  }
  if (j == 0) {
    tmp = apr_pstrmemdup(p, s, (unsigned int )i);
    return (tmp);
  }
  x = (char *)apr_palloc(p, (unsigned int )((i + j) + 1));
  i = 0;
  j = 0;
  while ((int const   )(*(s + i)) != 0) {
    if ((int const   )(*(s + i)) == 60) {
      memcpy((void * __restrict  )(x + j), (void const   * __restrict  )"&lt;", 4U);
      j += 3;
    } else {
      if ((int const   )(*(s + i)) == 62) {
        memcpy((void * __restrict  )(x + j), (void const   * __restrict  )"&gt;",
               4U);
        j += 3;
      } else {
        if ((int const   )(*(s + i)) == 38) {
          memcpy((void * __restrict  )(x + j), (void const   * __restrict  )"&amp;",
                 5U);
          j += 4;
        } else {
          (*(x + j)) = (char )(*(s + i));
        }
      }
    }
    i ++;
    j ++;
  }
  (*(x + j)) = (char )'\000';
  return (x);
}
}
int ap_is_directory(apr_pool_t *p , char const   *path ) 
{ apr_finfo_t finfo ;
  apr_status_t tmp ;

  {
  tmp = apr_stat(& finfo, path, 32768, p);
  if (tmp != 0) {
    return (0);
  }
  return ((int )finfo.filetype == 2);
}
}
int ap_is_rdirectory(apr_pool_t *p , char const   *path ) 
{ apr_finfo_t finfo ;
  apr_status_t tmp ;

  {
  tmp = apr_lstat(& finfo, path, 32768, p);
  if (tmp != 0) {
    return (0);
  }
  return ((int )finfo.filetype == 2);
}
}
char *ap_make_full_path(apr_pool_t *a , char const   *src1 , char const   *src2 ) 
{ apr_size_t len1 ;
  apr_size_t len2 ;
  char *path ;
  char *next ;
  char *tmp___0 ;

  {
  len1 = strlen(src1);
  len2 = strlen(src2);
  path = (char *)apr_palloc(a, (len1 + len2) + 3U);
  if (len1 == 0U) {
    (*path) = (char )'/';
    memcpy((void * __restrict  )(path + 1), (void const   * __restrict  )src2, len2 +
                                                                               1U);
  } else {
    memcpy((void * __restrict  )path, (void const   * __restrict  )src1, len1);
    next = path + len1;
    if ((int )(*(next + -1)) != 47) {
      tmp___0 = next;
      next ++;
      (*tmp___0) = (char )'/';
    }
    memcpy((void * __restrict  )next, (void const   * __restrict  )src2, len2 + 1U);
  }
  return (path);
}
}
int ap_is_url(char const   *u___0 ) 
{ register int x ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
  x = 0;
  while ((int const   )(*(u___0 + x)) != 58) {
    if (! (*(u___0 + x))) {
      goto _L;
    } else {
      tmp = __ctype_b_loc();
      if ((int const   )(*((*tmp) + (int )((unsigned char )(*(u___0 + x))))) & 1024) {
        _L___3: ;
      } else {
        tmp___0 = __ctype_b_loc();
        if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*(u___0 + x))))) &
            2048) {
          goto _L___3;
        } else {
          if ((int const   )(*(u___0 + x)) != 43) {
            if ((int const   )(*(u___0 + x)) != 45) {
              if ((int const   )(*(u___0 + x)) != 46) {
                _L: 
                return (0);
              } else {
                goto _L___3;
              }
            } else {
              goto _L___3;
            }
          } else {
            goto _L___3;
          }
        }
      }
    }
    x ++;
  }
  if (x) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
int ap_ind(char const   *s , char c ) 
{ char const   *p ;
  char const   *tmp ;

  {
  tmp = strchr(s, (int )c);
  p = tmp;
  if ((unsigned int )p == (unsigned int )((void *)0)) {
    return (-1);
  }
  return (p - s);
}
}
int ap_rind(char const   *s , char c ) 
{ char const   *p ;
  char const   *tmp ;

  {
  tmp = strrchr(s, (int )c);
  p = tmp;
  if ((unsigned int )p == (unsigned int )((void *)0)) {
    return (-1);
  }
  return (p - s);
}
}
void ap_str_tolower(char *str ) 
{ 

  {
  while ((*str)) {
    (*str) = (char )tolower((int )((unsigned char )(*str)));
    str ++;
  }
  return;
}
}
static char *find_fqdn(apr_pool_t *a , struct hostent *p ) 
{ int x ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  tmp___3 = strchr((char const   *)p->h_name, '.');
  if (! tmp___3) {
    if (p->h_aliases) {
      x = 0;
      while ((*(p->h_aliases + x))) {
        tmp___0 = strchr((char const   *)(*(p->h_aliases + x)), '.');
        if (tmp___0) {
          tmp___1 = strlen((char const   *)p->h_name);
          tmp___2 = strncasecmp((char const   *)(*(p->h_aliases + x)), (char const   *)p->h_name,
                                tmp___1);
          if (tmp___2) {
            goto _L;
          } else {
            tmp = apr_pstrdup(a, (char const   *)(*(p->h_aliases + x)));
            return (tmp);
          }
        } else {
          _L: ;
        }
        x ++;
      }
    }
    return ((char *)((void *)0));
  }
  tmp___4 = apr_pstrdup(a, (char const   *)((void *)p->h_name));
  return (tmp___4);
}
}
char *ap_get_local_host(apr_pool_t *a ) 
{ char str[257] ;
  char *server_hostname ;
  struct hostent *p ;
  int tmp ;

  {
  server_hostname = (char *)((void *)0);
  tmp = gethostname(str, sizeof(str) - 1U);
  if (tmp != 0) {
    ap_log_perror("util.c", 1859, 36, 0, a, "%s: gethostname() failed to determine ServerName",
                  ap_server_argv0);
  } else {
    str[sizeof(str) - 1U] = (char )'\000';
    p = gethostbyname((char const   *)(str));
    if (p) {
      server_hostname = find_fqdn(a, p);
      if (server_hostname) {
        return (server_hostname);
      } else {
        _L___0: 
        if (p) {
          if ((*(p->h_addr_list + 0))) {
            apr_snprintf(str, sizeof(str), "%pA", (*(p->h_addr_list + 0)));
            server_hostname = apr_pstrdup(a, (char const   *)(str));
          } else {
            goto _L;
          }
        } else {
          _L: ;
        }
      }
    } else {
      goto _L___0;
    }
  }
  if (! server_hostname) {
    server_hostname = apr_pstrdup(a, "127.0.0.1");
  }
  ap_log_perror("util.c", 1885, 33, 0, a, "%s: Could not determine the server\'s fully qualified domain name, using %s for ServerName",
                ap_server_argv0, server_hostname);
  return (server_hostname);
}
}
char *ap_pbase64decode(apr_pool_t *p , char const   *bufcoded ) 
{ char *decoded ;
  int l ;
  int tmp ;

  {
  tmp = apr_base64_decode_len(bufcoded);
  decoded = (char *)apr_palloc(p, (unsigned int )(1 + tmp));
  l = apr_base64_decode(decoded, bufcoded);
  (*(decoded + l)) = (char )'\000';
  return (decoded);
}
}
char *ap_pbase64encode(apr_pool_t *p , char *string ) 
{ char *encoded ;
  int l ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = (int )strlen((char const   *)string);
  l = tmp;
  tmp___0 = apr_base64_encode_len(l);
  encoded = (char *)apr_palloc(p, (unsigned int )(1 + tmp___0));
  l = apr_base64_encode(encoded, (char const   *)string, l);
  (*(encoded + l)) = (char )'\000';
  return (encoded);
}
}
void ap_content_type_tolower(char *str ) 
{ char *semi ;

  {
  semi = strchr((char const   *)str, ';');
  if (semi) {
    (*semi) = (char )'\000';
  }
  while ((*str)) {
    (*str) = (char )tolower((int )((unsigned char )(*str)));
    str ++;
  }
  if (semi) {
    (*semi) = (char )';';
  }
  return;
}
}
char *ap_escape_quotes(apr_pool_t *p , char const   *instring ) 
{ int newlen ;
  char const   *inchr ;
  char *outchr ;
  char *outstring ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;

  {
  newlen = 0;
  inchr = instring;
  while ((int const   )(*inchr) != 0) {
    newlen ++;
    if ((int const   )(*inchr) == 34) {
      newlen ++;
    }
    if ((int const   )(*inchr) == 92) {
      if ((int const   )(*(inchr + 1)) != 0) {
        inchr ++;
        newlen ++;
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    inchr ++;
  }
  outstring = (char *)apr_palloc(p, (unsigned int )(newlen + 1));
  inchr = instring;
  outchr = outstring;
  while ((int const   )(*inchr) != 0) {
    if ((int const   )(*inchr) == 92) {
      if ((int const   )(*(inchr + 1)) != 0) {
        tmp = outchr;
        outchr ++;
        tmp___0 = inchr;
        inchr ++;
        (*tmp) = (char )(*tmp___0);
        tmp___1 = outchr;
        outchr ++;
        tmp___2 = inchr;
        inchr ++;
        (*tmp___1) = (char )(*tmp___2);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
    if ((int const   )(*inchr) == 34) {
      tmp___3 = outchr;
      outchr ++;
      (*tmp___3) = (char )'\\';
    }
    if ((int const   )(*inchr) != 0) {
      tmp___4 = outchr;
      outchr ++;
      tmp___5 = inchr;
      inchr ++;
      (*tmp___4) = (char )(*tmp___5);
    }
  }
  (*outchr) = (char )'\000';
  return (outstring);
}
}
#pragma merger(0,"/tmp/cil-sRMVvnDh.i","-g -pthread")
extern char *strncpy(char * __restrict  __dest , char const   * __restrict  __src ,
                     size_t __n ) ;
void apr_table_add(apr_table_t *t , char const   *key , char const   *val ) ;
void apr_table_overlap(apr_table_t *a , apr_table_t const   *b , unsigned int flags ) ;
char const   *ap_document_root(request_rec *r ) ;
apr_port_t ap_get_server_port(request_rec const   *r ) ;
int ap_scan_script_header_err_strs(request_rec *r , char *buffer , char const   **termch ,
                                   int *termarg  , ...) ;
int ap_scan_script_header_err_core(request_rec *r , char *buffer , int (*getsfunc)(char * ,
                                                                                   int  ,
                                                                                   void * ) ,
                                   void *getsfunc_data ) ;
static char *http2env(apr_pool_t *a , char const   *w ) 
{ char *res ;
  size_t tmp ;
  char *tmp___0 ;
  char *cp ;
  char c ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  unsigned short const   **tmp___8 ;
  char const   *tmp___9 ;

  {
  tmp = strlen(w);
  tmp___0 = (char *)apr_palloc(a, sizeof("HTTP_") + tmp);
  res = tmp___0;
  cp = res;
  tmp___1 = cp;
  cp ++;
  (*tmp___1) = (char )'H';
  tmp___2 = cp;
  cp ++;
  (*tmp___2) = (char )'T';
  tmp___3 = cp;
  cp ++;
  (*tmp___3) = (char )'T';
  tmp___4 = cp;
  cp ++;
  (*tmp___4) = (char )'P';
  tmp___5 = cp;
  cp ++;
  (*tmp___5) = (char )'_';
  while (1) {
    tmp___9 = w;
    w ++;
    c = (char )(*tmp___9);
    if (! ((int )c != 0)) {
      break;
    }
    tmp___8 = __ctype_b_loc();
    if ((int const   )(*((*tmp___8) + (int )((unsigned char )c))) & 8) {
      tmp___7 = cp;
      cp ++;
      (*tmp___7) = (char )toupper((int )((unsigned char )c));
    } else {
      tmp___6 = cp;
      cp ++;
      (*tmp___6) = (char )'_';
    }
  }
  (*cp) = (char)0;
  return (res);
}
}
char **ap_create_environment(apr_pool_t *p , apr_table_t *t ) 
{ apr_array_header_t const   *env_arr ;
  apr_array_header_t const   *tmp ;
  apr_table_entry_t const   *elts ;
  char **env ;
  char **tmp___0 ;
  int i ;
  int j ;
  char *tz ;
  char *whack ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  tmp = apr_table_elts((apr_table_t const   *)t);
  env_arr = tmp;
  elts = (apr_table_entry_t const   *)env_arr->elts;
  tmp___0 = (char **)apr_palloc(p, (unsigned int )(env_arr->nelts + 2) * sizeof(char *));
  env = tmp___0;
  j = 0;
  tmp___2 = apr_table_get((apr_table_t const   *)t, "TZ");
  if (! tmp___2) {
    tz = getenv("TZ");
    if ((unsigned int )tz != (unsigned int )((void *)0)) {
      tmp___1 = j;
      j ++;
      (*(env + tmp___1)) = apr_pstrcat(p, "TZ=", tz, (void *)0);
    }
  }
  i = 0;
  while (i < env_arr->nelts) {
    if (! (elts + i)->key) {
      goto __Cont;
    }
    (*(env + j)) = apr_pstrcat(p, (elts + i)->key, "=", (elts + i)->val, (void *)0);
    whack = (*(env + j));
    tmp___4 = __ctype_b_loc();
    if ((int const   )(*((*tmp___4) + (int )((unsigned char )(*whack)))) & 2048) {
      tmp___3 = whack;
      whack ++;
      (*tmp___3) = (char )'_';
    }
    while ((int )(*whack) != 61) {
      tmp___5 = __ctype_b_loc();
      if ((int const   )(*((*tmp___5) + (int )((unsigned char )(*whack)))) & 8) {
        _L: ;
      } else {
        if ((int )(*whack) != 95) {
          (*whack) = (char )'_';
        } else {
          goto _L;
        }
      }
      whack ++;
    }
    j ++;
    __Cont: 
    i ++;
  }
  (*(env + j)) = (char *)((void *)0);
  return (env);
}
}
void ap_add_common_vars(request_rec *r ) 
{ apr_table_t *e ;
  server_rec *s ;
  conn_rec *c ;
  char const   *rem_logname ;
  char *env_path ;
  char const   *host ;
  apr_array_header_t const   *hdrs_arr ;
  apr_array_header_t const   *tmp ;
  apr_table_entry_t const   *hdrs ;
  int i ;
  apr_port_t rport ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  apr_port_t tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;

  {
  s = r->server;
  c = r->connection;
  tmp = apr_table_elts((apr_table_t const   *)r->headers_in);
  hdrs_arr = tmp;
  hdrs = (apr_table_entry_t const   *)hdrs_arr->elts;
  tmp___0 = apr_is_empty_table((apr_table_t const   *)r->subprocess_env);
  if (tmp___0) {
    e = r->subprocess_env;
  } else {
    e = apr_table_make(r->pool, 25 + hdrs_arr->nelts);
  }
  i = 0;
  while (i < hdrs_arr->nelts) {
    if (! (hdrs + i)->key) {
      goto __Cont;
    }
    tmp___5 = strcasecmp((char const   *)(hdrs + i)->key, "Content-type");
    if (tmp___5) {
      tmp___4 = strcasecmp((char const   *)(hdrs + i)->key, "Content-length");
      if (tmp___4) {
        tmp___2 = strcasecmp((char const   *)(hdrs + i)->key, "Authorization");
        if (tmp___2) {
          tmp___3 = strcasecmp((char const   *)(hdrs + i)->key, "Proxy-Authorization");
          if (tmp___3) {
            tmp___1 = http2env(r->pool, (char const   *)(hdrs + i)->key);
            apr_table_addn(e, tmp___1, (char const   *)(hdrs + i)->val);
          } else {
            _L: 
            goto __Cont;
          }
        } else {
          goto _L;
        }
      } else {
        apr_table_addn(e, "CONTENT_LENGTH", (char const   *)(hdrs + i)->val);
      }
    } else {
      apr_table_addn(e, "CONTENT_TYPE", (char const   *)(hdrs + i)->val);
    }
    __Cont: 
    i ++;
  }
  env_path = getenv("PATH");
  if (! env_path) {
    env_path = (char *)"/bin:/usr/bin:/usr/ucb:/usr/bsd:/usr/local/bin";
  }
  tmp___6 = apr_pstrdup(r->pool, (char const   *)env_path);
  apr_table_addn(e, "PATH", tmp___6);
  tmp___7 = ap_psignature("", r);
  apr_table_addn(e, "SERVER_SIGNATURE", tmp___7);
  tmp___8 = ap_get_server_version();
  apr_table_addn(e, "SERVER_SOFTWARE", tmp___8);
  tmp___9 = ap_get_server_name(r);
  tmp___10 = ap_escape_html(r->pool, tmp___9);
  apr_table_addn(e, "SERVER_NAME", tmp___10);
  apr_table_addn(e, "SERVER_ADDR", (char const   *)(r->connection)->local_ip);
  tmp___11 = ap_get_server_port((request_rec const   *)r);
  tmp___12 = apr_psprintf(r->pool, "%u", tmp___11);
  apr_table_addn(e, "SERVER_PORT", tmp___12);
  host = ap_get_remote_host(c, (void *)r->per_dir_config, 0, (int *)((void *)0));
  if (host) {
    apr_table_addn(e, "REMOTE_HOST", host);
  }
  apr_table_addn(e, "REMOTE_ADDR", (char const   *)c->remote_ip);
  tmp___13 = ap_document_root(r);
  apr_table_addn(e, "DOCUMENT_ROOT", tmp___13);
  apr_table_addn(e, "SERVER_ADMIN", (char const   *)s->server_admin);
  apr_table_addn(e, "SCRIPT_FILENAME", (char const   *)r->filename);
  apr_sockaddr_port_get(& rport, c->remote_addr);
  tmp___14 = apr_itoa(r->pool, (int )rport);
  apr_table_addn(e, "REMOTE_PORT", tmp___14);
  if (r->user) {
    apr_table_addn(e, "REMOTE_USER", (char const   *)r->user);
  }
  if (r->ap_auth_type) {
    apr_table_addn(e, "AUTH_TYPE", (char const   *)r->ap_auth_type);
  }
  rem_logname = ap_get_remote_logname(r);
  if (rem_logname) {
    tmp___15 = apr_pstrdup(r->pool, rem_logname);
    apr_table_addn(e, "REMOTE_IDENT", tmp___15);
  }
  if (r->prev) {
    if ((r->prev)->args) {
      apr_table_addn(e, "REDIRECT_QUERY_STRING", (char const   *)(r->prev)->args);
    }
    if ((r->prev)->uri) {
      apr_table_addn(e, "REDIRECT_URL", (char const   *)(r->prev)->uri);
    }
  }
  if ((unsigned int )e != (unsigned int )r->subprocess_env) {
    apr_table_overlap(r->subprocess_env, (apr_table_t const   *)e, 0U);
  }
  return;
}
}
int ap_find_path_info(char const   *uri , char const   *path_info ) 
{ int lu ;
  int tmp ;
  int lp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = (int )strlen(uri);
  lu = tmp;
  tmp___0 = (int )strlen(path_info);
  lp = tmp___0;
  while (1) {
    tmp___1 = lu;
    lu --;
    if (tmp___1) {
      tmp___2 = lp;
      lp --;
      if (tmp___2) {
        if (! ((int const   )(*(uri + lu)) == (int const   )(*(path_info + lp)))) {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      break;
    }
  }
  if (lu == -1) {
    lu = 0;
  }
  while (1) {
    if ((int const   )(*(uri + lu)) != 0) {
      if (! ((int const   )(*(uri + lu)) != 47)) {
        goto _L___1;
      }
    } else {
      _L___1: 
      break;
    }
    lu ++;
  }
  return (lu);
}
}
static char *original_uri(request_rec *r ) 
{ char *first ;
  char *last ;
  void *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;

  {
  if ((unsigned int )r->the_request == (unsigned int )((void *)0)) {
    tmp = apr_palloc(r->pool, 1U);
    tmp___0 = (char *)memset(tmp, 0, 1U);
    return (tmp___0);
  }
  first = r->the_request;
  while (1) {
    if ((*first)) {
      tmp___1 = __ctype_b_loc();
      if ((int const   )(*((*tmp___1) + (int )((unsigned char )(*first)))) & 8192) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
    first ++;
  }
  while (1) {
    tmp___2 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___2) + (int )((unsigned char )(*first)))) & 8192)) {
      break;
    }
    first ++;
  }
  last = first;
  while (1) {
    if ((*last)) {
      tmp___3 = __ctype_b_loc();
      if ((int const   )(*((*tmp___3) + (int )((unsigned char )(*last)))) & 8192) {
        goto _L___0;
      }
    } else {
      _L___0: 
      break;
    }
    last ++;
  }
  tmp___4 = apr_pstrmemdup(r->pool, (char const   *)first, (unsigned int )(last -
                                                                           first));
  return (tmp___4);
}
}
void ap_add_cgi_vars(request_rec *r ) 
{ apr_table_t *e ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int path_info_start ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  request_rec *pa_req ;
  char const   *tmp___4 ;
  char *pt ;
  char *tmp___5 ;

  {
  e = r->subprocess_env;
  apr_table_setn(e, "GATEWAY_INTERFACE", "CGI/1.1");
  apr_table_setn(e, "SERVER_PROTOCOL", (char const   *)r->protocol);
  apr_table_setn(e, "REQUEST_METHOD", r->method);
  if (r->args) {
    tmp = (char const   *)r->args;
  } else {
    tmp = "";
  }
  apr_table_setn(e, "QUERY_STRING", tmp);
  tmp___0 = original_uri(r);
  apr_table_setn(e, "REQUEST_URI", tmp___0);
  tmp___3 = strcmp((char const   *)r->protocol, "INCLUDED");
  if (tmp___3) {
    if (! r->path_info) {
      goto _L___0;
    } else {
      if (! (*(r->path_info))) {
        _L___0: 
        apr_table_setn(e, "SCRIPT_NAME", (char const   *)r->uri);
      } else {
        tmp___1 = ap_find_path_info((char const   *)r->uri, (char const   *)r->path_info);
        path_info_start = tmp___1;
        tmp___2 = apr_pstrndup(r->pool, (char const   *)r->uri, (unsigned int )path_info_start);
        apr_table_setn(e, "SCRIPT_NAME", tmp___2);
        apr_table_setn(e, "PATH_INFO", (char const   *)r->path_info);
      }
    }
  } else {
    apr_table_setn(e, "SCRIPT_NAME", (char const   *)r->uri);
    if (r->path_info) {
      if ((*(r->path_info))) {
        apr_table_setn(e, "PATH_INFO", (char const   *)r->path_info);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
  }
  if (r->path_info) {
    if ((*(r->path_info + 0))) {
      tmp___4 = ap_os_escape_path(r->pool, (char const   *)r->path_info, 1);
      pa_req = ap_sub_req_lookup_uri(tmp___4, (request_rec const   *)r, (ap_filter_t *)((void *)0));
      if (pa_req->filename) {
        tmp___5 = apr_pstrcat(r->pool, pa_req->filename, pa_req->path_info, (void *)0);
        pt = tmp___5;
        apr_table_setn(e, "PATH_TRANSLATED", (char const   *)pt);
      }
      ap_destroy_sub_req(pa_req);
    } else {
      goto _L___1;
    }
  } else {
    _L___1: ;
  }
  return;
}
}
static int set_cookie_doo_doo(void *v , char const   *key , char const   *val ) 
{ 

  {
  apr_table_addn((apr_table_t *)v, key, val);
  return (1);
}
}
int ap_scan_script_header_err_core(request_rec *r , char *buffer , int (*getsfunc)(char * ,
                                                                                   int  ,
                                                                                   void * ) ,
                                   void *getsfunc_data ) 
{ char x[8192] ;
  char *w ;
  char *l ;
  int p ;
  int cgi_status ;
  apr_table_t *merge ;
  apr_table_t *cookie_table ;
  char const   *tmp ;
  int tmp___0 ;
  int cond_status ;
  int tmp___1 ;
  char malformed[(int )((sizeof("malformed header from script. Bad header=") + 1U) +
                        30U)] ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  char *endp ;
  size_t tmp___7 ;
  char *tmp___8 ;
  unsigned short const   **tmp___9 ;
  apr_time_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  cgi_status = 200;
  if (buffer) {
    (*buffer) = (char )'\000';
  }
  if (buffer) {
    w = buffer;
  } else {
    w = x;
  }
  merge = apr_table_make(r->pool, 10);
  cookie_table = apr_table_make(r->pool, 2);
  apr_table_do(& set_cookie_doo_doo, (void *)cookie_table, (apr_table_t const   *)r->err_headers_out,
               "Set-Cookie", (void *)0);
  while (1) {
    tmp___0 = ((*getsfunc))(w, 8191, getsfunc_data);
    if (tmp___0 == 0) {
      tmp = apr_filename_of_pathname((char const   *)r->filename);
      ap_log_rerror("util_script.c", 459, 19, 0, (request_rec const   *)r, "Premature end of script headers: %s",
                    tmp);
      return (500);
    }
    p = (int )strlen((char const   *)w);
    if (p > 0) {
      if ((int )(*(w + (p - 1))) == 10) {
        if (p > 1) {
          if ((int )(*(w + (p - 2))) == 13) {
            (*(w + (p - 2))) = (char )'\000';
          } else {
            goto _L;
          }
        } else {
          _L: 
          (*(w + (p - 1))) = (char )'\000';
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
    if ((int )(*(w + 0)) == 0) {
      cond_status = 0;
      if (cgi_status == 200) {
        if (r->method_number == 0) {
          cond_status = ap_meets_conditions(r);
        } else {
          goto _L___1;
        }
      } else {
        _L___1: ;
      }
      apr_table_overlap(r->err_headers_out, (apr_table_t const   *)merge, 1U);
      tmp___1 = apr_is_empty_table((apr_table_t const   *)cookie_table);
      if (! tmp___1) {
        apr_table_unset(r->err_headers_out, "Set-Cookie");
        r->err_headers_out = apr_table_overlay(r->pool, (apr_table_t const   *)r->err_headers_out,
                                               (apr_table_t const   *)cookie_table);
      }
      return (cond_status);
    }
    l = strchr((char const   *)w, ':');
    if (! l) {
      strcpy((char * __restrict  )(malformed), (char const   * __restrict  )"malformed header from script. Bad header=");
      strncat((char * __restrict  )(malformed), (char const   * __restrict  )w, 30U);
      if (! buffer) {
        while (1) {
          tmp___2 = ((*getsfunc))(w, 8191, getsfunc_data);
          if (! tmp___2) {
            break;
          }
          continue;
        }
      }
      tmp___3 = apr_filename_of_pathname((char const   *)r->filename);
      ap_log_rerror("util_script.c", 552, 19, 0, (request_rec const   *)r, "%s: %s",
                    malformed, tmp___3);
      return (500);
    }
    tmp___4 = l;
    l ++;
    (*tmp___4) = (char )'\000';
    while (1) {
      if ((*l)) {
        tmp___5 = __ctype_b_loc();
        if (! ((int const   )(*((*tmp___5) + (int )((unsigned char )(*l)))) & 8192)) {
          goto _L___2;
        }
      } else {
        _L___2: 
        break;
      }
      l ++;
    }
    tmp___17 = strcasecmp((char const   *)w, "Content-type");
    if (tmp___17) {
      tmp___16 = strcasecmp((char const   *)w, "Status");
      if (tmp___16) {
        tmp___15 = strcasecmp((char const   *)w, "Location");
        if (tmp___15) {
          tmp___14 = strcasecmp((char const   *)w, "Content-Length");
          if (tmp___14) {
            tmp___13 = strcasecmp((char const   *)w, "Transfer-Encoding");
            if (tmp___13) {
              tmp___12 = strcasecmp((char const   *)w, "Last-Modified");
              if (tmp___12) {
                tmp___11 = strcasecmp((char const   *)w, "Set-Cookie");
                if (tmp___11) {
                  apr_table_add(merge, (char const   *)w, (char const   *)l);
                } else {
                  apr_table_add(cookie_table, (char const   *)w, (char const   *)l);
                }
              } else {
                tmp___10 = apr_date_parse_http((char const   *)l);
                ap_update_mtime(r, tmp___10);
                ap_set_last_modified(r);
              }
            } else {
              apr_table_set(r->headers_out, (char const   *)w, (char const   *)l);
            }
          } else {
            apr_table_set(r->headers_out, (char const   *)w, (char const   *)l);
          }
        } else {
          apr_table_set(r->headers_out, (char const   *)w, (char const   *)l);
        }
      } else {
        cgi_status = atoi((char const   *)l);
        r->status = cgi_status;
        r->status_line = apr_pstrdup(r->pool, (char const   *)l);
      }
    } else {
      tmp___7 = strlen((char const   *)l);
      endp = (l + tmp___7) - 1;
      while (1) {
        if ((unsigned int )endp > (unsigned int )l) {
          tmp___9 = __ctype_b_loc();
          if (! ((int const   )(*((*tmp___9) + (int )((unsigned char )(*endp)))) &
                 8192)) {
            goto _L___3;
          }
        } else {
          _L___3: 
          break;
        }
        tmp___8 = endp;
        endp --;
        (*tmp___8) = (char )'\000';
      }
      tmp___6 = apr_pstrdup(r->pool, (char const   *)l);
      ap_content_type_tolower(tmp___6);
      ap_set_content_type(r, (char const   *)tmp___6);
    }
  }
  return (0);
}
}
static int getsfunc_FILE(char *buf , int len , void *f ) 
{ apr_status_t tmp ;

  {
  tmp = apr_file_gets(buf, len, (apr_file_t *)f);
  return (tmp == 0);
}
}
int ap_scan_script_header_err(request_rec *r , apr_file_t *f , char *buffer ) 
{ int tmp ;

  {
  tmp = ap_scan_script_header_err_core(r, buffer, & getsfunc_FILE, (void *)f);
  return (tmp);
}
}
static int getsfunc_BRIGADE(char *buf , int len , void *arg ) 
{ apr_bucket_brigade *bb ;
  char const   *dst_end ;
  char *dst ;
  apr_bucket *e ;
  apr_status_t rv ;
  int done ;
  char const   *bucket_data ;
  apr_size_t bucket_data_len ;
  char const   *src ;
  char const   *src_end ;
  apr_bucket *next ;
  char *tmp ;

  {
  bb = (apr_bucket_brigade *)arg;
  dst_end = (char const   *)((buf + len) - 1);
  dst = buf;
  e = bb->list.next;
  done = 0;
  while (1) {
    if ((unsigned int )dst < (unsigned int )dst_end) {
      if (! done) {
        if (! (! ((unsigned int )e->type == (unsigned int )(& apr_bucket_type_eos)))) {
          goto _L___3;
        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: 
      break;
    }
    rv = ((*((e->type)->read)))(e, & bucket_data, & bucket_data_len, (enum __anonenum_apr_read_type_e_60 )0);
    if (! (rv == 0)) {
      goto _L;
    } else {
      if (bucket_data_len == 0U) {
        _L: 
        return (0);
      }
    }
    src = bucket_data;
    src_end = bucket_data + bucket_data_len;
    while (1) {
      if ((unsigned int )src < (unsigned int )src_end) {
        if ((unsigned int )dst < (unsigned int )dst_end) {
          if (! (! done)) {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        _L___1: 
        break;
      }
      if ((int const   )(*src) == 10) {
        done = 1;
      } else {
        if ((int const   )(*src) != 13) {
          tmp = dst;
          dst ++;
          (*tmp) = (char )(*src);
        }
      }
      src ++;
    }
    if ((unsigned int )src < (unsigned int )src_end) {
      ((*((e->type)->split)))(e, (unsigned int )(src - bucket_data));
    }
    next = e->link.next;
    while (1) {
      (e->link.prev)->link.next = e->link.next;
      (e->link.next)->link.prev = e->link.prev;
      break;
    }
    while (1) {
      ((*((e->type)->destroy)))(e->data);
      ((*(e->free)))((void *)e);
      break;
    }
    e = next;
  }
  (*dst) = (char)0;
  return (1);
}
}
int ap_scan_script_header_err_brigade(request_rec *r , apr_bucket_brigade *bb , char *buffer ) 
{ int tmp ;

  {
  tmp = ap_scan_script_header_err_core(r, buffer, & getsfunc_BRIGADE, (void *)bb);
  return (tmp);
}
}
static int getsfunc_STRING(char *w , int len , void *pvastrs ) 
{ struct vastrs *strs ;
  char const   *p ;
  int t ;

  {
  strs = (struct vastrs *)pvastrs;
  if (! strs->curpos) {
    goto _L;
  } else {
    if (! (*(strs->curpos))) {
      _L: 
      return (0);
    }
  }
  p = strchr(strs->curpos, '\n');
  if (p) {
    p ++;
  } else {
    p = strchr(strs->curpos, '\000');
  }
  t = p - strs->curpos;
  if (t > len) {
    t = len;
  }
  strncpy((char * __restrict  )w, (char const   * __restrict  )strs->curpos, (unsigned int )t);
  (*(w + t)) = (char )'\000';
  if (! (*(strs->curpos + t))) {
    strs->arg ++;
    strs->curpos = __builtin_va_arg(strs->args, char const   *);
  } else {
    strs->curpos += t;
  }
  return (t);
}
}
int ap_scan_script_header_err_strs(request_rec *r , char *buffer , char const   **termch ,
                                   int *termarg  , ...) 
{ struct vastrs strs ;
  int res ;

  {
  __builtin_stdarg_start(strs.args, termarg);
  strs.arg = 0;
  strs.curpos = __builtin_va_arg(strs.args, char *);
  res = ap_scan_script_header_err_core(r, buffer, & getsfunc_STRING, (void *)(& strs));
  if (termch) {
    (*termch) = strs.curpos;
  }
  if (termarg) {
    (*termarg) = strs.arg;
  }
  __builtin_va_end(strs.args);
  return (res);
}
}
#pragma merger(0,"/tmp/cil-4MhZJws6.i","-g -pthread")
apr_status_t apr_md5_init(apr_md5_ctx_t *context ) ;
apr_status_t apr_md5_update(apr_md5_ctx_t *context , unsigned char const   *input ,
                            apr_size_t inputLen ) ;
apr_status_t apr_md5_final(unsigned char *digest , apr_md5_ctx_t *context ) ;
char *ap_md5(apr_pool_t *p , unsigned char const   *string ) ;
char *ap_md5_binary(apr_pool_t *p , unsigned char const   *buf , int length ) ;
char *ap_md5contextTo64(apr_pool_t *a , apr_md5_ctx_t *context ) ;
char *ap_md5digest(apr_pool_t *p , apr_file_t *infile ) ;
char *ap_md5_binary(apr_pool_t *p , unsigned char const   *buf , int length ) 
{ char const   *hex ;
  apr_md5_ctx_t my_md5 ;
  unsigned char hash[16] ;
  char *r ;
  char result[33] ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  hex = "0123456789abcdef";
  apr_md5_init(& my_md5);
  apr_md5_update(& my_md5, buf, (unsigned int )length);
  apr_md5_final(hash, & my_md5);
  i = 0;
  r = result;
  while (i < 16) {
    tmp = r;
    r ++;
    (*tmp) = (char )(*(hex + ((int )hash[i] >> 4)));
    tmp___0 = r;
    r ++;
    (*tmp___0) = (char )(*(hex + ((int )hash[i] & 15)));
    i ++;
  }
  (*r) = (char )'\000';
  tmp___1 = apr_pstrndup(p, (char const   *)(result), 32U);
  return (tmp___1);
}
}
char *ap_md5(apr_pool_t *p , unsigned char const   *string ) 
{ int tmp ;
  char *tmp___0 ;

  {
  tmp = (int )strlen((char const   *)((char *)string));
  tmp___0 = ap_md5_binary(p, string, tmp);
  return (tmp___0);
}
}
static char basis_64[65]  = 
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'+',      (char )'/', 
        (char )'\000'};
char *ap_md5contextTo64(apr_pool_t *a , apr_md5_ctx_t *context ) 
{ unsigned char digest[18] ;
  char *encodedDigest ;
  int i ;
  char *p ;
  void *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  tmp = apr_palloc(a, 25U * sizeof(char ));
  encodedDigest = (char *)memset(tmp, 0, 25U * sizeof(char ));
  apr_md5_final(digest, context);
  digest[sizeof(digest) - 2U] = (unsigned char)0;
  digest[sizeof(digest) - 1U] = digest[sizeof(digest) - 2U];
  p = encodedDigest;
  i = 0;
  while ((unsigned int )i < sizeof(digest)) {
    tmp___1 = p;
    p ++;
    (*tmp___1) = basis_64[(int )digest[i] >> 2];
    tmp___2 = p;
    p ++;
    (*tmp___2) = basis_64[(((int )digest[i] & 3) << 4) | (((int )digest[i + 1] & 240) >>
                                                          4)];
    tmp___3 = p;
    p ++;
    (*tmp___3) = basis_64[(((int )digest[i + 1] & 15) << 2) | (((int )digest[i + 2] &
                                                                192) >> 6)];
    tmp___4 = p;
    p ++;
    (*tmp___4) = basis_64[(int )digest[i + 2] & 63];
    i += 3;
  }
  tmp___5 = p;
  p --;
  (*tmp___5) = (char )'\000';
  tmp___6 = p;
  p --;
  (*tmp___6) = (char )'=';
  tmp___7 = p;
  p --;
  (*tmp___7) = (char )'=';
  return (encodedDigest);
}
}
char *ap_md5digest(apr_pool_t *p , apr_file_t *infile ) 
{ apr_md5_ctx_t context ;
  unsigned char buf[1000] ;
  long length ;
  apr_size_t nbytes ;
  apr_off_t offset ;
  apr_status_t tmp ;
  char *tmp___0 ;

  {
  length = 0L;
  offset = 0L;
  apr_md5_init(& context);
  nbytes = sizeof(buf);
  while (1) {
    tmp = apr_file_read(infile, (void *)(buf), & nbytes);
    if (! (tmp == 0)) {
      break;
    }
    length = (long )((unsigned long )length + (unsigned long )nbytes);
    apr_md5_update(& context, (unsigned char const   *)(buf), nbytes);
  }
  apr_file_seek(infile, 0, & offset);
  tmp___0 = ap_md5contextTo64(p, & context);
  return (tmp___0);
}
}
#pragma merger(0,"/tmp/cil-wknuukkn.i","-g -pthread")
ap_directive_t *ap_add_node(ap_directive_t **parent , ap_directive_t *current , ap_directive_t *toadd ,
                            int child ) 
{ 

  {
  if ((unsigned int )current == (unsigned int )((void *)0)) {
    if ((unsigned int )(*parent) != (unsigned int )((void *)0)) {
      ((*parent))->first_child = toadd;
      toadd->parent = (*parent);
    }
    if (child) {
      (*parent) = toadd;
      return ((ap_directive_t *)((void *)0));
    }
    return (toadd);
  }
  current->next = toadd;
  toadd->parent = (*parent);
  if (child) {
    (*parent) = toadd;
    return ((ap_directive_t *)((void *)0));
  }
  return (toadd);
}
}
#pragma merger(0,"/tmp/cil-0k8xc82k.i","-g -pthread")
#pragma merger(0,"/tmp/cil-xqW2BIeJ.i","-g -pthread")
char const   apr_day_snames[7][4] ;
apr_status_t ap_explode_recent_gmt(apr_time_exp_t *tm , apr_time_t t ) ;
static struct exploded_time_cache_element exploded_cache_localtime[16]  ;
static struct exploded_time_cache_element exploded_cache_gmt[16]  ;
static apr_status_t cached_explode(apr_time_exp_t *xt , apr_time_t t , struct exploded_time_cache_element *cache ,
                                   int use_gmt ) 
{ apr_int64_t seconds ;
  struct exploded_time_cache_element *cache_element ;
  struct exploded_time_cache_element cache_element_snapshot ;
  apr_status_t tmp ;
  apr_status_t tmp___0 ;
  apr_status_t r ;

  {
  seconds = t / 1000000LL;
  cache_element = cache + (seconds & 15LL);
  if (cache_element->t >= seconds) {
    memcpy((void * __restrict  )(& cache_element_snapshot), (void const   * __restrict  )cache_element,
           sizeof(struct exploded_time_cache_element ));
    if (seconds != cache_element_snapshot.t) {
      goto _L;
    } else {
      if (seconds != cache_element_snapshot.t_validate) {
        _L: 
        if (use_gmt) {
          tmp = apr_time_exp_gmt(xt, t);
          return (tmp);
        } else {
          tmp___0 = apr_time_exp_lt(xt, t);
          return (tmp___0);
        }
      } else {
        memcpy((void * __restrict  )xt, (void const   * __restrict  )(& cache_element_snapshot.xt),
               sizeof(apr_time_exp_t ));
      }
    }
  } else {
    if (use_gmt) {
      r = apr_time_exp_gmt(xt, t);
    } else {
      r = apr_time_exp_lt(xt, t);
    }
    if (! (r == 0)) {
      return (r);
    }
    cache_element->t = seconds;
    memcpy((void * __restrict  )(& cache_element->xt), (void const   * __restrict  )xt,
           sizeof(apr_time_exp_t ));
    cache_element->t_validate = seconds;
  }
  xt->tm_usec = (int )(t % 1000000LL);
  return (0);
}
}
apr_status_t ap_explode_recent_localtime(apr_time_exp_t *tm , apr_time_t t ) 
{ apr_status_t tmp ;

  {
  tmp = cached_explode(tm, t, exploded_cache_localtime, 0);
  return (tmp);
}
}
apr_status_t ap_explode_recent_gmt(apr_time_exp_t *tm , apr_time_t t ) 
{ apr_status_t tmp ;

  {
  tmp = cached_explode(tm, t, exploded_cache_gmt, 1);
  return (tmp);
}
}
apr_status_t ap_recent_ctime(char *date_str , apr_time_t t ) 
{ apr_time_exp_t xt ;
  char const   *s ;
  int real_year ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;

  {
  ap_explode_recent_localtime(& xt, t);
  s = & apr_day_snames[xt.tm_wday][0];
  tmp = date_str;
  date_str ++;
  tmp___0 = s;
  s ++;
  (*tmp) = (char )(*tmp___0);
  tmp___1 = date_str;
  date_str ++;
  tmp___2 = s;
  s ++;
  (*tmp___1) = (char )(*tmp___2);
  tmp___3 = date_str;
  date_str ++;
  tmp___4 = s;
  s ++;
  (*tmp___3) = (char )(*tmp___4);
  tmp___5 = date_str;
  date_str ++;
  (*tmp___5) = (char )' ';
  s = & apr_month_snames[xt.tm_mon][0];
  tmp___6 = date_str;
  date_str ++;
  tmp___7 = s;
  s ++;
  (*tmp___6) = (char )(*tmp___7);
  tmp___8 = date_str;
  date_str ++;
  tmp___9 = s;
  s ++;
  (*tmp___8) = (char )(*tmp___9);
  tmp___10 = date_str;
  date_str ++;
  tmp___11 = s;
  s ++;
  (*tmp___10) = (char )(*tmp___11);
  tmp___12 = date_str;
  date_str ++;
  (*tmp___12) = (char )' ';
  tmp___13 = date_str;
  date_str ++;
  (*tmp___13) = (char )(xt.tm_mday / 10 + 48);
  tmp___14 = date_str;
  date_str ++;
  (*tmp___14) = (char )(xt.tm_mday % 10 + 48);
  tmp___15 = date_str;
  date_str ++;
  (*tmp___15) = (char )' ';
  tmp___16 = date_str;
  date_str ++;
  (*tmp___16) = (char )(xt.tm_hour / 10 + 48);
  tmp___17 = date_str;
  date_str ++;
  (*tmp___17) = (char )(xt.tm_hour % 10 + 48);
  tmp___18 = date_str;
  date_str ++;
  (*tmp___18) = (char )':';
  tmp___19 = date_str;
  date_str ++;
  (*tmp___19) = (char )(xt.tm_min / 10 + 48);
  tmp___20 = date_str;
  date_str ++;
  (*tmp___20) = (char )(xt.tm_min % 10 + 48);
  tmp___21 = date_str;
  date_str ++;
  (*tmp___21) = (char )':';
  tmp___22 = date_str;
  date_str ++;
  (*tmp___22) = (char )(xt.tm_sec / 10 + 48);
  tmp___23 = date_str;
  date_str ++;
  (*tmp___23) = (char )(xt.tm_sec % 10 + 48);
  tmp___24 = date_str;
  date_str ++;
  (*tmp___24) = (char )' ';
  real_year = 1900 + xt.tm_year;
  tmp___25 = date_str;
  date_str ++;
  (*tmp___25) = (char )(real_year / 1000 + 48);
  tmp___26 = date_str;
  date_str ++;
  (*tmp___26) = (char )((real_year % 1000) / 100 + 48);
  tmp___27 = date_str;
  date_str ++;
  (*tmp___27) = (char )((real_year % 100) / 10 + 48);
  tmp___28 = date_str;
  date_str ++;
  (*tmp___28) = (char )(real_year % 10 + 48);
  tmp___29 = date_str;
  date_str ++;
  (*tmp___29) = (char)0;
  return (0);
}
}
apr_status_t ap_recent_rfc822_date(char *date_str , apr_time_t t ) 
{ apr_time_exp_t xt ;
  char const   *s ;
  int real_year ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;

  {
  ap_explode_recent_gmt(& xt, t);
  s = & apr_day_snames[xt.tm_wday][0];
  tmp = date_str;
  date_str ++;
  tmp___0 = s;
  s ++;
  (*tmp) = (char )(*tmp___0);
  tmp___1 = date_str;
  date_str ++;
  tmp___2 = s;
  s ++;
  (*tmp___1) = (char )(*tmp___2);
  tmp___3 = date_str;
  date_str ++;
  tmp___4 = s;
  s ++;
  (*tmp___3) = (char )(*tmp___4);
  tmp___5 = date_str;
  date_str ++;
  (*tmp___5) = (char )',';
  tmp___6 = date_str;
  date_str ++;
  (*tmp___6) = (char )' ';
  tmp___7 = date_str;
  date_str ++;
  (*tmp___7) = (char )(xt.tm_mday / 10 + 48);
  tmp___8 = date_str;
  date_str ++;
  (*tmp___8) = (char )(xt.tm_mday % 10 + 48);
  tmp___9 = date_str;
  date_str ++;
  (*tmp___9) = (char )' ';
  s = & apr_month_snames[xt.tm_mon][0];
  tmp___10 = date_str;
  date_str ++;
  tmp___11 = s;
  s ++;
  (*tmp___10) = (char )(*tmp___11);
  tmp___12 = date_str;
  date_str ++;
  tmp___13 = s;
  s ++;
  (*tmp___12) = (char )(*tmp___13);
  tmp___14 = date_str;
  date_str ++;
  tmp___15 = s;
  s ++;
  (*tmp___14) = (char )(*tmp___15);
  tmp___16 = date_str;
  date_str ++;
  (*tmp___16) = (char )' ';
  real_year = 1900 + xt.tm_year;
  tmp___17 = date_str;
  date_str ++;
  (*tmp___17) = (char )(real_year / 1000 + 48);
  tmp___18 = date_str;
  date_str ++;
  (*tmp___18) = (char )((real_year % 1000) / 100 + 48);
  tmp___19 = date_str;
  date_str ++;
  (*tmp___19) = (char )((real_year % 100) / 10 + 48);
  tmp___20 = date_str;
  date_str ++;
  (*tmp___20) = (char )(real_year % 10 + 48);
  tmp___21 = date_str;
  date_str ++;
  (*tmp___21) = (char )' ';
  tmp___22 = date_str;
  date_str ++;
  (*tmp___22) = (char )(xt.tm_hour / 10 + 48);
  tmp___23 = date_str;
  date_str ++;
  (*tmp___23) = (char )(xt.tm_hour % 10 + 48);
  tmp___24 = date_str;
  date_str ++;
  (*tmp___24) = (char )':';
  tmp___25 = date_str;
  date_str ++;
  (*tmp___25) = (char )(xt.tm_min / 10 + 48);
  tmp___26 = date_str;
  date_str ++;
  (*tmp___26) = (char )(xt.tm_min % 10 + 48);
  tmp___27 = date_str;
  date_str ++;
  (*tmp___27) = (char )':';
  tmp___28 = date_str;
  date_str ++;
  (*tmp___28) = (char )(xt.tm_sec / 10 + 48);
  tmp___29 = date_str;
  date_str ++;
  (*tmp___29) = (char )(xt.tm_sec % 10 + 48);
  tmp___30 = date_str;
  date_str ++;
  (*tmp___30) = (char )' ';
  tmp___31 = date_str;
  date_str ++;
  (*tmp___31) = (char )'G';
  tmp___32 = date_str;
  date_str ++;
  (*tmp___32) = (char )'M';
  tmp___33 = date_str;
  date_str ++;
  (*tmp___33) = (char )'T';
  tmp___34 = date_str;
  date_str ++;
  (*tmp___34) = (char)0;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-slKMhr71.i","-g -pthread")
apr_status_t apr_socket_create(apr_socket_t **new , int family , int type , apr_pool_t *cont ) ;
apr_status_t apr_socket_close(apr_socket_t *thesocket ) ;
apr_status_t apr_bind(apr_socket_t *sock , apr_sockaddr_t *sa ) ;
apr_status_t apr_connect(apr_socket_t *sock , apr_sockaddr_t *sa ) ;
apr_status_t apr_send(apr_socket_t *sock , char const   *buf , apr_size_t *len ) ;
apr_status_t apr_recv(apr_socket_t *sock , char *buf , apr_size_t *len ) ;
apr_status_t apr_socket_timeout_set(apr_socket_t *sock , apr_interval_time_t t ) ;
char *ap_rfc1413(conn_rec *conn , server_rec *srv ) ;
int ap_rfc1413_timeout  =    30;
static apr_status_t rfc1413_connect(apr_socket_t **newsock , conn_rec *conn , server_rec *srv ) 
{ apr_status_t rv ;
  apr_sockaddr_t *localsa ;
  apr_sockaddr_t *destsa ;

  {
  rv = apr_sockaddr_info_get(& localsa, (char const   *)conn->local_ip, 0, (unsigned short)0,
                             0, conn->pool);
  if (rv != 0) {
    ap_log_error("rfc1413.c", 125, 2, rv, (server_rec const   *)srv, "rfc1413: apr_sockaddr_info_get(%s) failed",
                 conn->local_ip);
    return (rv);
  }
  rv = apr_sockaddr_info_get(& destsa, (char const   *)conn->remote_ip, localsa->family,
                             (unsigned short)113, 0, conn->pool);
  if (rv != 0) {
    ap_log_error("rfc1413.c", 136, 2, rv, (server_rec const   *)srv, "rfc1413: apr_sockaddr_info_get(%s) failed",
                 conn->remote_ip);
    return (rv);
  }
  rv = apr_socket_create(newsock, localsa->family, 1, conn->pool);
  if (rv != 0) {
    ap_log_error("rfc1413.c", 145, 2, rv, (server_rec const   *)srv, "rfc1413: error creating query socket");
    return (rv);
  }
  rv = apr_socket_timeout_set((*newsock), (long long )ap_rfc1413_timeout * 1000000LL);
  if (rv != 0) {
    ap_log_error("rfc1413.c", 152, 2, rv, (server_rec const   *)srv, "rfc1413: error setting query socket timeout");
    apr_socket_close((*newsock));
    return (rv);
  }
  rv = apr_bind((*newsock), localsa);
  if (rv != 0) {
    ap_log_error("rfc1413.c", 168, 2, rv, (server_rec const   *)srv, "rfc1413: Error binding query socket to local port");
    apr_socket_close((*newsock));
    return (rv);
  }
  rv = apr_connect((*newsock), destsa);
  if (rv != 0) {
    apr_socket_close((*newsock));
    return (rv);
  }
  return (0);
}
}
static apr_status_t rfc1413_query(apr_socket_t *sock , conn_rec *conn , server_rec *srv ) 
{ apr_port_t rmt_port ;
  apr_port_t our_port ;
  apr_port_t sav_rmt_port ;
  apr_port_t sav_our_port ;
  apr_size_t i ;
  char *cp ;
  char buffer[1001] ;
  char user[513] ;
  apr_size_t buflen ;
  apr_size_t j ;
  apr_size_t tmp ;
  apr_status_t status ;
  apr_size_t j___0 ;
  apr_status_t status___0 ;
  int tmp___0 ;

  {
  apr_sockaddr_port_get(& sav_our_port, conn->local_addr);
  apr_sockaddr_port_get(& sav_rmt_port, conn->remote_addr);
  buflen = (apr_size_t )apr_snprintf(buffer, sizeof(buffer), "%hu,%hu\r\n", sav_rmt_port,
                                     sav_our_port);
  i = 0U;
  while (i < buflen) {
    tmp = strlen((char const   *)(buffer + i));
    j = tmp;
    status = apr_send(sock, (char const   *)(buffer + i), & j);
    if (status != 0) {
      ap_log_error("rfc1413.c", 212, 2, status, (server_rec const   *)srv, "write: rfc1413: error sending request");
      return (status);
    } else {
      if (j > 0U) {
        i += j;
      }
    }
  }
  i = 0U;
  memset((void *)(buffer), '\000', sizeof(buffer));
  while (1) {
    cp = strchr((char const   *)(buffer), '\n');
    if ((unsigned int )cp == (unsigned int )((void *)0)) {
      if (! (i < sizeof(buffer) - 1U)) {
        goto _L___0;
      }
    } else {
      _L___0: 
      break;
    }
    j___0 = (sizeof(buffer) - 1U) - i;
    status___0 = apr_recv(sock, buffer + i, & j___0);
    if (status___0 != 0) {
      ap_log_error("rfc1413.c", 238, 2, status___0, (server_rec const   *)srv, "read: rfc1413: error reading response");
      return (status___0);
    } else {
      if (j___0 > 0U) {
        i += j___0;
      } else {
        if (status___0 == 0) {
          if (j___0 == 0U) {
            return (22);
          } else {
            goto _L;
          }
        } else {
          _L: ;
        }
      }
    }
  }
  tmp___0 = sscanf((char const   * __restrict  )(buffer), (char const   * __restrict  )"%hu , %hu : USERID :%*[^:]:%512s",
                   & rmt_port, & our_port, user);
  if (tmp___0 != 3) {
    goto _L___2;
  } else {
    if ((int )sav_rmt_port != (int )rmt_port) {
      _L___2: 
      goto _L___1;
    } else {
      if ((int )sav_our_port != (int )our_port) {
        _L___1: 
        return (22);
      }
    }
  }
  cp = strchr((char const   *)(user), '\r');
  if (cp) {
    (*cp) = (char )'\000';
  }
  conn->remote_logname = apr_pstrdup(conn->pool, (char const   *)(user));
  return (0);
}
}
char *ap_rfc1413(conn_rec *conn , server_rec *srv ) 
{ apr_socket_t *sock ;
  apr_status_t rv ;

  {
  rv = rfc1413_connect(& sock, conn, srv);
  if (rv == 0) {
    rv = rfc1413_query(sock, conn, srv);
    apr_socket_close(sock);
  }
  if (rv != 0) {
    conn->remote_logname = (char *)"unknown";
  }
  return (conn->remote_logname);
}
}
#pragma merger(0,"/tmp/cil-XjxP1Dyu.i","-g -pthread")
apr_status_t apr_shutdown(apr_socket_t *thesocket , apr_shutdown_how_e how ) ;
void ap_flush_conn(conn_rec *c ) ;
void ap_hook_create_connection(ap_HOOK_create_connection_t *pf , char const   * const  *aszPre___1 ,
                               char const   * const  *aszSucc___2 , int nOrder ) ;
apr_array_header_t *ap_hook_get_create_connection(void) ;
void ap_hook_pre_connection(ap_HOOK_pre_connection_t *pf , char const   * const  *aszPre___1 ,
                            char const   * const  *aszSucc___2 , int nOrder ) ;
int ap_run_pre_connection(conn_rec *c , void *csd ) ;
apr_array_header_t *ap_hook_get_pre_connection(void) ;
int ap_run_process_connection(conn_rec *c ) ;
apr_array_header_t *ap_hook_get_process_connection(void) ;
static struct __anonstruct__hooks_97 _hooks___1  ;
void ap_hook_create_connection(ap_HOOK_create_connection_t *pf , char const   * const  *aszPre___1 ,
                               char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_create_connection_t *pHook ;

  {
  if (! _hooks___1.link_create_connection) {
    _hooks___1.link_create_connection = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_create_connection_t ));
    apr_hook_sort_register("create_connection", & _hooks___1.link_create_connection);
  }
  pHook = (ap_LINK_create_connection_t *)apr_array_push(_hooks___1.link_create_connection);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("create_connection", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_create_connection(void) 
{ 

  {
  return (_hooks___1.link_create_connection);
}
}
conn_rec *ap_run_create_connection(apr_pool_t *p , server_rec *server , apr_socket_t *csd ,
                                   long conn_id , void *sbh , apr_bucket_alloc_t *alloc ) 
{ ap_LINK_create_connection_t *pHook ;
  int n ;
  conn_rec *rv ;

  {
  if (! _hooks___1.link_create_connection) {
    return ((conn_rec *)((void *)0));
  }
  pHook = (ap_LINK_create_connection_t *)(_hooks___1.link_create_connection)->elts;
  n = 0;
  while (n < (_hooks___1.link_create_connection)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(p, server, csd, conn_id, sbh, alloc);
    if ((unsigned int )rv != (unsigned int )((void *)0)) {
      return (rv);
    }
    n ++;
  }
  return ((conn_rec *)((void *)0));
}
}
void ap_hook_process_connection(ap_HOOK_process_connection_t *pf , char const   * const  *aszPre___1 ,
                                char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_process_connection_t *pHook ;

  {
  if (! _hooks___1.link_process_connection) {
    _hooks___1.link_process_connection = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_process_connection_t ));
    apr_hook_sort_register("process_connection", & _hooks___1.link_process_connection);
  }
  pHook = (ap_LINK_process_connection_t *)apr_array_push(_hooks___1.link_process_connection);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("process_connection", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_process_connection(void) 
{ 

  {
  return (_hooks___1.link_process_connection);
}
}
int ap_run_process_connection(conn_rec *c ) 
{ ap_LINK_process_connection_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks___1.link_process_connection) {
    return (-1);
  }
  pHook = (ap_LINK_process_connection_t *)(_hooks___1.link_process_connection)->elts;
  n = 0;
  while (n < (_hooks___1.link_process_connection)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(c);
    if (rv != -1) {
      return (rv);
    }
    n ++;
  }
  return (-1);
}
}
void ap_hook_pre_connection(ap_HOOK_pre_connection_t *pf , char const   * const  *aszPre___1 ,
                            char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_pre_connection_t *pHook ;

  {
  if (! _hooks___1.link_pre_connection) {
    _hooks___1.link_pre_connection = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_pre_connection_t ));
    apr_hook_sort_register("pre_connection", & _hooks___1.link_pre_connection);
  }
  pHook = (ap_LINK_pre_connection_t *)apr_array_push(_hooks___1.link_pre_connection);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("pre_connection", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_pre_connection(void) 
{ 

  {
  return (_hooks___1.link_pre_connection);
}
}
int ap_run_pre_connection(conn_rec *c , void *csd ) 
{ ap_LINK_pre_connection_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks___1.link_pre_connection) {
    return (0);
  }
  pHook = (ap_LINK_pre_connection_t *)(_hooks___1.link_pre_connection)->elts;
  n = 0;
  while (n < (_hooks___1.link_pre_connection)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(c, csd);
    if (rv != 0) {
      if (rv != -1) {
        return (rv);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    n ++;
  }
  return (0);
}
}
void ap_flush_conn(conn_rec *c ) 
{ apr_bucket_brigade *bb ;
  apr_bucket *b ;
  apr_bucket *ap__b ;

  {
  bb = apr_brigade_create(c->pool, c->bucket_alloc);
  b = apr_bucket_flush_create(c->bucket_alloc);
  while (1) {
    ap__b = b;
    while (1) {
      ap__b->link.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                              (char *)((void *)0)));
      ap__b->link.prev = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                               (char *)((void *)0))))->link.prev;
      (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                             (char *)((void *)0))))->link.prev)->link.next = ap__b;
      ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                            (char *)((void *)0))))->link.prev = ap__b;
      break;
    }
    break;
  }
  ap_pass_brigade(c->output_filters, bb);
  return;
}
}
void ap_lingering_close(conn_rec *c ) 
{ char dummybuf[512] ;
  apr_size_t nbytes ;
  apr_status_t rc ;
  apr_int32_t timeout ;
  apr_int32_t total_linger_time ;
  apr_socket_t *csd ;
  apr_status_t tmp ;

  {
  nbytes = sizeof(dummybuf);
  total_linger_time = 0;
  csd = (apr_socket_t *)(*((void **)c->conn_config + core_module.module_index));
  if (! csd) {
    return;
  }
  ap_update_child_status((ap_sb_handle_t *)c->sbh, 8, (request_rec *)((void *)0));
  ap_flush_conn(c);
  if (c->aborted) {
    apr_socket_close(csd);
    return;
  }
  tmp = apr_shutdown(csd, (enum __anonenum_apr_shutdown_how_e_55 )1);
  if (tmp != 0) {
    goto _L;
  } else {
    if (c->aborted) {
      _L: 
      apr_socket_close(csd);
      return;
    }
  }
  timeout = 2000000;
  apr_socket_timeout_set(csd, (long long )timeout);
  apr_socket_opt_set(csd, 4096, 1);
  while (1) {
    nbytes = sizeof(dummybuf);
    rc = apr_recv(csd, dummybuf, & nbytes);
    if (rc != 0) {
      goto _L___0;
    } else {
      if (nbytes == 0U) {
        _L___0: 
        break;
      }
    }
    total_linger_time += 2;
    if (total_linger_time >= 30) {
      break;
    }
  }
  apr_socket_close(csd);
  return;
}
}
void ap_process_connection(conn_rec *c , void *csd ) 
{ 

  {
  ap_update_vhost_given_ip(c);
  ap_run_pre_connection(c, csd);
  if (! c->aborted) {
    ap_run_process_connection(c);
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-uXIR7CcV.i","-g -pthread")
apr_status_t apr_listen(apr_socket_t *sock , apr_int32_t backlog ) ;
apr_status_t unixd_accept(void **accepted , ap_listen_rec *lr , apr_pool_t *ptrans ) ;
void ap_sock_disable_nagle(apr_socket_t *s ) ;
ap_listen_rec *ap_listeners  =    (ap_listen_rec *)((void *)0);
static int default_family  =    0;
static ap_listen_rec *old_listeners  ;
static int ap_listenbacklog  ;
static int send_buffer_size  ;
static apr_status_t make_sock(apr_pool_t *p , ap_listen_rec *server ) 
{ apr_socket_t *s ;
  int one ;
  int v6only_setting ;
  apr_status_t stat___0 ;

  {
  s = server->sd;
  one = 1;
  v6only_setting = 0;
  stat___0 = apr_socket_opt_set(s, 16, one);
  if (stat___0 != 0) {
    if (stat___0 != 70023) {
      ap_log_perror("listen.c", 103, 2, stat___0, p, "make_sock: for address %pI, apr_socket_opt_set: (SO_REUSEADDR)",
                    server->bind_addr);
      apr_socket_close(s);
      return (stat___0);
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  stat___0 = apr_socket_opt_set(s, 2, one);
  if (stat___0 != 0) {
    if (stat___0 != 70023) {
      ap_log_perror("listen.c", 113, 2, stat___0, p, "make_sock: for address %pI, apr_socket_opt_set: (SO_KEEPALIVE)",
                    server->bind_addr);
      apr_socket_close(s);
      return (stat___0);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
  }
  if ((server->bind_addr)->family == 10) {
    stat___0 = apr_socket_opt_set(s, 16384, v6only_setting);
    if (stat___0 != 0) {
      if (stat___0 != 70023) {
        ap_log_perror("listen.c", 124, 2, stat___0, p, "make_sock: for address %pI, apr_socket_opt_set: (IPV6_V6ONLY)",
                      server->bind_addr);
        apr_socket_close(s);
        return (stat___0);
      } else {
        goto _L___1;
      }
    } else {
      _L___1: ;
    }
  }
  if (send_buffer_size) {
    stat___0 = apr_socket_opt_set(s, 64, send_buffer_size);
    if (stat___0 != 0) {
      if (stat___0 != 70023) {
        ap_log_perror("listen.c", 156, 4, stat___0, p, "make_sock: failed to set SendBufferSize for address %pI, using default",
                      server->bind_addr);
      } else {
        goto _L___2;
      }
    } else {
      _L___2: ;
    }
  }
  ap_sock_disable_nagle(s);
  stat___0 = apr_bind(s, server->bind_addr);
  if (stat___0 != 0) {
    ap_log_perror("listen.c", 169, 34, stat___0, p, "make_sock: could not bind to address %pI",
                  server->bind_addr);
    apr_socket_close(s);
    return (stat___0);
  }
  stat___0 = apr_listen(s, ap_listenbacklog);
  if (stat___0 != 0) {
    ap_log_perror("listen.c", 177, 35, stat___0, p, "make_sock: unable to listen for connections on address %pI",
                  server->bind_addr);
    apr_socket_close(s);
    return (stat___0);
  }
  server->sd = s;
  server->active = 1;
  server->accept_func = & unixd_accept;
  return (0);
}
}
static apr_status_t close_listeners_on_exec(void *v ) 
{ ap_listen_rec *lr ;

  {
  lr = ap_listeners;
  while (lr) {
    apr_socket_close(lr->sd);
    lr->active = 0;
    lr = lr->next;
  }
  return (0);
}
}
static void find_default_family(apr_pool_t *p ) 
{ apr_status_t sock_rv ;
  apr_socket_t *tmp_sock ;
  apr_sockaddr_t *sa ;
  apr_status_t tmp ;
  apr_status_t tmp___0 ;

  {
  if (default_family == 0) {
    sock_rv = apr_socket_create(& tmp_sock, 10, 1, p);
    if (sock_rv == 0) {
      tmp = apr_sockaddr_info_get(& sa, (char const   *)((void *)0), 10, (unsigned short)0,
                                  0, p);
      if (tmp == 0) {
        tmp___0 = apr_bind(tmp_sock, sa);
        if (tmp___0 == 0) {
          default_family = 10;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      default_family = 2;
    }
    if (sock_rv == 0) {
      apr_socket_close(tmp_sock);
    }
  }
  return;
}
}
static char const   *alloc_listener(process_rec *process , char *addr , apr_port_t port ) 
{ ap_listen_rec **walk ;
  ap_listen_rec *new ;
  apr_status_t status ;
  apr_port_t oldport ;
  apr_sockaddr_t *sa ;
  int tmp ;

  {
  if (! addr) {
    find_default_family(process->pool);
    switch (default_family) {
    case 2: 
    addr = (char *)"0.0.0.0";
    break;
    case 10: 
    addr = (char *)"::";
    break;
    default: 
    ap_log_assert("1 != 1", "listen.c", 292);
    }
  }
  walk = & old_listeners;
  while ((*walk)) {
    sa = ((*walk))->bind_addr;
    if (sa) {
      apr_sockaddr_port_get(& oldport, sa);
      tmp = strcmp((char const   *)sa->hostname, (char const   *)addr);
      if (tmp) {
        _L: ;
      } else {
        if ((int )port == (int )oldport) {
          new = (*walk);
          (*walk) = new->next;
          new->next = ap_listeners;
          ap_listeners = new;
          return ((char const   *)((void *)0));
        } else {
          goto _L;
        }
      }
    }
    walk = & ((*walk))->next;
  }
  new = (ap_listen_rec *)apr_palloc(process->pool, sizeof(ap_listen_rec ));
  new->active = 0;
  status = apr_sockaddr_info_get(& new->bind_addr, (char const   *)addr, 0, port,
                                 0, process->pool);
  if (status != 0) {
    ap_log_perror("listen.c", 319, 2, status, process->pool, "alloc_listener: failed to set up sockaddr for %s",
                  addr);
    return ("Listen setup failed");
  }
  status = apr_socket_create(& new->sd, (new->bind_addr)->family, 1, process->pool);
  if (status != 0) {
    ap_log_perror("listen.c", 328, 2, status, process->pool, "alloc_listener: failed to get a socket for %s",
                  addr);
    return ("Listen setup failed");
  }
  new->next = ap_listeners;
  ap_listeners = new;
  return ((char const   *)((void *)0));
}
}
static int ap_listen_open(apr_pool_t *pool , apr_port_t port ) 
{ ap_listen_rec *lr ;
  ap_listen_rec *next ;
  int num_open ;
  apr_status_t tmp ;
  int tmp___0 ;

  {
  num_open = 0;
  lr = ap_listeners;
  while (lr) {
    if (lr->active) {
      num_open ++;
    } else {
      tmp = make_sock(pool, lr);
      if (tmp == 0) {
        num_open ++;
        lr->active = 1;
      } else {
        return (-1);
      }
    }
    lr = lr->next;
  }
  lr = old_listeners;
  while (lr) {
    apr_socket_close(lr->sd);
    lr->active = 0;
    next = lr->next;
    lr = next;
  }
  old_listeners = (ap_listen_rec *)((void *)0);
  apr_pool_cleanup_register(pool, (void const   *)((void *)0), & apr_pool_cleanup_null,
                            & close_listeners_on_exec);
  if (num_open) {
    tmp___0 = 0;
  } else {
    tmp___0 = -1;
  }
  return (tmp___0);
}
}
int ap_setup_listeners(server_rec *s ) 
{ ap_listen_rec *lr ;
  int num_listeners ;
  int tmp ;

  {
  num_listeners = 0;
  tmp = ap_listen_open((s->process)->pool, s->port);
  if (tmp) {
    return (0);
  }
  lr = ap_listeners;
  while (lr) {
    num_listeners ++;
    lr = lr->next;
  }
  return (num_listeners);
}
}
void ap_listen_pre_config(void) 
{ 

  {
  old_listeners = ap_listeners;
  ap_listeners = (ap_listen_rec *)((void *)0);
  ap_listenbacklog = 511;
  return;
}
}
char const   *ap_set_listener(cmd_parms *cmd , void *dummy , char const   *ips ) 
{ char *host ;
  char *scope_id ;
  apr_port_t port ;
  apr_status_t rv ;
  char const   *err ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  rv = apr_parse_addr_port(& host, & scope_id, & port, ips, cmd->pool);
  if (rv != 0) {
    return ("Invalid address or port");
  }
  if (host) {
    tmp___0 = strcmp((char const   *)host, "*");
    if (tmp___0) {
      goto _L;
    } else {
      host = (char *)((void *)0);
    }
  } else {
    _L: ;
  }
  if (scope_id) {
    return ("Scope id is not supported");
  }
  if (! port) {
    return ("Port must be specified");
  }
  tmp___1 = alloc_listener((cmd->server)->process, host, port);
  return (tmp___1);
}
}
char const   *ap_set_listenbacklog(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ int b ;
  char const   *err ;
  char const   *tmp ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  b = atoi(arg);
  if (b < 1) {
    return ("ListenBacklog must be > 0");
  }
  ap_listenbacklog = b;
  return ((char const   *)((void *)0));
}
}
char const   *ap_set_send_buffer_size(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ int s ;
  int tmp ;
  char const   *err ;
  char const   *tmp___0 ;

  {
  tmp = atoi(arg);
  s = tmp;
  tmp___0 = ap_check_cmd_context(cmd, 31U);
  err = tmp___0;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  if (s < 512) {
    if (s != 0) {
      return ("SendBufferSize must be >= 512 bytes, or 0 for system default.");
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  send_buffer_size = s;
  return ((char const   *)((void *)0));
}
}
#pragma merger(0,"/tmp/cil-GdKiW2xQ.i","-g -pthread")
void apr_sleep(apr_interval_time_t t ) ;
apr_status_t apr_proc_wait(apr_proc_t *proc , int *exitcode , apr_exit_why_e *exitwhy ,
                           apr_wait_how_e waithow ) ;
apr_status_t apr_proc_wait_all_procs(apr_proc_t *proc , int *exitcode , apr_exit_why_e *exitwhy ,
                                     apr_wait_how_e waithow , apr_pool_t *p ) ;
void apr_proc_other_child_check(void) ;
char const   *apr_signal_description_get(int signum ) ;
char const   *ap_scoreboard_fname ;
extern struct passwd *getpwnam(char const   *__name ) ;
extern struct group *getgrnam(char const   *__name ) ;
uid_t ap_uname2id(char const   *name ) ;
gid_t ap_gname2id(char const   *name ) ;
char const   *ap_mpm_set_max_requests(cmd_parms *cmd , void *dummy , char const   *arg ) ;
char const   *ap_mpm_set_pidfile(cmd_parms *cmd , void *dummy , char const   *arg ) ;
char const   *ap_mpm_set_lockfile(cmd_parms *cmd , void *dummy , char const   *arg ) ;
char const   ap_valid_accept_mutex_string[103] ;
char const   *ap_mpm_set_accept_lock_mech(cmd_parms *cmd , void *dummy , char const   *arg ) ;
char const   *ap_mpm_set_scoreboard(cmd_parms *cmd , void *dummy , char const   *arg ) ;
char ap_coredump_dir[8192]  ;
char const   *ap_mpm_set_coredumpdir(cmd_parms *cmd , void *dummy , char const   *arg ) ;
int ap_signal_server(int *exit_status , apr_pool_t *pconf___0 ) ;
char const   *ap_mpm_set_max_mem_free(cmd_parms *cmd , void *dummy , char const   *arg ) ;
void ap_reclaim_child_processes(int terminate ) 
{ int i ;
  long waittime ;
  apr_status_t waitret ;
  int tries ;
  int not_dead_yet ;
  int max_daemons ;
  pid_t pid ;
  apr_proc_t proc ;

  {
  waittime = 16384L;
  ap_mpm_query(1, & max_daemons);
  if (terminate) {
    tries = 4;
  } else {
    tries = 1;
  }
  while (tries <= 9) {
    apr_sleep((long long )waittime);
    waittime = waittime * 4L;
    not_dead_yet = 0;
    i = 0;
    while (i < max_daemons) {
      pid = (ap_scoreboard_image->parent + i)->pid;
      if (pid == 0) {
        goto __Cont;
      }
      proc.pid = pid;
      waitret = apr_proc_wait(& proc, (int *)((void *)0), (apr_exit_why_e *)((void *)0),
                              (enum __anonenum_apr_wait_how_e_53 )1);
      if (waitret != 70006) {
        (ap_scoreboard_image->parent + i)->pid = 0;
        goto __Cont;
      }
      not_dead_yet ++;
      switch (tries) {
      case 1: ;
      case 2: ;
      case 3: ;
      case 4: ;
      break;
      case 5: ;
      case 6: ;
      case 7: 
      ap_log_error("mpm_common.c", 149, 4, 0, (server_rec const   *)ap_server_conf,
                   "child process %ld still did not exit, sending a SIGTERM", (long )pid);
      kill(pid, 15);
      break;
      case 8: 
      ap_log_error("mpm_common.c", 159, 3, 0, (server_rec const   *)ap_server_conf,
                   "child process %ld still did not exit, sending a SIGKILL", (long )pid);
      kill(pid, 9);
      break;
      case 9: 
      ap_log_error("mpm_common.c", 183, 3, 0, (server_rec const   *)ap_server_conf,
                   "could not make child process %ld exit, attempting to continue anyway",
                   (long )pid);
      break;
      }
      __Cont: 
      i ++;
    }
    apr_proc_other_child_check();
    if (! not_dead_yet) {
      break;
    }
    tries ++;
  }
  return;
}
}
static int wait_or_timeout_counter  ;
void ap_wait_or_timeout(apr_exit_why_e *status , int *exitcode , apr_proc_t *ret ,
                        apr_pool_t *p ) 
{ apr_status_t rv ;

  {
  wait_or_timeout_counter ++;
  if (wait_or_timeout_counter == 10) {
    wait_or_timeout_counter = 0;
  }
  rv = apr_proc_wait_all_procs(ret, exitcode, status, (enum __anonenum_apr_wait_how_e_53 )1,
                               p);
  if (rv == 4) {
    ret->pid = -1;
    return;
  }
  if (rv == 70005) {
    return;
  }
  apr_sleep(1000000LL);
  ret->pid = -1;
  return;
}
}
int ap_process_child_status(apr_proc_t *pid , apr_exit_why_e why , int status ) 
{ int signum ;
  char const   *sigdesc ;
  char const   *tmp ;

  {
  signum = status;
  tmp = apr_signal_description_get(signum);
  sigdesc = tmp;
  if ((int )why & 1) {
    if (status == 7) {
      return (status);
    }
    if (status == 15) {
      ap_log_error("mpm_common.c", 264, 1, 0, (server_rec const   *)ap_server_conf,
                   "Child %d returned a Fatal error...\nApache is exiting!", pid->pid);
      return (15);
    }
    return (0);
  }
  if ((int )why & 2) {
    switch (signum) {
    case 15: ;
    case 1: ;
    case 10: ;
    case 9: ;
    break;
    default: ;
    if ((int )why & 4) {
      ap_log_error("mpm_common.c", 286, 5, 0, (server_rec const   *)ap_server_conf,
                   "child pid %ld exit signal %s (%d), possible coredump in %s", (long )pid->pid,
                   sigdesc, signum, ap_coredump_dir);
    } else {
      ap_log_error("mpm_common.c", 294, 5, 0, (server_rec const   *)ap_server_conf,
                   "child pid %ld exit signal %s (%d)", (long )pid->pid, sigdesc,
                   signum);
    }
    }
  }
  return (0);
}
}
void ap_sock_disable_nagle(apr_socket_t *s ) 
{ apr_status_t status ;
  apr_status_t tmp ;

  {
  tmp = apr_socket_opt_set(s, 512, 1);
  status = tmp;
  if (status != 0) {
    ap_log_error("mpm_common.c", 320, 4, status, (server_rec const   *)ap_server_conf,
                 "apr_socket_opt_set: (TCP_NODELAY)");
  }
  return;
}
}
uid_t ap_uname2id(char const   *name ) 
{ struct passwd *ent ;
  uid_t tmp ;

  {
  if ((int const   )(*(name + 0)) == 35) {
    tmp = (uid_t )atoi(name + 1);
    return (tmp);
  }
  ent = getpwnam(name);
  if (! ent) {
    ap_log_error("mpm_common.c", 335, 32, 0, (server_rec const   *)((void *)0), "%s: bad user name %s",
                 ap_server_argv0, name);
    exit(1);
  }
  return (ent->pw_uid);
}
}
gid_t ap_gname2id(char const   *name ) 
{ struct group *ent ;
  gid_t tmp ;

  {
  if ((int const   )(*(name + 0)) == 35) {
    tmp = (gid_t )atoi(name + 1);
    return (tmp);
  }
  ent = getgrnam(name);
  if (! ent) {
    ap_log_error("mpm_common.c", 353, 32, 0, (server_rec const   *)((void *)0), "%s: bad group name %s",
                 ap_server_argv0, name);
    exit(1);
  }
  return (ent->gr_gid);
}
}
apr_status_t ap_mpm_pod_open(apr_pool_t *p , ap_pod_t **pod___0 ) 
{ apr_status_t rv ;

  {
  (*pod___0) = (ap_pod_t *)apr_palloc(p, sizeof((*((*pod___0)))));
  rv = apr_file_pipe_create(& ((*pod___0))->pod_in, & ((*pod___0))->pod_out, p);
  if (rv != 0) {
    return (rv);
  }
  apr_file_pipe_timeout_set(((*pod___0))->pod_in, 0LL);
  ((*pod___0))->p = p;
  apr_sockaddr_info_get(& ((*pod___0))->sa, (char const   *)(ap_listeners->bind_addr)->hostname,
                        0, (ap_listeners->bind_addr)->port, 0, p);
  return (0);
}
}
apr_status_t ap_mpm_pod_check(ap_pod_t *pod___0 ) 
{ char c ;
  apr_size_t len ;
  apr_status_t rv ;

  {
  len = 1U;
  rv = apr_file_read(pod___0->pod_in, (void *)(& c), & len);
  if (rv == 0) {
    if (len == 1U) {
      return (0);
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if (rv != 0) {
    return (rv);
  }
  return (120001);
}
}
apr_status_t ap_mpm_pod_close(ap_pod_t *pod___0 ) 
{ apr_status_t rv ;

  {
  rv = apr_file_close(pod___0->pod_out);
  if (rv != 0) {
    return (rv);
  }
  rv = apr_file_close(pod___0->pod_in);
  if (rv != 0) {
    return (rv);
  }
  return (0);
}
}
static apr_status_t pod_signal_internal(ap_pod_t *pod___0 ) 
{ apr_status_t rv ;
  char char_of_death ;
  apr_size_t one ;

  {
  char_of_death = (char )'!';
  one = 1U;
  rv = apr_file_write(pod___0->pod_out, (void const   *)(& char_of_death), & one);
  if (rv != 0) {
    ap_log_error("mpm_common.c", 460, 4, rv, (server_rec const   *)ap_server_conf,
                 "write pipe_of_death");
  }
  return (rv);
}
}
static apr_status_t dummy_connection(ap_pod_t *pod___0 ) 
{ apr_status_t rv ;
  apr_socket_t *sock ;
  apr_pool_t *p ;
  int log_level ;

  {
  rv = apr_pool_create_ex(& p, pod___0->p, (int (*)(int retcode ))((void *)0), (apr_allocator_t *)((void *)0));
  if (rv != 0) {
    return (rv);
  }
  rv = apr_socket_create(& sock, (pod___0->sa)->family, 1, p);
  if (rv != 0) {
    ap_log_error("mpm_common.c", 486, 4, rv, (server_rec const   *)ap_server_conf,
                 "get socket to connect to listener");
    return (rv);
  }
  rv = apr_socket_timeout_set(sock, 3000000LL);
  if (rv != 0) {
    ap_log_error("mpm_common.c", 499, 4, rv, (server_rec const   *)ap_server_conf,
                 "set timeout on socket to connect to listener");
    apr_socket_close(sock);
    return (rv);
  }
  rv = apr_connect(sock, pod___0->sa);
  if (rv != 0) {
    log_level = 4;
    if (rv == 70007) {
      log_level = 7;
    }
    ap_log_error("mpm_common.c", 517, log_level, rv, (server_rec const   *)ap_server_conf,
                 "connect to listener");
  }
  apr_socket_close(sock);
  apr_pool_destroy(p);
  return (rv);
}
}
apr_status_t ap_mpm_pod_signal(ap_pod_t *pod___0 ) 
{ apr_status_t rv ;
  apr_status_t tmp ;

  {
  rv = pod_signal_internal(pod___0);
  if (rv != 0) {
    return (rv);
  }
  tmp = dummy_connection(pod___0);
  return (tmp);
}
}
void ap_mpm_pod_killpg(ap_pod_t *pod___0 , int num ) 
{ int i ;
  apr_status_t rv ;

  {
  rv = 0;
  i = 0;
  while (1) {
    if (i < num) {
      if (! (rv == 0)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
    rv = dummy_connection(pod___0);
    i ++;
  }
  return;
}
}
char const   *ap_pid_fname  =    (char const   *)((void *)0);
char const   *ap_mpm_set_pidfile(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  if ((cmd->server)->is_virtual) {
    return ("PidFile directive not allowed in <VirtualHost>");
  }
  ap_pid_fname = arg;
  return ((char const   *)((void *)0));
}
}
char const   *ap_mpm_set_scoreboard(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  ap_scoreboard_fname = arg;
  return ((char const   *)((void *)0));
}
}
char const   *ap_lock_fname  =    (char const   *)((void *)0);
char const   *ap_mpm_set_lockfile(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  ap_lock_fname = arg;
  return ((char const   *)((void *)0));
}
}
int ap_max_requests_per_child  =    0;
char const   *ap_mpm_set_max_requests(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  ap_max_requests_per_child = atoi(arg);
  return ((char const   *)((void *)0));
}
}
char const   *ap_mpm_set_coredumpdir(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ apr_status_t rv ;
  apr_finfo_t finfo ;
  char const   *fname ;
  char const   *err ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  fname = ap_server_root_relative(cmd->pool, arg);
  if (! fname) {
    tmp___0 = apr_pstrcat(cmd->pool, "Invalid CoreDumpDirectory path ", arg, (void *)0);
    return (tmp___0);
  }
  rv = apr_stat(& finfo, fname, 32768, cmd->pool);
  if (rv != 0) {
    tmp___1 = apr_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, " does not exist",
                          (void *)0);
    return (tmp___1);
  }
  if ((int )finfo.filetype != 2) {
    tmp___2 = apr_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, " is not a directory",
                          (void *)0);
    return (tmp___2);
  }
  apr_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
  return ((char const   *)((void *)0));
}
}
int ap_accept_lock_mech  =    (int )5;
char const   ap_valid_accept_mutex_string[103]  = 
  {      (char const   )'V',      (char const   )'a',      (char const   )'l',      (char const   )'i', 
        (char const   )'d',      (char const   )' ',      (char const   )'a',      (char const   )'c', 
        (char const   )'c',      (char const   )'e',      (char const   )'p',      (char const   )'t', 
        (char const   )' ',      (char const   )'m',      (char const   )'u',      (char const   )'t', 
        (char const   )'e',      (char const   )'x',      (char const   )'e',      (char const   )'s', 
        (char const   )' ',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'i', 
        (char const   )'s',      (char const   )' ',      (char const   )'p',      (char const   )'l', 
        (char const   )'a',      (char const   )'t',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )'m',      (char const   )' ',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'M', 
        (char const   )'P',      (char const   )'M',      (char const   )' ',      (char const   )'a', 
        (char const   )'r',      (char const   )'e',      (char const   )':',      (char const   )' ', 
        (char const   )'d',      (char const   )'e',      (char const   )'f',      (char const   )'a', 
        (char const   )'u',      (char const   )'l',      (char const   )'t',      (char const   )',', 
        (char const   )' ',      (char const   )'f',      (char const   )'l',      (char const   )'o', 
        (char const   )'c',      (char const   )'k',      (char const   )',',      (char const   )' ', 
        (char const   )'f',      (char const   )'c',      (char const   )'n',      (char const   )'t', 
        (char const   )'l',      (char const   )',',      (char const   )' ',      (char const   )'s', 
        (char const   )'y',      (char const   )'s',      (char const   )'v',      (char const   )'s', 
        (char const   )'e',      (char const   )'m',      (char const   )',',      (char const   )' ', 
        (char const   )'p',      (char const   )'o',      (char const   )'s',      (char const   )'i', 
        (char const   )'x',      (char const   )'s',      (char const   )'e',      (char const   )'m', 
        (char const   )',',      (char const   )' ',      (char const   )'p',      (char const   )'t', 
        (char const   )'h',      (char const   )'r',      (char const   )'e',      (char const   )'a', 
        (char const   )'d',      (char const   )'.',      (char const   )'\000'};
char const   *ap_mpm_set_accept_lock_mech(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  tmp___6 = strcasecmp(arg, "default");
  if (tmp___6) {
    tmp___5 = strcasecmp(arg, "flock");
    if (tmp___5) {
      tmp___4 = strcasecmp(arg, "fcntl");
      if (tmp___4) {
        tmp___3 = strcasecmp(arg, "sysvsem");
        if (tmp___3) {
          tmp___2 = strcasecmp(arg, "posixsem");
          if (tmp___2) {
            tmp___1 = strcasecmp(arg, "pthread");
            if (tmp___1) {
              tmp___0 = apr_pstrcat(cmd->pool, arg, " is an invalid mutex mechanism; ",
                                    ap_valid_accept_mutex_string, (void *)0);
              return (tmp___0);
            } else {
              ap_accept_lock_mech = (int )3;
            }
          } else {
            ap_accept_lock_mech = (int )4;
          }
        } else {
          ap_accept_lock_mech = (int )2;
        }
      } else {
        ap_accept_lock_mech = (int )0;
      }
    } else {
      ap_accept_lock_mech = (int )1;
    }
  } else {
    ap_accept_lock_mech = (int )5;
  }
  return ((char const   *)((void *)0));
}
}
static char const   *dash_k_arg  ;
static int send_signal(pid_t pid , int sig ) 
{ int *tmp ;
  int tmp___0 ;

  {
  tmp___0 = kill(pid, sig);
  if (tmp___0 < 0) {
    tmp = __errno_location();
    ap_log_error("mpm_common.c", 744, 32, (*tmp), (server_rec const   *)((void *)0),
                 "sending signal to server");
    return (1);
  }
  return (0);
}
}
int ap_signal_server(int *exit_status , apr_pool_t *pconf___0 ) 
{ apr_status_t rv ;
  pid_t otherpid ;
  int running ;
  int have_pid_file ;
  char const   *status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  running = 0;
  have_pid_file = 0;
  (*exit_status) = 0;
  rv = ap_read_pid(pconf___0, ap_pid_fname, & otherpid);
  if (rv != 0) {
    if (rv != 2) {
      ap_log_error("mpm_common.c", 764, 32, rv, (server_rec const   *)((void *)0),
                   "Error retrieving pid file %s", ap_pid_fname);
      (*exit_status) = 1;
      return (1);
    }
    status = "httpd (no pid file) not running";
  } else {
    have_pid_file = 1;
    tmp = kill(otherpid, 0);
    if (tmp == 0) {
      running = 1;
      status = apr_psprintf(pconf___0, "httpd (pid %d) already running", otherpid);
    } else {
      status = apr_psprintf(pconf___0, "httpd (pid %d?) not running", otherpid);
    }
  }
  tmp___0 = strcmp(dash_k_arg, "start");
  if (! tmp___0) {
    if (running) {
      printf((char const   * __restrict  )"%s\n", status);
      return (1);
    }
  }
  tmp___1 = strcmp(dash_k_arg, "stop");
  if (! tmp___1) {
    if (! running) {
      printf((char const   * __restrict  )"%s\n", status);
    } else {
      send_signal(otherpid, 15);
    }
    return (1);
  }
  tmp___2 = strcmp(dash_k_arg, "restart");
  if (! tmp___2) {
    if (! running) {
      printf((char const   * __restrict  )"httpd not running, trying to start\n");
    } else {
      (*exit_status) = send_signal(otherpid, 1);
      return (1);
    }
  }
  tmp___3 = strcmp(dash_k_arg, "graceful");
  if (! tmp___3) {
    if (! running) {
      printf((char const   * __restrict  )"httpd not running, trying to start\n");
    } else {
      (*exit_status) = send_signal(otherpid, 10);
      return (1);
    }
  }
  return (0);
}
}
void ap_mpm_rewrite_args(process_rec *process ) 
{ apr_array_header_t *mpm_new_argv ;
  apr_status_t rv ;
  apr_getopt_t *opt ;
  char optbuf[3] ;
  char const   *optarg ;
  int fixed_args ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;

  {
  mpm_new_argv = apr_array_make(process->pool, process->argc, (int )sizeof(char const   **));
  tmp = apr_array_push(mpm_new_argv);
  (*((char const   **)tmp)) = (char const   *)(*(process->argv + 0));
  fixed_args = mpm_new_argv->nelts;
  apr_getopt_init(& opt, process->pool, process->argc, process->argv);
  opt->errfn = (apr_getopt_err_fn_t *)((void *)0);
  optbuf[0] = (char )'-';
  optbuf[2] = (char )'\000';
  while (1) {
    rv = apr_getopt(opt, "k:C:c:D:d:E:e:f:vVlLtSh?X", optbuf + 1, & optarg);
    if (! (rv == 0)) {
      break;
    }
    switch ((int )optbuf[1]) {
    case 107: ;
    if (! dash_k_arg) {
      tmp___0 = strcmp(optarg, "start");
      if (tmp___0) {
        tmp___1 = strcmp(optarg, "stop");
        if (tmp___1) {
          tmp___2 = strcmp(optarg, "restart");
          if (tmp___2) {
            tmp___3 = strcmp(optarg, "graceful");
            if (! tmp___3) {
              _L: 
              dash_k_arg = optarg;
              break;
            }
          } else {
            _L___0: 
            goto _L;
          }
        } else {
          _L___1: 
          goto _L___0;
        }
      } else {
        goto _L___1;
      }
    }
    default: 
    tmp___4 = apr_array_push(mpm_new_argv);
    (*((char const   **)tmp___4)) = apr_pstrdup(process->pool, (char const   *)(optbuf));
    if (optarg) {
      tmp___5 = apr_array_push(mpm_new_argv);
      (*((char const   **)tmp___5)) = optarg;
    }
    }
  }
  if (rv == 70012) {
    goto _L___2;
  } else {
    if (rv == 70013) {
      _L___2: 
      opt->ind = opt->ind - 1;
    }
  }
  while (opt->ind < opt->argc) {
    tmp___6 = apr_array_push(mpm_new_argv);
    tmp___7 = opt->ind;
    opt->ind = opt->ind + 1;
    (*((char const   **)tmp___6)) = apr_pstrdup(process->pool, (*(opt->argv + tmp___7)));
  }
  process->argc = mpm_new_argv->nelts;
  process->argv = (char const   * const  *)mpm_new_argv->elts;
  if (dash_k_arg) {
    ((*((void (*)(char const   * , apr_OFN_ap_signal_server_t * ))(& apr_dynamic_fn_register))))("ap_signal_server",
                                                                                                 & ap_signal_server);
  }
  return;
}
}
unsigned int ap_max_mem_free  =    0U;
char const   *ap_mpm_set_max_mem_free(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ long value ;
  char const   *err ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  value = strtol((char const   * __restrict  )arg, (char ** __restrict  )((void *)0),
                 0);
  if (value < 0L) {
    goto _L;
  } else {
    tmp___1 = __errno_location();
    if ((*tmp___1) == 34) {
      _L: 
      tmp___0 = apr_pstrcat(cmd->pool, "Invalid MaxMemFree value: ", arg, (void *)0);
      return (tmp___0);
    }
  }
  ap_max_mem_free = (unsigned int )value * 1024U;
  return ((char const   *)((void *)0));
}
}
#pragma merger(0,"/tmp/cil-9ggogkl3.i","-g -pthread")
#pragma merger(0,"/tmp/cil-oUDdaibQ.i","-g -pthread")
#pragma merger(0,"/tmp/cil-Fygx39Rm.i","-g -pthread")
apr_xml_parser *apr_xml_parser_create(apr_pool_t *pool ) ;
apr_status_t apr_xml_parser_feed(apr_xml_parser *parser , char const   *data , apr_size_t len ) ;
apr_status_t apr_xml_parser_done(apr_xml_parser *parser , apr_xml_doc **pdoc ) ;
char *apr_xml_parser_geterror(apr_xml_parser *parser , char *errbuf , apr_size_t errbufsize ) ;
size_t ap_get_limit_xml_body(request_rec const   *r ) ;
int ap_xml_parse_input(request_rec *r , apr_xml_doc **pdoc ) ;
int ap_xml_parse_input(request_rec *r , apr_xml_doc **pdoc ) 
{ apr_xml_parser *parser ;
  int result ;
  apr_status_t status ;
  char errbuf[200] ;
  long len ;
  char *buffer ;
  apr_size_t total_read ;
  apr_size_t limit_xml_body ;
  apr_size_t tmp ;
  int tmp___0 ;

  {
  result = ap_setup_client_block(r, 2);
  if (result != 0) {
    return (result);
  }
  if (r->remaining == 0L) {
    (*pdoc) = (apr_xml_doc *)((void *)0);
    return (0);
  }
  parser = apr_xml_parser_create(r->pool);
  tmp___0 = ap_should_client_block(r);
  if (tmp___0) {
    total_read = 0U;
    tmp = ap_get_limit_xml_body((request_rec const   *)r);
    limit_xml_body = tmp;
    buffer = (char *)apr_palloc(r->pool, 2048U);
    while (1) {
      len = ap_get_client_block(r, buffer, 2048U);
      if (! (len > 0L)) {
        break;
      }
      total_read = (unsigned int )((unsigned long )total_read + (unsigned long )len);
      if (limit_xml_body) {
        if (total_read > limit_xml_body) {
          ap_log_rerror("util_xml.c", 99, 3, 0, (request_rec const   *)r, "XML request body is larger than the configured limit of %lu",
                        (unsigned long )limit_xml_body);
          goto read_error;
        } else {
          goto _L;
        }
      } else {
        _L: ;
      }
      status = apr_xml_parser_feed(parser, (char const   *)buffer, (unsigned int )len);
      if (status) {
        goto parser_error;
      }
    }
    if (len == -1L) {
      goto read_error;
    }
  }
  status = apr_xml_parser_done(parser, pdoc);
  if (status) {
    ap_log_rerror("util_xml.c", 118, 3, 0, (request_rec const   *)r, "XML parser error (at end). status=%d",
                  status);
    return (400);
  }
  return (0);
  parser_error: 
  apr_xml_parser_geterror(parser, errbuf, sizeof(errbuf));
  ap_log_rerror("util_xml.c", 127, 3, 0, (request_rec const   *)r, "%s", errbuf);
  read_error: 
  apr_xml_parser_done(parser, (apr_xml_doc **)((void *)0));
  return (400);
}
}
#pragma merger(0,"/tmp/cil-pe2Nq4VK.i","-g -pthread")
apr_status_t apr_brigade_vputstrs(apr_bucket_brigade *b , apr_status_t (*flush)(apr_bucket_brigade *bb ,
                                                                                void *ctx ) ,
                                  void *ctx , va_list va ) ;
apr_status_t apr_brigade_vprintf(apr_bucket_brigade *b , apr_status_t (*flush)(apr_bucket_brigade *bb ,
                                                                               void *ctx ) ,
                                 void *ctx , char const   *fmt , va_list va ) ;
ap_filter_t *ap_add_input_filter_handle(ap_filter_rec_t *f , void *ctx , request_rec *r ,
                                        conn_rec *c ) ;
ap_filter_rec_t *ap_get_input_filter_handle(char const   *name ) ;
ap_filter_rec_t *ap_get_output_filter_handle(char const   *name ) ;
void ap_remove_input_filter(ap_filter_t *f ) ;
apr_status_t ap_filter_flush(apr_bucket_brigade *bb , void *ctx ) ;
apr_status_t ap_fflush(ap_filter_t *f , apr_bucket_brigade *bb ) ;
apr_status_t ap_fputstrs(ap_filter_t *f , apr_bucket_brigade *bb  , ...) ;
apr_status_t ap_fprintf(ap_filter_t *f , apr_bucket_brigade *bb , char const   *fmt 
                        , ...) ;
static void trie_node_link(apr_pool_t *p , filter_trie_node *parent , filter_trie_node *child ,
                           int c ) 
{ int i ;
  int j ;
  filter_trie_child_ptr *new ;

  {
  if (parent->nchildren == parent->size) {
    parent->size *= 2;
    new = (filter_trie_child_ptr *)apr_palloc(p, (unsigned int )parent->size * sizeof(filter_trie_child_ptr ));
    memcpy((void * __restrict  )new, (void const   * __restrict  )parent->children,
           (unsigned int )parent->nchildren * sizeof(filter_trie_child_ptr ));
    parent->children = new;
  }
  i = 0;
  while (i < parent->nchildren) {
    if (c == (parent->children + i)->c) {
      return;
    } else {
      if (c < (parent->children + i)->c) {
        break;
      }
    }
    i ++;
  }
  j = parent->nchildren;
  while (j > i) {
    (parent->children + j)->c = (parent->children + (j - 1))->c;
    (parent->children + j)->child = (parent->children + (j - 1))->child;
    j --;
  }
  (parent->children + i)->c = c;
  (parent->children + i)->child = child;
  parent->nchildren ++;
  return;
}
}
static filter_trie_node *trie_node_alloc(apr_pool_t *p , filter_trie_node *parent ,
                                         char c ) 
{ filter_trie_node *new_node ;
  int i ;

  {
  if (parent) {
    i = 0;
    while (i < parent->nchildren) {
      if ((int )c == (parent->children + i)->c) {
        return ((parent->children + i)->child);
      } else {
        if ((int )c < (parent->children + i)->c) {
          break;
        }
      }
      i ++;
    }
    new_node = (filter_trie_node *)apr_palloc(p, sizeof(filter_trie_node ));
    trie_node_link(p, parent, new_node, (int )c);
  } else {
    new_node = (filter_trie_node *)apr_palloc(p, sizeof(filter_trie_node ));
  }
  new_node->frec = (ap_filter_rec_t *)((void *)0);
  new_node->nchildren = 0;
  new_node->size = 4;
  new_node->children = (filter_trie_child_ptr *)apr_palloc(p, (unsigned int )new_node->size *
                                                              sizeof(filter_trie_child_ptr ));
  return (new_node);
}
}
static filter_trie_node *registered_output_filters  =    (filter_trie_node *)((void *)0);
static filter_trie_node *registered_input_filters  =    (filter_trie_node *)((void *)0);
static apr_status_t filter_cleanup(void *ctx ) 
{ 

  {
  registered_output_filters = (filter_trie_node *)((void *)0);
  registered_input_filters = (filter_trie_node *)((void *)0);
  return (0);
}
}
static ap_filter_rec_t *get_filter_handle(char const   *name , filter_trie_node const   *filter_set ) 
{ char const   *n ;
  filter_trie_node const   *node ;
  int start ;
  int end ;
  int middle ;
  char ch ;

  {
  if (filter_set) {
    node = filter_set;
    n = name;
    while ((*n)) {
      start = 0;
      end = node->nchildren - 1;
      while (end >= start) {
        middle = (end + start) / 2;
        ch = (char )(node->children + middle)->c;
        if ((int const   )(*n) == (int const   )ch) {
          node = (filter_trie_node const   *)(node->children + middle)->child;
          break;
        } else {
          if ((int const   )(*n) < (int const   )ch) {
            end = middle - 1;
          } else {
            start = middle + 1;
          }
        }
      }
      if (end < start) {
        node = (filter_trie_node const   *)((void *)0);
        break;
      }
      n ++;
    }
    if (node) {
      if (node->frec) {
        return (node->frec);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
  }
  return ((ap_filter_rec_t *)((void *)0));
}
}
ap_filter_rec_t *ap_get_output_filter_handle(char const   *name ) 
{ ap_filter_rec_t *tmp ;

  {
  tmp = get_filter_handle(name, (filter_trie_node const   *)registered_output_filters);
  return (tmp);
}
}
ap_filter_rec_t *ap_get_input_filter_handle(char const   *name ) 
{ ap_filter_rec_t *tmp ;

  {
  tmp = get_filter_handle(name, (filter_trie_node const   *)registered_input_filters);
  return (tmp);
}
}
static ap_filter_rec_t *register_filter(char const   *name , ap_filter_func filter_func ,
                                        int (*filter_init)(ap_filter_t *f ) , ap_filter_type ftype ,
                                        filter_trie_node **reg_filter_set ) 
{ ap_filter_rec_t *frec ;
  char *normalized_name ;
  char const   *n ;
  filter_trie_node *node ;
  filter_trie_node *child ;
  filter_trie_node *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  if (! (*reg_filter_set)) {
    (*reg_filter_set) = trie_node_alloc(apr_hook_global_pool, (filter_trie_node *)((void *)0),
                                        (char)0);
  }
  normalized_name = apr_pstrdup(apr_hook_global_pool, name);
  ap_str_tolower(normalized_name);
  node = (*reg_filter_set);
  n = (char const   *)normalized_name;
  while ((*n)) {
    tmp = trie_node_alloc(apr_hook_global_pool, node, (char )(*n));
    child = tmp;
    tmp___1 = __ctype_b_loc();
    if ((int const   )(*((*tmp___1) + (int )((unsigned char )(*n)))) & 1024) {
      tmp___0 = toupper((int )((unsigned char )(*n)));
      trie_node_link(apr_hook_global_pool, node, child, tmp___0);
    }
    node = child;
    n ++;
  }
  if (node->frec) {
    frec = node->frec;
  } else {
    frec = (ap_filter_rec_t *)apr_palloc(apr_hook_global_pool, sizeof((*frec)));
    node->frec = frec;
    frec->name = (char const   *)normalized_name;
  }
  frec->filter_func = filter_func;
  frec->filter_init_func = filter_init;
  frec->ftype = ftype;
  apr_pool_cleanup_register(apr_hook_global_pool, (void const   *)((void *)0), & filter_cleanup,
                            & apr_pool_cleanup_null);
  return (frec);
}
}
ap_filter_rec_t *ap_register_input_filter(char const   *name , apr_status_t (*filter_func)(ap_filter_t *f ,
                                                                                           apr_bucket_brigade *b ,
                                                                                           ap_input_mode_t mode ,
                                                                                           apr_read_type_e block ,
                                                                                           apr_off_t readbytes ) ,
                                          int (*filter_init)(ap_filter_t *f ) , ap_filter_type ftype ) 
{ ap_filter_func f ;
  ap_filter_rec_t *tmp ;

  {
  f.in_func = filter_func;
  tmp = register_filter(name, f, filter_init, ftype, & registered_input_filters);
  return (tmp);
}
}
ap_filter_rec_t *ap_register_output_filter(char const   *name , apr_status_t (*filter_func)(ap_filter_t *f ,
                                                                                            apr_bucket_brigade *b ) ,
                                           int (*filter_init)(ap_filter_t *f ) , ap_filter_type ftype ) 
{ ap_filter_func f ;
  ap_filter_rec_t *tmp ;

  {
  f.out_func = filter_func;
  tmp = register_filter(name, f, filter_init, ftype, & registered_output_filters);
  return (tmp);
}
}
static ap_filter_t *add_any_filter_handle(ap_filter_rec_t *frec , void *ctx , request_rec *r ,
                                          conn_rec *c , ap_filter_t **r_filters ,
                                          ap_filter_t **p_filters , ap_filter_t **c_filters ) 
{ apr_pool_t *p ;
  apr_pool_t *tmp ;
  ap_filter_t *f ;
  ap_filter_t *tmp___0 ;
  ap_filter_t **outf ;
  ap_filter_t *first ;
  ap_filter_t *fscan ;

  {
  if (r) {
    tmp = r->pool;
  } else {
    tmp = c->pool;
  }
  p = tmp;
  tmp___0 = (ap_filter_t *)apr_palloc(p, sizeof((*f)));
  f = tmp___0;
  if ((int )frec->ftype < 30) {
    if (r) {
      outf = r_filters;
    } else {
      ap_log_error("util_filter.c", 315, 3, 0, (server_rec const   *)((void *)0),
                   "a content filter was added without a request: %s", frec->name);
      return ((ap_filter_t *)((void *)0));
    }
  } else {
    if ((int )frec->ftype < 50) {
      if (r) {
        outf = p_filters;
      } else {
        ap_log_error("util_filter.c", 325, 3, 0, (server_rec const   *)((void *)0),
                     "a protocol filter was added without a request: %s", frec->name);
        return ((ap_filter_t *)((void *)0));
      }
    } else {
      outf = c_filters;
    }
  }
  f->frec = frec;
  f->ctx = ctx;
  f->r = r;
  f->c = c;
  f->next = (ap_filter_t *)((void *)0);
  if ((unsigned int )(*outf) == (unsigned int )((void *)0)) {
    goto _L___4;
  } else {
    if ((int )(((*outf))->frec)->ftype > (int )(f->frec)->ftype) {
      _L___4: 
      goto _L___3;
    } else {
      if ((unsigned int )((*outf))->r != (unsigned int )f->r) {
        _L___3: 
        f->next = (*outf);
        if ((*outf)) {
          first = (ap_filter_t *)((void *)0);
          if (r) {
            if ((unsigned int )(*r_filters) != (unsigned int )(*c_filters)) {
              first = (*r_filters);
              while (1) {
                if (first) {
                  if (! ((unsigned int )first->next != (unsigned int )(*outf))) {
                    goto _L;
                  }
                } else {
                  _L: 
                  break;
                }
                first = first->next;
              }
            }
          }
          if (first) {
            if ((unsigned int )first != (unsigned int )(*outf)) {
              first->next = f;
            } else {
              goto _L___0;
            }
          } else {
            _L___0: ;
          }
        }
        (*outf) = f;
      } else {
        fscan = (*outf);
        while (1) {
          if ((unsigned int )fscan->next == (unsigned int )((void *)0)) {
            goto _L___2;
          } else {
            if ((int )((fscan->next)->frec)->ftype > (int )(f->frec)->ftype) {
              _L___2: 
              goto _L___1;
            } else {
              if ((unsigned int )(fscan->next)->r != (unsigned int )f->r) {
                _L___1: 
                break;
              }
            }
          }
          fscan = fscan->next;
        }
        f->next = fscan->next;
        fscan->next = f;
      }
    }
  }
  if ((int )frec->ftype < 50) {
    if ((unsigned int )(*r_filters) == (unsigned int )(*c_filters)) {
      (*r_filters) = (*p_filters);
    } else {
      goto _L___5;
    }
  } else {
    _L___5: ;
  }
  return (f);
}
}
static ap_filter_t *add_any_filter(char const   *name , void *ctx , request_rec *r ,
                                   conn_rec *c , filter_trie_node const   *reg_filter_set ,
                                   ap_filter_t **r_filters , ap_filter_t **p_filters ,
                                   ap_filter_t **c_filters ) 
{ char const   *n ;
  filter_trie_node const   *node ;
  int start ;
  int end ;
  int middle ;
  char ch ;
  ap_filter_t *tmp ;

  {
  if (reg_filter_set) {
    node = reg_filter_set;
    n = name;
    while ((*n)) {
      start = 0;
      end = node->nchildren - 1;
      while (end >= start) {
        middle = (end + start) / 2;
        ch = (char )(node->children + middle)->c;
        if ((int const   )(*n) == (int const   )ch) {
          node = (filter_trie_node const   *)(node->children + middle)->child;
          break;
        } else {
          if ((int const   )(*n) < (int const   )ch) {
            end = middle - 1;
          } else {
            start = middle + 1;
          }
        }
      }
      if (end < start) {
        node = (filter_trie_node const   *)((void *)0);
        break;
      }
      n ++;
    }
    if (node) {
      if (node->frec) {
        tmp = add_any_filter_handle(node->frec, ctx, r, c, r_filters, p_filters, c_filters);
        return (tmp);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
  }
  ap_log_error("util_filter.c", 421, 3, 0, (server_rec const   *)((void *)0), "an unknown filter was not added: %s",
               name);
  return ((ap_filter_t *)((void *)0));
}
}
ap_filter_t *ap_add_input_filter(char const   *name , void *ctx , request_rec *r ,
                                 conn_rec *c ) 
{ struct ap_filter_t **tmp ;
  struct ap_filter_t **tmp___0 ;
  ap_filter_t *tmp___1 ;

  {
  if (r) {
    tmp = & r->proto_input_filters;
  } else {
    tmp = (struct ap_filter_t **)((void *)0);
  }
  if (r) {
    tmp___0 = & r->input_filters;
  } else {
    tmp___0 = (struct ap_filter_t **)((void *)0);
  }
  tmp___1 = add_any_filter(name, ctx, r, c, (filter_trie_node const   *)registered_input_filters,
                           tmp___0, tmp, & c->input_filters);
  return (tmp___1);
}
}
ap_filter_t *ap_add_input_filter_handle(ap_filter_rec_t *f , void *ctx , request_rec *r ,
                                        conn_rec *c ) 
{ struct ap_filter_t **tmp ;
  struct ap_filter_t **tmp___0 ;
  ap_filter_t *tmp___1 ;

  {
  if (r) {
    tmp = & r->proto_input_filters;
  } else {
    tmp = (struct ap_filter_t **)((void *)0);
  }
  if (r) {
    tmp___0 = & r->input_filters;
  } else {
    tmp___0 = (struct ap_filter_t **)((void *)0);
  }
  tmp___1 = add_any_filter_handle(f, ctx, r, c, tmp___0, tmp, & c->input_filters);
  return (tmp___1);
}
}
ap_filter_t *ap_add_output_filter(char const   *name , void *ctx , request_rec *r ,
                                  conn_rec *c ) 
{ struct ap_filter_t **tmp ;
  struct ap_filter_t **tmp___0 ;
  ap_filter_t *tmp___1 ;

  {
  if (r) {
    tmp = & r->proto_output_filters;
  } else {
    tmp = (struct ap_filter_t **)((void *)0);
  }
  if (r) {
    tmp___0 = & r->output_filters;
  } else {
    tmp___0 = (struct ap_filter_t **)((void *)0);
  }
  tmp___1 = add_any_filter(name, ctx, r, c, (filter_trie_node const   *)registered_output_filters,
                           tmp___0, tmp, & c->output_filters);
  return (tmp___1);
}
}
ap_filter_t *ap_add_output_filter_handle(ap_filter_rec_t *f , void *ctx , request_rec *r ,
                                         conn_rec *c ) 
{ struct ap_filter_t **tmp ;
  struct ap_filter_t **tmp___0 ;
  ap_filter_t *tmp___1 ;

  {
  if (r) {
    tmp = & r->proto_output_filters;
  } else {
    tmp = (struct ap_filter_t **)((void *)0);
  }
  if (r) {
    tmp___0 = & r->output_filters;
  } else {
    tmp___0 = (struct ap_filter_t **)((void *)0);
  }
  tmp___1 = add_any_filter_handle(f, ctx, r, c, tmp___0, tmp, & c->output_filters);
  return (tmp___1);
}
}
static void remove_any_filter(ap_filter_t *f , ap_filter_t **r_filt , ap_filter_t **p_filt ,
                              ap_filter_t **c_filt ) 
{ ap_filter_t **curr ;
  ap_filter_t **tmp ;
  ap_filter_t *fscan ;

  {
  if (r_filt) {
    tmp = r_filt;
  } else {
    tmp = c_filt;
  }
  curr = tmp;
  fscan = (*curr);
  if (p_filt) {
    if ((unsigned int )(*p_filt) == (unsigned int )f) {
      (*p_filt) = ((*p_filt))->next;
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if ((unsigned int )(*curr) == (unsigned int )f) {
    (*curr) = ((*curr))->next;
    return;
  }
  while ((unsigned int )fscan->next != (unsigned int )f) {
    fscan = fscan->next;
    if (! fscan) {
      return;
    }
  }
  fscan->next = f->next;
  return;
}
}
void ap_remove_input_filter(ap_filter_t *f ) 
{ struct ap_filter_t **tmp ;
  struct ap_filter_t **tmp___0 ;

  {
  if (f->r) {
    tmp = & (f->r)->proto_input_filters;
  } else {
    tmp = (struct ap_filter_t **)((void *)0);
  }
  if (f->r) {
    tmp___0 = & (f->r)->input_filters;
  } else {
    tmp___0 = (struct ap_filter_t **)((void *)0);
  }
  remove_any_filter(f, tmp___0, tmp, & (f->c)->input_filters);
  return;
}
}
void ap_remove_output_filter(ap_filter_t *f ) 
{ struct ap_filter_t **tmp ;
  struct ap_filter_t **tmp___0 ;

  {
  if (f->r) {
    tmp = & (f->r)->proto_output_filters;
  } else {
    tmp = (struct ap_filter_t **)((void *)0);
  }
  if (f->r) {
    tmp___0 = & (f->r)->output_filters;
  } else {
    tmp___0 = (struct ap_filter_t **)((void *)0);
  }
  remove_any_filter(f, tmp___0, tmp, & (f->c)->output_filters);
  return;
}
}
apr_status_t ap_get_brigade(ap_filter_t *next , apr_bucket_brigade *bb , ap_input_mode_t mode ,
                            apr_read_type_e block , apr_off_t readbytes ) 
{ apr_status_t tmp ;

  {
  if (next) {
    tmp = ((*((next->frec)->filter_func.in_func)))(next, bb, mode, block, readbytes);
    return (tmp);
  }
  return (-2);
}
}
apr_status_t ap_pass_brigade(ap_filter_t *next , apr_bucket_brigade *bb ) 
{ apr_bucket *e ;
  apr_status_t tmp ;

  {
  if (next) {
    e = bb->list.prev;
    if (e) {
      if ((unsigned int )e->type == (unsigned int )(& apr_bucket_type_eos)) {
        if (next->r) {
          (next->r)->eos_sent = 1;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
    tmp = ((*((next->frec)->filter_func.out_func)))(next, bb);
    return (tmp);
  }
  return (-1);
}
}
apr_status_t ap_save_brigade(ap_filter_t *f , apr_bucket_brigade **saveto , apr_bucket_brigade **b ,
                             apr_pool_t *p ) 
{ apr_bucket *e ;
  apr_status_t rv ;

  {
  if (! (*saveto)) {
    (*saveto) = apr_brigade_create(p, (f->c)->bucket_alloc);
  }
  e = ((*b))->list.next;
  while ((unsigned int )e != (unsigned int )((struct apr_bucket *)((char *)(& ((*b))->list) -
                                                                   (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                           (char *)((void *)0))))) {
    rv = ((*((e->type)->setaside)))(e, p);
    if (rv != 0) {
      if (rv != 70023) {
        return (rv);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    e = e->link.next;
  }
  while (1) {
    if (! ((unsigned int )((*b))->list.next == (unsigned int )((struct apr_bucket *)((char *)(& ((*b))->list) -
                                                                                     (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                             (char *)((void *)0)))))) {
      while (1) {
        (((*b))->list.prev)->link.next = (struct apr_bucket *)((char *)(& ((*saveto))->list) -
                                                               (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                       (char *)((void *)0)));
        (((*b))->list.next)->link.prev = ((struct apr_bucket *)((char *)(& ((*saveto))->list) -
                                                                (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                        (char *)((void *)0))))->link.prev;
        (((struct apr_bucket *)((char *)(& ((*saveto))->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                        (char *)((void *)0))))->link.prev)->link.next = ((*b))->list.next;
        ((struct apr_bucket *)((char *)(& ((*saveto))->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                       (char *)((void *)0))))->link.prev = ((*b))->list.prev;
        break;
      }
      while (1) {
        ((*b))->list.next = (struct apr_bucket *)((char *)(& ((*b))->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                     (char *)((void *)0)));
        ((*b))->list.prev = (struct apr_bucket *)((char *)(& ((*b))->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                     (char *)((void *)0)));
        break;
      }
    }
    break;
  }
  return (0);
}
}
apr_status_t ap_filter_flush(apr_bucket_brigade *bb , void *ctx ) 
{ ap_filter_t *f ;
  apr_status_t tmp ;

  {
  f = (ap_filter_t *)ctx;
  tmp = ap_pass_brigade(f, bb);
  return (tmp);
}
}
apr_status_t ap_fflush(ap_filter_t *f , apr_bucket_brigade *bb ) 
{ apr_bucket *b ;
  apr_bucket *ap__b ;
  apr_status_t tmp ;

  {
  b = apr_bucket_flush_create((f->c)->bucket_alloc);
  while (1) {
    ap__b = b;
    while (1) {
      ap__b->link.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                              (char *)((void *)0)));
      ap__b->link.prev = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                               (char *)((void *)0))))->link.prev;
      (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                             (char *)((void *)0))))->link.prev)->link.next = ap__b;
      ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                            (char *)((void *)0))))->link.prev = ap__b;
      break;
    }
    break;
  }
  tmp = ap_pass_brigade(f, bb);
  return (tmp);
}
}
apr_status_t ap_fputstrs(ap_filter_t *f , apr_bucket_brigade *bb  , ...) 
{ va_list args ;
  apr_status_t rv ;

  {
  __builtin_stdarg_start(args, bb);
  rv = apr_brigade_vputstrs(bb, & ap_filter_flush, (void *)f, args);
  __builtin_va_end(args);
  return (rv);
}
}
apr_status_t ap_fprintf(ap_filter_t *f , apr_bucket_brigade *bb , char const   *fmt 
                        , ...) 
{ va_list args ;
  apr_status_t rv ;

  {
  __builtin_stdarg_start(args, fmt);
  rv = apr_brigade_vprintf(bb, & ap_filter_flush, (void *)f, fmt, args);
  __builtin_va_end(args);
  return (rv);
}
}
#pragma merger(0,"/tmp/cil-0wTY2QWb.i","-g -pthread")
apr_status_t apr_initialize(void) ;
void apr_terminate2(void) ;
apr_status_t apr_generate_random_bytes(unsigned char *buf , int length ) ;
apr_status_t apr_pool_initialize(void) ;
void apr_pool_terminate(void) ;
void apr_allocator_destroy(apr_allocator_t *allocator ) ;
apr_memnode_t *apr_allocator_alloc(apr_allocator_t *allocator , apr_size_t size ) ;
void apr_allocator_free(apr_allocator_t *allocator , apr_memnode_t *node ) ;
void apr_allocator_set_owner(apr_allocator_t *allocator , apr_pool_t *pool ) ;
apr_pool_t *apr_allocator_owner_get(apr_allocator_t *allocator ) ;
apr_pool_t *apr_allocator_get_owner(apr_allocator_t *allocator ) ;
void apr_allocator_set_max_free(apr_allocator_t *allocator , apr_size_t size ) ;
apr_status_t apr_thread_mutex_create(apr_thread_mutex_t **mutex , unsigned int flags ,
                                     apr_pool_t *pool ) ;
apr_status_t apr_thread_mutex_lock(apr_thread_mutex_t *mutex ) ;
apr_status_t apr_thread_mutex_trylock(apr_thread_mutex_t *mutex ) ;
apr_status_t apr_thread_mutex_unlock(apr_thread_mutex_t *mutex ) ;
apr_status_t apr_thread_mutex_destroy(apr_thread_mutex_t *mutex ) ;
apr_pool_t *apr_thread_mutex_pool_get(apr_thread_mutex_t const   *ob ) ;
void apr_allocator_mutex_set(apr_allocator_t *allocator , apr_thread_mutex_t *mutex ) ;
void apr_allocator_set_mutex(apr_allocator_t *allocator , apr_thread_mutex_t *mutex ) ;
apr_thread_mutex_t *apr_allocator_mutex_get(apr_allocator_t *allocator ) ;
apr_thread_mutex_t *apr_allocator_get_mutex(apr_allocator_t *allocator ) ;
apr_status_t apr_pool_create_ex_debug(apr_pool_t **newpool , apr_pool_t *parent ,
                                      int (*abort_fn)(int retcode ) , apr_allocator_t *allocator ,
                                      char const   *file_line ) ;
apr_allocator_t *apr_pool_allocator_get(apr_pool_t *pool ) ;
void apr_pool_clear_debug(apr_pool_t *pool , char const   *file_line ) ;
void apr_pool_destroy_debug(apr_pool_t *pool , char const   *file_line ) ;
void *apr_palloc_debug(apr_pool_t *pool , apr_size_t size , char const   *file_line ) ;
void *apr_pcalloc_debug(apr_pool_t *pool , apr_size_t size , char const   *file_line ) ;
void apr_pool_abort_set(int (*abort_fn)(int retcode ) , apr_pool_t *pool ) ;
void apr_pool_set_abort(int (*abort_fn)(int retcode ) , apr_pool_t *pool ) ;
apr_abortfunc_t apr_pool_abort_get(apr_pool_t *pool ) ;
apr_abortfunc_t apr_pool_get_abort(apr_pool_t *pool ) ;
apr_pool_t *apr_pool_parent_get(apr_pool_t *pool ) ;
apr_pool_t *apr_pool_get_parent(apr_pool_t *pool ) ;
int apr_pool_is_ancestor(apr_pool_t *a , apr_pool_t *b ) ;
apr_status_t apr_pool_userdata_set(void const   *data , char const   *key , apr_status_t (*cleanup)(void * ) ,
                                   apr_pool_t *pool ) ;
apr_status_t apr_pool_userdata_setn(void const   *data , char const   *key , apr_status_t (*cleanup)(void * ) ,
                                    apr_pool_t *pool ) ;
apr_status_t apr_pool_userdata_get(void **data , char const   *key , apr_pool_t *pool ) ;
void apr_pool_child_cleanup_set(apr_pool_t *p , void const   *data , apr_status_t (*plain_cleanup_fn)(void * ) ,
                                apr_status_t (*child_cleanup_fn)(void * ) ) ;
void apr_pool_cleanup_for_exec(void) ;
void *apr_array_pop(apr_array_header_t *arr ) ;
void apr_array_cat(apr_array_header_t *dst , apr_array_header_t const   *src ) ;
apr_array_header_t *apr_array_copy_hdr(apr_pool_t *p , apr_array_header_t const   *arr ) ;
void apr_table_merge(apr_table_t *t , char const   *key , char const   *val ) ;
int apr_table_vdo(apr_table_do_callback_fn_t *comp , void *rec , apr_table_t const   *t ,
                  va_list vp ) ;
void apr_sort_hooks(void) ;
void apr_show_hook(char const   *szName , char const   * const  *aszPre___1 , char const   * const  *aszSucc___2 ) ;
void apr_optional_hook_add(char const   *szName , void (*pfn)(void) , char const   * const  *aszPre___1 ,
                           char const   * const  *aszSucc___2 , int nOrder ) ;
apr_array_header_t *apr_optional_hook_get(char const   *szName ) ;
apr_status_t apr_time_ansi_put(apr_time_t *result , time_t input ) ;
apr_status_t apr_time_exp_tz(apr_time_exp_t *result , apr_time_t input , apr_int32_t offs ) ;
apr_status_t apr_explode_time(apr_time_exp_t *result , apr_time_t input , apr_int32_t offs ) ;
apr_status_t apr_explode_localtime(apr_time_exp_t *result , apr_time_t input ) ;
apr_status_t apr_time_exp_get(apr_time_t *t , apr_time_exp_t *xt ) ;
apr_status_t apr_time_exp_gmt_get(apr_time_t *t , apr_time_exp_t *xt ) ;
apr_status_t apr_implode_gmt(apr_time_t *t , apr_time_exp_t *xt ) ;
apr_status_t apr_rfc822_date(char *date_str , apr_time_t t ) ;
void apr_time_clock_hires(apr_pool_t *p ) ;
apr_status_t apr_uid_current(apr_uid_t *uid , apr_gid_t *gid , apr_pool_t *p ) ;
apr_status_t apr_current_userid(apr_uid_t *uid , apr_gid_t *gid , apr_pool_t *p ) ;
apr_status_t apr_uid_name_get(char **username , apr_uid_t userid , apr_pool_t *p ) ;
apr_status_t apr_uid_get(apr_uid_t *uid , apr_gid_t *gid , char const   *username ,
                         apr_pool_t *p ) ;
apr_status_t apr_uid_homepath_get(char **dirname , char const   *username , apr_pool_t *p ) ;
apr_status_t apr_gid_name_get(char **groupname , apr_gid_t groupid , apr_pool_t *p ) ;
apr_status_t apr_group_name_get(char **groupname , apr_gid_t groupid , apr_pool_t *p ) ;
apr_status_t apr_get_groupname(char **groupname , apr_gid_t groupid , apr_pool_t *p ) ;
apr_status_t apr_gid_get(apr_gid_t *groupid , char const   *groupname , apr_pool_t *p ) ;
apr_status_t apr_get_groupid(apr_gid_t *groupid , char const   *groupname , apr_pool_t *p ) ;
apr_status_t apr_dir_rewind(apr_dir_t *thedir ) ;
apr_status_t apr_filepath_get(char **defpath , apr_int32_t flags , apr_pool_t *p ) ;
apr_status_t apr_filepath_set(char const   *path , apr_pool_t *p ) ;
apr_status_t apr_filepath_encoding(int *style , apr_pool_t *p ) ;
apr_status_t apr_file_remove(char const   *path , apr_pool_t *pool ) ;
apr_status_t apr_file_rename(char const   *from_path , char const   *to_path , apr_pool_t *p ) ;
apr_status_t apr_file_copy(char const   *from_path , char const   *to_path , apr_fileperms_t perms ,
                           apr_pool_t *pool ) ;
apr_status_t apr_file_append(char const   *from_path , char const   *to_path , apr_fileperms_t perms ,
                             apr_pool_t *pool ) ;
apr_status_t apr_file_open_stdout(apr_file_t **thefile , apr_pool_t *pool ) ;
apr_status_t apr_file_open_stdin(apr_file_t **thefile , apr_pool_t *pool ) ;
apr_status_t apr_file_writev(apr_file_t *thefile , struct iovec  const  *vec , apr_size_t nvec ,
                             apr_size_t *nbytes ) ;
apr_status_t apr_file_putc(char ch , apr_file_t *thefile ) ;
apr_status_t apr_file_dup(apr_file_t **new_file , apr_file_t *old_file , apr_pool_t *p ) ;
apr_status_t apr_file_setaside(apr_file_t **new_file , apr_file_t *old_file , apr_pool_t *p ) ;
apr_status_t apr_file_namedpipe_create(char const   *filename , apr_fileperms_t perm ,
                                       apr_pool_t *pool ) ;
apr_status_t apr_file_pipe_timeout_get(apr_file_t *thepipe , apr_interval_time_t *timeout ) ;
apr_status_t apr_file_lock(apr_file_t *thefile , int type ) ;
apr_status_t apr_file_unlock(apr_file_t *thefile ) ;
apr_status_t apr_file_name_get(char const   **fname , apr_file_t *thefile ) ;
apr_status_t apr_file_data_get(void **data , char const   *key , apr_file_t *file ) ;
apr_status_t apr_file_data_set(apr_file_t *file , void *data , char const   *key ,
                               apr_status_t (*cleanup)(void * ) ) ;
apr_status_t apr_file_perms_set(char const   *fname , apr_fileperms_t perms ) ;
apr_status_t apr_file_attrs_set(char const   *fname , apr_fileattrs_t attributes ,
                                apr_fileattrs_t attr_mask , apr_pool_t *pool ) ;
apr_status_t apr_dir_make(char const   *path , apr_fileperms_t perm , apr_pool_t *pool ) ;
apr_status_t apr_dir_make_recursive(char const   *path , apr_fileperms_t perm , apr_pool_t *pool ) ;
apr_status_t apr_dir_remove(char const   *path , apr_pool_t *pool ) ;
apr_status_t apr_file_trunc(apr_file_t *fp , apr_off_t offset ) ;
apr_int32_t apr_file_flags_get(apr_file_t *f ) ;
apr_pool_t *apr_file_pool_get(apr_file_t const   *ob ) ;
void apr_file_set_inherit(apr_file_t *thefile ) ;
apr_status_t apr_file_inherit_unset(apr_file_t *thefile ) ;
void apr_file_unset_inherit(apr_file_t *thefile ) ;
apr_status_t apr_file_mktemp(apr_file_t **fp , char *template , apr_int32_t flags ,
                             apr_pool_t *p ) ;
apr_status_t apr_socket_create_ex(apr_socket_t **new , int ofamily , int type , int protocol ,
                                  apr_pool_t *cont ) ;
apr_status_t apr_socket_shutdown(apr_socket_t *thesocket , apr_shutdown_how_e how ) ;
apr_status_t apr_socket_bind(apr_socket_t *sock , apr_sockaddr_t *sa ) ;
apr_status_t apr_socket_listen(apr_socket_t *sock , apr_int32_t backlog ) ;
apr_status_t apr_socket_accept(apr_socket_t **new , apr_socket_t *sock , apr_pool_t *connection_context ) ;
apr_status_t apr_accept(apr_socket_t **new , apr_socket_t *sock , apr_pool_t *connection_context ) ;
apr_status_t apr_socket_connect(apr_socket_t *sock , apr_sockaddr_t *sa ) ;
apr_status_t apr_gethostname(char *buf , int len , apr_pool_t *cont ) ;
apr_status_t apr_socket_data_get(void **data , char const   *key , apr_socket_t *sock ) ;
apr_status_t apr_socket_data_set(apr_socket_t *sock , void *data , char const   *key ,
                                 apr_status_t (*cleanup)(void * ) ) ;
apr_status_t apr_socket_send(apr_socket_t *sock , char const   *buf , apr_size_t *len ) ;
apr_status_t apr_socket_sendv(apr_socket_t *sock , struct iovec  const  *vec , apr_int32_t nvec ,
                              apr_size_t *len ) ;
apr_status_t apr_sendv(apr_socket_t *sock , struct iovec  const  *vec , apr_int32_t nvec ,
                       apr_size_t *len ) ;
apr_status_t apr_socket_sendto(apr_socket_t *sock , apr_sockaddr_t *where , apr_int32_t flags ,
                               char const   *buf , apr_size_t *len ) ;
apr_status_t apr_sendto(apr_socket_t *sock , apr_sockaddr_t *where , apr_int32_t flags ,
                        char const   *buf , apr_size_t *len ) ;
apr_status_t apr_socket_recvfrom(apr_sockaddr_t *from , apr_socket_t *sock , apr_int32_t flags ,
                                 char *buf , apr_size_t *len ) ;
apr_status_t apr_recvfrom(apr_sockaddr_t *from , apr_socket_t *sock , apr_int32_t flags ,
                          char *buf , apr_size_t *len ) ;
apr_status_t apr_socket_sendfile(apr_socket_t *sock , apr_file_t *file , apr_hdtr_t *hdtr ,
                                 apr_off_t *offset , apr_size_t *len , apr_int32_t flags ) ;
apr_status_t apr_sendfile(apr_socket_t *sock , apr_file_t *file , apr_hdtr_t *hdtr ,
                          apr_off_t *offset , apr_size_t *len , apr_int32_t flags ) ;
apr_status_t apr_socket_recv(apr_socket_t *sock , char *buf , apr_size_t *len ) ;
apr_status_t apr_setsocketopt(apr_socket_t *sock , apr_int32_t opt , apr_int32_t on ) ;
apr_status_t apr_socket_opt_get(apr_socket_t *sock , apr_int32_t opt , apr_int32_t *on ) ;
apr_status_t apr_getsocketopt(apr_socket_t *sock , apr_int32_t opt , apr_int32_t *on ) ;
apr_status_t apr_socket_timeout_get(apr_socket_t *sock , apr_interval_time_t *t ) ;
apr_status_t apr_socket_addr_get(apr_sockaddr_t **sa , apr_interface_e which , apr_socket_t *sock ) ;
apr_status_t apr_sockaddr_port_set(apr_sockaddr_t *sockaddr , apr_port_t port ) ;
apr_status_t apr_sockaddr_ip_set(apr_sockaddr_t *sockaddr , char const   *addr ) ;
apr_status_t apr_socket_from_file(apr_socket_t **newsock , apr_file_t *file ) ;
apr_status_t apr_getservbyname(apr_sockaddr_t *sockaddr , char const   *servname ) ;
apr_status_t apr_socket_protocol_get(apr_socket_t *sock , int *protocol ) ;
apr_status_t apr_socket_inherit_set(apr_socket_t *thesocket ) ;
void apr_socket_set_inherit(apr_socket_t *thesocket ) ;
apr_status_t apr_socket_inherit_unset(apr_socket_t *thesocket ) ;
void apr_socket_unset_inherit(apr_socket_t *thesocket ) ;
apr_status_t apr_mmap_create(apr_mmap_t **new , apr_file_t *file , apr_off_t offset ,
                             apr_size_t size , apr_int32_t flag , apr_pool_t *cont ) ;
apr_status_t apr_mmap_dup(apr_mmap_t **new_mmap , apr_mmap_t *old_mmap , apr_pool_t *p ,
                          int transfer_ownership ) ;
apr_status_t apr_mmap_delete(apr_mmap_t *mm ) ;
apr_status_t apr_mmap_offset(void **addr , apr_mmap_t *mmap___0 , apr_off_t offset ) ;
apr_status_t apr_brigade_pflatten(apr_bucket_brigade *bb , char **c , apr_size_t *len ,
                                  apr_pool_t *pool ) ;
apr_status_t apr_brigade_split_line(apr_bucket_brigade *bbOut , apr_bucket_brigade *bbIn ,
                                    apr_read_type_e block , apr_off_t maxbytes ) ;
apr_status_t apr_brigade_to_iovec(apr_bucket_brigade *b , struct iovec *vec , int *nvec ) ;
apr_status_t apr_brigade_putc(apr_bucket_brigade *b , apr_status_t (*flush)(apr_bucket_brigade *bb ,
                                                                            void *ctx ) ,
                              void *ctx , char c ) ;
apr_status_t apr_brigade_printf(apr_bucket_brigade *b , apr_status_t (*flush)(apr_bucket_brigade *bb ,
                                                                              void *ctx ) ,
                                void *ctx , char const   *fmt  , ...) ;
void apr_bucket_alloc_destroy(apr_bucket_alloc_t *list ) ;
void *apr_bucket_alloc(apr_size_t size , apr_bucket_alloc_t *list ) ;
void apr_bucket_free(void *mem ) ;
apr_status_t apr_bucket_setaside_noop(apr_bucket *data , apr_pool_t *pool ) ;
apr_status_t apr_bucket_setaside_notimpl(apr_bucket *data , apr_pool_t *pool ) ;
apr_status_t apr_bucket_split_notimpl(apr_bucket *data , apr_size_t point ) ;
apr_status_t apr_bucket_copy_notimpl(apr_bucket *e , apr_bucket **c ) ;
void apr_bucket_destroy_noop(void *data ) ;
apr_status_t apr_bucket_simple_split(apr_bucket *a , apr_size_t point ) ;
apr_status_t apr_bucket_simple_copy(apr_bucket *a , apr_bucket **b ) ;
apr_bucket *apr_bucket_shared_make(apr_bucket *b , void *data , apr_off_t start ,
                                   apr_size_t length ) ;
int apr_bucket_shared_destroy(void *data ) ;
apr_status_t apr_bucket_shared_split(apr_bucket *a , apr_size_t point ) ;
apr_status_t apr_bucket_shared_copy(apr_bucket *a , apr_bucket **b ) ;
apr_bucket *apr_bucket_eos_make(apr_bucket *b ) ;
apr_bucket *apr_bucket_flush_make(apr_bucket *b ) ;
apr_bucket *apr_bucket_immortal_make(apr_bucket *b , char const   *buf , apr_size_t length ) ;
apr_bucket *apr_bucket_transient_make(apr_bucket *b , char const   *buf , apr_size_t length ) ;
apr_bucket *apr_bucket_heap_make(apr_bucket *b , char const   *buf , apr_size_t length ,
                                 void (*free_func)(void *data ) ) ;
apr_bucket *apr_bucket_pool_make(apr_bucket *b , char const   *buf , apr_size_t length ,
                                 apr_pool_t *pool ) ;
apr_bucket *apr_bucket_mmap_create(apr_mmap_t *mm , apr_off_t start , apr_size_t length ,
                                   apr_bucket_alloc_t *list ) ;
apr_bucket *apr_bucket_mmap_make(apr_bucket *b , apr_mmap_t *mm , apr_off_t start ,
                                 apr_size_t length ) ;
apr_bucket *apr_bucket_socket_create(apr_socket_t *p , apr_bucket_alloc_t *list ) ;
apr_bucket *apr_bucket_socket_make(apr_bucket *b , apr_socket_t *p ) ;
apr_bucket *apr_bucket_pipe_make(apr_bucket *b , apr_file_t *p ) ;
apr_bucket *apr_bucket_file_make(apr_bucket *b , apr_file_t *fd , apr_off_t offset ,
                                 apr_size_t len , apr_pool_t *p ) ;
apr_status_t apr_bucket_file_enable_mmap(apr_bucket *e , int enabled ) ;
void ap_add_version_component(apr_pool_t *pconf___0 , char const   *component ) ;
apr_port_t apr_uri_port_of_scheme(char const   *scheme_str ) ;
apr_port_t apr_uri_default_port_for_scheme(char const   *scheme_str ) ;
int apr_uri_parse_hostinfo(apr_pool_t *p , char const   *hostinfo , apr_uri_t *uptr ) ;
apr_status_t apr_threadattr_create(apr_threadattr_t **new , apr_pool_t *pool ) ;
apr_status_t apr_threadattr_detach_set(apr_threadattr_t *attr , apr_int32_t on ) ;
apr_status_t apr_threadattr_detach_get(apr_threadattr_t *attr ) ;
apr_status_t apr_thread_create(apr_thread_t **new , apr_threadattr_t *attr , void *(*func)(apr_thread_t * ,
                                                                                           void * ) ,
                               void *data , apr_pool_t *pool ) ;
apr_status_t apr_thread_exit(apr_thread_t *thd , apr_status_t retval ) ;
apr_status_t apr_thread_join(apr_status_t *retval , apr_thread_t *thd ) ;
void apr_thread_yield(void) ;
apr_status_t apr_thread_once_init(apr_thread_once_t **control , apr_pool_t *p ) ;
apr_status_t apr_thread_once(apr_thread_once_t *control , void (*func)(void) ) ;
apr_status_t apr_thread_detach(apr_thread_t *thd ) ;
apr_status_t apr_thread_data_get(void **data , char const   *key , apr_thread_t *thread ) ;
apr_status_t apr_thread_data_set(void *data , char const   *key , apr_status_t (*cleanup)(void * ) ,
                                 apr_thread_t *thread ) ;
apr_status_t apr_threadkey_private_create(apr_threadkey_t **key , void (*dest)(void * ) ,
                                          apr_pool_t *pool ) ;
apr_status_t apr_threadkey_private_get(void **new , apr_threadkey_t *key ) ;
apr_status_t apr_threadkey_private_set(void *priv , apr_threadkey_t *key ) ;
apr_status_t apr_threadkey_private_delete(apr_threadkey_t *key ) ;
apr_status_t apr_threadkey_data_get(void **data , char const   *key , apr_threadkey_t *threadkey ) ;
apr_status_t apr_threadkey_data_set(void *data , char const   *key , apr_status_t (*cleanup)(void * ) ,
                                    apr_threadkey_t *threadkey ) ;
apr_status_t apr_procattr_child_out_set(struct apr_procattr_t *attr , apr_file_t *child_out ,
                                        apr_file_t *parent_out ) ;
apr_status_t apr_procattr_child_err_set(struct apr_procattr_t *attr , apr_file_t *child_err ,
                                        apr_file_t *parent_err ) ;
apr_status_t apr_proc_fork(apr_proc_t *proc , apr_pool_t *pool ) ;
apr_status_t apr_setup_signal_thread(void) ;
apr_status_t apr_signal_thread(int (*signal_handler)(int signum ) ) ;
apr_pool_t *apr_thread_pool_get(apr_thread_t const   *ob ) ;
apr_status_t ap_register_provider(apr_pool_t *pool , char const   *provider_group ,
                                  char const   *provider_name , char const   *provider_version ,
                                  void const   *provider ) ;
void *ap_lookup_provider(char const   *provider_group , char const   *provider_name ,
                         char const   *provider_version ) ;
unsigned int apr_hash_count(apr_hash_t *ht ) ;
apr_hash_t *apr_hash_overlay(apr_pool_t *p , apr_hash_t const   *overlay , apr_hash_t const   *base ) ;
apr_pool_t *apr_hash_pool_get(apr_hash_t const   *ob ) ;
void apr_register_optional_fn(char const   *szName , apr_opt_fn_t *pfn ) ;
apr_opt_fn_t *apr_retrieve_optional_fn(char const   *szName ) ;
int ap_allow_overrides(request_rec *r ) ;
void ap_custom_response(request_rec *r , int status , char const   *string ) ;
int ap_core_translate(request_rec *r ) ;
char const   *ap_auth_type(request_rec *r ) ;
char const   *ap_auth_name(request_rec *r ) ;
apr_size_t ap_register_request_note(void) ;
void **ap_get_request_note(request_rec *r , apr_size_t note_num ) ;
void ap_add_per_dir_conf(server_rec *s , void *dir_config ) ;
void ap_add_per_url_conf(server_rec *s , void *url_config ) ;
void ap_add_file_conf(core_dir_config *conf , void *url_config ) ;
char const   *ap_limit_section(cmd_parms *cmd , void *dummy , char const   *arg ) ;
void ap_hook_get_mgmt_items(ap_HOOK_get_mgmt_items_t *pf , char const   * const  *aszPre___1 ,
                            char const   * const  *aszSucc___2 , int nOrder ) ;
int ap_run_get_mgmt_items(apr_pool_t *p , char const   *val , apr_hash_t *ht ) ;
apr_array_header_t *ap_hook_get_get_mgmt_items(void) ;
apr_status_t apr_proc_mutex_trylock(apr_proc_mutex_t *mutex ) ;
apr_status_t apr_proc_mutex_destroy(apr_proc_mutex_t *mutex ) ;
apr_status_t apr_proc_mutex_cleanup(void *mutex ) ;
apr_pool_t *apr_proc_mutex_pool_get(apr_proc_mutex_t const   *ob ) ;
apr_status_t apr_global_mutex_create(apr_global_mutex_t **mutex , char const   *fname ,
                                     apr_lockmech_e mech , apr_pool_t *pool ) ;
apr_status_t apr_global_mutex_child_init(apr_global_mutex_t **mutex , char const   *fname ,
                                         apr_pool_t *pool ) ;
apr_status_t apr_global_mutex_lock(apr_global_mutex_t *mutex ) ;
apr_status_t apr_global_mutex_trylock(apr_global_mutex_t *mutex ) ;
apr_status_t apr_global_mutex_unlock(apr_global_mutex_t *mutex ) ;
apr_status_t apr_global_mutex_destroy(apr_global_mutex_t *mutex ) ;
apr_pool_t *apr_global_mutex_pool_get(apr_global_mutex_t const   *ob ) ;
apr_status_t apr_dso_unload(apr_dso_handle_t *handle ) ;
apr_status_t apr_shm_create(apr_shm_t **m , apr_size_t reqsize , char const   *filename ,
                            apr_pool_t *pool ) ;
apr_status_t apr_shm_destroy(apr_shm_t *m ) ;
apr_status_t apr_shm_attach(apr_shm_t **m , char const   *filename , apr_pool_t *pool ) ;
apr_status_t apr_shm_detach(apr_shm_t *m ) ;
void *apr_shm_baseaddr_get(apr_shm_t const   *m ) ;
apr_size_t apr_shm_size_get(apr_shm_t const   *m ) ;
apr_pool_t *apr_shm_pool_get(apr_shm_t const   *ob ) ;
apr_status_t apr_os_global_mutex_get(apr_os_global_mutex_t *ospmutex , apr_global_mutex_t *pmutex ) ;
apr_status_t apr_os_file_get(apr_os_file_t *thefile , apr_file_t *file ) ;
apr_status_t apr_os_dir_get(apr_os_dir_t **thedir , apr_dir_t *dir ) ;
apr_status_t apr_os_sock_get(apr_os_sock_t *thesock , apr_socket_t *sock ) ;
apr_status_t apr_os_proc_mutex_get(apr_os_proc_mutex_t *ospmutex , apr_proc_mutex_t *pmutex ) ;
apr_status_t apr_os_exp_time_get(apr_os_exp_time_t **ostime , apr_time_exp_t *aprtime ) ;
apr_status_t apr_os_imp_time_get(apr_os_imp_time_t **ostime , apr_time_t *aprtime ) ;
apr_status_t apr_os_shm_get(apr_os_shm_t *osshm , apr_shm_t *shm ) ;
apr_status_t apr_os_thread_get(apr_os_thread_t **thethd , apr_thread_t *thd ) ;
apr_status_t apr_os_threadkey_get(apr_os_threadkey_t *thekey , apr_threadkey_t *key ) ;
apr_status_t apr_os_thread_put(apr_thread_t **thd , apr_os_thread_t *thethd , apr_pool_t *pool ) ;
apr_status_t apr_os_threadkey_put(apr_threadkey_t **key , apr_os_threadkey_t *thekey ,
                                  apr_pool_t *pool ) ;
apr_os_thread_t apr_os_thread_current(void) ;
int apr_os_thread_equal(apr_os_thread_t tid1 , apr_os_thread_t tid2 ) ;
apr_status_t apr_os_file_put(apr_file_t **file , apr_os_file_t *thefile , apr_int32_t flags ,
                             apr_pool_t *pool ) ;
apr_status_t apr_os_pipe_put(apr_file_t **file , apr_os_file_t *thefile , apr_pool_t *pool ) ;
apr_status_t apr_os_dir_put(apr_dir_t **dir , apr_os_dir_t *thedir , apr_pool_t *pool ) ;
apr_status_t apr_os_sock_put(apr_socket_t **sock , apr_os_sock_t *thesock , apr_pool_t *cont ) ;
apr_status_t apr_os_sock_make(apr_socket_t **apr_sock , apr_os_sock_info_t *os_sock_info ,
                              apr_pool_t *cont ) ;
apr_status_t apr_os_proc_mutex_put(apr_proc_mutex_t **pmutex , apr_os_proc_mutex_t *ospmutex ,
                                   apr_pool_t *pool ) ;
apr_status_t apr_os_imp_time_put(apr_time_t *aprtime , apr_os_imp_time_t **ostime ,
                                 apr_pool_t *cont ) ;
apr_status_t apr_os_exp_time_put(apr_time_exp_t *aprtime , apr_os_exp_time_t **ostime ,
                                 apr_pool_t *cont ) ;
apr_status_t apr_os_shm_put(apr_shm_t **m , apr_os_shm_t *osshm , apr_pool_t *pool ) ;
apr_status_t apr_os_dso_handle_put(apr_dso_handle_t **aprdso , apr_os_dso_handle_t osdso ,
                                   apr_pool_t *pool ) ;
apr_status_t apr_os_dso_handle_get(apr_os_dso_handle_t *osdso , apr_dso_handle_t *aprdso ) ;
char const   *apr_os_default_encoding(apr_pool_t *pool ) ;
char const   *apr_os_locale_encoding(apr_pool_t *pool ) ;
void ap_get_mime_headers_core(request_rec *r , apr_bucket_brigade *bb ) ;
apr_time_t ap_rationalize_mtime(request_rec *r , apr_time_t mtime ) ;
void ap_setup_make_content_type(apr_pool_t *pool ) ;
apr_status_t ap_send_fd(apr_file_t *fd , request_rec *r , apr_off_t offset , apr_size_t len ,
                        apr_size_t *nbytes ) ;
size_t ap_send_mmap(apr_mmap_t *mm , request_rec *r , size_t offset , size_t length ) ;
int ap_rwrite(void const   *buf , int nbyte , request_rec *r ) ;
int ap_vrprintf(request_rec *r , char const   *fmt , va_list va ) ;
int ap_rflush(request_rec *r ) ;
void ap_note_auth_failure(request_rec *r ) ;
void ap_note_digest_auth_failure(request_rec *r ) ;
int ap_getline(char *s , int n , request_rec *r , int fold ) ;
apr_status_t ap_rgetline_core(char **s , apr_size_t n , apr_size_t *read___0 , request_rec *r ,
                              int fold , apr_bucket_brigade *bb ) ;
apr_array_header_t *ap_hook_get_post_read_request(void) ;
apr_array_header_t *ap_hook_get_log_transaction(void) ;
char const   *ap_run_http_method(request_rec const   *r ) ;
apr_array_header_t *ap_hook_get_http_method(void) ;
apr_array_header_t *ap_hook_get_default_port(void) ;
apr_bucket *ap_bucket_error_make(apr_bucket *b , int error , char const   *buf , apr_pool_t *p ) ;
apr_status_t ap_content_length_filter(ap_filter_t *f , apr_bucket_brigade *b ) ;
apr_status_t ap_old_write_filter(ap_filter_t *f , apr_bucket_brigade *bb ) ;
request_rec *ap_sub_req_method_uri(char const   *method , char const   *new_file ,
                                   request_rec const   *r , ap_filter_t *next_filter ) ;
apr_status_t ap_sub_req_output_filter(ap_filter_t *f , apr_bucket_brigade *bb ) ;
int ap_is_initial_req(request_rec *r ) ;
apr_array_header_t *ap_hook_get_create_request(void) ;
int ap_run_translate_name(request_rec *r ) ;
apr_array_header_t *ap_hook_get_translate_name(void) ;
int ap_run_map_to_storage(request_rec *r ) ;
apr_array_header_t *ap_hook_get_map_to_storage(void) ;
int ap_run_check_user_id(request_rec *r ) ;
apr_array_header_t *ap_hook_get_check_user_id(void) ;
int ap_run_fixups(request_rec *r ) ;
apr_array_header_t *ap_hook_get_fixups(void) ;
int ap_run_type_checker(request_rec *r ) ;
apr_array_header_t *ap_hook_get_type_checker(void) ;
int ap_run_access_checker(request_rec *r ) ;
apr_array_header_t *ap_hook_get_access_checker(void) ;
int ap_run_auth_checker(request_rec *r ) ;
apr_array_header_t *ap_hook_get_auth_checker(void) ;
void ap_hook_insert_filter(ap_HOOK_insert_filter_t *pf , char const   * const  *aszPre___1 ,
                           char const   * const  *aszSucc___2 , int nOrder ) ;
apr_array_header_t *ap_hook_get_insert_filter(void) ;
int ap_location_walk(request_rec *r ) ;
int ap_directory_walk(request_rec *r ) ;
int ap_file_walk(request_rec *r ) ;
int ap_calc_scoreboard_size(void) ;
global_score *ap_get_scoreboard_global(void) ;
void ap_hook_pre_mpm(ap_HOOK_pre_mpm_t *pf , char const   * const  *aszPre___1 , char const   * const  *aszSucc___2 ,
                     int nOrder ) ;
apr_array_header_t *ap_hook_get_pre_mpm(void) ;
ap_unix_identity_t *ap_run_get_suexec_identity(request_rec const   *r ) ;
apr_array_header_t *ap_hook_get_get_suexec_identity(void) ;
void unixd_set_rlimit(cmd_parms *cmd , struct rlimit **plimit , char const   *arg ,
                      char const   *arg2 , int type ) ;
apr_status_t unixd_set_global_mutex_perms(apr_global_mutex_t *gmutex ) ;
apr_status_t apr_xlate_open(apr_xlate_t **convset , char const   *topage , char const   *frompage ,
                            apr_pool_t *pool ) ;
apr_status_t apr_xlate_sb_get(apr_xlate_t *convset , int *onoff ) ;
apr_status_t apr_xlate_get_sb(apr_xlate_t *convset , int *onoff ) ;
apr_status_t apr_xlate_conv_buffer(apr_xlate_t *convset , char const   *inbuf , apr_size_t *inbytes_left ,
                                   char *outbuf , apr_size_t *outbytes_left ) ;
apr_int32_t apr_xlate_conv_byte(apr_xlate_t *convset , unsigned char inchar ) ;
apr_status_t apr_xlate_close(apr_xlate_t *convset ) ;
apr_status_t apr_md5_set_xlate(apr_md5_ctx_t *context , apr_xlate_t *xlate ) ;
apr_status_t apr_md5(unsigned char *digest , unsigned char const   *input , apr_size_t inputLen ) ;
apr_status_t apr_md5_encode(char const   *pw , char const   *salt , char *result ,
                            apr_size_t nbytes ) ;
void apr_text_append(apr_pool_t *p , apr_text_header *hdr , char const   *text ) ;
apr_status_t apr_xml_parse_file(apr_pool_t *p , apr_xml_parser **parser , apr_xml_doc **ppdoc ,
                                apr_file_t *xmlfd , apr_size_t buffer_length ) ;
void apr_xml_to_text(apr_pool_t *p , apr_xml_elem const   *elem , int style , apr_array_header_t *namespaces ,
                     int *ns_map , char const   **pbuf , apr_size_t *psize ) ;
char const   *apr_xml_empty_elem(apr_pool_t *p , apr_xml_elem const   *elem ) ;
char const   *apr_xml_quote_string(apr_pool_t *p , char const   *s , int quotes ) ;
void apr_xml_quote_elem(apr_pool_t *p , apr_xml_elem *elem ) ;
int apr_xml_insert_uri(apr_array_header_t *uri_array , char const   *uri ) ;
int apr_is_fnmatch(char const   *pattern ) ;
apr_status_t apr_getopt_long(apr_getopt_t *os , apr_getopt_option_t const   *opts ,
                             int *optch , char const   **optarg ) ;
char const   *apr_filepath_name_get(char const   *pathname ) ;
int apr_vformatter(int (*flush_func)(apr_vformatter_buff_t *b ) , apr_vformatter_buff_t *vbuff ,
                   char const   *fmt , va_list ap ) ;
apr_status_t apr_password_get(char const   *prompt , char *pwbuf , apr_size_t *bufsiz ) ;
apr_status_t apr_poll_setup(apr_pollfd_t **new , apr_int32_t num , apr_pool_t *cont ) ;
apr_status_t apr_poll_socket_add(apr_pollfd_t *aprset , apr_socket_t *sock , apr_int16_t event ) ;
apr_status_t apr_poll_socket_mask(apr_pollfd_t *aprset , apr_socket_t *sock , apr_int16_t events ) ;
apr_status_t apr_poll_socket_remove(apr_pollfd_t *aprset , apr_socket_t *sock ) ;
apr_status_t apr_poll_socket_clear(apr_pollfd_t *aprset , apr_int16_t events ) ;
apr_status_t apr_poll_revents_get(apr_int16_t *event , apr_socket_t *sock , apr_pollfd_t *aprset ) ;
apr_status_t apr_pollset_create(apr_pollset_t **pollset , apr_uint32_t size , apr_pool_t *p ,
                                apr_uint32_t flags ) ;
apr_status_t apr_pollset_destroy(apr_pollset_t *pollset ) ;
apr_status_t apr_pollset_add(apr_pollset_t *pollset , apr_pollfd_t const   *descriptor ) ;
apr_status_t apr_pollset_remove(apr_pollset_t *pollset , apr_pollfd_t const   *descriptor ) ;
apr_status_t apr_pollset_poll(apr_pollset_t *pollset , apr_interval_time_t timeout ,
                              apr_int32_t *num , apr_pollfd_t const   **descriptors ) ;
char const   *apr_signal_get_description(int signum ) ;
char *apr_pstrcatv(apr_pool_t *a , struct iovec  const  *vec , apr_size_t nvec , apr_size_t *nbytes ) ;
char *apr_collapse_spaces(char *dest , char const   *src ) ;
char *apr_strtok(char *str , char const   *sep , char **last ) ;
char *apr_ltoa(apr_pool_t *p , long n ) ;
apr_int64_t apr_strtoi64(char const   *nptr , char **endptr , int base ) ;
apr_status_t apr_thread_cond_create(apr_thread_cond_t **cond , apr_pool_t *pool ) ;
apr_status_t apr_thread_cond_wait(apr_thread_cond_t *cond , apr_thread_mutex_t *mutex ) ;
apr_status_t apr_thread_cond_timedwait(apr_thread_cond_t *cond , apr_thread_mutex_t *mutex ,
                                       apr_interval_time_t timeout ) ;
apr_status_t apr_thread_cond_signal(apr_thread_cond_t *cond ) ;
apr_status_t apr_thread_cond_broadcast(apr_thread_cond_t *cond ) ;
apr_status_t apr_thread_cond_destroy(apr_thread_cond_t *cond ) ;
apr_pool_t *apr_thread_cond_pool_get(apr_thread_cond_t const   *ob ) ;
apr_status_t apr_thread_rwlock_create(apr_thread_rwlock_t **rwlock , apr_pool_t *pool ) ;
apr_status_t apr_thread_rwlock_rdlock(apr_thread_rwlock_t *rwlock ) ;
apr_status_t apr_thread_rwlock_tryrdlock(apr_thread_rwlock_t *rwlock ) ;
apr_status_t apr_thread_rwlock_wrlock(apr_thread_rwlock_t *rwlock ) ;
apr_status_t apr_thread_rwlock_trywrlock(apr_thread_rwlock_t *rwlock ) ;
apr_status_t apr_thread_rwlock_unlock(apr_thread_rwlock_t *rwlock ) ;
apr_status_t apr_thread_rwlock_destroy(apr_thread_rwlock_t *rwlock ) ;
apr_pool_t *apr_thread_rwlock_pool_get(apr_thread_rwlock_t const   *ob ) ;
void apr_version(apr_version_t *pvsn ) ;
char const   *apr_version_string(void) ;
int apr_base64_encode_binary(char *encoded , unsigned char const   *string , int len ) ;
int apr_base64_decode_binary(unsigned char *bufplain , char const   *bufcoded ) ;
int apr_date_checkmask(char const   *data , char const   *mask ) ;
apr_time_t apr_date_parse_rfc(char const   *date ) ;
apr_status_t apr_dbm_open_ex(apr_dbm_t **pdb , char const   *type , char const   *pathname ,
                             apr_int32_t mode , apr_fileperms_t perm , apr_pool_t *pool ) ;
apr_status_t apr_dbm_open(apr_dbm_t **pdb , char const   *pathname , apr_int32_t mode ,
                          apr_fileperms_t perm , apr_pool_t *pool ) ;
void apr_dbm_close(apr_dbm_t *dbm ) ;
apr_status_t apr_dbm_fetch(apr_dbm_t *dbm , apr_datum_t key , apr_datum_t *pvalue ) ;
apr_status_t apr_dbm_store(apr_dbm_t *dbm , apr_datum_t key , apr_datum_t value ) ;
apr_status_t apr_dbm_delete(apr_dbm_t *dbm , apr_datum_t key ) ;
int apr_dbm_exists(apr_dbm_t *dbm , apr_datum_t key ) ;
apr_status_t apr_dbm_firstkey(apr_dbm_t *dbm , apr_datum_t *pkey ) ;
apr_status_t apr_dbm_nextkey(apr_dbm_t *dbm , apr_datum_t *pkey ) ;
void apr_dbm_freedatum(apr_dbm_t *dbm , apr_datum_t data ) ;
char *apr_dbm_geterror(apr_dbm_t *dbm , int *errcode , char *errbuf , apr_size_t errbufsize ) ;
apr_status_t apr_dbm_get_usednames_ex(apr_pool_t *p , char const   *type , char const   *pathname ,
                                      char const   **used1 , char const   **used2 ) ;
void apr_dbm_get_usednames(apr_pool_t *p , char const   *pathname , char const   **used1 ,
                           char const   **used2 ) ;
apr_status_t apr_md4_init(apr_md4_ctx_t *context ) ;
apr_status_t apr_md4_set_xlate(apr_md4_ctx_t *context , apr_xlate_t *xlate ) ;
apr_status_t apr_md4_update(apr_md4_ctx_t *context , unsigned char const   *input ,
                            apr_size_t inputLen ) ;
apr_status_t apr_md4_final(unsigned char *digest , apr_md4_ctx_t *context ) ;
apr_status_t apr_md4(unsigned char *digest , unsigned char const   *input , apr_size_t inputLen ) ;
apr_status_t apr_queue_create(apr_queue_t **q , unsigned int queue_capacity , apr_pool_t *a ) ;
apr_status_t apr_queue_push(apr_queue_t *queue , void *data ) ;
apr_status_t apr_queue_pop(apr_queue_t *queue , void **data ) ;
apr_status_t apr_queue_trypush(apr_queue_t *queue , void *data ) ;
apr_status_t apr_queue_trypop(apr_queue_t *queue , void **data ) ;
unsigned int apr_queue_size(apr_queue_t *queue ) ;
apr_status_t apr_queue_interrupt_all(apr_queue_t *queue ) ;
apr_status_t apr_queue_term(apr_queue_t *queue ) ;
apr_status_t apr_reslist_create(apr_reslist_t **reslist , int min , int smax , int hmax ,
                                apr_interval_time_t ttl , apr_status_t (*con)(void **resource ,
                                                                              void *params ,
                                                                              apr_pool_t *pool ) ,
                                apr_status_t (*de)(void *resource , void *params ,
                                                   apr_pool_t *pool ) , void *params ,
                                apr_pool_t *pool ) ;
apr_status_t apr_reslist_destroy(apr_reslist_t *reslist ) ;
apr_status_t apr_reslist_acquire(apr_reslist_t *reslist , void **resource ) ;
apr_status_t apr_reslist_release(apr_reslist_t *reslist , void *resource ) ;
apr_status_t apr_rmm_init(apr_rmm_t **rmm , apr_anylock_t *lock , void *base , apr_size_t size ,
                          apr_pool_t *p ) ;
apr_status_t apr_rmm_destroy(apr_rmm_t *rmm ) ;
apr_status_t apr_rmm_attach(apr_rmm_t **rmm , apr_anylock_t *lock , void *base , apr_pool_t *p ) ;
apr_status_t apr_rmm_detach(apr_rmm_t *rmm ) ;
apr_rmm_off_t apr_rmm_malloc(apr_rmm_t *rmm , apr_size_t reqsize ) ;
apr_rmm_off_t apr_rmm_realloc(apr_rmm_t *rmm , void *entity , apr_size_t reqsize ) ;
apr_rmm_off_t apr_rmm_calloc(apr_rmm_t *rmm , apr_size_t reqsize ) ;
apr_status_t apr_rmm_free(apr_rmm_t *rmm , apr_rmm_off_t this ) ;
void *apr_rmm_addr_get(apr_rmm_t *rmm , apr_rmm_off_t entity ) ;
apr_rmm_off_t apr_rmm_offset_get(apr_rmm_t *rmm , void *entity ) ;
apr_size_t apr_rmm_overhead_get(int n ) ;
apr_status_t apr_sdbm_open(apr_sdbm_t **db , char const   *file , apr_int32_t flags ,
                           apr_fileperms_t perms , apr_pool_t *p ) ;
apr_status_t apr_sdbm_close(apr_sdbm_t *db ) ;
apr_status_t apr_sdbm_lock(apr_sdbm_t *db , int type ) ;
apr_status_t apr_sdbm_unlock(apr_sdbm_t *db ) ;
apr_status_t apr_sdbm_fetch(apr_sdbm_t *db , apr_sdbm_datum_t *val , apr_sdbm_datum_t key ) ;
apr_status_t apr_sdbm_store(apr_sdbm_t *db , apr_sdbm_datum_t key , apr_sdbm_datum_t val ,
                            int flags ) ;
apr_status_t apr_sdbm_delete(apr_sdbm_t *db , apr_sdbm_datum_t key ) ;
apr_status_t apr_sdbm_firstkey(apr_sdbm_t *db , apr_sdbm_datum_t *key ) ;
apr_status_t apr_sdbm_nextkey(apr_sdbm_t *db , apr_sdbm_datum_t *key ) ;
int apr_sdbm_rdonly(apr_sdbm_t *db ) ;
void apr_sha1_base64(char const   *clear , int len , char *out ) ;
void apr_sha1_init(apr_sha1_ctx_t *sha_info ) ;
void apr_sha1_update(apr_sha1_ctx_t *sha_info , char const   *buf , unsigned int count ) ;
void apr_sha1_update_binary(apr_sha1_ctx_t *sha_info , unsigned char const   *buffer ,
                            unsigned int count ) ;
void apr_sha1_final(unsigned char *digest , apr_sha1_ctx_t *sha_info ) ;
void apr_uuid_get(apr_uuid_t *uuid ) ;
void apr_uuid_format(char *buffer , apr_uuid_t const   *uuid ) ;
apr_status_t apr_uuid_parse(apr_uuid_t *uuid , char const   *uuid_str ) ;
void apu_version(apr_version_t *pvsn ) ;
char const   *apu_version_string(void) ;
void const   *ap_ugly_hack  =    (void const   *)((void *)0);
void const   *ap_hack_ap_mpm_run  =    (void const   *)(& ap_mpm_run);
void const   *ap_hack_ap_graceful_stop_signalled  =    (void const   *)(& ap_graceful_stop_signalled);
void const   *ap_hack_ap_os_create_privileged_process  =    (void const   *)(& ap_os_create_privileged_process);
void const   *ap_hack_ap_mpm_query  =    (void const   *)(& ap_mpm_query);
void const   *ap_hack_ap_register_provider  =    (void const   *)(& ap_register_provider);
void const   *ap_hack_ap_lookup_provider  =    (void const   *)(& ap_lookup_provider);
void const   *ap_hack_ap_set_string_slot  =    (void const   *)(& ap_set_string_slot);
void const   *ap_hack_ap_set_int_slot  =    (void const   *)(& ap_set_int_slot);
void const   *ap_hack_ap_method_is_limited  =    (void const   *)(& ap_method_is_limited);
void const   *ap_hack_ap_set_string_slot_lower  =    (void const   *)(& ap_set_string_slot_lower);
void const   *ap_hack_ap_set_flag_slot  =    (void const   *)(& ap_set_flag_slot);
void const   *ap_hack_ap_set_file_slot  =    (void const   *)(& ap_set_file_slot);
void const   *ap_hack_ap_set_deprecated  =    (void const   *)(& ap_set_deprecated);
void const   *ap_hack_ap_server_root_relative  =    (void const   *)(& ap_server_root_relative);
void const   *ap_hack_ap_add_module  =    (void const   *)(& ap_add_module);
void const   *ap_hack_ap_remove_module  =    (void const   *)(& ap_remove_module);
void const   *ap_hack_ap_add_loaded_module  =    (void const   *)(& ap_add_loaded_module);
void const   *ap_hack_ap_remove_loaded_module  =    (void const   *)(& ap_remove_loaded_module);
void const   *ap_hack_ap_add_named_module  =    (void const   *)(& ap_add_named_module);
void const   *ap_hack_ap_find_module_name  =    (void const   *)(& ap_find_module_name);
void const   *ap_hack_ap_find_linked_module  =    (void const   *)(& ap_find_linked_module);
void const   *ap_hack_ap_pcfg_openfile  =    (void const   *)(& ap_pcfg_openfile);
void const   *ap_hack_ap_pcfg_open_custom  =    (void const   *)(& ap_pcfg_open_custom);
void const   *ap_hack_ap_cfg_getline  =    (void const   *)(& ap_cfg_getline);
void const   *ap_hack_ap_cfg_getc  =    (void const   *)(& ap_cfg_getc);
void const   *ap_hack_ap_cfg_closefile  =    (void const   *)(& ap_cfg_closefile);
void const   *ap_hack_ap_soak_end_container  =    (void const   *)(& ap_soak_end_container);
void const   *ap_hack_ap_build_cont_config  =    (void const   *)(& ap_build_cont_config);
void const   *ap_hack_ap_build_config  =    (void const   *)(& ap_build_config);
void const   *ap_hack_ap_walk_config  =    (void const   *)(& ap_walk_config);
void const   *ap_hack_ap_check_cmd_context  =    (void const   *)(& ap_check_cmd_context);
void const   *ap_hack_ap_single_module_configure  =    (void const   *)(& ap_single_module_configure);
void const   *ap_hack_ap_setup_prelinked_modules  =    (void const   *)(& ap_setup_prelinked_modules);
void const   *ap_hack_ap_show_directives  =    (void const   *)(& ap_show_directives);
void const   *ap_hack_ap_show_modules  =    (void const   *)(& ap_show_modules);
void const   *ap_hack_ap_show_mpm  =    (void const   *)(& ap_show_mpm);
void const   *ap_hack_ap_read_config  =    (void const   *)(& ap_read_config);
void const   *ap_hack_ap_run_rewrite_args  =    (void const   *)(& ap_run_rewrite_args);
void const   *ap_hack_ap_register_hooks  =    (void const   *)(& ap_register_hooks);
void const   *ap_hack_ap_fixup_virtual_hosts  =    (void const   *)(& ap_fixup_virtual_hosts);
void const   *ap_hack_ap_create_request_config  =    (void const   *)(& ap_create_request_config);
void const   *ap_hack_ap_create_per_dir_config  =    (void const   *)(& ap_create_per_dir_config);
void const   *ap_hack_ap_merge_per_dir_configs  =    (void const   *)(& ap_merge_per_dir_configs);
void const   *ap_hack_ap_create_conn_config  =    (void const   *)(& ap_create_conn_config);
void const   *ap_hack_ap_parse_htaccess  =    (void const   *)(& ap_parse_htaccess);
void const   *ap_hack_ap_init_virtual_host  =    (void const   *)(& ap_init_virtual_host);
void const   *ap_hack_ap_process_resource_config  =    (void const   *)(& ap_process_resource_config);
void const   *ap_hack_ap_process_config_tree  =    (void const   *)(& ap_process_config_tree);
void const   *ap_hack_ap_invoke_handler  =    (void const   *)(& ap_invoke_handler);
void const   *ap_hack_ap_find_command  =    (void const   *)(& ap_find_command);
void const   *ap_hack_ap_find_command_in_modules  =    (void const   *)(& ap_find_command_in_modules);
void const   *ap_hack_ap_set_config_vectors  =    (void const   *)(& ap_set_config_vectors);
void const   *ap_hack_ap_hook_header_parser  =    (void const   *)(& ap_hook_header_parser);
void const   *ap_hack_ap_hook_get_header_parser  =    (void const   *)(& ap_hook_get_header_parser);
void const   *ap_hack_ap_run_header_parser  =    (void const   *)(& ap_run_header_parser);
void const   *ap_hack_ap_hook_pre_config  =    (void const   *)(& ap_hook_pre_config);
void const   *ap_hack_ap_hook_get_pre_config  =    (void const   *)(& ap_hook_get_pre_config);
void const   *ap_hack_ap_run_pre_config  =    (void const   *)(& ap_run_pre_config);
void const   *ap_hack_ap_hook_post_config  =    (void const   *)(& ap_hook_post_config);
void const   *ap_hack_ap_hook_get_post_config  =    (void const   *)(& ap_hook_get_post_config);
void const   *ap_hack_ap_run_post_config  =    (void const   *)(& ap_run_post_config);
void const   *ap_hack_ap_hook_open_logs  =    (void const   *)(& ap_hook_open_logs);
void const   *ap_hack_ap_hook_get_open_logs  =    (void const   *)(& ap_hook_get_open_logs);
void const   *ap_hack_ap_run_open_logs  =    (void const   *)(& ap_run_open_logs);
void const   *ap_hack_ap_hook_child_init  =    (void const   *)(& ap_hook_child_init);
void const   *ap_hack_ap_hook_get_child_init  =    (void const   *)(& ap_hook_get_child_init);
void const   *ap_hack_ap_run_child_init  =    (void const   *)(& ap_run_child_init);
void const   *ap_hack_ap_hook_handler  =    (void const   *)(& ap_hook_handler);
void const   *ap_hack_ap_hook_get_handler  =    (void const   *)(& ap_hook_get_handler);
void const   *ap_hack_ap_run_handler  =    (void const   *)(& ap_run_handler);
void const   *ap_hack_ap_hook_quick_handler  =    (void const   *)(& ap_hook_quick_handler);
void const   *ap_hack_ap_hook_get_quick_handler  =    (void const   *)(& ap_hook_get_quick_handler);
void const   *ap_hack_ap_run_quick_handler  =    (void const   *)(& ap_run_quick_handler);
void const   *ap_hack_ap_hook_optional_fn_retrieve  =    (void const   *)(& ap_hook_optional_fn_retrieve);
void const   *ap_hack_ap_hook_get_optional_fn_retrieve  =    (void const   *)(& ap_hook_get_optional_fn_retrieve);
void const   *ap_hack_ap_run_optional_fn_retrieve  =    (void const   *)(& ap_run_optional_fn_retrieve);
void const   *ap_hack_ap_process_connection  =    (void const   *)(& ap_process_connection);
void const   *ap_hack_ap_flush_conn  =    (void const   *)(& ap_flush_conn);
void const   *ap_hack_ap_lingering_close  =    (void const   *)(& ap_lingering_close);
void const   *ap_hack_ap_hook_create_connection  =    (void const   *)(& ap_hook_create_connection);
void const   *ap_hack_ap_hook_get_create_connection  =    (void const   *)(& ap_hook_get_create_connection);
void const   *ap_hack_ap_run_create_connection  =    (void const   *)(& ap_run_create_connection);
void const   *ap_hack_ap_hook_pre_connection  =    (void const   *)(& ap_hook_pre_connection);
void const   *ap_hack_ap_hook_get_pre_connection  =    (void const   *)(& ap_hook_get_pre_connection);
void const   *ap_hack_ap_run_pre_connection  =    (void const   *)(& ap_run_pre_connection);
void const   *ap_hack_ap_hook_process_connection  =    (void const   *)(& ap_hook_process_connection);
void const   *ap_hack_ap_hook_get_process_connection  =    (void const   *)(& ap_hook_get_process_connection);
void const   *ap_hack_ap_run_process_connection  =    (void const   *)(& ap_run_process_connection);
void const   *ap_hack_ap_allow_options  =    (void const   *)(& ap_allow_options);
void const   *ap_hack_ap_allow_overrides  =    (void const   *)(& ap_allow_overrides);
void const   *ap_hack_ap_default_type  =    (void const   *)(& ap_default_type);
void const   *ap_hack_ap_document_root  =    (void const   *)(& ap_document_root);
void const   *ap_hack_ap_get_remote_host  =    (void const   *)(& ap_get_remote_host);
void const   *ap_hack_ap_get_remote_logname  =    (void const   *)(& ap_get_remote_logname);
void const   *ap_hack_ap_construct_url  =    (void const   *)(& ap_construct_url);
void const   *ap_hack_ap_get_server_name  =    (void const   *)(& ap_get_server_name);
void const   *ap_hack_ap_get_server_port  =    (void const   *)(& ap_get_server_port);
void const   *ap_hack_ap_get_limit_req_body  =    (void const   *)(& ap_get_limit_req_body);
void const   *ap_hack_ap_get_limit_xml_body  =    (void const   *)(& ap_get_limit_xml_body);
void const   *ap_hack_ap_custom_response  =    (void const   *)(& ap_custom_response);
void const   *ap_hack_ap_exists_config_define  =    (void const   *)(& ap_exists_config_define);
void const   *ap_hack_ap_core_translate  =    (void const   *)(& ap_core_translate);
void const   *ap_hack_ap_auth_type  =    (void const   *)(& ap_auth_type);
void const   *ap_hack_ap_auth_name  =    (void const   *)(& ap_auth_name);
void const   *ap_hack_ap_satisfies  =    (void const   *)(& ap_satisfies);
void const   *ap_hack_ap_requires  =    (void const   *)(& ap_requires);
void const   *ap_hack_ap_register_request_note  =    (void const   *)(& ap_register_request_note);
void const   *ap_hack_ap_get_request_note  =    (void const   *)(& ap_get_request_note);
void const   *ap_hack_ap_add_per_dir_conf  =    (void const   *)(& ap_add_per_dir_conf);
void const   *ap_hack_ap_add_per_url_conf  =    (void const   *)(& ap_add_per_url_conf);
void const   *ap_hack_ap_add_file_conf  =    (void const   *)(& ap_add_file_conf);
void const   *ap_hack_ap_limit_section  =    (void const   *)(& ap_limit_section);
void const   *ap_hack_ap_hook_get_mgmt_items  =    (void const   *)(& ap_hook_get_mgmt_items);
void const   *ap_hack_ap_hook_get_get_mgmt_items  =    (void const   *)(& ap_hook_get_get_mgmt_items);
void const   *ap_hack_ap_run_get_mgmt_items  =    (void const   *)(& ap_run_get_mgmt_items);
void const   *ap_hack_ap_get_server_version  =    (void const   *)(& ap_get_server_version);
void const   *ap_hack_ap_add_version_component  =    (void const   *)(& ap_add_version_component);
void const   *ap_hack_ap_get_server_built  =    (void const   *)(& ap_get_server_built);
void const   *ap_hack_ap_field_noparam  =    (void const   *)(& ap_field_noparam);
void const   *ap_hack_ap_ht_time  =    (void const   *)(& ap_ht_time);
void const   *ap_hack_ap_getword  =    (void const   *)(& ap_getword);
void const   *ap_hack_ap_getword_nc  =    (void const   *)(& ap_getword_nc);
void const   *ap_hack_ap_getword_white  =    (void const   *)(& ap_getword_white);
void const   *ap_hack_ap_getword_white_nc  =    (void const   *)(& ap_getword_white_nc);
void const   *ap_hack_ap_getword_nulls  =    (void const   *)(& ap_getword_nulls);
void const   *ap_hack_ap_getword_nulls_nc  =    (void const   *)(& ap_getword_nulls_nc);
void const   *ap_hack_ap_getword_conf  =    (void const   *)(& ap_getword_conf);
void const   *ap_hack_ap_getword_conf_nc  =    (void const   *)(& ap_getword_conf_nc);
void const   *ap_hack_ap_resolve_env  =    (void const   *)(& ap_resolve_env);
void const   *ap_hack_ap_size_list_item  =    (void const   *)(& ap_size_list_item);
void const   *ap_hack_ap_get_list_item  =    (void const   *)(& ap_get_list_item);
void const   *ap_hack_ap_find_list_item  =    (void const   *)(& ap_find_list_item);
void const   *ap_hack_ap_get_token  =    (void const   *)(& ap_get_token);
void const   *ap_hack_ap_find_token  =    (void const   *)(& ap_find_token);
void const   *ap_hack_ap_find_last_token  =    (void const   *)(& ap_find_last_token);
void const   *ap_hack_ap_is_url  =    (void const   *)(& ap_is_url);
void const   *ap_hack_ap_unescape_url  =    (void const   *)(& ap_unescape_url);
void const   *ap_hack_ap_no2slash  =    (void const   *)(& ap_no2slash);
void const   *ap_hack_ap_getparents  =    (void const   *)(& ap_getparents);
void const   *ap_hack_ap_escape_path_segment  =    (void const   *)(& ap_escape_path_segment);
void const   *ap_hack_ap_os_escape_path  =    (void const   *)(& ap_os_escape_path);
void const   *ap_hack_ap_escape_html  =    (void const   *)(& ap_escape_html);
void const   *ap_hack_ap_construct_server  =    (void const   *)(& ap_construct_server);
void const   *ap_hack_ap_escape_shell_cmd  =    (void const   *)(& ap_escape_shell_cmd);
void const   *ap_hack_ap_count_dirs  =    (void const   *)(& ap_count_dirs);
void const   *ap_hack_ap_make_dirstr_prefix  =    (void const   *)(& ap_make_dirstr_prefix);
void const   *ap_hack_ap_make_dirstr_parent  =    (void const   *)(& ap_make_dirstr_parent);
void const   *ap_hack_ap_make_full_path  =    (void const   *)(& ap_make_full_path);
void const   *ap_hack_ap_os_is_path_absolute  =    (void const   *)(& ap_os_is_path_absolute);
void const   *ap_hack_ap_is_matchexp  =    (void const   *)(& ap_is_matchexp);
void const   *ap_hack_ap_strcmp_match  =    (void const   *)(& ap_strcmp_match);
void const   *ap_hack_ap_strcasecmp_match  =    (void const   *)(& ap_strcasecmp_match);
void const   *ap_hack_ap_strcasestr  =    (void const   *)(& ap_strcasestr);
void const   *ap_hack_ap_stripprefix  =    (void const   *)(& ap_stripprefix);
void const   *ap_hack_ap_pbase64decode  =    (void const   *)(& ap_pbase64decode);
void const   *ap_hack_ap_pbase64encode  =    (void const   *)(& ap_pbase64encode);
void const   *ap_hack_ap_pregcomp  =    (void const   *)(& ap_pregcomp);
void const   *ap_hack_ap_pregfree  =    (void const   *)(& ap_pregfree);
void const   *ap_hack_ap_regexec  =    (void const   *)(& ap_regexec);
void const   *ap_hack_ap_regerror  =    (void const   *)(& ap_regerror);
void const   *ap_hack_ap_pregsub  =    (void const   *)(& ap_pregsub);
void const   *ap_hack_ap_content_type_tolower  =    (void const   *)(& ap_content_type_tolower);
void const   *ap_hack_ap_str_tolower  =    (void const   *)(& ap_str_tolower);
void const   *ap_hack_ap_ind  =    (void const   *)(& ap_ind);
void const   *ap_hack_ap_rind  =    (void const   *)(& ap_rind);
void const   *ap_hack_ap_escape_quotes  =    (void const   *)(& ap_escape_quotes);
void const   *ap_hack_ap_is_rdirectory  =    (void const   *)(& ap_is_rdirectory);
void const   *ap_hack_ap_is_directory  =    (void const   *)(& ap_is_directory);
void const   *ap_hack_ap_log_assert  =    (void const   *)(& ap_log_assert);
void const   *ap_hack_ap_psignature  =    (void const   *)(& ap_psignature);
void const   *ap_hack_ap_open_stderr_log  =    (void const   *)(& ap_open_stderr_log);
void const   *ap_hack_ap_replace_stderr_log  =    (void const   *)(& ap_replace_stderr_log);
void const   *ap_hack_ap_log_error  =    (void const   *)(& ap_log_error);
void const   *ap_hack_ap_log_perror  =    (void const   *)(& ap_log_perror);
void const   *ap_hack_ap_log_rerror  =    (void const   *)(& ap_log_rerror);
void const   *ap_hack_ap_error_log2stderr  =    (void const   *)(& ap_error_log2stderr);
void const   *ap_hack_ap_log_pid  =    (void const   *)(& ap_log_pid);
void const   *ap_hack_ap_read_pid  =    (void const   *)(& ap_read_pid);
void const   *ap_hack_ap_open_piped_log  =    (void const   *)(& ap_open_piped_log);
void const   *ap_hack_ap_close_piped_log  =    (void const   *)(& ap_close_piped_log);
void const   *ap_hack_ap_hook_error_log  =    (void const   *)(& ap_hook_error_log);
void const   *ap_hack_ap_hook_get_error_log  =    (void const   *)(& ap_hook_get_error_log);
void const   *ap_hack_ap_run_error_log  =    (void const   *)(& ap_run_error_log);
void const   *ap_hack_ap_get_mime_headers  =    (void const   *)(& ap_get_mime_headers);
void const   *ap_hack_ap_get_mime_headers_core  =    (void const   *)(& ap_get_mime_headers_core);
void const   *ap_hack_ap_finalize_request_protocol  =    (void const   *)(& ap_finalize_request_protocol);
void const   *ap_hack_ap_send_error_response  =    (void const   *)(& ap_send_error_response);
void const   *ap_hack_ap_set_content_length  =    (void const   *)(& ap_set_content_length);
void const   *ap_hack_ap_set_keepalive  =    (void const   *)(& ap_set_keepalive);
void const   *ap_hack_ap_rationalize_mtime  =    (void const   *)(& ap_rationalize_mtime);
void const   *ap_hack_ap_make_content_type  =    (void const   *)(& ap_make_content_type);
void const   *ap_hack_ap_setup_make_content_type  =    (void const   *)(& ap_setup_make_content_type);
void const   *ap_hack_ap_make_etag  =    (void const   *)(& ap_make_etag);
void const   *ap_hack_ap_set_etag  =    (void const   *)(& ap_set_etag);
void const   *ap_hack_ap_set_last_modified  =    (void const   *)(& ap_set_last_modified);
void const   *ap_hack_ap_meets_conditions  =    (void const   *)(& ap_meets_conditions);
void const   *ap_hack_ap_send_fd  =    (void const   *)(& ap_send_fd);
void const   *ap_hack_ap_send_mmap  =    (void const   *)(& ap_send_mmap);
void const   *ap_hack_ap_method_register  =    (void const   *)(& ap_method_register);
void const   *ap_hack_ap_method_registry_init  =    (void const   *)(& ap_method_registry_init);
void const   *ap_hack_ap_make_method_list  =    (void const   *)(& ap_make_method_list);
void const   *ap_hack_ap_copy_method_list  =    (void const   *)(& ap_copy_method_list);
void const   *ap_hack_ap_method_list_do  =    (void const   *)(& ap_method_list_do);
void const   *ap_hack_ap_method_list_vdo  =    (void const   *)(& ap_method_list_vdo);
void const   *ap_hack_ap_method_in_list  =    (void const   *)(& ap_method_in_list);
void const   *ap_hack_ap_method_list_add  =    (void const   *)(& ap_method_list_add);
void const   *ap_hack_ap_method_list_remove  =    (void const   *)(& ap_method_list_remove);
void const   *ap_hack_ap_clear_method_list  =    (void const   *)(& ap_clear_method_list);
void const   *ap_hack_ap_set_content_type  =    (void const   *)(& ap_set_content_type);
void const   *ap_hack_ap_rputc  =    (void const   *)(& ap_rputc);
void const   *ap_hack_ap_rputs  =    (void const   *)(& ap_rputs);
void const   *ap_hack_ap_rwrite  =    (void const   *)(& ap_rwrite);
void const   *ap_hack_ap_rvputs  =    (void const   *)(& ap_rvputs);
void const   *ap_hack_ap_vrprintf  =    (void const   *)(& ap_vrprintf);
void const   *ap_hack_ap_rprintf  =    (void const   *)(& ap_rprintf);
void const   *ap_hack_ap_rflush  =    (void const   *)(& ap_rflush);
void const   *ap_hack_ap_index_of_response  =    (void const   *)(& ap_index_of_response);
void const   *ap_hack_ap_get_status_line  =    (void const   *)(& ap_get_status_line);
void const   *ap_hack_ap_setup_client_block  =    (void const   *)(& ap_setup_client_block);
void const   *ap_hack_ap_should_client_block  =    (void const   *)(& ap_should_client_block);
void const   *ap_hack_ap_get_client_block  =    (void const   *)(& ap_get_client_block);
void const   *ap_hack_ap_discard_request_body  =    (void const   *)(& ap_discard_request_body);
void const   *ap_hack_ap_note_auth_failure  =    (void const   *)(& ap_note_auth_failure);
void const   *ap_hack_ap_note_basic_auth_failure  =    (void const   *)(& ap_note_basic_auth_failure);
void const   *ap_hack_ap_note_digest_auth_failure  =    (void const   *)(& ap_note_digest_auth_failure);
void const   *ap_hack_ap_get_basic_auth_pw  =    (void const   *)(& ap_get_basic_auth_pw);
void const   *ap_hack_ap_parse_uri  =    (void const   *)(& ap_parse_uri);
void const   *ap_hack_ap_getline  =    (void const   *)(& ap_getline);
void const   *ap_hack_ap_rgetline_core  =    (void const   *)(& ap_rgetline_core);
void const   *ap_hack_ap_method_number_of  =    (void const   *)(& ap_method_number_of);
void const   *ap_hack_ap_method_name_of  =    (void const   *)(& ap_method_name_of);
void const   *ap_hack_ap_hook_post_read_request  =    (void const   *)(& ap_hook_post_read_request);
void const   *ap_hack_ap_hook_get_post_read_request  =    (void const   *)(& ap_hook_get_post_read_request);
void const   *ap_hack_ap_run_post_read_request  =    (void const   *)(& ap_run_post_read_request);
void const   *ap_hack_ap_hook_log_transaction  =    (void const   *)(& ap_hook_log_transaction);
void const   *ap_hack_ap_hook_get_log_transaction  =    (void const   *)(& ap_hook_get_log_transaction);
void const   *ap_hack_ap_run_log_transaction  =    (void const   *)(& ap_run_log_transaction);
void const   *ap_hack_ap_hook_http_method  =    (void const   *)(& ap_hook_http_method);
void const   *ap_hack_ap_hook_get_http_method  =    (void const   *)(& ap_hook_get_http_method);
void const   *ap_hack_ap_run_http_method  =    (void const   *)(& ap_run_http_method);
void const   *ap_hack_ap_hook_default_port  =    (void const   *)(& ap_hook_default_port);
void const   *ap_hack_ap_hook_get_default_port  =    (void const   *)(& ap_hook_get_default_port);
void const   *ap_hack_ap_run_default_port  =    (void const   *)(& ap_run_default_port);
void const   *ap_hack_ap_bucket_error_make  =    (void const   *)(& ap_bucket_error_make);
void const   *ap_hack_ap_bucket_error_create  =    (void const   *)(& ap_bucket_error_create);
void const   *ap_hack_ap_byterange_filter  =    (void const   *)(& ap_byterange_filter);
void const   *ap_hack_ap_http_header_filter  =    (void const   *)(& ap_http_header_filter);
void const   *ap_hack_ap_content_length_filter  =    (void const   *)(& ap_content_length_filter);
void const   *ap_hack_ap_old_write_filter  =    (void const   *)(& ap_old_write_filter);
void const   *ap_hack_ap_process_request_internal  =    (void const   *)(& ap_process_request_internal);
void const   *ap_hack_ap_sub_req_lookup_uri  =    (void const   *)(& ap_sub_req_lookup_uri);
void const   *ap_hack_ap_sub_req_lookup_file  =    (void const   *)(& ap_sub_req_lookup_file);
void const   *ap_hack_ap_sub_req_lookup_dirent  =    (void const   *)(& ap_sub_req_lookup_dirent);
void const   *ap_hack_ap_sub_req_method_uri  =    (void const   *)(& ap_sub_req_method_uri);
void const   *ap_hack_ap_sub_req_output_filter  =    (void const   *)(& ap_sub_req_output_filter);
void const   *ap_hack_ap_run_sub_req  =    (void const   *)(& ap_run_sub_req);
void const   *ap_hack_ap_destroy_sub_req  =    (void const   *)(& ap_destroy_sub_req);
void const   *ap_hack_ap_internal_redirect  =    (void const   *)(& ap_internal_redirect);
void const   *ap_hack_ap_internal_redirect_handler  =    (void const   *)(& ap_internal_redirect_handler);
void const   *ap_hack_ap_internal_fast_redirect  =    (void const   *)(& ap_internal_fast_redirect);
void const   *ap_hack_ap_some_auth_required  =    (void const   *)(& ap_some_auth_required);
void const   *ap_hack_ap_is_initial_req  =    (void const   *)(& ap_is_initial_req);
void const   *ap_hack_ap_update_mtime  =    (void const   *)(& ap_update_mtime);
void const   *ap_hack_ap_allow_methods  =    (void const   *)(& ap_allow_methods);
void const   *ap_hack_ap_allow_standard_methods  =    (void const   *)(& ap_allow_standard_methods);
void const   *ap_hack_ap_die  =    (void const   *)(& ap_die);
void const   *ap_hack_ap_hook_create_request  =    (void const   *)(& ap_hook_create_request);
void const   *ap_hack_ap_hook_get_create_request  =    (void const   *)(& ap_hook_get_create_request);
void const   *ap_hack_ap_run_create_request  =    (void const   *)(& ap_run_create_request);
void const   *ap_hack_ap_hook_translate_name  =    (void const   *)(& ap_hook_translate_name);
void const   *ap_hack_ap_hook_get_translate_name  =    (void const   *)(& ap_hook_get_translate_name);
void const   *ap_hack_ap_run_translate_name  =    (void const   *)(& ap_run_translate_name);
void const   *ap_hack_ap_hook_map_to_storage  =    (void const   *)(& ap_hook_map_to_storage);
void const   *ap_hack_ap_hook_get_map_to_storage  =    (void const   *)(& ap_hook_get_map_to_storage);
void const   *ap_hack_ap_run_map_to_storage  =    (void const   *)(& ap_run_map_to_storage);
void const   *ap_hack_ap_hook_check_user_id  =    (void const   *)(& ap_hook_check_user_id);
void const   *ap_hack_ap_hook_get_check_user_id  =    (void const   *)(& ap_hook_get_check_user_id);
void const   *ap_hack_ap_run_check_user_id  =    (void const   *)(& ap_run_check_user_id);
void const   *ap_hack_ap_hook_fixups  =    (void const   *)(& ap_hook_fixups);
void const   *ap_hack_ap_hook_get_fixups  =    (void const   *)(& ap_hook_get_fixups);
void const   *ap_hack_ap_run_fixups  =    (void const   *)(& ap_run_fixups);
void const   *ap_hack_ap_hook_type_checker  =    (void const   *)(& ap_hook_type_checker);
void const   *ap_hack_ap_hook_get_type_checker  =    (void const   *)(& ap_hook_get_type_checker);
void const   *ap_hack_ap_run_type_checker  =    (void const   *)(& ap_run_type_checker);
void const   *ap_hack_ap_hook_access_checker  =    (void const   *)(& ap_hook_access_checker);
void const   *ap_hack_ap_hook_get_access_checker  =    (void const   *)(& ap_hook_get_access_checker);
void const   *ap_hack_ap_run_access_checker  =    (void const   *)(& ap_run_access_checker);
void const   *ap_hack_ap_hook_auth_checker  =    (void const   *)(& ap_hook_auth_checker);
void const   *ap_hack_ap_hook_get_auth_checker  =    (void const   *)(& ap_hook_get_auth_checker);
void const   *ap_hack_ap_run_auth_checker  =    (void const   *)(& ap_run_auth_checker);
void const   *ap_hack_ap_hook_insert_filter  =    (void const   *)(& ap_hook_insert_filter);
void const   *ap_hack_ap_hook_get_insert_filter  =    (void const   *)(& ap_hook_get_insert_filter);
void const   *ap_hack_ap_run_insert_filter  =    (void const   *)(& ap_run_insert_filter);
void const   *ap_hack_ap_location_walk  =    (void const   *)(& ap_location_walk);
void const   *ap_hack_ap_directory_walk  =    (void const   *)(& ap_directory_walk);
void const   *ap_hack_ap_file_walk  =    (void const   *)(& ap_file_walk);
void const   *ap_hack_ap_init_vhost_config  =    (void const   *)(& ap_init_vhost_config);
void const   *ap_hack_ap_fini_vhost_config  =    (void const   *)(& ap_fini_vhost_config);
void const   *ap_hack_ap_update_vhost_given_ip  =    (void const   *)(& ap_update_vhost_given_ip);
void const   *ap_hack_ap_update_vhost_from_headers  =    (void const   *)(& ap_update_vhost_from_headers);
void const   *ap_hack_ap_matches_request_vhost  =    (void const   *)(& ap_matches_request_vhost);
void const   *ap_hack_ap_uname2id  =    (void const   *)(& ap_uname2id);
void const   *ap_hack_ap_gname2id  =    (void const   *)(& ap_gname2id);
void const   *ap_hack_ap_mpm_pod_open  =    (void const   *)(& ap_mpm_pod_open);
void const   *ap_hack_ap_mpm_pod_check  =    (void const   *)(& ap_mpm_pod_check);
void const   *ap_hack_ap_mpm_pod_close  =    (void const   *)(& ap_mpm_pod_close);
void const   *ap_hack_ap_mpm_pod_signal  =    (void const   *)(& ap_mpm_pod_signal);
void const   *ap_hack_ap_mpm_pod_killpg  =    (void const   *)(& ap_mpm_pod_killpg);
void const   *ap_hack_ap_exists_scoreboard_image  =    (void const   *)(& ap_exists_scoreboard_image);
void const   *ap_hack_ap_increment_counts  =    (void const   *)(& ap_increment_counts);
void const   *ap_hack_ap_calc_scoreboard_size  =    (void const   *)(& ap_calc_scoreboard_size);
void const   *ap_hack_ap_create_sb_handle  =    (void const   *)(& ap_create_sb_handle);
void const   *ap_hack_find_child_by_pid  =    (void const   *)(& find_child_by_pid);
void const   *ap_hack_ap_update_child_status  =    (void const   *)(& ap_update_child_status);
void const   *ap_hack_ap_update_child_status_from_indexes  =    (void const   *)(& ap_update_child_status_from_indexes);
void const   *ap_hack_ap_get_scoreboard_worker  =    (void const   *)(& ap_get_scoreboard_worker);
void const   *ap_hack_ap_get_scoreboard_process  =    (void const   *)(& ap_get_scoreboard_process);
void const   *ap_hack_ap_get_scoreboard_global  =    (void const   *)(& ap_get_scoreboard_global);
void const   *ap_hack_ap_hook_pre_mpm  =    (void const   *)(& ap_hook_pre_mpm);
void const   *ap_hack_ap_hook_get_pre_mpm  =    (void const   *)(& ap_hook_get_pre_mpm);
void const   *ap_hack_ap_run_pre_mpm  =    (void const   *)(& ap_run_pre_mpm);
void const   *ap_hack_ap_get_brigade  =    (void const   *)(& ap_get_brigade);
void const   *ap_hack_ap_pass_brigade  =    (void const   *)(& ap_pass_brigade);
void const   *ap_hack_ap_register_input_filter  =    (void const   *)(& ap_register_input_filter);
void const   *ap_hack_ap_register_output_filter  =    (void const   *)(& ap_register_output_filter);
void const   *ap_hack_ap_add_input_filter  =    (void const   *)(& ap_add_input_filter);
void const   *ap_hack_ap_add_input_filter_handle  =    (void const   *)(& ap_add_input_filter_handle);
void const   *ap_hack_ap_get_input_filter_handle  =    (void const   *)(& ap_get_input_filter_handle);
void const   *ap_hack_ap_add_output_filter  =    (void const   *)(& ap_add_output_filter);
void const   *ap_hack_ap_add_output_filter_handle  =    (void const   *)(& ap_add_output_filter_handle);
void const   *ap_hack_ap_get_output_filter_handle  =    (void const   *)(& ap_get_output_filter_handle);
void const   *ap_hack_ap_remove_input_filter  =    (void const   *)(& ap_remove_input_filter);
void const   *ap_hack_ap_remove_output_filter  =    (void const   *)(& ap_remove_output_filter);
void const   *ap_hack_ap_save_brigade  =    (void const   *)(& ap_save_brigade);
void const   *ap_hack_ap_filter_flush  =    (void const   *)(& ap_filter_flush);
void const   *ap_hack_ap_fflush  =    (void const   *)(& ap_fflush);
void const   *ap_hack_ap_fputstrs  =    (void const   *)(& ap_fputstrs);
void const   *ap_hack_ap_fprintf  =    (void const   *)(& ap_fprintf);
void const   *ap_hack_ap_md5  =    (void const   *)(& ap_md5);
void const   *ap_hack_ap_md5_binary  =    (void const   *)(& ap_md5_binary);
void const   *ap_hack_ap_md5contextTo64  =    (void const   *)(& ap_md5contextTo64);
void const   *ap_hack_ap_md5digest  =    (void const   *)(& ap_md5digest);
void const   *ap_hack_ap_create_environment  =    (void const   *)(& ap_create_environment);
void const   *ap_hack_ap_find_path_info  =    (void const   *)(& ap_find_path_info);
void const   *ap_hack_ap_add_cgi_vars  =    (void const   *)(& ap_add_cgi_vars);
void const   *ap_hack_ap_add_common_vars  =    (void const   *)(& ap_add_common_vars);
void const   *ap_hack_ap_scan_script_header_err  =    (void const   *)(& ap_scan_script_header_err);
void const   *ap_hack_ap_scan_script_header_err_brigade  =    (void const   *)(& ap_scan_script_header_err_brigade);
void const   *ap_hack_ap_scan_script_header_err_strs  =    (void const   *)(& ap_scan_script_header_err_strs);
void const   *ap_hack_ap_scan_script_header_err_core  =    (void const   *)(& ap_scan_script_header_err_core);
void const   *ap_hack_ap_explode_recent_localtime  =    (void const   *)(& ap_explode_recent_localtime);
void const   *ap_hack_ap_explode_recent_gmt  =    (void const   *)(& ap_explode_recent_gmt);
void const   *ap_hack_ap_recent_ctime  =    (void const   *)(& ap_recent_ctime);
void const   *ap_hack_ap_recent_rfc822_date  =    (void const   *)(& ap_recent_rfc822_date);
void const   *ap_hack_ap_xml_parse_input  =    (void const   *)(& ap_xml_parse_input);
void const   *ap_hack_ap_hook_get_suexec_identity  =    (void const   *)(& ap_hook_get_suexec_identity);
void const   *ap_hack_ap_hook_get_get_suexec_identity  =    (void const   *)(& ap_hook_get_get_suexec_identity);
void const   *ap_hack_ap_run_get_suexec_identity  =    (void const   *)(& ap_run_get_suexec_identity);
void const   *ap_hack_unixd_setup_child  =    (void const   *)(& unixd_setup_child);
void const   *ap_hack_unixd_pre_config  =    (void const   *)(& unixd_pre_config);
void const   *ap_hack_unixd_set_user  =    (void const   *)(& unixd_set_user);
void const   *ap_hack_unixd_set_group  =    (void const   *)(& unixd_set_group);
void const   *ap_hack_unixd_set_rlimit  =    (void const   *)(& unixd_set_rlimit);
void const   *ap_hack_unixd_set_proc_mutex_perms  =    (void const   *)(& unixd_set_proc_mutex_perms);
void const   *ap_hack_unixd_set_global_mutex_perms  =    (void const   *)(& unixd_set_global_mutex_perms);
void const   *ap_hack_unixd_accept  =    (void const   *)(& unixd_accept);
void const   *ap_hack_apr_allocator_create  =    (void const   *)(& apr_allocator_create);
void const   *ap_hack_apr_allocator_destroy  =    (void const   *)(& apr_allocator_destroy);
void const   *ap_hack_apr_allocator_alloc  =    (void const   *)(& apr_allocator_alloc);
void const   *ap_hack_apr_allocator_free  =    (void const   *)(& apr_allocator_free);
void const   *ap_hack_apr_allocator_owner_set  =    (void const   *)(& apr_allocator_owner_set);
void const   *ap_hack_apr_allocator_set_owner  =    (void const   *)(& apr_allocator_set_owner);
void const   *ap_hack_apr_allocator_owner_get  =    (void const   *)(& apr_allocator_owner_get);
void const   *ap_hack_apr_allocator_get_owner  =    (void const   *)(& apr_allocator_get_owner);
void const   *ap_hack_apr_allocator_max_free_set  =    (void const   *)(& apr_allocator_max_free_set);
void const   *ap_hack_apr_allocator_set_max_free  =    (void const   *)(& apr_allocator_set_max_free);
void const   *ap_hack_apr_allocator_mutex_set  =    (void const   *)(& apr_allocator_mutex_set);
void const   *ap_hack_apr_allocator_set_mutex  =    (void const   *)(& apr_allocator_set_mutex);
void const   *ap_hack_apr_allocator_mutex_get  =    (void const   *)(& apr_allocator_mutex_get);
void const   *ap_hack_apr_allocator_get_mutex  =    (void const   *)(& apr_allocator_get_mutex);
void const   *ap_hack_apr_dso_load  =    (void const   *)(& apr_dso_load);
void const   *ap_hack_apr_dso_unload  =    (void const   *)(& apr_dso_unload);
void const   *ap_hack_apr_dso_sym  =    (void const   *)(& apr_dso_sym);
void const   *ap_hack_apr_dso_error  =    (void const   *)(& apr_dso_error);
void const   *ap_hack_apr_strerror  =    (void const   *)(& apr_strerror);
void const   *ap_hack_apr_stat  =    (void const   *)(& apr_stat);
void const   *ap_hack_apr_lstat  =    (void const   *)(& apr_lstat);
void const   *ap_hack_apr_dir_open  =    (void const   *)(& apr_dir_open);
void const   *ap_hack_apr_dir_close  =    (void const   *)(& apr_dir_close);
void const   *ap_hack_apr_dir_read  =    (void const   *)(& apr_dir_read);
void const   *ap_hack_apr_dir_rewind  =    (void const   *)(& apr_dir_rewind);
void const   *ap_hack_apr_filepath_root  =    (void const   *)(& apr_filepath_root);
void const   *ap_hack_apr_filepath_merge  =    (void const   *)(& apr_filepath_merge);
void const   *ap_hack_apr_filepath_get  =    (void const   *)(& apr_filepath_get);
void const   *ap_hack_apr_filepath_set  =    (void const   *)(& apr_filepath_set);
void const   *ap_hack_apr_filepath_encoding  =    (void const   *)(& apr_filepath_encoding);
void const   *ap_hack_apr_file_open  =    (void const   *)(& apr_file_open);
void const   *ap_hack_apr_file_close  =    (void const   *)(& apr_file_close);
void const   *ap_hack_apr_file_remove  =    (void const   *)(& apr_file_remove);
void const   *ap_hack_apr_file_rename  =    (void const   *)(& apr_file_rename);
void const   *ap_hack_apr_file_copy  =    (void const   *)(& apr_file_copy);
void const   *ap_hack_apr_file_append  =    (void const   *)(& apr_file_append);
void const   *ap_hack_apr_file_eof  =    (void const   *)(& apr_file_eof);
void const   *ap_hack_apr_file_open_stderr  =    (void const   *)(& apr_file_open_stderr);
void const   *ap_hack_apr_file_open_stdout  =    (void const   *)(& apr_file_open_stdout);
void const   *ap_hack_apr_file_open_stdin  =    (void const   *)(& apr_file_open_stdin);
void const   *ap_hack_apr_file_read  =    (void const   *)(& apr_file_read);
void const   *ap_hack_apr_file_write  =    (void const   *)(& apr_file_write);
void const   *ap_hack_apr_file_writev  =    (void const   *)(& apr_file_writev);
void const   *ap_hack_apr_file_read_full  =    (void const   *)(& apr_file_read_full);
void const   *ap_hack_apr_file_write_full  =    (void const   *)(& apr_file_write_full);
void const   *ap_hack_apr_file_putc  =    (void const   *)(& apr_file_putc);
void const   *ap_hack_apr_file_getc  =    (void const   *)(& apr_file_getc);
void const   *ap_hack_apr_file_ungetc  =    (void const   *)(& apr_file_ungetc);
void const   *ap_hack_apr_file_gets  =    (void const   *)(& apr_file_gets);
void const   *ap_hack_apr_file_puts  =    (void const   *)(& apr_file_puts);
void const   *ap_hack_apr_file_flush  =    (void const   *)(& apr_file_flush);
void const   *ap_hack_apr_file_dup  =    (void const   *)(& apr_file_dup);
void const   *ap_hack_apr_file_dup2  =    (void const   *)(& apr_file_dup2);
void const   *ap_hack_apr_file_setaside  =    (void const   *)(& apr_file_setaside);
void const   *ap_hack_apr_file_seek  =    (void const   *)(& apr_file_seek);
void const   *ap_hack_apr_file_pipe_create  =    (void const   *)(& apr_file_pipe_create);
void const   *ap_hack_apr_file_namedpipe_create  =    (void const   *)(& apr_file_namedpipe_create);
void const   *ap_hack_apr_file_pipe_timeout_get  =    (void const   *)(& apr_file_pipe_timeout_get);
void const   *ap_hack_apr_file_pipe_timeout_set  =    (void const   *)(& apr_file_pipe_timeout_set);
void const   *ap_hack_apr_file_lock  =    (void const   *)(& apr_file_lock);
void const   *ap_hack_apr_file_unlock  =    (void const   *)(& apr_file_unlock);
void const   *ap_hack_apr_file_name_get  =    (void const   *)(& apr_file_name_get);
void const   *ap_hack_apr_file_data_get  =    (void const   *)(& apr_file_data_get);
void const   *ap_hack_apr_file_data_set  =    (void const   *)(& apr_file_data_set);
void const   *ap_hack_apr_file_printf  =    (void const   *)(& apr_file_printf);
void const   *ap_hack_apr_file_perms_set  =    (void const   *)(& apr_file_perms_set);
void const   *ap_hack_apr_file_attrs_set  =    (void const   *)(& apr_file_attrs_set);
void const   *ap_hack_apr_dir_make  =    (void const   *)(& apr_dir_make);
void const   *ap_hack_apr_dir_make_recursive  =    (void const   *)(& apr_dir_make_recursive);
void const   *ap_hack_apr_dir_remove  =    (void const   *)(& apr_dir_remove);
void const   *ap_hack_apr_file_info_get  =    (void const   *)(& apr_file_info_get);
void const   *ap_hack_apr_file_trunc  =    (void const   *)(& apr_file_trunc);
void const   *ap_hack_apr_file_flags_get  =    (void const   *)(& apr_file_flags_get);
void const   *ap_hack_apr_file_pool_get  =    (void const   *)(& apr_file_pool_get);
void const   *ap_hack_apr_file_inherit_set  =    (void const   *)(& apr_file_inherit_set);
void const   *ap_hack_apr_file_set_inherit  =    (void const   *)(& apr_file_set_inherit);
void const   *ap_hack_apr_file_inherit_unset  =    (void const   *)(& apr_file_inherit_unset);
void const   *ap_hack_apr_file_unset_inherit  =    (void const   *)(& apr_file_unset_inherit);
void const   *ap_hack_apr_file_mktemp  =    (void const   *)(& apr_file_mktemp);
void const   *ap_hack_apr_fnmatch  =    (void const   *)(& apr_fnmatch);
void const   *ap_hack_apr_fnmatch_test  =    (void const   *)(& apr_fnmatch_test);
void const   *ap_hack_apr_is_fnmatch  =    (void const   *)(& apr_is_fnmatch);
void const   *ap_hack_apr_initialize  =    (void const   *)(& apr_initialize);
void const   *ap_hack_apr_app_initialize  =    (void const   *)(& apr_app_initialize);
void const   *ap_hack_apr_terminate  =    (void const   *)(& apr_terminate);
void const   *ap_hack_apr_terminate2  =    (void const   *)(& apr_terminate2);
void const   *ap_hack_apr_generate_random_bytes  =    (void const   *)(& apr_generate_random_bytes);
void const   *ap_hack_apr_getopt_init  =    (void const   *)(& apr_getopt_init);
void const   *ap_hack_apr_getopt  =    (void const   *)(& apr_getopt);
void const   *ap_hack_apr_getopt_long  =    (void const   *)(& apr_getopt_long);
void const   *ap_hack_apr_global_mutex_create  =    (void const   *)(& apr_global_mutex_create);
void const   *ap_hack_apr_global_mutex_child_init  =    (void const   *)(& apr_global_mutex_child_init);
void const   *ap_hack_apr_global_mutex_lock  =    (void const   *)(& apr_global_mutex_lock);
void const   *ap_hack_apr_global_mutex_trylock  =    (void const   *)(& apr_global_mutex_trylock);
void const   *ap_hack_apr_global_mutex_unlock  =    (void const   *)(& apr_global_mutex_unlock);
void const   *ap_hack_apr_global_mutex_destroy  =    (void const   *)(& apr_global_mutex_destroy);
void const   *ap_hack_apr_global_mutex_pool_get  =    (void const   *)(& apr_global_mutex_pool_get);
void const   *ap_hack_apr_hash_make  =    (void const   *)(& apr_hash_make);
void const   *ap_hack_apr_hash_copy  =    (void const   *)(& apr_hash_copy);
void const   *ap_hack_apr_hash_set  =    (void const   *)(& apr_hash_set);
void const   *ap_hack_apr_hash_get  =    (void const   *)(& apr_hash_get);
void const   *ap_hack_apr_hash_first  =    (void const   *)(& apr_hash_first);
void const   *ap_hack_apr_hash_next  =    (void const   *)(& apr_hash_next);
void const   *ap_hack_apr_hash_this  =    (void const   *)(& apr_hash_this);
void const   *ap_hack_apr_hash_count  =    (void const   *)(& apr_hash_count);
void const   *ap_hack_apr_hash_overlay  =    (void const   *)(& apr_hash_overlay);
void const   *ap_hack_apr_hash_merge  =    (void const   *)(& apr_hash_merge);
void const   *ap_hack_apr_hash_pool_get  =    (void const   *)(& apr_hash_pool_get);
void const   *ap_hack_apr_filepath_name_get  =    (void const   *)(& apr_filepath_name_get);
void const   *ap_hack_apr_filename_of_pathname  =    (void const   *)(& apr_filename_of_pathname);
void const   *ap_hack_apr_vformatter  =    (void const   *)(& apr_vformatter);
void const   *ap_hack_apr_password_get  =    (void const   *)(& apr_password_get);
void const   *ap_hack_apr_mmap_create  =    (void const   *)(& apr_mmap_create);
void const   *ap_hack_apr_mmap_dup  =    (void const   *)(& apr_mmap_dup);
void const   *ap_hack_apr_mmap_delete  =    (void const   *)(& apr_mmap_delete);
void const   *ap_hack_apr_mmap_offset  =    (void const   *)(& apr_mmap_offset);
void const   *ap_hack_apr_socket_create  =    (void const   *)(& apr_socket_create);
void const   *ap_hack_apr_socket_create_ex  =    (void const   *)(& apr_socket_create_ex);
void const   *ap_hack_apr_socket_shutdown  =    (void const   *)(& apr_socket_shutdown);
void const   *ap_hack_apr_shutdown  =    (void const   *)(& apr_shutdown);
void const   *ap_hack_apr_socket_close  =    (void const   *)(& apr_socket_close);
void const   *ap_hack_apr_socket_bind  =    (void const   *)(& apr_socket_bind);
void const   *ap_hack_apr_bind  =    (void const   *)(& apr_bind);
void const   *ap_hack_apr_socket_listen  =    (void const   *)(& apr_socket_listen);
void const   *ap_hack_apr_listen  =    (void const   *)(& apr_listen);
void const   *ap_hack_apr_socket_accept  =    (void const   *)(& apr_socket_accept);
void const   *ap_hack_apr_accept  =    (void const   *)(& apr_accept);
void const   *ap_hack_apr_socket_connect  =    (void const   *)(& apr_socket_connect);
void const   *ap_hack_apr_connect  =    (void const   *)(& apr_connect);
void const   *ap_hack_apr_sockaddr_info_get  =    (void const   *)(& apr_sockaddr_info_get);
void const   *ap_hack_apr_getnameinfo  =    (void const   *)(& apr_getnameinfo);
void const   *ap_hack_apr_parse_addr_port  =    (void const   *)(& apr_parse_addr_port);
void const   *ap_hack_apr_gethostname  =    (void const   *)(& apr_gethostname);
void const   *ap_hack_apr_socket_data_get  =    (void const   *)(& apr_socket_data_get);
void const   *ap_hack_apr_socket_data_set  =    (void const   *)(& apr_socket_data_set);
void const   *ap_hack_apr_socket_send  =    (void const   *)(& apr_socket_send);
void const   *ap_hack_apr_send  =    (void const   *)(& apr_send);
void const   *ap_hack_apr_socket_sendv  =    (void const   *)(& apr_socket_sendv);
void const   *ap_hack_apr_sendv  =    (void const   *)(& apr_sendv);
void const   *ap_hack_apr_socket_sendto  =    (void const   *)(& apr_socket_sendto);
void const   *ap_hack_apr_sendto  =    (void const   *)(& apr_sendto);
void const   *ap_hack_apr_socket_recvfrom  =    (void const   *)(& apr_socket_recvfrom);
void const   *ap_hack_apr_recvfrom  =    (void const   *)(& apr_recvfrom);
void const   *ap_hack_apr_socket_sendfile  =    (void const   *)(& apr_socket_sendfile);
void const   *ap_hack_apr_sendfile  =    (void const   *)(& apr_sendfile);
void const   *ap_hack_apr_socket_recv  =    (void const   *)(& apr_socket_recv);
void const   *ap_hack_apr_recv  =    (void const   *)(& apr_recv);
void const   *ap_hack_apr_socket_opt_set  =    (void const   *)(& apr_socket_opt_set);
void const   *ap_hack_apr_setsocketopt  =    (void const   *)(& apr_setsocketopt);
void const   *ap_hack_apr_socket_timeout_set  =    (void const   *)(& apr_socket_timeout_set);
void const   *ap_hack_apr_socket_opt_get  =    (void const   *)(& apr_socket_opt_get);
void const   *ap_hack_apr_getsocketopt  =    (void const   *)(& apr_getsocketopt);
void const   *ap_hack_apr_socket_timeout_get  =    (void const   *)(& apr_socket_timeout_get);
void const   *ap_hack_apr_socket_addr_get  =    (void const   *)(& apr_socket_addr_get);
void const   *ap_hack_apr_sockaddr_port_set  =    (void const   *)(& apr_sockaddr_port_set);
void const   *ap_hack_apr_sockaddr_port_get  =    (void const   *)(& apr_sockaddr_port_get);
void const   *ap_hack_apr_sockaddr_ip_set  =    (void const   *)(& apr_sockaddr_ip_set);
void const   *ap_hack_apr_sockaddr_ip_get  =    (void const   *)(& apr_sockaddr_ip_get);
void const   *ap_hack_apr_sockaddr_equal  =    (void const   *)(& apr_sockaddr_equal);
void const   *ap_hack_apr_socket_from_file  =    (void const   *)(& apr_socket_from_file);
void const   *ap_hack_apr_getservbyname  =    (void const   *)(& apr_getservbyname);
void const   *ap_hack_apr_ipsubnet_create  =    (void const   *)(& apr_ipsubnet_create);
void const   *ap_hack_apr_ipsubnet_test  =    (void const   *)(& apr_ipsubnet_test);
void const   *ap_hack_apr_socket_protocol_get  =    (void const   *)(& apr_socket_protocol_get);
void const   *ap_hack_apr_socket_inherit_set  =    (void const   *)(& apr_socket_inherit_set);
void const   *ap_hack_apr_socket_set_inherit  =    (void const   *)(& apr_socket_set_inherit);
void const   *ap_hack_apr_socket_inherit_unset  =    (void const   *)(& apr_socket_inherit_unset);
void const   *ap_hack_apr_socket_unset_inherit  =    (void const   *)(& apr_socket_unset_inherit);
void const   *ap_hack_apr_poll_setup  =    (void const   *)(& apr_poll_setup);
void const   *ap_hack_apr_poll  =    (void const   *)(& apr_poll);
void const   *ap_hack_apr_poll_socket_add  =    (void const   *)(& apr_poll_socket_add);
void const   *ap_hack_apr_poll_socket_mask  =    (void const   *)(& apr_poll_socket_mask);
void const   *ap_hack_apr_poll_socket_remove  =    (void const   *)(& apr_poll_socket_remove);
void const   *ap_hack_apr_poll_socket_clear  =    (void const   *)(& apr_poll_socket_clear);
void const   *ap_hack_apr_poll_revents_get  =    (void const   *)(& apr_poll_revents_get);
void const   *ap_hack_apr_pollset_create  =    (void const   *)(& apr_pollset_create);
void const   *ap_hack_apr_pollset_destroy  =    (void const   *)(& apr_pollset_destroy);
void const   *ap_hack_apr_pollset_add  =    (void const   *)(& apr_pollset_add);
void const   *ap_hack_apr_pollset_remove  =    (void const   *)(& apr_pollset_remove);
void const   *ap_hack_apr_pollset_poll  =    (void const   *)(& apr_pollset_poll);
void const   *ap_hack_apr_pool_initialize  =    (void const   *)(& apr_pool_initialize);
void const   *ap_hack_apr_pool_terminate  =    (void const   *)(& apr_pool_terminate);
void const   *ap_hack_apr_pool_create_ex  =    (void const   *)(& apr_pool_create_ex);
void const   *ap_hack_apr_pool_create_ex_debug  =    (void const   *)(& apr_pool_create_ex_debug);
void const   *ap_hack_apr_pool_allocator_get  =    (void const   *)(& apr_pool_allocator_get);
void const   *ap_hack_apr_pool_clear  =    (void const   *)(& apr_pool_clear);
void const   *ap_hack_apr_pool_clear_debug  =    (void const   *)(& apr_pool_clear_debug);
void const   *ap_hack_apr_pool_destroy  =    (void const   *)(& apr_pool_destroy);
void const   *ap_hack_apr_pool_destroy_debug  =    (void const   *)(& apr_pool_destroy_debug);
void const   *ap_hack_apr_palloc  =    (void const   *)(& apr_palloc);
void const   *ap_hack_apr_palloc_debug  =    (void const   *)(& apr_palloc_debug);
void const   *ap_hack_apr_pcalloc_debug  =    (void const   *)(& apr_pcalloc_debug);
void const   *ap_hack_apr_pool_abort_set  =    (void const   *)(& apr_pool_abort_set);
void const   *ap_hack_apr_pool_set_abort  =    (void const   *)(& apr_pool_set_abort);
void const   *ap_hack_apr_pool_abort_get  =    (void const   *)(& apr_pool_abort_get);
void const   *ap_hack_apr_pool_get_abort  =    (void const   *)(& apr_pool_get_abort);
void const   *ap_hack_apr_pool_parent_get  =    (void const   *)(& apr_pool_parent_get);
void const   *ap_hack_apr_pool_get_parent  =    (void const   *)(& apr_pool_get_parent);
void const   *ap_hack_apr_pool_is_ancestor  =    (void const   *)(& apr_pool_is_ancestor);
void const   *ap_hack_apr_pool_tag  =    (void const   *)(& apr_pool_tag);
void const   *ap_hack_apr_pool_userdata_set  =    (void const   *)(& apr_pool_userdata_set);
void const   *ap_hack_apr_pool_userdata_setn  =    (void const   *)(& apr_pool_userdata_setn);
void const   *ap_hack_apr_pool_userdata_get  =    (void const   *)(& apr_pool_userdata_get);
void const   *ap_hack_apr_pool_cleanup_register  =    (void const   *)(& apr_pool_cleanup_register);
void const   *ap_hack_apr_pool_cleanup_kill  =    (void const   *)(& apr_pool_cleanup_kill);
void const   *ap_hack_apr_pool_child_cleanup_set  =    (void const   *)(& apr_pool_child_cleanup_set);
void const   *ap_hack_apr_pool_cleanup_run  =    (void const   *)(& apr_pool_cleanup_run);
void const   *ap_hack_apr_pool_cleanup_null  =    (void const   *)(& apr_pool_cleanup_null);
void const   *ap_hack_apr_pool_cleanup_for_exec  =    (void const   *)(& apr_pool_cleanup_for_exec);
void const   *ap_hack_apr_os_global_mutex_get  =    (void const   *)(& apr_os_global_mutex_get);
void const   *ap_hack_apr_os_file_get  =    (void const   *)(& apr_os_file_get);
void const   *ap_hack_apr_os_dir_get  =    (void const   *)(& apr_os_dir_get);
void const   *ap_hack_apr_os_sock_get  =    (void const   *)(& apr_os_sock_get);
void const   *ap_hack_apr_os_proc_mutex_get  =    (void const   *)(& apr_os_proc_mutex_get);
void const   *ap_hack_apr_os_exp_time_get  =    (void const   *)(& apr_os_exp_time_get);
void const   *ap_hack_apr_os_imp_time_get  =    (void const   *)(& apr_os_imp_time_get);
void const   *ap_hack_apr_os_shm_get  =    (void const   *)(& apr_os_shm_get);
void const   *ap_hack_apr_os_thread_get  =    (void const   *)(& apr_os_thread_get);
void const   *ap_hack_apr_os_threadkey_get  =    (void const   *)(& apr_os_threadkey_get);
void const   *ap_hack_apr_os_thread_put  =    (void const   *)(& apr_os_thread_put);
void const   *ap_hack_apr_os_threadkey_put  =    (void const   *)(& apr_os_threadkey_put);
void const   *ap_hack_apr_os_thread_current  =    (void const   *)(& apr_os_thread_current);
void const   *ap_hack_apr_os_thread_equal  =    (void const   *)(& apr_os_thread_equal);
void const   *ap_hack_apr_os_file_put  =    (void const   *)(& apr_os_file_put);
void const   *ap_hack_apr_os_pipe_put  =    (void const   *)(& apr_os_pipe_put);
void const   *ap_hack_apr_os_dir_put  =    (void const   *)(& apr_os_dir_put);
void const   *ap_hack_apr_os_sock_put  =    (void const   *)(& apr_os_sock_put);
void const   *ap_hack_apr_os_sock_make  =    (void const   *)(& apr_os_sock_make);
void const   *ap_hack_apr_os_proc_mutex_put  =    (void const   *)(& apr_os_proc_mutex_put);
void const   *ap_hack_apr_os_imp_time_put  =    (void const   *)(& apr_os_imp_time_put);
void const   *ap_hack_apr_os_exp_time_put  =    (void const   *)(& apr_os_exp_time_put);
void const   *ap_hack_apr_os_shm_put  =    (void const   *)(& apr_os_shm_put);
void const   *ap_hack_apr_os_dso_handle_put  =    (void const   *)(& apr_os_dso_handle_put);
void const   *ap_hack_apr_os_dso_handle_get  =    (void const   *)(& apr_os_dso_handle_get);
void const   *ap_hack_apr_os_default_encoding  =    (void const   *)(& apr_os_default_encoding);
void const   *ap_hack_apr_os_locale_encoding  =    (void const   *)(& apr_os_locale_encoding);
void const   *ap_hack_apr_proc_mutex_create  =    (void const   *)(& apr_proc_mutex_create);
void const   *ap_hack_apr_proc_mutex_child_init  =    (void const   *)(& apr_proc_mutex_child_init);
void const   *ap_hack_apr_proc_mutex_lock  =    (void const   *)(& apr_proc_mutex_lock);
void const   *ap_hack_apr_proc_mutex_trylock  =    (void const   *)(& apr_proc_mutex_trylock);
void const   *ap_hack_apr_proc_mutex_unlock  =    (void const   *)(& apr_proc_mutex_unlock);
void const   *ap_hack_apr_proc_mutex_destroy  =    (void const   *)(& apr_proc_mutex_destroy);
void const   *ap_hack_apr_proc_mutex_cleanup  =    (void const   *)(& apr_proc_mutex_cleanup);
void const   *ap_hack_apr_proc_mutex_name  =    (void const   *)(& apr_proc_mutex_name);
void const   *ap_hack_apr_proc_mutex_defname  =    (void const   *)(& apr_proc_mutex_defname);
void const   *ap_hack_apr_proc_mutex_pool_get  =    (void const   *)(& apr_proc_mutex_pool_get);
void const   *ap_hack_apr_shm_create  =    (void const   *)(& apr_shm_create);
void const   *ap_hack_apr_shm_destroy  =    (void const   *)(& apr_shm_destroy);
void const   *ap_hack_apr_shm_attach  =    (void const   *)(& apr_shm_attach);
void const   *ap_hack_apr_shm_detach  =    (void const   *)(& apr_shm_detach);
void const   *ap_hack_apr_shm_baseaddr_get  =    (void const   *)(& apr_shm_baseaddr_get);
void const   *ap_hack_apr_shm_size_get  =    (void const   *)(& apr_shm_size_get);
void const   *ap_hack_apr_shm_pool_get  =    (void const   *)(& apr_shm_pool_get);
void const   *ap_hack_apr_signal  =    (void const   *)(& apr_signal);
void const   *ap_hack_apr_signal_description_get  =    (void const   *)(& apr_signal_description_get);
void const   *ap_hack_apr_signal_get_description  =    (void const   *)(& apr_signal_get_description);
void const   *ap_hack_apr_strnatcmp  =    (void const   *)(& apr_strnatcmp);
void const   *ap_hack_apr_strnatcasecmp  =    (void const   *)(& apr_strnatcasecmp);
void const   *ap_hack_apr_pstrdup  =    (void const   *)(& apr_pstrdup);
void const   *ap_hack_apr_pstrmemdup  =    (void const   *)(& apr_pstrmemdup);
void const   *ap_hack_apr_pstrndup  =    (void const   *)(& apr_pstrndup);
void const   *ap_hack_apr_pmemdup  =    (void const   *)(& apr_pmemdup);
void const   *ap_hack_apr_pstrcat  =    (void const   *)(& apr_pstrcat);
void const   *ap_hack_apr_pstrcatv  =    (void const   *)(& apr_pstrcatv);
void const   *ap_hack_apr_pvsprintf  =    (void const   *)(& apr_pvsprintf);
void const   *ap_hack_apr_psprintf  =    (void const   *)(& apr_psprintf);
void const   *ap_hack_apr_cpystrn  =    (void const   *)(& apr_cpystrn);
void const   *ap_hack_apr_collapse_spaces  =    (void const   *)(& apr_collapse_spaces);
void const   *ap_hack_apr_tokenize_to_argv  =    (void const   *)(& apr_tokenize_to_argv);
void const   *ap_hack_apr_strtok  =    (void const   *)(& apr_strtok);
void const   *ap_hack_apr_snprintf  =    (void const   *)(& apr_snprintf);
void const   *ap_hack_apr_vsnprintf  =    (void const   *)(& apr_vsnprintf);
void const   *ap_hack_apr_itoa  =    (void const   *)(& apr_itoa);
void const   *ap_hack_apr_ltoa  =    (void const   *)(& apr_ltoa);
void const   *ap_hack_apr_off_t_toa  =    (void const   *)(& apr_off_t_toa);
void const   *ap_hack_apr_strtoi64  =    (void const   *)(& apr_strtoi64);
void const   *ap_hack_apr_atoi64  =    (void const   *)(& apr_atoi64);
void const   *ap_hack_apr_strfsize  =    (void const   *)(& apr_strfsize);
void const   *ap_hack_apr_table_elts  =    (void const   *)(& apr_table_elts);
void const   *ap_hack_apr_is_empty_table  =    (void const   *)(& apr_is_empty_table);
void const   *ap_hack_apr_is_empty_array  =    (void const   *)(& apr_is_empty_array);
void const   *ap_hack_apr_array_make  =    (void const   *)(& apr_array_make);
void const   *ap_hack_apr_array_push  =    (void const   *)(& apr_array_push);
void const   *ap_hack_apr_array_pop  =    (void const   *)(& apr_array_pop);
void const   *ap_hack_apr_array_cat  =    (void const   *)(& apr_array_cat);
void const   *ap_hack_apr_array_copy  =    (void const   *)(& apr_array_copy);
void const   *ap_hack_apr_array_copy_hdr  =    (void const   *)(& apr_array_copy_hdr);
void const   *ap_hack_apr_array_append  =    (void const   *)(& apr_array_append);
void const   *ap_hack_apr_array_pstrcat  =    (void const   *)(& apr_array_pstrcat);
void const   *ap_hack_apr_table_make  =    (void const   *)(& apr_table_make);
void const   *ap_hack_apr_table_copy  =    (void const   *)(& apr_table_copy);
void const   *ap_hack_apr_table_clear  =    (void const   *)(& apr_table_clear);
void const   *ap_hack_apr_table_get  =    (void const   *)(& apr_table_get);
void const   *ap_hack_apr_table_set  =    (void const   *)(& apr_table_set);
void const   *ap_hack_apr_table_setn  =    (void const   *)(& apr_table_setn);
void const   *ap_hack_apr_table_unset  =    (void const   *)(& apr_table_unset);
void const   *ap_hack_apr_table_merge  =    (void const   *)(& apr_table_merge);
void const   *ap_hack_apr_table_mergen  =    (void const   *)(& apr_table_mergen);
void const   *ap_hack_apr_table_add  =    (void const   *)(& apr_table_add);
void const   *ap_hack_apr_table_addn  =    (void const   *)(& apr_table_addn);
void const   *ap_hack_apr_table_overlay  =    (void const   *)(& apr_table_overlay);
void const   *ap_hack_apr_table_do  =    (void const   *)(& apr_table_do);
void const   *ap_hack_apr_table_vdo  =    (void const   *)(& apr_table_vdo);
void const   *ap_hack_apr_table_overlap  =    (void const   *)(& apr_table_overlap);
void const   *ap_hack_apr_thread_cond_create  =    (void const   *)(& apr_thread_cond_create);
void const   *ap_hack_apr_thread_cond_wait  =    (void const   *)(& apr_thread_cond_wait);
void const   *ap_hack_apr_thread_cond_timedwait  =    (void const   *)(& apr_thread_cond_timedwait);
void const   *ap_hack_apr_thread_cond_signal  =    (void const   *)(& apr_thread_cond_signal);
void const   *ap_hack_apr_thread_cond_broadcast  =    (void const   *)(& apr_thread_cond_broadcast);
void const   *ap_hack_apr_thread_cond_destroy  =    (void const   *)(& apr_thread_cond_destroy);
void const   *ap_hack_apr_thread_cond_pool_get  =    (void const   *)(& apr_thread_cond_pool_get);
void const   *ap_hack_apr_thread_mutex_create  =    (void const   *)(& apr_thread_mutex_create);
void const   *ap_hack_apr_thread_mutex_lock  =    (void const   *)(& apr_thread_mutex_lock);
void const   *ap_hack_apr_thread_mutex_trylock  =    (void const   *)(& apr_thread_mutex_trylock);
void const   *ap_hack_apr_thread_mutex_unlock  =    (void const   *)(& apr_thread_mutex_unlock);
void const   *ap_hack_apr_thread_mutex_destroy  =    (void const   *)(& apr_thread_mutex_destroy);
void const   *ap_hack_apr_thread_mutex_pool_get  =    (void const   *)(& apr_thread_mutex_pool_get);
void const   *ap_hack_apr_threadattr_create  =    (void const   *)(& apr_threadattr_create);
void const   *ap_hack_apr_threadattr_detach_set  =    (void const   *)(& apr_threadattr_detach_set);
void const   *ap_hack_apr_threadattr_detach_get  =    (void const   *)(& apr_threadattr_detach_get);
void const   *ap_hack_apr_thread_create  =    (void const   *)(& apr_thread_create);
void const   *ap_hack_apr_thread_exit  =    (void const   *)(& apr_thread_exit);
void const   *ap_hack_apr_thread_join  =    (void const   *)(& apr_thread_join);
void const   *ap_hack_apr_thread_yield  =    (void const   *)(& apr_thread_yield);
void const   *ap_hack_apr_thread_once_init  =    (void const   *)(& apr_thread_once_init);
void const   *ap_hack_apr_thread_once  =    (void const   *)(& apr_thread_once);
void const   *ap_hack_apr_thread_detach  =    (void const   *)(& apr_thread_detach);
void const   *ap_hack_apr_thread_data_get  =    (void const   *)(& apr_thread_data_get);
void const   *ap_hack_apr_thread_data_set  =    (void const   *)(& apr_thread_data_set);
void const   *ap_hack_apr_threadkey_private_create  =    (void const   *)(& apr_threadkey_private_create);
void const   *ap_hack_apr_threadkey_private_get  =    (void const   *)(& apr_threadkey_private_get);
void const   *ap_hack_apr_threadkey_private_set  =    (void const   *)(& apr_threadkey_private_set);
void const   *ap_hack_apr_threadkey_private_delete  =    (void const   *)(& apr_threadkey_private_delete);
void const   *ap_hack_apr_threadkey_data_get  =    (void const   *)(& apr_threadkey_data_get);
void const   *ap_hack_apr_threadkey_data_set  =    (void const   *)(& apr_threadkey_data_set);
void const   *ap_hack_apr_procattr_create  =    (void const   *)(& apr_procattr_create);
void const   *ap_hack_apr_procattr_io_set  =    (void const   *)(& apr_procattr_io_set);
void const   *ap_hack_apr_procattr_child_in_set  =    (void const   *)(& apr_procattr_child_in_set);
void const   *ap_hack_apr_procattr_child_out_set  =    (void const   *)(& apr_procattr_child_out_set);
void const   *ap_hack_apr_procattr_child_err_set  =    (void const   *)(& apr_procattr_child_err_set);
void const   *ap_hack_apr_procattr_dir_set  =    (void const   *)(& apr_procattr_dir_set);
void const   *ap_hack_apr_procattr_cmdtype_set  =    (void const   *)(& apr_procattr_cmdtype_set);
void const   *ap_hack_apr_procattr_detach_set  =    (void const   *)(& apr_procattr_detach_set);
void const   *ap_hack_apr_procattr_limit_set  =    (void const   *)(& apr_procattr_limit_set);
void const   *ap_hack_apr_proc_fork  =    (void const   *)(& apr_proc_fork);
void const   *ap_hack_apr_proc_create  =    (void const   *)(& apr_proc_create);
void const   *ap_hack_apr_proc_wait  =    (void const   *)(& apr_proc_wait);
void const   *ap_hack_apr_proc_wait_all_procs  =    (void const   *)(& apr_proc_wait_all_procs);
void const   *ap_hack_apr_proc_detach  =    (void const   *)(& apr_proc_detach);
void const   *ap_hack_apr_proc_other_child_register  =    (void const   *)(& apr_proc_other_child_register);
void const   *ap_hack_apr_proc_other_child_unregister  =    (void const   *)(& apr_proc_other_child_unregister);
void const   *ap_hack_apr_proc_other_child_read  =    (void const   *)(& apr_proc_other_child_read);
void const   *ap_hack_apr_proc_other_child_check  =    (void const   *)(& apr_proc_other_child_check);
void const   *ap_hack_apr_proc_kill  =    (void const   *)(& apr_proc_kill);
void const   *ap_hack_apr_pool_note_subprocess  =    (void const   *)(& apr_pool_note_subprocess);
void const   *ap_hack_apr_setup_signal_thread  =    (void const   *)(& apr_setup_signal_thread);
void const   *ap_hack_apr_signal_thread  =    (void const   *)(& apr_signal_thread);
void const   *ap_hack_apr_thread_pool_get  =    (void const   *)(& apr_thread_pool_get);
void const   *ap_hack_apr_thread_rwlock_create  =    (void const   *)(& apr_thread_rwlock_create);
void const   *ap_hack_apr_thread_rwlock_rdlock  =    (void const   *)(& apr_thread_rwlock_rdlock);
void const   *ap_hack_apr_thread_rwlock_tryrdlock  =    (void const   *)(& apr_thread_rwlock_tryrdlock);
void const   *ap_hack_apr_thread_rwlock_wrlock  =    (void const   *)(& apr_thread_rwlock_wrlock);
void const   *ap_hack_apr_thread_rwlock_trywrlock  =    (void const   *)(& apr_thread_rwlock_trywrlock);
void const   *ap_hack_apr_thread_rwlock_unlock  =    (void const   *)(& apr_thread_rwlock_unlock);
void const   *ap_hack_apr_thread_rwlock_destroy  =    (void const   *)(& apr_thread_rwlock_destroy);
void const   *ap_hack_apr_thread_rwlock_pool_get  =    (void const   *)(& apr_thread_rwlock_pool_get);
void const   *ap_hack_apr_time_now  =    (void const   *)(& apr_time_now);
void const   *ap_hack_apr_time_ansi_put  =    (void const   *)(& apr_time_ansi_put);
void const   *ap_hack_apr_time_exp_tz  =    (void const   *)(& apr_time_exp_tz);
void const   *ap_hack_apr_explode_time  =    (void const   *)(& apr_explode_time);
void const   *ap_hack_apr_time_exp_gmt  =    (void const   *)(& apr_time_exp_gmt);
void const   *ap_hack_apr_time_exp_lt  =    (void const   *)(& apr_time_exp_lt);
void const   *ap_hack_apr_explode_localtime  =    (void const   *)(& apr_explode_localtime);
void const   *ap_hack_apr_time_exp_get  =    (void const   *)(& apr_time_exp_get);
void const   *ap_hack_apr_time_exp_gmt_get  =    (void const   *)(& apr_time_exp_gmt_get);
void const   *ap_hack_apr_implode_gmt  =    (void const   *)(& apr_implode_gmt);
void const   *ap_hack_apr_sleep  =    (void const   *)(& apr_sleep);
void const   *ap_hack_apr_rfc822_date  =    (void const   *)(& apr_rfc822_date);
void const   *ap_hack_apr_ctime  =    (void const   *)(& apr_ctime);
void const   *ap_hack_apr_strftime  =    (void const   *)(& apr_strftime);
void const   *ap_hack_apr_time_clock_hires  =    (void const   *)(& apr_time_clock_hires);
void const   *ap_hack_apr_uid_current  =    (void const   *)(& apr_uid_current);
void const   *ap_hack_apr_current_userid  =    (void const   *)(& apr_current_userid);
void const   *ap_hack_apr_uid_name_get  =    (void const   *)(& apr_uid_name_get);
void const   *ap_hack_apr_get_username  =    (void const   *)(& apr_get_username);
void const   *ap_hack_apr_uid_get  =    (void const   *)(& apr_uid_get);
void const   *ap_hack_apr_get_userid  =    (void const   *)(& apr_get_userid);
void const   *ap_hack_apr_uid_homepath_get  =    (void const   *)(& apr_uid_homepath_get);
void const   *ap_hack_apr_get_home_directory  =    (void const   *)(& apr_get_home_directory);
void const   *ap_hack_apr_gid_name_get  =    (void const   *)(& apr_gid_name_get);
void const   *ap_hack_apr_group_name_get  =    (void const   *)(& apr_group_name_get);
void const   *ap_hack_apr_get_groupname  =    (void const   *)(& apr_get_groupname);
void const   *ap_hack_apr_gid_get  =    (void const   *)(& apr_gid_get);
void const   *ap_hack_apr_get_groupid  =    (void const   *)(& apr_get_groupid);
void const   *ap_hack_apr_version  =    (void const   *)(& apr_version);
void const   *ap_hack_apr_version_string  =    (void const   *)(& apr_version_string);
void const   *ap_hack_apr_base64_encode_len  =    (void const   *)(& apr_base64_encode_len);
void const   *ap_hack_apr_base64_encode  =    (void const   *)(& apr_base64_encode);
void const   *ap_hack_apr_base64_encode_binary  =    (void const   *)(& apr_base64_encode_binary);
void const   *ap_hack_apr_base64_decode_len  =    (void const   *)(& apr_base64_decode_len);
void const   *ap_hack_apr_base64_decode  =    (void const   *)(& apr_base64_decode);
void const   *ap_hack_apr_base64_decode_binary  =    (void const   *)(& apr_base64_decode_binary);
void const   *ap_hack_apr_brigade_create  =    (void const   *)(& apr_brigade_create);
void const   *ap_hack_apr_brigade_destroy  =    (void const   *)(& apr_brigade_destroy);
void const   *ap_hack_apr_brigade_cleanup  =    (void const   *)(& apr_brigade_cleanup);
void const   *ap_hack_apr_brigade_split  =    (void const   *)(& apr_brigade_split);
void const   *ap_hack_apr_brigade_partition  =    (void const   *)(& apr_brigade_partition);
void const   *ap_hack_apr_brigade_length  =    (void const   *)(& apr_brigade_length);
void const   *ap_hack_apr_brigade_flatten  =    (void const   *)(& apr_brigade_flatten);
void const   *ap_hack_apr_brigade_pflatten  =    (void const   *)(& apr_brigade_pflatten);
void const   *ap_hack_apr_brigade_split_line  =    (void const   *)(& apr_brigade_split_line);
void const   *ap_hack_apr_brigade_to_iovec  =    (void const   *)(& apr_brigade_to_iovec);
void const   *ap_hack_apr_brigade_vputstrs  =    (void const   *)(& apr_brigade_vputstrs);
void const   *ap_hack_apr_brigade_write  =    (void const   *)(& apr_brigade_write);
void const   *ap_hack_apr_brigade_writev  =    (void const   *)(& apr_brigade_writev);
void const   *ap_hack_apr_brigade_puts  =    (void const   *)(& apr_brigade_puts);
void const   *ap_hack_apr_brigade_putc  =    (void const   *)(& apr_brigade_putc);
void const   *ap_hack_apr_brigade_putstrs  =    (void const   *)(& apr_brigade_putstrs);
void const   *ap_hack_apr_brigade_printf  =    (void const   *)(& apr_brigade_printf);
void const   *ap_hack_apr_brigade_vprintf  =    (void const   *)(& apr_brigade_vprintf);
void const   *ap_hack_apr_bucket_alloc_create  =    (void const   *)(& apr_bucket_alloc_create);
void const   *ap_hack_apr_bucket_alloc_destroy  =    (void const   *)(& apr_bucket_alloc_destroy);
void const   *ap_hack_apr_bucket_alloc  =    (void const   *)(& apr_bucket_alloc);
void const   *ap_hack_apr_bucket_free  =    (void const   *)(& apr_bucket_free);
void const   *ap_hack_apr_bucket_setaside_noop  =    (void const   *)(& apr_bucket_setaside_noop);
void const   *ap_hack_apr_bucket_setaside_notimpl  =    (void const   *)(& apr_bucket_setaside_notimpl);
void const   *ap_hack_apr_bucket_split_notimpl  =    (void const   *)(& apr_bucket_split_notimpl);
void const   *ap_hack_apr_bucket_copy_notimpl  =    (void const   *)(& apr_bucket_copy_notimpl);
void const   *ap_hack_apr_bucket_destroy_noop  =    (void const   *)(& apr_bucket_destroy_noop);
void const   *ap_hack_apr_bucket_simple_split  =    (void const   *)(& apr_bucket_simple_split);
void const   *ap_hack_apr_bucket_simple_copy  =    (void const   *)(& apr_bucket_simple_copy);
void const   *ap_hack_apr_bucket_shared_make  =    (void const   *)(& apr_bucket_shared_make);
void const   *ap_hack_apr_bucket_shared_destroy  =    (void const   *)(& apr_bucket_shared_destroy);
void const   *ap_hack_apr_bucket_shared_split  =    (void const   *)(& apr_bucket_shared_split);
void const   *ap_hack_apr_bucket_shared_copy  =    (void const   *)(& apr_bucket_shared_copy);
void const   *ap_hack_apr_bucket_eos_create  =    (void const   *)(& apr_bucket_eos_create);
void const   *ap_hack_apr_bucket_eos_make  =    (void const   *)(& apr_bucket_eos_make);
void const   *ap_hack_apr_bucket_flush_create  =    (void const   *)(& apr_bucket_flush_create);
void const   *ap_hack_apr_bucket_flush_make  =    (void const   *)(& apr_bucket_flush_make);
void const   *ap_hack_apr_bucket_immortal_create  =    (void const   *)(& apr_bucket_immortal_create);
void const   *ap_hack_apr_bucket_immortal_make  =    (void const   *)(& apr_bucket_immortal_make);
void const   *ap_hack_apr_bucket_transient_create  =    (void const   *)(& apr_bucket_transient_create);
void const   *ap_hack_apr_bucket_transient_make  =    (void const   *)(& apr_bucket_transient_make);
void const   *ap_hack_apr_bucket_heap_create  =    (void const   *)(& apr_bucket_heap_create);
void const   *ap_hack_apr_bucket_heap_make  =    (void const   *)(& apr_bucket_heap_make);
void const   *ap_hack_apr_bucket_pool_create  =    (void const   *)(& apr_bucket_pool_create);
void const   *ap_hack_apr_bucket_pool_make  =    (void const   *)(& apr_bucket_pool_make);
void const   *ap_hack_apr_bucket_mmap_create  =    (void const   *)(& apr_bucket_mmap_create);
void const   *ap_hack_apr_bucket_mmap_make  =    (void const   *)(& apr_bucket_mmap_make);
void const   *ap_hack_apr_bucket_socket_create  =    (void const   *)(& apr_bucket_socket_create);
void const   *ap_hack_apr_bucket_socket_make  =    (void const   *)(& apr_bucket_socket_make);
void const   *ap_hack_apr_bucket_pipe_create  =    (void const   *)(& apr_bucket_pipe_create);
void const   *ap_hack_apr_bucket_pipe_make  =    (void const   *)(& apr_bucket_pipe_make);
void const   *ap_hack_apr_bucket_file_create  =    (void const   *)(& apr_bucket_file_create);
void const   *ap_hack_apr_bucket_file_make  =    (void const   *)(& apr_bucket_file_make);
void const   *ap_hack_apr_bucket_file_enable_mmap  =    (void const   *)(& apr_bucket_file_enable_mmap);
void const   *ap_hack_apr_date_checkmask  =    (void const   *)(& apr_date_checkmask);
void const   *ap_hack_apr_date_parse_http  =    (void const   *)(& apr_date_parse_http);
void const   *ap_hack_apr_date_parse_rfc  =    (void const   *)(& apr_date_parse_rfc);
void const   *ap_hack_apr_dbm_open_ex  =    (void const   *)(& apr_dbm_open_ex);
void const   *ap_hack_apr_dbm_open  =    (void const   *)(& apr_dbm_open);
void const   *ap_hack_apr_dbm_close  =    (void const   *)(& apr_dbm_close);
void const   *ap_hack_apr_dbm_fetch  =    (void const   *)(& apr_dbm_fetch);
void const   *ap_hack_apr_dbm_store  =    (void const   *)(& apr_dbm_store);
void const   *ap_hack_apr_dbm_delete  =    (void const   *)(& apr_dbm_delete);
void const   *ap_hack_apr_dbm_exists  =    (void const   *)(& apr_dbm_exists);
void const   *ap_hack_apr_dbm_firstkey  =    (void const   *)(& apr_dbm_firstkey);
void const   *ap_hack_apr_dbm_nextkey  =    (void const   *)(& apr_dbm_nextkey);
void const   *ap_hack_apr_dbm_freedatum  =    (void const   *)(& apr_dbm_freedatum);
void const   *ap_hack_apr_dbm_geterror  =    (void const   *)(& apr_dbm_geterror);
void const   *ap_hack_apr_dbm_get_usednames_ex  =    (void const   *)(& apr_dbm_get_usednames_ex);
void const   *ap_hack_apr_dbm_get_usednames  =    (void const   *)(& apr_dbm_get_usednames);
void const   *ap_hack_apr_hook_sort_register  =    (void const   *)(& apr_hook_sort_register);
void const   *ap_hack_apr_hook_sort_all  =    (void const   *)(& apr_hook_sort_all);
void const   *ap_hack_apr_sort_hooks  =    (void const   *)(& apr_sort_hooks);
void const   *ap_hack_apr_hook_debug_show  =    (void const   *)(& apr_hook_debug_show);
void const   *ap_hack_apr_show_hook  =    (void const   *)(& apr_show_hook);
void const   *ap_hack_apr_hook_deregister_all  =    (void const   *)(& apr_hook_deregister_all);
void const   *ap_hack_apr_md4_init  =    (void const   *)(& apr_md4_init);
void const   *ap_hack_apr_md4_set_xlate  =    (void const   *)(& apr_md4_set_xlate);
void const   *ap_hack_apr_md4_update  =    (void const   *)(& apr_md4_update);
void const   *ap_hack_apr_md4_final  =    (void const   *)(& apr_md4_final);
void const   *ap_hack_apr_md4  =    (void const   *)(& apr_md4);
void const   *ap_hack_apr_md5_init  =    (void const   *)(& apr_md5_init);
void const   *ap_hack_apr_md5_set_xlate  =    (void const   *)(& apr_md5_set_xlate);
void const   *ap_hack_apr_md5_update  =    (void const   *)(& apr_md5_update);
void const   *ap_hack_apr_md5_final  =    (void const   *)(& apr_md5_final);
void const   *ap_hack_apr_md5  =    (void const   *)(& apr_md5);
void const   *ap_hack_apr_md5_encode  =    (void const   *)(& apr_md5_encode);
void const   *ap_hack_apr_password_validate  =    (void const   *)(& apr_password_validate);
void const   *ap_hack_apr_dynamic_fn_register  =    (void const   *)(& apr_dynamic_fn_register);
void const   *ap_hack_apr_register_optional_fn  =    (void const   *)(& apr_register_optional_fn);
void const   *ap_hack_apr_dynamic_fn_retrieve  =    (void const   *)(& apr_dynamic_fn_retrieve);
void const   *ap_hack_apr_retrieve_optional_fn  =    (void const   *)(& apr_retrieve_optional_fn);
void const   *ap_hack_apr_optional_hook_add  =    (void const   *)(& apr_optional_hook_add);
void const   *ap_hack_apr_optional_hook_get  =    (void const   *)(& apr_optional_hook_get);
void const   *ap_hack_apr_queue_create  =    (void const   *)(& apr_queue_create);
void const   *ap_hack_apr_queue_push  =    (void const   *)(& apr_queue_push);
void const   *ap_hack_apr_queue_pop  =    (void const   *)(& apr_queue_pop);
void const   *ap_hack_apr_queue_trypush  =    (void const   *)(& apr_queue_trypush);
void const   *ap_hack_apr_queue_trypop  =    (void const   *)(& apr_queue_trypop);
void const   *ap_hack_apr_queue_size  =    (void const   *)(& apr_queue_size);
void const   *ap_hack_apr_queue_interrupt_all  =    (void const   *)(& apr_queue_interrupt_all);
void const   *ap_hack_apr_queue_term  =    (void const   *)(& apr_queue_term);
void const   *ap_hack_apr_reslist_create  =    (void const   *)(& apr_reslist_create);
void const   *ap_hack_apr_reslist_destroy  =    (void const   *)(& apr_reslist_destroy);
void const   *ap_hack_apr_reslist_acquire  =    (void const   *)(& apr_reslist_acquire);
void const   *ap_hack_apr_reslist_release  =    (void const   *)(& apr_reslist_release);
void const   *ap_hack_apr_rmm_init  =    (void const   *)(& apr_rmm_init);
void const   *ap_hack_apr_rmm_destroy  =    (void const   *)(& apr_rmm_destroy);
void const   *ap_hack_apr_rmm_attach  =    (void const   *)(& apr_rmm_attach);
void const   *ap_hack_apr_rmm_detach  =    (void const   *)(& apr_rmm_detach);
void const   *ap_hack_apr_rmm_malloc  =    (void const   *)(& apr_rmm_malloc);
void const   *ap_hack_apr_rmm_realloc  =    (void const   *)(& apr_rmm_realloc);
void const   *ap_hack_apr_rmm_calloc  =    (void const   *)(& apr_rmm_calloc);
void const   *ap_hack_apr_rmm_free  =    (void const   *)(& apr_rmm_free);
void const   *ap_hack_apr_rmm_addr_get  =    (void const   *)(& apr_rmm_addr_get);
void const   *ap_hack_apr_rmm_offset_get  =    (void const   *)(& apr_rmm_offset_get);
void const   *ap_hack_apr_rmm_overhead_get  =    (void const   *)(& apr_rmm_overhead_get);
void const   *ap_hack_apr_sdbm_open  =    (void const   *)(& apr_sdbm_open);
void const   *ap_hack_apr_sdbm_close  =    (void const   *)(& apr_sdbm_close);
void const   *ap_hack_apr_sdbm_lock  =    (void const   *)(& apr_sdbm_lock);
void const   *ap_hack_apr_sdbm_unlock  =    (void const   *)(& apr_sdbm_unlock);
void const   *ap_hack_apr_sdbm_fetch  =    (void const   *)(& apr_sdbm_fetch);
void const   *ap_hack_apr_sdbm_store  =    (void const   *)(& apr_sdbm_store);
void const   *ap_hack_apr_sdbm_delete  =    (void const   *)(& apr_sdbm_delete);
void const   *ap_hack_apr_sdbm_firstkey  =    (void const   *)(& apr_sdbm_firstkey);
void const   *ap_hack_apr_sdbm_nextkey  =    (void const   *)(& apr_sdbm_nextkey);
void const   *ap_hack_apr_sdbm_rdonly  =    (void const   *)(& apr_sdbm_rdonly);
void const   *ap_hack_apr_sha1_base64  =    (void const   *)(& apr_sha1_base64);
void const   *ap_hack_apr_sha1_init  =    (void const   *)(& apr_sha1_init);
void const   *ap_hack_apr_sha1_update  =    (void const   *)(& apr_sha1_update);
void const   *ap_hack_apr_sha1_update_binary  =    (void const   *)(& apr_sha1_update_binary);
void const   *ap_hack_apr_sha1_final  =    (void const   *)(& apr_sha1_final);
void const   *ap_hack_apr_strmatch_precompile  =    (void const   *)(& apr_strmatch_precompile);
void const   *ap_hack_apr_uri_port_of_scheme  =    (void const   *)(& apr_uri_port_of_scheme);
void const   *ap_hack_apr_uri_default_port_for_scheme  =    (void const   *)(& apr_uri_default_port_for_scheme);
void const   *ap_hack_apr_uri_unparse  =    (void const   *)(& apr_uri_unparse);
void const   *ap_hack_apr_uri_parse  =    (void const   *)(& apr_uri_parse);
void const   *ap_hack_apr_uri_parse_hostinfo  =    (void const   *)(& apr_uri_parse_hostinfo);
void const   *ap_hack_apr_uuid_get  =    (void const   *)(& apr_uuid_get);
void const   *ap_hack_apr_uuid_format  =    (void const   *)(& apr_uuid_format);
void const   *ap_hack_apr_uuid_parse  =    (void const   *)(& apr_uuid_parse);
void const   *ap_hack_apr_xlate_open  =    (void const   *)(& apr_xlate_open);
void const   *ap_hack_apr_xlate_sb_get  =    (void const   *)(& apr_xlate_sb_get);
void const   *ap_hack_apr_xlate_get_sb  =    (void const   *)(& apr_xlate_get_sb);
void const   *ap_hack_apr_xlate_conv_buffer  =    (void const   *)(& apr_xlate_conv_buffer);
void const   *ap_hack_apr_xlate_conv_byte  =    (void const   *)(& apr_xlate_conv_byte);
void const   *ap_hack_apr_xlate_close  =    (void const   *)(& apr_xlate_close);
void const   *ap_hack_apr_text_append  =    (void const   *)(& apr_text_append);
void const   *ap_hack_apr_xml_parser_create  =    (void const   *)(& apr_xml_parser_create);
void const   *ap_hack_apr_xml_parse_file  =    (void const   *)(& apr_xml_parse_file);
void const   *ap_hack_apr_xml_parser_feed  =    (void const   *)(& apr_xml_parser_feed);
void const   *ap_hack_apr_xml_parser_done  =    (void const   *)(& apr_xml_parser_done);
void const   *ap_hack_apr_xml_parser_geterror  =    (void const   *)(& apr_xml_parser_geterror);
void const   *ap_hack_apr_xml_to_text  =    (void const   *)(& apr_xml_to_text);
void const   *ap_hack_apr_xml_empty_elem  =    (void const   *)(& apr_xml_empty_elem);
void const   *ap_hack_apr_xml_quote_string  =    (void const   *)(& apr_xml_quote_string);
void const   *ap_hack_apr_xml_quote_elem  =    (void const   *)(& apr_xml_quote_elem);
void const   *ap_hack_apr_xml_insert_uri  =    (void const   *)(& apr_xml_insert_uri);
void const   *ap_hack_apu_version  =    (void const   *)(& apu_version);
void const   *ap_hack_apu_version_string  =    (void const   *)(& apu_version_string);
void const   *ap_hack_ap_basic_http_header  =    (void const   *)(& ap_basic_http_header);
void const   *ap_hack_ap_send_http_trace  =    (void const   *)(& ap_send_http_trace);
void const   *ap_hack_ap_send_http_options  =    (void const   *)(& ap_send_http_options);
#pragma merger(0,"/tmp/cil-01yocNAr.i","-g -pthread")
static char const   server_built[21]  = 
  {      (char const   )'M',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'1',      (char const   )'0',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'6',      (char const   )' ', 
        (char const   )'1',      (char const   )'5',      (char const   )':',      (char const   )'4', 
        (char const   )'2',      (char const   )':',      (char const   )'1',      (char const   )'3', 
        (char const   )'\000'};
char const   *ap_get_server_built(void) 
{ 

  {
  return (server_built);
}
}
#pragma merger(0,"/tmp/cil-24GUZnmJ.i","-g -pthread")
extern char *strerror(int __errnum ) ;
extern void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern void free(void *__ptr ) ;
extern clock_t times(struct tms *__buffer ) ;
int ap_create_scoreboard(apr_pool_t *p , ap_scoreboard_e sb_type ) ;
void ap_init_scoreboard(void *shared_score ) ;
apr_status_t ap_cleanup_scoreboard(void *d ) ;
void ap_time_process_request(int child_num , int thread_num , int status ) ;
scoreboard *ap_scoreboard_image  =    (scoreboard *)((void *)0);
char const   *ap_scoreboard_fname  =    (char const   *)((void *)0);
int ap_extended_status  =    0;
static apr_shm_t *ap_scoreboard_shm  =    (apr_shm_t *)((void *)0);
static struct __anonstruct__hooks_96 _hooks___2  ;
void ap_hook_pre_mpm(ap_HOOK_pre_mpm_t *pf , char const   * const  *aszPre___1 , char const   * const  *aszSucc___2 ,
                     int nOrder ) 
{ ap_LINK_pre_mpm_t *pHook ;

  {
  if (! _hooks___2.link_pre_mpm) {
    _hooks___2.link_pre_mpm = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_pre_mpm_t ));
    apr_hook_sort_register("pre_mpm", & _hooks___2.link_pre_mpm);
  }
  pHook = (ap_LINK_pre_mpm_t *)apr_array_push(_hooks___2.link_pre_mpm);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("pre_mpm", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_pre_mpm(void) 
{ 

  {
  return (_hooks___2.link_pre_mpm);
}
}
int ap_run_pre_mpm(apr_pool_t *p , ap_scoreboard_e sb_type ) 
{ ap_LINK_pre_mpm_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks___2.link_pre_mpm) {
    return (0);
  }
  pHook = (ap_LINK_pre_mpm_t *)(_hooks___2.link_pre_mpm)->elts;
  n = 0;
  while (n < (_hooks___2.link_pre_mpm)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(p, sb_type);
    if (rv != 0) {
      if (rv != -1) {
        return (rv);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    n ++;
  }
  return (0);
}
}
static int server_limit___1  ;
static int thread_limit___0  ;
static apr_size_t scoreboard_size  ;
static apr_status_t ap_cleanup_shared_mem(void *d ) 
{ 

  {
  free((void *)ap_scoreboard_image);
  ap_scoreboard_image = (scoreboard *)((void *)0);
  apr_shm_destroy(ap_scoreboard_shm);
  return (0);
}
}
int ap_calc_scoreboard_size(void) 
{ 

  {
  ap_mpm_query(5, & thread_limit___0);
  ap_mpm_query(4, & server_limit___1);
  scoreboard_size = sizeof(global_score );
  scoreboard_size += sizeof(process_score ) * (unsigned int )server_limit___1;
  scoreboard_size += (sizeof(worker_score ) * (unsigned int )server_limit___1) * (unsigned int )thread_limit___0;
  return ((int )scoreboard_size);
}
}
void ap_init_scoreboard(void *shared_score ) 
{ char *more_storage ;
  int i ;

  {
  ap_calc_scoreboard_size();
  ap_scoreboard_image = (scoreboard *)calloc(1U, sizeof(scoreboard ) + (unsigned int )server_limit___1 *
                                                                       sizeof(worker_score *));
  more_storage = (char *)shared_score;
  ap_scoreboard_image->global = (global_score *)more_storage;
  more_storage += sizeof(global_score );
  ap_scoreboard_image->parent = (process_score *)more_storage;
  more_storage += sizeof(process_score ) * (unsigned int )server_limit___1;
  ap_scoreboard_image->servers = (worker_score **)((char *)ap_scoreboard_image + sizeof(scoreboard ));
  i = 0;
  while (i < server_limit___1) {
    (*(ap_scoreboard_image->servers + i)) = (worker_score *)more_storage;
    more_storage += (unsigned int )thread_limit___0 * sizeof(worker_score );
    i ++;
  }
  if (! ((unsigned int )more_storage == (unsigned int )((char *)shared_score + scoreboard_size))) {
    ap_log_assert("more_storage == (char*)shared_score + scoreboard_size", "scoreboard.c",
                  160);
  }
  (ap_scoreboard_image->global)->server_limit = server_limit___1;
  (ap_scoreboard_image->global)->thread_limit = thread_limit___0;
  return;
}
}
static apr_status_t create_namebased_scoreboard(apr_pool_t *pool , char const   *fname ) 
{ apr_status_t rv ;

  {
  apr_file_remove(fname, pool);
  rv = apr_shm_create(& ap_scoreboard_shm, scoreboard_size, fname, pool);
  if (rv != 0) {
    ap_log_error("scoreboard.c", 181, 2, rv, (server_rec const   *)((void *)0), "unable to create scoreboard (name-based shared memory failure)");
    return (rv);
  }
  return (0);
}
}
static apr_status_t open_scoreboard(apr_pool_t *pconf___0 ) 
{ apr_status_t rv ;
  char *fname ;
  apr_pool_t *global_pool___0 ;
  apr_status_t tmp ;
  apr_status_t tmp___0 ;

  {
  fname = (char *)((void *)0);
  rv = apr_pool_create_ex(& global_pool___0, (apr_pool_t *)((void *)0), (int (*)(int retcode ))((void *)0),
                          (apr_allocator_t *)((void *)0));
  if (rv != 0) {
    ap_log_error("scoreboard.c", 206, 2, rv, (server_rec const   *)((void *)0), "Fatal error: unable to create global pool for use with by the scoreboard");
    return (rv);
  }
  if (ap_scoreboard_fname) {
    fname = ap_server_root_relative(pconf___0, ap_scoreboard_fname);
    if (! fname) {
      ap_log_error("scoreboard.c", 217, 2, 20024, (server_rec const   *)((void *)0),
                   "Fatal error: Invalid Scoreboard path %s", ap_scoreboard_fname);
      return (20024);
    }
    tmp = create_namebased_scoreboard(global_pool___0, (char const   *)fname);
    return (tmp);
  } else {
    rv = apr_shm_create(& ap_scoreboard_shm, scoreboard_size, (char const   *)((void *)0),
                        global_pool___0);
    if (rv != 0) {
      if (rv != 70023) {
        ap_log_error("scoreboard.c", 228, 2, rv, (server_rec const   *)((void *)0),
                     "Unable to create scoreboard (anonymous shared memory failure)");
        return (rv);
      } else {
        goto _L;
      }
    } else {
      _L: 
      if (rv == 70023) {
        ap_scoreboard_fname = "logs/apache_runtime_status";
        fname = ap_server_root_relative(pconf___0, ap_scoreboard_fname);
        tmp___0 = create_namebased_scoreboard(global_pool___0, (char const   *)fname);
        return (tmp___0);
      }
    }
  }
  return (0);
}
}
apr_status_t ap_reopen_scoreboard(apr_pool_t *p , apr_shm_t **shm , int detached ) 
{ apr_size_t tmp ;

  {
  if (! detached) {
    return (0);
  }
  tmp = apr_shm_size_get((apr_shm_t const   *)ap_scoreboard_shm);
  if (tmp < scoreboard_size) {
    ap_log_error("scoreboard.c", 256, 2, 0, (server_rec const   *)((void *)0), "Fatal error: shared scoreboard too small for child!");
    apr_shm_detach(ap_scoreboard_shm);
    ap_scoreboard_shm = (apr_shm_t *)((void *)0);
    return (22);
  }
  if ((*shm)) {
    (*shm) = ap_scoreboard_shm;
  }
  return (0);
}
}
apr_status_t ap_cleanup_scoreboard(void *d ) 
{ 

  {
  if ((unsigned int )ap_scoreboard_image == (unsigned int )((void *)0)) {
    return (0);
  }
  if ((int )(ap_scoreboard_image->global)->sb_type == 2) {
    ap_cleanup_shared_mem((void *)0);
  } else {
    free((void *)ap_scoreboard_image->global);
    free((void *)ap_scoreboard_image);
    ap_scoreboard_image = (scoreboard *)((void *)0);
  }
  return (0);
}
}
int ap_create_scoreboard(apr_pool_t *p , ap_scoreboard_e sb_type ) 
{ int running_gen ;
  int i ;
  apr_status_t rv ;
  void *sb_shared ;
  void *sb_mem ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
  running_gen = 0;
  if (ap_scoreboard_image) {
    running_gen = (ap_scoreboard_image->global)->running_generation;
    (ap_scoreboard_image->global)->restart_time = apr_time_now();
    memset((void *)ap_scoreboard_image->parent, 0, sizeof(process_score ) * (unsigned int )server_limit___1);
    i = 0;
    while (i < server_limit___1) {
      memset((void *)(*(ap_scoreboard_image->servers + i)), 0, sizeof(worker_score ) *
                                                               (unsigned int )thread_limit___0);
      i ++;
    }
    return (0);
  }
  ap_calc_scoreboard_size();
  if ((int )sb_type == 2) {
    rv = open_scoreboard(p);
    if (rv) {
      goto _L;
    } else {
      sb_shared = apr_shm_baseaddr_get((apr_shm_t const   *)ap_scoreboard_shm);
      if (! sb_shared) {
        _L: 
        return (500);
      }
    }
    memset(sb_shared, 0, scoreboard_size);
    ap_init_scoreboard(sb_shared);
  } else {
    tmp = calloc(1U, scoreboard_size);
    sb_mem = tmp;
    if ((unsigned int )sb_mem == (unsigned int )((void *)0)) {
      tmp___0 = __errno_location();
      tmp___1 = strerror((*tmp___0));
      tmp___2 = __errno_location();
      ap_log_error("scoreboard.c", 326, 2, 0, (server_rec const   *)((void *)0), "(%d)%s: cannot allocate scoreboard",
                   (*tmp___2), tmp___1);
      return (500);
    }
    ap_init_scoreboard(sb_mem);
  }
  (ap_scoreboard_image->global)->sb_type = sb_type;
  (ap_scoreboard_image->global)->running_generation = running_gen;
  (ap_scoreboard_image->global)->restart_time = apr_time_now();
  apr_pool_cleanup_register(p, (void const   *)((void *)0), & ap_cleanup_scoreboard,
                            & apr_pool_cleanup_null);
  return (0);
}
}
int ap_exists_scoreboard_image(void) 
{ int tmp ;

  {
  if (ap_scoreboard_image) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
void ap_increment_counts(ap_sb_handle_t *sb , request_rec *r ) 
{ worker_score *ws ;

  {
  ws = (*(ap_scoreboard_image->servers + sb->child_num)) + sb->thread_num;
  times(& ws->times);
  ws->access_count = ws->access_count + 1UL;
  ws->my_access_count = ws->my_access_count + 1UL;
  ws->conn_count = (unsigned short )((int )ws->conn_count + 1);
  ws->bytes_served = ws->bytes_served + r->bytes_sent;
  ws->my_bytes_served = ws->my_bytes_served + r->bytes_sent;
  ws->conn_bytes = ws->conn_bytes + r->bytes_sent;
  return;
}
}
int find_child_by_pid(apr_proc_t *pid ) 
{ int i ;
  int max_daemons_limit ;

  {
  ap_mpm_query(12, & max_daemons_limit);
  i = 0;
  while (i < max_daemons_limit) {
    if ((ap_scoreboard_image->parent + i)->pid == pid->pid) {
      return (i);
    }
    i ++;
  }
  return (-1);
}
}
void ap_create_sb_handle(ap_sb_handle_t **new_sbh , apr_pool_t *p , int child_num ,
                         int thread_num ) 
{ 

  {
  (*new_sbh) = (ap_sb_handle_t *)apr_palloc(p, sizeof(ap_sb_handle_t ));
  ((*new_sbh))->child_num = child_num;
  ((*new_sbh))->thread_num = thread_num;
  return;
}
}
int ap_update_child_status_from_indexes(int child_num , int thread_num , int status ,
                                        request_rec *r ) 
{ int old_status ;
  worker_score *ws ;
  process_score *ps ;
  conn_rec *c ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
  if (child_num < 0) {
    return (-1);
  }
  ws = (*(ap_scoreboard_image->servers + child_num)) + thread_num;
  old_status = (int )ws->status;
  ws->status = (unsigned char )status;
  ps = ap_scoreboard_image->parent + child_num;
  if (status == 2) {
    if (old_status == 1) {
      ws->thread_num = child_num * thread_limit___0 + thread_num;
      ps->generation = ap_my_generation;
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if (ap_extended_status) {
    ws->last_used = apr_time_now();
    if (status == 2) {
      goto _L___0;
    } else {
      if (status == 0) {
        _L___0: 
        if (status == 0) {
          ws->my_access_count = 0UL;
          ws->my_bytes_served = 0L;
        }
        ws->conn_count = (unsigned short)0;
        ws->conn_bytes = 0L;
      }
    }
    if (r) {
      c = r->connection;
      tmp = ap_get_remote_host(c, (void *)r->per_dir_config, 2, (int *)((void *)0));
      apr_cpystrn(ws->client, tmp, sizeof(ws->client));
      if ((unsigned int )r->the_request == (unsigned int )((void *)0)) {
        apr_cpystrn(ws->request, "NULL", sizeof(ws->request));
      } else {
        if ((unsigned int )r->parsed_uri.password == (unsigned int )((void *)0)) {
          apr_cpystrn(ws->request, (char const   *)r->the_request, sizeof(ws->request));
        } else {
          if (r->assbackwards) {
            tmp___0 = (char const   *)((void *)0);
          } else {
            tmp___0 = " ";
          }
          tmp___1 = apr_uri_unparse(r->pool, (apr_uri_t const   *)(& r->parsed_uri),
                                    4U);
          tmp___2 = apr_pstrcat(r->pool, r->method, " ", tmp___1, tmp___0, r->protocol,
                                (void *)0);
          apr_cpystrn(ws->request, tmp___2, sizeof(ws->request));
        }
      }
      apr_cpystrn(ws->vhost, (char const   *)(r->server)->server_hostname, sizeof(ws->vhost));
    }
  }
  return (old_status);
}
}
int ap_update_child_status(ap_sb_handle_t *sbh , int status , request_rec *r ) 
{ int tmp ;

  {
  tmp = ap_update_child_status_from_indexes(sbh->child_num, sbh->thread_num, status,
                                            r);
  return (tmp);
}
}
void ap_time_process_request(int child_num , int thread_num , int status ) 
{ worker_score *ws ;

  {
  if (child_num < 0) {
    return;
  }
  ws = (*(ap_scoreboard_image->servers + child_num)) + thread_num;
  if (status == 1) {
    ws->start_time = apr_time_now();
  } else {
    if (status == 2) {
      ws->stop_time = apr_time_now();
    }
  }
  return;
}
}
worker_score *ap_get_scoreboard_worker(int x , int y ) 
{ 

  {
  if (x < 0) {
    goto _L___1;
  } else {
    if (server_limit___1 < x) {
      _L___1: 
      goto _L___0;
    } else {
      if (y < 0) {
        goto _L___0;
      } else {
        if (thread_limit___0 < y) {
          _L___0: 
          return ((worker_score *)((void *)0));
        }
      }
    }
  }
  return ((*(ap_scoreboard_image->servers + x)) + y);
}
}
process_score *ap_get_scoreboard_process(int x ) 
{ 

  {
  if (x < 0) {
    goto _L;
  } else {
    if (server_limit___1 < x) {
      _L: 
      return ((process_score *)((void *)0));
    }
  }
  return (ap_scoreboard_image->parent + x);
}
}
global_score *ap_get_scoreboard_global(void) 
{ 

  {
  return (ap_scoreboard_image->global);
}
}
#pragma merger(0,"/tmp/cil-A3L45X75.i","-g -pthread")
static apr_status_t error_bucket_read(apr_bucket *b , char const   **str , apr_size_t *len ,
                                      apr_read_type_e block ) 
{ 

  {
  (*str) = (char const   *)((void *)0);
  (*len) = 0U;
  return (0);
}
}
static void error_bucket_destroy(void *data ) 
{ ap_bucket_error *h ;
  int tmp ;

  {
  h = (ap_bucket_error *)data;
  tmp = apr_bucket_shared_destroy((void *)h);
  if (tmp) {
    apr_bucket_free((void *)h);
  }
  return;
}
}
apr_bucket *ap_bucket_error_make(apr_bucket *b , int error , char const   *buf , apr_pool_t *p ) 
{ ap_bucket_error *h ;

  {
  h = (ap_bucket_error *)apr_bucket_alloc(sizeof((*h)), b->list);
  h->status = error;
  if (buf) {
    h->data = apr_pstrdup(p, buf);
  } else {
    h->data = (char const   *)((void *)0);
  }
  b = apr_bucket_shared_make(b, (void *)h, 0L, 0U);
  b->type = & ap_bucket_type_error;
  return (b);
}
}
apr_bucket *ap_bucket_error_create(int error , char const   *buf , apr_pool_t *p ,
                                   apr_bucket_alloc_t *list ) 
{ apr_bucket *b ;
  apr_bucket *tmp ;
  apr_bucket *tmp___0 ;

  {
  tmp = (apr_bucket *)apr_bucket_alloc(sizeof((*b)), list);
  b = tmp;
  while (1) {
    b->link.next = b;
    b->link.prev = b;
    break;
  }
  b->free = & apr_bucket_free;
  b->list = list;
  tmp___0 = ap_bucket_error_make(b, error, buf, p);
  return (tmp___0);
}
}
struct apr_bucket_type_t  const  ap_bucket_type_error  = 
     {"ERROR", 5, (enum __anonenum_is_metadata_61 )1, & error_bucket_destroy, & error_bucket_read,
    & apr_bucket_setaside_notimpl, & apr_bucket_split_notimpl, & apr_bucket_shared_copy};
#pragma merger(0,"/tmp/cil-6U0ElF2L.i","-g -pthread")
ap_filter_rec_t *ap_old_write_func ;
void ap_set_sub_req_protocol(request_rec *rnew , request_rec const   *r ) ;
void ap_finalize_sub_req_protocol(request_rec *sub ) ;
static struct __anonstruct__hooks_98 _hooks___3  ;
ap_filter_rec_t *ap_old_write_func  =    (ap_filter_rec_t *)((void *)0);
static char const   *needcset[3]  = {      "text/plain",      "text/html",      (char const   *)((void *)0)};
static apr_strmatch_pattern const   **needcset_patterns  ;
static apr_strmatch_pattern const   *charset_pattern  ;
void ap_setup_make_content_type(apr_pool_t *pool ) 
{ int i ;

  {
  i = 0;
  while (needcset[i]) {
    goto __Cont;
    __Cont: 
    i ++;
  }
  needcset_patterns = (apr_strmatch_pattern const   **)apr_palloc(pool, (unsigned int )(i +
                                                                                        1) *
                                                                        sizeof(apr_strmatch_pattern *));
  i = 0;
  while (needcset[i]) {
    (*(needcset_patterns + i)) = apr_strmatch_precompile(pool, needcset[i], 0);
    i ++;
  }
  (*(needcset_patterns + i)) = (apr_strmatch_pattern const   *)((void *)0);
  charset_pattern = apr_strmatch_precompile(pool, "charset=", 0);
  return;
}
}
char const   *ap_make_content_type(request_rec *r , char const   *type ) 
{ apr_strmatch_pattern const   **pcset ;
  core_dir_config *conf ;
  apr_size_t type_len ;
  struct iovec concat[3] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  conf = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  if (! type) {
    type = ap_default_type(r);
  }
  if (conf->add_default_charset != 1U) {
    return (type);
  }
  type_len = strlen(type);
  tmp___0 = ((*(charset_pattern->compare)))(charset_pattern, type, type_len);
  if (! ((unsigned int )tmp___0 != (unsigned int )((void *)0))) {
    pcset = needcset_patterns;
    while ((*pcset)) {
      tmp = ((*(((*pcset))->compare)))((*pcset), type, type_len);
      if ((unsigned int )tmp != (unsigned int )((void *)0)) {
        concat[0].iov_base = (void *)type;
        concat[0].iov_len = type_len;
        concat[1].iov_base = (void *)"; charset=";
        concat[1].iov_len = sizeof("; charset=") - 1U;
        concat[2].iov_base = (void *)conf->add_default_charset_name;
        concat[2].iov_len = strlen(conf->add_default_charset_name);
        type = apr_pstrcatv(r->pool, (struct iovec  const  *)(concat), 3U, (apr_size_t *)((void *)0));
        break;
      }
      pcset ++;
    }
  }
  return (type);
}
}
void ap_set_content_length(request_rec *r , apr_off_t clength ) 
{ char const   *tmp ;

  {
  r->clength = clength;
  tmp = apr_off_t_toa(r->pool, clength);
  apr_table_setn(r->headers_out, "Content-Length", tmp);
  return;
}
}
apr_time_t ap_rationalize_mtime(request_rec *r , apr_time_t mtime ) 
{ apr_time_t now ;
  apr_time_t tmp___0 ;

  {
  if (mtime < r->request_time) {
    now = r->request_time;
  } else {
    now = apr_time_now();
  }
  if (mtime > now) {
    tmp___0 = now;
  } else {
    tmp___0 = mtime;
  }
  return (tmp___0);
}
}
apr_status_t ap_rgetline_core(char **s , apr_size_t n , apr_size_t *read___0 , request_rec *r ,
                              int fold , apr_bucket_brigade *bb ) 
{ apr_status_t rv ;
  apr_bucket *e ;
  apr_size_t bytes_handled ;
  apr_size_t current_alloc ;
  char *pos ;
  char *last_char ;
  int do_alloc ;
  int saw_eos ;
  char const   *str ;
  apr_size_t len ;
  apr_size_t new_size ;
  char *new_buffer ;
  apr_size_t next_size ;
  apr_size_t next_len ;
  char *tmp ;
  char *new_buffer___0 ;
  apr_size_t new_size___0 ;
  char const   *str___0 ;
  apr_size_t len___0 ;
  char c ;
  apr_size_t next_size___0 ;
  apr_size_t next_len___0 ;
  char *tmp___0 ;
  char *new_buffer___1 ;
  apr_size_t new_size___1 ;

  {
  bytes_handled = 0U;
  current_alloc = 0U;
  last_char = (*s);
  do_alloc = (unsigned int )(*s) == (unsigned int )((void *)0);
  saw_eos = 0;
  apr_brigade_cleanup((void *)bb);
  rv = ap_get_brigade(r->input_filters, bb, (enum __anonenum_ap_input_mode_t_70 )1,
                      (enum __anonenum_apr_read_type_e_60 )0, 0L);
  if (rv != 0) {
    return (rv);
  }
  if ((unsigned int )bb->list.next == (unsigned int )((struct apr_bucket *)((char *)(& bb->list) -
                                                                            (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                    (char *)((void *)0))))) {
    return (20014);
  }
  e = bb->list.next;
  while ((unsigned int )e != (unsigned int )((struct apr_bucket *)((char *)(& bb->list) -
                                                                   (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                           (char *)((void *)0))))) {
    if ((unsigned int )e->type == (unsigned int )(& apr_bucket_type_eos)) {
      saw_eos = 1;
      break;
    }
    rv = ((*((e->type)->read)))(e, & str, & len, (enum __anonenum_apr_read_type_e_60 )0);
    if (rv != 0) {
      return (rv);
    }
    if (len == 0U) {
      goto __Cont;
    }
    if (n < bytes_handled + len) {
      return (28);
    }
    if (do_alloc) {
      if (! (*s)) {
        current_alloc = len;
        if (current_alloc < 80U) {
          current_alloc = 80U;
        }
        (*s) = (char *)apr_palloc(r->pool, current_alloc);
      } else {
        if (bytes_handled + len > current_alloc) {
          new_size = current_alloc * 2U;
          if (bytes_handled + len > new_size) {
            new_size = (bytes_handled + len) * 2U;
          }
          new_buffer = (char *)apr_palloc(r->pool, new_size);
          memcpy((void * __restrict  )new_buffer, (void const   * __restrict  )(*s),
                 bytes_handled);
          current_alloc = new_size;
          (*s) = new_buffer;
        }
      }
    }
    pos = (*s) + bytes_handled;
    memcpy((void * __restrict  )pos, (void const   * __restrict  )str, len);
    last_char = (pos + len) - 1;
    bytes_handled += len;
    __Cont: 
    e = e->link.next;
  }
  if (bytes_handled == 0U) {
    (*read___0) = 0U;
    return (0);
  }
  if ((int )(*last_char) != 10) {
    if (bytes_handled < n) {
      if (do_alloc) {
        tmp = (char *)((void *)0);
      } else {
        tmp = last_char + 1;
      }
      next_size = n - bytes_handled;
      rv = ap_rgetline_core(& tmp, next_size, & next_len, r, fold, bb);
      if (rv != 0) {
        return (rv);
      }
      if (do_alloc) {
        if (next_len > 0U) {
          new_size___0 = bytes_handled + next_len;
          new_buffer___0 = (char *)apr_palloc(r->pool, new_size___0);
          memcpy((void * __restrict  )new_buffer___0, (void const   * __restrict  )(*s),
                 bytes_handled);
          memcpy((void * __restrict  )(new_buffer___0 + bytes_handled), (void const   * __restrict  )tmp,
                 next_len);
          current_alloc = new_size___0;
          (*s) = new_buffer___0;
        } else {
          goto _L;
        }
      } else {
        _L: ;
      }
      bytes_handled += next_len;
      last_char = ((*s) + bytes_handled) - 1;
    } else {
      return (28);
    }
  }
  pos = last_char;
  if ((unsigned int )pos > (unsigned int )(*s)) {
    if ((int )(*(pos - 1)) == 13) {
      pos --;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
  }
  while (1) {
    if ((unsigned int )pos > (unsigned int )((*s) + 1)) {
      if ((int )(*(pos - 1)) == 32) {
        goto _L___2;
      } else {
        if ((int )(*(pos - 1)) == 9) {
          _L___2: ;
        } else {
          goto _L___1;
        }
      }
    } else {
      _L___1: 
      break;
    }
    pos --;
  }
  (*pos) = (char )'\000';
  last_char = pos;
  bytes_handled = (unsigned int )(pos - (*s));
  if (fold) {
    if (bytes_handled) {
      if (! saw_eos) {
        apr_brigade_cleanup((void *)bb);
        rv = ap_get_brigade(r->input_filters, bb, (enum __anonenum_ap_input_mode_t_70 )3,
                            (enum __anonenum_apr_read_type_e_60 )0, 1L);
        if (rv != 0) {
          return (rv);
        }
        if ((unsigned int )bb->list.next == (unsigned int )((struct apr_bucket *)((char *)(& bb->list) -
                                                                                  (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                          (char *)((void *)0))))) {
          (*read___0) = bytes_handled;
          return (0);
        }
        e = bb->list.next;
        if ((unsigned int )e->type == (unsigned int )(& apr_bucket_type_eos)) {
          (*read___0) = bytes_handled;
          return (0);
        }
        rv = ((*((e->type)->read)))(e, & str___0, & len___0, (enum __anonenum_apr_read_type_e_60 )0);
        if (rv != 0) {
          apr_brigade_destroy(bb);
          return (rv);
        }
        c = (char )(*str___0);
        if ((int )c == 32) {
          goto _L___4;
        } else {
          if ((int )c == 9) {
            _L___4: 
            if (bytes_handled < n) {
              if (do_alloc) {
                tmp___0 = (char *)((void *)0);
              } else {
                tmp___0 = last_char;
              }
              next_size___0 = n - bytes_handled;
              rv = ap_rgetline_core(& tmp___0, next_size___0, & next_len___0, r, fold,
                                    bb);
              if (rv != 0) {
                return (rv);
              }
              if (do_alloc) {
                if (next_len___0 > 0U) {
                  new_size___1 = (bytes_handled + next_len___0) + 1U;
                  new_buffer___1 = (char *)apr_palloc(r->pool, new_size___1);
                  memcpy((void * __restrict  )new_buffer___1, (void const   * __restrict  )(*s),
                         bytes_handled);
                  memcpy((void * __restrict  )(new_buffer___1 + bytes_handled), (void const   * __restrict  )tmp___0,
                         next_len___0 + 1U);
                  (*s) = new_buffer___1;
                } else {
                  goto _L___3;
                }
              } else {
                _L___3: ;
              }
              (*read___0) = bytes_handled + next_len___0;
              return (0);
            } else {
              return (28);
            }
          }
        }
      } else {
        goto _L___6;
      }
    } else {
      goto _L___6;
    }
  } else {
    _L___6: ;
  }
  (*read___0) = bytes_handled;
  return (0);
}
}
int ap_getline(char *s , int n , request_rec *r , int fold ) 
{ char *tmp_s ;
  apr_status_t rv ;
  apr_size_t len ;
  apr_bucket_brigade *tmp_bb ;

  {
  tmp_s = s;
  tmp_bb = apr_brigade_create(r->pool, (r->connection)->bucket_alloc);
  rv = ap_rgetline_core(& tmp_s, (unsigned int )n, & len, r, fold, tmp_bb);
  apr_brigade_destroy(tmp_bb);
  if (rv == 28) {
    return (n);
  }
  if (rv != 0) {
    return (-1);
  }
  return ((int )len);
}
}
void ap_parse_uri(request_rec *r , char const   *uri ) 
{ int status ;
  char const   *tmp ;
  int tmp___0 ;

  {
  status = 200;
  r->unparsed_uri = apr_pstrdup(r->pool, uri);
  if (r->method_number == 4) {
    status = apr_uri_parse_hostinfo(r->pool, uri, & r->parsed_uri);
  } else {
    status = apr_uri_parse(r->pool, uri, & r->parsed_uri);
  }
  if (status == 0) {
    if (r->parsed_uri.scheme) {
      tmp = ap_run_http_method((request_rec const   *)r);
      tmp___0 = strcasecmp((char const   *)r->parsed_uri.scheme, tmp);
      if (tmp___0) {
        goto _L;
      } else {
        r->hostname = (char const   *)r->parsed_uri.hostname;
      }
    } else {
      _L: 
      if (r->method_number == 4) {
        r->hostname = (char const   *)r->parsed_uri.hostname;
      }
    }
    r->args = r->parsed_uri.query;
    if (r->parsed_uri.path) {
      r->uri = r->parsed_uri.path;
    } else {
      r->uri = apr_pstrdup(r->pool, "/");
    }
  } else {
    r->args = (char *)((void *)0);
    r->hostname = (char const   *)((void *)0);
    r->status = 400;
    r->uri = apr_pstrdup(r->pool, uri);
  }
  return;
}
}
static int read_request_line(request_rec *r , apr_bucket_brigade *bb ) 
{ char const   *ll ;
  char const   *uri ;
  char const   *pro ;
  int major ;
  int minor ;
  char http[5] ;
  apr_size_t len ;
  apr_status_t rv ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  major = 1;
  minor = 0;
  while (1) {
    r->the_request = (char *)((void *)0);
    rv = ap_rgetline_core(& r->the_request, 8192U, & len, r, 0, bb);
    if (rv != 0) {
      r->request_time = apr_time_now();
      return (0);
    }
    if (! (len <= 0U)) {
      break;
    }
  }
  r->request_time = apr_time_now();
  ll = (char const   *)r->the_request;
  r->method = ap_getword_white(r->pool, & ll);
  uri = ap_getword_white(r->pool, & ll);
  r->method_number = ap_method_number_of(r->method);
  if (r->method_number == 0) {
    if ((int const   )(*(r->method + 0)) == 72) {
      r->header_only = 1;
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  ap_parse_uri(r, uri);
  if (len > (unsigned int )(r->server)->limit_req_line) {
    r->status = 414;
    r->proto_num = 1000;
    r->protocol = apr_pstrdup(r->pool, "HTTP/1.0");
    return (0);
  }
  if ((*(ll + 0))) {
    r->assbackwards = 0;
    pro = ll;
    len = strlen(ll);
  } else {
    r->assbackwards = 1;
    pro = "HTTP/0.9";
    len = 8U;
  }
  r->protocol = apr_pstrmemdup(r->pool, pro, len);
  if (len == 8U) {
    if ((int const   )(*(pro + 0)) == 72) {
      if ((int const   )(*(pro + 1)) == 84) {
        if ((int const   )(*(pro + 2)) == 84) {
          if ((int const   )(*(pro + 3)) == 80) {
            if ((int const   )(*(pro + 4)) == 47) {
              tmp___1 = __ctype_b_loc();
              if ((int const   )(*((*tmp___1) + (int )((unsigned char )(*(pro + 5))))) &
                  2048) {
                if ((int const   )(*(pro + 6)) == 46) {
                  tmp___2 = __ctype_b_loc();
                  if ((int const   )(*((*tmp___2) + (int )((unsigned char )(*(pro +
                                                                              7))))) &
                      2048) {
                    r->proto_num = 1000 * (int )((int const   )(*(pro + 5)) - 48) +
                                   (int )((int const   )(*(pro + 7)) - 48);
                  } else {
                    goto _L___9;
                  }
                } else {
                  goto _L___9;
                }
              } else {
                goto _L___9;
              }
            } else {
              goto _L___9;
            }
          } else {
            goto _L___9;
          }
        } else {
          goto _L___9;
        }
      } else {
        goto _L___9;
      }
    } else {
      goto _L___9;
    }
  } else {
    _L___9: 
    tmp = sscanf((char const   * __restrict  )r->protocol, (char const   * __restrict  )"%4s/%u.%u",
                 http, & major, & minor);
    if (3 == tmp) {
      tmp___0 = strcasecmp("http", (char const   *)(http));
      if (tmp___0 == 0) {
        if (minor < 1000) {
          r->proto_num = 1000 * major + minor;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      r->proto_num = 1000;
    }
  }
  return (1);
}
}
void ap_get_mime_headers_core(request_rec *r , apr_bucket_brigade *bb ) 
{ char *last_field ;
  apr_size_t last_len ;
  apr_size_t alloc_len ;
  char *field ;
  char *value ;
  apr_size_t len ;
  int fields_read ;
  apr_table_t *tmp_headers ;
  apr_status_t rv ;
  int folded ;
  char *tmp ;
  char const   *tmp___0 ;
  char *fold_buf ;
  char *tmp___2 ;
  char const   *tmp___3 ;

  {
  last_field = (char *)((void *)0);
  last_len = 0U;
  alloc_len = 0U;
  fields_read = 0;
  tmp_headers = apr_table_make(r->pool, 50);
  while (1) {
    folded = 0;
    field = (char *)((void *)0);
    rv = ap_rgetline_core(& field, 8192U, & len, r, 0, bb);
    if (rv == 28) {
      goto _L;
    } else {
      if (rv == 0) {
        if (len > (unsigned int )(r->server)->limit_req_fieldsize) {
          _L: 
          r->status = 400;
          tmp = ap_escape_html(r->pool, (char const   *)field);
          tmp___0 = apr_pstrcat(r->pool, "Size of a request header field exceeds server limit.<br />\n<pre>\n",
                                tmp, "</pre>\n", (void *)0);
          apr_table_setn(r->notes, "error-notes", tmp___0);
          return;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: ;
      }
    }
    if (rv != 0) {
      r->status = 400;
      return;
    }
    if ((unsigned int )last_field != (unsigned int )((void *)0)) {
      if (len > 0U) {
        if ((int )(*field) == 9) {
          goto _L___4;
        } else {
          if ((int )(*field) == 32) {
            _L___4: 
            if (last_len + len > alloc_len) {
              alloc_len += alloc_len;
              if (last_len + len > alloc_len) {
                alloc_len = last_len + len;
              }
              fold_buf = (char *)apr_palloc(r->pool, alloc_len);
              memcpy((void * __restrict  )fold_buf, (void const   * __restrict  )last_field,
                     last_len);
              last_field = fold_buf;
            }
            memcpy((void * __restrict  )(last_field + last_len), (void const   * __restrict  )field,
                   len + 1U);
            last_len += len;
            folded = 1;
          } else {
            goto _L___3;
          }
        }
      } else {
        _L___3: 
        if ((r->server)->limit_req_fields) {
          fields_read ++;
          if (fields_read > (r->server)->limit_req_fields) {
            r->status = 400;
            apr_table_setn(r->notes, "error-notes", "The number of request header fields exceeds this server\'s limit.");
            return;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: ;
        }
        value = strchr((char const   *)last_field, ':');
        if (! value) {
          r->status = 400;
          tmp___2 = ap_escape_html(r->pool, (char const   *)last_field);
          tmp___3 = apr_pstrcat(r->pool, "Request header field is missing \':\' separator.<br />\n<pre>\n",
                                tmp___2, "</pre>\n", (void *)0);
          apr_table_setn(r->notes, "error-notes", tmp___3);
          return;
        }
        (*value) = (char )'\000';
        value ++;
        while (1) {
          if ((int )(*value) == 32) {
            goto _L___2;
          } else {
            if ((int )(*value) == 9) {
              _L___2: ;
            } else {
              break;
            }
          }
          value ++;
        }
        apr_table_addn(tmp_headers, (char const   *)last_field, (char const   *)value);
        alloc_len = 0U;
      }
    }
    if (len == 0U) {
      break;
    }
    if (! folded) {
      last_field = field;
      last_len = len;
    }
  }
  apr_table_overlap(r->headers_in, (apr_table_t const   *)tmp_headers, 1U);
  return;
}
}
void ap_get_mime_headers(request_rec *r ) 
{ apr_bucket_brigade *tmp_bb ;

  {
  tmp_bb = apr_brigade_create(r->pool, (r->connection)->bucket_alloc);
  ap_get_mime_headers_core(r, tmp_bb);
  apr_brigade_destroy(tmp_bb);
  return;
}
}
request_rec *ap_read_request(conn_rec *conn ) 
{ request_rec *r ;
  apr_pool_t *p ;
  char const   *expect ;
  int access_status ;
  apr_bucket_brigade *tmp_bb ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  apr_pool_create_ex(& p, conn->pool, (int (*)(int retcode ))((void *)0), (apr_allocator_t *)((void *)0));
  tmp = apr_palloc(p, sizeof(request_rec ));
  r = (request_rec *)memset(tmp, 0, sizeof(request_rec ));
  r->pool = p;
  r->connection = conn;
  r->server = conn->base_server;
  r->user = (char *)((void *)0);
  r->ap_auth_type = (char *)((void *)0);
  r->allowed_methods = ap_make_method_list(p, 2);
  r->headers_in = apr_table_make(r->pool, 25);
  r->subprocess_env = apr_table_make(r->pool, 25);
  r->headers_out = apr_table_make(r->pool, 12);
  r->err_headers_out = apr_table_make(r->pool, 5);
  r->notes = apr_table_make(r->pool, 5);
  r->request_config = ap_create_request_config(r->pool);
  r->proto_output_filters = conn->output_filters;
  r->output_filters = r->proto_output_filters;
  r->proto_input_filters = conn->input_filters;
  r->input_filters = r->proto_input_filters;
  ap_run_create_request(r);
  r->per_dir_config = (r->server)->lookup_defaults;
  r->sent_bodyct = 0L;
  r->read_length = 0L;
  r->read_body = 0;
  r->status = 408;
  r->the_request = (char *)((void *)0);
  tmp_bb = apr_brigade_create(r->pool, (r->connection)->bucket_alloc);
  tmp___0 = read_request_line(r, tmp_bb);
  if (! tmp___0) {
    if (r->status == 414) {
      ap_log_rerror("protocol.c", 934, 3, 0, (request_rec const   *)r, "request failed: URI too long");
      ap_send_error_response(r, 0);
      ap_run_log_transaction(r);
      apr_brigade_destroy(tmp_bb);
      return (r);
    }
    apr_brigade_destroy(tmp_bb);
    return ((request_rec *)((void *)0));
  }
  if (! r->assbackwards) {
    ap_get_mime_headers_core(r, tmp_bb);
    if (r->status != 408) {
      ap_log_rerror("protocol.c", 949, 3, 0, (request_rec const   *)r, "request failed: error reading the headers");
      ap_send_error_response(r, 0);
      ap_run_log_transaction(r);
      apr_brigade_destroy(tmp_bb);
      return (r);
    }
  } else {
    if (r->header_only) {
      ap_log_rerror("protocol.c", 964, 3, 0, (request_rec const   *)r, "client sent invalid HTTP/0.9 request: HEAD %s",
                    r->uri);
      r->header_only = 0;
      r->status = 400;
      ap_send_error_response(r, 0);
      ap_run_log_transaction(r);
      apr_brigade_destroy(tmp_bb);
      return (r);
    }
  }
  apr_brigade_destroy(tmp_bb);
  r->status = 200;
  ap_update_vhost_from_headers(r);
  r->per_dir_config = (r->server)->lookup_defaults;
  if (! r->hostname) {
    if (r->proto_num >= 1001) {
      goto _L;
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    if (r->proto_num == 1001) {
      tmp___1 = apr_table_get((apr_table_t const   *)r->headers_in, "Host");
      if (tmp___1) {
        goto _L___0;
      } else {
        _L: 
        r->status = 400;
        ap_log_rerror("protocol.c", 999, 3, 0, (request_rec const   *)r, "client sent HTTP/1.1 request without hostname (see RFC2616 section 14.23): %s",
                      r->uri);
      }
    } else {
      _L___0: ;
    }
  }
  if (r->status != 200) {
    ap_send_error_response(r, 0);
    ap_run_log_transaction(r);
    return (r);
  }
  expect = apr_table_get((apr_table_t const   *)r->headers_in, "Expect");
  if ((unsigned int )expect != (unsigned int )((void *)0)) {
    if ((int const   )(*(expect + 0)) != 0) {
      tmp___2 = strcasecmp(expect, "100-continue");
      if (tmp___2 == 0) {
        r->expecting_100 = 1U;
      } else {
        r->status = 417;
        ap_log_rerror("protocol.c", 1023, 6, 0, (request_rec const   *)r, "client sent an unrecognized expectation value of Expect: %s",
                      expect);
        ap_send_error_response(r, 0);
        ap_run_log_transaction(r);
        return (r);
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: ;
  }
  ap_add_input_filter_handle(ap_http_input_filter_handle, (void *)0, r, r->connection);
  access_status = ap_run_post_read_request(r);
  if (access_status) {
    ap_die(access_status, r);
    ap_run_log_transaction(r);
    return ((request_rec *)((void *)0));
  }
  return (r);
}
}
void ap_set_sub_req_protocol(request_rec *rnew , request_rec const   *r ) 
{ 

  {
  rnew->the_request = r->the_request;
  rnew->assbackwards = 1;
  rnew->no_local_copy = 1;
  rnew->method = "GET";
  rnew->method_number = 0;
  rnew->protocol = (char *)"INCLUDED";
  rnew->status = 200;
  rnew->headers_in = r->headers_in;
  rnew->subprocess_env = apr_table_copy(rnew->pool, (apr_table_t const   *)r->subprocess_env);
  rnew->headers_out = apr_table_make(rnew->pool, 5);
  rnew->err_headers_out = apr_table_make(rnew->pool, 5);
  rnew->notes = apr_table_make(rnew->pool, 5);
  rnew->expecting_100 = r->expecting_100;
  rnew->read_length = r->read_length;
  rnew->read_body = 0;
  rnew->main = (request_rec *)r;
  return;
}
}
static void end_output_stream(request_rec *r ) 
{ conn_rec *c ;
  apr_bucket_brigade *bb ;
  apr_bucket *b ;
  apr_bucket *ap__b ;

  {
  c = r->connection;
  bb = apr_brigade_create(r->pool, c->bucket_alloc);
  b = apr_bucket_eos_create(c->bucket_alloc);
  while (1) {
    ap__b = b;
    while (1) {
      ap__b->link.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                              (char *)((void *)0)));
      ap__b->link.prev = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                               (char *)((void *)0))))->link.prev;
      (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                             (char *)((void *)0))))->link.prev)->link.next = ap__b;
      ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                            (char *)((void *)0))))->link.prev = ap__b;
      break;
    }
    break;
  }
  ap_pass_brigade(r->output_filters, bb);
  return;
}
}
void ap_finalize_sub_req_protocol(request_rec *sub ) 
{ 

  {
  if (! sub->eos_sent) {
    end_output_stream(sub);
  }
  return;
}
}
void ap_finalize_request_protocol(request_rec *r ) 
{ 

  {
  ap_discard_request_body(r);
  if (! r->eos_sent) {
    end_output_stream(r);
  }
  return;
}
}
void ap_note_auth_failure(request_rec *r ) 
{ char const   *type ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = ap_auth_type(r);
  type = tmp;
  if (type) {
    tmp___1 = strcasecmp(type, "Basic");
    if (tmp___1) {
      tmp___0 = strcasecmp(type, "Digest");
      if (! tmp___0) {
        ap_note_digest_auth_failure(r);
      }
    } else {
      ap_note_basic_auth_failure(r);
    }
  } else {
    ap_log_rerror("protocol.c", 1125, 3, 0, (request_rec const   *)r, "need AuthType to note auth failure: %s",
                  r->uri);
  }
  return;
}
}
void ap_note_basic_auth_failure(request_rec *r ) 
{ char const   *type ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  tmp = ap_auth_type(r);
  type = tmp;
  if (! type) {
    goto _L;
  } else {
    tmp___3 = strcasecmp(type, "Basic");
    if (tmp___3) {
      _L: 
      ap_note_auth_failure(r);
    } else {
      tmp___0 = ap_auth_name(r);
      tmp___1 = apr_pstrcat(r->pool, "Basic realm=\"", tmp___0, "\"", (void *)0);
      if (1 == r->proxyreq) {
        tmp___2 = "Proxy-Authenticate";
      } else {
        tmp___2 = "WWW-Authenticate";
      }
      apr_table_setn(r->err_headers_out, tmp___2, tmp___1);
    }
  }
  return;
}
}
void ap_note_digest_auth_failure(request_rec *r ) 
{ char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  tmp = ap_auth_name(r);
  tmp___0 = apr_psprintf(r->pool, "Digest realm=\"%s\", nonce=\"%llx\"", tmp, r->request_time);
  if (1 == r->proxyreq) {
    tmp___1 = "Proxy-Authenticate";
  } else {
    tmp___1 = "WWW-Authenticate";
  }
  apr_table_setn(r->err_headers_out, tmp___1, tmp___0);
  return;
}
}
int ap_get_basic_auth_pw(request_rec *r , char const   **pw ) 
{ char const   *auth_line ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *t ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
  if (1 == r->proxyreq) {
    tmp = "Proxy-Authorization";
  } else {
    tmp = "Authorization";
  }
  tmp___0 = apr_table_get((apr_table_t const   *)r->headers_in, tmp);
  auth_line = tmp___0;
  t = ap_auth_type(r);
  if (t) {
    tmp___1 = strcasecmp(t, "Basic");
    if (tmp___1) {
      _L: 
      return (-1);
    }
  } else {
    goto _L;
  }
  tmp___2 = ap_auth_name(r);
  if (! tmp___2) {
    ap_log_rerror("protocol.c", 1169, 3, 0, (request_rec const   *)r, "need AuthName: %s",
                  r->uri);
    return (500);
  }
  if (! auth_line) {
    ap_note_basic_auth_failure(r);
    return (401);
  }
  tmp___3 = ap_getword(r->pool, & auth_line, (char )' ');
  tmp___4 = strcasecmp(tmp___3, "Basic");
  if (tmp___4) {
    ap_log_rerror("protocol.c", 1181, 3, 0, (request_rec const   *)r, "client used wrong authentication scheme: %s",
                  r->uri);
    ap_note_basic_auth_failure(r);
    return (401);
  }
  while (1) {
    if ((int const   )(*auth_line) == 32) {
      goto _L___0;
    } else {
      if ((int const   )(*auth_line) == 9) {
        _L___0: ;
      } else {
        break;
      }
    }
    auth_line ++;
  }
  t = ap_pbase64decode(r->pool, auth_line);
  r->user = ap_getword_nulls(r->pool, & t, (char )':');
  r->ap_auth_type = (char *)"Basic";
  (*pw) = t;
  return (0);
}
}
apr_status_t ap_content_length_filter(ap_filter_t *f , apr_bucket_brigade *b ) 
{ request_rec *r ;
  struct content_length_ctx *ctx ;
  apr_bucket *e ;
  int eos ;
  apr_read_type_e eblock ;
  apr_size_t len ;
  char const   *ignored ;
  apr_status_t rv ;
  apr_bucket_brigade *split ;
  apr_bucket_brigade *tmp ;
  apr_bucket *flush ;
  apr_bucket *tmp___0 ;
  apr_bucket *ap__b ;
  apr_status_t tmp___1 ;

  {
  r = f->r;
  eos = 0;
  eblock = (enum __anonenum_apr_read_type_e_60 )1;
  ctx = (struct content_length_ctx *)f->ctx;
  if (! ctx) {
    ctx = (struct content_length_ctx *)apr_palloc(r->pool, sizeof((*ctx)));
    f->ctx = (void *)ctx;
    ctx->data_sent = 0;
  }
  e = b->list.next;
  while ((unsigned int )e != (unsigned int )((struct apr_bucket *)((char *)(& b->list) -
                                                                   (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                           (char *)((void *)0))))) {
    if ((unsigned int )e->type == (unsigned int )(& apr_bucket_type_eos)) {
      eos = 1;
      break;
    }
    if (e->length == 4294967295U) {
      rv = ((*((e->type)->read)))(e, & ignored, & len, eblock);
      if (rv == 0) {
        eblock = (enum __anonenum_apr_read_type_e_60 )1;
        r->bytes_sent = (long )((unsigned long )r->bytes_sent + (unsigned long )len);
      } else {
        if (rv == 11) {
          if ((unsigned int )e != (unsigned int )b->list.next) {
            tmp = apr_brigade_split(b, e);
            split = tmp;
            tmp___0 = apr_bucket_flush_create((r->connection)->bucket_alloc);
            flush = tmp___0;
            while (1) {
              ap__b = flush;
              while (1) {
                ap__b->link.next = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0)));
                ap__b->link.prev = ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                        (char *)((void *)0))))->link.prev;
                (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                      (char *)((void *)0))))->link.prev)->link.next = ap__b;
                ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                     (char *)((void *)0))))->link.prev = ap__b;
                break;
              }
              break;
            }
            rv = ap_pass_brigade(f->next, b);
            if (rv != 0) {
              goto _L;
            } else {
              if ((f->c)->aborted) {
                _L: 
                apr_brigade_destroy(split);
                return (rv);
              }
            }
            b = split;
            e = b->list.next;
            ctx->data_sent = 1;
          }
          eblock = (enum __anonenum_apr_read_type_e_60 )0;
          continue;
        } else {
          ap_log_rerror("protocol.c", 1276, 3, rv, (request_rec const   *)r, "ap_content_length_filter: apr_bucket_read() failed");
          return (rv);
        }
      }
    } else {
      r->bytes_sent = (long )((unsigned long )r->bytes_sent + (unsigned long )e->length);
    }
    e = e->link.next;
  }
  if (ctx->data_sent == 0) {
    if (eos) {
      ap_set_content_length(r, r->bytes_sent);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
  }
  ctx->data_sent = 1;
  tmp___1 = ap_pass_brigade(f->next, b);
  return (tmp___1);
}
}
apr_status_t ap_send_fd(apr_file_t *fd , request_rec *r , apr_off_t offset , apr_size_t len ,
                        apr_size_t *nbytes ) 
{ conn_rec *c ;
  apr_bucket_brigade *bb ;
  apr_bucket *b ;
  apr_status_t rv ;
  apr_bucket *ap__b ;

  {
  c = r->connection;
  bb = (apr_bucket_brigade *)((void *)0);
  bb = apr_brigade_create(r->pool, c->bucket_alloc);
  b = apr_bucket_file_create(fd, offset, len, r->pool, c->bucket_alloc);
  while (1) {
    ap__b = b;
    while (1) {
      ap__b->link.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                              (char *)((void *)0)));
      ap__b->link.prev = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                               (char *)((void *)0))))->link.prev;
      (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                             (char *)((void *)0))))->link.prev)->link.next = ap__b;
      ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                            (char *)((void *)0))))->link.prev = ap__b;
      break;
    }
    break;
  }
  rv = ap_pass_brigade(r->output_filters, bb);
  if (rv != 0) {
    (*nbytes) = 0U;
  } else {
    (*nbytes) = len;
  }
  return (rv);
}
}
size_t ap_send_mmap(apr_mmap_t *mm , request_rec *r , size_t offset , size_t length ) 
{ conn_rec *c ;
  apr_bucket_brigade *bb ;
  apr_bucket *b ;
  apr_bucket *ap__b ;

  {
  c = r->connection;
  bb = (apr_bucket_brigade *)((void *)0);
  bb = apr_brigade_create(r->pool, c->bucket_alloc);
  b = apr_bucket_mmap_create(mm, (long )offset, length, c->bucket_alloc);
  while (1) {
    ap__b = b;
    while (1) {
      ap__b->link.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                              (char *)((void *)0)));
      ap__b->link.prev = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                               (char *)((void *)0))))->link.prev;
      (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                             (char *)((void *)0))))->link.prev)->link.next = ap__b;
      ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                            (char *)((void *)0))))->link.prev = ap__b;
      break;
    }
    break;
  }
  ap_pass_brigade(r->output_filters, bb);
  return (mm->size);
}
}
apr_status_t ap_old_write_filter(ap_filter_t *f , apr_bucket_brigade *bb ) 
{ old_write_filter_ctx *ctx ;
  apr_status_t tmp ;

  {
  ctx = (old_write_filter_ctx *)f->ctx;
  if ((unsigned int )ctx->bb != (unsigned int )((apr_bucket_brigade *)0)) {
    while (1) {
      if (! ((unsigned int )bb->list.next == (unsigned int )((struct apr_bucket *)((char *)(& bb->list) -
                                                                                   (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                           (char *)((void *)0)))))) {
        while (1) {
          (bb->list.prev)->link.next = (struct apr_bucket *)((char *)(& (ctx->bb)->list) -
                                                             (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                     (char *)((void *)0)));
          (bb->list.next)->link.prev = ((struct apr_bucket *)((char *)(& (ctx->bb)->list) -
                                                              (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                      (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& (ctx->bb)->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                        (char *)((void *)0))))->link.prev)->link.next = bb->list.next;
          ((struct apr_bucket *)((char *)(& (ctx->bb)->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                       (char *)((void *)0))))->link.prev = bb->list.prev;
          break;
        }
        while (1) {
          bb->list.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                               (char *)((void *)0)));
          bb->list.prev = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                               (char *)((void *)0)));
          break;
        }
      }
      break;
    }
    bb = ctx->bb;
    ctx->bb = (apr_bucket_brigade *)((void *)0);
  }
  tmp = ap_pass_brigade(f->next, bb);
  return (tmp);
}
}
static apr_status_t buffer_output(request_rec *r , char const   *str , apr_size_t len ) 
{ conn_rec *c ;
  ap_filter_t *f ;
  old_write_filter_ctx *ctx ;
  void *tmp ;
  apr_bucket_brigade *bb ;
  apr_bucket_brigade *tmp___0 ;
  apr_bucket *b ;
  apr_bucket *tmp___1 ;
  apr_bucket *ap__b ;
  apr_status_t tmp___2 ;
  apr_status_t tmp___3 ;

  {
  c = r->connection;
  if (len == 0U) {
    return (0);
  }
  f = r->output_filters;
  while ((unsigned int )f != (unsigned int )((void *)0)) {
    if ((unsigned int )ap_old_write_func == (unsigned int )f->frec) {
      break;
    }
    f = f->next;
  }
  if ((unsigned int )f == (unsigned int )((void *)0)) {
    tmp = apr_palloc(r->pool, sizeof((*ctx)));
    ctx = (old_write_filter_ctx *)memset(tmp, 0, sizeof((*ctx)));
    ap_add_output_filter("OLD_WRITE", (void *)ctx, r, r->connection);
    f = r->output_filters;
  }
  if ((unsigned int )f != (unsigned int )r->output_filters) {
    tmp___0 = apr_brigade_create(r->pool, c->bucket_alloc);
    bb = tmp___0;
    tmp___1 = apr_bucket_transient_create(str, len, c->bucket_alloc);
    b = tmp___1;
    while (1) {
      ap__b = b;
      while (1) {
        ap__b->link.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                (char *)((void *)0)));
        ap__b->link.prev = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                 (char *)((void *)0))))->link.prev;
        (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                               (char *)((void *)0))))->link.prev)->link.next = ap__b;
        ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                              (char *)((void *)0))))->link.prev = ap__b;
        break;
      }
      break;
    }
    tmp___2 = ap_pass_brigade(r->output_filters, bb);
    return (tmp___2);
  }
  ctx = (old_write_filter_ctx *)(r->output_filters)->ctx;
  if ((unsigned int )ctx->bb == (unsigned int )((void *)0)) {
    ctx->bb = apr_brigade_create(r->pool, c->bucket_alloc);
  }
  tmp___3 = apr_brigade_write(ctx->bb, & ap_filter_flush, (void *)f->next, str, len);
  return (tmp___3);
}
}
int ap_rputc(int c , request_rec *r ) 
{ char c2 ;
  apr_status_t tmp ;

  {
  c2 = (char )c;
  if ((r->connection)->aborted) {
    return (-1);
  }
  tmp = buffer_output(r, (char const   *)(& c2), 1U);
  if (tmp != 0) {
    return (-1);
  }
  return (c);
}
}
int ap_rputs(char const   *str , request_rec *r ) 
{ apr_size_t len ;
  apr_status_t tmp ;

  {
  if ((r->connection)->aborted) {
    return (-1);
  }
  len = strlen(str);
  tmp = buffer_output(r, str, len);
  if (tmp != 0) {
    return (-1);
  }
  return ((int )len);
}
}
int ap_rwrite(void const   *buf , int nbyte , request_rec *r ) 
{ apr_status_t tmp ;

  {
  if ((r->connection)->aborted) {
    return (-1);
  }
  tmp = buffer_output(r, (char const   *)buf, (unsigned int )nbyte);
  if (tmp != 0) {
    return (-1);
  }
  return (nbyte);
}
}
static apr_status_t r_flush(apr_vformatter_buff_t *buff ) 
{ struct ap_vrprintf_data *vd ;
  apr_status_t tmp ;

  {
  vd = (struct ap_vrprintf_data *)buff;
  if (((vd->r)->connection)->aborted) {
    return (-1);
  }
  tmp = buffer_output(vd->r, (char const   *)vd->buff, 8192U);
  if (tmp) {
    return (-1);
  }
  vd->vbuff.curpos = vd->buff;
  vd->vbuff.endpos = vd->buff + 8192;
  return (0);
}
}
int ap_vrprintf(request_rec *r , char const   *fmt , va_list va ) 
{ apr_size_t written ;
  struct ap_vrprintf_data vd ;
  char vrprintf_buf[8192] ;
  int n ;
  apr_status_t tmp ;

  {
  vd.vbuff.curpos = vrprintf_buf;
  vd.vbuff.endpos = vrprintf_buf + 8192;
  vd.r = r;
  vd.buff = vrprintf_buf;
  if ((r->connection)->aborted) {
    return (-1);
  }
  written = (apr_size_t )apr_vformatter(& r_flush, & vd.vbuff, fmt, va);
  (*(vd.vbuff.curpos)) = (char )'\000';
  if (written != 4294967295U) {
    n = vd.vbuff.curpos - vrprintf_buf;
    tmp = buffer_output(r, (char const   *)(vrprintf_buf), (unsigned int )n);
    if (tmp != 0) {
      return (-1);
    }
    written += (unsigned int )n;
  }
  return ((int )written);
}
}
int ( /* format attribute */  ap_rprintf)(request_rec *r , char const   *fmt  , ...) 
{ va_list va ;
  int n ;

  {
  if ((r->connection)->aborted) {
    return (-1);
  }
  __builtin_stdarg_start(va, fmt);
  n = ap_vrprintf(r, fmt, va);
  __builtin_va_end(va);
  return (n);
}
}
int ap_rvputs(request_rec *r  , ...) 
{ va_list va ;
  char const   *s ;
  apr_size_t len ;
  apr_size_t written ;
  apr_status_t tmp ;

  {
  written = 0U;
  if ((r->connection)->aborted) {
    return (-1);
  }
  __builtin_stdarg_start(va, r);
  while (1) {
    s = __builtin_va_arg(va, char const   *);
    if ((unsigned int )s == (unsigned int )((void *)0)) {
      break;
    }
    len = strlen(s);
    tmp = buffer_output(r, s, len);
    if (tmp != 0) {
      return (-1);
    }
    written += len;
  }
  __builtin_va_end(va);
  return ((int )written);
}
}
int ap_rflush(request_rec *r ) 
{ conn_rec *c ;
  apr_bucket_brigade *bb ;
  apr_bucket *b ;
  apr_bucket *ap__b ;
  apr_status_t tmp ;

  {
  c = r->connection;
  bb = apr_brigade_create(r->pool, c->bucket_alloc);
  b = apr_bucket_flush_create(c->bucket_alloc);
  while (1) {
    ap__b = b;
    while (1) {
      ap__b->link.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                              (char *)((void *)0)));
      ap__b->link.prev = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                               (char *)((void *)0))))->link.prev;
      (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                             (char *)((void *)0))))->link.prev)->link.next = ap__b;
      ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                            (char *)((void *)0))))->link.prev = ap__b;
      break;
    }
    break;
  }
  tmp = ap_pass_brigade(r->output_filters, bb);
  if (tmp != 0) {
    return (-1);
  }
  return (0);
}
}
void ap_set_last_modified(request_rec *r ) 
{ apr_time_t mod_time ;
  apr_time_t tmp ;
  char *datestr ;
  char *tmp___0 ;

  {
  if (! r->assbackwards) {
    tmp = ap_rationalize_mtime(r, r->mtime);
    mod_time = tmp;
    tmp___0 = (char *)apr_palloc(r->pool, 30U);
    datestr = tmp___0;
    apr_rfc822_date(datestr, mod_time);
    apr_table_setn(r->headers_out, "Last-Modified", (char const   *)datestr);
  }
  return;
}
}
void ap_hook_post_read_request(ap_HOOK_post_read_request_t *pf , char const   * const  *aszPre___1 ,
                               char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_post_read_request_t *pHook ;

  {
  if (! _hooks___3.link_post_read_request) {
    _hooks___3.link_post_read_request = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_post_read_request_t ));
    apr_hook_sort_register("post_read_request", & _hooks___3.link_post_read_request);
  }
  pHook = (ap_LINK_post_read_request_t *)apr_array_push(_hooks___3.link_post_read_request);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("post_read_request", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_post_read_request(void) 
{ 

  {
  return (_hooks___3.link_post_read_request);
}
}
int ap_run_post_read_request(request_rec *r ) 
{ ap_LINK_post_read_request_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks___3.link_post_read_request) {
    return (0);
  }
  pHook = (ap_LINK_post_read_request_t *)(_hooks___3.link_post_read_request)->elts;
  n = 0;
  while (n < (_hooks___3.link_post_read_request)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(r);
    if (rv != 0) {
      if (rv != -1) {
        return (rv);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    n ++;
  }
  return (0);
}
}
void ap_hook_log_transaction(ap_HOOK_log_transaction_t *pf , char const   * const  *aszPre___1 ,
                             char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_log_transaction_t *pHook ;

  {
  if (! _hooks___3.link_log_transaction) {
    _hooks___3.link_log_transaction = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_log_transaction_t ));
    apr_hook_sort_register("log_transaction", & _hooks___3.link_log_transaction);
  }
  pHook = (ap_LINK_log_transaction_t *)apr_array_push(_hooks___3.link_log_transaction);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("log_transaction", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_log_transaction(void) 
{ 

  {
  return (_hooks___3.link_log_transaction);
}
}
int ap_run_log_transaction(request_rec *r ) 
{ ap_LINK_log_transaction_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks___3.link_log_transaction) {
    return (0);
  }
  pHook = (ap_LINK_log_transaction_t *)(_hooks___3.link_log_transaction)->elts;
  n = 0;
  while (n < (_hooks___3.link_log_transaction)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(r);
    if (rv != 0) {
      if (rv != -1) {
        return (rv);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    n ++;
  }
  return (0);
}
}
void ap_hook_http_method(ap_HOOK_http_method_t *pf , char const   * const  *aszPre___1 ,
                         char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_http_method_t *pHook ;

  {
  if (! _hooks___3.link_http_method) {
    _hooks___3.link_http_method = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_http_method_t ));
    apr_hook_sort_register("http_method", & _hooks___3.link_http_method);
  }
  pHook = (ap_LINK_http_method_t *)apr_array_push(_hooks___3.link_http_method);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("http_method", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_http_method(void) 
{ 

  {
  return (_hooks___3.link_http_method);
}
}
char const   *ap_run_http_method(request_rec const   *r ) 
{ ap_LINK_http_method_t *pHook ;
  int n ;
  char const   *rv ;

  {
  if (! _hooks___3.link_http_method) {
    return ((char const   *)((void *)0));
  }
  pHook = (ap_LINK_http_method_t *)(_hooks___3.link_http_method)->elts;
  n = 0;
  while (n < (_hooks___3.link_http_method)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(r);
    if ((unsigned int )rv != (unsigned int )((void *)0)) {
      return (rv);
    }
    n ++;
  }
  return ((char const   *)((void *)0));
}
}
void ap_hook_default_port(ap_HOOK_default_port_t *pf , char const   * const  *aszPre___1 ,
                          char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_default_port_t *pHook ;

  {
  if (! _hooks___3.link_default_port) {
    _hooks___3.link_default_port = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_default_port_t ));
    apr_hook_sort_register("default_port", & _hooks___3.link_default_port);
  }
  pHook = (ap_LINK_default_port_t *)apr_array_push(_hooks___3.link_default_port);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("default_port", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_default_port(void) 
{ 

  {
  return (_hooks___3.link_default_port);
}
}
unsigned short ap_run_default_port(request_rec const   *r ) 
{ ap_LINK_default_port_t *pHook ;
  int n ;
  unsigned short rv ;

  {
  if (! _hooks___3.link_default_port) {
    return ((unsigned short)0);
  }
  pHook = (ap_LINK_default_port_t *)(_hooks___3.link_default_port)->elts;
  n = 0;
  while (n < (_hooks___3.link_default_port)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(r);
    if ((int )rv != 0) {
      return (rv);
    }
    n ++;
  }
  return ((unsigned short)0);
}
}
#pragma merger(0,"/tmp/cil-VsFDIyfw.i","-g -pthread")
struct apr_bucket_type_t  const  apr_bucket_type_file ;
ap_filter_rec_t *ap_subreq_core_filter_handle  ;
ap_filter_rec_t *ap_core_output_filter_handle  ;
ap_filter_rec_t *ap_content_length_filter_handle  ;
ap_filter_rec_t *ap_net_time_filter_handle  ;
ap_filter_rec_t *ap_core_input_filter_handle  ;
static struct __anonstruct__hooks_107 _hooks___4  ;
void ap_hook_get_mgmt_items(ap_HOOK_get_mgmt_items_t *pf , char const   * const  *aszPre___1 ,
                            char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_get_mgmt_items_t *pHook ;

  {
  if (! _hooks___4.link_get_mgmt_items) {
    _hooks___4.link_get_mgmt_items = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_get_mgmt_items_t ));
    apr_hook_sort_register("get_mgmt_items", & _hooks___4.link_get_mgmt_items);
  }
  pHook = (ap_LINK_get_mgmt_items_t *)apr_array_push(_hooks___4.link_get_mgmt_items);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("get_mgmt_items", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_get_mgmt_items(void) 
{ 

  {
  return (_hooks___4.link_get_mgmt_items);
}
}
int ap_run_get_mgmt_items(apr_pool_t *p , char const   *val , apr_hash_t *ht ) 
{ ap_LINK_get_mgmt_items_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks___4.link_get_mgmt_items) {
    return (0);
  }
  pHook = (ap_LINK_get_mgmt_items_t *)(_hooks___4.link_get_mgmt_items)->elts;
  n = 0;
  while (n < (_hooks___4.link_get_mgmt_items)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(p, val, ht);
    if (rv != 0) {
      if (rv != -1) {
        return (rv);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    n ++;
  }
  return (0);
}
}
static void *create_core_dir_config(apr_pool_t *a , char *dir ) 
{ core_dir_config *conf ;
  void *tmp ;

  {
  tmp = apr_palloc(a, sizeof(core_dir_config ));
  conf = (core_dir_config *)memset(tmp, 0, sizeof(core_dir_config ));
  if (dir) {
    conf->opts = (unsigned char)16;
  } else {
    conf->opts = (unsigned char)31;
  }
  conf->opts_remove = (unsigned char)0;
  conf->opts_add = conf->opts_remove;
  if (dir) {
    conf->override = (unsigned char)32;
  } else {
    conf->override = (unsigned char)63;
  }
  conf->content_md5 = 2;
  conf->accept_path_info = 3;
  conf->use_canonical_name = 3U;
  conf->hostname_lookups = 3U;
  conf->do_rfc1413 = 2;
  conf->satisfy = 2;
  conf->limit_cpu = (struct rlimit *)((void *)0);
  conf->limit_mem = (struct rlimit *)((void *)0);
  conf->limit_nproc = (struct rlimit *)((void *)0);
  conf->limit_req_body = 0L;
  conf->limit_xml_body = -1L;
  conf->sec_file = apr_array_make(a, 2, (int )sizeof(ap_conf_vector_t *));
  conf->server_signature = (enum __anonenum_server_signature_e_74 )0;
  conf->add_default_charset = 2U;
  conf->add_default_charset_name = "iso-8859-1";
  conf->mime_type = (char const   *)((void *)0);
  conf->handler = (char const   *)((void *)0);
  conf->output_filters = (char const   *)((void *)0);
  conf->input_filters = (char const   *)((void *)0);
  conf->etag_bits = 0UL;
  conf->etag_add = 0UL;
  conf->etag_remove = 0UL;
  conf->enable_mmap = 2U;
  conf->enable_sendfile = 2U;
  return ((void *)conf);
}
}
static void *merge_ct_filters(apr_pool_t *p , void const   *key , apr_ssize_t klen ,
                              void const   *overlay_val , void const   *base_val ,
                              void const   *data ) 
{ ap_filter_rec_t *cur ;
  ap_filter_rec_t const   *overlay_info ;
  ap_filter_rec_t const   *base_info ;
  ap_filter_rec_t *new ;
  void *tmp ;
  ap_filter_rec_t *f ;
  int found ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  overlay_info = (ap_filter_rec_t const   *)overlay_val;
  base_info = (ap_filter_rec_t const   *)base_val;
  cur = (ap_filter_rec_t *)((void *)0);
  while (overlay_info) {
    tmp = apr_palloc(p, sizeof(ap_filter_rec_t ));
    new = (ap_filter_rec_t *)memset(tmp, 0, sizeof(ap_filter_rec_t ));
    new->name = apr_pstrdup(p, overlay_info->name);
    new->next = cur;
    cur = new;
    overlay_info = (ap_filter_rec_t const   *)overlay_info->next;
  }
  while (base_info) {
    found = 0;
    f = cur;
    while (f) {
      tmp___0 = strcasecmp(base_info->name, f->name);
      if (! tmp___0) {
        found = 1;
        break;
      }
      f = f->next;
    }
    if (! found) {
      tmp___1 = apr_palloc(p, sizeof(ap_filter_rec_t ));
      f = (ap_filter_rec_t *)memset(tmp___1, 0, sizeof(ap_filter_rec_t ));
      f->name = apr_pstrdup(p, base_info->name);
      f->next = cur;
      cur = f;
    }
    base_info = (ap_filter_rec_t const   *)base_info->next;
  }
  return ((void *)cur);
}
}
static void *merge_core_dir_configs(apr_pool_t *a , void *basev , void *newv ) 
{ core_dir_config *base ;
  core_dir_config *new ;
  core_dir_config *conf ;
  int i ;

  {
  base = (core_dir_config *)basev;
  new = (core_dir_config *)newv;
  conf = (core_dir_config *)apr_palloc(a, sizeof(core_dir_config ));
  memcpy((void * __restrict  )conf, (void const   * __restrict  )base, sizeof(core_dir_config ));
  conf->d = new->d;
  conf->d_is_fnmatch = new->d_is_fnmatch;
  conf->d_components = new->d_components;
  conf->r = new->r;
  if ((int )new->opts & 16) {
    conf->opts_add = (unsigned char )(((int )conf->opts_add & ~ ((int )new->opts_remove)) |
                                      (int )new->opts_add);
    conf->opts_remove = (unsigned char )(((int )conf->opts_remove & ~ ((int )new->opts_add)) |
                                         (int )new->opts_remove);
    conf->opts = (unsigned char )(((int )conf->opts & ~ ((int )conf->opts_remove)) |
                                  (int )conf->opts_add);
    if ((int )base->opts & 32) {
      if ((int )new->opts & 2) {
        conf->opts = (unsigned char )(((int )conf->opts & -33) | 2);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
  } else {
    conf->opts = new->opts;
    conf->opts_add = new->opts_add;
    conf->opts_remove = new->opts_remove;
  }
  if (! ((int )new->override & 32)) {
    conf->override = new->override;
  }
  if (new->ap_default_type) {
    conf->ap_default_type = new->ap_default_type;
  }
  if (new->ap_auth_type) {
    conf->ap_auth_type = new->ap_auth_type;
  }
  if (new->ap_auth_name) {
    conf->ap_auth_name = new->ap_auth_name;
  }
  if (new->ap_requires) {
    conf->ap_requires = new->ap_requires;
  }
  if ((unsigned int )conf->response_code_strings == (unsigned int )((void *)0)) {
    conf->response_code_strings = new->response_code_strings;
  } else {
    if ((unsigned int )new->response_code_strings != (unsigned int )((void *)0)) {
      conf->response_code_strings = (char **)apr_palloc(a, sizeof((*(conf->response_code_strings))) *
                                                           57U);
      memcpy((void * __restrict  )conf->response_code_strings, (void const   * __restrict  )base->response_code_strings,
             sizeof((*(conf->response_code_strings))) * 57U);
      i = 0;
      while (i < 57) {
        if ((unsigned int )(*(new->response_code_strings + i)) != (unsigned int )((void *)0)) {
          (*(conf->response_code_strings + i)) = (*(new->response_code_strings + i));
        }
        i ++;
      }
    }
  }
  if (new->hostname_lookups != 3U) {
    conf->hostname_lookups = new->hostname_lookups;
  }
  if ((new->do_rfc1413 & 2) == 0) {
    conf->do_rfc1413 = new->do_rfc1413;
  }
  if ((new->content_md5 & 2) == 0) {
    conf->content_md5 = new->content_md5;
  }
  if (new->accept_path_info != 3) {
    conf->accept_path_info = new->accept_path_info;
  }
  if (new->use_canonical_name != 3U) {
    conf->use_canonical_name = new->use_canonical_name;
  }
  if (new->limit_cpu) {
    conf->limit_cpu = new->limit_cpu;
  }
  if (new->limit_mem) {
    conf->limit_mem = new->limit_mem;
  }
  if (new->limit_nproc) {
    conf->limit_nproc = new->limit_nproc;
  }
  if (new->limit_req_body) {
    conf->limit_req_body = new->limit_req_body;
  }
  if (new->limit_xml_body != -1L) {
    conf->limit_xml_body = new->limit_xml_body;
  } else {
    conf->limit_xml_body = base->limit_xml_body;
  }
  if (! conf->sec_file) {
    conf->sec_file = new->sec_file;
  } else {
    if (new->sec_file) {
      conf->sec_file = apr_array_append(a, (apr_array_header_t const   *)base->sec_file,
                                        (apr_array_header_t const   *)new->sec_file);
    }
  }
  if (new->satisfy != 2) {
    conf->satisfy = new->satisfy;
  }
  if ((int )new->server_signature != 0) {
    conf->server_signature = new->server_signature;
  }
  if (new->add_default_charset != 2U) {
    conf->add_default_charset = new->add_default_charset;
    conf->add_default_charset_name = new->add_default_charset_name;
  }
  if (new->mime_type) {
    conf->mime_type = new->mime_type;
  }
  if (new->handler) {
    conf->handler = new->handler;
  }
  if (new->output_filters) {
    conf->output_filters = new->output_filters;
  }
  if (new->input_filters) {
    conf->input_filters = new->input_filters;
  }
  if (conf->ct_output_filters) {
    if (new->ct_output_filters) {
      conf->ct_output_filters = apr_hash_merge(a, (apr_hash_t const   *)new->ct_output_filters,
                                               (apr_hash_t const   *)conf->ct_output_filters,
                                               & merge_ct_filters, (void const   *)((void *)0));
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    if (new->ct_output_filters) {
      conf->ct_output_filters = apr_hash_copy(a, (apr_hash_t const   *)new->ct_output_filters);
    } else {
      if (conf->ct_output_filters) {
        conf->ct_output_filters = apr_hash_copy(a, (apr_hash_t const   *)base->ct_output_filters);
      }
    }
  }
  if (new->etag_bits == 0UL) {
    conf->etag_add = (conf->etag_add & ~ new->etag_remove) | new->etag_add;
    conf->etag_remove = ((unsigned long )conf->opts_remove & ~ new->etag_add) | new->etag_remove;
    conf->etag_bits = (conf->etag_bits & ~ conf->etag_remove) | conf->etag_add;
  } else {
    conf->etag_bits = new->etag_bits;
    conf->etag_add = new->etag_add;
    conf->etag_remove = new->etag_remove;
  }
  if (conf->etag_bits != 1UL) {
    conf->etag_bits = conf->etag_bits & 4294967294UL;
  }
  if (new->enable_mmap != 2U) {
    conf->enable_mmap = new->enable_mmap;
  }
  if (new->enable_sendfile != 2U) {
    conf->enable_sendfile = new->enable_sendfile;
  }
  return ((void *)conf);
}
}
static void *create_core_server_config(apr_pool_t *a , server_rec *s ) 
{ core_server_config *conf ;
  int is_virtual ;
  void *tmp ;

  {
  is_virtual = s->is_virtual;
  tmp = apr_palloc(a, sizeof(core_server_config ));
  conf = (core_server_config *)memset(tmp, 0, sizeof(core_server_config ));
  if (is_virtual) {
    conf->access_name = (char *)((void *)0);
  } else {
    conf->access_name = (char *)".htaccess";
  }
  if (is_virtual) {
    conf->ap_document_root = (char const   *)((void *)0);
  } else {
    conf->ap_document_root = "/usr/local/apache2/htdocs";
  }
  conf->sec_dir = apr_array_make(a, 40, (int )sizeof(ap_conf_vector_t *));
  conf->sec_url = apr_array_make(a, 40, (int )sizeof(ap_conf_vector_t *));
  return ((void *)conf);
}
}
static void *merge_core_server_configs(apr_pool_t *p , void *basev , void *virtv ) 
{ core_server_config *base ;
  core_server_config *virt ;
  core_server_config *conf ;

  {
  base = (core_server_config *)basev;
  virt = (core_server_config *)virtv;
  conf = (core_server_config *)apr_palloc(p, sizeof(core_server_config ));
  memcpy((void * __restrict  )conf, (void const   * __restrict  )virt, sizeof(core_server_config ));
  if (! conf->access_name) {
    conf->access_name = base->access_name;
  }
  if (! conf->ap_document_root) {
    conf->ap_document_root = base->ap_document_root;
  }
  conf->sec_dir = apr_array_append(p, (apr_array_header_t const   *)base->sec_dir,
                                   (apr_array_header_t const   *)virt->sec_dir);
  conf->sec_url = apr_array_append(p, (apr_array_header_t const   *)base->sec_url,
                                   (apr_array_header_t const   *)virt->sec_url);
  return ((void *)conf);
}
}
void ap_add_per_dir_conf(server_rec *s , void *dir_config ) 
{ core_server_config *sconf ;
  void **new_space ;
  void **tmp ;

  {
  sconf = (core_server_config *)(*((void **)s->module_config + core_module.module_index));
  tmp = (void **)apr_array_push(sconf->sec_dir);
  new_space = tmp;
  (*new_space) = dir_config;
  return;
}
}
void ap_add_per_url_conf(server_rec *s , void *url_config ) 
{ core_server_config *sconf ;
  void **new_space ;
  void **tmp ;

  {
  sconf = (core_server_config *)(*((void **)s->module_config + core_module.module_index));
  tmp = (void **)apr_array_push(sconf->sec_url);
  new_space = tmp;
  (*new_space) = url_config;
  return;
}
}
void ap_add_file_conf(core_dir_config *conf , void *url_config ) 
{ void **new_space ;
  void **tmp ;

  {
  tmp = (void **)apr_array_push(conf->sec_file);
  new_space = tmp;
  (*new_space) = url_config;
  return;
}
}
static int reorder_sorter(void const   *va , void const   *vb ) 
{ struct reorder_sort_rec  const  *a ;
  struct reorder_sort_rec  const  *b ;
  core_dir_config *core_a ;
  core_dir_config *core_b ;

  {
  a = (struct reorder_sort_rec  const  *)va;
  b = (struct reorder_sort_rec  const  *)vb;
  core_a = (core_dir_config *)(*((void **)a->elt + core_module.module_index));
  core_b = (core_dir_config *)(*((void **)b->elt + core_module.module_index));
  if (! core_a->r) {
    if (core_b->r) {
      return (-1);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    if (core_a->r) {
      if (! core_b->r) {
        return (1);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
  }
  if (core_a->d_components < core_b->d_components) {
    return (-1);
  } else {
    if (core_a->d_components > core_b->d_components) {
      return (1);
    }
  }
  return (a->orig_index - b->orig_index);
}
}
void ap_core_reorder_directories(apr_pool_t *p , server_rec *s ) 
{ core_server_config *sconf ;
  apr_array_header_t *sec_dir ;
  struct reorder_sort_rec *sortbin ;
  int nelts ;
  ap_conf_vector_t **elts ;
  int i ;
  apr_pool_t *tmp ;

  {
  sconf = (core_server_config *)(*((void **)s->module_config + core_module.module_index));
  sec_dir = sconf->sec_dir;
  nelts = sec_dir->nelts;
  elts = (ap_conf_vector_t **)sec_dir->elts;
  if (! nelts) {
    return;
  }
  apr_pool_create_ex(& tmp, p, (int (*)(int retcode ))((void *)0), (apr_allocator_t *)((void *)0));
  sortbin = (struct reorder_sort_rec *)apr_palloc(tmp, (unsigned int )sec_dir->nelts *
                                                       sizeof((*sortbin)));
  i = 0;
  while (i < nelts) {
    (sortbin + i)->orig_index = i;
    (sortbin + i)->elt = (*(elts + i));
    i ++;
  }
  qsort((void *)sortbin, (unsigned int )nelts, sizeof((*sortbin)), & reorder_sorter);
  i = 0;
  while (i < nelts) {
    (*(elts + i)) = (sortbin + i)->elt;
    i ++;
  }
  apr_pool_destroy(tmp);
  return;
}
}
int ap_allow_options(request_rec *r ) 
{ core_dir_config *conf ;

  {
  conf = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  return ((int )conf->opts);
}
}
int ap_allow_overrides(request_rec *r ) 
{ core_dir_config *conf ;

  {
  conf = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  return ((int )conf->override);
}
}
char const   *ap_auth_type(request_rec *r ) 
{ core_dir_config *conf ;

  {
  conf = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  return ((char const   *)conf->ap_auth_type);
}
}
char const   *ap_auth_name(request_rec *r ) 
{ core_dir_config *conf ;

  {
  conf = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  return ((char const   *)conf->ap_auth_name);
}
}
char const   *ap_default_type(request_rec *r ) 
{ core_dir_config *conf ;
  char const   *tmp ;

  {
  conf = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  if (conf->ap_default_type) {
    tmp = (char const   *)conf->ap_default_type;
  } else {
    tmp = "text/plain";
  }
  return (tmp);
}
}
char const   *ap_document_root(request_rec *r ) 
{ core_server_config *conf ;

  {
  conf = (core_server_config *)(*((void **)(r->server)->module_config + core_module.module_index));
  return (conf->ap_document_root);
}
}
apr_array_header_t const   *ap_requires(request_rec *r ) 
{ core_dir_config *conf ;

  {
  conf = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  return ((apr_array_header_t const   *)conf->ap_requires);
}
}
int ap_satisfies(request_rec *r ) 
{ core_dir_config *conf ;

  {
  conf = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  return (conf->satisfy);
}
}
char *ap_response_code_string(request_rec *r , int error_index ) 
{ core_dir_config *conf ;

  {
  conf = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  if ((unsigned int )conf->response_code_strings == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  }
  return ((*(conf->response_code_strings + error_index)));
}
}
__inline static void do_double_reverse(conn_rec *conn ) 
{ apr_sockaddr_t *sa ;
  apr_status_t rv ;
  int tmp ;

  {
  if (conn->double_reverse) {
    return;
  }
  if ((unsigned int )conn->remote_host == (unsigned int )((void *)0)) {
    goto _L;
  } else {
    if ((int )(*(conn->remote_host + 0)) == 0) {
      _L: 
      conn->double_reverse = -1;
      return;
    }
  }
  rv = apr_sockaddr_info_get(& sa, (char const   *)conn->remote_host, 0, (unsigned short)0,
                             0, conn->pool);
  if (rv == 0) {
    while (sa) {
      tmp = apr_sockaddr_equal((apr_sockaddr_t const   *)sa, (apr_sockaddr_t const   *)conn->remote_addr);
      if (tmp) {
        conn->double_reverse = 1;
        return;
      }
      sa = sa->next;
    }
  }
  conn->double_reverse = -1;
  return;
}
}
char const   *ap_get_remote_host(conn_rec *conn , void *dir_config , int type , int *str_is_ip ) 
{ int hostname_lookups ;
  apr_status_t tmp ;

  {
  if (str_is_ip) {
    (*str_is_ip) = 0;
  }
  if (dir_config) {
    hostname_lookups = (int )((core_dir_config *)(*((void **)dir_config + core_module.module_index)))->hostname_lookups;
    if (hostname_lookups == 3) {
      hostname_lookups = 0;
    }
  } else {
    hostname_lookups = 0;
  }
  if (type != 2) {
    if ((unsigned int )conn->remote_host == (unsigned int )((void *)0)) {
      if (type == 3) {
        goto _L___0;
      } else {
        if (hostname_lookups != 0) {
          _L___0: 
          tmp = apr_getnameinfo(& conn->remote_host, conn->remote_addr, 0);
          if (tmp == 0) {
            ap_str_tolower(conn->remote_host);
            if (hostname_lookups == 2) {
              do_double_reverse(conn);
              if (conn->double_reverse != 1) {
                conn->remote_host = (char *)((void *)0);
              }
            }
          }
          if ((unsigned int )conn->remote_host == (unsigned int )((void *)0)) {
            conn->remote_host = (char *)"";
          }
        } else {
          goto _L___1;
        }
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: ;
  }
  if (type == 3) {
    do_double_reverse(conn);
    if (conn->double_reverse == -1) {
      return ((char const   *)((void *)0));
    }
  }
  if ((unsigned int )conn->remote_host != (unsigned int )((void *)0)) {
    if ((int )(*(conn->remote_host + 0)) != 0) {
      return ((char const   *)conn->remote_host);
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    if (type == 0) {
      goto _L___2;
    } else {
      if (type == 3) {
        _L___2: 
        return ((char const   *)((void *)0));
      } else {
        if (str_is_ip) {
          (*str_is_ip) = 1;
        }
        return ((char const   *)conn->remote_ip);
      }
    }
  }
}
}
char const   *ap_get_remote_logname(request_rec *r ) 
{ core_dir_config *dir_conf ;
  char const   *tmp ;

  {
  if ((unsigned int )(r->connection)->remote_logname != (unsigned int )((void *)0)) {
    return ((char const   *)(r->connection)->remote_logname);
  }
  dir_conf = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  if (dir_conf->do_rfc1413 & 1) {
    tmp = ap_rfc1413(r->connection, r->server);
    return (tmp);
  } else {
    return ((char const   *)((void *)0));
  }
}
}
char const   *ap_get_server_name(request_rec *r ) 
{ conn_rec *conn ;
  core_dir_config *d ;
  char const   *tmp ;
  apr_status_t tmp___0 ;

  {
  conn = r->connection;
  d = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  if (d->use_canonical_name == 0U) {
    if (r->hostname) {
      tmp = r->hostname;
    } else {
      tmp = (char const   *)(r->server)->server_hostname;
    }
    return (tmp);
  }
  if (d->use_canonical_name == 2U) {
    if ((unsigned int )conn->local_host == (unsigned int )((void *)0)) {
      tmp___0 = apr_getnameinfo(& conn->local_host, conn->local_addr, 0);
      if (tmp___0 != 0) {
        conn->local_host = apr_pstrdup(conn->pool, (char const   *)(r->server)->server_hostname);
      } else {
        ap_str_tolower(conn->local_host);
      }
    }
    return ((char const   *)conn->local_host);
  }
  return ((char const   *)(r->server)->server_hostname);
}
}
apr_port_t ap_get_server_port(request_rec const   *r ) 
{ apr_port_t port ;
  core_dir_config *d ;

  {
  d = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  if (d->use_canonical_name == 0U) {
    goto _L;
  } else {
    if (d->use_canonical_name == 2U) {
      _L: 
      if (r->parsed_uri.port) {
        port = r->parsed_uri.port;
      } else {
        if ((r->server)->port) {
          port = (r->server)->port;
        } else {
          port = ap_run_default_port(r);
        }
      }
    } else {
      if ((r->server)->port) {
        port = (r->server)->port;
      } else {
        if (((r->connection)->local_addr)->port) {
          port = ((r->connection)->local_addr)->port;
        } else {
          port = ap_run_default_port(r);
        }
      }
    }
  }
  return (port);
}
}
char *ap_construct_url(apr_pool_t *p , char const   *uri , request_rec *r ) 
{ unsigned int port ;
  unsigned int tmp ;
  char const   *host ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  apr_port_t tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;

  {
  tmp = (unsigned int )ap_get_server_port((request_rec const   *)r);
  port = tmp;
  tmp___0 = ap_get_server_name(r);
  host = tmp___0;
  tmp___3 = ap_run_default_port((request_rec const   *)r);
  if (port == (unsigned int )tmp___3) {
    tmp___1 = ap_run_http_method((request_rec const   *)r);
    tmp___2 = apr_pstrcat(p, tmp___1, "://", host, uri, (void *)0);
    return (tmp___2);
  }
  tmp___4 = ap_run_http_method((request_rec const   *)r);
  tmp___5 = apr_psprintf(p, "%s://%s:%u%s", tmp___4, host, port, uri);
  return (tmp___5);
}
}
apr_off_t ap_get_limit_req_body(request_rec const   *r ) 
{ core_dir_config *d ;

  {
  d = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  return (d->limit_req_body);
}
}
static ap_directive_t const   *find_parent(ap_directive_t const   *dirp , char const   *what ) 
{ int tmp ;

  {
  while ((unsigned int )dirp->parent != (unsigned int )((void *)0)) {
    dirp = (ap_directive_t const   *)dirp->parent;
    tmp = strcasecmp(dirp->directive, what);
    if (tmp == 0) {
      return (dirp);
    }
  }
  return ((ap_directive_t const   *)((void *)0));
}
}
char const   *ap_check_cmd_context(cmd_parms *cmd , unsigned int forbidden ) 
{ char const   *gt ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  ap_directive_t const   *found ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
  if ((int const   )(*((cmd->cmd)->name + 0)) == 60) {
    tmp___1 = strlen((cmd->cmd)->name);
    if ((int const   )(*((cmd->cmd)->name + (tmp___1 - 1U))) != 62) {
      tmp___0 = ">";
    } else {
      goto _L;
    }
  } else {
    _L: 
    tmp___0 = "";
  }
  gt = tmp___0;
  if (forbidden & 1U) {
    if ((cmd->server)->is_virtual) {
      tmp___2 = apr_pstrcat(cmd->pool, (cmd->cmd)->name, gt, " cannot occur within <VirtualHost> section",
                            (void *)0);
      return (tmp___2);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
  }
  if (forbidden & 2U) {
    if (cmd->limited != -1LL) {
      tmp___3 = apr_pstrcat(cmd->pool, (cmd->cmd)->name, gt, " cannot occur within <Limit> section",
                            (void *)0);
      return (tmp___3);
    } else {
      goto _L___1;
    }
  } else {
    _L___1: ;
  }
  if ((forbidden & 28U) == 28U) {
    if ((unsigned int )cmd->path != (unsigned int )((void *)0)) {
      tmp___4 = apr_pstrcat(cmd->pool, (cmd->cmd)->name, gt, " cannot occur within <Directory/Location/Files> section",
                            (void *)0);
      return (tmp___4);
    }
    if ((cmd->cmd)->req_override & 256) {
      return ((char const   *)((void *)0));
    }
  }
  if (forbidden & 4U) {
    found = find_parent((ap_directive_t const   *)cmd->directive, "<Directory");
    if (found) {
      goto _L___9;
    } else {
      found = find_parent((ap_directive_t const   *)cmd->directive, "<DirectoryMatch");
      if (found) {
        _L___9: 
        goto _L___7;
      } else {
        goto _L___8;
      }
    }
  } else {
    _L___8: 
    if (forbidden & 8U) {
      found = find_parent((ap_directive_t const   *)cmd->directive, "<Location");
      if (found) {
        goto _L___7;
      } else {
        found = find_parent((ap_directive_t const   *)cmd->directive, "<LocationMatch");
        if (found) {
          _L___7: 
          goto _L___4;
        } else {
          goto _L___6;
        }
      }
    } else {
      _L___6: 
      if (forbidden & 16U) {
        found = find_parent((ap_directive_t const   *)cmd->directive, "<Files");
        if (found) {
          goto _L___4;
        } else {
          found = find_parent((ap_directive_t const   *)cmd->directive, "<FilesMatch");
          if (found) {
            _L___4: 
            tmp___5 = apr_pstrcat(cmd->pool, (cmd->cmd)->name, gt, " cannot occur within ",
                                  found->directive, "> section", (void *)0);
            return (tmp___5);
          } else {
            goto _L___3;
          }
        }
      } else {
        _L___3: ;
      }
    }
  }
  return ((char const   *)((void *)0));
}
}
static char const   *set_access_name(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ void *sconf ;
  core_server_config *conf ;
  char const   *err ;
  char const   *tmp ;

  {
  sconf = (void *)(cmd->server)->module_config;
  conf = (core_server_config *)(*((void **)sconf + core_module.module_index));
  tmp = ap_check_cmd_context(cmd, 30U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  conf->access_name = apr_pstrdup(cmd->pool, arg);
  return ((char const   *)((void *)0));
}
}
static char const   *set_add_default_charset(cmd_parms *cmd , void *d_ , char const   *arg ) 
{ core_dir_config *d ;
  char const   *err ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  d = (core_dir_config *)d_;
  tmp = ap_check_cmd_context(cmd, 2U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  tmp___1 = strcasecmp(arg, "Off");
  if (tmp___1) {
    tmp___0 = strcasecmp(arg, "On");
    if (tmp___0) {
      d->add_default_charset = 1U;
      d->add_default_charset_name = arg;
    } else {
      d->add_default_charset = 1U;
      d->add_default_charset_name = "iso-8859-1";
    }
  } else {
    d->add_default_charset = 0U;
  }
  return ((char const   *)((void *)0));
}
}
static char const   *set_document_root(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ void *sconf ;
  core_server_config *conf ;
  char const   *err ;
  char const   *tmp ;
  apr_status_t tmp___0 ;
  int tmp___1 ;

  {
  sconf = (void *)(cmd->server)->module_config;
  conf = (core_server_config *)(*((void **)sconf + core_module.module_index));
  tmp = ap_check_cmd_context(cmd, 30U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  tmp___0 = apr_filepath_merge((char **)(& conf->ap_document_root), (char const   *)((void *)0),
                               arg, 32, cmd->pool);
  if (tmp___0 != 0) {
    goto _L;
  } else {
    tmp___1 = ap_is_directory(cmd->pool, arg);
    if (! tmp___1) {
      _L: 
      if ((cmd->server)->is_virtual) {
        ap_log_perror("core.c", 1098, 32, 0, cmd->pool, "Warning: DocumentRoot [%s] does not exist",
                      arg);
        conf->ap_document_root = arg;
      } else {
        return ("DocumentRoot must be a directory");
      }
    }
  }
  return ((char const   *)((void *)0));
}
}
void ap_custom_response(request_rec *r , int status , char const   *string ) 
{ core_dir_config *conf ;
  int idx ;
  void *tmp ;
  int tmp___3 ;

  {
  conf = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  if ((unsigned int )conf->response_code_strings == (unsigned int )((void *)0)) {
    tmp = apr_palloc(r->pool, sizeof((*(conf->response_code_strings))) * 57U);
    conf->response_code_strings = (char **)memset(tmp, 0, sizeof((*(conf->response_code_strings))) *
                                                          57U);
  }
  idx = ap_index_of_response(status);
  tmp___3 = ap_is_url(string);
  if (tmp___3) {
    goto _L___0;
  } else {
    if ((int const   )(*string) == 47) {
      _L___0: 
      if ((int const   )(*string) != 34) {
        (*(conf->response_code_strings + idx)) = apr_pstrdup(r->pool, string);
      } else {
        goto _L;
      }
    } else {
      _L: 
      (*(conf->response_code_strings + idx)) = apr_pstrcat(r->pool, "\"", string,
                                                           (void *)0);
    }
  }
  return;
}
}
static char const   *set_error_document(cmd_parms *cmd , void *conf_ , char const   *errno_str ,
                                        char const   *msg ) 
{ core_dir_config *conf ;
  int error_number ;
  int index_number ;
  int idx500 ;
  enum __anonenum_what_108 what ;
  char const   *err ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  conf = (core_dir_config *)conf_;
  what = (enum __anonenum_what_108 )0;
  tmp = ap_check_cmd_context(cmd, 2U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  error_number = atoi(errno_str);
  idx500 = ap_index_of_response(500);
  if (error_number == 500) {
    index_number = idx500;
  } else {
    index_number = ap_index_of_response(error_number);
    if (index_number == idx500) {
      tmp___0 = apr_pstrcat(cmd->pool, "Unsupported HTTP response code ", errno_str,
                            (void *)0);
      return (tmp___0);
    }
  }
  tmp___2 = strchr(msg, ' ');
  if (tmp___2) {
    what = (enum __anonenum_what_108 )0;
  } else {
    if ((int const   )(*(msg + 0)) == 47) {
      what = (enum __anonenum_what_108 )1;
    } else {
      tmp___1 = ap_is_url(msg);
      if (tmp___1) {
        what = (enum __anonenum_what_108 )2;
      } else {
        what = (enum __anonenum_what_108 )0;
      }
    }
  }
  if (error_number == 401) {
    if ((int )what == 2) {
      ap_log_error("core.c", 1170, 5, 0, (server_rec const   *)cmd->server, "cannot use a full URL in a 401 ErrorDocument directive --- ignoring!");
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )conf->response_code_strings == (unsigned int )((void *)0)) {
      tmp___3 = apr_palloc(cmd->pool, sizeof((*(conf->response_code_strings))) * 57U);
      conf->response_code_strings = (char **)memset(tmp___3, 0, sizeof((*(conf->response_code_strings))) *
                                                                57U);
    }
    if ((int )what == 0) {
      (*(conf->response_code_strings + index_number)) = apr_pstrcat(cmd->pool, "\"",
                                                                    msg, (void *)0);
    } else {
      (*(conf->response_code_strings + index_number)) = apr_pstrdup(cmd->pool, msg);
    }
  }
  return ((char const   *)((void *)0));
}
}
static char const   *set_override(cmd_parms *cmd , void *d_ , char const   *l ) 
{ core_dir_config *d ;
  char *w ;
  char const   *err ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  d = (core_dir_config *)d_;
  tmp = ap_check_cmd_context(cmd, 2U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  d->override = (unsigned char)0;
  while ((*(l + 0))) {
    w = ap_getword_conf(cmd->pool, & l);
    tmp___7 = strcasecmp((char const   *)w, "Limit");
    if (tmp___7) {
      tmp___6 = strcasecmp((char const   *)w, "Options");
      if (tmp___6) {
        tmp___5 = strcasecmp((char const   *)w, "FileInfo");
        if (tmp___5) {
          tmp___4 = strcasecmp((char const   *)w, "AuthConfig");
          if (tmp___4) {
            tmp___3 = strcasecmp((char const   *)w, "Indexes");
            if (tmp___3) {
              tmp___2 = strcasecmp((char const   *)w, "None");
              if (tmp___2) {
                tmp___1 = strcasecmp((char const   *)w, "All");
                if (tmp___1) {
                  tmp___0 = apr_pstrcat(cmd->pool, "Illegal override option ", w,
                                        (void *)0);
                  return (tmp___0);
                } else {
                  d->override = (unsigned char)31;
                }
              } else {
                d->override = (unsigned char)0;
              }
            } else {
              d->override = (unsigned char )((int )d->override | 16);
            }
          } else {
            d->override = (unsigned char )((int )d->override | 8);
          }
        } else {
          d->override = (unsigned char )((int )d->override | 4);
        }
      } else {
        d->override = (unsigned char )((int )d->override | 2);
      }
    } else {
      d->override = (unsigned char )((int )d->override | 1);
    }
    d->override = (unsigned char )((int )d->override & -33);
  }
  return ((char const   *)((void *)0));
}
}
static char const   *set_options(cmd_parms *cmd , void *d_ , char const   *l ) 
{ core_dir_config *d ;
  allow_options_t opt ;
  int first ;
  char action ;
  char *w ;
  char *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  d = (core_dir_config *)d_;
  first = 1;
  while ((*(l + 0))) {
    tmp = ap_getword_conf(cmd->pool, & l);
    w = tmp;
    action = (char )'\000';
    if ((int )(*w) == 43) {
      goto _L;
    } else {
      if ((int )(*w) == 45) {
        _L: 
        tmp___0 = w;
        w ++;
        action = (*tmp___0);
      } else {
        if (first) {
          d->opts = (unsigned char)0;
          first = 0;
        }
      }
    }
    tmp___11 = strcasecmp((char const   *)w, "Indexes");
    if (tmp___11) {
      tmp___10 = strcasecmp((char const   *)w, "Includes");
      if (tmp___10) {
        tmp___9 = strcasecmp((char const   *)w, "IncludesNOEXEC");
        if (tmp___9) {
          tmp___8 = strcasecmp((char const   *)w, "FollowSymLinks");
          if (tmp___8) {
            tmp___7 = strcasecmp((char const   *)w, "SymLinksIfOwnerMatch");
            if (tmp___7) {
              tmp___6 = strcasecmp((char const   *)w, "execCGI");
              if (tmp___6) {
                tmp___5 = strcasecmp((char const   *)w, "MultiViews");
                if (tmp___5) {
                  tmp___4 = strcasecmp((char const   *)w, "RunScripts");
                  if (tmp___4) {
                    tmp___3 = strcasecmp((char const   *)w, "None");
                    if (tmp___3) {
                      tmp___2 = strcasecmp((char const   *)w, "All");
                      if (tmp___2) {
                        tmp___1 = apr_pstrcat(cmd->pool, "Illegal option ", w, (void *)0);
                        return (tmp___1);
                      } else {
                        opt = (unsigned char)15;
                      }
                    } else {
                      opt = (unsigned char)0;
                    }
                  } else {
                    opt = (unsigned char)136;
                  }
                } else {
                  opt = (unsigned char)128;
                }
              } else {
                opt = (unsigned char)8;
              }
            } else {
              opt = (unsigned char)64;
            }
          } else {
            opt = (unsigned char)4;
          }
        } else {
          opt = (unsigned char)34;
        }
      } else {
        opt = (unsigned char)2;
      }
    } else {
      opt = (unsigned char)1;
    }
    if ((int )action == 45) {
      d->opts_remove = (unsigned char )((int )d->opts_remove | (int )opt);
      d->opts_add = (unsigned char )((int )d->opts_add & ~ ((int )opt));
      d->opts = (unsigned char )((int )d->opts & ~ ((int )opt));
    } else {
      if ((int )action == 43) {
        d->opts_add = (unsigned char )((int )d->opts_add | (int )opt);
        d->opts_remove = (unsigned char )((int )d->opts_remove & ~ ((int )opt));
        d->opts = (unsigned char )((int )d->opts | (int )opt);
      } else {
        d->opts = (unsigned char )((int )d->opts | (int )opt);
      }
    }
  }
  return ((char const   *)((void *)0));
}
}
static char const   *set_etag_bits(cmd_parms *cmd , void *mconfig , char const   *args_p ) 
{ core_dir_config *cfg ;
  etag_components_t bit ;
  char action ;
  char *token ;
  char const   *args ;
  int valid ;
  int first ;
  int explicit ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;

  {
  cfg = (core_dir_config *)mconfig;
  args = args_p;
  first = 1;
  explicit = 0;
  while ((int const   )(*(args + 0)) != 0) {
    action = (char )'*';
    bit = 0UL;
    valid = 1;
    token = ap_getword_conf(cmd->pool, & args);
    if ((int )(*token) == 43) {
      goto _L;
    } else {
      if ((int )(*token) == 45) {
        _L: 
        action = (*token);
        token ++;
      } else {
        if (first) {
          cfg->etag_bits = 0UL;
          cfg->etag_add = 0UL;
          cfg->etag_remove = 0UL;
          first = 0;
        }
      }
    }
    tmp___6 = strcasecmp((char const   *)token, "None");
    if (tmp___6 == 0) {
      if ((int )action != 42) {
        valid = 0;
      } else {
        bit = 1UL;
        cfg->etag_bits = bit;
        explicit = 1;
      }
    } else {
      tmp___5 = strcasecmp((char const   *)token, "All");
      if (tmp___5 == 0) {
        if ((int )action != 42) {
          valid = 0;
        } else {
          explicit = 1;
          bit = 14UL;
          cfg->etag_bits = bit;
        }
      } else {
        tmp___4 = strcasecmp((char const   *)token, "Size");
        if (tmp___4 == 0) {
          bit = 8UL;
        } else {
          tmp___1 = strcasecmp((char const   *)token, "LMTime");
          if (tmp___1 == 0) {
            goto _L___1;
          } else {
            tmp___2 = strcasecmp((char const   *)token, "MTime");
            if (tmp___2 == 0) {
              _L___1: 
              goto _L___0;
            } else {
              tmp___3 = strcasecmp((char const   *)token, "LastModified");
              if (tmp___3 == 0) {
                _L___0: 
                bit = 2UL;
              } else {
                tmp___0 = strcasecmp((char const   *)token, "INode");
                if (tmp___0 == 0) {
                  bit = 4UL;
                } else {
                  tmp = apr_pstrcat(cmd->pool, "Unknown keyword \'", token, "\' for ",
                                    (cmd->cmd)->name, " directive", (void *)0);
                  return (tmp);
                }
              }
            }
          }
        }
      }
    }
    if (! valid) {
      tmp___7 = apr_pstrcat(cmd->pool, (cmd->cmd)->name, " keyword \'", token, "\' cannot be used with \'+\' or \'-\'",
                            (void *)0);
      return (tmp___7);
    }
    if ((int )action == 43) {
      cfg->etag_add = cfg->etag_add | bit;
      cfg->etag_remove = cfg->etag_remove & ~ bit;
    } else {
      if ((int )action == 45) {
        cfg->etag_remove = cfg->etag_remove | bit;
        cfg->etag_add = cfg->etag_add & ~ bit;
      } else {
        cfg->etag_bits = cfg->etag_bits | bit;
        cfg->etag_add = 0UL;
        cfg->etag_remove = 0UL;
        explicit = 1;
      }
    }
  }
  if (cfg->etag_add != 0UL) {
    cfg->etag_add = cfg->etag_add & 4294967295UL;
  }
  if (cfg->etag_remove != 0UL) {
    cfg->etag_remove = cfg->etag_remove & 4294967295UL;
  }
  if (explicit) {
    cfg->etag_bits = cfg->etag_bits & 4294967295UL;
    if ((cfg->etag_bits & 1UL) != 1UL) {
      cfg->etag_bits = cfg->etag_bits & 4294967294UL;
    }
  }
  return ((char const   *)((void *)0));
}
}
static char const   *set_enable_mmap(cmd_parms *cmd , void *d_ , char const   *arg ) 
{ core_dir_config *d ;
  char const   *err ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  d = (core_dir_config *)d_;
  tmp = ap_check_cmd_context(cmd, 2U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  tmp___1 = strcasecmp(arg, "on");
  if (tmp___1 == 0) {
    d->enable_mmap = 1U;
  } else {
    tmp___0 = strcasecmp(arg, "off");
    if (tmp___0 == 0) {
      d->enable_mmap = 0U;
    } else {
      return ("parameter must be \'on\' or \'off\'");
    }
  }
  return ((char const   *)((void *)0));
}
}
static char const   *set_enable_sendfile(cmd_parms *cmd , void *d_ , char const   *arg ) 
{ core_dir_config *d ;
  char const   *err ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  d = (core_dir_config *)d_;
  tmp = ap_check_cmd_context(cmd, 2U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  tmp___1 = strcasecmp(arg, "on");
  if (tmp___1 == 0) {
    d->enable_sendfile = 1U;
  } else {
    tmp___0 = strcasecmp(arg, "off");
    if (tmp___0 == 0) {
      d->enable_sendfile = 0U;
    } else {
      return ("parameter must be \'on\' or \'off\'");
    }
  }
  return ((char const   *)((void *)0));
}
}
static char const   *satisfy(cmd_parms *cmd , void *c_ , char const   *arg ) 
{ core_dir_config *c ;
  int tmp ;
  int tmp___0 ;

  {
  c = (core_dir_config *)c_;
  tmp___0 = strcasecmp(arg, "all");
  if (tmp___0) {
    tmp = strcasecmp(arg, "any");
    if (tmp) {
      return ("Satisfy either \'any\' or \'all\'.");
    } else {
      c->satisfy = 1;
    }
  } else {
    c->satisfy = 0;
  }
  return ((char const   *)((void *)0));
}
}
static char const   *require(cmd_parms *cmd , void *c_ , char const   *arg ) 
{ require_line *r ;
  core_dir_config *c ;

  {
  c = (core_dir_config *)c_;
  if (! c->ap_requires) {
    c->ap_requires = apr_array_make(cmd->pool, 2, (int )sizeof(require_line ));
  }
  r = (require_line *)apr_array_push(c->ap_requires);
  r->requirement = apr_pstrdup(cmd->pool, arg);
  r->method_mask = cmd->limited;
  return ((char const   *)((void *)0));
}
}
char const   *ap_limit_section(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *limited_methods ;
  char const   *tmp ;
  void *tog ;
  apr_int64_t limited ;
  char const   *errmsg ;
  char const   *err ;
  char const   *tmp___0 ;
  char *method ;
  char *tmp___1 ;
  int methnum ;

  {
  tmp = ap_getword(cmd->pool, & arg, (char )'>');
  limited_methods = tmp;
  tog = (cmd->cmd)->cmd_data;
  limited = 0LL;
  tmp___0 = ap_check_cmd_context(cmd, 2U);
  err = tmp___0;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  while ((*(limited_methods + 0))) {
    tmp___1 = ap_getword_conf(cmd->pool, & limited_methods);
    method = tmp___1;
    methnum = ap_method_number_of((char const   *)method);
    if (methnum == 6) {
      if (! tog) {
        return ("TRACE cannot be controlled by <Limit>");
      } else {
        goto _L;
      }
    } else {
      _L: 
      if (methnum == 26) {
        methnum = ap_method_register(cmd->pool, (char const   *)method);
      }
    }
    limited |= 1LL << methnum;
  }
  if (tog) {
    cmd->limited = ~ limited;
  } else {
    cmd->limited = limited;
  }
  errmsg = ap_walk_config((cmd->directive)->first_child, cmd, cmd->context);
  cmd->limited = -1LL;
  return (errmsg);
}
}
static char *unclosed_directive(cmd_parms *cmd ) 
{ char *tmp ;

  {
  tmp = apr_pstrcat(cmd->pool, (cmd->cmd)->name, "> directive missing closing \'>\'",
                    (void *)0);
  return (tmp);
}
}
static char const   *dirsection(cmd_parms *cmd , void *mconfig , char const   *arg ) 
{ char const   *errmsg ;
  char const   *endp ;
  char const   *tmp ;
  int old_overrides ;
  char *old_path ;
  core_dir_config *conf ;
  ap_conf_vector_t *new_dir_conf ;
  ap_conf_vector_t *tmp___0 ;
  regex_t *r ;
  command_rec const   *thiscmd ;
  char const   *err ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *newpath ;
  apr_status_t rv ;
  apr_status_t tmp___3 ;
  char const   *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;

  {
  tmp = strrchr(arg, '>');
  endp = tmp;
  old_overrides = cmd->override;
  old_path = cmd->path;
  tmp___0 = ap_create_per_dir_config(cmd->pool);
  new_dir_conf = tmp___0;
  r = (regex_t *)((void *)0);
  thiscmd = cmd->cmd;
  tmp___1 = ap_check_cmd_context(cmd, 30U);
  err = tmp___1;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  if ((unsigned int )endp == (unsigned int )((void *)0)) {
    tmp___2 = unclosed_directive(cmd);
    return (tmp___2);
  }
  arg = apr_pstrndup(cmd->pool, arg, (unsigned int )(endp - arg));
  if (! arg) {
    if (thiscmd->cmd_data) {
      return ("<DirectoryMatch > block must specify a path");
    } else {
      return ("<Directory > block must specify a path");
    }
  }
  cmd->path = ap_getword_conf(cmd->pool, & arg);
  cmd->override = 95;
  tmp___8 = strcmp((char const   *)cmd->path, "~");
  if (tmp___8) {
    if (thiscmd->cmd_data) {
      r = ap_pregcomp(cmd->pool, (char const   *)cmd->path, 0);
    } else {
      tmp___6 = strcmp((char const   *)cmd->path, "/");
      if (tmp___6) {
        tmp___7 = 0;
      } else {
        tmp___7 = 1;
      }
      if (tmp___7 == 0) {
        tmp___3 = apr_filepath_merge(& newpath, (char const   *)((void *)0), (char const   *)cmd->path,
                                     32, cmd->pool);
        rv = tmp___3;
        if (rv != 0) {
          if (rv != 20025) {
            tmp___4 = apr_pstrcat(cmd->pool, "<Directory \"", cmd->path, "\"> path is invalid.",
                                  (void *)0);
            return (tmp___4);
          } else {
            goto _L;
          }
        } else {
          _L: ;
        }
        cmd->path = newpath;
        tmp___5 = strlen((char const   *)cmd->path);
        if ((int )(*(cmd->path + (tmp___5 - 1U))) != 47) {
          cmd->path = apr_pstrcat(cmd->pool, cmd->path, "/", (void *)0);
        }
      }
    }
  } else {
    cmd->path = ap_getword_conf(cmd->pool, & arg);
    if (! cmd->path) {
      return ("<Directory ~ > block must specify a path");
    }
    r = ap_pregcomp(cmd->pool, (char const   *)cmd->path, 0);
  }
  conf = (core_dir_config *)ap_set_config_vectors(cmd->server, new_dir_conf, (char const   *)cmd->path,
                                                  & core_module, cmd->pool);
  errmsg = ap_walk_config((cmd->directive)->first_child, cmd, new_dir_conf);
  if ((unsigned int )errmsg != (unsigned int )((void *)0)) {
    return (errmsg);
  }
  conf->r = r;
  conf->d = cmd->path;
  tmp___9 = apr_fnmatch_test((char const   *)conf->d);
  conf->d_is_fnmatch = (unsigned int )(tmp___9 != 0);
  tmp___10 = strcmp((char const   *)conf->d, "/");
  if (tmp___10 == 0) {
    conf->d_components = 0U;
  } else {
    conf->d_components = (unsigned int )ap_count_dirs((char const   *)conf->d);
  }
  ap_add_per_dir_conf(cmd->server, (void *)new_dir_conf);
  if ((int const   )(*arg) != 0) {
    tmp___11 = apr_pstrcat(cmd->pool, "Multiple ", thiscmd->name, "> arguments not (yet) supported.",
                           (void *)0);
    return (tmp___11);
  }
  cmd->path = old_path;
  cmd->override = old_overrides;
  return ((char const   *)((void *)0));
}
}
static char const   *urlsection(cmd_parms *cmd , void *mconfig , char const   *arg ) 
{ char const   *errmsg ;
  char const   *endp ;
  char const   *tmp ;
  int old_overrides ;
  char *old_path ;
  core_dir_config *conf ;
  regex_t *r ;
  command_rec const   *thiscmd ;
  ap_conf_vector_t *new_url_conf ;
  ap_conf_vector_t *tmp___0 ;
  char const   *err ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
  tmp = strrchr(arg, '>');
  endp = tmp;
  old_overrides = cmd->override;
  old_path = cmd->path;
  r = (regex_t *)((void *)0);
  thiscmd = cmd->cmd;
  tmp___0 = ap_create_per_dir_config(cmd->pool);
  new_url_conf = tmp___0;
  tmp___1 = ap_check_cmd_context(cmd, 30U);
  err = tmp___1;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  if ((unsigned int )endp == (unsigned int )((void *)0)) {
    tmp___2 = unclosed_directive(cmd);
    return (tmp___2);
  }
  arg = apr_pstrndup(cmd->pool, arg, (unsigned int )(endp - arg));
  cmd->path = ap_getword_conf(cmd->pool, & arg);
  cmd->override = 95;
  if (thiscmd->cmd_data) {
    r = ap_pregcomp(cmd->pool, (char const   *)cmd->path, 0);
  } else {
    tmp___3 = strcmp((char const   *)cmd->path, "~");
    if (! tmp___3) {
      cmd->path = ap_getword_conf(cmd->pool, & arg);
      r = ap_pregcomp(cmd->pool, (char const   *)cmd->path, 0);
    }
  }
  conf = (core_dir_config *)ap_set_config_vectors(cmd->server, new_url_conf, (char const   *)cmd->path,
                                                  & core_module, cmd->pool);
  errmsg = ap_walk_config((cmd->directive)->first_child, cmd, new_url_conf);
  if ((unsigned int )errmsg != (unsigned int )((void *)0)) {
    return (errmsg);
  }
  conf->d = apr_pstrdup(cmd->pool, (char const   *)cmd->path);
  tmp___4 = apr_fnmatch_test((char const   *)conf->d);
  conf->d_is_fnmatch = (unsigned int )(tmp___4 != 0);
  conf->r = r;
  ap_add_per_url_conf(cmd->server, (void *)new_url_conf);
  if ((int const   )(*arg) != 0) {
    tmp___5 = apr_pstrcat(cmd->pool, "Multiple ", thiscmd->name, "> arguments not (yet) supported.",
                          (void *)0);
    return (tmp___5);
  }
  cmd->path = old_path;
  cmd->override = old_overrides;
  return ((char const   *)((void *)0));
}
}
static char const   *filesection(cmd_parms *cmd , void *mconfig , char const   *arg ) 
{ char const   *errmsg ;
  char const   *endp ;
  char const   *tmp ;
  int old_overrides ;
  char *old_path ;
  core_dir_config *conf ;
  regex_t *r ;
  command_rec const   *thiscmd ;
  core_dir_config *c ;
  ap_conf_vector_t *new_file_conf ;
  ap_conf_vector_t *tmp___0 ;
  char const   *err ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *newpath ;
  char const   *tmp___3 ;
  apr_status_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;

  {
  tmp = strrchr(arg, '>');
  endp = tmp;
  old_overrides = cmd->override;
  old_path = cmd->path;
  r = (regex_t *)((void *)0);
  thiscmd = cmd->cmd;
  c = (core_dir_config *)mconfig;
  tmp___0 = ap_create_per_dir_config(cmd->pool);
  new_file_conf = tmp___0;
  tmp___1 = ap_check_cmd_context(cmd, 10U);
  err = tmp___1;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  if ((unsigned int )endp == (unsigned int )((void *)0)) {
    tmp___2 = unclosed_directive(cmd);
    return (tmp___2);
  }
  arg = apr_pstrndup(cmd->pool, arg, (unsigned int )(endp - arg));
  cmd->path = ap_getword_conf(cmd->pool, & arg);
  if (! old_path) {
    cmd->override = 95;
  }
  if (thiscmd->cmd_data) {
    r = ap_pregcomp(cmd->pool, (char const   *)cmd->path, 0);
  } else {
    tmp___5 = strcmp((char const   *)cmd->path, "~");
    if (tmp___5) {
      tmp___4 = apr_filepath_merge(& newpath, "", (char const   *)cmd->path, 0, cmd->pool);
      if (tmp___4 != 0) {
        tmp___3 = apr_pstrcat(cmd->pool, "<Files \"", cmd->path, "\"> is invalid.",
                              (void *)0);
        return (tmp___3);
      }
      cmd->path = newpath;
    } else {
      cmd->path = ap_getword_conf(cmd->pool, & arg);
      r = ap_pregcomp(cmd->pool, (char const   *)cmd->path, 0);
    }
  }
  conf = (core_dir_config *)ap_set_config_vectors(cmd->server, new_file_conf, (char const   *)cmd->path,
                                                  & core_module, cmd->pool);
  errmsg = ap_walk_config((cmd->directive)->first_child, cmd, new_file_conf);
  if ((unsigned int )errmsg != (unsigned int )((void *)0)) {
    return (errmsg);
  }
  conf->d = cmd->path;
  tmp___6 = apr_fnmatch_test((char const   *)conf->d);
  conf->d_is_fnmatch = (unsigned int )(tmp___6 != 0);
  conf->r = r;
  ap_add_file_conf(c, (void *)new_file_conf);
  if ((int const   )(*arg) != 0) {
    tmp___7 = apr_pstrcat(cmd->pool, "Multiple ", thiscmd->name, "> arguments not (yet) supported.",
                          (void *)0);
    return (tmp___7);
  }
  cmd->path = old_path;
  cmd->override = old_overrides;
  return ((char const   *)((void *)0));
}
}
static char const   *start_ifmod(cmd_parms *cmd , void *mconfig , char const   *arg ) 
{ char const   *endp ;
  char const   *tmp ;
  int not ;
  module *found ;
  char const   *tmp___0 ;
  ap_directive_t *parent ;
  ap_directive_t *current ;
  char const   *retval ;
  char const   *tmp___1 ;

  {
  tmp = strrchr(arg, '>');
  endp = tmp;
  not = (int const   )(*(arg + 0)) == 33;
  if ((unsigned int )endp == (unsigned int )((void *)0)) {
    tmp___0 = unclosed_directive(cmd);
    return (tmp___0);
  }
  arg = apr_pstrndup(cmd->pool, arg, (unsigned int )(endp - arg));
  if (not) {
    arg ++;
  }
  found = ap_find_linked_module(arg);
  if (! not) {
    if (found) {
      goto _L;
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    if (not) {
      if (! found) {
        _L: 
        parent = (ap_directive_t *)((void *)0);
        current = (ap_directive_t *)((void *)0);
        retval = ap_build_cont_config(cmd->pool, cmd->temp_pool, cmd, & current, & parent,
                                      (char *)"<IfModule");
        (*((ap_directive_t **)mconfig)) = current;
        return (retval);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      (*((ap_directive_t **)mconfig)) = (ap_directive_t *)((void *)0);
      tmp___1 = ap_soak_end_container(cmd, (char *)"<IfModule");
      return (tmp___1);
    }
  }
}
}
int ap_exists_config_define(char const   *name ) 
{ char **defines ;
  int i ;
  int tmp ;

  {
  defines = (char **)ap_server_config_defines->elts;
  i = 0;
  while (i < ap_server_config_defines->nelts) {
    tmp = strcmp((char const   *)(*(defines + i)), name);
    if (tmp == 0) {
      return (1);
    }
    i ++;
  }
  return (0);
}
}
static char const   *start_ifdefine(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *endp ;
  int defined ;
  int not ;
  char const   *tmp ;
  ap_directive_t *parent ;
  ap_directive_t *current ;
  char const   *retval ;
  char const   *tmp___0 ;

  {
  not = 0;
  endp = strrchr(arg, '>');
  if ((unsigned int )endp == (unsigned int )((void *)0)) {
    tmp = unclosed_directive(cmd);
    return (tmp);
  }
  arg = apr_pstrndup(cmd->pool, arg, (unsigned int )(endp - arg));
  if ((int const   )(*(arg + 0)) == 33) {
    not = 1;
    arg ++;
  }
  defined = ap_exists_config_define(arg);
  if (! not) {
    if (defined) {
      goto _L;
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    if (not) {
      if (! defined) {
        _L: 
        parent = (ap_directive_t *)((void *)0);
        current = (ap_directive_t *)((void *)0);
        retval = ap_build_cont_config(cmd->pool, cmd->temp_pool, cmd, & current, & parent,
                                      (char *)"<IfDefine");
        (*((ap_directive_t **)dummy)) = current;
        return (retval);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      (*((ap_directive_t **)dummy)) = (ap_directive_t *)((void *)0);
      tmp___0 = ap_soak_end_container(cmd, (char *)"<IfDefine");
      return (tmp___0);
    }
  }
}
}
static char const   *virtualhost_section(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ server_rec *main_server ;
  server_rec *s ;
  char const   *errmsg ;
  char const   *endp ;
  char const   *tmp ;
  apr_pool_t *p ;
  char const   *err ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  main_server = cmd->server;
  tmp = strrchr(arg, '>');
  endp = tmp;
  p = cmd->pool;
  tmp___0 = ap_check_cmd_context(cmd, 31U);
  err = tmp___0;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  if ((unsigned int )endp == (unsigned int )((void *)0)) {
    tmp___1 = unclosed_directive(cmd);
    return (tmp___1);
  }
  arg = apr_pstrndup(cmd->pool, arg, (unsigned int )(endp - arg));
  if (main_server->is_virtual) {
    return ("<VirtualHost> doesn\'t nest!");
  }
  errmsg = ap_init_virtual_host(p, arg, main_server, & s);
  if (errmsg) {
    return (errmsg);
  }
  s->next = main_server->next;
  main_server->next = s;
  s->defn_name = (cmd->directive)->filename;
  s->defn_line_number = (unsigned int )(cmd->directive)->line_num;
  cmd->server = s;
  errmsg = ap_walk_config((cmd->directive)->first_child, cmd, s->lookup_defaults);
  cmd->server = main_server;
  return (errmsg);
}
}
static char const   *set_server_alias(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char **item ;
  char *name ;
  char *tmp ;
  int tmp___2 ;

  {
  if (! (cmd->server)->names) {
    return ("ServerAlias only used in <VirtualHost>");
  }
  while ((*arg)) {
    tmp = ap_getword_conf(cmd->pool, & arg);
    name = tmp;
    tmp___2 = ap_is_matchexp((char const   *)name);
    if (tmp___2) {
      item = (char **)apr_array_push((cmd->server)->wild_names);
    } else {
      item = (char **)apr_array_push((cmd->server)->names);
    }
    (*item) = name;
  }
  return ((char const   *)((void *)0));
}
}
static char const   *set_server_string_slot(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ int offset ;
  char *struct_ptr ;
  char const   *err ;
  char const   *tmp ;

  {
  offset = (int )((long )cmd->info);
  struct_ptr = (char *)cmd->server;
  tmp = ap_check_cmd_context(cmd, 30U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  (*((char const   **)(struct_ptr + offset))) = arg;
  return ((char const   *)((void *)0));
}
}
static char const   *server_hostname_port(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;
  char const   *portstr ;
  int port ;
  char const   *tmp___0 ;

  {
  tmp = ap_check_cmd_context(cmd, 30U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  portstr = strchr(arg, ':');
  if (portstr) {
    (cmd->server)->server_hostname = apr_pstrndup(cmd->pool, arg, (unsigned int )(portstr -
                                                                                  arg));
    portstr ++;
    port = atoi(portstr);
    if (port <= 0) {
      goto _L;
    } else {
      if (port >= 65536) {
        _L: 
        tmp___0 = apr_pstrcat(cmd->temp_pool, "The port number \"", arg, "\" is outside the appropriate range (i.e., 1..65535).",
                              (void *)0);
        return (tmp___0);
      }
    }
  } else {
    (cmd->server)->server_hostname = apr_pstrdup(cmd->pool, arg);
    port = 0;
  }
  (cmd->server)->port = (unsigned short )port;
  return ((char const   *)((void *)0));
}
}
static char const   *set_signature_flag(cmd_parms *cmd , void *d_ , char const   *arg ) 
{ core_dir_config *d ;
  char const   *err ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  d = (core_dir_config *)d_;
  tmp = ap_check_cmd_context(cmd, 2U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  tmp___2 = strcasecmp(arg, "On");
  if (tmp___2 == 0) {
    d->server_signature = (enum __anonenum_server_signature_e_74 )2;
  } else {
    tmp___1 = strcasecmp(arg, "Off");
    if (tmp___1 == 0) {
      d->server_signature = (enum __anonenum_server_signature_e_74 )1;
    } else {
      tmp___0 = strcasecmp(arg, "EMail");
      if (tmp___0 == 0) {
        d->server_signature = (enum __anonenum_server_signature_e_74 )3;
      } else {
        return ("ServerSignature: use one of: off | on | email");
      }
    }
  }
  return ((char const   *)((void *)0));
}
}
static char const   *set_server_root(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;
  apr_status_t tmp___0 ;
  int tmp___1 ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  tmp___0 = apr_filepath_merge((char **)(& ap_server_root), (char const   *)((void *)0),
                               arg, 32, cmd->pool);
  if (tmp___0 != 0) {
    goto _L;
  } else {
    tmp___1 = ap_is_directory(cmd->pool, ap_server_root);
    if (! tmp___1) {
      _L: 
      return ("ServerRoot must be a valid directory");
    }
  }
  return ((char const   *)((void *)0));
}
}
static char const   *set_timeout(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;
  int tmp___0 ;

  {
  tmp = ap_check_cmd_context(cmd, 30U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  tmp___0 = atoi(arg);
  (cmd->server)->timeout = (long long )tmp___0 * 1000000LL;
  return ((char const   *)((void *)0));
}
}
static char const   *set_idcheck(cmd_parms *cmd , void *d_ , int arg ) 
{ core_dir_config *d ;
  char const   *err ;
  char const   *tmp ;

  {
  d = (core_dir_config *)d_;
  tmp = ap_check_cmd_context(cmd, 2U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  d->do_rfc1413 = arg != 0;
  return ((char const   *)((void *)0));
}
}
static char const   *set_hostname_lookups(cmd_parms *cmd , void *d_ , char const   *arg ) 
{ core_dir_config *d ;
  char const   *err ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  d = (core_dir_config *)d_;
  tmp = ap_check_cmd_context(cmd, 2U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  tmp___2 = strcasecmp(arg, "on");
  if (tmp___2) {
    tmp___1 = strcasecmp(arg, "off");
    if (tmp___1) {
      tmp___0 = strcasecmp(arg, "double");
      if (tmp___0) {
        return ("parameter must be \'on\', \'off\', or \'double\'");
      } else {
        d->hostname_lookups = 2U;
      }
    } else {
      d->hostname_lookups = 0U;
    }
  } else {
    d->hostname_lookups = 1U;
  }
  return ((char const   *)((void *)0));
}
}
static char const   *set_serverpath(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;

  {
  tmp = ap_check_cmd_context(cmd, 30U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  (cmd->server)->path = arg;
  (cmd->server)->pathlen = (int )strlen(arg);
  return ((char const   *)((void *)0));
}
}
static char const   *set_content_md5(cmd_parms *cmd , void *d_ , int arg ) 
{ core_dir_config *d ;
  char const   *err ;
  char const   *tmp ;

  {
  d = (core_dir_config *)d_;
  tmp = ap_check_cmd_context(cmd, 2U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  d->content_md5 = arg != 0;
  return ((char const   *)((void *)0));
}
}
static char const   *set_accept_path_info(cmd_parms *cmd , void *d_ , char const   *arg ) 
{ core_dir_config *d ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  d = (core_dir_config *)d_;
  tmp___1 = strcasecmp(arg, "on");
  if (tmp___1 == 0) {
    d->accept_path_info = 0;
  } else {
    tmp___0 = strcasecmp(arg, "off");
    if (tmp___0 == 0) {
      d->accept_path_info = 1;
    } else {
      tmp = strcasecmp(arg, "default");
      if (tmp == 0) {
        d->accept_path_info = 2;
      } else {
        return ("AcceptPathInfo must be set to on, off or default");
      }
    }
  }
  return ((char const   *)((void *)0));
}
}
static char const   *set_use_canonical_name(cmd_parms *cmd , void *d_ , char const   *arg ) 
{ core_dir_config *d ;
  char const   *err ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  d = (core_dir_config *)d_;
  tmp = ap_check_cmd_context(cmd, 2U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  tmp___2 = strcasecmp(arg, "on");
  if (tmp___2 == 0) {
    d->use_canonical_name = 1U;
  } else {
    tmp___1 = strcasecmp(arg, "off");
    if (tmp___1 == 0) {
      d->use_canonical_name = 0U;
    } else {
      tmp___0 = strcasecmp(arg, "dns");
      if (tmp___0 == 0) {
        d->use_canonical_name = 2U;
      } else {
        return ("parameter must be \'on\', \'off\', or \'dns\'");
      }
    }
  }
  return ((char const   *)((void *)0));
}
}
static char const   *include_config(cmd_parms *cmd , void *dummy , char const   *name ) 
{ ap_directive_t *conftree ;
  char const   *conffile ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  conftree = (ap_directive_t *)((void *)0);
  tmp = ap_server_root_relative(cmd->pool, name);
  conffile = tmp;
  if (! conffile) {
    tmp___0 = apr_pstrcat(cmd->pool, "Invalid Include path ", name, (void *)0);
    return (tmp___0);
  }
  ap_process_resource_config(cmd->server, conffile, & conftree, cmd->pool, cmd->temp_pool);
  (*((ap_directive_t **)dummy)) = conftree;
  return ((char const   *)((void *)0));
}
}
static char const   *set_loglevel(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char *str ;
  char const   *err ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  tmp = ap_check_cmd_context(cmd, 30U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  str = ap_getword_conf(cmd->pool, & arg);
  if (str) {
    tmp___7 = strcasecmp((char const   *)str, "emerg");
    if (tmp___7) {
      tmp___6 = strcasecmp((char const   *)str, "alert");
      if (tmp___6) {
        tmp___5 = strcasecmp((char const   *)str, "crit");
        if (tmp___5) {
          tmp___4 = strcasecmp((char const   *)str, "error");
          if (tmp___4) {
            tmp___3 = strcasecmp((char const   *)str, "warn");
            if (tmp___3) {
              tmp___2 = strcasecmp((char const   *)str, "notice");
              if (tmp___2) {
                tmp___1 = strcasecmp((char const   *)str, "info");
                if (tmp___1) {
                  tmp___0 = strcasecmp((char const   *)str, "debug");
                  if (tmp___0) {
                    return ("LogLevel requires level keyword: one of emerg/alert/crit/error/warn/notice/info/debug");
                  } else {
                    (cmd->server)->loglevel = 7;
                  }
                } else {
                  (cmd->server)->loglevel = 6;
                }
              } else {
                (cmd->server)->loglevel = 5;
              }
            } else {
              (cmd->server)->loglevel = 4;
            }
          } else {
            (cmd->server)->loglevel = 3;
          }
        } else {
          (cmd->server)->loglevel = 2;
        }
      } else {
        (cmd->server)->loglevel = 1;
      }
    } else {
      (cmd->server)->loglevel = 0;
    }
  } else {
    return ("LogLevel requires level keyword");
  }
  return ((char const   *)((void *)0));
}
}
char const   *ap_psignature(char const   *prefix , request_rec *r ) 
{ char sport[20] ;
  core_dir_config *conf ;
  apr_port_t tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;

  {
  conf = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  if ((int )conf->server_signature == 1) {
    goto _L;
  } else {
    if ((int )conf->server_signature == 0) {
      _L: 
      return ("");
    }
  }
  tmp = ap_get_server_port((request_rec const   *)r);
  apr_snprintf(sport, sizeof(sport), "%u", (unsigned int )tmp);
  if ((int )conf->server_signature == 3) {
    tmp___0 = ap_get_server_name(r);
    tmp___1 = ap_escape_html(r->pool, tmp___0);
    tmp___2 = ap_get_server_version();
    tmp___3 = apr_pstrcat(r->pool, prefix, "<address>", tmp___2, " Server at <a href=\"mailto:",
                          (r->server)->server_admin, "\">", tmp___1, "</a> Port ",
                          sport, "</address>\n", (void *)0);
    return (tmp___3);
  }
  tmp___4 = ap_get_server_name(r);
  tmp___5 = ap_escape_html(r->pool, tmp___4);
  tmp___6 = ap_get_server_version();
  tmp___7 = apr_pstrcat(r->pool, prefix, "<address>", tmp___6, " Server at ", tmp___5,
                        " Port ", sport, "</address>\n", (void *)0);
  return (tmp___7);
}
}
static char const   *set_authname(cmd_parms *cmd , void *mconfig , char const   *word1 ) 
{ core_dir_config *aconfig ;

  {
  aconfig = (core_dir_config *)mconfig;
  aconfig->ap_auth_name = ap_escape_quotes(cmd->pool, word1);
  return ((char const   *)((void *)0));
}
}
static char *server_version  =    (char *)((void *)0);
static int version_locked  =    0;
static enum server_token_type ap_server_tokens  =    (enum server_token_type )4;
static apr_status_t reset_version(void *dummy ) 
{ 

  {
  version_locked = 0;
  ap_server_tokens = (enum server_token_type )4;
  server_version = (char *)((void *)0);
  return (0);
}
}
char const   *ap_get_server_version(void) 
{ char const   *tmp ;

  {
  if (server_version) {
    tmp = (char const   *)server_version;
  } else {
    tmp = "Apache/2.0.44";
  }
  return (tmp);
}
}
void ap_add_version_component(apr_pool_t *pconf___0 , char const   *component ) 
{ 

  {
  if (! version_locked) {
    if ((unsigned int )server_version == (unsigned int )((void *)0)) {
      apr_pool_cleanup_register(pconf___0, (void const   *)((void *)0), & reset_version,
                                & apr_pool_cleanup_null);
      server_version = apr_pstrdup(pconf___0, component);
    } else {
      server_version = apr_pstrcat(pconf___0, server_version, " ", component, (void *)0);
    }
  }
  return;
}
}
static void ap_set_version(apr_pool_t *pconf___0 ) 
{ 

  {
  if ((int )ap_server_tokens == 5) {
    ap_add_version_component(pconf___0, "Apache");
  } else {
    if ((int )ap_server_tokens == 2) {
      ap_add_version_component(pconf___0, "Apache/2.0.44");
    } else {
      if ((int )ap_server_tokens == 1) {
        ap_add_version_component(pconf___0, "Apache/2.0");
      } else {
        if ((int )ap_server_tokens == 0) {
          ap_add_version_component(pconf___0, "Apache/2");
        } else {
          ap_add_version_component(pconf___0, "Apache/2.0.44 (Unix)");
        }
      }
    }
  }
  if ((int )ap_server_tokens != 4) {
    version_locked ++;
  }
  return;
}
}
static char const   *set_serv_tokens(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  tmp___6 = strcasecmp(arg, "OS");
  if (tmp___6) {
    tmp___4 = strcasecmp(arg, "Min");
    if (tmp___4) {
      tmp___5 = strcasecmp(arg, "Minimal");
      if (tmp___5) {
        tmp___3 = strcasecmp(arg, "Major");
        if (tmp___3) {
          tmp___2 = strcasecmp(arg, "Minor");
          if (tmp___2) {
            tmp___0 = strcasecmp(arg, "Prod");
            if (tmp___0) {
              tmp___1 = strcasecmp(arg, "ProductOnly");
              if (tmp___1) {
                ap_server_tokens = (enum server_token_type )4;
              } else {
                _L: 
                ap_server_tokens = (enum server_token_type )5;
              }
            } else {
              goto _L;
            }
          } else {
            ap_server_tokens = (enum server_token_type )1;
          }
        } else {
          ap_server_tokens = (enum server_token_type )0;
        }
      } else {
        _L___0: 
        ap_server_tokens = (enum server_token_type )2;
      }
    } else {
      goto _L___0;
    }
  } else {
    ap_server_tokens = (enum server_token_type )3;
  }
  return ((char const   *)((void *)0));
}
}
static char const   *set_limit_req_line(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;
  int lim ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  tmp = ap_check_cmd_context(cmd, 30U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  lim = atoi(arg);
  if (lim < 0) {
    tmp___0 = apr_pstrcat(cmd->temp_pool, "LimitRequestLine \"", arg, "\" must be a non-negative integer",
                          (void *)0);
    return (tmp___0);
  }
  if (lim > 8190) {
    tmp___1 = apr_psprintf(cmd->temp_pool, "LimitRequestLine \"%s\" must not exceed the precompiled maximum of %d",
                           arg, 8190);
    return (tmp___1);
  }
  (cmd->server)->limit_req_line = lim;
  return ((char const   *)((void *)0));
}
}
static char const   *set_limit_req_fieldsize(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;
  int lim ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  tmp = ap_check_cmd_context(cmd, 30U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  lim = atoi(arg);
  if (lim < 0) {
    tmp___0 = apr_pstrcat(cmd->temp_pool, "LimitRequestFieldsize \"", arg, "\" must be a non-negative integer (0 = no limit)",
                          (void *)0);
    return (tmp___0);
  }
  if (lim > 8190) {
    tmp___1 = apr_psprintf(cmd->temp_pool, "LimitRequestFieldsize \"%s\" must not exceed the precompiled maximum of %d",
                           arg, 8190);
    return (tmp___1);
  }
  (cmd->server)->limit_req_fieldsize = lim;
  return ((char const   *)((void *)0));
}
}
static char const   *set_limit_req_fields(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;
  int lim ;
  char const   *tmp___0 ;

  {
  tmp = ap_check_cmd_context(cmd, 30U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  lim = atoi(arg);
  if (lim < 0) {
    tmp___0 = apr_pstrcat(cmd->temp_pool, "LimitRequestFields \"", arg, "\" must be a non-negative integer (0 = no limit)",
                          (void *)0);
    return (tmp___0);
  }
  (cmd->server)->limit_req_fields = lim;
  return ((char const   *)((void *)0));
}
}
static char const   *set_limit_req_body(cmd_parms *cmd , void *conf_ , char const   *arg ) 
{ core_dir_config *conf ;
  char const   *err ;
  char const   *tmp ;
  char *errp ;
  long tmp___0 ;

  {
  conf = (core_dir_config *)conf_;
  tmp = ap_check_cmd_context(cmd, 2U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  tmp___0 = strtol((char const   * __restrict  )arg, (char ** __restrict  )(& errp),
                   10);
  conf->limit_req_body = tmp___0;
  if ((int )(*errp) != 0) {
    return ("LimitRequestBody requires a non-negative integer.");
  }
  return ((char const   *)((void *)0));
}
}
static char const   *set_limit_xml_req_body(cmd_parms *cmd , void *conf_ , char const   *arg ) 
{ core_dir_config *conf ;
  char const   *err ;
  char const   *tmp ;

  {
  conf = (core_dir_config *)conf_;
  tmp = ap_check_cmd_context(cmd, 2U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  conf->limit_xml_body = atol(arg);
  if (conf->limit_xml_body < 0L) {
    return ("LimitXMLRequestBody requires a non-negative integer.");
  }
  return ((char const   *)((void *)0));
}
}
size_t ap_get_limit_xml_body(request_rec const   *r ) 
{ core_dir_config *conf ;

  {
  conf = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  if (conf->limit_xml_body == -1L) {
    return (1000000U);
  }
  return ((unsigned int )conf->limit_xml_body);
}
}
static char const   *set_limit_cpu(cmd_parms *cmd , void *conf_ , char const   *arg ,
                                   char const   *arg2 ) 
{ core_dir_config *conf ;

  {
  conf = (core_dir_config *)conf_;
  unixd_set_rlimit(cmd, & conf->limit_cpu, arg, arg2, 0);
  return ((char const   *)((void *)0));
}
}
static char const   *set_limit_mem(cmd_parms *cmd , void *conf_ , char const   *arg ,
                                   char const   *arg2 ) 
{ core_dir_config *conf ;

  {
  conf = (core_dir_config *)conf_;
  unixd_set_rlimit(cmd, & conf->limit_mem, arg, arg2, 9);
  return ((char const   *)((void *)0));
}
}
static char const   *set_limit_nproc(cmd_parms *cmd , void *conf_ , char const   *arg ,
                                     char const   *arg2 ) 
{ core_dir_config *conf ;

  {
  conf = (core_dir_config *)conf_;
  unixd_set_rlimit(cmd, & conf->limit_nproc, arg, arg2, 6);
  return ((char const   *)((void *)0));
}
}
static char const   *add_ct_output_filters(cmd_parms *cmd , void *conf_ , char const   *arg ,
                                           char const   *arg2 ) 
{ core_dir_config *conf ;
  ap_filter_rec_t *old ;
  ap_filter_rec_t *new ;
  char const   *filter_name ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  conf = (core_dir_config *)conf_;
  new = (ap_filter_rec_t *)((void *)0);
  if (! conf->ct_output_filters) {
    conf->ct_output_filters = apr_hash_make(cmd->pool);
    old = (ap_filter_rec_t *)((void *)0);
  } else {
    old = (ap_filter_rec_t *)apr_hash_get(conf->ct_output_filters, (void const   *)arg2,
                                          -1);
  }
  while (1) {
    if ((*arg)) {
      filter_name = ap_getword(cmd->pool, & arg, (char )';');
      if (filter_name) {
        tmp___1 = strcmp(filter_name, "");
        if (! tmp___1) {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      break;
    }
    tmp___0 = apr_palloc(cmd->pool, sizeof(ap_filter_rec_t ));
    new = (ap_filter_rec_t *)memset(tmp___0, 0, sizeof(ap_filter_rec_t ));
    new->name = filter_name;
    if (old) {
      new->next = old;
    }
    old = new;
  }
  if (! new) {
    return ("invalid filter name");
  }
  apr_hash_set(conf->ct_output_filters, (void const   *)arg2, -1, (void const   *)new);
  return ((char const   *)((void *)0));
}
}
void ap_add_output_filters_by_type(request_rec *r ) 
{ core_dir_config *conf ;
  char const   *ctype ;
  char const   *ctypes ;
  ap_filter_rec_t *ct_filter ;

  {
  conf = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  if (r->proxyreq != 0) {
    goto _L___0;
  } else {
    if (! r->content_type) {
      _L___0: 
      goto _L;
    } else {
      if (! conf->ct_output_filters) {
        _L: 
        return;
      }
    }
  }
  ctypes = r->content_type;
  while (1) {
    if ((*ctypes)) {
      ctype = ap_getword(r->pool, & ctypes, (char )';');
      if (! ctype) {
        goto _L___1;
      }
    } else {
      _L___1: 
      break;
    }
    ct_filter = (ap_filter_rec_t *)apr_hash_get(conf->ct_output_filters, (void const   *)ctype,
                                                -1);
    while (ct_filter) {
      ap_add_output_filter(ct_filter->name, (void *)0, r, r->connection);
      ct_filter = ct_filter->next;
    }
  }
  return;
}
}
static apr_status_t writev_it_all(apr_socket_t *s , struct iovec *vec , int nvec ,
                                  apr_size_t len , apr_size_t *nbytes ) 
{ apr_size_t bytes_written ;
  apr_status_t rv ;
  apr_size_t n ;
  int i ;
  apr_size_t cnt ;

  {
  bytes_written = 0U;
  n = len;
  i = 0;
  (*nbytes) = 0U;
  while (bytes_written != len) {
    rv = apr_sendv(s, (struct iovec  const  *)(vec + i), nvec - i, & n);
    bytes_written += n;
    if (rv != 0) {
      return (rv);
    }
    (*nbytes) += n;
    if (bytes_written < len) {
      cnt = (vec + i)->iov_len;
      while (1) {
        if (n >= cnt) {
          if (! (i + 1 < nvec)) {
            goto _L;
          }
        } else {
          _L: 
          break;
        }
        i ++;
        cnt += (vec + i)->iov_len;
      }
      if (n < cnt) {
        (vec + i)->iov_base = (void *)((char *)(vec + i)->iov_base + ((vec + i)->iov_len -
                                                                      (cnt - n)));
        (vec + i)->iov_len = cnt - n;
      }
    }
    n = len - bytes_written;
  }
  return (0);
}
}
static apr_status_t sendfile_it_all(core_net_rec *c , apr_file_t *fd , apr_hdtr_t *hdtr ,
                                    apr_off_t file_offset , apr_size_t file_bytes_left ,
                                    apr_size_t total_bytes_left , apr_size_t *bytes_sent ,
                                    apr_int32_t flags ) 
{ apr_status_t rv ;
  apr_size_t tmplen ;
  char *iov_base ;
  char *iov_base___0 ;

  {
  (*bytes_sent) = 0U;
  while (1) {
    tmplen = file_bytes_left;
    rv = apr_sendfile(c->client_socket, fd, hdtr, & file_offset, & tmplen, flags);
    (*bytes_sent) += tmplen;
    total_bytes_left -= tmplen;
    if (! total_bytes_left) {
      goto _L;
    } else {
      if (rv != 0) {
        _L: 
        return (rv);
      }
    }
    while (1) {
      if (tmplen) {
        if (! hdtr->numheaders) {
          goto _L___0;
        }
      } else {
        _L___0: 
        break;
      }
      if (tmplen >= (hdtr->headers + 0)->iov_len) {
        tmplen -= (hdtr->headers + 0)->iov_len;
        hdtr->numheaders = hdtr->numheaders - 1;
        hdtr->headers = hdtr->headers + 1;
      } else {
        iov_base = (char *)(hdtr->headers + 0)->iov_base;
        (hdtr->headers + 0)->iov_len = (hdtr->headers + 0)->iov_len - tmplen;
        iov_base += tmplen;
        (hdtr->headers + 0)->iov_base = (void *)iov_base;
        tmplen = 0U;
      }
    }
    if (tmplen <= file_bytes_left) {
      file_offset = (long )((unsigned long )file_offset + (unsigned long )tmplen);
      file_bytes_left -= tmplen;
      goto __Cont;
    }
    tmplen -= file_bytes_left;
    file_bytes_left = 0U;
    file_offset = 0L;
    while (1) {
      if (tmplen) {
        if (! hdtr->numtrailers) {
          goto _L___1;
        }
      } else {
        _L___1: 
        break;
      }
      if (tmplen >= (hdtr->trailers + 0)->iov_len) {
        tmplen -= (hdtr->trailers + 0)->iov_len;
        hdtr->numtrailers = hdtr->numtrailers - 1;
        hdtr->trailers = hdtr->trailers + 1;
      } else {
        iov_base___0 = (char *)(hdtr->trailers + 0)->iov_base;
        (hdtr->trailers + 0)->iov_len = (hdtr->trailers + 0)->iov_len - tmplen;
        iov_base___0 += tmplen;
        (hdtr->trailers + 0)->iov_base = (void *)iov_base___0;
        tmplen = 0U;
      }
    }
    __Cont: ;
  }
  return (0);
}
}
static apr_status_t emulate_sendfile(core_net_rec *c , apr_file_t *fd , apr_hdtr_t *hdtr ,
                                     apr_off_t offset , apr_size_t length , apr_size_t *nbytes ) 
{ apr_status_t rv ;
  apr_int32_t togo ;
  apr_size_t sendlen ;
  apr_size_t bytes_sent ;
  apr_int32_t i ;
  apr_off_t o ;
  char buffer[8192] ;

  {
  rv = 0;
  sendlen = 0U;
  (*nbytes) = 0U;
  if (hdtr) {
    if (hdtr->numheaders > 0) {
      i = 0;
      while (i < hdtr->numheaders) {
        sendlen += (hdtr->headers + i)->iov_len;
        i ++;
      }
      rv = writev_it_all(c->client_socket, hdtr->headers, hdtr->numheaders, sendlen,
                         & bytes_sent);
      if (rv == 0) {
        (*nbytes) += bytes_sent;
      }
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if (offset != 0L) {
    if (rv == 0) {
      rv = apr_file_seek(fd, 0, & offset);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
  }
  togo = (int )length;
  while (1) {
    if (rv == 0) {
      if (! togo) {
        goto _L___2;
      }
    } else {
      _L___2: 
      break;
    }
    if ((unsigned int )togo > sizeof(buffer)) {
      sendlen = sizeof(buffer);
    } else {
      sendlen = (unsigned int )togo;
    }
    o = 0L;
    rv = apr_file_read(fd, (void *)(buffer), & sendlen);
    while (1) {
      if (rv == 0) {
        if (! sendlen) {
          goto _L___1;
        }
      } else {
        _L___1: 
        break;
      }
      bytes_sent = sendlen;
      rv = apr_send(c->client_socket, (char const   *)(& buffer[o]), & bytes_sent);
      if (rv == 0) {
        sendlen -= bytes_sent;
        o = (long )((unsigned long )o + (unsigned long )bytes_sent);
        (*nbytes) += bytes_sent;
        togo = (int )((unsigned int )togo - bytes_sent);
      }
    }
  }
  sendlen = 0U;
  if (rv == 0) {
    if (hdtr) {
      if (hdtr->numtrailers > 0) {
        i = 0;
        while (i < hdtr->numtrailers) {
          sendlen += (hdtr->trailers + i)->iov_len;
          i ++;
        }
        rv = writev_it_all(c->client_socket, hdtr->trailers, hdtr->numtrailers, sendlen,
                           & bytes_sent);
        if (rv == 0) {
          (*nbytes) += bytes_sent;
        }
      } else {
        goto _L___4;
      }
    } else {
      goto _L___4;
    }
  } else {
    _L___4: ;
  }
  return (rv);
}
}
static command_rec const   core_cmds[64]  = 
  {      {"<Directory", {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& dirsection)},
      (void *)0, 128, (enum cmd_how )0, "Container for directives affecting resources located in the specified directories"}, 
        {"<Location",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& urlsection)},
      (void *)0, 128, (enum cmd_how )0, "Container for directives affecting resources accessed through the specified URL paths"}, 
        {"<VirtualHost",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& virtualhost_section)},
      (void *)0, 128, (enum cmd_how )0, "Container to map directives to a particular virtual host, takes one or more host addresses"}, 
        {"<Files",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& filesection)},
      (void *)0, 31, (enum cmd_how )0, "Container for directives affecting files matching specified patterns"}, 
        {"<Limit",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& ap_limit_section)},
      (void *)0, 31, (enum cmd_how )0, "Container for authentication directives when accessed using specified HTTP methods"}, 
        {"<LimitExcept",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& ap_limit_section)},
      (void *)1, 31, (enum cmd_how )0, "Container for authentication directives to be applied when any HTTP method other than those specified is used to access the resource"}, 
        {"<IfModule",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& start_ifmod)},
      (void *)0, 287, (enum cmd_how )1, "Container for directives based on existance of specified modules"}, 
        {"<IfDefine",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& start_ifdefine)},
      (void *)0, 287, (enum cmd_how )1, "Container for directives based on existance of command line defines"}, 
        {"<DirectoryMatch",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& dirsection)},
      (void *)1, 128, (enum cmd_how )0, "Container for directives affecting resources located in the specified directories"}, 
        {"<LocationMatch",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& urlsection)},
      (void *)1, 128, (enum cmd_how )0, "Container for directives affecting resources accessed through the specified URL paths"}, 
        {"<FilesMatch",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& filesection)},
      (void *)1, 31, (enum cmd_how )0, "Container for directives affecting files matching specified patterns"}, 
        {"AuthType",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& ap_set_string_slot)},
      (void *)((long )((char *)(& ((core_dir_config *)((void *)0))->ap_auth_type) -
                       (char *)((void *)0))), 8, (enum cmd_how )1, "An HTTP authorization type (e.g., \"Basic\")"}, 
        {"AuthName",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_authname)},
      (void *)0, 8, (enum cmd_how )1, "The authentication realm (e.g. \"Members Only\")"}, 
        {"Require",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& require)},
      (void *)0, 8, (enum cmd_how )0, "Selects which authenticated users or groups may access a protected space"}, 
        {"Satisfy",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& satisfy)},
      (void *)0, 8, (enum cmd_how )1, "access policy if both allow and require used (\'all\' or \'any\')"}, 
        {"AddDefaultCharset",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_add_default_charset)},
      (void *)0, 4, (enum cmd_how )1, "The name of the default charset to add to any Content-Type without one or \'Off\' to disable"}, 
        {"AcceptPathInfo",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_accept_path_info)},
      (void *)0, 4, (enum cmd_how )1, "Set to on or off for PATH_INFO to be accepted by handlers, or default for the per-handler preference"}, 
        {"AccessFileName",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_access_name)},
      (void *)0, 128, (enum cmd_how )0, "Name(s) of per-directory config files (default: .htaccess)"}, 
        {"DocumentRoot",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_document_root)},
      (void *)0, 128, (enum cmd_how )1, "Root directory of the document tree"}, 
        {"ErrorDocument", {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_error_document)},
      (void *)0, 4, (enum cmd_how )2, "Change responses for HTTP errors"}, 
        {"AllowOverride", {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_override)},
      (void *)0, 64, (enum cmd_how )0, "Controls what groups of directives can be configured by per-directory config files"}, 
        {"Options",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_options)},
      (void *)0, 2, (enum cmd_how )0, "Set a number of attributes for a given directory"}, 
        {"DefaultType",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& ap_set_string_slot)},
      (void *)((long )((char *)(& ((core_dir_config *)((void *)0))->ap_default_type) -
                       (char *)((void *)0))), 4, (enum cmd_how )1, "the default MIME type for untypable files"}, 
        {"FileETag",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_etag_bits)},
      (void *)0, 4, (enum cmd_how )0, "Specify components used to construct a file\'s ETag"}, 
        {"EnableMMAP",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_enable_mmap)},
      (void *)0, 4, (enum cmd_how )1, "Controls whether memory-mapping may be used to read files"}, 
        {"EnableSendfile",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_enable_sendfile)},
      (void *)0, 4, (enum cmd_how )1, "Controls whether sendfile may be used to transmit files"}, 
        {"Port",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& ap_set_deprecated)},
      (void *)0, 128, (enum cmd_how )1, "Port was replaced with Listen in Apache 2.0"}, 
        {"HostnameLookups",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_hostname_lookups)},
      (void *)0, 192, (enum cmd_how )1, "\"on\" to enable, \"off\" to disable reverse DNS lookups, or \"double\" to enable double-reverse DNS lookups"}, 
        {"ServerAdmin",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_server_string_slot)},
      (void *)((long )((char *)(& ((server_rec *)((void *)0))->server_admin) - (char *)((void *)0))),
      128, (enum cmd_how )1, "The email address of the server administrator"}, 
        {"ServerName", {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& server_hostname_port)},
      (void *)0, 128, (enum cmd_how )1, "The hostname and port of the server"}, 
        {"ServerSignature", {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_signature_flag)},
      (void *)0, 31, (enum cmd_how )1, "En-/disable server signature (on|off|email)"}, 
        {"ServerRoot",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_server_root)},
      (void *)0, 384, (enum cmd_how )1, "Common directory of server-related files (logs, confs, etc.)"}, 
        {"ErrorLog",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_server_string_slot)},
      (void *)((long )((char *)(& ((server_rec *)((void *)0))->error_fname) - (char *)((void *)0))),
      128, (enum cmd_how )1, "The filename of the error log"}, 
        {"ServerAlias", {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_server_alias)},
      (void *)0, 128, (enum cmd_how )0, "A name or names alternately used to access the server"}, 
        {"ServerPath",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_serverpath)},
      (void *)0, 128, (enum cmd_how )1, "The pathname the server can be reached at"}, 
        {"Timeout",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_timeout)},
      (void *)0, 128, (enum cmd_how )1, "Timeout duration (sec)"}, 
        {"IdentityCheck", {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_idcheck)},
      (void *)0, 192, (enum cmd_how )5, "Enable identd (RFC 1413) user lookups - SLOW"}, 
        {"ContentDigest",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_content_md5)},
      (void *)0, 2, (enum cmd_how )5, "whether or not to send a Content-MD5 header with each request"}, 
        {"UseCanonicalName",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_use_canonical_name)},
      (void *)0, 192, (enum cmd_how )1, "How to work out the ServerName : Port when constructing URLs"}, 
        {"Include",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& include_config)},
      (void *)0, 448, (enum cmd_how )1, "Name of the config file to be included"}, 
        {"LogLevel",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_loglevel)},
      (void *)0, 128, (enum cmd_how )1, "Level of verbosity in error logging"}, 
        {"NameVirtualHost", {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& ap_set_name_virtual_host)},
      (void *)0, 128, (enum cmd_how )1, "A numeric IP address:port, or the name of a host"}, 
        {"ServerTokens",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_serv_tokens)},
      (void *)0, 128, (enum cmd_how )1, "Determine tokens displayed in the Server: header - Min(imal), OS or Full"}, 
        {"LimitRequestLine",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_limit_req_line)},
      (void *)0, 128, (enum cmd_how )1, "Limit on maximum size of an HTTP request line"}, 
        {"LimitRequestFieldsize",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_limit_req_fieldsize)},
      (void *)0, 128, (enum cmd_how )1, "Limit on maximum size of an HTTP request header field"}, 
        {"LimitRequestFields",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_limit_req_fields)},
      (void *)0, 128, (enum cmd_how )1, "Limit (0 = unlimited) on max number of header fields in a request message"}, 
        {"LimitRequestBody",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_limit_req_body)},
      (void *)((long )((char *)(& ((core_dir_config *)((void *)0))->limit_req_body) -
                       (char *)((void *)0))), 31, (enum cmd_how )1, "Limit (in bytes) on maximum size of request message body"}, 
        {"LimitXMLRequestBody",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_limit_xml_req_body)},
      (void *)0, 31, (enum cmd_how )1, "Limit (in bytes) on maximum size of an XML-based request body"}, 
        {"RLimitCPU",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_limit_cpu)},
      (void *)((long )((char *)(& ((core_dir_config *)((void *)0))->limit_cpu) - (char *)((void *)0))),
      31, (enum cmd_how )7, "Soft/hard limits for max CPU usage in seconds"}, 
        {"RLimitMEM", {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_limit_mem)},
      (void *)((long )((char *)(& ((core_dir_config *)((void *)0))->limit_mem) - (char *)((void *)0))),
      31, (enum cmd_how )7, "Soft/hard limits for max memory usage per process"}, 
        {"RLimitNPROC", {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& set_limit_nproc)},
      (void *)((long )((char *)(& ((core_dir_config *)((void *)0))->limit_nproc) -
                       (char *)((void *)0))), 31, (enum cmd_how )7, "soft/hard limits for max number of processes per uid"}, 
        {"ForceType",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& ap_set_string_slot_lower)},
      (void *)((long )((char *)(& ((core_dir_config *)((void *)0))->mime_type) - (char *)((void *)0))),
      4, (enum cmd_how )1, "a mime type that overrides other configured type"}, 
        {"SetHandler", {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& ap_set_string_slot_lower)},
      (void *)((long )((char *)(& ((core_dir_config *)((void *)0))->handler) - (char *)((void *)0))),
      4, (enum cmd_how )1, "a handler name that overrides any other configured handler"}, 
        {"SetOutputFilter",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& ap_set_string_slot)},
      (void *)((long )((char *)(& ((core_dir_config *)((void *)0))->output_filters) -
                       (char *)((void *)0))), 4, (enum cmd_how )1, "filter (or ; delimited list of filters) to be run on the request content"}, 
        {"SetInputFilter",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& ap_set_string_slot)},
      (void *)((long )((char *)(& ((core_dir_config *)((void *)0))->input_filters) -
                       (char *)((void *)0))), 4, (enum cmd_how )1, "filter (or ; delimited list of filters) to be run on the request body"}, 
        {"AddOutputFilterByType",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& add_ct_output_filters)},
      (void *)((long )((char *)(& ((core_dir_config *)((void *)0))->ct_output_filters) -
                       (char *)((void *)0))), 4, (enum cmd_how )4, "output filter name followed by one or more content-types"}, 
        {"PidFile",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& ap_mpm_set_pidfile)},
      (void *)0, 128, (enum cmd_how )1, "A file for logging the server process ID"}, 
        {"ScoreBoardFile",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& ap_mpm_set_scoreboard)},
      (void *)0, 128, (enum cmd_how )1, "A file for Apache to maintain runtime process management information"}, 
        {"LockFile",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& ap_mpm_set_lockfile)},
      (void *)0, 128, (enum cmd_how )1, "The lockfile used when Apache needs to lock the accept() call"}, 
        {"MaxRequestsPerChild",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& ap_mpm_set_max_requests)},
      (void *)0, 128, (enum cmd_how )1, "Maximum number of requests a particular child serves before dying."}, 
        {"CoreDumpDirectory",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& ap_mpm_set_coredumpdir)},
      (void *)0, 128, (enum cmd_how )1, "The location of the directory Apache changes to before dumping core"}, 
        {"AcceptMutex",
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& ap_mpm_set_accept_lock_mech)},
      (void *)0, 128, (enum cmd_how )1, ap_valid_accept_mutex_string}, 
        {"MaxMemFree", {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))(& ap_mpm_set_max_mem_free)},
      (void *)0, 128, (enum cmd_how )1, "Maximum number of 1k blocks a particular childs allocator may hold."}, 
        {(char const   *)((void *)0),
      {.no_args = (char const   *(*)(cmd_parms *parms , void *mconfig ))0}, (void *)0,
      0, (enum cmd_how )0, (char const   *)0}};
int ap_core_translate(request_rec *r ) 
{ void *sconf ;
  core_server_config *conf ;
  int tmp ;
  char *path ;
  apr_status_t tmp___0 ;
  char *path___0 ;
  apr_status_t tmp___1 ;
  int tmp___2 ;

  {
  sconf = (void *)(r->server)->module_config;
  conf = (core_server_config *)(*((void **)sconf + core_module.module_index));
  if (r->proxyreq) {
    return (403);
  }
  if (! r->uri) {
    goto _L;
  } else {
    if ((int )(*(r->uri + 0)) != 47) {
      tmp = strcmp((char const   *)r->uri, "*");
      if (tmp) {
        _L: 
        ap_log_rerror("core.c", 3134, 3, 0, (request_rec const   *)r, "Invalid URI in request %s",
                      r->the_request);
        return (400);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
  }
  if ((r->server)->path) {
    tmp___2 = strncmp((char const   *)r->uri, (r->server)->path, (unsigned int )(r->server)->pathlen);
    if (tmp___2) {
      goto _L___4;
    } else {
      if ((int const   )(*((r->server)->path + ((r->server)->pathlen - 1))) == 47) {
        goto _L___3;
      } else {
        if ((int )(*(r->uri + (r->server)->pathlen)) == 47) {
          _L___3: 
          goto _L___2;
        } else {
          if ((int )(*(r->uri + (r->server)->pathlen)) == 0) {
            _L___2: 
            path = r->uri + (r->server)->pathlen;
            while ((int )(*path) == 47) {
              path ++;
            }
            tmp___0 = apr_filepath_merge(& r->filename, conf->ap_document_root, (char const   *)path,
                                         35, r->pool);
            if (tmp___0 != 0) {
              return (403);
            }
            r->canonical_filename = r->filename;
          } else {
            goto _L___4;
          }
        }
      }
    }
  } else {
    _L___4: 
    path___0 = r->uri;
    while ((int )(*path___0) == 47) {
      path___0 ++;
    }
    tmp___1 = apr_filepath_merge(& r->filename, conf->ap_document_root, (char const   *)path___0,
                                 35, r->pool);
    if (tmp___1 != 0) {
      return (403);
    }
    r->canonical_filename = r->filename;
  }
  return (0);
}
}
static int core_map_to_storage(request_rec *r ) 
{ int access_status ;

  {
  access_status = ap_directory_walk(r);
  if (access_status) {
    return (access_status);
  }
  access_status = ap_file_walk(r);
  if (access_status) {
    return (access_status);
  }
  return (0);
}
}
static int do_nothing(request_rec *r ) 
{ 

  {
  return (0);
}
}
static int core_override_type(request_rec *r ) 
{ core_dir_config *conf ;
  int tmp ;
  int tmp___0 ;

  {
  conf = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  if (conf->mime_type) {
    tmp = strcmp(conf->mime_type, "none");
    if (tmp) {
      ap_set_content_type(r, (char const   *)((char *)conf->mime_type));
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if (conf->handler) {
    tmp___0 = strcmp(conf->handler, "none");
    if (tmp___0) {
      r->handler = conf->handler;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
  }
  if (r->used_path_info == 2) {
    if (conf->accept_path_info != 3) {
      r->used_path_info = conf->accept_path_info;
    } else {
      goto _L___1;
    }
  } else {
    _L___1: ;
  }
  return (0);
}
}
static int default_handler(request_rec *r ) 
{ conn_rec *c ;
  apr_bucket_brigade *bb ;
  apr_bucket *e ;
  core_dir_config *d ;
  int errstatus ;
  apr_file_t *fd ;
  apr_status_t status ;
  int bld_content_md5 ;
  int tmp ;
  char *tmp___0 ;
  core_request_config *req_cfg ;
  int tmp___1 ;
  char const   *tmp___2 ;
  apr_bucket *ap__b ;
  apr_bucket *ap__b___0 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  c = r->connection;
  fd = (apr_file_t *)((void *)0);
  d = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  if (d->content_md5 & 1) {
    if ((int )((r->output_filters)->frec)->ftype != 10) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else {
    _L: 
    tmp = 0;
  }
  bld_content_md5 = tmp;
  ap_allow_standard_methods(r, 0, 0, 5, 2, -1);
  errstatus = ap_discard_request_body(r);
  if (errstatus != 0) {
    return (errstatus);
  }
  if (r->method_number == 0) {
    goto _L___2;
  } else {
    if (r->method_number == 2) {
      _L___2: 
      if ((int )r->finfo.filetype == 0) {
        ap_log_rerror("core.c", 3278, 3, 0, (request_rec const   *)r, "File does not exist: %s",
                      r->filename);
        return (404);
      }
      if ((int )r->finfo.filetype == 2) {
        ap_log_rerror("core.c", 3287, 3, 0, (request_rec const   *)r, "Attempt to serve directory: %s",
                      r->filename);
        return (404);
      }
      if (r->used_path_info != 0) {
        if (r->path_info) {
          if ((*(r->path_info))) {
            tmp___0 = apr_pstrcat(r->pool, r->filename, r->path_info, (void *)0);
            ap_log_rerror("core.c", 3296, 3, 0, (request_rec const   *)r, "File does not exist: %s",
                          tmp___0);
            return (404);
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        _L___1: ;
      }
      if (r->method_number != 0) {
        req_cfg = (core_request_config *)(*((void **)r->request_config + core_module.module_index));
        if (! req_cfg->deliver_script) {
          ap_log_rerror("core.c", 3316, 3, 0, (request_rec const   *)r, "This resource does not accept the %s method.",
                        r->method);
          return (405);
        }
      }
      if (d->enable_sendfile == 0U) {
        tmp___1 = 0;
      } else {
        tmp___1 = 4096;
      }
      status = apr_file_open(& fd, (char const   *)r->filename, 33 | tmp___1, 0, r->pool);
      if (status != 0) {
        ap_log_rerror("core.c", 3330, 3, status, (request_rec const   *)r, "file permissions deny server access: %s",
                      r->filename);
        return (403);
      }
      ap_update_mtime(r, r->finfo.mtime);
      ap_set_last_modified(r);
      ap_set_etag(r);
      apr_table_setn(r->headers_out, "Accept-Ranges", "bytes");
      ap_set_content_length(r, r->finfo.size);
      errstatus = ap_meets_conditions(r);
      if (errstatus != 0) {
        apr_file_close(fd);
        return (errstatus);
      }
      if (bld_content_md5) {
        tmp___2 = ap_md5digest(r->pool, fd);
        apr_table_setn(r->headers_out, "Content-MD5", tmp___2);
      }
      bb = apr_brigade_create(r->pool, c->bucket_alloc);
      e = apr_bucket_file_create(fd, 0L, (unsigned int )r->finfo.size, r->pool, c->bucket_alloc);
      if (d->enable_mmap == 0U) {
        apr_bucket_file_enable_mmap(e, 0);
      }
      while (1) {
        ap__b = e;
        while (1) {
          ap__b->link.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                  (char *)((void *)0)));
          ap__b->link.prev = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                   (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0))))->link.prev)->link.next = ap__b;
          ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0))))->link.prev = ap__b;
          break;
        }
        break;
      }
      e = apr_bucket_eos_create(c->bucket_alloc);
      while (1) {
        ap__b___0 = e;
        while (1) {
          ap__b___0->link.next = (struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                      (char *)((void *)0)));
          ap__b___0->link.prev = ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0))))->link.prev)->link.next = ap__b___0;
          ((struct apr_bucket *)((char *)(& bb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0))))->link.prev = ap__b___0;
          break;
        }
        break;
      }
      tmp___3 = ap_pass_brigade(r->output_filters, bb);
      return (tmp___3);
    } else {
      if (r->method_number == 26) {
        ap_log_rerror("core.c", 3388, 3, 0, (request_rec const   *)r, "Invalid method in request %s",
                      r->the_request);
        return (501);
      }
      if (r->method_number == 5) {
        tmp___4 = ap_send_http_options(r);
        return (tmp___4);
      }
      return (405);
    }
  }
}
}
static int net_time_filter(ap_filter_t *f , apr_bucket_brigade *b , ap_input_mode_t mode ,
                           apr_read_type_e block , apr_off_t readbytes ) 
{ net_time_filter_ctx_t *ctx ;
  int keptalive ;
  apr_interval_time_t tmp ;
  int tmp___0 ;

  {
  ctx = (net_time_filter_ctx_t *)f->ctx;
  keptalive = (int )(f->c)->keepalive == 2;
  if (! ctx) {
    ctx = (net_time_filter_ctx_t *)apr_palloc((f->r)->pool, sizeof((*ctx)));
    f->ctx = (void *)ctx;
    ctx->first_line = 1;
    ctx->csd = (apr_socket_t *)(*((void **)(f->c)->conn_config + core_module.module_index));
  }
  if ((int )mode != 5) {
    if ((int )mode != 2) {
      if (ctx->first_line) {
        if (keptalive) {
          tmp = ((f->c)->base_server)->keep_alive_timeout;
        } else {
          tmp = ((f->c)->base_server)->timeout;
        }
        apr_socket_timeout_set(ctx->csd, tmp);
        ctx->first_line = 0;
      } else {
        if (keptalive) {
          apr_socket_timeout_set(ctx->csd, ((f->c)->base_server)->timeout);
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  tmp___0 = ap_get_brigade(f->next, b, mode, block, readbytes);
  return (tmp___0);
}
}
static int core_input_filter(ap_filter_t *f , apr_bucket_brigade *b , ap_input_mode_t mode ,
                             apr_read_type_e block , apr_off_t readbytes ) 
{ apr_bucket *e ;
  apr_status_t rv ;
  core_net_rec *net ;
  core_ctx_t *ctx ;
  char const   *str ;
  apr_size_t len ;
  void *tmp ;
  apr_bucket *ap__b ;
  apr_bucket *e___0 ;
  apr_bucket *d ;
  apr_bucket *e___1 ;
  char const   *c ;
  apr_bucket *e___2 ;
  apr_bucket *ap__b___0 ;
  apr_bucket *e___3 ;
  apr_bucket_brigade *newbb ;
  apr_bucket *ap__b___1 ;
  apr_bucket *copy_bucket ;
  apr_bucket *ap__b___2 ;

  {
  net = (core_net_rec *)f->ctx;
  ctx = net->in_ctx;
  if ((int )mode == 5) {
    return (0);
  }
  if (! ctx) {
    tmp = apr_palloc((f->c)->pool, sizeof((*ctx)));
    ctx = (core_ctx_t *)memset(tmp, 0, sizeof((*ctx)));
    ctx->b = apr_brigade_create((f->c)->pool, (f->c)->bucket_alloc);
    e = apr_bucket_socket_create(net->client_socket, (f->c)->bucket_alloc);
    while (1) {
      ap__b = e;
      while (1) {
        ap__b->link.next = (struct apr_bucket *)((char *)(& (ctx->b)->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                      (char *)((void *)0)));
        ap__b->link.prev = ((struct apr_bucket *)((char *)(& (ctx->b)->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0))))->link.prev;
        (((struct apr_bucket *)((char *)(& (ctx->b)->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                     (char *)((void *)0))))->link.prev)->link.next = ap__b;
        ((struct apr_bucket *)((char *)(& (ctx->b)->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                    (char *)((void *)0))))->link.prev = ap__b;
        break;
      }
      break;
    }
    net->in_ctx = ctx;
  } else {
    if ((unsigned int )(ctx->b)->list.next == (unsigned int )((struct apr_bucket *)((char *)(& (ctx->b)->list) -
                                                                                    (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                            (char *)((void *)0))))) {
      return (70014);
    }
  }
  while (1) {
    e___0 = (ctx->b)->list.next;
    while (1) {
      if (e___0->length == 0U) {
        if (! (e___0->type)->is_metadata) {
          d = e___0->link.next;
          while (1) {
            while (1) {
              (e___0->link.prev)->link.next = e___0->link.next;
              (e___0->link.next)->link.prev = e___0->link.prev;
              break;
            }
            while (1) {
              ((*((e___0->type)->destroy)))(e___0->data);
              ((*(e___0->free)))((void *)e___0);
              break;
            }
            break;
          }
          e___0 = d;
        } else {
          goto _L;
        }
      } else {
        _L: ;
      }
      e___0 = e___0->link.next;
      if (! ((unsigned int )(ctx->b)->list.next == (unsigned int )((struct apr_bucket *)((char *)(& (ctx->b)->list) -
                                                                                         (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                 (char *)((void *)0)))))) {
        if (! ((unsigned int )e___0 != (unsigned int )((struct apr_bucket *)((char *)(& (ctx->b)->list) -
                                                                             (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                     (char *)((void *)0)))))) {
          goto _L___0;
        }
      } else {
        _L___0: 
        break;
      }
    }
    break;
  }
  if ((unsigned int )(ctx->b)->list.next == (unsigned int )((struct apr_bucket *)((char *)(& (ctx->b)->list) -
                                                                                  (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                          (char *)((void *)0))))) {
    return (70014);
  }
  if ((int )mode == 1) {
    rv = apr_brigade_split_line(b, ctx->b, block, 8192L);
    if (rv == 11) {
      rv = 0;
    }
    return (rv);
  }
  if ((int )mode == 2) {
    while (1) {
      if ((unsigned int )(ctx->b)->list.next == (unsigned int )((struct apr_bucket *)((char *)(& (ctx->b)->list) -
                                                                                      (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                              (char *)((void *)0))))) {
        return (70014);
      }
      e___1 = (ctx->b)->list.next;
      rv = ((*((e___1->type)->read)))(e___1, & str, & len, (enum __anonenum_apr_read_type_e_60 )1);
      if (rv != 0) {
        return (rv);
      }
      c = str;
      while ((unsigned int )c < (unsigned int )(str + len)) {
        if ((int const   )(*c) == 10) {
          c ++;
        } else {
          if ((int const   )(*c) == 13) {
            if ((int const   )(*(c + 1)) == 10) {
              c += 2;
            } else {
              goto _L___1;
            }
          } else {
            _L___1: 
            return (0);
          }
        }
      }
      while (1) {
        while (1) {
          (e___1->link.prev)->link.next = e___1->link.next;
          (e___1->link.next)->link.prev = e___1->link.prev;
          break;
        }
        while (1) {
          ((*((e___1->type)->destroy)))(e___1->data);
          ((*(e___1->free)))((void *)e___1);
          break;
        }
        break;
      }
    }
    return (0);
  }
  if ((int )mode == 4) {
    while (1) {
      if (! ((unsigned int )(ctx->b)->list.next == (unsigned int )((struct apr_bucket *)((char *)(& (ctx->b)->list) -
                                                                                         (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                 (char *)((void *)0)))))) {
        while (1) {
          ((ctx->b)->list.prev)->link.next = (struct apr_bucket *)((char *)(& b->list) -
                                                                   (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                           (char *)((void *)0)));
          ((ctx->b)->list.next)->link.prev = ((struct apr_bucket *)((char *)(& b->list) -
                                                                    (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                            (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0))))->link.prev)->link.next = (ctx->b)->list.next;
          ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                               (char *)((void *)0))))->link.prev = (ctx->b)->list.prev;
          break;
        }
        while (1) {
          (ctx->b)->list.next = (struct apr_bucket *)((char *)(& (ctx->b)->list) -
                                                      (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                              (char *)((void *)0)));
          (ctx->b)->list.prev = (struct apr_bucket *)((char *)(& (ctx->b)->list) -
                                                      (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                              (char *)((void *)0)));
          break;
        }
      }
      break;
    }
    e___2 = apr_bucket_eos_create((f->c)->bucket_alloc);
    while (1) {
      ap__b___0 = e___2;
      while (1) {
        ap__b___0->link.next = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                   (char *)((void *)0)));
        ap__b___0->link.prev = ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                    (char *)((void *)0))))->link.prev;
        (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                              (char *)((void *)0))))->link.prev)->link.next = ap__b___0;
        ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                             (char *)((void *)0))))->link.prev = ap__b___0;
        break;
      }
      break;
    }
    return (0);
  }
  if ((int )mode == 0) {
    goto _L___3;
  } else {
    if ((int )mode == 3) {
      _L___3: 
      e___3 = (ctx->b)->list.next;
      rv = ((*((e___3->type)->read)))(e___3, & str, & len, block);
      if (rv == 11) {
        return (0);
      } else {
        if (rv != 0) {
          return (rv);
        } else {
          if ((int )block == 0) {
            if (len == 0U) {
              while (1) {
                while (1) {
                  (e___3->link.prev)->link.next = e___3->link.next;
                  (e___3->link.next)->link.prev = e___3->link.prev;
                  break;
                }
                while (1) {
                  ((*((e___3->type)->destroy)))(e___3->data);
                  ((*(e___3->free)))((void *)e___3);
                  break;
                }
                break;
              }
              if ((int )mode == 0) {
                e___3 = apr_bucket_eos_create((f->c)->bucket_alloc);
                while (1) {
                  ap__b___1 = e___3;
                  while (1) {
                    ap__b___1->link.next = (struct apr_bucket *)((char *)(& b->list) -
                                                                 (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                         (char *)((void *)0)));
                    ap__b___1->link.prev = ((struct apr_bucket *)((char *)(& b->list) -
                                                                  (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                          (char *)((void *)0))))->link.prev;
                    (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                          (char *)((void *)0))))->link.prev)->link.next = ap__b___1;
                    ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                         (char *)((void *)0))))->link.prev = ap__b___1;
                    break;
                  }
                  break;
                }
              }
              return (0);
            } else {
              goto _L___2;
            }
          } else {
            _L___2: ;
          }
        }
      }
      if ((unsigned long )len < (unsigned long )readbytes) {
        readbytes = (long )len;
      }
      rv = apr_brigade_partition(ctx->b, readbytes, & e___3);
      if (rv != 0) {
        return (rv);
      }
      newbb = apr_brigade_split(ctx->b, e___3);
      if ((int )mode == 0) {
        while (1) {
          if (! ((unsigned int )(ctx->b)->list.next == (unsigned int )((struct apr_bucket *)((char *)(& (ctx->b)->list) -
                                                                                             (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                     (char *)((void *)0)))))) {
            while (1) {
              ((ctx->b)->list.prev)->link.next = (struct apr_bucket *)((char *)(& b->list) -
                                                                       (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                               (char *)((void *)0)));
              ((ctx->b)->list.next)->link.prev = ((struct apr_bucket *)((char *)(& b->list) -
                                                                        (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                (char *)((void *)0))))->link.prev;
              (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                    (char *)((void *)0))))->link.prev)->link.next = (ctx->b)->list.next;
              ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                   (char *)((void *)0))))->link.prev = (ctx->b)->list.prev;
              break;
            }
            while (1) {
              (ctx->b)->list.next = (struct apr_bucket *)((char *)(& (ctx->b)->list) -
                                                          (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                  (char *)((void *)0)));
              (ctx->b)->list.prev = (struct apr_bucket *)((char *)(& (ctx->b)->list) -
                                                          (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                  (char *)((void *)0)));
              break;
            }
          }
          break;
        }
      } else {
        if ((int )mode == 3) {
          e___3 = (ctx->b)->list.next;
          while ((unsigned int )e___3 != (unsigned int )((struct apr_bucket *)((char *)(& (ctx->b)->list) -
                                                                               (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0))))) {
            rv = ((*((e___3->type)->copy)))(e___3, & copy_bucket);
            if (rv != 0) {
              return (rv);
            }
            while (1) {
              ap__b___2 = copy_bucket;
              while (1) {
                ap__b___2->link.next = (struct apr_bucket *)((char *)(& b->list) -
                                                             (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                     (char *)((void *)0)));
                ap__b___2->link.prev = ((struct apr_bucket *)((char *)(& b->list) -
                                                              (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                      (char *)((void *)0))))->link.prev;
                (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                      (char *)((void *)0))))->link.prev)->link.next = ap__b___2;
                ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                     (char *)((void *)0))))->link.prev = ap__b___2;
                break;
              }
              break;
            }
            e___3 = e___3->link.next;
          }
        }
      }
      while (1) {
        if (! ((unsigned int )newbb->list.next == (unsigned int )((struct apr_bucket *)((char *)(& newbb->list) -
                                                                                        (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                                (char *)((void *)0)))))) {
          while (1) {
            (newbb->list.prev)->link.next = (struct apr_bucket *)((char *)(& (ctx->b)->list) -
                                                                  (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                          (char *)((void *)0)));
            (newbb->list.next)->link.prev = ((struct apr_bucket *)((char *)(& (ctx->b)->list) -
                                                                   (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                           (char *)((void *)0))))->link.prev;
            (((struct apr_bucket *)((char *)(& (ctx->b)->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                         (char *)((void *)0))))->link.prev)->link.next = newbb->list.next;
            ((struct apr_bucket *)((char *)(& (ctx->b)->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                        (char *)((void *)0))))->link.prev = newbb->list.prev;
            break;
          }
          while (1) {
            newbb->list.next = (struct apr_bucket *)((char *)(& newbb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0)));
            newbb->list.prev = (struct apr_bucket *)((char *)(& newbb->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0)));
            break;
          }
        }
        break;
      }
    }
  }
  return (0);
}
}
static apr_OFN_ap_logio_add_bytes_out_t *logio_add_bytes_out  ;
static apr_status_t core_output_filter(ap_filter_t *f , apr_bucket_brigade *b ) 
{ apr_status_t rv ;
  apr_bucket_brigade *more ;
  conn_rec *c ;
  core_net_rec *net ;
  core_output_filter_ctx_t *ctx ;
  apr_read_type_e eblock ;
  apr_pool_t *input_pool ;
  void *tmp ;
  apr_size_t nbytes ;
  apr_bucket *last_e ;
  apr_bucket *e ;
  apr_size_t nvec ;
  apr_size_t nvec_trailers ;
  struct iovec vec[16] ;
  struct iovec vec_trailers[16] ;
  apr_file_t *fd ;
  apr_size_t flen ;
  apr_off_t foffset ;
  apr_bucket *last_merged_bucket ;
  apr_bucket_file *a ;
  char const   *str ;
  apr_size_t n ;
  apr_bucket *temp ;
  apr_bucket *next ;
  apr_bucket_brigade *temp_brig ;
  apr_bucket_brigade *bb ;
  apr_bucket *d ;
  apr_bucket *ap__b ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b___0 ;
  apr_bucket *bucket ;
  int file_bucket_saved ;
  char const   *buf ;
  apr_size_t len ;
  apr_hdtr_t hdtr ;
  apr_size_t bytes_sent ;
  apr_int32_t flags ;
  apr_int32_t tmp___0 ;
  apr_size_t bytes_sent___0 ;
  apr_bucket_brigade *tmp_more ;

  {
  c = f->c;
  net = (core_net_rec *)f->ctx;
  ctx = net->out_ctx;
  eblock = (enum __anonenum_apr_read_type_e_60 )1;
  input_pool = b->p;
  if ((unsigned int )ctx == (unsigned int )((void *)0)) {
    tmp = apr_palloc(c->pool, sizeof((*ctx)));
    ctx = (core_output_filter_ctx_t *)memset(tmp, 0, sizeof((*ctx)));
    net->out_ctx = ctx;
  }
  if (ctx->b) {
    while (1) {
      if (! ((unsigned int )b->list.next == (unsigned int )((struct apr_bucket *)((char *)(& b->list) -
                                                                                  (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                          (char *)((void *)0)))))) {
        while (1) {
          (b->list.prev)->link.next = (struct apr_bucket *)((char *)(& (ctx->b)->list) -
                                                            (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                    (char *)((void *)0)));
          (b->list.next)->link.prev = ((struct apr_bucket *)((char *)(& (ctx->b)->list) -
                                                             (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                     (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& (ctx->b)->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                       (char *)((void *)0))))->link.prev)->link.next = b->list.next;
          ((struct apr_bucket *)((char *)(& (ctx->b)->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                      (char *)((void *)0))))->link.prev = b->list.prev;
          break;
        }
        while (1) {
          b->list.next = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                             (char *)((void *)0)));
          b->list.prev = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                             (char *)((void *)0)));
          break;
        }
      }
      break;
    }
    b = ctx->b;
    ctx->b = (apr_bucket_brigade *)((void *)0);
  }
  while (1) {
    if (b) {
      if (! (! ((unsigned int )b->list.next == (unsigned int )((struct apr_bucket *)((char *)(& b->list) -
                                                                                     (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                             (char *)((void *)0))))))) {
        goto _L___11;
      }
    } else {
      _L___11: 
      break;
    }
    nbytes = 0U;
    last_e = (apr_bucket *)((void *)0);
    nvec = 0U;
    nvec_trailers = 0U;
    fd = (apr_file_t *)((void *)0);
    flen = 0U;
    foffset = 0L;
    last_merged_bucket = (apr_bucket *)((void *)0);
    more = (apr_bucket_brigade *)((void *)0);
    e = b->list.next;
    while ((unsigned int )e != (unsigned int )((struct apr_bucket *)((char *)(& b->list) -
                                                                     (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                             (char *)((void *)0))))) {
      last_e = e;
      if ((unsigned int )e->type == (unsigned int )(& apr_bucket_type_eos)) {
        break;
      }
      if ((unsigned int )e->type == (unsigned int )(& apr_bucket_type_flush)) {
        more = apr_brigade_split(b, e->link.next);
        break;
      } else {
        if ((unsigned int )e->type == (unsigned int )(& apr_bucket_type_file)) {
          if (e->length >= 256U) {
            a = (apr_bucket_file *)e->data;
            if (fd) {
              more = apr_brigade_split(b, e);
              break;
            }
            fd = a->fd;
            flen = e->length;
            foffset = e->start;
          } else {
            goto _L;
          }
        } else {
          _L: 
          rv = ((*((e->type)->read)))(e, & str, & n, eblock);
          if (rv == 11) {
            more = apr_brigade_split(b, e);
            eblock = (enum __anonenum_apr_read_type_e_60 )0;
            break;
          }
          eblock = (enum __anonenum_apr_read_type_e_60 )1;
          if (n) {
            if (! fd) {
              if (nvec == 16U) {
                if (nbytes >= 8000U) {
                  more = apr_brigade_split(b, e);
                  break;
                }
                if (last_merged_bucket) {
                  bb = apr_brigade_split(b, last_merged_bucket->link.next);
                  temp_brig = b;
                  b = bb;
                } else {
                  temp_brig = apr_brigade_create((f->c)->pool, (f->c)->bucket_alloc);
                }
                temp = b->list.next;
                while ((unsigned int )temp != (unsigned int )e) {
                  rv = ((*((temp->type)->read)))(temp, & str, & n, (enum __anonenum_apr_read_type_e_60 )0);
                  apr_brigade_write(temp_brig, (apr_status_t (*)(apr_bucket_brigade *bb ,
                                                                 void *ctx ))((void *)0),
                                    (void *)0, str, n);
                  d = temp;
                  temp = temp->link.next;
                  while (1) {
                    while (1) {
                      (d->link.prev)->link.next = d->link.next;
                      (d->link.next)->link.prev = d->link.prev;
                      break;
                    }
                    while (1) {
                      ((*((d->type)->destroy)))(d->data);
                      ((*(d->free)))((void *)d);
                      break;
                    }
                    break;
                  }
                }
                nvec = 0U;
                nbytes = 0U;
                temp = temp_brig->list.next;
                while (1) {
                  (temp->link.prev)->link.next = temp->link.next;
                  (temp->link.next)->link.prev = temp->link.prev;
                  break;
                }
                while (1) {
                  ap__b = temp;
                  while (1) {
                    ap__b->link.prev = (struct apr_bucket *)((char *)(& b->list) -
                                                             (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                     (char *)((void *)0)));
                    ap__b->link.next = ((struct apr_bucket *)((char *)(& b->list) -
                                                              (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                      (char *)((void *)0))))->link.next;
                    (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                          (char *)((void *)0))))->link.next)->link.prev = ap__b;
                    ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                         (char *)((void *)0))))->link.next = ap__b;
                    break;
                  }
                  break;
                }
                ((*((temp->type)->read)))(temp, & str, & n, (enum __anonenum_apr_read_type_e_60 )0);
                vec[nvec].iov_base = (void *)((char *)str);
                vec[nvec].iov_len = n;
                nvec ++;
                next = temp_brig->list.next;
                while ((unsigned int )next != (unsigned int )((struct apr_bucket *)((char *)(& temp_brig->list) -
                                                                                    (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                            (char *)((void *)0))))) {
                  while (1) {
                    (next->link.prev)->link.next = next->link.next;
                    (next->link.next)->link.prev = next->link.prev;
                    break;
                  }
                  while (1) {
                    ap__a = temp;
                    ap__b___0 = next;
                    while (1) {
                      ap__b___0->link.prev = ap__a;
                      ap__b___0->link.next = ap__a->link.next;
                      (ap__a->link.next)->link.prev = ap__b___0;
                      ap__a->link.next = ap__b___0;
                      break;
                    }
                    break;
                  }
                  temp = next;
                  ((*((next->type)->read)))(next, & str, & n, (enum __anonenum_apr_read_type_e_60 )0);
                  vec[nvec].iov_base = (void *)((char *)str);
                  vec[nvec].iov_len = n;
                  nvec ++;
                  next = temp_brig->list.next;
                }
                apr_brigade_destroy(temp_brig);
                last_merged_bucket = temp;
                e = temp;
                last_e = e;
              } else {
                vec[nvec].iov_base = (void *)((char *)str);
                vec[nvec].iov_len = n;
                nvec ++;
              }
            } else {
              if (nvec_trailers == 16U) {
                more = apr_brigade_split(b, e);
                break;
              }
              vec_trailers[nvec_trailers].iov_base = (void *)((char *)str);
              vec_trailers[nvec_trailers].iov_len = n;
              nvec_trailers ++;
            }
            nbytes += n;
          }
        }
      }
      e = e->link.next;
    }
    if (nbytes + flen < 8000U) {
      if (! fd) {
        if (! more) {
          if (! ((unsigned int )last_e->type == (unsigned int )(& apr_bucket_type_flush))) {
            goto _L___2;
          } else {
            goto _L___5;
          }
        } else {
          goto _L___5;
        }
      } else {
        _L___5: 
        if ((unsigned int )last_e->type == (unsigned int )(& apr_bucket_type_eos)) {
          if ((int )c->keepalive == 2) {
            _L___2: 
            if ((unsigned int )last_e->type == (unsigned int )(& apr_bucket_type_eos)) {
              file_bucket_saved = 0;
              while (1) {
                while (1) {
                  (last_e->link.prev)->link.next = last_e->link.next;
                  (last_e->link.next)->link.prev = last_e->link.prev;
                  break;
                }
                while (1) {
                  ((*((last_e->type)->destroy)))(last_e->data);
                  ((*(last_e->free)))((void *)last_e);
                  break;
                }
                break;
              }
              bucket = b->list.next;
              while ((unsigned int )bucket != (unsigned int )((struct apr_bucket *)((char *)(& b->list) -
                                                                                    (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                            (char *)((void *)0))))) {
                if ((unsigned int )bucket->type == (unsigned int )(& apr_bucket_type_file)) {
                  if (! file_bucket_saved) {
                    file_bucket_saved = 1;
                  } else {
                    goto _L___0;
                  }
                } else {
                  _L___0: 
                  len = 0U;
                  rv = ((*((bucket->type)->read)))(bucket, & buf, & len, (enum __anonenum_apr_read_type_e_60 )0);
                  if (rv != 0) {
                    ap_log_error("core.c", 3921, 3, rv, (server_rec const   *)c->base_server,
                                 "core_output_filter: Error reading from bucket.");
                    return (500);
                  }
                }
                bucket = bucket->link.next;
              }
            }
            if (! ctx->deferred_write_pool) {
              apr_pool_create_ex(& ctx->deferred_write_pool, c->pool, (int (*)(int retcode ))((void *)0),
                                 (apr_allocator_t *)((void *)0));
            }
            ap_save_brigade(f, & ctx->b, & b, ctx->deferred_write_pool);
            return (0);
          } else {
            goto _L___3;
          }
        } else {
          _L___3: 
          goto _L___1;
        }
      }
    } else {
      _L___1: ;
    }
    if (fd) {
      flags = 0;
      memset((void *)(& hdtr), '\000', sizeof(hdtr));
      if (nvec) {
        hdtr.numheaders = (int )nvec;
        hdtr.headers = vec;
      }
      if (nvec_trailers) {
        hdtr.numtrailers = (int )nvec_trailers;
        hdtr.trailers = vec_trailers;
      }
      tmp___0 = apr_file_flags_get(fd);
      if (tmp___0 & 4096) {
        if ((int )c->keepalive == 1) {
          if ((unsigned int )last_e->type == (unsigned int )(& apr_bucket_type_eos)) {
            flags |= 1;
          } else {
            goto _L___6;
          }
        } else {
          _L___6: ;
        }
        rv = sendfile_it_all(net, fd, & hdtr, foffset, flen, nbytes + flen, & bytes_sent,
                             flags);
        if (logio_add_bytes_out) {
          if (bytes_sent > 0U) {
            ((*logio_add_bytes_out))(c, (long )bytes_sent);
          } else {
            goto _L___7;
          }
        } else {
          _L___7: ;
        }
      } else {
        rv = emulate_sendfile(net, fd, & hdtr, foffset, flen, & bytes_sent);
        if (logio_add_bytes_out) {
          if (bytes_sent > 0U) {
            ((*logio_add_bytes_out))(c, (long )bytes_sent);
          } else {
            goto _L___8;
          }
        } else {
          _L___8: ;
        }
      }
      fd = (apr_file_t *)((void *)0);
    } else {
      rv = writev_it_all(net->client_socket, vec, (int )nvec, nbytes, & bytes_sent___0);
      if (logio_add_bytes_out) {
        if (bytes_sent___0 > 0U) {
          ((*logio_add_bytes_out))(c, (long )bytes_sent___0);
        } else {
          goto _L___9;
        }
      } else {
        _L___9: ;
      }
    }
    apr_brigade_destroy(b);
    if (ctx->deferred_write_pool) {
      if (more) {
        if ((unsigned int )more->p == (unsigned int )ctx->deferred_write_pool) {
          if ((unsigned int )more->list.next == (unsigned int )((struct apr_bucket *)((char *)(& more->list) -
                                                                                      (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                              (char *)((void *)0))))) {
            more = (apr_bucket_brigade *)((void *)0);
          } else {
            tmp_more = more;
            more = (apr_bucket_brigade *)((void *)0);
            ap_save_brigade(f, & more, & tmp_more, input_pool);
          }
        } else {
          goto _L___10;
        }
      } else {
        _L___10: ;
      }
      apr_pool_clear(ctx->deferred_write_pool);
    }
    if (rv != 0) {
      ap_log_error("core.c", 4029, 6, rv, (server_rec const   *)c->base_server, "core_output_filter: writing data to the network");
      if (more) {
        apr_brigade_destroy(more);
      }
      if (! (rv == 11)) {
        c->aborted = 1U;
      }
      return (0);
    }
    b = more;
    more = (apr_bucket_brigade *)((void *)0);
  }
  return (0);
}
}
static int core_post_config(apr_pool_t *pconf___0 , apr_pool_t *plog , apr_pool_t *ptemp ,
                            server_rec *s ) 
{ 

  {
  logio_add_bytes_out = (apr_OFN_ap_logio_add_bytes_out_t *)apr_dynamic_fn_retrieve("ap_logio_add_bytes_out");
  ap_set_version(pconf___0);
  ap_setup_make_content_type(pconf___0);
  return (0);
}
}
static void core_insert_filter(request_rec *r ) 
{ core_dir_config *conf ;
  char const   *filter ;
  char const   *filters ;

  {
  conf = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  filters = conf->output_filters;
  if (filters) {
    while (1) {
      if ((*filters)) {
        filter = ap_getword(r->pool, & filters, (char )';');
        if (! filter) {
          goto _L;
        }
      } else {
        _L: 
        break;
      }
      ap_add_output_filter(filter, (void *)0, r, r->connection);
    }
  }
  filters = conf->input_filters;
  if (filters) {
    while (1) {
      if ((*filters)) {
        filter = ap_getword(r->pool, & filters, (char )';');
        if (! filter) {
          goto _L___0;
        }
      } else {
        _L___0: 
        break;
      }
      ap_add_input_filter(filter, (void *)0, r, r->connection);
    }
  }
  return;
}
}
static unsigned int num_request_notes  =    3U;
static apr_status_t reset_request_notes(void *dummy ) 
{ 

  {
  num_request_notes = 3U;
  return (0);
}
}
apr_size_t ap_register_request_note(void) 
{ unsigned int tmp ;

  {
  apr_pool_cleanup_register(apr_hook_global_pool, (void const   *)((void *)0), & reset_request_notes,
                            & apr_pool_cleanup_null);
  tmp = num_request_notes;
  num_request_notes ++;
  return (tmp);
}
}
void **ap_get_request_note(request_rec *r , apr_size_t note_num ) 
{ core_request_config *req_cfg ;

  {
  if (note_num >= num_request_notes) {
    return ((void **)((void *)0));
  }
  req_cfg = (core_request_config *)(*((void **)r->request_config + core_module.module_index));
  if (! req_cfg) {
    return ((void **)((void *)0));
  }
  return (req_cfg->notes + note_num);
}
}
static int core_create_req(request_rec *r ) 
{ core_request_config *req_cfg ;
  void *tmp ;
  core_request_config *main_req_cfg ;

  {
  tmp = apr_palloc(r->pool, sizeof(core_request_config ) + sizeof(void *) * num_request_notes);
  req_cfg = (core_request_config *)memset(tmp, 0, sizeof(core_request_config ) + sizeof(void *) *
                                                                                 num_request_notes);
  req_cfg->notes = (void **)((char *)req_cfg + sizeof(core_request_config ));
  req_cfg->deliver_script = 1;
  if (r->main) {
    main_req_cfg = (core_request_config *)(*((void **)(r->main)->request_config +
                                             core_module.module_index));
    req_cfg->bb = main_req_cfg->bb;
  } else {
    req_cfg->bb = apr_brigade_create(r->pool, (r->connection)->bucket_alloc);
    if (! r->prev) {
      ap_add_input_filter_handle(ap_net_time_filter_handle, (void *)0, r, r->connection);
    }
  }
  (*((void **)r->request_config + core_module.module_index)) = (void *)req_cfg;
  r->used_path_info = 2;
  return (0);
}
}
static int core_create_proxy_req(request_rec *r , request_rec *pr ) 
{ int tmp ;

  {
  tmp = core_create_req(pr);
  return (tmp);
}
}
static conn_rec *core_create_conn(apr_pool_t *ptrans , server_rec *server , apr_socket_t *csd ,
                                  long id , void *sbh , apr_bucket_alloc_t *alloc ) 
{ apr_status_t rv ;
  conn_rec *c ;
  void *tmp ;
  conn_rec *tmp___0 ;

  {
  tmp = apr_palloc(ptrans, sizeof(conn_rec ));
  tmp___0 = (conn_rec *)memset(tmp, 0, sizeof(conn_rec ));
  c = tmp___0;
  c->sbh = sbh;
  ap_update_child_status((ap_sb_handle_t *)c->sbh, 3, (request_rec *)((void *)0));
  c->conn_config = ap_create_conn_config(ptrans);
  c->notes = apr_table_make(ptrans, 5);
  c->pool = ptrans;
  rv = apr_socket_addr_get(& c->local_addr, (enum __anonenum_apr_interface_e_56 )0,
                           csd);
  if (rv != 0) {
    ap_log_error("core.c", 4178, 6, rv, (server_rec const   *)server, "apr_socket_addr_get(APR_LOCAL)");
    apr_socket_close(csd);
    return ((conn_rec *)((void *)0));
  }
  apr_sockaddr_ip_get(& c->local_ip, c->local_addr);
  rv = apr_socket_addr_get(& c->remote_addr, (enum __anonenum_apr_interface_e_56 )1,
                           csd);
  if (rv != 0) {
    ap_log_error("core.c", 4187, 6, rv, (server_rec const   *)server, "apr_socket_addr_get(APR_REMOTE)");
    apr_socket_close(csd);
    return ((conn_rec *)((void *)0));
  }
  apr_sockaddr_ip_get(& c->remote_ip, c->remote_addr);
  c->base_server = server;
  c->id = id;
  c->bucket_alloc = alloc;
  return (c);
}
}
static int core_pre_connection(conn_rec *c , void *csd ) 
{ core_net_rec *net ;
  core_net_rec *tmp ;

  {
  tmp = (core_net_rec *)apr_palloc(c->pool, sizeof((*net)));
  net = tmp;
  ap_sock_disable_nagle((apr_socket_t *)csd);
  net->c = c;
  net->in_ctx = (core_ctx_t *)((void *)0);
  net->out_ctx = (core_output_filter_ctx_t *)((void *)0);
  net->client_socket = (apr_socket_t *)csd;
  (*((void **)(net->c)->conn_config + core_module.module_index)) = csd;
  ap_add_input_filter_handle(ap_core_input_filter_handle, (void *)net, (request_rec *)((void *)0),
                             net->c);
  ap_add_output_filter_handle(ap_core_output_filter_handle, (void *)net, (request_rec *)((void *)0),
                              net->c);
  return (-2);
}
}
static void register_hooks___17(apr_pool_t *p ) 
{ 

  {
  ap_hook_create_connection(& core_create_conn, (char const   * const  *)((void *)0),
                            (char const   * const  *)((void *)0), 30);
  ap_hook_pre_connection(& core_pre_connection, (char const   * const  *)((void *)0),
                         (char const   * const  *)((void *)0), 30);
  ap_hook_post_config(& core_post_config, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                      -10);
  ap_hook_translate_name(& ap_core_translate, (char const   * const  *)((void *)0),
                         (char const   * const  *)((void *)0), 30);
  ap_hook_map_to_storage(& core_map_to_storage, (char const   * const  *)((void *)0),
                         (char const   * const  *)((void *)0), 30);
  ap_hook_open_logs(& ap_open_logs, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                    -10);
  ap_hook_handler(& default_handler, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                  30);
  ap_hook_type_checker(& do_nothing, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                       30);
  ap_hook_fixups(& core_override_type, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                 -10);
  ap_hook_access_checker(& do_nothing, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                         30);
  ap_hook_create_request(& core_create_req, (char const   * const  *)((void *)0),
                         (char const   * const  *)((void *)0), 10);
  ((*((void (*)(char const   * , proxy_HOOK_create_req_t * , char const   * const  * ,
                char const   * const  * , int  ))(& apr_optional_hook_add))))("create_req",
                                                                              & core_create_proxy_req,
                                                                              (char const   * const  *)((void *)0),
                                                                              (char const   * const  *)((void *)0),
                                                                              10);
  ap_hook_pre_mpm(& ap_create_scoreboard, (char const   * const  *)((void *)0), (char const   * const  *)((void *)0),
                  10);
  ap_hook_insert_filter(& core_insert_filter, (char const   * const  *)((void *)0),
                        (char const   * const  *)((void *)0), 10);
  ap_core_input_filter_handle = ap_register_input_filter("CORE_IN", & core_input_filter,
                                                         (int (*)(ap_filter_t *f ))((void *)0),
                                                         (enum __anonenum_ap_filter_type_71 )60);
  ap_net_time_filter_handle = ap_register_input_filter("NET_TIME", & net_time_filter,
                                                       (int (*)(ap_filter_t *f ))((void *)0),
                                                       (enum __anonenum_ap_filter_type_71 )30);
  ap_content_length_filter_handle = ap_register_output_filter("CONTENT_LENGTH", & ap_content_length_filter,
                                                              (int (*)(ap_filter_t *f ))((void *)0),
                                                              (enum __anonenum_ap_filter_type_71 )30);
  ap_core_output_filter_handle = ap_register_output_filter("CORE", & core_output_filter,
                                                           (int (*)(ap_filter_t *f ))((void *)0),
                                                           (enum __anonenum_ap_filter_type_71 )60);
  ap_subreq_core_filter_handle = ap_register_output_filter("SUBREQ_CORE", & ap_sub_req_output_filter,
                                                           (int (*)(ap_filter_t *f ))((void *)0),
                                                           (enum __anonenum_ap_filter_type_71 )20);
  ap_old_write_func = ap_register_output_filter("OLD_WRITE", & ap_old_write_filter,
                                                (int (*)(ap_filter_t *f ))((void *)0),
                                                (enum __anonenum_ap_filter_type_71 )0);
  return;
}
}
struct module_struct core_module  = 
     {20020903, 0, -1, "core.c", (void *)0, (struct module_struct *)((void *)0), 1095774768UL,
    (void (*)(process_rec *process ))((void *)0), & create_core_dir_config, & merge_core_dir_configs,
    & create_core_server_config, & merge_core_server_configs, core_cmds, & register_hooks___17};
#pragma merger(0,"/tmp/cil-ovw3d6WD.i","-g -pthread")
static struct __anonstruct__hooks_94 _hooks___5  ;
void ap_hook_translate_name(ap_HOOK_translate_name_t *pf , char const   * const  *aszPre___1 ,
                            char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_translate_name_t *pHook ;

  {
  if (! _hooks___5.link_translate_name) {
    _hooks___5.link_translate_name = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_translate_name_t ));
    apr_hook_sort_register("translate_name", & _hooks___5.link_translate_name);
  }
  pHook = (ap_LINK_translate_name_t *)apr_array_push(_hooks___5.link_translate_name);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("translate_name", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_translate_name(void) 
{ 

  {
  return (_hooks___5.link_translate_name);
}
}
int ap_run_translate_name(request_rec *r ) 
{ ap_LINK_translate_name_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks___5.link_translate_name) {
    return (-1);
  }
  pHook = (ap_LINK_translate_name_t *)(_hooks___5.link_translate_name)->elts;
  n = 0;
  while (n < (_hooks___5.link_translate_name)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(r);
    if (rv != -1) {
      return (rv);
    }
    n ++;
  }
  return (-1);
}
}
void ap_hook_map_to_storage(ap_HOOK_map_to_storage_t *pf , char const   * const  *aszPre___1 ,
                            char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_map_to_storage_t *pHook ;

  {
  if (! _hooks___5.link_map_to_storage) {
    _hooks___5.link_map_to_storage = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_map_to_storage_t ));
    apr_hook_sort_register("map_to_storage", & _hooks___5.link_map_to_storage);
  }
  pHook = (ap_LINK_map_to_storage_t *)apr_array_push(_hooks___5.link_map_to_storage);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("map_to_storage", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_map_to_storage(void) 
{ 

  {
  return (_hooks___5.link_map_to_storage);
}
}
int ap_run_map_to_storage(request_rec *r ) 
{ ap_LINK_map_to_storage_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks___5.link_map_to_storage) {
    return (-1);
  }
  pHook = (ap_LINK_map_to_storage_t *)(_hooks___5.link_map_to_storage)->elts;
  n = 0;
  while (n < (_hooks___5.link_map_to_storage)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(r);
    if (rv != -1) {
      return (rv);
    }
    n ++;
  }
  return (-1);
}
}
void ap_hook_check_user_id(ap_HOOK_check_user_id_t *pf , char const   * const  *aszPre___1 ,
                           char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_check_user_id_t *pHook ;

  {
  if (! _hooks___5.link_check_user_id) {
    _hooks___5.link_check_user_id = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_check_user_id_t ));
    apr_hook_sort_register("check_user_id", & _hooks___5.link_check_user_id);
  }
  pHook = (ap_LINK_check_user_id_t *)apr_array_push(_hooks___5.link_check_user_id);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("check_user_id", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_check_user_id(void) 
{ 

  {
  return (_hooks___5.link_check_user_id);
}
}
int ap_run_check_user_id(request_rec *r ) 
{ ap_LINK_check_user_id_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks___5.link_check_user_id) {
    return (-1);
  }
  pHook = (ap_LINK_check_user_id_t *)(_hooks___5.link_check_user_id)->elts;
  n = 0;
  while (n < (_hooks___5.link_check_user_id)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(r);
    if (rv != -1) {
      return (rv);
    }
    n ++;
  }
  return (-1);
}
}
void ap_hook_fixups(ap_HOOK_fixups_t *pf , char const   * const  *aszPre___1 , char const   * const  *aszSucc___2 ,
                    int nOrder ) 
{ ap_LINK_fixups_t *pHook ;

  {
  if (! _hooks___5.link_fixups) {
    _hooks___5.link_fixups = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_fixups_t ));
    apr_hook_sort_register("fixups", & _hooks___5.link_fixups);
  }
  pHook = (ap_LINK_fixups_t *)apr_array_push(_hooks___5.link_fixups);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("fixups", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_fixups(void) 
{ 

  {
  return (_hooks___5.link_fixups);
}
}
int ap_run_fixups(request_rec *r ) 
{ ap_LINK_fixups_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks___5.link_fixups) {
    return (0);
  }
  pHook = (ap_LINK_fixups_t *)(_hooks___5.link_fixups)->elts;
  n = 0;
  while (n < (_hooks___5.link_fixups)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(r);
    if (rv != 0) {
      if (rv != -1) {
        return (rv);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    n ++;
  }
  return (0);
}
}
void ap_hook_type_checker(ap_HOOK_type_checker_t *pf , char const   * const  *aszPre___1 ,
                          char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_type_checker_t *pHook ;

  {
  if (! _hooks___5.link_type_checker) {
    _hooks___5.link_type_checker = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_type_checker_t ));
    apr_hook_sort_register("type_checker", & _hooks___5.link_type_checker);
  }
  pHook = (ap_LINK_type_checker_t *)apr_array_push(_hooks___5.link_type_checker);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("type_checker", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_type_checker(void) 
{ 

  {
  return (_hooks___5.link_type_checker);
}
}
int ap_run_type_checker(request_rec *r ) 
{ ap_LINK_type_checker_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks___5.link_type_checker) {
    return (-1);
  }
  pHook = (ap_LINK_type_checker_t *)(_hooks___5.link_type_checker)->elts;
  n = 0;
  while (n < (_hooks___5.link_type_checker)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(r);
    if (rv != -1) {
      return (rv);
    }
    n ++;
  }
  return (-1);
}
}
void ap_hook_access_checker(ap_HOOK_access_checker_t *pf , char const   * const  *aszPre___1 ,
                            char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_access_checker_t *pHook ;

  {
  if (! _hooks___5.link_access_checker) {
    _hooks___5.link_access_checker = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_access_checker_t ));
    apr_hook_sort_register("access_checker", & _hooks___5.link_access_checker);
  }
  pHook = (ap_LINK_access_checker_t *)apr_array_push(_hooks___5.link_access_checker);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("access_checker", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_access_checker(void) 
{ 

  {
  return (_hooks___5.link_access_checker);
}
}
int ap_run_access_checker(request_rec *r ) 
{ ap_LINK_access_checker_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks___5.link_access_checker) {
    return (0);
  }
  pHook = (ap_LINK_access_checker_t *)(_hooks___5.link_access_checker)->elts;
  n = 0;
  while (n < (_hooks___5.link_access_checker)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(r);
    if (rv != 0) {
      if (rv != -1) {
        return (rv);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    n ++;
  }
  return (0);
}
}
void ap_hook_auth_checker(ap_HOOK_auth_checker_t *pf , char const   * const  *aszPre___1 ,
                          char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_auth_checker_t *pHook ;

  {
  if (! _hooks___5.link_auth_checker) {
    _hooks___5.link_auth_checker = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_auth_checker_t ));
    apr_hook_sort_register("auth_checker", & _hooks___5.link_auth_checker);
  }
  pHook = (ap_LINK_auth_checker_t *)apr_array_push(_hooks___5.link_auth_checker);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("auth_checker", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_auth_checker(void) 
{ 

  {
  return (_hooks___5.link_auth_checker);
}
}
int ap_run_auth_checker(request_rec *r ) 
{ ap_LINK_auth_checker_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks___5.link_auth_checker) {
    return (-1);
  }
  pHook = (ap_LINK_auth_checker_t *)(_hooks___5.link_auth_checker)->elts;
  n = 0;
  while (n < (_hooks___5.link_auth_checker)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(r);
    if (rv != -1) {
      return (rv);
    }
    n ++;
  }
  return (-1);
}
}
void ap_hook_insert_filter(ap_HOOK_insert_filter_t *pf , char const   * const  *aszPre___1 ,
                           char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_insert_filter_t *pHook ;

  {
  if (! _hooks___5.link_insert_filter) {
    _hooks___5.link_insert_filter = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_insert_filter_t ));
    apr_hook_sort_register("insert_filter", & _hooks___5.link_insert_filter);
  }
  pHook = (ap_LINK_insert_filter_t *)apr_array_push(_hooks___5.link_insert_filter);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("insert_filter", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_insert_filter(void) 
{ 

  {
  return (_hooks___5.link_insert_filter);
}
}
void ap_run_insert_filter(request_rec *r ) 
{ ap_LINK_insert_filter_t *pHook ;
  int n ;

  {
  if (! _hooks___5.link_insert_filter) {
    return;
  }
  pHook = (ap_LINK_insert_filter_t *)(_hooks___5.link_insert_filter)->elts;
  n = 0;
  while (n < (_hooks___5.link_insert_filter)->nelts) {
    ((*((pHook + n)->pFunc)))(r);
    n ++;
  }
  return;
}
}
void ap_hook_create_request(ap_HOOK_create_request_t *pf , char const   * const  *aszPre___1 ,
                            char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_create_request_t *pHook ;

  {
  if (! _hooks___5.link_create_request) {
    _hooks___5.link_create_request = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(ap_LINK_create_request_t ));
    apr_hook_sort_register("create_request", & _hooks___5.link_create_request);
  }
  pHook = (ap_LINK_create_request_t *)apr_array_push(_hooks___5.link_create_request);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("create_request", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_create_request(void) 
{ 

  {
  return (_hooks___5.link_create_request);
}
}
int ap_run_create_request(request_rec *r ) 
{ ap_LINK_create_request_t *pHook ;
  int n ;
  int rv ;

  {
  if (! _hooks___5.link_create_request) {
    return (0);
  }
  pHook = (ap_LINK_create_request_t *)(_hooks___5.link_create_request)->elts;
  n = 0;
  while (n < (_hooks___5.link_create_request)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(r);
    if (rv != 0) {
      if (rv != -1) {
        return (rv);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    n ++;
  }
  return (0);
}
}
static int decl_die(int status , char *phase , request_rec *r ) 
{ 

  {
  if (status == -1) {
    ap_log_rerror("request.c", 129, 2, 0, (request_rec const   *)r, "configuration error:  couldn\'t %s: %s",
                  phase, r->uri);
    return (500);
  } else {
    return (status);
  }
}
}
int ap_process_request_internal(request_rec *r ) 
{ int file_req ;
  int tmp ;
  int access_status ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  int tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  int tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  int tmp___30 ;

  {
  if (r->main) {
    if (r->filename) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else {
    _L: 
    tmp = 0;
  }
  file_req = tmp;
  if (! r->proxyreq) {
    if (r->parsed_uri.path) {
      access_status = ap_unescape_url(r->parsed_uri.path);
      if (access_status) {
        if (access_status == 404) {
          ap_log_rerror("request.c", 153, 6, 0, (request_rec const   *)r, "found %%2f (encoded \'/\') in URI (decoded=\'%s\'), returning 404",
                        r->parsed_uri.path);
        }
        return (access_status);
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
  }
  ap_getparents(r->uri);
  if (! file_req) {
    access_status = ap_location_walk(r);
    if (access_status) {
      return (access_status);
    }
    access_status = ap_run_translate_name(r);
    if (access_status) {
      tmp___0 = decl_die(access_status, (char *)"translate", r);
      return (tmp___0);
    }
  }
  r->per_dir_config = (r->server)->lookup_defaults;
  access_status = ap_run_map_to_storage(r);
  if (access_status) {
    return (access_status);
  }
  if (! file_req) {
    access_status = ap_location_walk(r);
    if (access_status) {
      return (access_status);
    }
  }
  if ((unsigned int )r->main == (unsigned int )((void *)0)) {
    access_status = ap_run_header_parser(r);
    if (access_status) {
      return (access_status);
    }
  }
  if (r->main) {
    if ((unsigned int )(r->main)->per_dir_config == (unsigned int )r->per_dir_config) {
      r->user = (r->main)->user;
      r->ap_auth_type = (r->main)->ap_auth_type;
    } else {
      goto _L___7;
    }
  } else {
    _L___7: 
    if (r->prev) {
      if ((unsigned int )(r->prev)->per_dir_config == (unsigned int )r->per_dir_config) {
        r->user = (r->prev)->user;
        r->ap_auth_type = (r->prev)->ap_auth_type;
      } else {
        goto _L___6;
      }
    } else {
      _L___6: 
      tmp___1 = ap_satisfies(r);
      switch (tmp___1) {
      case 0: ;
      case 2: 
      access_status = ap_run_access_checker(r);
      if (access_status != 0) {
        tmp___2 = decl_die(access_status, (char *)"check access", r);
        return (tmp___2);
      }
      tmp___13 = ap_some_auth_required(r);
      if (tmp___13) {
        access_status = ap_run_check_user_id(r);
        if (access_status != 0) {
          goto _L___1;
        } else {
          tmp___7 = ap_auth_type(r);
          if (! tmp___7) {
            _L___1: 
            tmp___5 = ap_auth_type(r);
            if (tmp___5) {
              tmp___4 = "check user.  No user file?";
            } else {
              tmp___4 = "perform authentication. AuthType not set!";
            }
            tmp___6 = decl_die(access_status, (char *)tmp___4, r);
            return (tmp___6);
          }
        }
        access_status = ap_run_auth_checker(r);
        if (access_status != 0) {
          goto _L___2;
        } else {
          tmp___12 = ap_auth_type(r);
          if (! tmp___12) {
            _L___2: 
            tmp___10 = ap_auth_type(r);
            if (tmp___10) {
              tmp___9 = "check access.  No groups file?";
            } else {
              tmp___9 = "perform authentication. AuthType not set!";
            }
            tmp___11 = decl_die(access_status, (char *)tmp___9, r);
            return (tmp___11);
          }
        }
      }
      break;
      case 1: 
      access_status = ap_run_access_checker(r);
      if (access_status != 0) {
        goto _L___5;
      } else {
        tmp___29 = ap_auth_type(r);
        if (! tmp___29) {
          _L___5: 
          tmp___18 = ap_some_auth_required(r);
          if (! tmp___18) {
            tmp___16 = ap_auth_type(r);
            if (tmp___16) {
              tmp___15 = "check access";
            } else {
              tmp___15 = "perform authentication. AuthType not set!";
            }
            tmp___17 = decl_die(access_status, (char *)tmp___15, r);
            return (tmp___17);
          }
          access_status = ap_run_check_user_id(r);
          if (access_status != 0) {
            goto _L___3;
          } else {
            tmp___23 = ap_auth_type(r);
            if (! tmp___23) {
              _L___3: 
              tmp___21 = ap_auth_type(r);
              if (tmp___21) {
                tmp___20 = "check user.  No user file?";
              } else {
                tmp___20 = "perform authentication. AuthType not set!";
              }
              tmp___22 = decl_die(access_status, (char *)tmp___20, r);
              return (tmp___22);
            }
          }
          access_status = ap_run_auth_checker(r);
          if (access_status != 0) {
            goto _L___4;
          } else {
            tmp___28 = ap_auth_type(r);
            if (! tmp___28) {
              _L___4: 
              tmp___26 = ap_auth_type(r);
              if (tmp___26) {
                tmp___25 = "check access.  No groups file?";
              } else {
                tmp___25 = "perform authentication. AuthType not set!";
              }
              tmp___27 = decl_die(access_status, (char *)tmp___25, r);
              return (tmp___27);
            }
          }
        }
      }
      break;
      }
    }
  }
  access_status = ap_run_type_checker(r);
  if (access_status != 0) {
    tmp___30 = decl_die(access_status, (char *)"find types", r);
    return (tmp___30);
  }
  access_status = ap_run_fixups(r);
  if (access_status != 0) {
    return (access_status);
  }
  return (0);
}
}
static walk_cache_t *prep_walk_cache(apr_size_t t , request_rec *r ) 
{ walk_cache_t *cache ;
  void **note ;
  void **inherit_note ;
  void *tmp ;

  {
  note = ap_get_request_note(r, t);
  if (! note) {
    return ((walk_cache_t *)((void *)0));
  }
  cache = (walk_cache_t *)(*note);
  if (! cache) {
    if (r->main) {
      inherit_note = ap_get_request_note(r->main, t);
      if (inherit_note) {
        if ((*inherit_note)) {
          goto _L;
        } else {
          goto _L___3;
        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: 
      if (r->prev) {
        inherit_note = ap_get_request_note(r->prev, t);
        if (inherit_note) {
          if ((*inherit_note)) {
            _L: 
            cache = (walk_cache_t *)apr_pmemdup(r->pool, (void const   *)(*inherit_note),
                                                sizeof((*cache)));
            cache->walked = apr_array_copy(r->pool, (apr_array_header_t const   *)cache->walked);
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        _L___1: 
        tmp = apr_palloc(r->pool, sizeof((*cache)));
        cache = (walk_cache_t *)memset(tmp, 0, sizeof((*cache)));
        cache->walked = apr_array_make(r->pool, 4, (int )sizeof(walk_walked_t ));
      }
    }
    (*note) = (void *)cache;
  }
  return (cache);
}
}
static int resolve_symlink(char *d , apr_finfo_t *lfi , int opts , apr_pool_t *p ) 
{ apr_finfo_t fi ;
  int res ;
  char const   *savename ;
  int tmp ;

  {
  if (! (opts & 68)) {
    return (403);
  }
  if (lfi->valid & 33554432) {
    savename = lfi->name;
  } else {
    savename = (char const   *)((void *)0);
  }
  if (opts & 4) {
    res = apr_stat(& fi, (char const   *)d, lfi->valid & -33554434, p);
    if (res != 0) {
      return (403);
    }
    memcpy((void * __restrict  )lfi, (void const   * __restrict  )(& fi), sizeof(fi));
    if (savename) {
      lfi->name = savename;
      lfi->valid = lfi->valid | 33554432;
    }
    return (0);
  }
  if (! (lfi->valid & 196608)) {
    res = apr_lstat(& fi, (char const   *)d, lfi->valid | 196608, p);
    if (res != 0) {
      return (403);
    }
  }
  res = apr_stat(& fi, (char const   *)d, lfi->valid & -33554433, p);
  if (res != 0) {
    return (403);
  }
  if (fi.user == lfi->user) {
    tmp = 0;
  } else {
    tmp = 70024;
  }
  if (tmp != 0) {
    return (403);
  }
  memcpy((void * __restrict  )lfi, (void const   * __restrict  )(& fi), sizeof(fi));
  if (savename) {
    lfi->name = savename;
    lfi->valid = lfi->valid | 33554432;
  }
  return (0);
}
}
static void core_opts_merge(ap_conf_vector_t const   *sec , core_opts_t *opts ) 
{ core_dir_config *this_dir ;

  {
  this_dir = (core_dir_config *)(*((void **)sec + core_module.module_index));
  if (! this_dir) {
    return;
  }
  if ((int )this_dir->opts & 16) {
    opts->add = (unsigned char )(((int )opts->add & ~ ((int )this_dir->opts_remove)) |
                                 (int )this_dir->opts_add);
    opts->remove = (unsigned char )(((int )opts->remove & ~ ((int )this_dir->opts_add)) |
                                    (int )this_dir->opts_remove);
    opts->opts = (unsigned char )(((int )opts->opts & ~ ((int )opts->remove)) | (int )opts->add);
  } else {
    opts->opts = this_dir->opts;
    opts->add = this_dir->opts_add;
    opts->remove = this_dir->opts_remove;
  }
  if (! ((int )this_dir->override & 32)) {
    opts->override = this_dir->override;
  }
  return;
}
}
int ap_directory_walk(request_rec *r ) 
{ ap_conf_vector_t *now_merged ;
  core_server_config *sconf ;
  ap_conf_vector_t **sec_ent ;
  int num_sec ;
  walk_cache_t *cache ;
  char *entry_dir ;
  apr_status_t rv ;
  size_t tmp ;
  size_t tmp___0 ;
  int sec_idx ;
  int matches ;
  walk_walked_t *last_walk ;
  core_dir_config *this_dir ;
  core_opts_t opts ;
  apr_finfo_t thisinfo ;
  char *save_path_info ;
  apr_size_t buflen ;
  char *buf ;
  unsigned int seg ;
  unsigned int startseg ;
  apr_size_t filename_len ;
  size_t tmp___1 ;
  int res ;
  char *seg_name ;
  char *delim ;
  int temp_slash ;
  apr_size_t tmp___2 ;
  ap_conf_vector_t *entry_config ;
  core_dir_config *entry_core ;
  int tmp___5 ;
  apr_status_t tmp___6 ;
  int tmp___7 ;
  ap_conf_vector_t *htaccess_conf ;
  char const   *tmp___9 ;
  int tmp___11 ;
  size_t path_info_len ;
  size_t path_info_len___0 ;
  size_t tmp___12 ;
  int tmp___13 ;
  core_dir_config *entry_core___0 ;
  int tmp___14 ;
  int tmp___16 ;

  {
  now_merged = (ap_conf_vector_t *)((void *)0);
  sconf = (core_server_config *)(*((void **)(r->server)->module_config + core_module.module_index));
  sec_ent = (ap_conf_vector_t **)(sconf->sec_dir)->elts;
  num_sec = (sconf->sec_dir)->nelts;
  if ((unsigned int )r->filename == (unsigned int )((void *)0)) {
    ap_log_rerror("request.c", 522, 6, 0, (request_rec const   *)r, "Module bug?  Request filename is missing for URI %s",
                  r->uri);
    return (0);
  }
  rv = apr_filepath_merge(& entry_dir, (char const   *)((void *)0), (char const   *)r->filename,
                          4, r->pool);
  if (rv != 0) {
    ap_log_rerror("request.c", 535, 6, 0, (request_rec const   *)r, "Module bug?  Request filename path %s is invalid or or not absolute for uri %s",
                  r->filename, r->uri);
    return (0);
  }
  r->filename = entry_dir;
  cache = prep_walk_cache(0U, r);
  if (! r->finfo.filetype) {
    goto _L___2;
  } else {
    if ((int )r->finfo.filetype == 6) {
      _L___2: 
      rv = apr_stat(& r->finfo, (char const   *)r->filename, 33136, r->pool);
      if (rv != 0) {
        goto _L;
      } else {
        if (r->finfo.filetype) {
          if ((int )r->finfo.filetype != 2) {
            tmp = strlen((char const   *)r->filename);
            if ((int )(*(r->filename + (tmp - 1U))) == 47) {
              _L: 
              r->finfo.filetype = (enum __anonenum_apr_filetype_e_42 )0;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: ;
        }
      }
    }
  }
  if ((int )r->finfo.filetype == 1) {
    entry_dir = ap_make_dirstr_parent(r->pool, (char const   *)entry_dir);
  } else {
    tmp___0 = strlen((char const   *)r->filename);
    if ((int )(*(r->filename + (tmp___0 - 1U))) != 47) {
      entry_dir = apr_pstrcat(r->pool, r->filename, "/", (void *)0);
    }
  }
  if (cache->cached) {
    if ((int )r->finfo.filetype == 1) {
      goto _L___23;
    } else {
      if ((int )r->finfo.filetype == 2) {
        if (! r->path_info) {
          goto _L___23;
        } else {
          if (! (*(r->path_info))) {
            _L___23: 
            if ((unsigned int )cache->dir_conf_tested == (unsigned int )sec_ent) {
              tmp___16 = strcmp((char const   *)entry_dir, cache->cached);
              if (tmp___16 == 0) {
                if ((unsigned int )r->per_dir_config == (unsigned int )cache->per_dir_result) {
                  return (0);
                }
                if ((unsigned int )r->per_dir_config == (unsigned int )cache->dir_conf_merged) {
                  r->per_dir_config = cache->per_dir_result;
                  return (0);
                }
                if ((cache->walked)->nelts) {
                  now_merged = ((walk_walked_t *)(cache->walked)->elts + ((cache->walked)->nelts -
                                                                          1))->merged;
                }
              } else {
                goto _L___20;
              }
            } else {
              goto _L___20;
            }
          } else {
            goto _L___22;
          }
        }
      } else {
        _L___22: 
        goto _L___20;
      }
    }
  } else {
    _L___20: 
    matches = (cache->walked)->nelts;
    last_walk = (walk_walked_t *)(cache->walked)->elts;
    this_dir = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
    opts.opts = this_dir->opts;
    opts.add = this_dir->opts_add;
    opts.remove = this_dir->opts_remove;
    opts.override = this_dir->override;
    if ((int )r->finfo.filetype == 2) {
      if (r->path_info) {
        if ((*(r->path_info))) {
          rv = apr_filepath_merge(& r->path_info, (char const   *)r->filename, (char const   *)r->path_info,
                                  1, r->pool);
          if (rv != 0) {
            ap_log_rerror("request.c", 666, 3, rv, (request_rec const   *)r, "dir_walk error, path_info %s is not relative to the filename path %s for uri %s",
                          r->path_info, r->filename, r->uri);
            return (500);
          }
          save_path_info = (char *)((void *)0);
        } else {
          goto _L___4;
        }
      } else {
        goto _L___4;
      }
    } else {
      _L___4: 
      save_path_info = r->path_info;
      r->path_info = r->filename;
    }
    rv = apr_filepath_root((char const   **)(& r->filename), (char const   **)(& r->path_info),
                           0, r->pool);
    filename_len = strlen((char const   *)r->filename);
    if (rv != 0) {
      ap_log_rerror("request.c", 733, 3, rv, (request_rec const   *)r, "dir_walk error, could not determine the root path of filename %s%s for uri %s",
                    r->filename, r->path_info, r->uri);
      return (500);
    }
    tmp___1 = strlen((char const   *)r->path_info);
    buflen = (filename_len + tmp___1) + 2U;
    buf = (char *)apr_palloc(r->pool, buflen);
    memcpy((void * __restrict  )buf, (void const   * __restrict  )r->filename, filename_len +
                                                                               1U);
    r->filename = buf;
    thisinfo.valid = 32768;
    thisinfo.filetype = (enum __anonenum_apr_filetype_e_42 )2;
    seg = (unsigned int )ap_count_dirs((char const   *)r->filename);
    startseg = seg;
    sec_idx = 0;
    while (1) {
      temp_slash = 0;
      if (seg > startseg) {
        if ((int )(*(r->filename + (filename_len - 1U))) != 47) {
          tmp___2 = filename_len;
          filename_len ++;
          (*(r->filename + tmp___2)) = (char )'/';
          (*(r->filename + filename_len)) = (char)0;
          temp_slash = 1;
        } else {
          goto _L___5;
        }
      } else {
        _L___5: ;
      }
      while (sec_idx < num_sec) {
        entry_config = (*(sec_ent + sec_idx));
        entry_core = (core_dir_config *)(*((void **)entry_config + core_module.module_index));
        if (entry_core->r) {
          goto _L___6;
        } else {
          if (entry_core->d_components > seg) {
            _L___6: 
            break;
          }
        }
        if (entry_core->d_components) {
          if (entry_core->d_components < seg) {
            goto _L___8;
          } else {
            if (entry_core->d_is_fnmatch) {
              tmp___6 = apr_fnmatch((char const   *)entry_core->d, (char const   *)r->filename,
                                    2);
              tmp___5 = tmp___6 != 0;
            } else {
              tmp___7 = strcmp((char const   *)r->filename, (char const   *)entry_core->d);
              tmp___5 = tmp___7 != 0;
            }
            if (tmp___5) {
              _L___8: 
              goto __Cont;
            } else {
              goto _L___7;
            }
          }
        } else {
          _L___7: ;
        }
        core_opts_merge((ap_conf_vector_t const   *)(*(sec_ent + sec_idx)), & opts);
        if (matches) {
          if ((unsigned int )last_walk->matched == (unsigned int )(*(sec_ent + sec_idx))) {
            now_merged = last_walk->merged;
            last_walk ++;
            matches --;
            goto __Cont;
          }
          (cache->walked)->nelts = (cache->walked)->nelts - matches;
          matches = 0;
        }
        if (now_merged) {
          now_merged = ap_merge_per_dir_configs(r->pool, now_merged, (*(sec_ent +
                                                                        sec_idx)));
        } else {
          now_merged = (*(sec_ent + sec_idx));
        }
        last_walk = (walk_walked_t *)apr_array_push(cache->walked);
        last_walk->matched = (*(sec_ent + sec_idx));
        last_walk->merged = now_merged;
        __Cont: 
        sec_idx ++;
      }
      while (1) {
        htaccess_conf = (ap_conf_vector_t *)((void *)0);
        if (seg < startseg) {
          goto _L___9;
        } else {
          if (! opts.override) {
            _L___9: 
            break;
          }
        }
        tmp___9 = apr_pstrdup(r->pool, (char const   *)r->filename);
        res = ap_parse_htaccess(& htaccess_conf, r, (int )opts.override, tmp___9,
                                (char const   *)sconf->access_name);
        if (res) {
          return (res);
        }
        if (! htaccess_conf) {
          break;
        }
        core_opts_merge((ap_conf_vector_t const   *)htaccess_conf, & opts);
        if (matches) {
          if ((unsigned int )last_walk->matched == (unsigned int )htaccess_conf) {
            now_merged = last_walk->merged;
            last_walk ++;
            matches --;
            break;
          }
          (cache->walked)->nelts = (cache->walked)->nelts - matches;
          matches = 0;
        }
        if (now_merged) {
          now_merged = ap_merge_per_dir_configs(r->pool, now_merged, htaccess_conf);
        } else {
          now_merged = htaccess_conf;
        }
        last_walk = (walk_walked_t *)apr_array_push(cache->walked);
        last_walk->matched = htaccess_conf;
        last_walk->merged = now_merged;
        break;
      }
      if (temp_slash) {
        filename_len --;
        (*(r->filename + filename_len)) = (char )'\000';
      }
      if (! r->path_info) {
        goto _L___10;
      } else {
        if (! (*(r->path_info))) {
          _L___10: 
          break;
        }
      }
      seg_name = r->filename + filename_len;
      if ((int )(*(r->path_info)) == 47) {
        tmp___11 = 1;
      } else {
        tmp___11 = 0;
      }
      delim = strchr((char const   *)(r->path_info + tmp___11), '/');
      if (delim) {
        path_info_len = (unsigned int )(delim - r->path_info);
        (*delim) = (char )'\000';
        memcpy((void * __restrict  )seg_name, (void const   * __restrict  )r->path_info,
               path_info_len + 1U);
        filename_len += path_info_len;
        r->path_info = delim;
        (*delim) = (char )'/';
      } else {
        tmp___12 = strlen((char const   *)r->path_info);
        path_info_len___0 = tmp___12;
        memcpy((void * __restrict  )seg_name, (void const   * __restrict  )r->path_info,
               path_info_len___0 + 1U);
        filename_len += path_info_len___0;
        r->path_info = r->path_info + path_info_len___0;
      }
      if ((int )(*seg_name) == 47) {
        seg_name ++;
      }
      if (! (*seg_name)) {
        break;
      }
      if (r->finfo.filetype) {
        if (((int )opts.opts & 68) == 4) {
          thisinfo.filetype = (enum __anonenum_apr_filetype_e_42 )2;
          seg ++;
          goto __Cont___0;
        } else {
          goto _L___11;
        }
      } else {
        _L___11: ;
      }
      rv = apr_lstat(& thisinfo, (char const   *)r->filename, 33587568, r->pool);
      if (rv == 2) {
        thisinfo.filetype = (enum __anonenum_apr_filetype_e_42 )0;
        break;
      } else {
        if (rv == 13) {
          ap_log_rerror("request.c", 991, 3, rv, (request_rec const   *)r, "access to %s denied",
                        r->uri);
          r->status = 403;
          return (r->status);
        } else {
          if (rv != 0) {
            if (rv != 70008) {
              goto _L___12;
            } else {
              goto _L___13;
            }
          } else {
            _L___13: 
            if (! (thisinfo.valid & 32768)) {
              _L___12: 
              ap_log_rerror("request.c", 1000, 3, rv, (request_rec const   *)r, "access to %s failed",
                            r->uri);
              r->status = 403;
              return (r->status);
            }
          }
        }
      }
      if (thisinfo.valid & 33554432) {
        tmp___13 = strcmp((char const   *)seg_name, thisinfo.name);
        if (tmp___13) {
          strcpy((char * __restrict  )seg_name, (char const   * __restrict  )thisinfo.name);
          filename_len = strlen((char const   *)r->filename);
        } else {
          goto _L___14;
        }
      } else {
        _L___14: ;
      }
      if ((int )thisinfo.filetype == 6) {
        res = resolve_symlink(r->filename, & thisinfo, (int )opts.opts, r->pool);
        if (res != 0) {
          ap_log_rerror("request.c", 1022, 3, 0, (request_rec const   *)r, "Symbolic link not allowed: %s",
                        r->filename);
          r->status = res;
          return (r->status);
        }
      }
      if ((int )thisinfo.filetype == 1) {
        goto _L___15;
      } else {
        if ((int )thisinfo.filetype == 0) {
          _L___15: 
          break;
        } else {
          if ((int )thisinfo.filetype != 2) {
            ap_log_rerror("request.c", 1038, 3, 0, (request_rec const   *)r, "Forbidden: %s doesn\'t point to a file or directory",
                          r->filename);
            r->status = 403;
            return (r->status);
          }
        }
      }
      seg ++;
      __Cont___0: 
      if (! ((int )thisinfo.filetype == 2)) {
        break;
      }
    }
    if (! r->finfo.filetype) {
      goto _L___16;
    } else {
      if ((int )r->finfo.filetype == 6) {
        _L___16: 
        r->finfo = thisinfo;
      }
    }
    if (save_path_info) {
      if (r->path_info) {
        if ((*(r->path_info))) {
          r->path_info = ap_make_full_path(r->pool, (char const   *)r->path_info,
                                           (char const   *)save_path_info);
        } else {
          goto _L___17;
        }
      } else {
        _L___17: 
        r->path_info = save_path_info;
      }
    }
    while (sec_idx < num_sec) {
      entry_core___0 = (core_dir_config *)(*((void **)(*(sec_ent + sec_idx)) + core_module.module_index));
      if (! entry_core___0->r) {
        goto __Cont___1;
      }
      tmp___14 = ap_regexec(entry_core___0->r, (char const   *)r->filename, 0U, (regmatch_t *)((void *)0),
                            8);
      if (tmp___14) {
        goto __Cont___1;
      }
      core_opts_merge((ap_conf_vector_t const   *)(*(sec_ent + sec_idx)), & opts);
      if (matches) {
        if ((unsigned int )last_walk->matched == (unsigned int )(*(sec_ent + sec_idx))) {
          now_merged = last_walk->merged;
          last_walk ++;
          matches --;
          goto __Cont___1;
        }
        (cache->walked)->nelts = (cache->walked)->nelts - matches;
        matches = 0;
      }
      if (now_merged) {
        now_merged = ap_merge_per_dir_configs(r->pool, now_merged, (*(sec_ent + sec_idx)));
      } else {
        now_merged = (*(sec_ent + sec_idx));
      }
      last_walk = (walk_walked_t *)apr_array_push(cache->walked);
      last_walk->matched = (*(sec_ent + sec_idx));
      last_walk->merged = now_merged;
      __Cont___1: 
      sec_idx ++;
    }
    if (matches) {
      (cache->walked)->nelts = (cache->walked)->nelts - matches;
    }
  }
  r->canonical_filename = r->filename;
  if ((int )r->finfo.filetype == 2) {
    cache->cached = (char const   *)r->filename;
  } else {
    cache->cached = ap_make_dirstr_parent(r->pool, (char const   *)r->filename);
  }
  cache->dir_conf_tested = sec_ent;
  cache->dir_conf_merged = r->per_dir_config;
  if (now_merged) {
    r->per_dir_config = ap_merge_per_dir_configs(r->pool, r->per_dir_config, now_merged);
  }
  cache->per_dir_result = r->per_dir_config;
  return (0);
}
}
int ap_location_walk(request_rec *r ) 
{ ap_conf_vector_t *now_merged ;
  core_server_config *sconf ;
  ap_conf_vector_t **sec_ent ;
  int num_sec ;
  walk_cache_t *cache ;
  char const   *entry_uri ;
  char *uri ;
  char *tmp ;
  int len ;
  int sec_idx ;
  int matches ;
  walk_walked_t *last_walk ;
  core_dir_config *entry_core ;
  int tmp___7 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___14 ;

  {
  now_merged = (ap_conf_vector_t *)((void *)0);
  sconf = (core_server_config *)(*((void **)(r->server)->module_config + core_module.module_index));
  sec_ent = (ap_conf_vector_t **)(sconf->sec_url)->elts;
  num_sec = (sconf->sec_url)->nelts;
  if (! num_sec) {
    return (0);
  }
  cache = prep_walk_cache(1U, r);
  if ((int )(*(r->uri + 0)) != 47) {
    entry_uri = (char const   *)r->uri;
  } else {
    tmp = apr_pstrdup(r->pool, (char const   *)r->uri);
    uri = tmp;
    ap_no2slash(uri);
    entry_uri = (char const   *)uri;
  }
  if (cache->cached) {
    if ((unsigned int )cache->dir_conf_tested == (unsigned int )sec_ent) {
      tmp___14 = strcmp(entry_uri, cache->cached);
      if (tmp___14 == 0) {
        if ((unsigned int )r->per_dir_config == (unsigned int )cache->per_dir_result) {
          return (0);
        }
        if ((unsigned int )r->per_dir_config == (unsigned int )cache->dir_conf_merged) {
          r->per_dir_config = cache->per_dir_result;
          return (0);
        }
        if ((cache->walked)->nelts) {
          now_merged = ((walk_walked_t *)(cache->walked)->elts + ((cache->walked)->nelts -
                                                                  1))->merged;
        }
      } else {
        goto _L___12;
      }
    } else {
      goto _L___12;
    }
  } else {
    _L___12: 
    matches = (cache->walked)->nelts;
    last_walk = (walk_walked_t *)(cache->walked)->elts;
    cache->cached = entry_uri;
    sec_idx = 0;
    while (sec_idx < num_sec) {
      entry_core = (core_dir_config *)(*((void **)(*(sec_ent + sec_idx)) + core_module.module_index));
      len = (int )strlen((char const   *)entry_core->d);
      if (entry_core->r) {
        tmp___7 = ap_regexec(entry_core->r, (char const   *)r->uri, 0U, (regmatch_t *)((void *)0),
                             0);
      } else {
        if (entry_core->d_is_fnmatch) {
          tmp___7 = apr_fnmatch((char const   *)entry_core->d, cache->cached, 2);
        } else {
          tmp___11 = strncmp((char const   *)entry_core->d, cache->cached, (unsigned int )len);
          if (tmp___11) {
            goto _L___8;
          } else {
            if ((int )(*(entry_core->d + (len - 1))) != 47) {
              if ((int const   )(*(cache->cached + len)) != 47) {
                if ((int const   )(*(cache->cached + len)) != 0) {
                  _L___8: 
                  tmp___12 = 1;
                } else {
                  goto _L___10;
                }
              } else {
                goto _L___10;
              }
            } else {
              _L___10: 
              tmp___12 = 0;
            }
          }
          tmp___7 = tmp___12;
        }
      }
      if (tmp___7) {
        goto __Cont;
      }
      if (matches) {
        if ((unsigned int )last_walk->matched == (unsigned int )(*(sec_ent + sec_idx))) {
          now_merged = last_walk->merged;
          last_walk ++;
          matches --;
          goto __Cont;
        }
        (cache->walked)->nelts = (cache->walked)->nelts - matches;
        matches = 0;
      }
      if (now_merged) {
        now_merged = ap_merge_per_dir_configs(r->pool, now_merged, (*(sec_ent + sec_idx)));
      } else {
        now_merged = (*(sec_ent + sec_idx));
      }
      last_walk = (walk_walked_t *)apr_array_push(cache->walked);
      last_walk->matched = (*(sec_ent + sec_idx));
      last_walk->merged = now_merged;
      __Cont: 
      sec_idx ++;
    }
    if (matches) {
      (cache->walked)->nelts = (cache->walked)->nelts - matches;
    }
  }
  cache->dir_conf_tested = sec_ent;
  cache->dir_conf_merged = r->per_dir_config;
  if (now_merged) {
    r->per_dir_config = ap_merge_per_dir_configs(r->pool, r->per_dir_config, now_merged);
  }
  cache->per_dir_result = r->per_dir_config;
  return (0);
}
}
int ap_file_walk(request_rec *r ) 
{ ap_conf_vector_t *now_merged ;
  core_dir_config *dconf ;
  ap_conf_vector_t **sec_ent ;
  int num_sec ;
  walk_cache_t *cache ;
  char const   *test_file ;
  int sec_idx ;
  int matches ;
  walk_walked_t *last_walk ;
  core_dir_config *entry_core ;
  int tmp___3 ;
  int tmp___7 ;

  {
  now_merged = (ap_conf_vector_t *)((void *)0);
  dconf = (core_dir_config *)(*((void **)r->per_dir_config + core_module.module_index));
  sec_ent = (ap_conf_vector_t **)(dconf->sec_file)->elts;
  num_sec = (dconf->sec_file)->nelts;
  if ((unsigned int )r->filename == (unsigned int )((void *)0)) {
    return (0);
  }
  cache = prep_walk_cache(2U, r);
  if (! num_sec) {
    return (0);
  }
  test_file = strrchr((char const   *)r->filename, '/');
  if ((unsigned int )test_file == (unsigned int )((void *)0)) {
    test_file = apr_pstrdup(r->pool, (char const   *)r->filename);
  } else {
    test_file ++;
    test_file = apr_pstrdup(r->pool, test_file);
  }
  if (cache->cached) {
    if ((unsigned int )cache->dir_conf_tested == (unsigned int )sec_ent) {
      tmp___7 = strcmp(test_file, cache->cached);
      if (tmp___7 == 0) {
        if ((unsigned int )r->per_dir_config == (unsigned int )cache->per_dir_result) {
          return (0);
        }
        if ((unsigned int )r->per_dir_config == (unsigned int )cache->dir_conf_merged) {
          r->per_dir_config = cache->per_dir_result;
          return (0);
        }
        if ((cache->walked)->nelts) {
          now_merged = ((walk_walked_t *)(cache->walked)->elts + ((cache->walked)->nelts -
                                                                  1))->merged;
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    matches = (cache->walked)->nelts;
    last_walk = (walk_walked_t *)(cache->walked)->elts;
    cache->cached = test_file;
    sec_idx = 0;
    while (sec_idx < num_sec) {
      entry_core = (core_dir_config *)(*((void **)(*(sec_ent + sec_idx)) + core_module.module_index));
      if (entry_core->r) {
        tmp___3 = ap_regexec(entry_core->r, cache->cached, 0U, (regmatch_t *)((void *)0),
                             0);
      } else {
        if (entry_core->d_is_fnmatch) {
          tmp___3 = apr_fnmatch((char const   *)entry_core->d, cache->cached, 2);
        } else {
          tmp___3 = strcmp((char const   *)entry_core->d, cache->cached);
        }
      }
      if (tmp___3) {
        goto __Cont;
      }
      if (matches) {
        if ((unsigned int )last_walk->matched == (unsigned int )(*(sec_ent + sec_idx))) {
          now_merged = last_walk->merged;
          last_walk ++;
          matches --;
          goto __Cont;
        }
        (cache->walked)->nelts = (cache->walked)->nelts - matches;
        matches = 0;
      }
      if (now_merged) {
        now_merged = ap_merge_per_dir_configs(r->pool, now_merged, (*(sec_ent + sec_idx)));
      } else {
        now_merged = (*(sec_ent + sec_idx));
      }
      last_walk = (walk_walked_t *)apr_array_push(cache->walked);
      last_walk->matched = (*(sec_ent + sec_idx));
      last_walk->merged = now_merged;
      __Cont: 
      sec_idx ++;
    }
    if (matches) {
      (cache->walked)->nelts = (cache->walked)->nelts - matches;
    }
  }
  cache->dir_conf_tested = sec_ent;
  cache->dir_conf_merged = r->per_dir_config;
  if (now_merged) {
    r->per_dir_config = ap_merge_per_dir_configs(r->pool, r->per_dir_config, now_merged);
  }
  cache->per_dir_result = r->per_dir_config;
  return (0);
}
}
static request_rec *make_sub_request(request_rec const   *r , ap_filter_t *next_filter ) 
{ apr_pool_t *rrp ;
  request_rec *rnew ;
  void *tmp ;

  {
  apr_pool_create_ex(& rrp, r->pool, (int (*)(int retcode ))((void *)0), (apr_allocator_t *)((void *)0));
  tmp = apr_palloc(rrp, sizeof(request_rec ));
  rnew = (request_rec *)memset(tmp, 0, sizeof(request_rec ));
  rnew->pool = rrp;
  rnew->hostname = r->hostname;
  rnew->request_time = r->request_time;
  rnew->connection = r->connection;
  rnew->server = r->server;
  rnew->request_config = ap_create_request_config(rnew->pool);
  rnew->per_dir_config = (r->server)->lookup_defaults;
  rnew->htaccess = r->htaccess;
  rnew->allowed_methods = ap_make_method_list(rnew->pool, 2);
  ap_copy_method_list(rnew->allowed_methods, r->allowed_methods);
  if (next_filter) {
    rnew->input_filters = r->input_filters;
    rnew->proto_input_filters = r->proto_input_filters;
    rnew->output_filters = next_filter;
    rnew->proto_output_filters = r->proto_output_filters;
    ap_add_output_filter_handle(ap_subreq_core_filter_handle, (void *)0, rnew, rnew->connection);
  } else {
    rnew->proto_input_filters = r->proto_input_filters;
    rnew->proto_output_filters = r->proto_output_filters;
    rnew->input_filters = r->proto_input_filters;
    rnew->output_filters = r->proto_output_filters;
  }
  ap_set_sub_req_protocol(rnew, r);
  ap_run_create_request(rnew);
  return (rnew);
}
}
apr_status_t ap_sub_req_output_filter(ap_filter_t *f , apr_bucket_brigade *bb ) 
{ apr_bucket *e ;
  apr_status_t tmp ;

  {
  e = bb->list.prev;
  if ((unsigned int )e->type == (unsigned int )(& apr_bucket_type_eos)) {
    while (1) {
      while (1) {
        (e->link.prev)->link.next = e->link.next;
        (e->link.next)->link.prev = e->link.prev;
        break;
      }
      while (1) {
        ((*((e->type)->destroy)))(e->data);
        ((*(e->free)))((void *)e);
        break;
      }
      break;
    }
  }
  if (! ((unsigned int )bb->list.next == (unsigned int )((struct apr_bucket *)((char *)(& bb->list) -
                                                                               (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0)))))) {
    tmp = ap_pass_brigade(f->next, bb);
    return (tmp);
  }
  return (0);
}
}
int ap_some_auth_required(request_rec *r ) 
{ apr_array_header_t const   *reqs_arr ;
  apr_array_header_t const   *tmp ;
  require_line *reqs ;
  int i ;

  {
  tmp = ap_requires(r);
  reqs_arr = tmp;
  if (! reqs_arr) {
    return (0);
  }
  reqs = (require_line *)reqs_arr->elts;
  i = 0;
  while (i < reqs_arr->nelts) {
    if ((reqs + i)->method_mask & (1LL << r->method_number)) {
      return (1);
    }
    i ++;
  }
  return (0);
}
}
request_rec *ap_sub_req_method_uri(char const   *method , char const   *new_file ,
                                   request_rec const   *r , ap_filter_t *next_filter ) 
{ request_rec *rnew ;
  int res ;
  char *udir ;
  char const   *tmp ;

  {
  rnew = make_sub_request(r, next_filter);
  rnew->method = method;
  rnew->method_number = ap_method_number_of(method);
  if ((int const   )(*(new_file + 0)) == 47) {
    ap_parse_uri(rnew, new_file);
  } else {
    udir = ap_make_dirstr_parent(rnew->pool, (char const   *)r->uri);
    udir = ap_os_escape_path(rnew->pool, (char const   *)udir, 1);
    tmp = ap_make_full_path(rnew->pool, (char const   *)udir, new_file);
    ap_parse_uri(rnew, tmp);
  }
  res = ap_run_quick_handler(rnew, 1);
  if (res != 0) {
    res = ap_process_request_internal(rnew);
    if (res) {
      rnew->status = res;
    }
  }
  return (rnew);
}
}
request_rec *ap_sub_req_lookup_uri(char const   *new_file , request_rec const   *r ,
                                   ap_filter_t *next_filter ) 
{ request_rec *tmp ;

  {
  tmp = ap_sub_req_method_uri("GET", new_file, r, next_filter);
  return (tmp);
}
}
request_rec *ap_sub_req_lookup_dirent(apr_finfo_t const   *dirent , request_rec const   *r ,
                                      int subtype , ap_filter_t *next_filter ) 
{ request_rec *rnew ;
  int res ;
  char *fdir ;
  char *udir ;
  int tmp ;
  apr_status_t rv ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char const   *tmp___4 ;

  {
  rnew = make_sub_request(r, next_filter);
  if (r->path_info) {
    if ((*(r->path_info))) {
      udir = apr_pstrdup(rnew->pool, (char const   *)r->uri);
      tmp = ap_find_path_info((char const   *)udir, (char const   *)r->path_info);
      (*(udir + tmp)) = (char )'\000';
      udir = ap_make_dirstr_parent(rnew->pool, (char const   *)udir);
      rnew->uri = ap_make_full_path(rnew->pool, (char const   *)udir, dirent->name);
      if (subtype == 1) {
        rnew->uri = ap_make_full_path(rnew->pool, (char const   *)rnew->uri, (char const   *)(r->path_info +
                                                                                              1));
        rnew->path_info = apr_pstrdup(rnew->pool, (char const   *)r->path_info);
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    udir = ap_make_dirstr_parent(rnew->pool, (char const   *)r->uri);
    rnew->uri = ap_make_full_path(rnew->pool, (char const   *)udir, dirent->name);
  }
  fdir = ap_make_dirstr_parent(rnew->pool, (char const   *)r->filename);
  rnew->filename = ap_make_full_path(rnew->pool, (char const   *)fdir, dirent->name);
  if ((unsigned int )r->canonical_filename == (unsigned int )r->filename) {
    rnew->canonical_filename = rnew->filename;
  }
  rnew->per_dir_config = (r->server)->lookup_defaults;
  if ((dirent->valid & 33136) != 33136) {
    tmp___0 = ap_allow_options(rnew);
    if (tmp___0 & 4) {
      rv = apr_stat(& rnew->finfo, (char const   *)rnew->filename, 33136, rnew->pool);
      if (rv != 0) {
        if (rv != 70008) {
          rnew->finfo.filetype = (enum __anonenum_apr_filetype_e_42 )0;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: ;
      }
    } else {
      rv = apr_lstat(& rnew->finfo, (char const   *)rnew->filename, 33136, rnew->pool);
      if (rv != 0) {
        if (rv != 70008) {
          rnew->finfo.filetype = (enum __anonenum_apr_filetype_e_42 )0;
        } else {
          goto _L___1;
        }
      } else {
        _L___1: ;
      }
    }
  } else {
    memcpy((void * __restrict  )(& rnew->finfo), (void const   * __restrict  )dirent,
           sizeof(apr_finfo_t ));
  }
  if ((int )rnew->finfo.filetype == 6) {
    tmp___1 = ap_allow_options(rnew);
    res = resolve_symlink(rnew->filename, & rnew->finfo, tmp___1, rnew->pool);
    if (res != 0) {
      rnew->status = res;
      return (rnew);
    }
  }
  if ((int )rnew->finfo.filetype == 2) {
    tmp___2 = strlen((char const   *)rnew->filename);
    strcpy((char * __restrict  )(rnew->filename + tmp___2), (char const   * __restrict  )"/");
    if (! rnew->path_info) {
      goto _L___2;
    } else {
      if (! (*(rnew->path_info))) {
        _L___2: 
        tmp___3 = strlen((char const   *)rnew->uri);
        strcpy((char * __restrict  )(rnew->uri + tmp___3), (char const   * __restrict  )"/");
      }
    }
  }
  if (r->args) {
    if ((*(r->args))) {
      if (subtype == 1) {
        tmp___4 = apr_pstrcat(r->pool, rnew->uri, "?", r->args, (void *)0);
        ap_parse_uri(rnew, tmp___4);
      } else {
        goto _L___4;
      }
    } else {
      goto _L___4;
    }
  } else {
    _L___4: 
    ap_parse_uri(rnew, (char const   *)rnew->uri);
  }
  res = ap_process_request_internal(rnew);
  if (res) {
    rnew->status = res;
  }
  return (rnew);
}
}
request_rec *ap_sub_req_lookup_file(char const   *new_file , request_rec const   *r ,
                                    ap_filter_t *next_filter ) 
{ request_rec *rnew ;
  int res ;
  char *fdir ;
  apr_size_t fdirlen ;
  apr_status_t tmp ;
  apr_status_t rv ;
  int tmp___0 ;
  char *udir ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  rnew = make_sub_request(r, next_filter);
  fdir = ap_make_dirstr_parent(rnew->pool, (char const   *)r->filename);
  fdirlen = strlen((char const   *)fdir);
  if ((unsigned int )r->canonical_filename == (unsigned int )r->filename) {
    rnew->canonical_filename = (char *)1;
  }
  tmp = apr_filepath_merge(& rnew->filename, (char const   *)fdir, new_file, 32, rnew->pool);
  if (tmp != 0) {
    rnew->status = 403;
    return (rnew);
  }
  if (rnew->canonical_filename) {
    rnew->canonical_filename = rnew->filename;
  }
  tmp___2 = strncmp((char const   *)rnew->filename, (char const   *)fdir, fdirlen);
  if (tmp___2 == 0) {
    if ((*(rnew->filename + fdirlen))) {
      tmp___3 = strchr((char const   *)(rnew->filename + fdirlen), '/');
      if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
        tmp___0 = ap_allow_options(rnew);
        if (tmp___0 & 4) {
          rv = apr_stat(& rnew->finfo, (char const   *)rnew->filename, 33136, rnew->pool);
          if (rv != 0) {
            if (rv != 70008) {
              rnew->finfo.filetype = (enum __anonenum_apr_filetype_e_42 )0;
            } else {
              goto _L;
            }
          } else {
            _L: ;
          }
        } else {
          rv = apr_lstat(& rnew->finfo, (char const   *)rnew->filename, 33136, rnew->pool);
          if (rv != 0) {
            if (rv != 70008) {
              rnew->finfo.filetype = (enum __anonenum_apr_filetype_e_42 )0;
            } else {
              goto _L___0;
            }
          } else {
            _L___0: ;
          }
        }
        if (r->uri) {
          if ((*(r->uri))) {
            tmp___1 = ap_make_dirstr_parent(rnew->pool, (char const   *)r->uri);
            udir = tmp___1;
            rnew->uri = ap_make_full_path(rnew->pool, (char const   *)udir, (char const   *)(rnew->filename +
                                                                                             fdirlen));
            ap_parse_uri(rnew, (char const   *)rnew->uri);
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          ap_parse_uri(rnew, new_file);
          rnew->uri = apr_pstrdup(rnew->pool, "");
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    ap_parse_uri(rnew, new_file);
    rnew->uri = apr_pstrdup(rnew->pool, "");
  }
  res = ap_process_request_internal(rnew);
  if (res) {
    rnew->status = res;
  }
  return (rnew);
}
}
int ap_run_sub_req(request_rec *r ) 
{ int retval ;

  {
  retval = -1;
  if (r->filename) {
    if (! r->finfo.filetype) {
      goto _L;
    }
  } else {
    _L: 
    retval = ap_run_quick_handler(r, 0);
  }
  if (retval != 0) {
    retval = ap_invoke_handler(r);
    if (retval == -2) {
      retval = 0;
    }
  }
  ap_finalize_sub_req_protocol(r);
  return (retval);
}
}
void ap_destroy_sub_req(request_rec *r ) 
{ 

  {
  apr_pool_destroy(r->pool);
  return;
}
}
void ap_update_mtime(request_rec *r , apr_time_t dependency_mtime ) 
{ 

  {
  if (r->mtime < dependency_mtime) {
    r->mtime = dependency_mtime;
  }
  return;
}
}
int ap_is_initial_req(request_rec *r ) 
{ int tmp ;

  {
  if ((unsigned int )r->main == (unsigned int )((void *)0)) {
    if ((unsigned int )r->prev == (unsigned int )((void *)0)) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else {
    _L: 
    tmp = 0;
  }
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-YUCy1JPX.i","-g -pthread")
static apr_hash_t *global_providers  =    (apr_hash_t *)((void *)0);
static apr_status_t cleanup_global_providers(void *ctx ) 
{ 

  {
  global_providers = (apr_hash_t *)((void *)0);
  return (0);
}
}
apr_status_t ap_register_provider(apr_pool_t *pool , char const   *provider_group ,
                                  char const   *provider_name , char const   *provider_version ,
                                  void const   *provider ) 
{ apr_hash_t *provider_group_hash ;
  apr_hash_t *provider_version_hash ;

  {
  if ((unsigned int )global_providers == (unsigned int )((void *)0)) {
    global_providers = apr_hash_make(pool);
    apr_pool_cleanup_register(pool, (void const   *)((void *)0), & cleanup_global_providers,
                              & apr_pool_cleanup_null);
  }
  provider_group_hash = (apr_hash_t *)apr_hash_get(global_providers, (void const   *)provider_group,
                                                   -1);
  if (! provider_group_hash) {
    provider_group_hash = apr_hash_make(pool);
    apr_hash_set(global_providers, (void const   *)provider_group, -1, (void const   *)provider_group_hash);
  }
  provider_version_hash = (apr_hash_t *)apr_hash_get(provider_group_hash, (void const   *)provider_name,
                                                     -1);
  if (! provider_version_hash) {
    provider_version_hash = apr_hash_make(pool);
    apr_hash_set(provider_group_hash, (void const   *)provider_name, -1, (void const   *)provider_version_hash);
  }
  apr_hash_set(provider_version_hash, (void const   *)provider_version, -1, provider);
  return (0);
}
}
void *ap_lookup_provider(char const   *provider_group , char const   *provider_name ,
                         char const   *provider_version ) 
{ apr_hash_t *provider_group_hash ;
  apr_hash_t *provider_name_hash ;
  void *tmp ;

  {
  if ((unsigned int )global_providers == (unsigned int )((void *)0)) {
    return ((void *)0);
  }
  provider_group_hash = (apr_hash_t *)apr_hash_get(global_providers, (void const   *)provider_group,
                                                   -1);
  if ((unsigned int )provider_group_hash == (unsigned int )((void *)0)) {
    return ((void *)0);
  }
  provider_name_hash = (apr_hash_t *)apr_hash_get(provider_group_hash, (void const   *)provider_name,
                                                  -1);
  if ((unsigned int )provider_name_hash == (unsigned int )((void *)0)) {
    return ((void *)0);
  }
  tmp = apr_hash_get(provider_name_hash, (void const   *)provider_version, -1);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-73W3P0lU.i","-g -pthread")
extern int getrlimit(__rlimit_resource_t __resource , struct rlimit *__rlimits ) ;
extern struct passwd *getpwuid(__uid_t __uid ) ;
extern int initgroups(char const   *__user , __gid_t __group ) ;
unixd_config_rec unixd_config  ;
extern __uid_t geteuid(void) ;
extern int setuid(__uid_t __uid ) ;
extern int setgid(__gid_t __gid ) ;
extern int semctl(int __semid , int __semnum , int __cmd  , ...) ;
static int set_group_privs(void) 
{ char const   *name ;
  struct passwd *ent ;
  uid_t uid ;
  uid_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  __uid_t tmp___5 ;

  {
  tmp___5 = geteuid();
  if (! tmp___5) {
    if ((int const   )(*(unixd_config.user_name + 0)) == 35) {
      tmp = (uid_t )atoi(unixd_config.user_name + 1);
      uid = tmp;
      ent = getpwuid(uid);
      if ((unsigned int )ent == (unsigned int )((void *)0)) {
        tmp___0 = __errno_location();
        ap_log_error("unixd.c", 114, 1, (*tmp___0), (server_rec const   *)((void *)0),
                     "getpwuid: couldn\'t determine user name from uid %u, you probably need to modify the User directive",
                     uid);
        return (-1);
      }
      name = (char const   *)ent->pw_name;
    } else {
      name = unixd_config.user_name;
    }
    tmp___2 = setgid(unixd_config.group_id);
    if (tmp___2 == -1) {
      tmp___1 = __errno_location();
      ap_log_error("unixd.c", 134, 1, (*tmp___1), (server_rec const   *)((void *)0),
                   "setgid: unable to set group id to Group %u", unixd_config.group_id);
      return (-1);
    }
    tmp___4 = initgroups(name, unixd_config.group_id);
    if (tmp___4 == -1) {
      tmp___3 = __errno_location();
      ap_log_error("unixd.c", 143, 1, (*tmp___3), (server_rec const   *)((void *)0),
                   "initgroups: unable to set groups for User %s and Group %u", name,
                   unixd_config.group_id);
      return (-1);
    }
  }
  return (0);
}
}
int unixd_setup_child(void) 
{ int tmp ;
  int *tmp___0 ;
  __uid_t tmp___1 ;
  int tmp___2 ;

  {
  tmp = set_group_privs();
  if (tmp) {
    return (-1);
  }
  tmp___1 = geteuid();
  if (tmp___1) {
    _L: /* CIL Label */ ;
  } else {
    tmp___2 = setuid(unixd_config.user_id);
    if (tmp___2 == -1) {
      tmp___0 = __errno_location();
      ap_log_error("unixd.c", 179, 1, (*tmp___0), (server_rec const   *)((void *)0),
                   "setuid: unable to change to uid: %ld", (long )unixd_config.user_id);
      return (-1);
    } else {
      goto _L;
    }
  }
  return (0);
}
}
char const   *unixd_set_user(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  unixd_config.user_name = arg;
  unixd_config.user_id = ap_uname2id(arg);
  if (unixd_config.user_id == 0U) {
    return ("Error:\tApache has not been designed to serve pages while\n\trunning as root.  There are known race conditions that\n\twill allow any local user to read any file on the system.\n\tIf you still desire to serve pages as root then\n\tadd -DBIG_SECURITY_HOLE to the CFLAGS env variable\n\tand then rebuild the server.\n\tIt is strongly suggested that you instead modify the User\n\tdirective in your httpd.conf file to list a non-root\n\tuser.\n");
  }
  return ((char const   *)((void *)0));
}
}
char const   *unixd_set_group(cmd_parms *cmd , void *dummy , char const   *arg ) 
{ char const   *err ;
  char const   *tmp ;

  {
  tmp = ap_check_cmd_context(cmd, 31U);
  err = tmp;
  if ((unsigned int )err != (unsigned int )((void *)0)) {
    return (err);
  }
  unixd_config.group_id = ap_gname2id(arg);
  return ((char const   *)((void *)0));
}
}
void unixd_pre_config(apr_pool_t *ptemp ) 
{ apr_finfo_t wrapper ;
  apr_status_t tmp ;

  {
  unixd_config.user_name = "#-1";
  unixd_config.user_id = ap_uname2id("#-1");
  unixd_config.group_id = ap_gname2id("#-1");
  unixd_config.suexec_enabled = 0;
  tmp = apr_stat(& wrapper, "/usr/local/apache2/bin/suexec", 7582064, ptemp);
  if (tmp != 0) {
    return;
  }
  unixd_config.suexec_enabled = 1;
  return;
}
}
void unixd_set_rlimit(cmd_parms *cmd , struct rlimit **plimit , char const   *arg ,
                      char const   *arg2 , int type ) 
{ char *str ;
  struct rlimit *limit ;
  rlim_t cur ;
  rlim_t max ;
  void *tmp ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __uid_t tmp___4 ;

  {
  cur = (rlim_t )0;
  max = (rlim_t )0;
  tmp = apr_palloc(cmd->pool, sizeof((*((*plimit)))));
  (*plimit) = (struct rlimit *)memset(tmp, 0, sizeof((*((*plimit)))));
  limit = (*plimit);
  tmp___2 = getrlimit((enum __rlimit_resource )type, limit);
  if (tmp___2 != 0) {
    (*plimit) = (struct rlimit *)((void *)0);
    tmp___1 = __errno_location();
    ap_log_error("unixd.c", 265, 3, (*tmp___1), (server_rec const   *)cmd->server,
                 "%s: getrlimit failed", (cmd->cmd)->name);
    return;
  }
  str = ap_getword_conf(cmd->pool, & arg);
  if (str) {
    tmp___3 = strcasecmp((char const   *)str, "max");
    if (tmp___3) {
      cur = (rlim_t )atol((char const   *)str);
    } else {
      cur = limit->rlim_max;
    }
  } else {
    ap_log_error("unixd.c", 279, 3, 0, (server_rec const   *)cmd->server, "Invalid parameters for %s",
                 (cmd->cmd)->name);
    return;
  }
  if (arg2) {
    str = ap_getword_conf(cmd->pool, & arg2);
    if (str) {
      max = (rlim_t )atol((char const   *)str);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
  tmp___4 = geteuid();
  if (tmp___4) {
    limit->rlim_cur = cur;
    if (max) {
      ap_log_error("unixd.c", 292, 3, 0, (server_rec const   *)cmd->server, "Must be uid 0 to raise maximum %s",
                   (cmd->cmd)->name);
    }
  } else {
    if (cur) {
      limit->rlim_cur = cur;
    }
    if (max) {
      limit->rlim_max = max;
    }
  }
  return;
}
}
static struct __anonstruct__hooks_94___0 _hooks___6  ;
void ap_hook_get_suexec_identity(ap_HOOK_get_suexec_identity_t *pf , char const   * const  *aszPre___1 ,
                                 char const   * const  *aszSucc___2 , int nOrder ) 
{ ap_LINK_get_suexec_identity_t *pHook ;

  {
  if (! _hooks___6.link_get_suexec_identity) {
    _hooks___6.link_get_suexec_identity = apr_array_make(apr_hook_global_pool, 1,
                                                         (int )sizeof(ap_LINK_get_suexec_identity_t ));
    apr_hook_sort_register("get_suexec_identity", & _hooks___6.link_get_suexec_identity);
  }
  pHook = (ap_LINK_get_suexec_identity_t *)apr_array_push(_hooks___6.link_get_suexec_identity);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show("get_suexec_identity", aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_array_header_t *ap_hook_get_get_suexec_identity(void) 
{ 

  {
  return (_hooks___6.link_get_suexec_identity);
}
}
ap_unix_identity_t *ap_run_get_suexec_identity(request_rec const   *r ) 
{ ap_LINK_get_suexec_identity_t *pHook ;
  int n ;
  ap_unix_identity_t *rv ;

  {
  if (! _hooks___6.link_get_suexec_identity) {
    return ((ap_unix_identity_t *)((void *)0));
  }
  pHook = (ap_LINK_get_suexec_identity_t *)(_hooks___6.link_get_suexec_identity)->elts;
  n = 0;
  while (n < (_hooks___6.link_get_suexec_identity)->nelts) {
    rv = ((*((pHook + n)->pFunc)))(r);
    if ((unsigned int )rv != (unsigned int )((void *)0)) {
      return (rv);
    }
    n ++;
  }
  return ((ap_unix_identity_t *)((void *)0));
}
}
static apr_status_t ap_unix_create_privileged_process(apr_proc_t *newproc , char const   *progname ,
                                                      char const   * const  *args ,
                                                      char const   * const  *env ,
                                                      apr_procattr_t *attr , ap_unix_identity_t *ugid ,
                                                      apr_pool_t *p ) 
{ int i ;
  char const   **newargs ;
  char *newprogname ;
  char *execuser ;
  char *execgroup ;
  char const   *argv0 ;
  apr_status_t tmp ;
  apr_status_t tmp___0 ;
  int tmp___1 ;
  apr_status_t tmp___2 ;

  {
  i = 0;
  if (! unixd_config.suexec_enabled) {
    tmp = apr_proc_create(newproc, progname, args, env, attr, p);
    return (tmp);
  }
  argv0 = strrchr(progname, '/');
  if ((unsigned int )argv0 != (unsigned int )((void *)0)) {
    argv0 ++;
  } else {
    argv0 = progname;
  }
  if (ugid->userdir) {
    execuser = apr_psprintf(p, "~%ld", (long )ugid->uid);
  } else {
    execuser = apr_psprintf(p, "%ld", (long )ugid->uid);
  }
  execgroup = apr_psprintf(p, "%ld", (long )ugid->gid);
  if (! execuser) {
    goto _L;
  } else {
    if (! execgroup) {
      _L: /* CIL Label */ 
      return (12);
    }
  }
  i = 0;
  if (args) {
    while ((*(args + i))) {
      i ++;
    }
  }
  newargs = (char const   **)apr_palloc(p, sizeof(char *) * (unsigned int )(i + 4));
  newprogname = (char *)"/usr/local/apache2/bin/suexec";
  (*(newargs + 0)) = "/usr/local/apache2/bin/suexec";
  (*(newargs + 1)) = (char const   *)execuser;
  (*(newargs + 2)) = (char const   *)execgroup;
  (*(newargs + 3)) = apr_pstrdup(p, argv0);
  tmp___0 = apr_procattr_cmdtype_set(attr, 1);
  if (tmp___0 != 0) {
    return (20014);
  }
  i = 1;
  while (1) {
    (*(newargs + (i + 3))) = (char const   *)(*(args + i));
    tmp___1 = i;
    i ++;
    if (! (*(args + tmp___1))) {
      break;
    }
  }
  tmp___2 = apr_proc_create(newproc, (char const   *)newprogname, (char const   * const  *)newargs,
                            env, attr, p);
  return (tmp___2);
}
}
apr_status_t ap_os_create_privileged_process(request_rec const   *r , apr_proc_t *newproc ,
                                             char const   *progname , char const   * const  *args ,
                                             char const   * const  *env , apr_procattr_t *attr ,
                                             apr_pool_t *p ) 
{ ap_unix_identity_t *ugid ;
  ap_unix_identity_t *tmp ;
  apr_status_t tmp___0 ;
  apr_status_t tmp___1 ;

  {
  tmp = ap_run_get_suexec_identity(r);
  ugid = tmp;
  if ((unsigned int )ugid == (unsigned int )((void *)0)) {
    tmp___0 = apr_proc_create(newproc, progname, args, env, attr, p);
    return (tmp___0);
  }
  tmp___1 = ap_unix_create_privileged_process(newproc, progname, args, env, attr,
                                              ugid, p);
  return (tmp___1);
}
}
apr_status_t unixd_set_proc_mutex_perms(apr_proc_mutex_t *pmutex ) 
{ apr_os_proc_mutex_t ospmutex ;
  union semun ick ;
  struct semid_ds buf ;
  int *tmp ;
  int tmp___0 ;
  __uid_t tmp___1 ;

  {
  tmp___1 = geteuid();
  if (! tmp___1) {
    apr_os_proc_mutex_get(& ospmutex, pmutex);
    buf.sem_perm.uid = unixd_config.user_id;
    buf.sem_perm.gid = unixd_config.group_id;
    buf.sem_perm.mode = (unsigned short)384;
    ick.buf = & buf;
    tmp___0 = semctl(ospmutex.crossproc, 0, 1, ick);
    if (tmp___0 < 0) {
      tmp = __errno_location();
      return ((*tmp));
    }
  }
  return (0);
}
}
apr_status_t unixd_set_global_mutex_perms(apr_global_mutex_t *gmutex ) 
{ apr_os_global_mutex_t osgmutex ;
  apr_status_t tmp ;

  {
  apr_os_global_mutex_get(& osgmutex, gmutex);
  tmp = unixd_set_proc_mutex_perms(osgmutex.proc_mutex);
  return (tmp);
}
}
apr_status_t unixd_accept(void **accepted , ap_listen_rec *lr , apr_pool_t *ptrans ) 
{ apr_socket_t *csd ;
  apr_status_t status ;
  int sockdes ;

  {
  (*accepted) = (void *)0;
  status = apr_accept(& csd, lr->sd, ptrans);
  if (status == 0) {
    (*accepted) = (void *)csd;
    apr_os_sock_get(& sockdes, csd);
    if (sockdes >= 1024) {
      ap_log_error("unixd.c", 462, 4, 0, (server_rec const   *)((void *)0), "new file descriptor %d is too large; you probably need to rebuild Apache with a larger FD_SETSIZE (currently %d)",
                   sockdes, 1024);
      apr_socket_close(csd);
      return (4);
    }
    return (status);
  }
  if (status == 4) {
    return (status);
  }
  switch (status) {
  case 71: ;
  case 103: ;
  case 104: ;
  case 110: ;
  case 113: ;
  case 101: ;
  break;
  case 100: 
  ap_log_error("unixd.c", 560, 0, status, (server_rec const   *)ap_server_conf, "apr_accept: giving up.");
  return (20014);
  default: 
  ap_log_error("unixd.c", 577, 3, status, (server_rec const   *)ap_server_conf, "apr_accept: (client socket)");
  return (20014);
  }
  return (status);
}
}
#pragma merger(0,"/tmp/cil-4g4HvR6f.i","-g -pthread")
void *(*pcre_malloc)(size_t  ) ;
unsigned char const   *pcre_maketables(void) ;
unsigned char const   *pcre_maketables(void) 
{ unsigned char *yield ;
  unsigned char *p ;
  int i ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___13 ;
  unsigned short const   **tmp___14 ;
  int x ;
  unsigned short const   **tmp___15 ;
  unsigned short const   **tmp___16 ;
  unsigned short const   **tmp___17 ;
  unsigned short const   **tmp___18 ;
  unsigned short const   **tmp___19 ;
  char *tmp___20 ;
  unsigned char *tmp___21 ;

  {
  yield = (unsigned char *)((*pcre_malloc))(1088U);
  if ((unsigned int )yield == (unsigned int )((void *)0)) {
    return ((unsigned char const   *)((void *)0));
  }
  p = yield;
  i = 0;
  while (i < 256) {
    tmp___0 = p;
    p ++;
    (*tmp___0) = (unsigned char )tolower(i);
    i ++;
  }
  i = 0;
  while (i < 256) {
    tmp___1 = p;
    p ++;
    tmp___5 = __ctype_b_loc();
    if ((int const   )(*((*tmp___5) + i)) & 512) {
      (*tmp___1) = (unsigned char )toupper(i);
    } else {
      (*tmp___1) = (unsigned char )tolower(i);
    }
    i ++;
  }
  memset((void *)p, 0, 320U);
  i = 0;
  while (i < 256) {
    tmp___6 = __ctype_b_loc();
    if ((int const   )(*((*tmp___6) + i)) & 2048) {
      (*(p + (64 + i / 8))) = (unsigned char )((int )(*(p + (64 + i / 8))) | (1 <<
                                                                              (i &
                                                                               7)));
      (*(p + (160 + i / 8))) = (unsigned char )((int )(*(p + (160 + i / 8))) | (1 <<
                                                                                (i &
                                                                                 7)));
    }
    tmp___7 = __ctype_b_loc();
    if ((int const   )(*((*tmp___7) + i)) & 256) {
      (*(p + (96 + i / 8))) = (unsigned char )((int )(*(p + (96 + i / 8))) | (1 <<
                                                                              (i &
                                                                               7)));
      (*(p + (160 + i / 8))) = (unsigned char )((int )(*(p + (160 + i / 8))) | (1 <<
                                                                                (i &
                                                                                 7)));
    }
    tmp___8 = __ctype_b_loc();
    if ((int const   )(*((*tmp___8) + i)) & 512) {
      (*(p + (128 + i / 8))) = (unsigned char )((int )(*(p + (128 + i / 8))) | (1 <<
                                                                                (i &
                                                                                 7)));
      (*(p + (160 + i / 8))) = (unsigned char )((int )(*(p + (160 + i / 8))) | (1 <<
                                                                                (i &
                                                                                 7)));
    }
    if (i == 95) {
      (*(p + (160 + i / 8))) = (unsigned char )((int )(*(p + (160 + i / 8))) | (1 <<
                                                                                (i &
                                                                                 7)));
    }
    tmp___9 = __ctype_b_loc();
    if ((int const   )(*((*tmp___9) + i)) & 8192) {
      (*(p + i / 8)) = (unsigned char )((int )(*(p + i / 8)) | (1 << (i & 7)));
    }
    tmp___10 = __ctype_b_loc();
    if ((int const   )(*((*tmp___10) + i)) & 4096) {
      (*(p + (32 + i / 8))) = (unsigned char )((int )(*(p + (32 + i / 8))) | (1 <<
                                                                              (i &
                                                                               7)));
    }
    tmp___11 = __ctype_b_loc();
    if ((int const   )(*((*tmp___11) + i)) & 32768) {
      (*(p + (192 + i / 8))) = (unsigned char )((int )(*(p + (192 + i / 8))) | (1 <<
                                                                                (i &
                                                                                 7)));
    }
    tmp___12 = __ctype_b_loc();
    if ((int const   )(*((*tmp___12) + i)) & 16384) {
      (*(p + (224 + i / 8))) = (unsigned char )((int )(*(p + (224 + i / 8))) | (1 <<
                                                                                (i &
                                                                                 7)));
    }
    tmp___13 = __ctype_b_loc();
    if ((int const   )(*((*tmp___13) + i)) & 4) {
      (*(p + (256 + i / 8))) = (unsigned char )((int )(*(p + (256 + i / 8))) | (1 <<
                                                                                (i &
                                                                                 7)));
    }
    tmp___14 = __ctype_b_loc();
    if ((int const   )(*((*tmp___14) + i)) & 2) {
      (*(p + (288 + i / 8))) = (unsigned char )((int )(*(p + (288 + i / 8))) | (1 <<
                                                                                (i &
                                                                                 7)));
    }
    i ++;
  }
  p += 320;
  i = 0;
  while (i < 256) {
    x = 0;
    tmp___15 = __ctype_b_loc();
    if ((int const   )(*((*tmp___15) + i)) & 8192) {
      x ++;
    }
    tmp___16 = __ctype_b_loc();
    if ((int const   )(*((*tmp___16) + i)) & 1024) {
      x += 2;
    }
    tmp___17 = __ctype_b_loc();
    if ((int const   )(*((*tmp___17) + i)) & 2048) {
      x += 4;
    }
    tmp___18 = __ctype_b_loc();
    if ((int const   )(*((*tmp___18) + i)) & 4096) {
      x += 8;
    }
    tmp___19 = __ctype_b_loc();
    if ((int const   )(*((*tmp___19) + i)) & 8) {
      goto _L;
    } else {
      if (i == 95) {
        _L: 
        x += 16;
      }
    }
    tmp___20 = strchr("*+?{^.$|()[", i);
    if ((unsigned int )tmp___20 != (unsigned int )((char *)0)) {
      x += 128;
    }
    tmp___21 = p;
    p ++;
    (*tmp___21) = (unsigned char )x;
    i ++;
  }
  return ((unsigned char const   *)yield);
}
}
#pragma merger(0,"/tmp/cil-CszN913A.i","-g -pthread")
void (*pcre_free)(void * ) ;
int pcre_copy_substring(char const   *subject , int *ovector , int stringcount , int stringnumber ,
                        char *buffer , int size ) ;
void pcre_free_substring(char const   *pointer ) ;
void pcre_free_substring_list(char const   **pointer ) ;
int pcre_get_substring(char const   *subject , int *ovector , int stringcount , int stringnumber ,
                       char const   **stringptr ) ;
int pcre_get_substring_list(char const   *subject , int *ovector , int stringcount ,
                            char const   ***listptr ) ;
int pcre_copy_substring(char const   *subject , int *ovector , int stringcount , int stringnumber ,
                        char *buffer , int size ) 
{ int yield ;

  {
  if (stringnumber < 0) {
    goto _L;
  } else {
    if (stringnumber >= stringcount) {
      _L: 
      return (-7);
    }
  }
  stringnumber *= 2;
  yield = (*(ovector + (stringnumber + 1))) - (*(ovector + stringnumber));
  if (size < yield + 1) {
    return (-6);
  }
  memcpy((void * __restrict  )buffer, (void const   * __restrict  )(subject + (*(ovector +
                                                                                 stringnumber))),
         (unsigned int )yield);
  (*(buffer + yield)) = (char)0;
  return (yield);
}
}
int pcre_get_substring_list(char const   *subject , int *ovector , int stringcount ,
                            char const   ***listptr ) 
{ int i ;
  int size ;
  int double_count ;
  char **stringlist ;
  char *p ;
  int len ;
  char **tmp___0 ;
  char *tmp___1 ;

  {
  size = (int )sizeof(char *);
  double_count = stringcount * 2;
  i = 0;
  while (i < double_count) {
    size = (int )((unsigned int )size + (((sizeof(char *) + (unsigned int )(*(ovector +
                                                                              (i +
                                                                               1)))) -
                                          (unsigned int )(*(ovector + i))) + 1U));
    i += 2;
  }
  stringlist = (char **)((*pcre_malloc))((unsigned int )size);
  if ((unsigned int )stringlist == (unsigned int )((void *)0)) {
    return (-6);
  }
  (*listptr) = (char const   **)stringlist;
  p = (char *)((stringlist + stringcount) + 1);
  i = 0;
  while (i < double_count) {
    len = (*(ovector + (i + 1))) - (*(ovector + i));
    memcpy((void * __restrict  )p, (void const   * __restrict  )(subject + (*(ovector +
                                                                              i))),
           (unsigned int )len);
    tmp___0 = stringlist;
    stringlist ++;
    (*tmp___0) = p;
    p += len;
    tmp___1 = p;
    p ++;
    (*tmp___1) = (char)0;
    i += 2;
  }
  (*stringlist) = (char *)((void *)0);
  return (0);
}
}
void pcre_free_substring_list(char const   **pointer ) 
{ 

  {
  ((*pcre_free))((void *)pointer);
  return;
}
}
int pcre_get_substring(char const   *subject , int *ovector , int stringcount , int stringnumber ,
                       char const   **stringptr ) 
{ int yield ;
  char *substring ;

  {
  if (stringnumber < 0) {
    goto _L;
  } else {
    if (stringnumber >= stringcount) {
      _L: 
      return (-7);
    }
  }
  stringnumber *= 2;
  yield = (*(ovector + (stringnumber + 1))) - (*(ovector + stringnumber));
  substring = (char *)((*pcre_malloc))((unsigned int )(yield + 1));
  if ((unsigned int )substring == (unsigned int )((void *)0)) {
    return (-6);
  }
  memcpy((void * __restrict  )substring, (void const   * __restrict  )(subject + (*(ovector +
                                                                                    stringnumber))),
         (unsigned int )yield);
  (*(substring + yield)) = (char)0;
  (*stringptr) = (char const   *)substring;
  return (yield);
}
}
void pcre_free_substring(char const   *pointer ) 
{ 

  {
  ((*pcre_free))((void *)pointer);
  return;
}
}
#pragma merger(0,"/tmp/cil-aW8qECot.i","-g -pthread")
pcre_extra *pcre_study(pcre const   *external_re , int options , char const   **errorptr ) ;
static void set_bit(uschar *start_bits , int c , BOOL caseless , compile_data *cd ) 
{ 

  {
  (*(start_bits + c / 8)) = (unsigned char )((int )(*(start_bits + c / 8)) | (1 <<
                                                                              (c &
                                                                               7)));
  if (caseless) {
    if (((int const   )(*(cd->ctypes + c)) & 2) != 0) {
      (*(start_bits + (int const   )(*(cd->fcc + c)) / 8)) = (unsigned char )((int )(*(start_bits +
                                                                                       (int const   )(*(cd->fcc +
                                                                                                        c)) /
                                                                                       8)) |
                                                                              (1 <<
                                                                               ((int const   )(*(cd->fcc +
                                                                                                 c)) &
                                                                                7)));
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  return;
}
}
static BOOL set_start_bits(uschar const   *code , uschar *start_bits , BOOL caseless ,
                           compile_data *cd ) 
{ register int c ;
  int volatile   dummy ;
  uschar const   *tcode ;
  BOOL try_next ;
  BOOL tmp ;
  BOOL tmp___0 ;

  {
  while (1) {
    tcode = code + 3;
    try_next = 1;
    while (try_next) {
      if ((int )(*tcode) >= 71) {
        goto _L;
      } else {
        if ((int const   )(*tcode) == 60) {
          _L: 
          tmp = set_start_bits(tcode, start_bits, caseless, cd);
          if (! tmp) {
            return (0);
          }
          try_next = 0;
        } else {
          switch ((int )(*tcode)) {
          default: ;
          return (0);
          case 70: 
          tcode += 3;
          break;
          case 61: ;
          case 62: ;
          case 63: ;
          while (1) {
            tcode += ((int const   )(*(tcode + 1)) << 8) + (int const   )(*(tcode +
                                                                            2));
            if (! ((int const   )(*tcode) == 56)) {
              break;
            }
          }
          tcode += 3;
          break;
          case 12: 
          caseless = ((int const   )(*(tcode + 1)) & 1) != 0;
          tcode += 2;
          break;
          case 68: ;
          case 69: 
          tcode ++;
          tmp___0 = set_start_bits(tcode, start_bits, caseless, cd);
          if (! tmp___0) {
            return (0);
          }
          dummy = (int volatile   )1;
          while (1) {
            tcode += ((int const   )(*(tcode + 1)) << 8) + (int const   )(*(tcode +
                                                                            2));
            if (! ((int const   )(*tcode) == 56)) {
              break;
            }
          }
          tcode += 3;
          break;
          case 18: ;
          case 19: ;
          case 22: ;
          case 23: 
          set_bit(start_bits, (int )(*(tcode + 1)), caseless, cd);
          tcode += 2;
          break;
          case 24: ;
          case 25: 
          set_bit(start_bits, (int )(*(tcode + 3)), caseless, cd);
          tcode += 4;
          break;
          case 26: 
          tcode ++;
          case 16: 
          tcode ++;
          case 20: ;
          case 21: 
          set_bit(start_bits, (int )(*(tcode + 1)), caseless, cd);
          try_next = 0;
          break;
          case 4: 
          c = 0;
          while (c < 32) {
            (*(start_bits + c)) = (unsigned char )((int )(*(start_bits + c)) | (int )(~ ((int const   )(*(cd->cbits +
                                                                                                          (c +
                                                                                                           64))))));
            c ++;
          }
          try_next = 0;
          break;
          case 5: 
          c = 0;
          while (c < 32) {
            (*(start_bits + c)) = (unsigned char )((int )(*(start_bits + c)) | (int )(*(cd->cbits +
                                                                                        (c +
                                                                                         64))));
            c ++;
          }
          try_next = 0;
          break;
          case 6: 
          c = 0;
          while (c < 32) {
            (*(start_bits + c)) = (unsigned char )((int )(*(start_bits + c)) | (int )(~ ((int const   )(*(cd->cbits +
                                                                                                          c)))));
            c ++;
          }
          try_next = 0;
          break;
          case 7: 
          c = 0;
          while (c < 32) {
            (*(start_bits + c)) = (unsigned char )((int )(*(start_bits + c)) | (int )(*(cd->cbits +
                                                                                        c)));
            c ++;
          }
          try_next = 0;
          break;
          case 8: 
          c = 0;
          while (c < 32) {
            (*(start_bits + c)) = (unsigned char )((int )(*(start_bits + c)) | (int )(~ ((int const   )(*(cd->cbits +
                                                                                                          (c +
                                                                                                           160))))));
            c ++;
          }
          try_next = 0;
          break;
          case 9: 
          c = 0;
          while (c < 32) {
            (*(start_bits + c)) = (unsigned char )((int )(*(start_bits + c)) | (int )(*(cd->cbits +
                                                                                        (c +
                                                                                         160))));
            c ++;
          }
          try_next = 0;
          break;
          case 38: ;
          case 39: 
          tcode ++;
          break;
          case 44: 
          tcode += 3;
          break;
          case 42: ;
          case 43: 
          tcode += 2;
          case 36: ;
          case 37: ;
          case 40: ;
          case 41: ;
          switch ((int )(*(tcode + 1))) {
          case 4: 
          c = 0;
          while (c < 32) {
            (*(start_bits + c)) = (unsigned char )((int )(*(start_bits + c)) | (int )(~ ((int const   )(*(cd->cbits +
                                                                                                          (c +
                                                                                                           64))))));
            c ++;
          }
          break;
          case 5: 
          c = 0;
          while (c < 32) {
            (*(start_bits + c)) = (unsigned char )((int )(*(start_bits + c)) | (int )(*(cd->cbits +
                                                                                        (c +
                                                                                         64))));
            c ++;
          }
          break;
          case 6: 
          c = 0;
          while (c < 32) {
            (*(start_bits + c)) = (unsigned char )((int )(*(start_bits + c)) | (int )(~ ((int const   )(*(cd->cbits +
                                                                                                          c)))));
            c ++;
          }
          break;
          case 7: 
          c = 0;
          while (c < 32) {
            (*(start_bits + c)) = (unsigned char )((int )(*(start_bits + c)) | (int )(*(cd->cbits +
                                                                                        c)));
            c ++;
          }
          break;
          case 8: 
          c = 0;
          while (c < 32) {
            (*(start_bits + c)) = (unsigned char )((int )(*(start_bits + c)) | (int )(~ ((int const   )(*(cd->cbits +
                                                                                                          (c +
                                                                                                           160))))));
            c ++;
          }
          break;
          case 9: 
          c = 0;
          while (c < 32) {
            (*(start_bits + c)) = (unsigned char )((int )(*(start_bits + c)) | (int )(*(cd->cbits +
                                                                                        (c +
                                                                                         160))));
            c ++;
          }
          break;
          }
          tcode += 2;
          break;
          case 53: 
          tcode ++;
          c = 0;
          while (c < 32) {
            (*(start_bits + c)) = (unsigned char )((int )(*(start_bits + c)) | (int )(*(tcode +
                                                                                        c)));
            c ++;
          }
          tcode += 32;
          switch ((int )(*tcode)) {
          case 45: ;
          case 46: ;
          case 49: ;
          case 50: 
          tcode ++;
          break;
          case 51: ;
          case 52: ;
          if (((int const   )(*(tcode + 1)) << 8) + (int const   )(*(tcode + 2)) ==
              0) {
            tcode += 5;
          } else {
            try_next = 0;
          }
          break;
          default: 
          try_next = 0;
          break;
          }
          break;
          }
        }
      }
    }
    code += ((int const   )(*(code + 1)) << 8) + (int const   )(*(code + 2));
    if (! ((int const   )(*code) == 56)) {
      break;
    }
  }
  return (1);
}
}
pcre_extra *pcre_study(pcre const   *external_re , int options , char const   **errorptr ) 
{ uschar start_bits[32] ;
  real_pcre_extra *extra ;
  real_pcre const   *re ;
  compile_data compile_block ;
  BOOL tmp ;

  {
  re = external_re;
  (*errorptr) = (char const   *)((void *)0);
  if ((unsigned int )re == (unsigned int )((void *)0)) {
    goto _L;
  } else {
    if (re->magic_number != 1346589253UL) {
      _L: 
      (*errorptr) = "argument is not a compiled regular expression";
      return ((pcre_extra *)((void *)0));
    }
  }
  if ((options & -1) != 0) {
    (*errorptr) = "unknown or incorrect option bit(s) set";
    return ((pcre_extra *)((void *)0));
  }
  if ((re->options & 1342177296UL) != 0UL) {
    return ((pcre_extra *)((void *)0));
  }
  compile_block.lcc = re->tables + 0;
  compile_block.fcc = re->tables + 256;
  compile_block.cbits = re->tables + 512;
  compile_block.ctypes = re->tables + 832;
  memset((void *)(start_bits), 0, 32U * sizeof(uschar ));
  tmp = set_start_bits((uschar const   *)(re->code), start_bits, (re->options & 1UL) !=
                                                                 0UL, & compile_block);
  if (! tmp) {
    return ((pcre_extra *)((void *)0));
  }
  extra = (real_pcre_extra *)((*pcre_malloc))(sizeof(real_pcre_extra ));
  if ((unsigned int )extra == (unsigned int )((void *)0)) {
    (*errorptr) = "failed to get memory";
    return ((pcre_extra *)((void *)0));
  }
  extra->options = (unsigned char)1;
  memcpy((void * __restrict  )(extra->start_bits), (void const   * __restrict  )(start_bits),
         sizeof(start_bits));
  return (extra);
}
}
#pragma merger(0,"/tmp/cil-2fGX3gUE.i","-g -pthread")
extern void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern void *memmove(void *__dest , void const   *__src , size_t __n ) ;
pcre *pcre_compile(char const   *pattern , int options , char const   **errorptr ,
                   int *erroroffset , unsigned char const   *tables ) ;
int pcre_exec(pcre const   *external_re , pcre_extra const   *external_extra , char const   *subject ,
              int length , int start_offset , int options , int *offsets , int offsetcount ) ;
int pcre_info(pcre const   *external_re , int *optptr , int *first_char ) ;
int pcre_fullinfo(pcre const   *external_re , pcre_extra const   *study_data , int what ,
                  void *where ) ;
char const   *pcre_version(void) ;
static char const   rep_min[6]  = {      (char const   )0,      (char const   )0,      (char const   )1,      (char const   )1, 
        (char const   )0,      (char const   )0};
static char const   rep_max[6]  = {      (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )1,      (char const   )1};
static short const   escapes[75]  = 
  {      (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )':',      (short const   )';', 
        (short const   )'<',      (short const   )'=',      (short const   )'>',      (short const   )'?', 
        (short const   )'@',      (short const   )-1,      (short const   )-2,      (short const   )0, 
        (short const   )-4,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )-6, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )-8, 
        (short const   )0,      (short const   )0,      (short const   )-10,      (short const   )'[', 
        (short const   )'\\',      (short const   )']',      (short const   )'^',      (short const   )'_', 
        (short const   )'`',      (short const   )7,      (short const   )-3,      (short const   )0, 
        (short const   )-5,      (short const   )27,      (short const   )'\f',      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )'\n',      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )'\r',      (short const   )-7, 
        (short const   )'\t',      (short const   )0,      (short const   )0,      (short const   )-9, 
        (short const   )0,      (short const   )0,      (short const   )-11};
static char const   *posix_names[13]  = 
  {      "alpha",      "lower",      "upper",      "alnum", 
        "ascii",      "cntrl",      "digit",      "graph", 
        "print",      "punct",      "space",      "word", 
        "xdigit"};
static uschar const   posix_name_lengths[14]  = 
  {      (uschar const   )(unsigned char)5,      (uschar const   )(unsigned char)5,      (uschar const   )(unsigned char)5,      (uschar const   )(unsigned char)5, 
        (uschar const   )(unsigned char)5,      (uschar const   )(unsigned char)5,      (uschar const   )(unsigned char)5,      (uschar const   )(unsigned char)5, 
        (uschar const   )(unsigned char)5,      (uschar const   )(unsigned char)5,      (uschar const   )(unsigned char)5,      (uschar const   )(unsigned char)4, 
        (uschar const   )(unsigned char)6,      (uschar const   )(unsigned char)0};
static int const   posix_class_maps[39]  = 
  {      (int const   )128,      (int const   )96,      (int const   )-1,      (int const   )128, 
        (int const   )-1,      (int const   )-1,      (int const   )96,      (int const   )-1, 
        (int const   )-1,      (int const   )64,      (int const   )128,      (int const   )96, 
        (int const   )224,      (int const   )288,      (int const   )-1,      (int const   )288, 
        (int const   )-1,      (int const   )-1,      (int const   )64,      (int const   )-1, 
        (int const   )-1,      (int const   )192,      (int const   )-1,      (int const   )-1, 
        (int const   )224,      (int const   )-1,      (int const   )-1,      (int const   )256, 
        (int const   )-1,      (int const   )-1,      (int const   )0,      (int const   )-1, 
        (int const   )-1,      (int const   )160,      (int const   )-1,      (int const   )-1, 
        (int const   )32,      (int const   )-1,      (int const   )-1};
static BOOL compile_regex(int options , int optchanged , int *brackets , uschar **codeptr ,
                          uschar const   **ptrptr , char const   **errorptr , BOOL lookbehind ,
                          int skipbytes , int *reqchar , int *countlits , compile_data *cd ) ;
void *(*pcre_malloc)(size_t  )  =    & malloc;
void (*pcre_free)(void * )  =    & free;
static unsigned char pcre_default_tables[1088]  = 
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)8,      (unsigned char)9,      (unsigned char)10,      (unsigned char)11, 
        (unsigned char)12,      (unsigned char)13,      (unsigned char)14,      (unsigned char)15, 
        (unsigned char)16,      (unsigned char)17,      (unsigned char)18,      (unsigned char)19, 
        (unsigned char)20,      (unsigned char)21,      (unsigned char)22,      (unsigned char)23, 
        (unsigned char)24,      (unsigned char)25,      (unsigned char)26,      (unsigned char)27, 
        (unsigned char)28,      (unsigned char)29,      (unsigned char)30,      (unsigned char)31, 
        (unsigned char)32,      (unsigned char)33,      (unsigned char)34,      (unsigned char)35, 
        (unsigned char)36,      (unsigned char)37,      (unsigned char)38,      (unsigned char)39, 
        (unsigned char)40,      (unsigned char)41,      (unsigned char)42,      (unsigned char)43, 
        (unsigned char)44,      (unsigned char)45,      (unsigned char)46,      (unsigned char)47, 
        (unsigned char)48,      (unsigned char)49,      (unsigned char)50,      (unsigned char)51, 
        (unsigned char)52,      (unsigned char)53,      (unsigned char)54,      (unsigned char)55, 
        (unsigned char)56,      (unsigned char)57,      (unsigned char)58,      (unsigned char)59, 
        (unsigned char)60,      (unsigned char)61,      (unsigned char)62,      (unsigned char)63, 
        (unsigned char)64,      (unsigned char)97,      (unsigned char)98,      (unsigned char)99, 
        (unsigned char)100,      (unsigned char)101,      (unsigned char)102,      (unsigned char)103, 
        (unsigned char)104,      (unsigned char)105,      (unsigned char)106,      (unsigned char)107, 
        (unsigned char)108,      (unsigned char)109,      (unsigned char)110,      (unsigned char)111, 
        (unsigned char)112,      (unsigned char)113,      (unsigned char)114,      (unsigned char)115, 
        (unsigned char)116,      (unsigned char)117,      (unsigned char)118,      (unsigned char)119, 
        (unsigned char)120,      (unsigned char)121,      (unsigned char)122,      (unsigned char)91, 
        (unsigned char)92,      (unsigned char)93,      (unsigned char)94,      (unsigned char)95, 
        (unsigned char)96,      (unsigned char)97,      (unsigned char)98,      (unsigned char)99, 
        (unsigned char)100,      (unsigned char)101,      (unsigned char)102,      (unsigned char)103, 
        (unsigned char)104,      (unsigned char)105,      (unsigned char)106,      (unsigned char)107, 
        (unsigned char)108,      (unsigned char)109,      (unsigned char)110,      (unsigned char)111, 
        (unsigned char)112,      (unsigned char)113,      (unsigned char)114,      (unsigned char)115, 
        (unsigned char)116,      (unsigned char)117,      (unsigned char)118,      (unsigned char)119, 
        (unsigned char)120,      (unsigned char)121,      (unsigned char)122,      (unsigned char)123, 
        (unsigned char)124,      (unsigned char)125,      (unsigned char)126,      (unsigned char)127, 
        (unsigned char)128,      (unsigned char)129,      (unsigned char)130,      (unsigned char)131, 
        (unsigned char)132,      (unsigned char)133,      (unsigned char)134,      (unsigned char)135, 
        (unsigned char)136,      (unsigned char)137,      (unsigned char)138,      (unsigned char)139, 
        (unsigned char)140,      (unsigned char)141,      (unsigned char)142,      (unsigned char)143, 
        (unsigned char)144,      (unsigned char)145,      (unsigned char)146,      (unsigned char)147, 
        (unsigned char)148,      (unsigned char)149,      (unsigned char)150,      (unsigned char)151, 
        (unsigned char)152,      (unsigned char)153,      (unsigned char)154,      (unsigned char)155, 
        (unsigned char)156,      (unsigned char)157,      (unsigned char)158,      (unsigned char)159, 
        (unsigned char)160,      (unsigned char)161,      (unsigned char)162,      (unsigned char)163, 
        (unsigned char)164,      (unsigned char)165,      (unsigned char)166,      (unsigned char)167, 
        (unsigned char)168,      (unsigned char)169,      (unsigned char)170,      (unsigned char)171, 
        (unsigned char)172,      (unsigned char)173,      (unsigned char)174,      (unsigned char)175, 
        (unsigned char)176,      (unsigned char)177,      (unsigned char)178,      (unsigned char)179, 
        (unsigned char)180,      (unsigned char)181,      (unsigned char)182,      (unsigned char)183, 
        (unsigned char)184,      (unsigned char)185,      (unsigned char)186,      (unsigned char)187, 
        (unsigned char)188,      (unsigned char)189,      (unsigned char)190,      (unsigned char)191, 
        (unsigned char)192,      (unsigned char)193,      (unsigned char)194,      (unsigned char)195, 
        (unsigned char)196,      (unsigned char)197,      (unsigned char)198,      (unsigned char)199, 
        (unsigned char)200,      (unsigned char)201,      (unsigned char)202,      (unsigned char)203, 
        (unsigned char)204,      (unsigned char)205,      (unsigned char)206,      (unsigned char)207, 
        (unsigned char)208,      (unsigned char)209,      (unsigned char)210,      (unsigned char)211, 
        (unsigned char)212,      (unsigned char)213,      (unsigned char)214,      (unsigned char)215, 
        (unsigned char)216,      (unsigned char)217,      (unsigned char)218,      (unsigned char)219, 
        (unsigned char)220,      (unsigned char)221,      (unsigned char)222,      (unsigned char)223, 
        (unsigned char)224,      (unsigned char)225,      (unsigned char)226,      (unsigned char)227, 
        (unsigned char)228,      (unsigned char)229,      (unsigned char)230,      (unsigned char)231, 
        (unsigned char)232,      (unsigned char)233,      (unsigned char)234,      (unsigned char)235, 
        (unsigned char)236,      (unsigned char)237,      (unsigned char)238,      (unsigned char)239, 
        (unsigned char)240,      (unsigned char)241,      (unsigned char)242,      (unsigned char)243, 
        (unsigned char)244,      (unsigned char)245,      (unsigned char)246,      (unsigned char)247, 
        (unsigned char)248,      (unsigned char)249,      (unsigned char)250,      (unsigned char)251, 
        (unsigned char)252,      (unsigned char)253,      (unsigned char)254,      (unsigned char)255, 
        (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)8,      (unsigned char)9,      (unsigned char)10,      (unsigned char)11, 
        (unsigned char)12,      (unsigned char)13,      (unsigned char)14,      (unsigned char)15, 
        (unsigned char)16,      (unsigned char)17,      (unsigned char)18,      (unsigned char)19, 
        (unsigned char)20,      (unsigned char)21,      (unsigned char)22,      (unsigned char)23, 
        (unsigned char)24,      (unsigned char)25,      (unsigned char)26,      (unsigned char)27, 
        (unsigned char)28,      (unsigned char)29,      (unsigned char)30,      (unsigned char)31, 
        (unsigned char)32,      (unsigned char)33,      (unsigned char)34,      (unsigned char)35, 
        (unsigned char)36,      (unsigned char)37,      (unsigned char)38,      (unsigned char)39, 
        (unsigned char)40,      (unsigned char)41,      (unsigned char)42,      (unsigned char)43, 
        (unsigned char)44,      (unsigned char)45,      (unsigned char)46,      (unsigned char)47, 
        (unsigned char)48,      (unsigned char)49,      (unsigned char)50,      (unsigned char)51, 
        (unsigned char)52,      (unsigned char)53,      (unsigned char)54,      (unsigned char)55, 
        (unsigned char)56,      (unsigned char)57,      (unsigned char)58,      (unsigned char)59, 
        (unsigned char)60,      (unsigned char)61,      (unsigned char)62,      (unsigned char)63, 
        (unsigned char)64,      (unsigned char)97,      (unsigned char)98,      (unsigned char)99, 
        (unsigned char)100,      (unsigned char)101,      (unsigned char)102,      (unsigned char)103, 
        (unsigned char)104,      (unsigned char)105,      (unsigned char)106,      (unsigned char)107, 
        (unsigned char)108,      (unsigned char)109,      (unsigned char)110,      (unsigned char)111, 
        (unsigned char)112,      (unsigned char)113,      (unsigned char)114,      (unsigned char)115, 
        (unsigned char)116,      (unsigned char)117,      (unsigned char)118,      (unsigned char)119, 
        (unsigned char)120,      (unsigned char)121,      (unsigned char)122,      (unsigned char)91, 
        (unsigned char)92,      (unsigned char)93,      (unsigned char)94,      (unsigned char)95, 
        (unsigned char)96,      (unsigned char)65,      (unsigned char)66,      (unsigned char)67, 
        (unsigned char)68,      (unsigned char)69,      (unsigned char)70,      (unsigned char)71, 
        (unsigned char)72,      (unsigned char)73,      (unsigned char)74,      (unsigned char)75, 
        (unsigned char)76,      (unsigned char)77,      (unsigned char)78,      (unsigned char)79, 
        (unsigned char)80,      (unsigned char)81,      (unsigned char)82,      (unsigned char)83, 
        (unsigned char)84,      (unsigned char)85,      (unsigned char)86,      (unsigned char)87, 
        (unsigned char)88,      (unsigned char)89,      (unsigned char)90,      (unsigned char)123, 
        (unsigned char)124,      (unsigned char)125,      (unsigned char)126,      (unsigned char)127, 
        (unsigned char)128,      (unsigned char)129,      (unsigned char)130,      (unsigned char)131, 
        (unsigned char)132,      (unsigned char)133,      (unsigned char)134,      (unsigned char)135, 
        (unsigned char)136,      (unsigned char)137,      (unsigned char)138,      (unsigned char)139, 
        (unsigned char)140,      (unsigned char)141,      (unsigned char)142,      (unsigned char)143, 
        (unsigned char)144,      (unsigned char)145,      (unsigned char)146,      (unsigned char)147, 
        (unsigned char)148,      (unsigned char)149,      (unsigned char)150,      (unsigned char)151, 
        (unsigned char)152,      (unsigned char)153,      (unsigned char)154,      (unsigned char)155, 
        (unsigned char)156,      (unsigned char)157,      (unsigned char)158,      (unsigned char)159, 
        (unsigned char)160,      (unsigned char)161,      (unsigned char)162,      (unsigned char)163, 
        (unsigned char)164,      (unsigned char)165,      (unsigned char)166,      (unsigned char)167, 
        (unsigned char)168,      (unsigned char)169,      (unsigned char)170,      (unsigned char)171, 
        (unsigned char)172,      (unsigned char)173,      (unsigned char)174,      (unsigned char)175, 
        (unsigned char)176,      (unsigned char)177,      (unsigned char)178,      (unsigned char)179, 
        (unsigned char)180,      (unsigned char)181,      (unsigned char)182,      (unsigned char)183, 
        (unsigned char)184,      (unsigned char)185,      (unsigned char)186,      (unsigned char)187, 
        (unsigned char)188,      (unsigned char)189,      (unsigned char)190,      (unsigned char)191, 
        (unsigned char)192,      (unsigned char)193,      (unsigned char)194,      (unsigned char)195, 
        (unsigned char)196,      (unsigned char)197,      (unsigned char)198,      (unsigned char)199, 
        (unsigned char)200,      (unsigned char)201,      (unsigned char)202,      (unsigned char)203, 
        (unsigned char)204,      (unsigned char)205,      (unsigned char)206,      (unsigned char)207, 
        (unsigned char)208,      (unsigned char)209,      (unsigned char)210,      (unsigned char)211, 
        (unsigned char)212,      (unsigned char)213,      (unsigned char)214,      (unsigned char)215, 
        (unsigned char)216,      (unsigned char)217,      (unsigned char)218,      (unsigned char)219, 
        (unsigned char)220,      (unsigned char)221,      (unsigned char)222,      (unsigned char)223, 
        (unsigned char)224,      (unsigned char)225,      (unsigned char)226,      (unsigned char)227, 
        (unsigned char)228,      (unsigned char)229,      (unsigned char)230,      (unsigned char)231, 
        (unsigned char)232,      (unsigned char)233,      (unsigned char)234,      (unsigned char)235, 
        (unsigned char)236,      (unsigned char)237,      (unsigned char)238,      (unsigned char)239, 
        (unsigned char)240,      (unsigned char)241,      (unsigned char)242,      (unsigned char)243, 
        (unsigned char)244,      (unsigned char)245,      (unsigned char)246,      (unsigned char)247, 
        (unsigned char)248,      (unsigned char)249,      (unsigned char)250,      (unsigned char)251, 
        (unsigned char)252,      (unsigned char)253,      (unsigned char)254,      (unsigned char)255, 
        (unsigned char)0,      (unsigned char)62,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)255,      (unsigned char)3, 
        (unsigned char)126,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)126,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)255,      (unsigned char)3, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)254,      (unsigned char)255,      (unsigned char)255,      (unsigned char)7, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)254,      (unsigned char)255,      (unsigned char)255,      (unsigned char)7, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)255,      (unsigned char)3, 
        (unsigned char)254,      (unsigned char)255,      (unsigned char)255,      (unsigned char)135, 
        (unsigned char)254,      (unsigned char)255,      (unsigned char)255,      (unsigned char)7, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)254,      (unsigned char)255,      (unsigned char)255,      (unsigned char)255, 
        (unsigned char)255,      (unsigned char)255,      (unsigned char)255,      (unsigned char)255, 
        (unsigned char)255,      (unsigned char)255,      (unsigned char)255,      (unsigned char)127, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)255,      (unsigned char)255,      (unsigned char)255, 
        (unsigned char)255,      (unsigned char)255,      (unsigned char)255,      (unsigned char)255, 
        (unsigned char)255,      (unsigned char)255,      (unsigned char)255,      (unsigned char)127, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)254,      (unsigned char)255,      (unsigned char)0,      (unsigned char)252, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)0,      (unsigned char)248, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)0,      (unsigned char)120, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)255,      (unsigned char)255,      (unsigned char)255, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)128, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)128,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)128,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)128,      (unsigned char)0, 
        (unsigned char)28,      (unsigned char)28,      (unsigned char)28,      (unsigned char)28, 
        (unsigned char)28,      (unsigned char)28,      (unsigned char)28,      (unsigned char)28, 
        (unsigned char)28,      (unsigned char)28,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)128, 
        (unsigned char)0,      (unsigned char)26,      (unsigned char)26,      (unsigned char)26, 
        (unsigned char)26,      (unsigned char)26,      (unsigned char)26,      (unsigned char)18, 
        (unsigned char)18,      (unsigned char)18,      (unsigned char)18,      (unsigned char)18, 
        (unsigned char)18,      (unsigned char)18,      (unsigned char)18,      (unsigned char)18, 
        (unsigned char)18,      (unsigned char)18,      (unsigned char)18,      (unsigned char)18, 
        (unsigned char)18,      (unsigned char)18,      (unsigned char)18,      (unsigned char)18, 
        (unsigned char)18,      (unsigned char)18,      (unsigned char)18,      (unsigned char)128, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)128,      (unsigned char)16, 
        (unsigned char)0,      (unsigned char)26,      (unsigned char)26,      (unsigned char)26, 
        (unsigned char)26,      (unsigned char)26,      (unsigned char)26,      (unsigned char)18, 
        (unsigned char)18,      (unsigned char)18,      (unsigned char)18,      (unsigned char)18, 
        (unsigned char)18,      (unsigned char)18,      (unsigned char)18,      (unsigned char)18, 
        (unsigned char)18,      (unsigned char)18,      (unsigned char)18,      (unsigned char)18, 
        (unsigned char)18,      (unsigned char)18,      (unsigned char)18,      (unsigned char)18, 
        (unsigned char)18,      (unsigned char)18,      (unsigned char)18,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
char const   *pcre_version(void) 
{ 

  {
  return ("3.9 02-Jan-2002");
}
}
int pcre_info(pcre const   *external_re , int *optptr , int *first_char ) 
{ real_pcre const   *re ;

  {
  re = external_re;
  if ((unsigned int )re == (unsigned int )((void *)0)) {
    return (-2);
  }
  if (re->magic_number != 1346589253UL) {
    return (-4);
  }
  if ((unsigned int )optptr != (unsigned int )((void *)0)) {
    (*optptr) = (int )(re->options & 2687UL);
  }
  if ((unsigned int )first_char != (unsigned int )((void *)0)) {
    if ((re->options & 1073741824UL) != 0UL) {
      (*first_char) = (int )re->first_char;
    } else {
      if ((re->options & 268435456UL) != 0UL) {
        (*first_char) = -1;
      } else {
        (*first_char) = -2;
      }
    }
  }
  return ((int )re->top_bracket);
}
}
int pcre_fullinfo(pcre const   *external_re , pcre_extra const   *study_data , int what ,
                  void *where ) 
{ real_pcre const   *re ;
  real_pcre_extra const   *study ;

  {
  re = external_re;
  study = study_data;
  if ((unsigned int )re == (unsigned int )((void *)0)) {
    goto _L;
  } else {
    if ((unsigned int )where == (unsigned int )((void *)0)) {
      _L: 
      return (-2);
    }
  }
  if (re->magic_number != 1346589253UL) {
    return (-4);
  }
  switch (what) {
  case 0: 
  (*((unsigned long *)where)) = re->options & 2687UL;
  break;
  case 1: 
  (*((size_t *)where)) = re->size;
  break;
  case 2: 
  (*((int *)where)) = (int )re->top_bracket;
  break;
  case 3: 
  (*((int *)where)) = (int )re->top_backref;
  break;
  case 4: ;
  if ((re->options & 1073741824UL) != 0UL) {
    (*((int *)where)) = (int )re->first_char;
  } else {
    if ((re->options & 268435456UL) != 0UL) {
      (*((int *)where)) = -1;
    } else {
      (*((int *)where)) = -2;
    }
  }
  break;
  case 5: ;
  if ((unsigned int )study != (unsigned int )((void *)0)) {
    if (((int )study->options & 1) != 0) {
      (*((uschar const   **)where)) = (uschar const   *)(study->start_bits);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    (*((uschar const   **)where)) = (uschar const   *)((void *)0);
  }
  break;
  case 6: ;
  if ((re->options & 536870912UL) != 0UL) {
    (*((int *)where)) = (int )re->req_char;
  } else {
    (*((int *)where)) = -1;
  }
  break;
  default: ;
  return (-3);
  }
  return (0);
}
}
static int check_escape(uschar const   **ptrptr , char const   **errorptr , int bracount ,
                        int options , BOOL isclass , compile_data *cd ) 
{ uschar const   *ptr ;
  int c ;
  int i ;
  uschar const   *oldptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  ptr = (*ptrptr);
  ptr ++;
  c = (int )(*ptr);
  if (c == 0) {
    (*errorptr) = "\\ at end of pattern";
  } else {
    if (c < 48) {
      goto _L___5;
    } else {
      if (c > 122) {
        _L___5: ;
      } else {
        i = (int )escapes[c - 48];
        if (i != 0) {
          c = i;
        } else {
          switch (c) {
          case 49: ;
          case 50: ;
          case 51: ;
          case 52: ;
          case 53: ;
          case 54: ;
          case 55: ;
          case 56: ;
          case 57: ;
          if (! isclass) {
            oldptr = ptr;
            c -= 48;
            while (((int const   )(*(cd->ctypes + (int const   )(*(ptr + 1)))) & 4) !=
                   0) {
              ptr ++;
              c = (c * 10 + (int )(*ptr)) - 48;
            }
            if (c < 10) {
              goto _L;
            } else {
              if (c <= bracount) {
                _L: 
                c = - (12 + c);
                break;
              }
            }
            ptr = oldptr;
          }
          c = (int )(*ptr);
          if (c >= 56) {
            ptr --;
            c = 0;
            break;
          }
          case 48: 
          c -= 48;
          while (1) {
            tmp = i;
            i ++;
            if (tmp < 2) {
              if (((int const   )(*(cd->ctypes + (int const   )(*(ptr + 1)))) & 4) !=
                  0) {
                if ((int const   )(*(ptr + 1)) != 56) {
                  if (! ((int const   )(*(ptr + 1)) != 57)) {
                    goto _L___2;
                  }
                } else {
                  goto _L___2;
                }
              } else {
                goto _L___2;
              }
            } else {
              _L___2: 
              break;
            }
            ptr ++;
            c = (c * 8 + (int )(*ptr)) - 48;
          }
          c &= 255;
          break;
          case 120: 
          c = 0;
          while (1) {
            tmp___1 = i;
            i ++;
            if (tmp___1 < 2) {
              if (! (((int const   )(*(cd->ctypes + (int const   )(*(ptr + 1)))) &
                      8) != 0)) {
                goto _L___3;
              }
            } else {
              _L___3: 
              break;
            }
            ptr ++;
            if (((int const   )(*(cd->ctypes + (int const   )(*ptr))) & 4) != 0) {
              tmp___0 = '0';
            } else {
              tmp___0 = 'W';
            }
            c = (c * 16 + (int )(*(cd->lcc + (int const   )(*ptr)))) - tmp___0;
          }
          break;
          case 99: 
          ptr ++;
          c = (int )(*ptr);
          if (c == 0) {
            (*errorptr) = "\\c at end of pattern";
            return (0);
          }
          if (c >= 97) {
            if (c <= 122) {
              c = (int )(*(cd->fcc + c));
            } else {
              goto _L___4;
            }
          } else {
            _L___4: ;
          }
          c ^= 64;
          break;
          default: ;
          if ((options & 64) != 0) {
            switch (c) {
            default: 
            (*errorptr) = "unrecognized character follows \\";
            break;
            }
          }
          break;
          }
        }
      }
    }
  }
  (*ptrptr) = ptr;
  return (c);
}
}
static BOOL is_counted_repeat(uschar const   *p , compile_data *cd ) 
{ uschar const   *tmp ;
  uschar const   *tmp___0 ;
  uschar const   *tmp___1 ;

  {
  tmp = p;
  p ++;
  if (((int const   )(*(cd->ctypes + (int const   )(*tmp))) & 4) == 0) {
    return (0);
  }
  while (((int const   )(*(cd->ctypes + (int const   )(*p))) & 4) != 0) {
    p ++;
  }
  if ((int const   )(*p) == 125) {
    return (1);
  }
  tmp___0 = p;
  p ++;
  if ((int const   )(*tmp___0) != 44) {
    return (0);
  }
  if ((int const   )(*p) == 125) {
    return (1);
  }
  tmp___1 = p;
  p ++;
  if (((int const   )(*(cd->ctypes + (int const   )(*tmp___1))) & 4) == 0) {
    return (0);
  }
  while (((int const   )(*(cd->ctypes + (int const   )(*p))) & 4) != 0) {
    p ++;
  }
  return ((int const   )(*p) == 125);
}
}
static uschar const   *read_repeat_counts(uschar const   *p , int *minp , int *maxp ,
                                          char const   **errorptr , compile_data *cd ) 
{ int min ;
  int max ;
  uschar const   *tmp ;
  uschar const   *tmp___0 ;

  {
  min = 0;
  max = -1;
  while (((int const   )(*(cd->ctypes + (int const   )(*p))) & 4) != 0) {
    tmp = p;
    p ++;
    min = (min * 10 + (int )(*tmp)) - 48;
  }
  if ((int const   )(*p) == 125) {
    max = min;
  } else {
    p ++;
    if ((int const   )(*p) != 125) {
      max = 0;
      while (((int const   )(*(cd->ctypes + (int const   )(*p))) & 4) != 0) {
        tmp___0 = p;
        p ++;
        max = (max * 10 + (int )(*tmp___0)) - 48;
      }
      if (max < min) {
        (*errorptr) = "numbers out of order in {} quantifier";
        return (p);
      }
    }
  }
  if (min > 65535) {
    goto _L;
  } else {
    if (max > 65535) {
      _L: 
      (*errorptr) = "number too big in {} quantifier";
    } else {
      (*minp) = min;
      (*maxp) = max;
    }
  }
  return (p);
}
}
static int find_fixedlength(uschar *code , int options ) 
{ int length ;
  register int branchlength ;
  register uschar *cc ;
  int d ;
  register int op ;

  {
  length = -1;
  branchlength = 0;
  cc = code + 3;
  while (1) {
    op = (int )(*cc);
    if (op >= 71) {
      op = 71;
    }
    switch (op) {
    case 71: ;
    case 65: ;
    case 66: 
    d = find_fixedlength(cc, options);
    if (d < 0) {
      return (-1);
    }
    branchlength += d;
    while (1) {
      cc += ((int )(*(cc + 1)) << 8) + (int )(*(cc + 2));
      if (! ((int )(*cc) == 56)) {
        break;
      }
    }
    cc += 3;
    break;
    case 56: ;
    case 57: ;
    case 58: ;
    case 59: ;
    case 0: ;
    if (length < 0) {
      length = branchlength;
    } else {
      if (length != branchlength) {
        return (-1);
      }
    }
    if ((int )(*cc) != 56) {
      return (length);
    }
    cc += 3;
    branchlength = 0;
    break;
    case 60: ;
    case 61: ;
    case 62: ;
    case 63: ;
    while (1) {
      cc += ((int )(*(cc + 1)) << 8) + (int )(*(cc + 2));
      if (! ((int )(*cc) == 56)) {
        break;
      }
    }
    cc += 3;
    break;
    case 64: ;
    case 70: ;
    case 67: 
    cc ++;
    case 12: 
    cc ++;
    case 1: ;
    case 11: ;
    case 10: ;
    case 13: ;
    case 14: ;
    case 2: ;
    case 3: 
    cc ++;
    break;
    case 16: 
    cc ++;
    branchlength += (int )(*cc);
    cc += (int )(*cc) + 1;
    break;
    case 26: ;
    case 44: 
    branchlength += ((int )(*(cc + 1)) << 8) + (int )(*(cc + 2));
    cc += 4;
    break;
    case 4: ;
    case 5: ;
    case 6: ;
    case 7: ;
    case 8: ;
    case 9: ;
    case 15: 
    branchlength ++;
    cc ++;
    break;
    case 53: 
    cc += 33;
    switch ((int )(*cc)) {
    case 45: ;
    case 46: ;
    case 49: ;
    case 50: ;
    return (-1);
    case 51: ;
    case 52: ;
    if (((int )(*(cc + 1)) << 8) + (int )(*(cc + 2)) != ((int )(*(cc + 3)) << 8) +
                                                        (int )(*(cc + 4))) {
      return (-1);
    }
    branchlength += ((int )(*(cc + 1)) << 8) + (int )(*(cc + 2));
    cc += 5;
    break;
    default: 
    branchlength ++;
    }
    break;
    default: ;
    return (-1);
    }
  }
  return (0);
}
}
static BOOL check_posix_syntax(uschar const   *ptr , uschar const   **endptr , compile_data *cd ) 
{ int terminator ;

  {
  ptr ++;
  terminator = (int )(*ptr);
  ptr ++;
  if ((int const   )(*ptr) == 94) {
    ptr ++;
  }
  while (((int const   )(*(cd->ctypes + (int const   )(*ptr))) & 2) != 0) {
    ptr ++;
  }
  if ((int const   )(*ptr) == (int const   )terminator) {
    if ((int const   )(*(ptr + 1)) == 93) {
      (*endptr) = ptr;
      return (1);
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  return (0);
}
}
static int check_posix_name(uschar const   *ptr , int len ) 
{ register int yield ;
  int tmp ;

  {
  yield = 0;
  while ((int const   )posix_name_lengths[yield] != 0) {
    if (len == (int )posix_name_lengths[yield]) {
      tmp = strncmp((char const   *)ptr, posix_names[yield], (unsigned int )len);
      if (tmp == 0) {
        return (yield);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    yield ++;
  }
  return (-1);
}
}
static BOOL compile_branch(int options , int *brackets , uschar **codeptr , uschar const   **ptrptr ,
                           char const   **errorptr , int *optchanged , int *reqchar ,
                           int *countlits , compile_data *cd ) 
{ int repeat_type ;
  int op_type ;
  int repeat_min ;
  int repeat_max ;
  int bravalue ;
  int length ;
  int greedy_default ;
  int greedy_non_default ;
  int prevreqchar ;
  int condcount ;
  int subcountlits ;
  register int c ;
  register uschar *code ;
  uschar *tempcode ;
  uschar const   *ptr ;
  uschar const   *tempptr ;
  uschar *previous ;
  uschar class[32] ;
  BOOL negate_class ;
  int class_charcount ;
  int class_lastchar ;
  int newoptions ;
  int skipbytes ;
  int subreqchar ;
  uschar *tmp ;
  uschar *tmp___0 ;
  uschar *tmp___1 ;
  uschar *tmp___2 ;
  BOOL local_negate ;
  int posix_class ;
  int i ;
  register uschar const   *cbits ;
  int taboffset ;
  BOOL tmp___3 ;
  register uschar const   *cbits___0 ;
  int d ;
  uschar const   *oldptr ;
  int uc ;
  uschar *tmp___4 ;
  uschar *tmp___5 ;
  BOOL tmp___6 ;
  int len ;
  uschar *tmp___7 ;
  uschar *tmp___8 ;
  uschar *tmp___9 ;
  uschar *tmp___10 ;
  uschar *tmp___11 ;
  uschar *tmp___12 ;
  uschar *tmp___13 ;
  uschar *tmp___14 ;
  uschar *tmp___15 ;
  uschar *tmp___16 ;
  uschar *tmp___17 ;
  uschar *tmp___18 ;
  uschar *tmp___19 ;
  uschar *tmp___20 ;
  uschar *tmp___21 ;
  uschar *tmp___22 ;
  uschar *tmp___23 ;
  uschar *tmp___24 ;
  uschar *tmp___25 ;
  uschar *tmp___26 ;
  uschar *tmp___27 ;
  uschar *tmp___28 ;
  uschar *tmp___29 ;
  uschar *tmp___30 ;
  register int i___0 ;
  int ketoffset ;
  int len___0 ;
  uschar *bralink ;
  register uschar *ket ;
  uschar *tmp___31 ;
  int offset ;
  uschar *tmp___32 ;
  uschar *tmp___33 ;
  uschar *tmp___34 ;
  uschar *tmp___35 ;
  uschar *tmp___36 ;
  int offset___0 ;
  uschar *tmp___37 ;
  uschar *tmp___38 ;
  uschar *tmp___39 ;
  int oldlinkoffset ;
  int offset___1 ;
  uschar *bra ;
  uschar *tmp___40 ;
  uschar *tmp___41 ;
  uschar *tmp___42 ;
  int set ;
  int unset ;
  int *optset ;
  int condref ;
  uschar *tmp___43 ;
  uschar const   *tmp___44 ;
  uschar *tmp___45 ;
  uschar *tmp___46 ;
  uschar *tc ;
  int tmp___47 ;
  int tmp___48 ;
  BOOL tmp___49 ;
  int number ;
  uschar *tmp___50 ;
  uschar *tmp___51 ;
  uschar *tmp___52 ;
  uschar *tmp___53 ;
  uschar *tmp___54 ;

  {
  condcount = 0;
  subcountlits = 0;
  code = (*codeptr);
  ptr = (*ptrptr);
  previous = (uschar *)((void *)0);
  greedy_default = (options & 512) != 0;
  greedy_non_default = greedy_default ^ 1;
  prevreqchar = -1;
  (*reqchar) = prevreqchar;
  (*countlits) = 0;
  while (1) {
    c = (int )(*ptr);
    if ((options & 8) != 0) {
      if (((int const   )(*(cd->ctypes + c)) & 1) != 0) {
        goto __Cont;
      }
      if (c == 35) {
        while (1) {
          ptr ++;
          c = (int )(*ptr);
          if (c != 0) {
            if (! (c != 10)) {
              goto _L;
            }
          } else {
            _L: 
            break;
          }
        }
        goto __Cont;
      }
    }
    switch (c) {
    case 0: ;
    case 124: ;
    case 41: 
    (*codeptr) = code;
    (*ptrptr) = ptr;
    return (1);
    case 94: 
    previous = (uschar *)((void *)0);
    tmp = code;
    code ++;
    (*tmp) = (unsigned char)13;
    break;
    case 36: 
    previous = (uschar *)((void *)0);
    tmp___0 = code;
    code ++;
    (*tmp___0) = (unsigned char)14;
    break;
    case 46: 
    previous = code;
    tmp___1 = code;
    code ++;
    (*tmp___1) = (unsigned char)15;
    break;
    case 91: 
    previous = code;
    tmp___2 = code;
    code ++;
    (*tmp___2) = (unsigned char)53;
    ptr ++;
    c = (int )(*ptr);
    if (c == 94) {
      negate_class = 1;
      ptr ++;
      c = (int )(*ptr);
    } else {
      negate_class = 0;
    }
    class_charcount = 0;
    class_lastchar = -1;
    memset((void *)(class), 0, 32U * sizeof(uschar ));
    while (1) {
      if (c == 0) {
        (*errorptr) = "missing terminating ] for character class";
        goto FAILED;
      }
      if (c == 91) {
        if ((int const   )(*(ptr + 1)) == 58) {
          goto _L___4;
        } else {
          if ((int const   )(*(ptr + 1)) == 46) {
            _L___4: 
            goto _L___3;
          } else {
            if ((int const   )(*(ptr + 1)) == 61) {
              _L___3: 
              tmp___3 = check_posix_syntax(ptr, & tempptr, cd);
              if (tmp___3) {
                local_negate = 0;
                cbits = cd->cbits;
                if ((int const   )(*(ptr + 1)) != 58) {
                  (*errorptr) = "POSIX collating elements are not supported";
                  goto FAILED;
                }
                ptr += 2;
                if ((int const   )(*ptr) == 94) {
                  local_negate = 1;
                  ptr ++;
                }
                posix_class = check_posix_name(ptr, tempptr - ptr);
                if (posix_class < 0) {
                  (*errorptr) = "unknown POSIX class name";
                  goto FAILED;
                }
                if ((options & 1) != 0) {
                  if (posix_class <= 2) {
                    posix_class = 0;
                  } else {
                    goto _L___0;
                  }
                } else {
                  _L___0: ;
                }
                posix_class *= 3;
                i = 0;
                while (i < 3) {
                  taboffset = (int )posix_class_maps[posix_class + i];
                  if (taboffset < 0) {
                    break;
                  }
                  if (local_negate) {
                    c = 0;
                    while (c < 32) {
                      class[c] = (unsigned char )((int )class[c] | (int )(~ ((int const   )(*(cbits +
                                                                                              (c +
                                                                                               taboffset))))));
                      c ++;
                    }
                  } else {
                    c = 0;
                    while (c < 32) {
                      class[c] = (unsigned char )((int )class[c] | (int )(*(cbits +
                                                                            (c + taboffset))));
                      c ++;
                    }
                  }
                  i ++;
                }
                ptr = tempptr + 1;
                class_charcount = 10;
                goto __Cont___0;
              } else {
                goto _L___2;
              }
            } else {
              goto _L___2;
            }
          }
        }
      } else {
        _L___2: ;
      }
      if (c == 92) {
        c = check_escape(& ptr, errorptr, (*brackets), options, 1, cd);
        if (- c == 3) {
          c = '\b';
        } else {
          if (c < 0) {
            cbits___0 = cd->cbits;
            class_charcount = 10;
            switch (- c) {
            case 5: 
            c = 0;
            while (c < 32) {
              class[c] = (unsigned char )((int )class[c] | (int )(*(cbits___0 + (c +
                                                                                 64))));
              c ++;
            }
            goto __Cont___0;
            case 4: 
            c = 0;
            while (c < 32) {
              class[c] = (unsigned char )((int )class[c] | (int )(~ ((int const   )(*(cbits___0 +
                                                                                      (c +
                                                                                       64))))));
              c ++;
            }
            goto __Cont___0;
            case 9: 
            c = 0;
            while (c < 32) {
              class[c] = (unsigned char )((int )class[c] | (int )(*(cbits___0 + (c +
                                                                                 160))));
              c ++;
            }
            goto __Cont___0;
            case 8: 
            c = 0;
            while (c < 32) {
              class[c] = (unsigned char )((int )class[c] | (int )(~ ((int const   )(*(cbits___0 +
                                                                                      (c +
                                                                                       160))))));
              c ++;
            }
            goto __Cont___0;
            case 7: 
            c = 0;
            while (c < 32) {
              class[c] = (unsigned char )((int )class[c] | (int )(*(cbits___0 + c)));
              c ++;
            }
            goto __Cont___0;
            case 6: 
            c = 0;
            while (c < 32) {
              class[c] = (unsigned char )((int )class[c] | (int )(~ ((int const   )(*(cbits___0 +
                                                                                      c)))));
              c ++;
            }
            goto __Cont___0;
            default: 
            (*errorptr) = "invalid escape sequence in character class";
            goto FAILED;
            }
          }
        }
      }
      if ((int const   )(*(ptr + 1)) == 45) {
        if ((int const   )(*(ptr + 2)) != 93) {
          ptr += 2;
          d = (int )(*ptr);
          if (d == 0) {
            (*errorptr) = "missing terminating ] for character class";
            goto FAILED;
          }
          if (d == 92) {
            oldptr = ptr;
            d = check_escape(& ptr, errorptr, (*brackets), options, 1, cd);
            if (d < 0) {
              if (d == -3) {
                d = '\b';
              } else {
                ptr = oldptr - 2;
                goto SINGLE_CHARACTER;
              }
            }
          }
          if (d < c) {
            (*errorptr) = "range out of order in character class";
            goto FAILED;
          }
          while (c <= d) {
            class[c / 8] = (unsigned char )((int )class[c / 8] | (1 << (c & 7)));
            if ((options & 1) != 0) {
              uc = (int )(*(cd->fcc + c));
              class[uc / 8] = (unsigned char )((int )class[uc / 8] | (1 << (uc & 7)));
            }
            class_charcount ++;
            class_lastchar = c;
            c ++;
          }
          goto __Cont___0;
        } else {
          goto _L___5;
        }
      } else {
        _L___5: ;
      }
      SINGLE_CHARACTER: 
      class[c / 8] = (unsigned char )((int )class[c / 8] | (1 << (c & 7)));
      if ((options & 1) != 0) {
        c = (int )(*(cd->fcc + c));
        class[c / 8] = (unsigned char )((int )class[c / 8] | (1 << (c & 7)));
      }
      class_charcount ++;
      class_lastchar = c;
      __Cont___0: 
      ptr ++;
      c = (int )(*ptr);
      if (! (c != 93)) {
        break;
      }
    }
    if (class_charcount == 1) {
      if (class_lastchar >= 0) {
        if (negate_class) {
          (*(code + -1)) = (unsigned char)17;
        } else {
          (*(code + -1)) = (unsigned char)16;
          tmp___4 = code;
          code ++;
          (*tmp___4) = (unsigned char)1;
        }
        tmp___5 = code;
        code ++;
        (*tmp___5) = (unsigned char )class_lastchar;
      } else {
        goto _L___6;
      }
    } else {
      _L___6: 
      if (negate_class) {
        c = 0;
        while (c < 32) {
          (*(code + c)) = (unsigned char )(~ ((int )class[c]));
          c ++;
        }
      } else {
        memcpy((void * __restrict  )code, (void const   * __restrict  )(class), 32U);
      }
      code += 32;
    }
    break;
    case 123: 
    tmp___6 = is_counted_repeat(ptr + 1, cd);
    if (! tmp___6) {
      goto NORMAL_CHAR;
    }
    ptr = read_repeat_counts(ptr + 1, & repeat_min, & repeat_max, errorptr, cd);
    if ((unsigned int )(*errorptr) != (unsigned int )((void *)0)) {
      goto FAILED;
    }
    goto REPEAT;
    case 42: 
    repeat_min = 0;
    repeat_max = -1;
    goto REPEAT;
    case 43: 
    repeat_min = 1;
    repeat_max = -1;
    goto REPEAT;
    case 63: 
    repeat_min = 0;
    repeat_max = 1;
    REPEAT: 
    if ((unsigned int )previous == (unsigned int )((void *)0)) {
      (*errorptr) = "nothing to repeat";
      goto FAILED;
    }
    if ((int const   )(*(ptr + 1)) == 63) {
      repeat_type = greedy_non_default;
      ptr ++;
    } else {
      repeat_type = greedy_default;
    }
    if ((int )(*previous) == 16) {
      len = (int )(*(previous + 1));
      if (repeat_min == 0) {
        (*reqchar) = prevreqchar;
      }
      (*countlits) += repeat_min - 1;
      if (len == 1) {
        c = (int )(*(previous + 2));
        code = previous;
      } else {
        c = (int )(*(previous + (len + 1)));
        (*(previous + 1)) = (unsigned char )((int )(*(previous + 1)) - 1);
        code --;
      }
      op_type = 0;
      goto OUTPUT_SINGLE_REPEAT;
    } else {
      if ((int )(*previous) == 17) {
        op_type = 9;
        c = (int )(*(previous + 1));
        code = previous;
        goto OUTPUT_SINGLE_REPEAT;
      } else {
        if ((int )(*previous) < 10) {
          goto _L___14;
        } else {
          if ((int )(*previous) == 15) {
            _L___14: 
            op_type = 18;
            c = (int )(*previous);
            code = previous;
            OUTPUT_SINGLE_REPEAT: 
            if (repeat_max == 0) {
              goto END_REPEAT;
            }
            repeat_type += op_type;
            if (repeat_min == 0) {
              if (repeat_max == -1) {
                tmp___7 = code;
                code ++;
                (*tmp___7) = (unsigned char )(18 + repeat_type);
              } else {
                if (repeat_max == 1) {
                  tmp___8 = code;
                  code ++;
                  (*tmp___8) = (unsigned char )(22 + repeat_type);
                } else {
                  tmp___9 = code;
                  code ++;
                  (*tmp___9) = (unsigned char )(24 + repeat_type);
                  tmp___10 = code;
                  code ++;
                  (*tmp___10) = (unsigned char )(repeat_max >> 8);
                  tmp___11 = code;
                  code ++;
                  (*tmp___11) = (unsigned char )(repeat_max & 255);
                }
              }
            } else {
              if (repeat_min == 1) {
                if (repeat_max == -1) {
                  tmp___12 = code;
                  code ++;
                  (*tmp___12) = (unsigned char )(20 + repeat_type);
                } else {
                  goto _L___7;
                }
              } else {
                _L___7: 
                if (repeat_min != 1) {
                  tmp___13 = code;
                  code ++;
                  (*tmp___13) = (unsigned char )(26 + op_type);
                  tmp___14 = code;
                  code ++;
                  (*tmp___14) = (unsigned char )(repeat_min >> 8);
                  tmp___15 = code;
                  code ++;
                  (*tmp___15) = (unsigned char )(repeat_min & 255);
                } else {
                  if ((int )(*previous) == 16) {
                    if ((unsigned int )code == (unsigned int )previous) {
                      code += 2;
                    } else {
                      (*(previous + 1)) = (unsigned char )((int )(*(previous + 1)) +
                                                           1);
                    }
                  } else {
                    if ((int )(*previous) == 17) {
                      code ++;
                    }
                  }
                }
                if (repeat_max < 0) {
                  tmp___16 = code;
                  code ++;
                  (*tmp___16) = (unsigned char )c;
                  tmp___17 = code;
                  code ++;
                  (*tmp___17) = (unsigned char )(18 + repeat_type);
                } else {
                  if (repeat_max != repeat_min) {
                    tmp___18 = code;
                    code ++;
                    (*tmp___18) = (unsigned char )c;
                    repeat_max -= repeat_min;
                    tmp___19 = code;
                    code ++;
                    (*tmp___19) = (unsigned char )(24 + repeat_type);
                    tmp___20 = code;
                    code ++;
                    (*tmp___20) = (unsigned char )(repeat_max >> 8);
                    tmp___21 = code;
                    code ++;
                    (*tmp___21) = (unsigned char )(repeat_max & 255);
                  }
                }
              }
            }
            tmp___22 = code;
            code ++;
            (*tmp___22) = (unsigned char )c;
          } else {
            if ((int )(*previous) == 53) {
              goto _L___13;
            } else {
              if ((int )(*previous) == 54) {
                _L___13: 
                if (repeat_max == 0) {
                  code = previous;
                  goto END_REPEAT;
                }
                if (repeat_min == 0) {
                  if (repeat_max == -1) {
                    tmp___23 = code;
                    code ++;
                    (*tmp___23) = (unsigned char )(45 + repeat_type);
                  } else {
                    goto _L___10;
                  }
                } else {
                  _L___10: 
                  if (repeat_min == 1) {
                    if (repeat_max == -1) {
                      tmp___24 = code;
                      code ++;
                      (*tmp___24) = (unsigned char )(47 + repeat_type);
                    } else {
                      goto _L___9;
                    }
                  } else {
                    _L___9: 
                    if (repeat_min == 0) {
                      if (repeat_max == 1) {
                        tmp___25 = code;
                        code ++;
                        (*tmp___25) = (unsigned char )(49 + repeat_type);
                      } else {
                        goto _L___8;
                      }
                    } else {
                      _L___8: 
                      tmp___26 = code;
                      code ++;
                      (*tmp___26) = (unsigned char )(51 + repeat_type);
                      tmp___27 = code;
                      code ++;
                      (*tmp___27) = (unsigned char )(repeat_min >> 8);
                      tmp___28 = code;
                      code ++;
                      (*tmp___28) = (unsigned char )(repeat_min & 255);
                      if (repeat_max == -1) {
                        repeat_max = 0;
                      }
                      tmp___29 = code;
                      code ++;
                      (*tmp___29) = (unsigned char )(repeat_max >> 8);
                      tmp___30 = code;
                      code ++;
                      (*tmp___30) = (unsigned char )(repeat_max & 255);
                    }
                  }
                }
              } else {
                if ((int )(*previous) >= 71) {
                  goto _L___12;
                } else {
                  if ((int )(*previous) == 65) {
                    _L___12: 
                    goto _L___11;
                  } else {
                    if ((int )(*previous) == 66) {
                      _L___11: 
                      ketoffset = 0;
                      len___0 = code - previous;
                      bralink = (uschar *)((void *)0);
                      if (repeat_max == -1) {
                        ket = previous;
                        while (1) {
                          ket += ((int )(*(ket + 1)) << 8) + (int )(*(ket + 2));
                          if (! ((int )(*ket) != 57)) {
                            break;
                          }
                        }
                        ketoffset = code - ket;
                      }
                      if (repeat_min == 0) {
                        if (subcountlits > 0) {
                          (*reqchar) = prevreqchar;
                          (*countlits) -= subcountlits;
                        }
                        if (repeat_max == 0) {
                          code = previous;
                          goto END_REPEAT;
                        }
                        if (repeat_max <= 1) {
                          memmove((void *)(previous + 1), (void const   *)previous,
                                  (unsigned int )len___0);
                          code ++;
                          tmp___31 = previous;
                          previous ++;
                          (*tmp___31) = (unsigned char )(68 + repeat_type);
                        } else {
                          memmove((void *)(previous + 4), (void const   *)previous,
                                  (unsigned int )len___0);
                          code += 4;
                          tmp___32 = previous;
                          previous ++;
                          (*tmp___32) = (unsigned char )(68 + repeat_type);
                          tmp___33 = previous;
                          previous ++;
                          (*tmp___33) = (unsigned char)71;
                          if ((unsigned int )bralink == (unsigned int )((void *)0)) {
                            offset = 0;
                          } else {
                            offset = previous - bralink;
                          }
                          bralink = previous;
                          tmp___34 = previous;
                          previous ++;
                          (*tmp___34) = (unsigned char )(offset >> 8);
                          tmp___35 = previous;
                          previous ++;
                          (*tmp___35) = (unsigned char )(offset & 255);
                        }
                        repeat_max --;
                      } else {
                        i___0 = 1;
                        while (i___0 < repeat_min) {
                          memcpy((void * __restrict  )code, (void const   * __restrict  )previous,
                                 (unsigned int )len___0);
                          code += len___0;
                          i___0 ++;
                        }
                        if (repeat_max > 0) {
                          repeat_max -= repeat_min;
                        }
                      }
                      if (repeat_max >= 0) {
                        i___0 = repeat_max - 1;
                        while (i___0 >= 0) {
                          tmp___36 = code;
                          code ++;
                          (*tmp___36) = (unsigned char )(68 + repeat_type);
                          if (i___0 != 0) {
                            tmp___37 = code;
                            code ++;
                            (*tmp___37) = (unsigned char)71;
                            if ((unsigned int )bralink == (unsigned int )((void *)0)) {
                              offset___0 = 0;
                            } else {
                              offset___0 = code - bralink;
                            }
                            bralink = code;
                            tmp___38 = code;
                            code ++;
                            (*tmp___38) = (unsigned char )(offset___0 >> 8);
                            tmp___39 = code;
                            code ++;
                            (*tmp___39) = (unsigned char )(offset___0 & 255);
                          }
                          memcpy((void * __restrict  )code, (void const   * __restrict  )previous,
                                 (unsigned int )len___0);
                          code += len___0;
                          i___0 --;
                        }
                        while ((unsigned int )bralink != (unsigned int )((void *)0)) {
                          offset___1 = (code - bralink) + 1;
                          bra = code - offset___1;
                          oldlinkoffset = ((int )(*(bra + 1)) << 8) + (int )(*(bra +
                                                                               2));
                          if (oldlinkoffset == 0) {
                            bralink = (uschar *)((void *)0);
                          } else {
                            bralink = bralink - oldlinkoffset;
                          }
                          tmp___40 = code;
                          code ++;
                          (*tmp___40) = (unsigned char)57;
                          tmp___41 = code;
                          code ++;
                          (*(bra + 1)) = (unsigned char )(offset___1 >> 8);
                          (*tmp___41) = (*(bra + 1));
                          tmp___42 = code;
                          code ++;
                          (*(bra + 2)) = (unsigned char )(offset___1 & 255);
                          (*tmp___42) = (*(bra + 2));
                        }
                      } else {
                        (*(code + - ketoffset)) = (unsigned char )(58 + repeat_type);
                      }
                    } else {
                      (*errorptr) = "internal error: unexpected repeat";
                      goto FAILED;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    END_REPEAT: 
    previous = (uschar *)((void *)0);
    break;
    case 40: 
    newoptions = options;
    skipbytes = 0;
    ptr ++;
    if ((int const   )(*ptr) == 63) {
      ptr ++;
      switch ((int )(*ptr)) {
      case 35: 
      ptr ++;
      while ((int const   )(*ptr) != 41) {
        ptr ++;
      }
      goto __Cont;
      case 58: 
      bravalue = 71;
      ptr ++;
      break;
      case 40: 
      bravalue = 66;
      ptr ++;
      if (((int const   )(*(cd->ctypes + (int const   )(*ptr))) & 4) != 0) {
        condref = (int )((int const   )(*ptr) - 48);
        while (1) {
          ptr ++;
          if (! ((int const   )(*ptr) != 41)) {
            break;
          }
          condref = (condref * 10 + (int )(*ptr)) - 48;
        }
        if (condref == 0) {
          (*errorptr) = "invalid condition (?(0)";
          goto FAILED;
        }
        ptr ++;
        (*(code + 3)) = (unsigned char)67;
        (*(code + 4)) = (unsigned char )(condref >> 8);
        (*(code + 5)) = (unsigned char )(condref & 255);
        skipbytes = 3;
      } else {
        ptr --;
      }
      break;
      case 61: 
      bravalue = 60;
      ptr ++;
      break;
      case 33: 
      bravalue = 61;
      ptr ++;
      break;
      case 60: 
      ptr ++;
      switch ((int )(*ptr)) {
      case 61: 
      bravalue = 62;
      ptr ++;
      break;
      case 33: 
      bravalue = 63;
      ptr ++;
      break;
      default: 
      (*errorptr) = "unrecognized character after (?<";
      goto FAILED;
      }
      break;
      case 62: 
      bravalue = 65;
      ptr ++;
      break;
      case 82: 
      tmp___43 = code;
      code ++;
      (*tmp___43) = (unsigned char)55;
      ptr ++;
      goto __Cont;
      default: 
      unset = 0;
      set = unset;
      optset = & set;
      while (1) {
        if ((int const   )(*ptr) != 41) {
          if (! ((int const   )(*ptr) != 58)) {
            goto _L___15;
          }
        } else {
          _L___15: 
          break;
        }
        tmp___44 = ptr;
        ptr ++;
        switch ((int )(*tmp___44)) {
        case 45: 
        optset = & unset;
        break;
        case 105: 
        (*optset) |= 1;
        break;
        case 109: 
        (*optset) |= 2;
        break;
        case 115: 
        (*optset) |= 4;
        break;
        case 120: 
        (*optset) |= 8;
        break;
        case 85: 
        (*optset) |= 512;
        break;
        case 88: 
        (*optset) |= 64;
        break;
        default: 
        (*errorptr) = "unrecognized character after (?";
        goto FAILED;
        }
      }
      newoptions = (options | set) & ~ unset;
      if ((int const   )(*ptr) == 41) {
        if ((options & 134217728) != 0) {
          if ((options & 7) != (newoptions & 7)) {
            tmp___45 = code;
            code ++;
            (*tmp___45) = (unsigned char)12;
            tmp___46 = code;
            code ++;
            (*optchanged) = newoptions & 7;
            (*tmp___46) = (unsigned char )(*optchanged);
          } else {
            goto _L___16;
          }
        } else {
          _L___16: ;
        }
        options = newoptions;
        previous = (uschar *)((void *)0);
        goto __Cont;
      }
      bravalue = 71;
      ptr ++;
      }
    } else {
      (*brackets) ++;
      if ((*brackets) > 150) {
        bravalue = 222;
        (*(code + 3)) = (unsigned char)70;
        (*(code + 4)) = (unsigned char )((*brackets) >> 8);
        (*(code + 5)) = (unsigned char )((*brackets) & 255);
        skipbytes = 3;
      } else {
        bravalue = 71 + (*brackets);
      }
    }
    if (bravalue >= 65) {
      previous = code;
    } else {
      previous = (uschar *)((void *)0);
    }
    (*code) = (unsigned char )bravalue;
    tempcode = code;
    if (bravalue == 62) {
      goto _L___17;
    } else {
      if (bravalue == 63) {
        _L___17: 
        tmp___47 = 1;
      } else {
        tmp___47 = 0;
      }
    }
    if ((options & 7) != (newoptions & 7)) {
      tmp___48 = newoptions & 7;
    } else {
      tmp___48 = -1;
    }
    tmp___49 = compile_regex(options | 134217728, tmp___48, brackets, & tempcode,
                             & ptr, errorptr, tmp___47, skipbytes, & subreqchar, & subcountlits,
                             cd);
    if (tmp___49) {
      if (bravalue == 66) {
        tc = code;
        condcount = 0;
        while (1) {
          condcount ++;
          tc += ((int )(*(tc + 1)) << 8) | (int )(*(tc + 2));
          if (! ((int )(*tc) != 57)) {
            break;
          }
        }
        if (condcount > 2) {
          (*errorptr) = "conditional group contains more than two branches";
          goto FAILED;
        }
      }
    } else {
      goto FAILED;
    }
    if (subreqchar > 0) {
      if (bravalue >= 71) {
        goto _L___22;
      } else {
        if (bravalue == 65) {
          _L___22: 
          goto _L___21;
        } else {
          if (bravalue == 60) {
            _L___21: 
            goto _L___19;
          } else {
            if (bravalue == 66) {
              if (condcount == 2) {
                _L___19: 
                prevreqchar = (*reqchar);
                (*reqchar) = subreqchar;
                if (bravalue != 60) {
                  (*countlits) += subcountlits;
                }
              } else {
                goto _L___20;
              }
            } else {
              _L___20: 
              goto _L___18;
            }
          }
        }
      }
    } else {
      _L___18: ;
    }
    code = tempcode;
    if ((int const   )(*ptr) != 41) {
      (*errorptr) = "missing )";
      goto FAILED;
    }
    break;
    case 92: 
    tempptr = ptr;
    c = check_escape(& ptr, errorptr, (*brackets), options, 0, cd);
    if (c < 0) {
      if (- c >= 12) {
        number = - c - 12;
        previous = code;
        tmp___50 = code;
        code ++;
        (*tmp___50) = (unsigned char)54;
        tmp___51 = code;
        code ++;
        (*tmp___51) = (unsigned char )(number >> 8);
        tmp___52 = code;
        code ++;
        (*tmp___52) = (unsigned char )(number & 255);
      } else {
        if (- c > 3) {
          if (- c < 10) {
            previous = code;
          } else {
            goto _L___23;
          }
        } else {
          _L___23: 
          previous = (uschar *)((void *)0);
        }
        tmp___53 = code;
        code ++;
        (*tmp___53) = (unsigned char )(- c);
      }
      goto __Cont;
    }
    ptr = tempptr;
    c = '\\';
    NORMAL_CHAR: 
    default: 
    previous = code;
    (*code) = (unsigned char)16;
    code += 2;
    length = 0;
    while (1) {
      if ((options & 8) != 0) {
        if (((int const   )(*(cd->ctypes + c)) & 1) != 0) {
          goto __Cont___1;
        }
        if (c == 35) {
          while (1) {
            ptr ++;
            c = (int )(*ptr);
            if (c != 0) {
              if (! (c != 10)) {
                goto _L___24;
              }
            } else {
              _L___24: 
              break;
            }
          }
          if (c == 0) {
            break;
          }
          goto __Cont___1;
        }
      }
      if (c == 92) {
        tempptr = ptr;
        c = check_escape(& ptr, errorptr, (*brackets), options, 0, cd);
        if (c < 0) {
          ptr = tempptr;
          break;
        }
      }
      tmp___54 = code;
      code ++;
      (*tmp___54) = (unsigned char )c;
      length ++;
      __Cont___1: 
      if (length < 255) {
        ptr ++;
        c = (int )(*ptr);
        if (! (((int const   )(*(cd->ctypes + c)) & 128) == 0)) {
          goto _L___25;
        }
      } else {
        _L___25: 
        break;
      }
    }
    if (length > 1) {
      prevreqchar = (int )(*(code + -2));
    } else {
      prevreqchar = (*reqchar);
    }
    (*reqchar) = (int )(*(code + -1));
    (*countlits) += length;
    (*(previous + 1)) = (unsigned char )length;
    if (length < 255) {
      ptr --;
    }
    break;
    }
    __Cont: 
    ptr ++;
  }
  FAILED: 
  (*ptrptr) = ptr;
  return (0);
}
}
static BOOL compile_regex(int options , int optchanged , int *brackets , uschar **codeptr ,
                          uschar const   **ptrptr , char const   **errorptr , BOOL lookbehind ,
                          int skipbytes , int *reqchar , int *countlits , compile_data *cd ) 
{ uschar const   *ptr ;
  uschar *code ;
  uschar *last_branch ;
  uschar *start_bracket ;
  uschar *reverse_count ;
  int oldoptions ;
  int branchreqchar ;
  int branchcountlits ;
  int length ;
  uschar *tmp ;
  uschar *tmp___0 ;
  uschar *tmp___1 ;
  uschar *tmp___2 ;
  uschar *tmp___3 ;
  BOOL tmp___4 ;
  uschar *tmp___5 ;
  uschar *tmp___6 ;
  uschar *tmp___7 ;
  uschar *tmp___8 ;
  uschar *tmp___9 ;

  {
  ptr = (*ptrptr);
  code = (*codeptr);
  last_branch = code;
  start_bracket = code;
  reverse_count = (uschar *)((void *)0);
  oldoptions = options & 7;
  (*reqchar) = -1;
  (*countlits) = 2147483647;
  code += 3 + skipbytes;
  while (1) {
    if (optchanged >= 0) {
      tmp = code;
      code ++;
      (*tmp) = (unsigned char)12;
      tmp___0 = code;
      code ++;
      (*tmp___0) = (unsigned char )optchanged;
      options = (options & -8) | optchanged;
    }
    if (lookbehind) {
      tmp___1 = code;
      code ++;
      (*tmp___1) = (unsigned char)64;
      reverse_count = code;
      tmp___2 = code;
      code ++;
      (*tmp___2) = (unsigned char)0;
      tmp___3 = code;
      code ++;
      (*tmp___3) = (unsigned char)0;
    }
    tmp___4 = compile_branch(options, brackets, & code, & ptr, errorptr, & optchanged,
                             & branchreqchar, & branchcountlits, cd);
    if (! tmp___4) {
      (*ptrptr) = ptr;
      return (0);
    }
    length = code - last_branch;
    (*(last_branch + 1)) = (unsigned char )(length >> 8);
    (*(last_branch + 2)) = (unsigned char )(length & 255);
    if ((*reqchar) != -2) {
      if (branchreqchar >= 0) {
        if ((*reqchar) == -1) {
          (*reqchar) = branchreqchar;
        } else {
          if ((*reqchar) != branchreqchar) {
            (*reqchar) = -2;
          }
        }
      } else {
        (*reqchar) = -2;
      }
    }
    if (branchcountlits < (*countlits)) {
      (*countlits) = branchcountlits;
    }
    if (lookbehind) {
      (*code) = (unsigned char)0;
      length = find_fixedlength(last_branch, options);
      if (length < 0) {
        (*errorptr) = "lookbehind assertion is not fixed length";
        (*ptrptr) = ptr;
        return (0);
      }
      (*(reverse_count + 0)) = (unsigned char )(length >> 8);
      (*(reverse_count + 1)) = (unsigned char )(length & 255);
    }
    if ((int const   )(*ptr) != 124) {
      length = code - start_bracket;
      tmp___5 = code;
      code ++;
      (*tmp___5) = (unsigned char)57;
      tmp___6 = code;
      code ++;
      (*tmp___6) = (unsigned char )(length >> 8);
      tmp___7 = code;
      code ++;
      (*tmp___7) = (unsigned char )(length & 255);
      if (optchanged >= 0) {
        tmp___8 = code;
        code ++;
        (*tmp___8) = (unsigned char)12;
        tmp___9 = code;
        code ++;
        (*tmp___9) = (unsigned char )oldoptions;
      }
      (*codeptr) = code;
      (*ptrptr) = ptr;
      return (1);
    }
    (*code) = (unsigned char)56;
    last_branch = code;
    code += 3;
    ptr ++;
  }
  return (0);
}
}
static uschar const   *first_significant_code(uschar const   *code , int *options ,
                                              int optbit , BOOL optstop ) 
{ 

  {
  while (1) {
    switch ((int )(*code)) {
    case 12: ;
    if (optbit > 0) {
      if (((int )(*(code + 1)) & optbit) != ((*options) & optbit)) {
        if (optstop) {
          return (code);
        }
        (*options) = (int )(*(code + 1));
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    code += 2;
    break;
    case 67: ;
    case 70: 
    code += 3;
    break;
    case 3: ;
    case 2: 
    code ++;
    break;
    case 61: ;
    case 62: ;
    case 63: ;
    while (1) {
      code += ((int const   )(*(code + 1)) << 8) + (int const   )(*(code + 2));
      if (! ((int const   )(*code) == 56)) {
        break;
      }
    }
    code += 3;
    break;
    default: ;
    return (code);
    }
  }
  return ((uschar const   *)0);
}
}
static BOOL is_anchored(uschar const   *code , int *options ) 
{ uschar const   *scode ;
  uschar const   *tmp ;
  register int op ;
  BOOL tmp___0 ;

  {
  while (1) {
    tmp = first_significant_code(code + 3, options, 2, 0);
    scode = tmp;
    op = (int )(*scode);
    if (op >= 71) {
      goto _L___5;
    } else {
      if (op == 60) {
        _L___5: 
        goto _L___4;
      } else {
        if (op == 65) {
          _L___4: 
          goto _L___3;
        } else {
          if (op == 66) {
            _L___3: 
            tmp___0 = is_anchored(scode, options);
            if (! tmp___0) {
              return (0);
            }
          } else {
            if (op == 36) {
              goto _L___2;
            } else {
              if (op == 37) {
                _L___2: 
                if (((*options) & 4) != 0) {
                  if ((int const   )(*(scode + 1)) != 15) {
                    return (0);
                  }
                } else {
                  goto _L___1;
                }
              } else {
                _L___1: 
                if (op != 1) {
                  if (((*options) & 2) != 0) {
                    goto _L___0;
                  } else {
                    if (op != 13) {
                      _L___0: 
                      return (0);
                    } else {
                      goto _L;
                    }
                  }
                } else {
                  _L: ;
                }
              }
            }
          }
        }
      }
    }
    code += ((int const   )(*(code + 1)) << 8) + (int const   )(*(code + 2));
    if (! ((int const   )(*code) == 56)) {
      break;
    }
  }
  return (1);
}
}
static BOOL is_startline(uschar const   *code ) 
{ uschar const   *scode ;
  uschar const   *tmp ;
  register int op ;
  BOOL tmp___0 ;

  {
  while (1) {
    tmp = first_significant_code(code + 3, (int *)((void *)0), 0, 0);
    scode = tmp;
    op = (int )(*scode);
    if (op >= 71) {
      goto _L___2;
    } else {
      if (op == 60) {
        _L___2: 
        goto _L___1;
      } else {
        if (op == 65) {
          _L___1: 
          goto _L___0;
        } else {
          if (op == 66) {
            _L___0: 
            tmp___0 = is_startline(scode);
            if (! tmp___0) {
              return (0);
            }
          } else {
            if (op == 36) {
              goto _L;
            } else {
              if (op == 37) {
                _L: 
                if ((int const   )(*(scode + 1)) != 15) {
                  return (0);
                }
              } else {
                if (op != 13) {
                  return (0);
                }
              }
            }
          }
        }
      }
    }
    code += ((int const   )(*(code + 1)) << 8) + (int const   )(*(code + 2));
    if (! ((int const   )(*code) == 56)) {
      break;
    }
  }
  return (1);
}
}
static int find_firstchar(uschar const   *code , int *options ) 
{ register int c ;
  int d ;
  uschar const   *scode ;
  uschar const   *tmp ;
  register int op ;

  {
  c = -1;
  while (1) {
    tmp = first_significant_code(code + 3, options, 1, 1);
    scode = tmp;
    op = (int )(*scode);
    if (op >= 71) {
      op = 71;
    }
    switch (op) {
    default: ;
    return (-1);
    case 71: ;
    case 60: ;
    case 65: ;
    case 66: 
    d = find_firstchar(scode, options);
    if (d < 0) {
      return (-1);
    }
    if (c < 0) {
      c = d;
    } else {
      if (c != d) {
        return (-1);
      }
    }
    break;
    case 26: 
    scode ++;
    case 16: 
    scode ++;
    case 20: ;
    case 21: ;
    if (c < 0) {
      c = (int )(*(scode + 1));
    } else {
      if (c != (int )(*(scode + 1))) {
        return (-1);
      }
    }
    break;
    }
    code += ((int const   )(*(code + 1)) << 8) + (int const   )(*(code + 2));
    if (! ((int const   )(*code) == 56)) {
      break;
    }
  }
  return (c);
}
}
pcre *pcre_compile(char const   *pattern , int options , char const   **errorptr ,
                   int *erroroffset , unsigned char const   *tables ) 
{ real_pcre *re ;
  int length ;
  int runlength ;
  int c ;
  int reqchar ;
  int countlits ;
  int bracount ;
  int top_backref ;
  int branch_extra ;
  int branch_newextra ;
  unsigned int brastackptr ;
  size_t size ;
  uschar *code ;
  uschar const   *ptr ;
  compile_data compile_block ;
  int brastack[200] ;
  uschar bralenstack[200] ;
  int min ;
  int max ;
  int class_charcount ;
  int bracket_length ;
  uschar const   *save_ptr ;
  int refnum ;
  BOOL tmp ;
  BOOL tmp___0 ;
  int ch ;
  int tmp___1 ;
  BOOL tmp___2 ;
  int set ;
  int unset ;
  int *optset ;
  unsigned int tmp___3 ;
  int minval ;
  int maxval ;
  int duplength ;
  BOOL tmp___4 ;
  uschar const   *saveptr ;
  uschar *tmp___6 ;
  int temp_options ;
  int ch___0 ;
  int tmp___7 ;
  BOOL tmp___8 ;
  BOOL tmp___9 ;

  {
  length = 3;
  bracount = 0;
  top_backref = 0;
  branch_extra = 0;
  brastackptr = 0U;
  if ((options & 2048) != 0) {
    (*errorptr) = "this version of PCRE is not compiled with PCRE_UTF8 support";
    return ((pcre *)((void *)0));
  }
  if ((unsigned int )errorptr == (unsigned int )((void *)0)) {
    return ((pcre *)((void *)0));
  }
  (*errorptr) = (char const   *)((void *)0);
  if ((unsigned int )erroroffset == (unsigned int )((void *)0)) {
    (*errorptr) = "erroffset passed as NULL";
    return ((pcre *)((void *)0));
  }
  (*erroroffset) = 0;
  if ((options & -2688) != 0) {
    (*errorptr) = "unknown option bit(s) set";
    return ((pcre *)((void *)0));
  }
  if ((unsigned int )tables == (unsigned int )((void *)0)) {
    tables = (unsigned char const   *)(pcre_default_tables);
  }
  compile_block.lcc = tables + 0;
  compile_block.fcc = tables + 256;
  compile_block.cbits = tables + 512;
  compile_block.ctypes = tables + 832;
  ptr = (uschar const   *)(pattern - 1);
  while (1) {
    ptr ++;
    c = (int )(*ptr);
    if (! (c != 0)) {
      break;
    }
    if ((options & 8) != 0) {
      if (((int const   )(*(compile_block.ctypes + c)) & 1) != 0) {
        continue;
      }
      if (c == 35) {
        while (1) {
          ptr ++;
          c = (int )(*ptr);
          if (c != 0) {
            if (! (c != 10)) {
              goto _L;
            }
          } else {
            _L: 
            break;
          }
        }
        continue;
      }
    }
    switch (c) {
    case 92: 
    save_ptr = ptr;
    c = check_escape(& ptr, errorptr, bracount, options, 0, & compile_block);
    if ((unsigned int )(*errorptr) != (unsigned int )((void *)0)) {
      goto PCRE_ERROR_RETURN;
    }
    if (c >= 0) {
      ptr = save_ptr;
      c = '\\';
      goto NORMAL_CHAR;
    }
    length ++;
    if (c <= -12) {
      refnum = - c - 12;
      if (refnum > top_backref) {
        top_backref = refnum;
      }
      length += 2;
      if ((int const   )(*(ptr + 1)) == 123) {
        tmp = is_counted_repeat(ptr + 2, & compile_block);
        if (tmp) {
          ptr = read_repeat_counts(ptr + 2, & min, & max, errorptr, & compile_block);
          if ((unsigned int )(*errorptr) != (unsigned int )((void *)0)) {
            goto PCRE_ERROR_RETURN;
          }
          if (min == 0) {
            if (max == 1) {
              goto _L___3;
            } else {
              if (max == -1) {
                _L___3: 
                goto _L___0;
              } else {
                goto _L___2;
              }
            }
          } else {
            _L___2: 
            if (min == 1) {
              if (max == -1) {
                _L___0: 
                length ++;
              } else {
                goto _L___1;
              }
            } else {
              _L___1: 
              length += 5;
            }
          }
          if ((int const   )(*(ptr + 1)) == 63) {
            ptr ++;
          }
        } else {
          goto _L___4;
        }
      } else {
        _L___4: ;
      }
    }
    continue;
    case 94: ;
    case 46: ;
    case 36: ;
    case 42: ;
    case 43: ;
    case 63: 
    length ++;
    continue;
    case 123: 
    tmp___0 = is_counted_repeat(ptr + 1, & compile_block);
    if (! tmp___0) {
      goto NORMAL_CHAR;
    }
    ptr = read_repeat_counts(ptr + 1, & min, & max, errorptr, & compile_block);
    if ((unsigned int )(*errorptr) != (unsigned int )((void *)0)) {
      goto PCRE_ERROR_RETURN;
    }
    if (min == 0) {
      if (max == 1) {
        goto _L___8;
      } else {
        if (max == -1) {
          _L___8: 
          goto _L___5;
        } else {
          goto _L___7;
        }
      }
    } else {
      _L___7: 
      if (min == 1) {
        if (max == -1) {
          _L___5: 
          length ++;
        } else {
          goto _L___6;
        }
      } else {
        _L___6: 
        length --;
        if (min == 1) {
          length ++;
        } else {
          if (min > 0) {
            length += 4;
          }
        }
        if (max > 0) {
          length += 4;
        } else {
          length += 2;
        }
      }
    }
    if ((int const   )(*(ptr + 1)) == 63) {
      ptr ++;
    }
    continue;
    case 124: 
    length += 3 + branch_extra;
    continue;
    case 91: 
    class_charcount = 0;
    ptr ++;
    if ((int const   )(*ptr) == 94) {
      ptr ++;
    }
    while (1) {
      if ((int const   )(*ptr) == 92) {
        tmp___1 = check_escape(& ptr, errorptr, bracount, options, 1, & compile_block);
        ch = tmp___1;
        if ((unsigned int )(*errorptr) != (unsigned int )((void *)0)) {
          goto PCRE_ERROR_RETURN;
        }
        if (- ch == 3) {
          class_charcount ++;
        } else {
          class_charcount = 10;
        }
      } else {
        class_charcount ++;
      }
      ptr ++;
      if ((int const   )(*ptr) != 0) {
        if (! ((int const   )(*ptr) != 93)) {
          goto _L___9;
        }
      } else {
        _L___9: 
        break;
      }
    }
    if (class_charcount == 1) {
      length += 3;
    } else {
      length += 33;
      if ((int const   )(*ptr) != 0) {
        if ((int const   )(*(ptr + 1)) == 123) {
          tmp___2 = is_counted_repeat(ptr + 2, & compile_block);
          if (tmp___2) {
            ptr = read_repeat_counts(ptr + 2, & min, & max, errorptr, & compile_block);
            if ((unsigned int )(*errorptr) != (unsigned int )((void *)0)) {
              goto PCRE_ERROR_RETURN;
            }
            if (min == 0) {
              if (max == 1) {
                goto _L___13;
              } else {
                if (max == -1) {
                  _L___13: 
                  goto _L___10;
                } else {
                  goto _L___12;
                }
              }
            } else {
              _L___12: 
              if (min == 1) {
                if (max == -1) {
                  _L___10: 
                  length ++;
                } else {
                  goto _L___11;
                }
              } else {
                _L___11: 
                length += 5;
              }
            }
            if ((int const   )(*(ptr + 1)) == 63) {
              ptr ++;
            }
          } else {
            goto _L___15;
          }
        } else {
          goto _L___15;
        }
      } else {
        _L___15: ;
      }
    }
    continue;
    case 40: 
    branch_newextra = 0;
    bracket_length = 3;
    if ((int const   )(*(ptr + 1)) == 63) {
      c = (int )(*(ptr + 2));
      switch (c) {
      case 35: 
      ptr += 3;
      while (1) {
        if ((int const   )(*ptr) != 0) {
          if (! ((int const   )(*ptr) != 41)) {
            goto _L___16;
          }
        } else {
          _L___16: 
          break;
        }
        ptr ++;
      }
      if ((int const   )(*ptr) == 0) {
        (*errorptr) = "missing ) after comment";
        goto PCRE_ERROR_RETURN;
      }
      continue;
      case 58: ;
      case 61: ;
      case 33: ;
      case 62: 
      ptr += 2;
      break;
      case 82: ;
      if ((int const   )(*(ptr + 3)) != 41) {
        (*errorptr) = "(?p must be followed by )";
        goto PCRE_ERROR_RETURN;
      }
      ptr += 3;
      length ++;
      break;
      case 60: ;
      if ((int const   )(*(ptr + 3)) == 61) {
        goto _L___17;
      } else {
        if ((int const   )(*(ptr + 3)) == 33) {
          _L___17: 
          ptr += 3;
          branch_newextra = 3;
          length += 3;
          break;
        }
      }
      (*errorptr) = "unrecognized character after (?<";
      goto PCRE_ERROR_RETURN;
      case 40: ;
      if (((int const   )(*(compile_block.ctypes + (int const   )(*(ptr + 3)))) &
           4) != 0) {
        ptr += 4;
        length += 3;
        while (((int const   )(*(compile_block.ctypes + (int const   )(*ptr))) & 4) !=
               0) {
          ptr ++;
        }
        if ((int const   )(*ptr) != 41) {
          (*errorptr) = "malformed number after (?(";
          goto PCRE_ERROR_RETURN;
        }
      } else {
        ptr ++;
        if ((int const   )(*(ptr + 2)) != 63) {
          goto _L___18;
        } else {
          if ((int const   )(*(ptr + 3)) != 61) {
            if ((int const   )(*(ptr + 3)) != 33) {
              if ((int const   )(*(ptr + 3)) != 60) {
                _L___18: 
                ptr += 2;
                (*errorptr) = "assertion expected after (?(";
                goto PCRE_ERROR_RETURN;
              } else {
                goto _L___20;
              }
            } else {
              goto _L___20;
            }
          } else {
            _L___20: ;
          }
        }
      }
      break;
      default: 
      unset = 0;
      set = unset;
      optset = & set;
      ptr += 2;
      while (1) {
        c = (int )(*ptr);
        switch (c) {
        case 105: 
        (*optset) |= 1;
        goto __Cont;
        case 109: 
        (*optset) |= 2;
        goto __Cont;
        case 115: 
        (*optset) |= 4;
        goto __Cont;
        case 120: 
        (*optset) |= 8;
        goto __Cont;
        case 88: 
        (*optset) |= 64;
        goto __Cont;
        case 85: 
        (*optset) |= 512;
        goto __Cont;
        case 45: 
        optset = & unset;
        goto __Cont;
        case 41: ;
        if (brastackptr == 0U) {
          options = (options | set) & ~ unset;
          unset = 0;
          set = unset;
        }
        case 58: ;
        if (((set | unset) & 7) != 0) {
          length += 4;
          branch_newextra = 2;
          if (((set | unset) & 1) != 0) {
            options |= 67108864;
          }
        }
        goto END_OPTIONS;
        default: 
        (*errorptr) = "unrecognized character after (?";
        goto PCRE_ERROR_RETURN;
        }
        __Cont: 
        ptr ++;
      }
      END_OPTIONS: 
      if (c == 41) {
        if (branch_newextra == 2) {
          if (branch_extra == 0) {
            goto _L___22;
          } else {
            if (branch_extra == 3) {
              _L___22: 
              branch_extra += branch_newextra;
            } else {
              goto _L___21;
            }
          }
        } else {
          _L___21: ;
        }
        continue;
      }
      }
    } else {
      bracount ++;
      if (bracount > 150) {
        bracket_length += 3;
      }
    }
    if (brastackptr >= sizeof(brastack) / sizeof(int )) {
      (*errorptr) = "parentheses nested too deeply";
      goto PCRE_ERROR_RETURN;
    }
    bralenstack[brastackptr] = (unsigned char )branch_extra;
    branch_extra = branch_newextra;
    tmp___3 = brastackptr;
    brastackptr ++;
    brastack[tmp___3] = length;
    length += bracket_length;
    continue;
    case 41: 
    length += 3;
    minval = 1;
    maxval = 1;
    if (brastackptr > 0U) {
      brastackptr --;
      duplength = length - brastack[brastackptr];
      branch_extra = (int )bralenstack[brastackptr];
    } else {
      duplength = 0;
    }
    c = (int )(*(ptr + 1));
    if (c == 123) {
      tmp___4 = is_counted_repeat(ptr + 2, & compile_block);
      if (tmp___4) {
        ptr = read_repeat_counts(ptr + 2, & minval, & maxval, errorptr, & compile_block);
        if ((unsigned int )(*errorptr) != (unsigned int )((void *)0)) {
          goto PCRE_ERROR_RETURN;
        }
      } else {
        goto _L___23;
      }
    } else {
      _L___23: 
      if (c == 42) {
        minval = 0;
        maxval = -1;
        ptr ++;
      } else {
        if (c == 43) {
          maxval = -1;
          ptr ++;
        } else {
          if (c == 63) {
            minval = 0;
            ptr ++;
          }
        }
      }
    }
    if (minval == 0) {
      length ++;
      if (maxval > 0) {
        length += (maxval - 1) * (duplength + 7);
      }
    } else {
      length += (minval - 1) * duplength;
      if (maxval > minval) {
        length += (maxval - minval) * (duplength + 7) - 6;
      }
    }
    continue;
    NORMAL_CHAR: 
    default: 
    length += 2;
    runlength = 0;
    while (1) {
      if ((options & 8) != 0) {
        if (((int const   )(*(compile_block.ctypes + c)) & 1) != 0) {
          goto __Cont___0;
        }
        if (c == 35) {
          while (1) {
            ptr ++;
            c = (int )(*ptr);
            if (c != 0) {
              if (! (c != 10)) {
                goto _L___24;
              }
            } else {
              _L___24: 
              break;
            }
          }
          goto __Cont___0;
        }
      }
      if (c == 92) {
        saveptr = ptr;
        c = check_escape(& ptr, errorptr, bracount, options, 0, & compile_block);
        if ((unsigned int )(*errorptr) != (unsigned int )((void *)0)) {
          goto PCRE_ERROR_RETURN;
        }
        if (c < 0) {
          ptr = saveptr;
          break;
        }
      }
      runlength ++;
      __Cont___0: 
      if (runlength < 255) {
        ptr ++;
        c = (int )(*ptr);
        if (! (((int const   )(*(compile_block.ctypes + c)) & 128) == 0)) {
          goto _L___25;
        }
      } else {
        _L___25: 
        break;
      }
    }
    ptr --;
    length += runlength;
    continue;
    }
  }
  length += 4;
  if (length > 65539) {
    (*errorptr) = "regular expression too large";
    return ((pcre *)((void *)0));
  }
  size = (unsigned int )length + (unsigned int )(& ((real_pcre *)0)->code[0]);
  re = (real_pcre *)((*pcre_malloc))(size);
  if ((unsigned int )re == (unsigned int )((void *)0)) {
    (*errorptr) = "failed to get memory";
    return ((pcre *)((void *)0));
  }
  re->magic_number = 1346589253UL;
  re->size = size;
  re->options = (unsigned long )options;
  re->tables = tables;
  ptr = (uschar const   *)pattern;
  code = re->code;
  (*code) = (unsigned char)71;
  bracount = 0;
  compile_regex(options, -1, & bracount, & code, & ptr, errorptr, 0, 0, & reqchar,
                & countlits, & compile_block);
  re->top_bracket = (unsigned short )bracount;
  re->top_backref = (unsigned short )top_backref;
  if ((unsigned int )(*errorptr) == (unsigned int )((void *)0)) {
    if ((int const   )(*ptr) != 0) {
      (*errorptr) = "unmatched parentheses";
    } else {
      goto _L___26;
    }
  } else {
    _L___26: ;
  }
  tmp___6 = code;
  code ++;
  (*tmp___6) = (unsigned char)0;
  if (code - re->code > length) {
    (*errorptr) = "internal error: code overflow";
  }
  if (top_backref > (int )re->top_bracket) {
    (*errorptr) = "back reference to non-existent subpattern";
  }
  if ((unsigned int )(*errorptr) != (unsigned int )((void *)0)) {
    ((*pcre_free))((void *)re);
    PCRE_ERROR_RETURN: 
    (*erroroffset) = ptr - (uschar const   *)pattern;
    return ((pcre *)((void *)0));
  }
  if ((options & 16) == 0) {
    temp_options = options;
    tmp___9 = is_anchored((uschar const   *)(re->code), & temp_options);
    if (tmp___9) {
      re->options = re->options | 16UL;
    } else {
      tmp___7 = find_firstchar((uschar const   *)(re->code), & temp_options);
      ch___0 = tmp___7;
      if (ch___0 >= 0) {
        re->first_char = (unsigned char )ch___0;
        re->options = re->options | 1073741824UL;
      } else {
        tmp___8 = is_startline((uschar const   *)(re->code));
        if (tmp___8) {
          re->options = re->options | 268435456UL;
        }
      }
    }
  }
  if (reqchar >= 0) {
    if (countlits > 1) {
      goto _L___28;
    } else {
      if ((re->options & 1073741824UL) == 0UL) {
        _L___28: 
        re->req_char = (unsigned char )reqchar;
        re->options = re->options | 536870912UL;
      } else {
        goto _L___27;
      }
    }
  } else {
    _L___27: ;
  }
  return (re);
}
}
static BOOL match_ref(int offset , uschar const   *eptr , int length , match_data *md ,
                      unsigned long ims ) 
{ uschar const   *p ;
  uschar const   *tmp ;
  uschar const   *tmp___0 ;
  int tmp___1 ;
  uschar const   *tmp___2 ;
  uschar const   *tmp___3 ;
  int tmp___4 ;

  {
  p = md->start_subject + (*(md->offset_vector + offset));
  if (length > md->end_subject - eptr) {
    return (0);
  }
  if ((ims & 1UL) != 0UL) {
    while (1) {
      tmp___1 = length;
      length --;
      if (! (tmp___1 > 0)) {
        break;
      }
      tmp = p;
      p ++;
      tmp___0 = eptr;
      eptr ++;
      if ((int const   )(*(md->lcc + (int const   )(*tmp))) != (int const   )(*(md->lcc +
                                                                                (int const   )(*tmp___0)))) {
        return (0);
      }
    }
  } else {
    while (1) {
      tmp___4 = length;
      length --;
      if (! (tmp___4 > 0)) {
        break;
      }
      tmp___2 = p;
      p ++;
      tmp___3 = eptr;
      eptr ++;
      if ((int const   )(*tmp___2) != (int const   )(*tmp___3)) {
        return (0);
      }
    }
  }
  return (1);
}
}
static BOOL match(uschar const   *eptr , uschar const   *ecode , int offset_top ,
                  match_data *md , unsigned long ims , eptrblock *eptrb , int flags ) 
{ unsigned long original_ims ;
  eptrblock newptrb ;
  int op ;
  int min ;
  int max ;
  int ctype ;
  register int i ;
  register int c ;
  BOOL minimize ;
  int offset ;
  int number ;
  int save_offset1 ;
  int save_offset2 ;
  int save_offset3 ;
  BOOL tmp ;
  BOOL tmp___0 ;
  int offset___0 ;
  int tmp___1 ;
  BOOL tmp___2 ;
  BOOL tmp___3 ;
  BOOL tmp___4 ;
  BOOL tmp___5 ;
  BOOL tmp___6 ;
  BOOL rc ;
  int *save ;
  int stacksave[15] ;
  uschar const   *prev ;
  uschar const   *saved_eptr ;
  BOOL tmp___8 ;
  BOOL tmp___9 ;
  BOOL tmp___10 ;
  BOOL tmp___11 ;
  BOOL tmp___12 ;
  uschar const   *next ;
  BOOL tmp___13 ;
  uschar const   *next___0 ;
  BOOL tmp___14 ;
  uschar const   *prev___0 ;
  uschar const   *saved_eptr___0 ;
  int offset___1 ;
  int number___0 ;
  BOOL tmp___15 ;
  BOOL tmp___16 ;
  BOOL tmp___17 ;
  BOOL tmp___18 ;
  BOOL prev_is_word ;
  int tmp___19 ;
  BOOL cur_is_word ;
  int tmp___20 ;
  int tmp___22 ;
  uschar const   *tmp___23 ;
  uschar const   *tmp___24 ;
  uschar const   *tmp___25 ;
  uschar const   *tmp___26 ;
  uschar const   *tmp___27 ;
  uschar const   *tmp___28 ;
  uschar const   *tmp___29 ;
  uschar const   *tmp___30 ;
  int length ;
  int offset___2 ;
  uschar const   *tmp___31 ;
  BOOL tmp___32 ;
  BOOL tmp___33 ;
  BOOL tmp___34 ;
  BOOL tmp___35 ;
  uschar const   *pp ;
  BOOL tmp___36 ;
  BOOL tmp___37 ;
  uschar const   *data ;
  uschar const   *tmp___38 ;
  uschar const   *tmp___39 ;
  BOOL tmp___40 ;
  uschar const   *tmp___41 ;
  uschar const   *pp___0 ;
  int len ;
  uschar const   *tmp___42 ;
  BOOL tmp___43 ;
  register int length___0 ;
  uschar const   *tmp___44 ;
  uschar const   *tmp___45 ;
  int tmp___46 ;
  uschar const   *tmp___47 ;
  uschar const   *tmp___48 ;
  int tmp___49 ;
  uschar const   *tmp___50 ;
  uschar const   *tmp___51 ;
  uschar const   *tmp___52 ;
  BOOL tmp___53 ;
  uschar const   *tmp___54 ;
  uschar const   *pp___1 ;
  uschar const   *tmp___55 ;
  BOOL tmp___56 ;
  uschar const   *tmp___57 ;
  BOOL tmp___58 ;
  uschar const   *tmp___59 ;
  uschar const   *pp___2 ;
  uschar const   *tmp___60 ;
  BOOL tmp___61 ;
  uschar const   *tmp___62 ;
  uschar const   *tmp___63 ;
  uschar const   *tmp___64 ;
  uschar const   *tmp___65 ;
  uschar const   *tmp___66 ;
  uschar const   *tmp___67 ;
  uschar const   *tmp___68 ;
  BOOL tmp___69 ;
  uschar const   *tmp___70 ;
  uschar const   *pp___3 ;
  uschar const   *tmp___71 ;
  BOOL tmp___72 ;
  uschar const   *tmp___73 ;
  BOOL tmp___74 ;
  uschar const   *tmp___75 ;
  uschar const   *pp___4 ;
  uschar const   *tmp___76 ;
  BOOL tmp___77 ;
  uschar const   *tmp___78 ;
  uschar const   *tmp___79 ;
  uschar const   *tmp___80 ;
  uschar const   *tmp___81 ;
  uschar const   *tmp___82 ;
  uschar const   *tmp___83 ;
  uschar const   *tmp___84 ;
  uschar const   *tmp___85 ;
  uschar const   *tmp___86 ;
  BOOL tmp___87 ;
  uschar const   *tmp___88 ;
  uschar const   *pp___5 ;
  uschar const   *tmp___89 ;
  BOOL tmp___90 ;

  {
  original_ims = ims;
  if ((flags & 2) != 0) {
    newptrb.prev = eptrb;
    newptrb.saved_eptr = eptr;
    eptrb = & newptrb;
  }
  while (1) {
    op = (int )(*ecode);
    minimize = 0;
    if (op > 71) {
      number = op - 71;
      if (number > 150) {
        number = (int )(((int const   )(*(ecode + 4)) << 8) | (int const   )(*(ecode +
                                                                               5)));
      }
      offset = number << 1;
      if (offset < md->offset_max) {
        save_offset1 = (*(md->offset_vector + offset));
        save_offset2 = (*(md->offset_vector + (offset + 1)));
        save_offset3 = (*(md->offset_vector + (md->offset_end - number)));
        (*(md->offset_vector + (md->offset_end - number))) = eptr - md->start_subject;
        while (1) {
          tmp = match(eptr, ecode + 3, offset_top, md, ims, eptrb, 2);
          if (tmp) {
            return (1);
          }
          ecode += ((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode +
                                                                          2));
          if (! ((int const   )(*ecode) == 56)) {
            break;
          }
        }
        (*(md->offset_vector + offset)) = save_offset1;
        (*(md->offset_vector + (offset + 1))) = save_offset2;
        (*(md->offset_vector + (md->offset_end - number))) = save_offset3;
        return (0);
      } else {
        op = 71;
      }
    }
    switch (op) {
    case 71: ;
    while (1) {
      tmp___0 = match(eptr, ecode + 3, offset_top, md, ims, eptrb, 2);
      if (tmp___0) {
        return (1);
      }
      ecode += ((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode + 2));
      if (! ((int const   )(*ecode) == 56)) {
        break;
      }
    }
    return (0);
    case 66: ;
    if ((int const   )(*(ecode + 3)) == 67) {
      offset___0 = (int )(((int const   )(*(ecode + 4)) << 9) | ((int const   )(*(ecode +
                                                                                  5)) <<
                                                                 1));
      if (offset___0 < offset_top) {
        if ((*(md->offset_vector + offset___0)) >= 0) {
          tmp___1 = 6;
        } else {
          goto _L;
        }
      } else {
        _L: 
        tmp___1 = (3 + (int )((int const   )(*(ecode + 1)) << 8)) + (int )(*(ecode +
                                                                             2));
      }
      tmp___2 = match(eptr, ecode + tmp___1, offset_top, md, ims, eptrb, 2);
      return (tmp___2);
    } else {
      tmp___3 = match(eptr, ecode + 3, offset_top, md, ims, (eptrblock *)((void *)0),
                      3);
      if (tmp___3) {
        ecode += (3 + (int )((int const   )(*(ecode + 4)) << 8)) + (int )(*(ecode +
                                                                            5));
        while ((int const   )(*ecode) == 56) {
          ecode += ((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode +
                                                                          2));
        }
      } else {
        ecode += ((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode + 2));
      }
      tmp___4 = match(eptr, ecode + 3, offset_top, md, ims, eptrb, 2);
      return (tmp___4);
    }
    case 67: ;
    case 70: 
    ecode += 3;
    break;
    case 0: ;
    if (md->notempty) {
      if ((unsigned int )eptr == (unsigned int )md->start_match) {
        return (0);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
    md->end_match_ptr = eptr;
    md->end_offset_top = offset_top;
    return (1);
    case 12: 
    ims = (unsigned long )(*(ecode + 1));
    ecode += 2;
    break;
    case 60: ;
    case 62: ;
    while (1) {
      tmp___5 = match(eptr, ecode + 3, offset_top, md, ims, (eptrblock *)((void *)0),
                      2);
      if (tmp___5) {
        break;
      }
      ecode += ((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode + 2));
      if (! ((int const   )(*ecode) == 56)) {
        break;
      }
    }
    if ((int const   )(*ecode) == 57) {
      return (0);
    }
    if ((flags & 1) != 0) {
      return (1);
    }
    while (1) {
      ecode += ((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode + 2));
      if (! ((int const   )(*ecode) == 56)) {
        break;
      }
    }
    ecode += 3;
    offset_top = md->end_offset_top;
    goto __Cont;
    case 61: ;
    case 63: ;
    while (1) {
      tmp___6 = match(eptr, ecode + 3, offset_top, md, ims, (eptrblock *)((void *)0),
                      2);
      if (tmp___6) {
        return (0);
      }
      ecode += ((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode + 2));
      if (! ((int const   )(*ecode) == 56)) {
        break;
      }
    }
    if ((flags & 1) != 0) {
      return (1);
    }
    ecode += 3;
    goto __Cont;
    case 64: 
    eptr -= ((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode + 2));
    if ((unsigned int )eptr < (unsigned int )md->start_subject) {
      return (0);
    }
    ecode += 3;
    break;
    case 55: 
    c = md->offset_max;
    if (c < 16) {
      save = stacksave;
    } else {
      save = (int *)((*pcre_malloc))((unsigned int )(c + 1) * sizeof(int ));
      if ((unsigned int )save == (unsigned int )((void *)0)) {
        save = stacksave;
        c = 15;
      }
    }
    i = 1;
    while (i <= c) {
      (*(save + i)) = (*(md->offset_vector + (md->offset_end - i)));
      i ++;
    }
    rc = match(eptr, md->start_pattern, offset_top, md, ims, eptrb, 2);
    i = 1;
    while (i <= c) {
      (*(md->offset_vector + (md->offset_end - i))) = (*(save + i));
      i ++;
    }
    if ((unsigned int )save != (unsigned int )(stacksave)) {
      ((*pcre_free))((void *)save);
    }
    if (! rc) {
      return (0);
    }
    offset_top = md->end_offset_top;
    eptr = md->end_match_ptr;
    ecode ++;
    break;
    case 65: 
    prev = ecode;
    saved_eptr = eptr;
    while (1) {
      tmp___8 = match(eptr, ecode + 3, offset_top, md, ims, eptrb, 2);
      if (tmp___8) {
        break;
      }
      ecode += ((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode + 2));
      if (! ((int const   )(*ecode) == 56)) {
        break;
      }
    }
    if ((int const   )(*ecode) != 65) {
      if ((int const   )(*ecode) != 56) {
        return (0);
      } else {
        goto _L___1;
      }
    } else {
      _L___1: ;
    }
    while (1) {
      ecode += ((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode + 2));
      if (! ((int const   )(*ecode) == 56)) {
        break;
      }
    }
    offset_top = md->end_offset_top;
    eptr = md->end_match_ptr;
    if ((int const   )(*ecode) == 57) {
      goto _L___2;
    } else {
      if ((unsigned int )eptr == (unsigned int )saved_eptr) {
        _L___2: 
        ecode += 3;
        break;
      }
    }
    if ((int const   )(*(ecode + 3)) == 12) {
      ims = (ims & 4294967288UL) | (unsigned long )(*(ecode + 4));
    }
    if ((int const   )(*ecode) == 59) {
      tmp___9 = match(eptr, ecode + 3, offset_top, md, ims, eptrb, 0);
      if (tmp___9) {
        goto _L___3;
      } else {
        tmp___10 = match(eptr, prev, offset_top, md, ims, eptrb, 2);
        if (tmp___10) {
          _L___3: 
          return (1);
        }
      }
    } else {
      tmp___11 = match(eptr, prev, offset_top, md, ims, eptrb, 2);
      if (tmp___11) {
        goto _L___4;
      } else {
        tmp___12 = match(eptr, ecode + 3, offset_top, md, ims, eptrb, 0);
        if (tmp___12) {
          _L___4: 
          return (1);
        }
      }
    }
    return (0);
    case 56: ;
    while (1) {
      ecode += ((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode + 2));
      if (! ((int const   )(*ecode) == 56)) {
        break;
      }
    }
    break;
    case 68: 
    next = ecode + 1;
    tmp___13 = match(eptr, next, offset_top, md, ims, eptrb, 2);
    if (tmp___13) {
      return (1);
    }
    while (1) {
      next += ((int const   )(*(next + 1)) << 8) + (int const   )(*(next + 2));
      if (! ((int const   )(*next) == 56)) {
        break;
      }
    }
    ecode = next + 3;
    break;
    case 69: 
    next___0 = ecode + 1;
    while (1) {
      next___0 += ((int const   )(*(next___0 + 1)) << 8) + (int const   )(*(next___0 +
                                                                            2));
      if (! ((int const   )(*next___0) == 56)) {
        break;
      }
    }
    tmp___14 = match(eptr, next___0 + 3, offset_top, md, ims, eptrb, 2);
    if (tmp___14) {
      return (1);
    }
    ecode ++;
    break;
    case 57: ;
    case 59: ;
    case 58: 
    prev___0 = (ecode - ((int const   )(*(ecode + 1)) << 8)) - (int const   )(*(ecode +
                                                                                2));
    saved_eptr___0 = eptrb->saved_eptr;
    eptrb = eptrb->prev;
    if ((int const   )(*prev___0) == 60) {
      goto _L___8;
    } else {
      if ((int const   )(*prev___0) == 61) {
        _L___8: 
        goto _L___7;
      } else {
        if ((int const   )(*prev___0) == 62) {
          _L___7: 
          goto _L___6;
        } else {
          if ((int const   )(*prev___0) == 63) {
            _L___6: 
            goto _L___5;
          } else {
            if ((int const   )(*prev___0) == 65) {
              _L___5: 
              md->end_match_ptr = eptr;
              md->end_offset_top = offset_top;
              return (1);
            }
          }
        }
      }
    }
    if ((int const   )(*prev___0) != 66) {
      number___0 = (int )((int const   )(*prev___0) - 71);
      if (number___0 > 150) {
        number___0 = (int )(((int const   )(*(prev___0 + 4)) << 8) | (int const   )(*(prev___0 +
                                                                                      5)));
      }
      offset___1 = number___0 << 1;
      if (number___0 > 0) {
        if (offset___1 >= md->offset_max) {
          md->offset_overflow = 1;
        } else {
          (*(md->offset_vector + offset___1)) = (*(md->offset_vector + (md->offset_end -
                                                                        number___0)));
          (*(md->offset_vector + (offset___1 + 1))) = eptr - md->start_subject;
          if (offset_top <= offset___1) {
            offset_top = offset___1 + 2;
          }
        }
      }
    }
    ims = original_ims;
    if ((int const   )(*ecode) == 57) {
      goto _L___9;
    } else {
      if ((unsigned int )eptr == (unsigned int )saved_eptr___0) {
        _L___9: 
        ecode += 3;
        break;
      }
    }
    if ((int const   )(*ecode) == 59) {
      tmp___15 = match(eptr, ecode + 3, offset_top, md, ims, eptrb, 0);
      if (tmp___15) {
        goto _L___10;
      } else {
        tmp___16 = match(eptr, prev___0, offset_top, md, ims, eptrb, 2);
        if (tmp___16) {
          _L___10: 
          return (1);
        }
      }
    } else {
      tmp___17 = match(eptr, prev___0, offset_top, md, ims, eptrb, 2);
      if (tmp___17) {
        goto _L___11;
      } else {
        tmp___18 = match(eptr, ecode + 3, offset_top, md, ims, eptrb, 0);
        if (tmp___18) {
          _L___11: 
          return (1);
        }
      }
    }
    return (0);
    case 13: ;
    if (md->notbol) {
      if ((unsigned int )eptr == (unsigned int )md->start_subject) {
        return (0);
      } else {
        goto _L___12;
      }
    } else {
      _L___12: ;
    }
    if ((ims & 2UL) != 0UL) {
      if ((unsigned int )eptr != (unsigned int )md->start_subject) {
        if ((int const   )(*(eptr + -1)) != 10) {
          return (0);
        } else {
          goto _L___13;
        }
      } else {
        _L___13: ;
      }
      ecode ++;
      break;
    }
    case 1: ;
    if ((unsigned int )eptr != (unsigned int )md->start_subject) {
      return (0);
    }
    ecode ++;
    break;
    case 14: ;
    if ((ims & 2UL) != 0UL) {
      if ((unsigned int )eptr < (unsigned int )md->end_subject) {
        if ((int const   )(*eptr) != 10) {
          return (0);
        }
      } else {
        if (md->noteol) {
          return (0);
        }
      }
      ecode ++;
      break;
    } else {
      if (md->noteol) {
        return (0);
      }
      if (! md->endonly) {
        if ((unsigned int )eptr < (unsigned int )(md->end_subject - 1)) {
          goto _L___14;
        } else {
          if ((unsigned int )eptr == (unsigned int )(md->end_subject - 1)) {
            if ((int const   )(*eptr) != 10) {
              _L___14: 
              return (0);
            } else {
              goto _L___15;
            }
          } else {
            _L___15: ;
          }
        }
        ecode ++;
        break;
      }
    }
    case 11: ;
    if ((unsigned int )eptr < (unsigned int )md->end_subject) {
      return (0);
    }
    ecode ++;
    break;
    case 10: ;
    if ((unsigned int )eptr < (unsigned int )(md->end_subject - 1)) {
      goto _L___16;
    } else {
      if ((unsigned int )eptr == (unsigned int )(md->end_subject - 1)) {
        if ((int const   )(*eptr) != 10) {
          _L___16: 
          return (0);
        } else {
          goto _L___17;
        }
      } else {
        _L___17: ;
      }
    }
    ecode ++;
    break;
    case 2: ;
    case 3: ;
    if ((unsigned int )eptr != (unsigned int )md->start_subject) {
      if (((int const   )(*(md->ctypes + (int const   )(*(eptr + -1)))) & 16) != 0) {
        tmp___19 = 1;
      } else {
        goto _L___18;
      }
    } else {
      _L___18: 
      tmp___19 = 0;
    }
    prev_is_word = tmp___19;
    if ((unsigned int )eptr < (unsigned int )md->end_subject) {
      if (((int const   )(*(md->ctypes + (int const   )(*eptr))) & 16) != 0) {
        tmp___20 = 1;
      } else {
        goto _L___19;
      }
    } else {
      _L___19: 
      tmp___20 = 0;
    }
    cur_is_word = tmp___20;
    tmp___23 = ecode;
    ecode ++;
    if ((int const   )(*tmp___23) == 3) {
      tmp___22 = cur_is_word == prev_is_word;
    } else {
      tmp___22 = cur_is_word != prev_is_word;
    }
    if (tmp___22) {
      return (0);
    }
    break;
    case 15: ;
    if ((ims & 4UL) == 0UL) {
      if ((unsigned int )eptr < (unsigned int )md->end_subject) {
        if ((int const   )(*eptr) == 10) {
          return (0);
        } else {
          goto _L___21;
        }
      } else {
        goto _L___21;
      }
    } else {
      _L___21: ;
    }
    tmp___24 = eptr;
    eptr ++;
    if ((unsigned int )tmp___24 >= (unsigned int )md->end_subject) {
      return (0);
    }
    ecode ++;
    break;
    case 4: ;
    if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
      goto _L___22;
    } else {
      tmp___25 = eptr;
      eptr ++;
      if (((int const   )(*(md->ctypes + (int const   )(*tmp___25))) & 4) != 0) {
        _L___22: 
        return (0);
      }
    }
    ecode ++;
    break;
    case 5: ;
    if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
      goto _L___23;
    } else {
      tmp___26 = eptr;
      eptr ++;
      if (((int const   )(*(md->ctypes + (int const   )(*tmp___26))) & 4) == 0) {
        _L___23: 
        return (0);
      }
    }
    ecode ++;
    break;
    case 6: ;
    if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
      goto _L___24;
    } else {
      tmp___27 = eptr;
      eptr ++;
      if (((int const   )(*(md->ctypes + (int const   )(*tmp___27))) & 1) != 0) {
        _L___24: 
        return (0);
      }
    }
    ecode ++;
    break;
    case 7: ;
    if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
      goto _L___25;
    } else {
      tmp___28 = eptr;
      eptr ++;
      if (((int const   )(*(md->ctypes + (int const   )(*tmp___28))) & 1) == 0) {
        _L___25: 
        return (0);
      }
    }
    ecode ++;
    break;
    case 8: ;
    if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
      goto _L___26;
    } else {
      tmp___29 = eptr;
      eptr ++;
      if (((int const   )(*(md->ctypes + (int const   )(*tmp___29))) & 16) != 0) {
        _L___26: 
        return (0);
      }
    }
    ecode ++;
    break;
    case 9: ;
    if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
      goto _L___27;
    } else {
      tmp___30 = eptr;
      eptr ++;
      if (((int const   )(*(md->ctypes + (int const   )(*tmp___30))) & 16) == 0) {
        _L___27: 
        return (0);
      }
    }
    ecode ++;
    break;
    case 54: 
    offset___2 = (int )(((int const   )(*(ecode + 1)) << 9) | ((int const   )(*(ecode +
                                                                                2)) <<
                                                               1));
    ecode += 3;
    if (offset___2 >= offset_top) {
      goto _L___28;
    } else {
      if ((*(md->offset_vector + offset___2)) < 0) {
        _L___28: 
        length = (md->end_subject - eptr) + 1;
      } else {
        length = (*(md->offset_vector + (offset___2 + 1))) - (*(md->offset_vector +
                                                                offset___2));
      }
    }
    switch ((int )(*ecode)) {
    case 45: ;
    case 46: ;
    case 47: ;
    case 48: ;
    case 49: ;
    case 50: 
    tmp___31 = ecode;
    ecode ++;
    c = (int )((int const   )(*tmp___31) - 45);
    minimize = (c & 1) != 0;
    min = (int )rep_min[c];
    max = (int )rep_max[c];
    if (max == 0) {
      max = 2147483647;
    }
    break;
    case 51: ;
    case 52: 
    minimize = (int const   )(*ecode) == 52;
    min = (int )(((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode + 2)));
    max = (int )(((int const   )(*(ecode + 3)) << 8) + (int const   )(*(ecode + 4)));
    if (max == 0) {
      max = 2147483647;
    }
    ecode += 5;
    break;
    default: 
    tmp___32 = match_ref(offset___2, eptr, length, md, ims);
    if (! tmp___32) {
      return (0);
    }
    eptr += length;
    goto __Cont;
    }
    if (length == 0) {
      goto __Cont;
    }
    i = 1;
    while (i <= min) {
      tmp___33 = match_ref(offset___2, eptr, length, md, ims);
      if (! tmp___33) {
        return (0);
      }
      eptr += length;
      i ++;
    }
    if (min == max) {
      goto __Cont;
    }
    if (minimize) {
      i = min;
      while (1) {
        tmp___34 = match(eptr, ecode, offset_top, md, ims, eptrb, 0);
        if (tmp___34) {
          return (1);
        }
        if (i >= max) {
          goto _L___29;
        } else {
          tmp___35 = match_ref(offset___2, eptr, length, md, ims);
          if (! tmp___35) {
            _L___29: 
            return (0);
          }
        }
        eptr += length;
        i ++;
      }
    } else {
      pp = eptr;
      i = min;
      while (i < max) {
        tmp___36 = match_ref(offset___2, eptr, length, md, ims);
        if (! tmp___36) {
          break;
        }
        eptr += length;
        i ++;
      }
      while ((unsigned int )eptr >= (unsigned int )pp) {
        tmp___37 = match(eptr, ecode, offset_top, md, ims, eptrb, 0);
        if (tmp___37) {
          return (1);
        }
        eptr -= length;
      }
      return (0);
    }
    case 53: 
    data = ecode + 1;
    ecode += 33;
    switch ((int )(*ecode)) {
    case 45: ;
    case 46: ;
    case 47: ;
    case 48: ;
    case 49: ;
    case 50: 
    tmp___38 = ecode;
    ecode ++;
    c = (int )((int const   )(*tmp___38) - 45);
    minimize = (c & 1) != 0;
    min = (int )rep_min[c];
    max = (int )rep_max[c];
    if (max == 0) {
      max = 2147483647;
    }
    break;
    case 51: ;
    case 52: 
    minimize = (int const   )(*ecode) == 52;
    min = (int )(((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode + 2)));
    max = (int )(((int const   )(*(ecode + 3)) << 8) + (int const   )(*(ecode + 4)));
    if (max == 0) {
      max = 2147483647;
    }
    ecode += 5;
    break;
    default: 
    max = 1;
    min = max;
    break;
    }
    i = 1;
    while (i <= min) {
      if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
        return (0);
      }
      tmp___39 = eptr;
      eptr ++;
      c = (int )(*tmp___39);
      if (((int const   )(*(data + c / 8)) & (int const   )(1 << (c & 7))) != 0) {
        goto __Cont___0;
      }
      return (0);
      __Cont___0: 
      i ++;
    }
    if (min == max) {
      goto __Cont;
    }
    if (minimize) {
      i = min;
      while (1) {
        tmp___40 = match(eptr, ecode, offset_top, md, ims, eptrb, 0);
        if (tmp___40) {
          return (1);
        }
        if (i >= max) {
          goto _L___30;
        } else {
          if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
            _L___30: 
            return (0);
          }
        }
        tmp___41 = eptr;
        eptr ++;
        c = (int )(*tmp___41);
        if (((int const   )(*(data + c / 8)) & (int const   )(1 << (c & 7))) != 0) {
          goto __Cont___1;
        }
        return (0);
        __Cont___1: 
        i ++;
      }
    } else {
      pp___0 = eptr;
      len = 1;
      i = min;
      while (i < max) {
        if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
          break;
        }
        c = (int )(*eptr);
        if (((int const   )(*(data + c / 8)) & (int const   )(1 << (c & 7))) == 0) {
          break;
        }
        eptr += len;
        i ++;
      }
      while ((unsigned int )eptr >= (unsigned int )pp___0) {
        tmp___42 = eptr;
        eptr --;
        tmp___43 = match(tmp___42, ecode, offset_top, md, ims, eptrb, 0);
        if (tmp___43) {
          return (1);
        }
      }
      return (0);
    }
    case 16: 
    length___0 = (int )(*(ecode + 1));
    ecode += 2;
    if (length___0 > md->end_subject - eptr) {
      return (0);
    }
    if ((ims & 1UL) != 0UL) {
      while (1) {
        tmp___46 = length___0;
        length___0 --;
        if (! (tmp___46 > 0)) {
          break;
        }
        tmp___44 = ecode;
        ecode ++;
        tmp___45 = eptr;
        eptr ++;
        if ((int const   )(*(md->lcc + (int const   )(*tmp___44))) != (int const   )(*(md->lcc +
                                                                                       (int const   )(*tmp___45)))) {
          return (0);
        }
      }
    } else {
      while (1) {
        tmp___49 = length___0;
        length___0 --;
        if (! (tmp___49 > 0)) {
          break;
        }
        tmp___47 = ecode;
        ecode ++;
        tmp___48 = eptr;
        eptr ++;
        if ((int const   )(*tmp___47) != (int const   )(*tmp___48)) {
          return (0);
        }
      }
    }
    break;
    case 26: 
    max = (int )(((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode + 2)));
    min = max;
    ecode += 3;
    goto REPEATCHAR;
    case 24: ;
    case 25: 
    min = 0;
    max = (int )(((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode + 2)));
    minimize = (int const   )(*ecode) == 25;
    ecode += 3;
    goto REPEATCHAR;
    case 18: ;
    case 19: ;
    case 20: ;
    case 21: ;
    case 22: ;
    case 23: 
    tmp___50 = ecode;
    ecode ++;
    c = (int )((int const   )(*tmp___50) - 18);
    minimize = (c & 1) != 0;
    min = (int )rep_min[c];
    max = (int )rep_max[c];
    if (max == 0) {
      max = 2147483647;
    }
    REPEATCHAR: 
    if (min > md->end_subject - eptr) {
      return (0);
    }
    tmp___51 = ecode;
    ecode ++;
    c = (int )(*tmp___51);
    if ((ims & 1UL) != 0UL) {
      c = (int )(*(md->lcc + c));
      i = 1;
      while (i <= min) {
        tmp___52 = eptr;
        eptr ++;
        if (c != (int )(*(md->lcc + (int const   )(*tmp___52)))) {
          return (0);
        }
        i ++;
      }
      if (min == max) {
        goto __Cont;
      }
      if (minimize) {
        i = min;
        while (1) {
          tmp___53 = match(eptr, ecode, offset_top, md, ims, eptrb, 0);
          if (tmp___53) {
            return (1);
          }
          if (i >= max) {
            goto _L___32;
          } else {
            if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
              _L___32: 
              goto _L___31;
            } else {
              tmp___54 = eptr;
              eptr ++;
              if (c != (int )(*(md->lcc + (int const   )(*tmp___54)))) {
                _L___31: 
                return (0);
              }
            }
          }
          i ++;
        }
      } else {
        pp___1 = eptr;
        i = min;
        while (i < max) {
          if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
            goto _L___33;
          } else {
            if (c != (int )(*(md->lcc + (int const   )(*eptr)))) {
              _L___33: 
              break;
            }
          }
          eptr ++;
          i ++;
        }
        while ((unsigned int )eptr >= (unsigned int )pp___1) {
          tmp___55 = eptr;
          eptr --;
          tmp___56 = match(tmp___55, ecode, offset_top, md, ims, eptrb, 0);
          if (tmp___56) {
            return (1);
          }
        }
        return (0);
      }
    } else {
      i = 1;
      while (i <= min) {
        tmp___57 = eptr;
        eptr ++;
        if (c != (int )(*tmp___57)) {
          return (0);
        }
        i ++;
      }
      if (min == max) {
        goto __Cont;
      }
      if (minimize) {
        i = min;
        while (1) {
          tmp___58 = match(eptr, ecode, offset_top, md, ims, eptrb, 0);
          if (tmp___58) {
            return (1);
          }
          if (i >= max) {
            goto _L___35;
          } else {
            if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
              _L___35: 
              goto _L___34;
            } else {
              tmp___59 = eptr;
              eptr ++;
              if (c != (int )(*tmp___59)) {
                _L___34: 
                return (0);
              }
            }
          }
          i ++;
        }
      } else {
        pp___2 = eptr;
        i = min;
        while (i < max) {
          if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
            goto _L___36;
          } else {
            if (c != (int )(*eptr)) {
              _L___36: 
              break;
            }
          }
          eptr ++;
          i ++;
        }
        while ((unsigned int )eptr >= (unsigned int )pp___2) {
          tmp___60 = eptr;
          eptr --;
          tmp___61 = match(tmp___60, ecode, offset_top, md, ims, eptrb, 0);
          if (tmp___61) {
            return (1);
          }
        }
        return (0);
      }
    }
    case 17: ;
    if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
      return (0);
    }
    ecode ++;
    if ((ims & 1UL) != 0UL) {
      tmp___62 = ecode;
      ecode ++;
      tmp___63 = eptr;
      eptr ++;
      if ((int const   )(*(md->lcc + (int const   )(*tmp___62))) == (int const   )(*(md->lcc +
                                                                                     (int const   )(*tmp___63)))) {
        return (0);
      }
    } else {
      tmp___64 = ecode;
      ecode ++;
      tmp___65 = eptr;
      eptr ++;
      if ((int const   )(*tmp___64) == (int const   )(*tmp___65)) {
        return (0);
      }
    }
    break;
    case 35: 
    max = (int )(((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode + 2)));
    min = max;
    ecode += 3;
    goto REPEATNOTCHAR;
    case 33: ;
    case 34: 
    min = 0;
    max = (int )(((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode + 2)));
    minimize = (int const   )(*ecode) == 34;
    ecode += 3;
    goto REPEATNOTCHAR;
    case 27: ;
    case 28: ;
    case 29: ;
    case 30: ;
    case 31: ;
    case 32: 
    tmp___66 = ecode;
    ecode ++;
    c = (int )((int const   )(*tmp___66) - 27);
    minimize = (c & 1) != 0;
    min = (int )rep_min[c];
    max = (int )rep_max[c];
    if (max == 0) {
      max = 2147483647;
    }
    REPEATNOTCHAR: 
    if (min > md->end_subject - eptr) {
      return (0);
    }
    tmp___67 = ecode;
    ecode ++;
    c = (int )(*tmp___67);
    if ((ims & 1UL) != 0UL) {
      c = (int )(*(md->lcc + c));
      i = 1;
      while (i <= min) {
        tmp___68 = eptr;
        eptr ++;
        if (c == (int )(*(md->lcc + (int const   )(*tmp___68)))) {
          return (0);
        }
        i ++;
      }
      if (min == max) {
        goto __Cont;
      }
      if (minimize) {
        i = min;
        while (1) {
          tmp___69 = match(eptr, ecode, offset_top, md, ims, eptrb, 0);
          if (tmp___69) {
            return (1);
          }
          if (i >= max) {
            goto _L___38;
          } else {
            if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
              _L___38: 
              goto _L___37;
            } else {
              tmp___70 = eptr;
              eptr ++;
              if (c == (int )(*(md->lcc + (int const   )(*tmp___70)))) {
                _L___37: 
                return (0);
              }
            }
          }
          i ++;
        }
      } else {
        pp___3 = eptr;
        i = min;
        while (i < max) {
          if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
            goto _L___39;
          } else {
            if (c == (int )(*(md->lcc + (int const   )(*eptr)))) {
              _L___39: 
              break;
            }
          }
          eptr ++;
          i ++;
        }
        while ((unsigned int )eptr >= (unsigned int )pp___3) {
          tmp___71 = eptr;
          eptr --;
          tmp___72 = match(tmp___71, ecode, offset_top, md, ims, eptrb, 0);
          if (tmp___72) {
            return (1);
          }
        }
        return (0);
      }
    } else {
      i = 1;
      while (i <= min) {
        tmp___73 = eptr;
        eptr ++;
        if (c == (int )(*tmp___73)) {
          return (0);
        }
        i ++;
      }
      if (min == max) {
        goto __Cont;
      }
      if (minimize) {
        i = min;
        while (1) {
          tmp___74 = match(eptr, ecode, offset_top, md, ims, eptrb, 0);
          if (tmp___74) {
            return (1);
          }
          if (i >= max) {
            goto _L___41;
          } else {
            if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
              _L___41: 
              goto _L___40;
            } else {
              tmp___75 = eptr;
              eptr ++;
              if (c == (int )(*tmp___75)) {
                _L___40: 
                return (0);
              }
            }
          }
          i ++;
        }
      } else {
        pp___4 = eptr;
        i = min;
        while (i < max) {
          if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
            goto _L___42;
          } else {
            if (c == (int )(*eptr)) {
              _L___42: 
              break;
            }
          }
          eptr ++;
          i ++;
        }
        while ((unsigned int )eptr >= (unsigned int )pp___4) {
          tmp___76 = eptr;
          eptr --;
          tmp___77 = match(tmp___76, ecode, offset_top, md, ims, eptrb, 0);
          if (tmp___77) {
            return (1);
          }
        }
        return (0);
      }
    }
    case 44: 
    max = (int )(((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode + 2)));
    min = max;
    minimize = 1;
    ecode += 3;
    goto REPEATTYPE;
    case 42: ;
    case 43: 
    min = 0;
    max = (int )(((int const   )(*(ecode + 1)) << 8) + (int const   )(*(ecode + 2)));
    minimize = (int const   )(*ecode) == 43;
    ecode += 3;
    goto REPEATTYPE;
    case 36: ;
    case 37: ;
    case 38: ;
    case 39: ;
    case 40: ;
    case 41: 
    tmp___78 = ecode;
    ecode ++;
    c = (int )((int const   )(*tmp___78) - 36);
    minimize = (c & 1) != 0;
    min = (int )rep_min[c];
    max = (int )rep_max[c];
    if (max == 0) {
      max = 2147483647;
    }
    REPEATTYPE: 
    tmp___79 = ecode;
    ecode ++;
    ctype = (int )(*tmp___79);
    if (min > md->end_subject - eptr) {
      return (0);
    }
    if (min > 0) {
      switch (ctype) {
      case 15: ;
      if ((ims & 4UL) == 0UL) {
        i = 1;
        while (i <= min) {
          tmp___80 = eptr;
          eptr ++;
          if ((int const   )(*tmp___80) == 10) {
            return (0);
          }
          i ++;
        }
      } else {
        eptr += min;
      }
      break;
      case 4: 
      i = 1;
      while (i <= min) {
        tmp___81 = eptr;
        eptr ++;
        if (((int const   )(*(md->ctypes + (int const   )(*tmp___81))) & 4) != 0) {
          return (0);
        }
        i ++;
      }
      break;
      case 5: 
      i = 1;
      while (i <= min) {
        tmp___82 = eptr;
        eptr ++;
        if (((int const   )(*(md->ctypes + (int const   )(*tmp___82))) & 4) == 0) {
          return (0);
        }
        i ++;
      }
      break;
      case 6: 
      i = 1;
      while (i <= min) {
        tmp___83 = eptr;
        eptr ++;
        if (((int const   )(*(md->ctypes + (int const   )(*tmp___83))) & 1) != 0) {
          return (0);
        }
        i ++;
      }
      break;
      case 7: 
      i = 1;
      while (i <= min) {
        tmp___84 = eptr;
        eptr ++;
        if (((int const   )(*(md->ctypes + (int const   )(*tmp___84))) & 1) == 0) {
          return (0);
        }
        i ++;
      }
      break;
      case 8: 
      i = 1;
      while (i <= min) {
        tmp___85 = eptr;
        eptr ++;
        if (((int const   )(*(md->ctypes + (int const   )(*tmp___85))) & 16) != 0) {
          return (0);
        }
        i ++;
      }
      break;
      case 9: 
      i = 1;
      while (i <= min) {
        tmp___86 = eptr;
        eptr ++;
        if (((int const   )(*(md->ctypes + (int const   )(*tmp___86))) & 16) == 0) {
          return (0);
        }
        i ++;
      }
      break;
      }
    }
    if (min == max) {
      goto __Cont;
    }
    if (minimize) {
      i = min;
      while (1) {
        tmp___87 = match(eptr, ecode, offset_top, md, ims, eptrb, 0);
        if (tmp___87) {
          return (1);
        }
        if (i >= max) {
          goto _L___43;
        } else {
          if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
            _L___43: 
            return (0);
          }
        }
        tmp___88 = eptr;
        eptr ++;
        c = (int )(*tmp___88);
        switch (ctype) {
        case 15: ;
        if ((ims & 4UL) == 0UL) {
          if (c == 10) {
            return (0);
          } else {
            goto _L___44;
          }
        } else {
          _L___44: ;
        }
        break;
        case 4: ;
        if (((int const   )(*(md->ctypes + c)) & 4) != 0) {
          return (0);
        }
        break;
        case 5: ;
        if (((int const   )(*(md->ctypes + c)) & 4) == 0) {
          return (0);
        }
        break;
        case 6: ;
        if (((int const   )(*(md->ctypes + c)) & 1) != 0) {
          return (0);
        }
        break;
        case 7: ;
        if (((int const   )(*(md->ctypes + c)) & 1) == 0) {
          return (0);
        }
        break;
        case 8: ;
        if (((int const   )(*(md->ctypes + c)) & 16) != 0) {
          return (0);
        }
        break;
        case 9: ;
        if (((int const   )(*(md->ctypes + c)) & 16) == 0) {
          return (0);
        }
        break;
        }
        i ++;
      }
    } else {
      pp___5 = eptr;
      switch (ctype) {
      case 15: ;
      if ((ims & 4UL) == 0UL) {
        i = min;
        while (i < max) {
          if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
            goto _L___45;
          } else {
            if ((int const   )(*eptr) == 10) {
              _L___45: 
              break;
            }
          }
          eptr ++;
          i ++;
        }
      } else {
        c = max - min;
        if (c > md->end_subject - eptr) {
          c = md->end_subject - eptr;
        }
        eptr += c;
      }
      break;
      case 4: 
      i = min;
      while (i < max) {
        if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
          goto _L___46;
        } else {
          if (((int const   )(*(md->ctypes + (int const   )(*eptr))) & 4) != 0) {
            _L___46: 
            break;
          }
        }
        eptr ++;
        i ++;
      }
      break;
      case 5: 
      i = min;
      while (i < max) {
        if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
          goto _L___47;
        } else {
          if (((int const   )(*(md->ctypes + (int const   )(*eptr))) & 4) == 0) {
            _L___47: 
            break;
          }
        }
        eptr ++;
        i ++;
      }
      break;
      case 6: 
      i = min;
      while (i < max) {
        if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
          goto _L___48;
        } else {
          if (((int const   )(*(md->ctypes + (int const   )(*eptr))) & 1) != 0) {
            _L___48: 
            break;
          }
        }
        eptr ++;
        i ++;
      }
      break;
      case 7: 
      i = min;
      while (i < max) {
        if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
          goto _L___49;
        } else {
          if (((int const   )(*(md->ctypes + (int const   )(*eptr))) & 1) == 0) {
            _L___49: 
            break;
          }
        }
        eptr ++;
        i ++;
      }
      break;
      case 8: 
      i = min;
      while (i < max) {
        if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
          goto _L___50;
        } else {
          if (((int const   )(*(md->ctypes + (int const   )(*eptr))) & 16) != 0) {
            _L___50: 
            break;
          }
        }
        eptr ++;
        i ++;
      }
      break;
      case 9: 
      i = min;
      while (i < max) {
        if ((unsigned int )eptr >= (unsigned int )md->end_subject) {
          goto _L___51;
        } else {
          if (((int const   )(*(md->ctypes + (int const   )(*eptr))) & 16) == 0) {
            _L___51: 
            break;
          }
        }
        eptr ++;
        i ++;
      }
      break;
      }
      while ((unsigned int )eptr >= (unsigned int )pp___5) {
        tmp___89 = eptr;
        eptr --;
        tmp___90 = match(tmp___89, ecode, offset_top, md, ims, eptrb, 0);
        if (tmp___90) {
          return (1);
        }
      }
      return (0);
    }
    default: 
    md->errorcode = -5;
    return (0);
    }
    __Cont: ;
  }
  return (0);
}
}
int pcre_exec(pcre const   *external_re , pcre_extra const   *external_extra , char const   *subject ,
              int length , int start_offset , int options , int *offsets , int offsetcount ) 
{ int resetcount ;
  int ocount ;
  int first_char ;
  int req_char ;
  int req_char2 ;
  unsigned long ims ;
  match_data match_block ;
  uschar const   *start_bits ;
  uschar const   *start_match ;
  uschar const   *end_subject ;
  uschar const   *req_char_ptr ;
  real_pcre const   *re ;
  real_pcre_extra const   *extra ;
  BOOL using_temporary_offsets ;
  BOOL anchored ;
  BOOL startline ;
  register int *iptr ;
  register int *iend ;
  int rc ;
  register int *iptr___0 ;
  register int *iend___0 ;
  int *tmp___0 ;
  register int c ;
  register uschar const   *p ;
  int tmp___1 ;
  uschar const   *tmp___2 ;
  register int pp ;
  uschar const   *tmp___3 ;
  BOOL tmp___4 ;
  uschar const   *tmp___5 ;

  {
  first_char = -1;
  req_char = -1;
  req_char2 = -1;
  ims = 0UL;
  start_bits = (uschar const   *)((void *)0);
  start_match = (uschar const   *)subject + start_offset;
  req_char_ptr = start_match - 1;
  re = external_re;
  extra = external_extra;
  using_temporary_offsets = 0;
  if ((options & -1425) != 0) {
    return (-3);
  }
  if ((unsigned int )re == (unsigned int )((void *)0)) {
    goto _L___1;
  } else {
    if ((unsigned int )subject == (unsigned int )((void *)0)) {
      _L___1: 
      goto _L;
    } else {
      if ((unsigned int )offsets == (unsigned int )((void *)0)) {
        if (offsetcount > 0) {
          _L: 
          return (-2);
        } else {
          goto _L___0;
        }
      } else {
        _L___0: ;
      }
    }
  }
  if (re->magic_number != 1346589253UL) {
    return (-4);
  }
  anchored = ((re->options | (unsigned long )options) & 16UL) != 0UL;
  startline = (re->options & 268435456UL) != 0UL;
  match_block.start_pattern = (uschar const   *)(re->code);
  match_block.start_subject = (uschar const   *)subject;
  match_block.end_subject = match_block.start_subject + length;
  end_subject = match_block.end_subject;
  match_block.endonly = (re->options & 32UL) != 0UL;
  match_block.utf8 = (re->options & 2048UL) != 0UL;
  match_block.notbol = (options & 128) != 0;
  match_block.noteol = (options & 256) != 0;
  match_block.notempty = (options & 1024) != 0;
  match_block.errorcode = -1;
  match_block.lcc = re->tables + 0;
  match_block.ctypes = re->tables + 832;
  ims = re->options & 7UL;
  ocount = offsetcount - offsetcount % 3;
  if ((int )re->top_backref > 0) {
    if ((int )re->top_backref >= ocount / 3) {
      ocount = (int )re->top_backref * 3 + 3;
      match_block.offset_vector = (int *)((*pcre_malloc))((unsigned int )ocount *
                                                          sizeof(int ));
      if ((unsigned int )match_block.offset_vector == (unsigned int )((void *)0)) {
        return (-6);
      }
      using_temporary_offsets = 1;
    } else {
      goto _L___2;
    }
  } else {
    _L___2: 
    match_block.offset_vector = offsets;
  }
  match_block.offset_end = ocount;
  match_block.offset_max = (2 * ocount) / 3;
  match_block.offset_overflow = 0;
  resetcount = 2 + (int )re->top_bracket * 2;
  if (resetcount > offsetcount) {
    resetcount = ocount;
  }
  if ((unsigned int )match_block.offset_vector != (unsigned int )((void *)0)) {
    iptr = match_block.offset_vector + ocount;
    iend = (iptr - resetcount / 2) + 1;
    while (1) {
      iptr --;
      if (! ((unsigned int )iptr >= (unsigned int )iend)) {
        break;
      }
      (*iptr) = -1;
    }
  }
  if (! anchored) {
    if ((re->options & 1073741824UL) != 0UL) {
      first_char = (int )re->first_char;
      if ((ims & 1UL) != 0UL) {
        first_char = (int )(*(match_block.lcc + first_char));
      }
    } else {
      if (! startline) {
        if ((unsigned int )extra != (unsigned int )((void *)0)) {
          if (((int )extra->options & 1) != 0) {
            start_bits = (uschar const   *)(extra->start_bits);
          } else {
            goto _L___4;
          }
        } else {
          goto _L___4;
        }
      } else {
        _L___4: ;
      }
    }
  }
  if ((re->options & 536870912UL) != 0UL) {
    req_char = (int )re->req_char;
    if ((re->options & 67108865UL) != 0UL) {
      req_char2 = (int )(*((re->tables + 256) + req_char));
    } else {
      req_char2 = req_char;
    }
  }
  while (1) {
    iptr___0 = match_block.offset_vector;
    iend___0 = iptr___0 + resetcount;
    while ((unsigned int )iptr___0 < (unsigned int )iend___0) {
      tmp___0 = iptr___0;
      iptr___0 ++;
      (*tmp___0) = -1;
    }
    if (first_char >= 0) {
      if ((ims & 1UL) != 0UL) {
        while (1) {
          if ((unsigned int )start_match < (unsigned int )end_subject) {
            if (! ((int const   )(*(match_block.lcc + (int const   )(*start_match))) !=
                   (int const   )first_char)) {
              goto _L___5;
            }
          } else {
            _L___5: 
            break;
          }
          start_match ++;
        }
      } else {
        while (1) {
          if ((unsigned int )start_match < (unsigned int )end_subject) {
            if (! ((int const   )(*start_match) != (int const   )first_char)) {
              goto _L___6;
            }
          } else {
            _L___6: 
            break;
          }
          start_match ++;
        }
      }
    } else {
      if (startline) {
        if ((unsigned int )start_match > (unsigned int )(match_block.start_subject +
                                                         start_offset)) {
          while (1) {
            if ((unsigned int )start_match < (unsigned int )end_subject) {
              if (! ((int const   )(*(start_match + -1)) != 10)) {
                goto _L___7;
              }
            } else {
              _L___7: 
              break;
            }
            start_match ++;
          }
        }
      } else {
        if ((unsigned int )start_bits != (unsigned int )((void *)0)) {
          while ((unsigned int )start_match < (unsigned int )end_subject) {
            c = (int )(*start_match);
            if (((int const   )(*(start_bits + c / 8)) & (int const   )(1 << (c &
                                                                              7))) ==
                0) {
              start_match ++;
            } else {
              break;
            }
          }
        }
      }
    }
    if (req_char >= 0) {
      if (first_char >= 0) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
      p = start_match + tmp___1;
      if ((unsigned int )p > (unsigned int )req_char_ptr) {
        if (req_char == req_char2) {
          while ((unsigned int )p < (unsigned int )end_subject) {
            tmp___2 = p;
            p ++;
            if ((int const   )(*tmp___2) == (int const   )req_char) {
              p --;
              break;
            }
          }
        } else {
          while ((unsigned int )p < (unsigned int )end_subject) {
            tmp___3 = p;
            p ++;
            pp = (int )(*tmp___3);
            if (pp == req_char) {
              goto _L___8;
            } else {
              if (pp == req_char2) {
                _L___8: 
                p --;
                break;
              }
            }
          }
        }
        if ((unsigned int )p >= (unsigned int )end_subject) {
          break;
        }
        req_char_ptr = p;
      }
    }
    match_block.start_match = start_match;
    tmp___4 = match(start_match, (uschar const   *)(re->code), 2, & match_block, ims,
                    (eptrblock *)((void *)0), 2);
    if (! tmp___4) {
      goto __Cont;
    }
    if (using_temporary_offsets) {
      if (offsetcount >= 4) {
        memcpy((void * __restrict  )(offsets + 2), (void const   * __restrict  )(match_block.offset_vector +
                                                                                 2),
               (unsigned int )(offsetcount - 2) * sizeof(int ));
      }
      if (match_block.end_offset_top > offsetcount) {
        match_block.offset_overflow = 1;
      }
      ((*pcre_free))((void *)match_block.offset_vector);
    }
    if (match_block.offset_overflow) {
      rc = 0;
    } else {
      rc = match_block.end_offset_top / 2;
    }
    if (offsetcount < 2) {
      rc = 0;
    } else {
      (*(offsets + 0)) = start_match - match_block.start_subject;
      (*(offsets + 1)) = match_block.end_match_ptr - match_block.start_subject;
    }
    return (rc);
    __Cont: 
    if (! anchored) {
      if (match_block.errorcode == -1) {
        tmp___5 = start_match;
        start_match ++;
        if (! ((unsigned int )tmp___5 < (unsigned int )end_subject)) {
          goto _L___10;
        }
      } else {
        goto _L___10;
      }
    } else {
      _L___10: 
      break;
    }
  }
  if (using_temporary_offsets) {
    ((*pcre_free))((void *)match_block.offset_vector);
  }
  return (match_block.errorcode);
}
}
#pragma merger(0,"/tmp/cil-Fy5dGsqx.i","-g -pthread")
extern int sprintf(char * __restrict  __s , char const   * __restrict  __format  , ...) ;
static char const   *estring[31]  = 
  {      "\\ at end of pattern",      "\\c at end of pattern",      "unrecognized character follows \\",      "numbers out of order in {} quantifier", 
        "number too big in {} quantifier",      "missing terminating ] for character class",      "invalid escape sequence in character class",      "range out of order in character class", 
        "nothing to repeat",      "operand of unlimited repeat could match the empty string",      "internal error: unexpected repeat",      "unrecognized character after (?", 
        "unused error",      "missing )",      "back reference to non-existent subpattern",      "erroffset passed as NULL", 
        "unknown option bit(s) set",      "missing ) after comment",      "parentheses nested too deeply",      "regular expression too large", 
        "failed to get memory",      "unmatched parentheses",      "internal error: code overflow",      "unrecognized character after (?<", 
        "lookbehind assertion is not fixed length",      "malformed number after (?(",      "conditional group contains more than two branches",      "(?p must be followed by )", 
        "(?p must be followed by )",      "unknown POSIX class name",      "POSIX collating elements are not supported"};
static int eint[35]  = 
  {      9,      9,      9,      2, 
        2,      6,      8,      12, 
        4,      4,      1,      3, 
        1,      11,      15,      16, 
        16,      11,      13,      13, 
        14,      11,      1,      3, 
        3,      3,      3,      3, 
        3,      8,      3,      16, 
        3,      3,      3};
static char const   *pstring[18]  = 
  {      "",      "internal error",      "invalid repeat counts in {}",      "pattern error", 
        "? * + invalid",      "unbalanced {}",      "unbalanced []",      "collation error - not relevant", 
        "bad class",      "bad escape sequence",      "empty expression",      "unbalanced ()", 
        "bad range inside []",      "expression too big",      "failed to get memory",      "bad back reference", 
        "bad argument",      "match failed"};
static int pcre_posix_error_code(char const   *s ) 
{ size_t i ;
  int tmp ;

  {
  i = 0U;
  while (i < sizeof(estring) / sizeof(char *)) {
    tmp = strcmp(s, estring[i]);
    if (tmp == 0) {
      return (eint[i]);
    }
    i ++;
  }
  return (1);
}
}
size_t regerror(int errcode , regex_t const   *preg , char *errbuf , size_t errbuf_size ) 
{ char const   *message ;
  char const   *addmessage ;
  size_t length ;
  size_t addlength ;
  size_t tmp ;
  size_t tmp___1 ;

  {
  if (errcode >= (int )(sizeof(pstring) / sizeof(char *))) {
    message = "unknown error code";
  } else {
    message = pstring[errcode];
  }
  tmp = strlen(message);
  length = tmp + 1U;
  addmessage = " at offset ";
  if ((unsigned int )preg != (unsigned int )((void *)0)) {
    if ((int )preg->re_erroffset != -1) {
      tmp___1 = strlen(addmessage);
      addlength = tmp___1 + 6U;
    } else {
      goto _L;
    }
  } else {
    _L: 
    addlength = 0U;
  }
  if (errbuf_size > 0U) {
    if (addlength > 0U) {
      if (errbuf_size >= length + addlength) {
        sprintf((char * __restrict  )errbuf, (char const   * __restrict  )"%s%s%-6d",
                message, addmessage, (int )preg->re_erroffset);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      strncpy((char * __restrict  )errbuf, (char const   * __restrict  )message, errbuf_size -
                                                                                 1U);
      (*(errbuf + (errbuf_size - 1U))) = (char)0;
    }
  }
  return (length + addlength);
}
}
void regfree(regex_t *preg ) 
{ 

  {
  ((*pcre_free))(preg->re_pcre);
  return;
}
}
int regcomp(regex_t *preg , char const   *pattern , int cflags ) 
{ char const   *errorptr ;
  int erroffset ;
  int options ;
  int tmp ;

  {
  options = 0;
  if ((cflags & 1) != 0) {
    options |= 1;
  }
  if ((cflags & 2) != 0) {
    options |= 2;
  }
  preg->re_pcre = (void *)pcre_compile(pattern, options, & errorptr, & erroffset,
                                       (unsigned char const   *)((void *)0));
  preg->re_erroffset = (unsigned int )erroffset;
  if ((unsigned int )preg->re_pcre == (unsigned int )((void *)0)) {
    tmp = pcre_posix_error_code(errorptr);
    return (tmp);
  }
  preg->re_nsub = (size_t )pcre_info((pcre const   *)preg->re_pcre, (int *)((void *)0),
                                     (int *)((void *)0));
  return (0);
}
}
int regexec(regex_t *preg , char const   *string , size_t nmatch , regmatch_t *pmatch ,
            int eflags ) 
{ int rc ;
  int options ;
  int small_ovector[15] ;
  int *ovector ;
  int allocated_ovector ;
  int tmp___0 ;
  size_t i ;

  {
  options = 0;
  ovector = (int *)((void *)0);
  allocated_ovector = 0;
  if ((eflags & 4) != 0) {
    options |= 128;
  }
  if ((eflags & 8) != 0) {
    options |= 256;
  }
  if (nmatch > 0U) {
    if (nmatch <= 5U) {
      ovector = small_ovector;
    } else {
      ovector = (int *)malloc((sizeof(int ) * nmatch) * 3U);
      if ((unsigned int )ovector == (unsigned int )((void *)0)) {
        return (14);
      }
      allocated_ovector = 1;
    }
  }
  tmp___0 = (int )strlen(string);
  rc = pcre_exec((pcre const   *)preg->re_pcre, (pcre_extra const   *)((void *)0),
                 string, tmp___0, 0, options, ovector, (int )(nmatch * 3U));
  if (rc == 0) {
    rc = (int )nmatch;
  }
  if (rc >= 0) {
    i = 0U;
    while (i < (unsigned int )rc) {
      (pmatch + i)->rm_so = (*(ovector + i * 2U));
      (pmatch + i)->rm_eo = (*(ovector + (i * 2U + 1U)));
      i ++;
    }
    if (allocated_ovector) {
      free((void *)ovector);
    }
    while (i < nmatch) {
      (pmatch + i)->rm_eo = -1;
      (pmatch + i)->rm_so = (pmatch + i)->rm_eo;
      i ++;
    }
    return (0);
  } else {
    if (allocated_ovector) {
      free((void *)ovector);
    }
    switch (rc) {
    case -1: ;
    return (17);
    case -2: ;
    return (16);
    case -3: ;
    return (16);
    case -4: ;
    return (16);
    case -5: ;
    return (1);
    case -6: ;
    return (14);
    default: ;
    return (1);
    }
  }
}
}
#pragma merger(0,"/tmp/cil-kMJ2c8rt.i","-g -pthread")
static void file_bucket_destroy(void *data ) 
{ apr_bucket_file *f ;
  int tmp ;

  {
  f = (apr_bucket_file *)data;
  tmp = apr_bucket_shared_destroy((void *)f);
  if (tmp) {
    apr_bucket_free((void *)f);
  }
  return;
}
}
static int file_make_mmap(apr_bucket *e , apr_size_t filelength , apr_off_t fileoffset ,
                          apr_pool_t *p ) 
{ apr_bucket_file *a ;
  apr_mmap_t *mm ;
  apr_status_t tmp ;
  apr_status_t tmp___0 ;

  {
  a = (apr_bucket_file *)e->data;
  if (! a->can_mmap) {
    return (0);
  }
  if (filelength > 4194304U) {
    tmp = apr_mmap_create(& mm, a->fd, fileoffset, 4194304U, 1, p);
    if (tmp != 0) {
      return (0);
    }
    ((*((e->type)->split)))(e, 4194304U);
    filelength = 4194304U;
  } else {
    if (filelength < 1U) {
      goto _L;
    } else {
      tmp___0 = apr_mmap_create(& mm, a->fd, fileoffset, filelength, 1, p);
      if (tmp___0 != 0) {
        _L: 
        return (0);
      }
    }
  }
  apr_bucket_mmap_make(e, mm, 0L, filelength);
  file_bucket_destroy((void *)a);
  return (1);
}
}
static apr_status_t file_bucket_read(apr_bucket *e , char const   **str , apr_size_t *len ,
                                     apr_read_type_e block ) 
{ apr_bucket_file *a ;
  apr_file_t *f ;
  apr_bucket *b ;
  char *buf ;
  apr_status_t rv ;
  apr_size_t filelength ;
  apr_off_t fileoffset ;
  apr_int32_t flags ;
  apr_status_t tmp ;
  int tmp___0 ;
  char const   *fname ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b ;

  {
  a = (apr_bucket_file *)e->data;
  f = a->fd;
  b = (apr_bucket *)((void *)0);
  filelength = e->length;
  fileoffset = e->start;
  tmp___0 = file_make_mmap(e, filelength, fileoffset, a->readpool);
  if (tmp___0) {
    tmp = ((*((e->type)->read)))(e, str, len, block);
    return (tmp);
  }
  flags = apr_file_flags_get(f);
  if (flags & 512) {
    apr_file_name_get(& fname, f);
    rv = apr_file_open(& f, fname, flags & -513, 0, a->readpool);
    if (rv != 0) {
      return (rv);
    }
    a->fd = f;
  }
  if (filelength > 8000U) {
    (*len) = 8000U;
  } else {
    (*len) = filelength;
  }
  (*str) = (char const   *)((void *)0);
  buf = (char *)apr_bucket_alloc((*len), e->list);
  rv = apr_file_seek(f, 0, & fileoffset);
  if (rv != 0) {
    apr_bucket_free((void *)buf);
    return (rv);
  }
  rv = apr_file_read(f, (void *)buf, len);
  if (rv != 0) {
    if (rv != 70014) {
      apr_bucket_free((void *)buf);
      return (rv);
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  filelength -= (*len);
  apr_bucket_heap_make(e, (char const   *)buf, (*len), & apr_bucket_free);
  if (filelength > 0U) {
    b = (apr_bucket *)apr_bucket_alloc(sizeof((*b)), e->list);
    b->start = (long )((unsigned long )fileoffset + (unsigned long )(*len));
    b->length = filelength;
    b->data = (void *)a;
    b->type = & apr_bucket_type_file;
    b->free = & apr_bucket_free;
    b->list = e->list;
    while (1) {
      ap__a = e;
      ap__b = b;
      while (1) {
        ap__b->link.prev = ap__a;
        ap__b->link.next = ap__a->link.next;
        (ap__a->link.next)->link.prev = ap__b;
        ap__a->link.next = ap__b;
        break;
      }
      break;
    }
  } else {
    file_bucket_destroy((void *)a);
  }
  (*str) = (char const   *)buf;
  return (0);
}
}
apr_bucket *apr_bucket_file_make(apr_bucket *b , apr_file_t *fd , apr_off_t offset ,
                                 apr_size_t len , apr_pool_t *p ) 
{ apr_bucket_file *f ;

  {
  f = (apr_bucket_file *)apr_bucket_alloc(sizeof((*f)), b->list);
  f->fd = fd;
  f->readpool = p;
  f->can_mmap = 1;
  b = apr_bucket_shared_make(b, (void *)f, offset, len);
  b->type = & apr_bucket_type_file;
  return (b);
}
}
apr_bucket *apr_bucket_file_create(apr_file_t *fd , apr_off_t offset , apr_size_t len ,
                                   apr_pool_t *p , apr_bucket_alloc_t *list ) 
{ apr_bucket *b ;
  apr_bucket *tmp ;
  apr_bucket *tmp___0 ;

  {
  tmp = (apr_bucket *)apr_bucket_alloc(sizeof((*b)), list);
  b = tmp;
  while (1) {
    b->link.next = b;
    b->link.prev = b;
    break;
  }
  b->free = & apr_bucket_free;
  b->list = list;
  tmp___0 = apr_bucket_file_make(b, fd, offset, len, p);
  return (tmp___0);
}
}
apr_status_t apr_bucket_file_enable_mmap(apr_bucket *e , int enabled ) 
{ apr_bucket_file *a ;

  {
  a = (apr_bucket_file *)e->data;
  a->can_mmap = enabled;
  return (0);
}
}
static apr_status_t file_bucket_setaside(apr_bucket *data , apr_pool_t *reqpool ) 
{ apr_bucket_file *a ;
  apr_file_t *fd ;
  apr_file_t *f ;
  apr_pool_t *curpool ;
  apr_pool_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  a = (apr_bucket_file *)data->data;
  fd = (apr_file_t *)((void *)0);
  f = a->fd;
  tmp = apr_file_pool_get((apr_file_t const   *)f);
  curpool = tmp;
  tmp___0 = apr_pool_is_ancestor(curpool, reqpool);
  if (tmp___0) {
    return (0);
  }
  tmp___1 = apr_pool_is_ancestor(a->readpool, reqpool);
  if (! tmp___1) {
    a->readpool = reqpool;
  }
  apr_file_setaside(& fd, f, reqpool);
  a->fd = fd;
  return (0);
}
}
struct apr_bucket_type_t  const  apr_bucket_type_file  = 
     {"FILE", 5, (enum __anonenum_is_metadata_61 )0, & file_bucket_destroy, & file_bucket_read,
    & file_bucket_setaside, & apr_bucket_shared_split, & apr_bucket_shared_copy};
#pragma merger(0,"/tmp/cil-h7r6rnKF.i","-g -pthread")
struct apr_bucket_type_t  const  apr_bucket_type_heap ;
struct apr_bucket_type_t  const  apr_bucket_type_pool ;
static apr_status_t pool_bucket_cleanup(void *data ) 
{ apr_bucket_pool *p ;

  {
  p = (apr_bucket_pool *)data;
  p->heap.base = (char *)apr_bucket_alloc(p->heap.alloc_len, p->list);
  memcpy((void * __restrict  )p->heap.base, (void const   * __restrict  )p->base,
         p->heap.alloc_len);
  p->base = (char const   *)((void *)0);
  p->pool = (apr_pool_t *)((void *)0);
  return (0);
}
}
static apr_status_t pool_bucket_read(apr_bucket *b , char const   **str , apr_size_t *len ,
                                     apr_read_type_e block ) 
{ apr_bucket_pool *p ;
  char const   *base ;

  {
  p = (apr_bucket_pool *)b->data;
  base = p->base;
  if ((unsigned int )p->pool == (unsigned int )((void *)0)) {
    b->type = & apr_bucket_type_heap;
    base = (char const   *)p->heap.base;
  }
  (*str) = base + b->start;
  (*len) = b->length;
  return (0);
}
}
static void pool_bucket_destroy(void *data ) 
{ apr_bucket_pool *p ;
  int tmp ;

  {
  p = (apr_bucket_pool *)data;
  if (p->pool) {
    tmp = apr_bucket_shared_destroy((void *)p);
    if (tmp) {
      apr_pool_cleanup_kill(p->pool, (void const   *)p, & pool_bucket_cleanup);
      apr_bucket_free((void *)p);
    }
  } else {
    ((*(apr_bucket_type_heap.destroy)))((void *)p);
  }
  return;
}
}
apr_bucket *apr_bucket_pool_make(apr_bucket *b , char const   *buf , apr_size_t length ,
                                 apr_pool_t *pool ) 
{ apr_bucket_pool *p ;

  {
  p = (apr_bucket_pool *)apr_bucket_alloc(sizeof((*p)), b->list);
  p->base = (char const   *)((char *)buf);
  p->pool = pool;
  p->list = b->list;
  b = apr_bucket_shared_make(b, (void *)p, 0L, length);
  b->type = & apr_bucket_type_pool;
  p->heap.alloc_len = length;
  p->heap.base = (char *)((void *)0);
  p->heap.free_func = & apr_bucket_free;
  apr_pool_cleanup_register(p->pool, (void const   *)p, & pool_bucket_cleanup, & apr_pool_cleanup_null);
  return (b);
}
}
apr_bucket *apr_bucket_pool_create(char const   *buf , apr_size_t length , apr_pool_t *pool ,
                                   apr_bucket_alloc_t *list ) 
{ apr_bucket *b ;
  apr_bucket *tmp ;
  apr_bucket *tmp___0 ;

  {
  tmp = (apr_bucket *)apr_bucket_alloc(sizeof((*b)), list);
  b = tmp;
  while (1) {
    b->link.next = b;
    b->link.prev = b;
    break;
  }
  b->free = & apr_bucket_free;
  b->list = list;
  tmp___0 = apr_bucket_pool_make(b, buf, length, pool);
  return (tmp___0);
}
}
struct apr_bucket_type_t  const  apr_bucket_type_pool  = 
     {"POOL", 5, (enum __anonenum_is_metadata_61 )0, & pool_bucket_destroy, & pool_bucket_read,
    & apr_bucket_setaside_noop, & apr_bucket_shared_split, & apr_bucket_shared_copy};
#pragma merger(0,"/tmp/cil-2TTpL1O3.i","-g -pthread")
static apr_status_t flush_bucket_read(apr_bucket *b , char const   **str , apr_size_t *len ,
                                      apr_read_type_e block ) 
{ 

  {
  (*str) = (char const   *)((void *)0);
  (*len) = 0U;
  return (0);
}
}
apr_bucket *apr_bucket_flush_make(apr_bucket *b ) 
{ 

  {
  b->length = 0U;
  b->start = 0L;
  b->data = (void *)0;
  b->type = & apr_bucket_type_flush;
  return (b);
}
}
apr_bucket *apr_bucket_flush_create(apr_bucket_alloc_t *list ) 
{ apr_bucket *b ;
  apr_bucket *tmp ;
  apr_bucket *tmp___0 ;

  {
  tmp = (apr_bucket *)apr_bucket_alloc(sizeof((*b)), list);
  b = tmp;
  while (1) {
    b->link.next = b;
    b->link.prev = b;
    break;
  }
  b->free = & apr_bucket_free;
  b->list = list;
  tmp___0 = apr_bucket_flush_make(b);
  return (tmp___0);
}
}
struct apr_bucket_type_t  const  apr_bucket_type_flush  = 
     {"FLUSH", 5, (enum __anonenum_is_metadata_61 )1, & apr_bucket_destroy_noop, & flush_bucket_read,
    & apr_bucket_setaside_noop, & apr_bucket_split_notimpl, & apr_bucket_simple_copy};
#pragma merger(0,"/tmp/cil-DTcxKpkr.i","-g -pthread")
apr_status_t apr_bucket_shared_split(apr_bucket *a , apr_size_t point ) 
{ apr_bucket_refcount *r ;
  apr_status_t rv ;

  {
  r = (apr_bucket_refcount *)a->data;
  rv = apr_bucket_simple_split(a, point);
  if (rv != 0) {
    return (rv);
  }
  r->refcount = r->refcount + 1;
  return (0);
}
}
apr_status_t apr_bucket_shared_copy(apr_bucket *a , apr_bucket **b ) 
{ apr_bucket_refcount *r ;

  {
  r = (apr_bucket_refcount *)a->data;
  apr_bucket_simple_copy(a, b);
  r->refcount = r->refcount + 1;
  return (0);
}
}
int apr_bucket_shared_destroy(void *data ) 
{ apr_bucket_refcount *r ;

  {
  r = (apr_bucket_refcount *)data;
  r->refcount = r->refcount - 1;
  return (r->refcount == 0);
}
}
apr_bucket *apr_bucket_shared_make(apr_bucket *b , void *data , apr_off_t start ,
                                   apr_size_t length ) 
{ apr_bucket_refcount *r ;

  {
  r = (apr_bucket_refcount *)data;
  b->data = (void *)r;
  b->start = start;
  b->length = length;
  r->refcount = 1;
  return (b);
}
}
#pragma merger(0,"/tmp/cil-kZboHxj2.i","-g -pthread")
static apr_status_t heap_bucket_read(apr_bucket *b , char const   **str , apr_size_t *len ,
                                     apr_read_type_e block ) 
{ apr_bucket_heap *h ;

  {
  h = (apr_bucket_heap *)b->data;
  (*str) = (char const   *)(h->base + b->start);
  (*len) = b->length;
  return (0);
}
}
static void heap_bucket_destroy(void *data ) 
{ apr_bucket_heap *h ;
  int tmp ;

  {
  h = (apr_bucket_heap *)data;
  tmp = apr_bucket_shared_destroy((void *)h);
  if (tmp) {
    ((*(h->free_func)))((void *)h->base);
    apr_bucket_free((void *)h);
  }
  return;
}
}
apr_bucket *apr_bucket_heap_make(apr_bucket *b , char const   *buf , apr_size_t length ,
                                 void (*free_func)(void *data ) ) 
{ apr_bucket_heap *h ;

  {
  h = (apr_bucket_heap *)apr_bucket_alloc(sizeof((*h)), b->list);
  if (! free_func) {
    h->alloc_len = length;
    h->base = (char *)apr_bucket_alloc(h->alloc_len, b->list);
    if ((unsigned int )h->base == (unsigned int )((void *)0)) {
      apr_bucket_free((void *)h);
      return ((apr_bucket *)((void *)0));
    }
    h->free_func = & apr_bucket_free;
    memcpy((void * __restrict  )h->base, (void const   * __restrict  )buf, length);
  } else {
    h->base = (char *)buf;
    h->alloc_len = length;
    h->free_func = free_func;
  }
  b = apr_bucket_shared_make(b, (void *)h, 0L, length);
  b->type = & apr_bucket_type_heap;
  return (b);
}
}
apr_bucket *apr_bucket_heap_create(char const   *buf , apr_size_t length , void (*free_func)(void *data ) ,
                                   apr_bucket_alloc_t *list ) 
{ apr_bucket *b ;
  apr_bucket *tmp ;
  apr_bucket *tmp___0 ;

  {
  tmp = (apr_bucket *)apr_bucket_alloc(sizeof((*b)), list);
  b = tmp;
  while (1) {
    b->link.next = b;
    b->link.prev = b;
    break;
  }
  b->free = & apr_bucket_free;
  b->list = list;
  tmp___0 = apr_bucket_heap_make(b, buf, length, free_func);
  return (tmp___0);
}
}
struct apr_bucket_type_t  const  apr_bucket_type_heap  = 
     {"HEAP", 5, (enum __anonenum_is_metadata_61 )0, & heap_bucket_destroy, & heap_bucket_read,
    & apr_bucket_setaside_noop, & apr_bucket_shared_split, & apr_bucket_shared_copy};
#pragma merger(0,"/tmp/cil-3JKbq8vc.i","-g -pthread")
struct apr_bucket_type_t  const  apr_bucket_type_immortal ;
struct apr_bucket_type_t  const  apr_bucket_type_transient ;
apr_status_t apr_bucket_simple_copy(apr_bucket *a , apr_bucket **b ) 
{ 

  {
  (*b) = (apr_bucket *)apr_bucket_alloc(sizeof((*((*b)))), a->list);
  (*((*b))) = (*a);
  return (0);
}
}
apr_status_t apr_bucket_simple_split(apr_bucket *a , apr_size_t point ) 
{ apr_bucket *b ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b ;

  {
  if (point > a->length) {
    return (22);
  }
  apr_bucket_simple_copy(a, & b);
  a->length = point;
  b->length = b->length - point;
  b->start = (long )((unsigned long )b->start + (unsigned long )point);
  while (1) {
    ap__a = a;
    ap__b = b;
    while (1) {
      ap__b->link.prev = ap__a;
      ap__b->link.next = ap__a->link.next;
      (ap__a->link.next)->link.prev = ap__b;
      ap__a->link.next = ap__b;
      break;
    }
    break;
  }
  return (0);
}
}
static apr_status_t simple_bucket_read(apr_bucket *b , char const   **str , apr_size_t *len ,
                                       apr_read_type_e block ) 
{ 

  {
  (*str) = (char const   *)((char *)b->data + b->start);
  (*len) = b->length;
  return (0);
}
}
apr_bucket *apr_bucket_immortal_make(apr_bucket *b , char const   *buf , apr_size_t length ) 
{ 

  {
  b->data = (void *)((char *)buf);
  b->length = length;
  b->start = 0L;
  b->type = & apr_bucket_type_immortal;
  return (b);
}
}
apr_bucket *apr_bucket_immortal_create(char const   *buf , apr_size_t length , apr_bucket_alloc_t *list ) 
{ apr_bucket *b ;
  apr_bucket *tmp ;
  apr_bucket *tmp___0 ;

  {
  tmp = (apr_bucket *)apr_bucket_alloc(sizeof((*b)), list);
  b = tmp;
  while (1) {
    b->link.next = b;
    b->link.prev = b;
    break;
  }
  b->free = & apr_bucket_free;
  b->list = list;
  tmp___0 = apr_bucket_immortal_make(b, buf, length);
  return (tmp___0);
}
}
static apr_status_t transient_bucket_setaside(apr_bucket *b , apr_pool_t *pool ) 
{ 

  {
  b = apr_bucket_heap_make(b, (char const   *)((char *)b->data + b->start), b->length,
                           (void (*)(void *data ))((void *)0));
  if ((unsigned int )b == (unsigned int )((void *)0)) {
    return (12);
  }
  return (0);
}
}
apr_bucket *apr_bucket_transient_make(apr_bucket *b , char const   *buf , apr_size_t length ) 
{ 

  {
  b->data = (void *)((char *)buf);
  b->length = length;
  b->start = 0L;
  b->type = & apr_bucket_type_transient;
  return (b);
}
}
apr_bucket *apr_bucket_transient_create(char const   *buf , apr_size_t length , apr_bucket_alloc_t *list ) 
{ apr_bucket *b ;
  apr_bucket *tmp ;
  apr_bucket *tmp___0 ;

  {
  tmp = (apr_bucket *)apr_bucket_alloc(sizeof((*b)), list);
  b = tmp;
  while (1) {
    b->link.next = b;
    b->link.prev = b;
    break;
  }
  b->free = & apr_bucket_free;
  b->list = list;
  tmp___0 = apr_bucket_transient_make(b, buf, length);
  return (tmp___0);
}
}
struct apr_bucket_type_t  const  apr_bucket_type_immortal  = 
     {"IMMORTAL", 5, (enum __anonenum_is_metadata_61 )0, & apr_bucket_destroy_noop,
    & simple_bucket_read, & apr_bucket_setaside_noop, & apr_bucket_simple_split, & apr_bucket_simple_copy};
struct apr_bucket_type_t  const  apr_bucket_type_transient  = 
     {"TRANSIENT", 5, (enum __anonenum_is_metadata_61 )0, & apr_bucket_destroy_noop,
    & simple_bucket_read, & transient_bucket_setaside, & apr_bucket_simple_split,
    & apr_bucket_simple_copy};
#pragma merger(0,"/tmp/cil-4AleChKP.i","-g -pthread")
apr_status_t apr_bucket_setaside_noop(apr_bucket *data , apr_pool_t *pool ) 
{ 

  {
  return (0);
}
}
apr_status_t apr_bucket_setaside_notimpl(apr_bucket *data , apr_pool_t *pool ) 
{ 

  {
  return (70023);
}
}
apr_status_t apr_bucket_split_notimpl(apr_bucket *data , apr_size_t point ) 
{ 

  {
  return (70023);
}
}
apr_status_t apr_bucket_copy_notimpl(apr_bucket *e , apr_bucket **c ) 
{ 

  {
  return (70023);
}
}
void apr_bucket_destroy_noop(void *data ) 
{ 

  {
  return;
}
}
#pragma merger(0,"/tmp/cil-zE1U1mj7.i","-g -pthread")
struct apr_bucket_type_t  const  apr_bucket_type_mmap ;
static apr_status_t mmap_bucket_read(apr_bucket *b , char const   **str , apr_size_t *length ,
                                     apr_read_type_e block ) 
{ apr_bucket_mmap *m ;
  apr_status_t ok ;
  void *addr ;

  {
  m = (apr_bucket_mmap *)b->data;
  if (! m->mmap) {
    return (22);
  }
  ok = apr_mmap_offset(& addr, m->mmap, b->start);
  if (ok != 0) {
    return (ok);
  }
  (*str) = (char const   *)addr;
  (*length) = b->length;
  return (0);
}
}
static apr_status_t mmap_bucket_cleanup(void *data ) 
{ apr_bucket_mmap *m ;

  {
  m = (apr_bucket_mmap *)data;
  m->mmap = (apr_mmap_t *)((void *)0);
  return (0);
}
}
static void mmap_bucket_destroy(void *data ) 
{ apr_bucket_mmap *m ;
  int tmp ;

  {
  m = (apr_bucket_mmap *)data;
  tmp = apr_bucket_shared_destroy((void *)m);
  if (tmp) {
    if (m->mmap) {
      apr_pool_cleanup_kill((m->mmap)->cntxt, (void const   *)m, & mmap_bucket_cleanup);
      apr_mmap_delete(m->mmap);
    }
    apr_bucket_free((void *)m);
  }
  return;
}
}
apr_bucket *apr_bucket_mmap_make(apr_bucket *b , apr_mmap_t *mm , apr_off_t start ,
                                 apr_size_t length ) 
{ apr_bucket_mmap *m ;

  {
  m = (apr_bucket_mmap *)apr_bucket_alloc(sizeof((*m)), b->list);
  m->mmap = mm;
  apr_pool_cleanup_register(mm->cntxt, (void const   *)m, & mmap_bucket_cleanup, & apr_pool_cleanup_null);
  b = apr_bucket_shared_make(b, (void *)m, start, length);
  b->type = & apr_bucket_type_mmap;
  return (b);
}
}
apr_bucket *apr_bucket_mmap_create(apr_mmap_t *mm , apr_off_t start , apr_size_t length ,
                                   apr_bucket_alloc_t *list ) 
{ apr_bucket *b ;
  apr_bucket *tmp ;
  apr_bucket *tmp___0 ;

  {
  tmp = (apr_bucket *)apr_bucket_alloc(sizeof((*b)), list);
  b = tmp;
  while (1) {
    b->link.next = b;
    b->link.prev = b;
    break;
  }
  b->free = & apr_bucket_free;
  b->list = list;
  tmp___0 = apr_bucket_mmap_make(b, mm, start, length);
  return (tmp___0);
}
}
static apr_status_t mmap_bucket_setaside(apr_bucket *b , apr_pool_t *p ) 
{ apr_bucket_mmap *m ;
  apr_mmap_t *mm ;
  apr_mmap_t *new_mm ;
  apr_status_t ok ;
  int tmp ;

  {
  m = (apr_bucket_mmap *)b->data;
  mm = m->mmap;
  if (! mm) {
    return (22);
  }
  tmp = apr_pool_is_ancestor(mm->cntxt, p);
  if (tmp) {
    return (0);
  }
  ok = apr_mmap_dup(& new_mm, mm, p, 1);
  if (ok != 0) {
    return (ok);
  }
  mmap_bucket_destroy((void *)mm);
  apr_bucket_mmap_make(b, new_mm, b->start, b->length);
  return (0);
}
}
struct apr_bucket_type_t  const  apr_bucket_type_mmap  = 
     {"MMAP", 5, (enum __anonenum_is_metadata_61 )0, & mmap_bucket_destroy, & mmap_bucket_read,
    & mmap_bucket_setaside, & apr_bucket_shared_split, & apr_bucket_shared_copy};
#pragma merger(0,"/tmp/cil-X7GMd2nN.i","-g -pthread")
struct apr_bucket_type_t  const  apr_bucket_type_socket ;
static apr_status_t socket_bucket_read(apr_bucket *a , char const   **str , apr_size_t *len ,
                                       apr_read_type_e block ) 
{ apr_socket_t *p ;
  char *buf ;
  apr_status_t rv ;
  apr_interval_time_t timeout ;
  apr_bucket_heap *h ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b ;
  apr_bucket *tmp ;

  {
  p = (apr_socket_t *)a->data;
  if ((int )block == 1) {
    apr_socket_timeout_get(p, & timeout);
    apr_socket_timeout_set(p, 0LL);
  }
  (*str) = (char const   *)((void *)0);
  (*len) = 8000U;
  buf = (char *)apr_bucket_alloc((*len), a->list);
  rv = apr_socket_recv(p, buf, len);
  if ((int )block == 1) {
    apr_socket_timeout_set(p, timeout);
  }
  if (rv != 0) {
    if (rv != 70014) {
      apr_bucket_free((void *)buf);
      return (rv);
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if ((*len) > 0U) {
    a = apr_bucket_heap_make(a, (char const   *)buf, (*len), & apr_bucket_free);
    h = (apr_bucket_heap *)a->data;
    h->alloc_len = 8000U;
    (*str) = (char const   *)buf;
    while (1) {
      ap__a = a;
      tmp = apr_bucket_socket_create(p, a->list);
      ap__b = tmp;
      while (1) {
        ap__b->link.prev = ap__a;
        ap__b->link.next = ap__a->link.next;
        (ap__a->link.next)->link.prev = ap__b;
        ap__a->link.next = ap__b;
        break;
      }
      break;
    }
  } else {
    apr_bucket_free((void *)buf);
    a = apr_bucket_immortal_make(a, "", 0U);
    (*str) = (char const   *)a->data;
  }
  return (0);
}
}
apr_bucket *apr_bucket_socket_make(apr_bucket *b , apr_socket_t *p ) 
{ 

  {
  b->type = & apr_bucket_type_socket;
  b->length = 4294967295U;
  b->start = -1L;
  b->data = (void *)p;
  return (b);
}
}
apr_bucket *apr_bucket_socket_create(apr_socket_t *p , apr_bucket_alloc_t *list ) 
{ apr_bucket *b ;
  apr_bucket *tmp ;
  apr_bucket *tmp___0 ;

  {
  tmp = (apr_bucket *)apr_bucket_alloc(sizeof((*b)), list);
  b = tmp;
  while (1) {
    b->link.next = b;
    b->link.prev = b;
    break;
  }
  b->free = & apr_bucket_free;
  b->list = list;
  tmp___0 = apr_bucket_socket_make(b, p);
  return (tmp___0);
}
}
struct apr_bucket_type_t  const  apr_bucket_type_socket  = 
     {"SOCKET", 5, (enum __anonenum_is_metadata_61 )0, & apr_bucket_destroy_noop, & socket_bucket_read,
    & apr_bucket_setaside_notimpl, & apr_bucket_split_notimpl, & apr_bucket_copy_notimpl};
#pragma merger(0,"/tmp/cil-ilfuehIK.i","-g -pthread")
static apr_status_t eos_bucket_read(apr_bucket *b , char const   **str , apr_size_t *len ,
                                    apr_read_type_e block ) 
{ 

  {
  (*str) = (char const   *)((void *)0);
  (*len) = 0U;
  return (0);
}
}
apr_bucket *apr_bucket_eos_make(apr_bucket *b ) 
{ 

  {
  b->length = 0U;
  b->start = 0L;
  b->data = (void *)0;
  b->type = & apr_bucket_type_eos;
  return (b);
}
}
apr_bucket *apr_bucket_eos_create(apr_bucket_alloc_t *list ) 
{ apr_bucket *b ;
  apr_bucket *tmp ;
  apr_bucket *tmp___0 ;

  {
  tmp = (apr_bucket *)apr_bucket_alloc(sizeof((*b)), list);
  b = tmp;
  while (1) {
    b->link.next = b;
    b->link.prev = b;
    break;
  }
  b->free = & apr_bucket_free;
  b->list = list;
  tmp___0 = apr_bucket_eos_make(b);
  return (tmp___0);
}
}
struct apr_bucket_type_t  const  apr_bucket_type_eos  = 
     {"EOS", 5, (enum __anonenum_is_metadata_61 )1, & apr_bucket_destroy_noop, & eos_bucket_read,
    & apr_bucket_setaside_noop, & apr_bucket_split_notimpl, & apr_bucket_simple_copy};
#pragma merger(0,"/tmp/cil-SpQoWLlv.i","-g -pthread")
struct apr_bucket_type_t  const  apr_bucket_type_pipe ;
static apr_status_t pipe_bucket_read(apr_bucket *a , char const   **str , apr_size_t *len ,
                                     apr_read_type_e block ) 
{ apr_file_t *p ;
  char *buf ;
  apr_status_t rv ;
  apr_interval_time_t timeout ;
  apr_bucket_heap *h ;
  apr_bucket *ap__a ;
  apr_bucket *ap__b ;
  apr_bucket *tmp ;

  {
  p = (apr_file_t *)a->data;
  if ((int )block == 1) {
    apr_file_pipe_timeout_get(p, & timeout);
    apr_file_pipe_timeout_set(p, 0LL);
  }
  (*str) = (char const   *)((void *)0);
  (*len) = 8000U;
  buf = (char *)apr_bucket_alloc((*len), a->list);
  rv = apr_file_read(p, (void *)buf, len);
  if ((int )block == 1) {
    apr_file_pipe_timeout_set(p, timeout);
  }
  if (rv != 0) {
    if (rv != 70014) {
      apr_bucket_free((void *)buf);
      return (rv);
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if ((*len) > 0U) {
    a = apr_bucket_heap_make(a, (char const   *)buf, (*len), & apr_bucket_free);
    h = (apr_bucket_heap *)a->data;
    h->alloc_len = 8000U;
    (*str) = (char const   *)buf;
    while (1) {
      ap__a = a;
      tmp = apr_bucket_pipe_create(p, a->list);
      ap__b = tmp;
      while (1) {
        ap__b->link.prev = ap__a;
        ap__b->link.next = ap__a->link.next;
        (ap__a->link.next)->link.prev = ap__b;
        ap__a->link.next = ap__b;
        break;
      }
      break;
    }
  } else {
    apr_bucket_free((void *)buf);
    a = apr_bucket_immortal_make(a, "", 0U);
    (*str) = (char const   *)a->data;
    if (rv == 70014) {
      apr_file_close(p);
    }
  }
  return (0);
}
}
apr_bucket *apr_bucket_pipe_make(apr_bucket *b , apr_file_t *p ) 
{ 

  {
  b->type = & apr_bucket_type_pipe;
  b->length = 4294967295U;
  b->start = -1L;
  b->data = (void *)p;
  return (b);
}
}
apr_bucket *apr_bucket_pipe_create(apr_file_t *p , apr_bucket_alloc_t *list ) 
{ apr_bucket *b ;
  apr_bucket *tmp ;
  apr_bucket *tmp___0 ;

  {
  tmp = (apr_bucket *)apr_bucket_alloc(sizeof((*b)), list);
  b = tmp;
  while (1) {
    b->link.next = b;
    b->link.prev = b;
    break;
  }
  b->free = & apr_bucket_free;
  b->list = list;
  tmp___0 = apr_bucket_pipe_make(b, p);
  return (tmp___0);
}
}
struct apr_bucket_type_t  const  apr_bucket_type_pipe  = 
     {"PIPE", 5, (enum __anonenum_is_metadata_61 )0, & apr_bucket_destroy_noop, & pipe_bucket_read,
    & apr_bucket_setaside_notimpl, & apr_bucket_split_notimpl, & apr_bucket_copy_notimpl};
#pragma merger(0,"/tmp/cil-szCBZbr3.i","-g -pthread")
extern void *memchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__)) ;
static apr_status_t brigade_cleanup(void *data ) 
{ apr_status_t tmp ;

  {
  tmp = apr_brigade_cleanup(data);
  return (tmp);
}
}
apr_status_t apr_brigade_cleanup(void *data ) 
{ apr_bucket_brigade *b ;
  apr_bucket *e ;

  {
  b = (apr_bucket_brigade *)data;
  while (! ((unsigned int )b->list.next == (unsigned int )((struct apr_bucket *)((char *)(& b->list) -
                                                                                 (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                         (char *)((void *)0)))))) {
    e = b->list.next;
    while (1) {
      while (1) {
        (e->link.prev)->link.next = e->link.next;
        (e->link.next)->link.prev = e->link.prev;
        break;
      }
      while (1) {
        ((*((e->type)->destroy)))(e->data);
        ((*(e->free)))((void *)e);
        break;
      }
      break;
    }
  }
  return (0);
}
}
apr_status_t apr_brigade_destroy(apr_bucket_brigade *b ) 
{ apr_status_t tmp ;

  {
  apr_pool_cleanup_kill(b->p, (void const   *)b, & brigade_cleanup);
  tmp = apr_brigade_cleanup((void *)b);
  return (tmp);
}
}
apr_bucket_brigade *apr_brigade_create(apr_pool_t *p , apr_bucket_alloc_t *list ) 
{ apr_bucket_brigade *b ;

  {
  b = (apr_bucket_brigade *)apr_palloc(p, sizeof((*b)));
  b->p = p;
  b->bucket_alloc = list;
  while (1) {
    b->list.next = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                       (char *)((void *)0)));
    b->list.prev = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                       (char *)((void *)0)));
    break;
  }
  apr_pool_cleanup_register(b->p, (void const   *)b, & brigade_cleanup, & apr_pool_cleanup_null);
  return (b);
}
}
apr_bucket_brigade *apr_brigade_split(apr_bucket_brigade *b , apr_bucket *e ) 
{ apr_bucket_brigade *a ;
  apr_bucket *f ;

  {
  a = apr_brigade_create(b->p, b->bucket_alloc);
  if ((unsigned int )e != (unsigned int )((struct apr_bucket *)((char *)(& b->list) -
                                                                (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                        (char *)((void *)0))))) {
    f = b->list.prev;
    while (1) {
      (e->link.prev)->link.next = f->link.next;
      (f->link.next)->link.prev = e->link.prev;
      break;
    }
    while (1) {
      e->link.prev = (struct apr_bucket *)((char *)(& a->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                         (char *)((void *)0)));
      f->link.next = ((struct apr_bucket *)((char *)(& a->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                          (char *)((void *)0))))->link.next;
      (((struct apr_bucket *)((char *)(& a->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                            (char *)((void *)0))))->link.next)->link.prev = f;
      ((struct apr_bucket *)((char *)(& a->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                           (char *)((void *)0))))->link.next = e;
      break;
    }
  }
  return (a);
}
}
apr_status_t apr_brigade_partition(apr_bucket_brigade *b , apr_off_t point , apr_bucket **after_point ) 
{ apr_bucket *e ;
  char const   *s ;
  apr_size_t len ;
  apr_status_t rv ;

  {
  if (point < 0L) {
    return (22);
  }
  if (point == 0L) {
    (*after_point) = b->list.next;
    return (0);
  }
  e = b->list.next;
  while ((unsigned int )e != (unsigned int )((struct apr_bucket *)((char *)(& b->list) -
                                                                   (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                           (char *)((void *)0))))) {
    if (e->length == 4294967295U) {
      if ((unsigned long )point > 4294967295UL) {
        rv = ((*((e->type)->read)))(e, & s, & len, (enum __anonenum_apr_read_type_e_60 )0);
        if (rv != 0) {
          (*after_point) = e;
          return (rv);
        }
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    if ((unsigned long )point < (unsigned long )e->length) {
      goto _L___0;
    } else {
      if (e->length == 4294967295U) {
        _L___0: 
        rv = ((*((e->type)->split)))(e, (unsigned int )point);
        if (rv != 70023) {
          (*after_point) = e->link.next;
          return (rv);
        }
        rv = ((*((e->type)->read)))(e, & s, & len, (enum __anonenum_apr_read_type_e_60 )0);
        if (rv != 0) {
          (*after_point) = e;
          return (rv);
        }
        if ((unsigned long )point < (unsigned long )e->length) {
          rv = ((*((e->type)->split)))(e, (unsigned int )point);
          (*after_point) = e->link.next;
          return (rv);
        }
      }
    }
    if ((unsigned long )point == (unsigned long )e->length) {
      (*after_point) = e->link.next;
      return (0);
    }
    point = (long )((unsigned long )point - (unsigned long )e->length);
    e = e->link.next;
  }
  (*after_point) = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                       (char *)((void *)0)));
  return (70008);
}
}
apr_status_t apr_brigade_length(apr_bucket_brigade *bb , int read_all , apr_off_t *length ) 
{ apr_off_t total ;
  apr_bucket *bkt ;
  char const   *ignore ;
  apr_size_t len ;
  apr_status_t status ;

  {
  total = 0L;
  bkt = bb->list.next;
  while ((unsigned int )bkt != (unsigned int )((struct apr_bucket *)((char *)(& bb->list) -
                                                                     (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                             (char *)((void *)0))))) {
    if (bkt->length == 4294967295U) {
      if (! read_all) {
        (*length) = -1L;
        return (0);
      }
      status = ((*((bkt->type)->read)))(bkt, & ignore, & len, (enum __anonenum_apr_read_type_e_60 )0);
      if (status != 0) {
        return (status);
      }
    }
    total = (long )((unsigned long )total + (unsigned long )bkt->length);
    bkt = bkt->link.next;
  }
  (*length) = total;
  return (0);
}
}
apr_status_t apr_brigade_flatten(apr_bucket_brigade *bb , char *c , apr_size_t *len ) 
{ apr_size_t actual ;
  apr_bucket *b ;
  char const   *str ;
  apr_size_t str_len ;
  apr_status_t status ;

  {
  actual = 0U;
  b = bb->list.next;
  while ((unsigned int )b != (unsigned int )((struct apr_bucket *)((char *)(& bb->list) -
                                                                   (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                           (char *)((void *)0))))) {
    status = ((*((b->type)->read)))(b, & str, & str_len, (enum __anonenum_apr_read_type_e_60 )0);
    if (status != 0) {
      return (status);
    }
    if (str_len + actual > (*len)) {
      str_len = (*len) - actual;
    }
    memcpy((void * __restrict  )c, (void const   * __restrict  )str, str_len);
    c += str_len;
    actual += str_len;
    if (actual >= (*len)) {
      break;
    }
    b = b->link.next;
  }
  (*len) = actual;
  return (0);
}
}
apr_status_t apr_brigade_pflatten(apr_bucket_brigade *bb , char **c , apr_size_t *len ,
                                  apr_pool_t *pool ) 
{ apr_off_t actual ;
  apr_size_t total ;
  apr_status_t rv ;

  {
  apr_brigade_length(bb, 1, & actual);
  total = (unsigned int )actual;
  (*c) = (char *)apr_palloc(pool, total);
  rv = apr_brigade_flatten(bb, (*c), & total);
  if (rv != 0) {
    return (rv);
  }
  (*len) = total;
  return (0);
}
}
apr_status_t apr_brigade_split_line(apr_bucket_brigade *bbOut , apr_bucket_brigade *bbIn ,
                                    apr_read_type_e block , apr_off_t maxbytes ) 
{ apr_off_t readbytes ;
  char const   *pos ;
  char const   *str ;
  apr_size_t len ;
  apr_status_t rv ;
  apr_bucket *e ;
  apr_bucket *ap__b ;
  apr_bucket *ap__b___0 ;

  {
  readbytes = 0L;
  while (! ((unsigned int )bbIn->list.next == (unsigned int )((struct apr_bucket *)((char *)(& bbIn->list) -
                                                                                    (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                            (char *)((void *)0)))))) {
    e = bbIn->list.next;
    rv = ((*((e->type)->read)))(e, & str, & len, block);
    if (rv != 0) {
      return (rv);
    }
    pos = (char const   *)memchr((void const   *)str, '\n', len);
    if ((unsigned int )pos != (unsigned int )((void *)0)) {
      ((*((e->type)->split)))(e, (unsigned int )((pos - str) + 1));
      while (1) {
        (e->link.prev)->link.next = e->link.next;
        (e->link.next)->link.prev = e->link.prev;
        break;
      }
      while (1) {
        ap__b = e;
        while (1) {
          ap__b->link.next = (struct apr_bucket *)((char *)(& bbOut->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                     (char *)((void *)0)));
          ap__b->link.prev = ((struct apr_bucket *)((char *)(& bbOut->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                      (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& bbOut->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                    (char *)((void *)0))))->link.prev)->link.next = ap__b;
          ((struct apr_bucket *)((char *)(& bbOut->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                   (char *)((void *)0))))->link.prev = ap__b;
          break;
        }
        break;
      }
      return (0);
    }
    while (1) {
      (e->link.prev)->link.next = e->link.next;
      (e->link.next)->link.prev = e->link.prev;
      break;
    }
    while (1) {
      ap__b___0 = e;
      while (1) {
        ap__b___0->link.next = (struct apr_bucket *)((char *)(& bbOut->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0)));
        ap__b___0->link.prev = ((struct apr_bucket *)((char *)(& bbOut->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                        (char *)((void *)0))))->link.prev;
        (((struct apr_bucket *)((char *)(& bbOut->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                  (char *)((void *)0))))->link.prev)->link.next = ap__b___0;
        ((struct apr_bucket *)((char *)(& bbOut->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0))))->link.prev = ap__b___0;
        break;
      }
      break;
    }
    readbytes = (long )((unsigned long )readbytes + (unsigned long )len);
    if (readbytes >= maxbytes) {
      break;
    }
  }
  return (0);
}
}
apr_status_t apr_brigade_to_iovec(apr_bucket_brigade *b , struct iovec *vec , int *nvec ) 
{ int left ;
  apr_bucket *e ;
  struct iovec *orig ;
  apr_size_t iov_len ;
  apr_status_t rv ;
  int tmp ;

  {
  left = (*nvec);
  orig = vec;
  e = b->list.next;
  while ((unsigned int )e != (unsigned int )((struct apr_bucket *)((char *)(& b->list) -
                                                                   (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                           (char *)((void *)0))))) {
    tmp = left;
    left --;
    if (tmp == 0) {
      break;
    }
    rv = ((*((e->type)->read)))(e, (char const   **)(& vec->iov_base), & iov_len,
                                (enum __anonenum_apr_read_type_e_60 )1);
    if (rv != 0) {
      return (rv);
    }
    vec->iov_len = iov_len;
    vec ++;
    e = e->link.next;
  }
  (*nvec) = vec - orig;
  return (0);
}
}
apr_status_t apr_brigade_vputstrs(apr_bucket_brigade *b , apr_status_t (*flush)(apr_bucket_brigade *bb ,
                                                                                void *ctx ) ,
                                  void *ctx , va_list va ) 
{ char const   *str ;
  char const   *tmp ;
  apr_status_t rv ;
  apr_size_t tmp___0 ;

  {
  while (1) {
    tmp = __builtin_va_arg(va, char const   *);
    str = tmp;
    if ((unsigned int )str == (unsigned int )((void *)0)) {
      break;
    }
    tmp___0 = strlen(str);
    rv = apr_brigade_write(b, flush, ctx, str, tmp___0);
    if (rv != 0) {
      return (rv);
    }
  }
  return (0);
}
}
apr_status_t apr_brigade_putc(apr_bucket_brigade *b , apr_status_t (*flush)(apr_bucket_brigade *bb ,
                                                                            void *ctx ) ,
                              void *ctx , char c ) 
{ apr_status_t tmp ;

  {
  tmp = apr_brigade_write(b, flush, ctx, (char const   *)(& c), 1U);
  return (tmp);
}
}
apr_status_t apr_brigade_write(apr_bucket_brigade *b , apr_status_t (*flush)(apr_bucket_brigade *bb ,
                                                                             void *ctx ) ,
                               void *ctx , char const   *str , apr_size_t nbyte ) 
{ apr_bucket *e ;
  apr_size_t remaining ;
  char *buf ;
  apr_bucket_heap *h ;
  apr_bucket *ap__b ;
  apr_status_t tmp ;
  apr_bucket *ap__b___0 ;
  apr_bucket *ap__b___1 ;

  {
  e = b->list.prev;
  remaining = 8000U;
  buf = (char *)((void *)0);
  if (! ((unsigned int )b->list.next == (unsigned int )((struct apr_bucket *)((char *)(& b->list) -
                                                                              (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                      (char *)((void *)0)))))) {
    if ((unsigned int )e->type == (unsigned int )(& apr_bucket_type_heap)) {
      h = (apr_bucket_heap *)e->data;
      remaining = h->alloc_len - (e->length + (unsigned int )e->start);
      buf = (h->base + e->start) + e->length;
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if (nbyte > remaining) {
    if (flush) {
      e = apr_bucket_transient_create(str, nbyte, b->bucket_alloc);
      while (1) {
        ap__b = e;
        while (1) {
          ap__b->link.next = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                 (char *)((void *)0)));
          ap__b->link.prev = ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                  (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0))))->link.prev)->link.next = ap__b;
          ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                               (char *)((void *)0))))->link.prev = ap__b;
          break;
        }
        break;
      }
      tmp = ((*flush))(b, ctx);
      return (tmp);
    } else {
      e = apr_bucket_heap_create(str, nbyte, (void (*)(void *data ))((void *)0), b->bucket_alloc);
      while (1) {
        ap__b___0 = e;
        while (1) {
          ap__b___0->link.next = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                     (char *)((void *)0)));
          ap__b___0->link.prev = ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                      (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0))))->link.prev)->link.next = ap__b___0;
          ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                               (char *)((void *)0))))->link.prev = ap__b___0;
          break;
        }
        break;
      }
      return (0);
    }
  } else {
    if (! buf) {
      buf = (char *)apr_bucket_alloc(8000U, b->bucket_alloc);
      e = apr_bucket_heap_create((char const   *)buf, 8000U, & apr_bucket_free, b->bucket_alloc);
      while (1) {
        ap__b___1 = e;
        while (1) {
          ap__b___1->link.next = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                     (char *)((void *)0)));
          ap__b___1->link.prev = ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                      (char *)((void *)0))))->link.prev;
          (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                (char *)((void *)0))))->link.prev)->link.next = ap__b___1;
          ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                               (char *)((void *)0))))->link.prev = ap__b___1;
          break;
        }
        break;
      }
      e->length = 0U;
    }
  }
  memcpy((void * __restrict  )buf, (void const   * __restrict  )str, nbyte);
  e->length = e->length + nbyte;
  return (0);
}
}
apr_status_t apr_brigade_writev(apr_bucket_brigade *b , apr_status_t (*flush)(apr_bucket_brigade *bb ,
                                                                              void *ctx ) ,
                                void *ctx , struct iovec  const  *vec , apr_size_t nvec ) 
{ apr_bucket *e ;
  apr_size_t total_len ;
  apr_size_t i ;
  char *buf ;
  apr_bucket *ap__b ;
  apr_status_t tmp ;
  apr_bucket *ap__b___0 ;
  apr_bucket_heap *h ;
  apr_size_t remaining ;
  apr_size_t len ;
  char const   *start_buf ;
  apr_size_t len___0 ;
  apr_status_t rv ;
  apr_status_t tmp___0 ;
  apr_size_t len___1 ;
  apr_bucket *ap__b___1 ;

  {
  total_len = 0U;
  i = 0U;
  while (i < nvec) {
    total_len += (vec + i)->iov_len;
    i ++;
  }
  if (total_len > 8000U) {
    if (flush) {
      i = 0U;
      while (i < nvec) {
        e = apr_bucket_transient_create((char const   *)(vec + i)->iov_base, (vec +
                                                                              i)->iov_len,
                                        b->bucket_alloc);
        while (1) {
          ap__b = e;
          while (1) {
            ap__b->link.next = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                   (char *)((void *)0)));
            ap__b->link.prev = ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                    (char *)((void *)0))))->link.prev;
            (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                  (char *)((void *)0))))->link.prev)->link.next = ap__b;
            ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0))))->link.prev = ap__b;
            break;
          }
          break;
        }
        i ++;
      }
      tmp = ((*flush))(b, ctx);
      return (tmp);
    } else {
      i = 0U;
      while (i < nvec) {
        e = apr_bucket_heap_create((char const   *)(vec + i)->iov_base, (vec + i)->iov_len,
                                   (void (*)(void *data ))((void *)0), b->bucket_alloc);
        while (1) {
          ap__b___0 = e;
          while (1) {
            ap__b___0->link.next = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0)));
            ap__b___0->link.prev = ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                        (char *)((void *)0))))->link.prev;
            (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                  (char *)((void *)0))))->link.prev)->link.next = ap__b___0;
            ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                 (char *)((void *)0))))->link.prev = ap__b___0;
            break;
          }
          break;
        }
        i ++;
      }
      return (0);
    }
  }
  i = 0U;
  e = b->list.prev;
  if (! ((unsigned int )b->list.next == (unsigned int )((struct apr_bucket *)((char *)(& b->list) -
                                                                              (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                      (char *)((void *)0)))))) {
    if ((unsigned int )e->type == (unsigned int )(& apr_bucket_type_heap)) {
      h = (apr_bucket_heap *)e->data;
      remaining = h->alloc_len - (e->length + (unsigned int )e->start);
      buf = (h->base + e->start) + e->length;
      if (remaining >= total_len) {
        while (i < nvec) {
          len = (vec + i)->iov_len;
          memcpy((void * __restrict  )buf, (void const   * __restrict  )((void const   *)(vec +
                                                                                          i)->iov_base),
                 len);
          buf += len;
          i ++;
        }
        e->length = e->length + total_len;
        return (0);
      } else {
        start_buf = (char const   *)buf;
        while (i < nvec) {
          len___0 = (vec + i)->iov_len;
          if (len___0 > remaining) {
            break;
          }
          memcpy((void * __restrict  )buf, (void const   * __restrict  )((void const   *)(vec +
                                                                                          i)->iov_base),
                 len___0);
          buf += len___0;
          remaining -= len___0;
          i ++;
        }
        e->length = e->length + (unsigned int )(buf - (char *)start_buf);
        total_len -= (unsigned int )(buf - (char *)start_buf);
        if (flush) {
          tmp___0 = ((*flush))(b, ctx);
          rv = tmp___0;
          if (rv != 0) {
            return (rv);
          }
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  buf = (char *)apr_bucket_alloc(8000U, b->bucket_alloc);
  e = apr_bucket_heap_create((char const   *)buf, 8000U, & apr_bucket_free, b->bucket_alloc);
  while (i < nvec) {
    len___1 = (vec + i)->iov_len;
    memcpy((void * __restrict  )buf, (void const   * __restrict  )((void const   *)(vec +
                                                                                    i)->iov_base),
           len___1);
    buf += len___1;
    i ++;
  }
  e->length = total_len;
  while (1) {
    ap__b___1 = e;
    while (1) {
      ap__b___1->link.next = (struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                 (char *)((void *)0)));
      ap__b___1->link.prev = ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                  (char *)((void *)0))))->link.prev;
      (((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                            (char *)((void *)0))))->link.prev)->link.next = ap__b___1;
      ((struct apr_bucket *)((char *)(& b->list) - (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                           (char *)((void *)0))))->link.prev = ap__b___1;
      break;
    }
    break;
  }
  return (0);
}
}
apr_status_t apr_brigade_puts(apr_bucket_brigade *bb , apr_status_t (*flush)(apr_bucket_brigade *bb ,
                                                                             void *ctx ) ,
                              void *ctx , char const   *str ) 
{ apr_size_t len ;
  apr_size_t tmp ;
  apr_bucket *bkt ;
  apr_bucket_heap *h ;
  apr_size_t bytes_avail ;
  char *buf ;
  apr_status_t tmp___0 ;

  {
  tmp = strlen(str);
  len = tmp;
  bkt = bb->list.prev;
  if (! ((unsigned int )bb->list.next == (unsigned int )((struct apr_bucket *)((char *)(& bb->list) -
                                                                               (long )((char *)(& ((struct apr_bucket *)((void *)0))->link) -
                                                                                       (char *)((void *)0)))))) {
    if ((unsigned int )bkt->type == (unsigned int )(& apr_bucket_type_heap)) {
      h = (apr_bucket_heap *)bkt->data;
      bytes_avail = h->alloc_len - bkt->length;
      if (bytes_avail >= len) {
        buf = (h->base + bkt->start) + bkt->length;
        memcpy((void * __restrict  )buf, (void const   * __restrict  )str, len);
        bkt->length = bkt->length + len;
        return (0);
      }
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  tmp___0 = apr_brigade_write(bb, flush, ctx, str, len);
  return (tmp___0);
}
}
apr_status_t apr_brigade_putstrs(apr_bucket_brigade *b , apr_status_t (*flush)(apr_bucket_brigade *bb ,
                                                                               void *ctx ) ,
                                 void *ctx  , ...) 
{ va_list va ;
  apr_status_t rv ;

  {
  __builtin_stdarg_start(va, ctx);
  rv = apr_brigade_vputstrs(b, flush, ctx, va);
  __builtin_va_end(va);
  return (rv);
}
}
apr_status_t apr_brigade_printf(apr_bucket_brigade *b , apr_status_t (*flush)(apr_bucket_brigade *bb ,
                                                                              void *ctx ) ,
                                void *ctx , char const   *fmt  , ...) 
{ va_list ap ;
  apr_status_t rv ;

  {
  __builtin_stdarg_start(ap, fmt);
  rv = apr_brigade_vprintf(b, flush, ctx, fmt, ap);
  __builtin_va_end(ap);
  return (rv);
}
}
static apr_status_t brigade_flush(apr_vformatter_buff_t *buff ) 
{ struct brigade_vprintf_data_t *vd ;
  apr_status_t res ;

  {
  vd = (struct brigade_vprintf_data_t *)buff;
  res = 0;
  res = apr_brigade_write(vd->b, (*(vd->flusher)), vd->ctx, (char const   *)vd->cbuff,
                          8000U);
  if (res != 0) {
    return (-1);
  }
  vd->vbuff.curpos = vd->cbuff;
  vd->vbuff.endpos = vd->cbuff + 8000;
  return (res);
}
}
apr_status_t apr_brigade_vprintf(apr_bucket_brigade *b , apr_status_t (*flush)(apr_bucket_brigade *bb ,
                                                                               void *ctx ) ,
                                 void *ctx , char const   *fmt , va_list va ) 
{ struct brigade_vprintf_data_t vd ;
  char buf[8000] ;
  apr_size_t written ;
  apr_status_t tmp ;

  {
  vd.vbuff.curpos = buf;
  vd.vbuff.endpos = buf + 8000;
  vd.b = b;
  vd.flusher = & flush;
  vd.ctx = ctx;
  vd.cbuff = buf;
  written = (apr_size_t )apr_vformatter(& brigade_flush, & vd.vbuff, fmt, va);
  if (written == 4294967295U) {
    return (-1);
  }
  (*(vd.vbuff.curpos)) = (char )'\000';
  tmp = apr_brigade_write(b, flush, ctx, (char const   *)(buf), (unsigned int )(vd.vbuff.curpos -
                                                                                buf));
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-0CYc3eQj.i","-g -pthread")
static apr_status_t alloc_cleanup(void *data ) 
{ apr_bucket_alloc_t *list ;
  apr_allocator_t *allocator ;

  {
  list = (apr_bucket_alloc_t *)data;
  allocator = list->allocator;
  apr_allocator_free(allocator, list->blocks);
  apr_allocator_destroy(allocator);
  return (0);
}
}
apr_bucket_alloc_t *apr_bucket_alloc_create(apr_pool_t *p ) 
{ apr_allocator_t *allocator ;
  apr_bucket_alloc_t *list ;
  apr_memnode_t *block ;

  {
  apr_allocator_create(& allocator);
  block = apr_allocator_alloc(allocator, 8192U - ((sizeof(apr_memnode_t ) + 7U) &
                                                  4294967288U));
  list = (apr_bucket_alloc_t *)block->first_avail;
  list->pool = p;
  list->allocator = allocator;
  list->freelist = (node_header_t *)((void *)0);
  list->blocks = block;
  block->first_avail = block->first_avail + ((sizeof((*list)) + 7U) & 4294967288U);
  apr_pool_cleanup_register(list->pool, (void const   *)list, & alloc_cleanup, & apr_pool_cleanup_null);
  return (list);
}
}
void apr_bucket_alloc_destroy(apr_bucket_alloc_t *list ) 
{ 

  {
  apr_pool_cleanup_run(list->pool, (void *)list, & alloc_cleanup);
  return;
}
}
void *apr_bucket_alloc(apr_size_t size , apr_bucket_alloc_t *list ) 
{ node_header_t *node ;
  apr_memnode_t *active ;
  char *endp ;
  apr_memnode_t *memnode ;
  apr_memnode_t *tmp ;

  {
  active = list->blocks;
  size += (sizeof(node_header_t ) + 7U) & 4294967288U;
  if (size <= ((2U * sizeof(apr_bucket_structs ) + 7U) & 4294967288U) + ((sizeof(node_header_t ) +
                                                                          7U) & 4294967288U)) {
    if (list->freelist) {
      node = list->freelist;
      list->freelist = node->next;
    } else {
      endp = active->first_avail + (((2U * sizeof(apr_bucket_structs ) + 7U) & 4294967288U) +
                                    ((sizeof(node_header_t ) + 7U) & 4294967288U));
      if ((unsigned int )endp >= (unsigned int )active->endp) {
        list->blocks = apr_allocator_alloc(list->allocator, 8192U - ((sizeof(apr_memnode_t ) +
                                                                      7U) & 4294967288U));
        (list->blocks)->next = active;
        active = list->blocks;
        endp = active->first_avail + (((2U * sizeof(apr_bucket_structs ) + 7U) & 4294967288U) +
                                      ((sizeof(node_header_t ) + 7U) & 4294967288U));
      }
      node = (node_header_t *)active->first_avail;
      node->alloc = list;
      node->memnode = active;
      node->size = ((2U * sizeof(apr_bucket_structs ) + 7U) & 4294967288U) + ((sizeof(node_header_t ) +
                                                                               7U) &
                                                                              4294967288U);
      active->first_avail = endp;
    }
  } else {
    tmp = apr_allocator_alloc(list->allocator, size);
    memnode = tmp;
    node = (node_header_t *)memnode->first_avail;
    node->alloc = list;
    node->memnode = memnode;
    node->size = size;
  }
  return ((void *)((char *)node + ((sizeof(node_header_t ) + 7U) & 4294967288U)));
}
}
void apr_bucket_free(void *mem ) 
{ node_header_t *node ;
  apr_bucket_alloc_t *list ;

  {
  node = (node_header_t *)((char *)mem - ((sizeof(node_header_t ) + 7U) & 4294967288U));
  list = node->alloc;
  if (node->size == ((2U * sizeof(apr_bucket_structs ) + 7U) & 4294967288U) + ((sizeof(node_header_t ) +
                                                                                7U) &
                                                                               4294967288U)) {
    node->next = list->freelist;
    list->freelist = node;
  } else {
    apr_allocator_free(list->allocator, node->memnode);
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-TRcDsGxo.i","-g -pthread")
static void sha_transform(apr_sha1_ctx_t *sha_info ) 
{ int i ;
  apr_uint32_t temp ;
  apr_uint32_t A ;
  apr_uint32_t B ;
  apr_uint32_t C ;
  apr_uint32_t D ;
  apr_uint32_t E ;
  apr_uint32_t W[80] ;

  {
  i = 0;
  while (i < 16) {
    W[i] = sha_info->data[i];
    i ++;
  }
  i = 16;
  while (i < 80) {
    W[i] = ((W[i - 3] ^ W[i - 8]) ^ W[i - 14]) ^ W[i - 16];
    W[i] = (W[i] << 1) | (W[i] >> 31);
    i ++;
  }
  A = sha_info->digest[0];
  B = sha_info->digest[1];
  C = sha_info->digest[2];
  D = sha_info->digest[3];
  E = sha_info->digest[4];
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[0]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[1]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[2]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[3]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[4]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[5]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[6]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[7]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[8]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[9]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[10]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[11]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[12]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[13]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[14]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[15]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[16]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[17]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[18]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B &
                                                                                 D))) +
                                           E) + W[19]) + 1518500249UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[20]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[21]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[22]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[23]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[24]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[25]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[26]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[27]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[28]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[29]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[30]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[31]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[32]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[33]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[34]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[35]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[36]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[37]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[38]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[39]) + 1859775393UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[40]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[41]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[42]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[43]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[44]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[45]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[46]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[47]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[48]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[49]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[50]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[51]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[52]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[53]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[54]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[55]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[56]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[57]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[58]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B &
                                                                                  D)) |
                                                                      (C & D))) +
                                           E) + W[59]) + 2400959708UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[60]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[61]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[62]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[63]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[64]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[65]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[66]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[67]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[68]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[69]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[70]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[71]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[72]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[73]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[74]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[75]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[76]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[77]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[78]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  temp = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) +
                                           E) + W[79]) + 3395469782UL);
  E = D;
  D = C;
  C = (B << 30) | (B >> 2);
  B = A;
  A = temp;
  sha_info->digest[0] = sha_info->digest[0] + A;
  sha_info->digest[1] = sha_info->digest[1] + B;
  sha_info->digest[2] = sha_info->digest[2] + C;
  sha_info->digest[3] = sha_info->digest[3] + D;
  sha_info->digest[4] = sha_info->digest[4] + E;
  return;
}
}
static union endianTest u  ;
static char isLittleEndian(void) 
{ 

  {
  u.Long = 1L;
  return ((char )((int )u.Char[0] == 1));
}
}
static void maybe_byte_reverse(apr_uint32_t *buffer , int count ) 
{ int i ;
  apr_byte_t ct[4] ;
  apr_byte_t *cp ;
  char tmp ;

  {
  tmp = isLittleEndian();
  if (tmp) {
    count = (int )((unsigned int )count / sizeof(apr_uint32_t ));
    cp = (apr_byte_t *)buffer;
    i = 0;
    while (i < count) {
      ct[0] = (*(cp + 0));
      ct[1] = (*(cp + 1));
      ct[2] = (*(cp + 2));
      ct[3] = (*(cp + 3));
      (*(cp + 0)) = ct[3];
      (*(cp + 1)) = ct[2];
      (*(cp + 2)) = ct[1];
      (*(cp + 3)) = ct[0];
      cp += sizeof(apr_uint32_t );
      i ++;
    }
  }
  return;
}
}
void apr_sha1_init(apr_sha1_ctx_t *sha_info ) 
{ 

  {
  sha_info->digest[0] = 1732584193U;
  sha_info->digest[1] = 4023233417U;
  sha_info->digest[2] = 2562383102U;
  sha_info->digest[3] = 271733878U;
  sha_info->digest[4] = 3285377520U;
  sha_info->count_lo = 0U;
  sha_info->count_hi = 0U;
  sha_info->local = 0;
  return;
}
}
void apr_sha1_update_binary(apr_sha1_ctx_t *sha_info , unsigned char const   *buffer ,
                            unsigned int count ) 
{ unsigned int i ;

  {
  if (sha_info->count_lo + (count << 3) < sha_info->count_lo) {
    sha_info->count_hi = sha_info->count_hi + 1U;
  }
  sha_info->count_lo = sha_info->count_lo + (count << 3);
  sha_info->count_hi = sha_info->count_hi + (count >> 29);
  if (sha_info->local) {
    i = (unsigned int )(64 - sha_info->local);
    if (i > count) {
      i = count;
    }
    memcpy((void * __restrict  )((apr_byte_t *)(sha_info->data) + sha_info->local),
           (void const   * __restrict  )buffer, i);
    count -= i;
    buffer += i;
    sha_info->local = (int )((unsigned int )sha_info->local + i);
    if (sha_info->local == 64) {
      maybe_byte_reverse(sha_info->data, 64);
      sha_transform(sha_info);
    } else {
      return;
    }
  }
  while (count >= 64U) {
    memcpy((void * __restrict  )(sha_info->data), (void const   * __restrict  )buffer,
           64U);
    buffer += 64;
    count -= 64U;
    maybe_byte_reverse(sha_info->data, 64);
    sha_transform(sha_info);
  }
  memcpy((void * __restrict  )(sha_info->data), (void const   * __restrict  )buffer,
         count);
  sha_info->local = (int )count;
  return;
}
}
void apr_sha1_update(apr_sha1_ctx_t *sha_info , char const   *buf , unsigned int count ) 
{ 

  {
  apr_sha1_update_binary(sha_info, (unsigned char const   *)buf, count);
  return;
}
}
void apr_sha1_final(unsigned char *digest , apr_sha1_ctx_t *sha_info ) 
{ int count ;
  int i ;
  int j ;
  apr_uint32_t lo_bit_count ;
  apr_uint32_t hi_bit_count ;
  apr_uint32_t k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  lo_bit_count = sha_info->count_lo;
  hi_bit_count = sha_info->count_hi;
  count = (int )((lo_bit_count >> 3) & 63U);
  tmp = count;
  count ++;
  (*((apr_byte_t *)(sha_info->data) + tmp)) = (unsigned char)128;
  if (count > 56) {
    memset((void *)((apr_byte_t *)(sha_info->data) + count), 0, (unsigned int )(64 -
                                                                                count));
    maybe_byte_reverse(sha_info->data, 64);
    sha_transform(sha_info);
    memset((void *)((apr_byte_t *)(sha_info->data)), 0, 56U);
  } else {
    memset((void *)((apr_byte_t *)(sha_info->data) + count), 0, (unsigned int )(56 -
                                                                                count));
  }
  maybe_byte_reverse(sha_info->data, 64);
  sha_info->data[14] = hi_bit_count;
  sha_info->data[15] = lo_bit_count;
  sha_transform(sha_info);
  i = 0;
  j = 0;
  while (j < 20) {
    k = sha_info->digest[i];
    tmp___0 = j;
    j ++;
    (*(digest + tmp___0)) = (unsigned char )((k >> 24) & 255U);
    tmp___1 = j;
    j ++;
    (*(digest + tmp___1)) = (unsigned char )((k >> 16) & 255U);
    tmp___2 = j;
    j ++;
    (*(digest + tmp___2)) = (unsigned char )((k >> 8) & 255U);
    tmp___3 = j;
    j ++;
    (*(digest + tmp___3)) = (unsigned char )(k & 255U);
    i ++;
  }
  return;
}
}
void apr_sha1_base64(char const   *clear , int len , char *out ) 
{ int l ;
  apr_sha1_ctx_t context ;
  apr_byte_t digest[20] ;
  int tmp ;

  {
  tmp = strncmp(clear, "{SHA}", 5U);
  if (tmp == 0) {
    clear += 5;
  }
  apr_sha1_init(& context);
  apr_sha1_update(& context, clear, (unsigned int )len);
  apr_sha1_final(digest, & context);
  apr_cpystrn(out, "{SHA}", 6U);
  l = apr_base64_encode_binary(out + 5, (unsigned char const   *)(digest), (int )sizeof(digest));
  (*(out + (l + 5))) = (char )'\000';
  return;
}
}
#pragma merger(0,"/tmp/cil-TOxY36Tv.i","-g -pthread")
static void MD4Transform(apr_uint32_t *state , unsigned char const   *block ) ;
static void Encode(unsigned char *output , apr_uint32_t const   *input , unsigned int len ) ;
static void Decode(apr_uint32_t *output , unsigned char const   *input , unsigned int len ) ;
static unsigned char PADDING[64]  = 
  {      (unsigned char)128,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
apr_status_t apr_md4_init(apr_md4_ctx_t *context ) 
{ 

  {
  context->count[1] = 0U;
  context->count[0] = context->count[1];
  context->state[0] = 1732584193U;
  context->state[1] = 4023233417U;
  context->state[2] = 2562383102U;
  context->state[3] = 271733878U;
  context->xlate = (apr_xlate_t *)((void *)0);
  return (0);
}
}
apr_status_t apr_md4_set_xlate(apr_md4_ctx_t *context , apr_xlate_t *xlate ) 
{ apr_status_t rv ;
  int is_sb ;

  {
  rv = apr_xlate_get_sb(xlate, & is_sb);
  if (rv != 0) {
    return (rv);
  }
  if (! is_sb) {
    return (22);
  }
  context->xlate = xlate;
  return (0);
}
}
apr_status_t apr_md4_update(apr_md4_ctx_t *context , unsigned char const   *input ,
                            apr_size_t inputLen ) 
{ unsigned int i ;
  unsigned int idx ;
  unsigned int partLen ;
  apr_size_t inbytes_left ;
  apr_size_t outbytes_left ;
  unsigned char inp_tmp[64] ;

  {
  idx = (context->count[0] >> 3) & 63U;
  context->count[0] = context->count[0] + (inputLen << 3);
  if (context->count[0] < inputLen << 3) {
    context->count[1] = context->count[1] + 1U;
  }
  context->count[1] = context->count[1] + (inputLen >> 29);
  partLen = 64U - idx;
  if (inputLen >= partLen) {
    if (context->xlate) {
      outbytes_left = partLen;
      inbytes_left = outbytes_left;
      apr_xlate_conv_buffer(context->xlate, (char const   *)input, & inbytes_left,
                            (char *)(& context->buffer[idx]), & outbytes_left);
    } else {
      memcpy((void * __restrict  )(& context->buffer[idx]), (void const   * __restrict  )input,
             partLen);
    }
    MD4Transform(context->state, (unsigned char const   *)(context->buffer));
    i = partLen;
    while (i + 63U < inputLen) {
      if (context->xlate) {
        outbytes_left = 64U;
        inbytes_left = outbytes_left;
        apr_xlate_conv_buffer(context->xlate, (char const   *)(input + i), & inbytes_left,
                              (char *)(inp_tmp), & outbytes_left);
        MD4Transform(context->state, (unsigned char const   *)(inp_tmp));
      } else {
        MD4Transform(context->state, input + i);
      }
      i += 64U;
    }
    idx = 0U;
  } else {
    i = 0U;
  }
  if (context->xlate) {
    outbytes_left = inputLen - i;
    inbytes_left = outbytes_left;
    apr_xlate_conv_buffer(context->xlate, (char const   *)(input + i), & inbytes_left,
                          (char *)(& context->buffer[idx]), & outbytes_left);
  } else {
    memcpy((void * __restrict  )(& context->buffer[idx]), (void const   * __restrict  )(input +
                                                                                        i),
           inputLen - i);
  }
  return (0);
}
}
apr_status_t apr_md4_final(unsigned char *digest , apr_md4_ctx_t *context ) 
{ unsigned char bits[8] ;
  unsigned int idx ;
  unsigned int padLen ;

  {
  Encode(bits, (apr_uint32_t const   *)(context->count), 8U);
  context->xlate = (apr_xlate_t *)((void *)0);
  idx = (context->count[0] >> 3) & 63U;
  if (idx < 56U) {
    padLen = 56U - idx;
  } else {
    padLen = 120U - idx;
  }
  apr_md4_update(context, (unsigned char const   *)(PADDING), padLen);
  apr_md4_update(context, (unsigned char const   *)(bits), 8U);
  Encode(digest, (apr_uint32_t const   *)(context->state), 16U);
  memset((void *)context, 0, sizeof((*context)));
  return (0);
}
}
apr_status_t apr_md4(unsigned char *digest , unsigned char const   *input , apr_size_t inputLen ) 
{ apr_md4_ctx_t ctx ;
  apr_status_t rv ;
  apr_status_t tmp ;

  {
  apr_md4_init(& ctx);
  rv = apr_md4_update(& ctx, input, inputLen);
  if (rv != 0) {
    return (rv);
  }
  tmp = apr_md4_final(digest, & ctx);
  return (tmp);
}
}
static void MD4Transform(apr_uint32_t *state , unsigned char const   *block ) 
{ apr_uint32_t a ;
  apr_uint32_t b ;
  apr_uint32_t c ;
  apr_uint32_t d ;
  apr_uint32_t x[16] ;

  {
  a = (*(state + 0));
  b = (*(state + 1));
  c = (*(state + 2));
  d = (*(state + 3));
  Decode(x, block, 64U);
  a += ((b & c) | (~ b & d)) + x[0];
  a = (a << 3) | (a >> 29);
  d += ((a & b) | (~ a & c)) + x[1];
  d = (d << 7) | (d >> 25);
  c += ((d & a) | (~ d & b)) + x[2];
  c = (c << 11) | (c >> 21);
  b += ((c & d) | (~ c & a)) + x[3];
  b = (b << 19) | (b >> 13);
  a += ((b & c) | (~ b & d)) + x[4];
  a = (a << 3) | (a >> 29);
  d += ((a & b) | (~ a & c)) + x[5];
  d = (d << 7) | (d >> 25);
  c += ((d & a) | (~ d & b)) + x[6];
  c = (c << 11) | (c >> 21);
  b += ((c & d) | (~ c & a)) + x[7];
  b = (b << 19) | (b >> 13);
  a += ((b & c) | (~ b & d)) + x[8];
  a = (a << 3) | (a >> 29);
  d += ((a & b) | (~ a & c)) + x[9];
  d = (d << 7) | (d >> 25);
  c += ((d & a) | (~ d & b)) + x[10];
  c = (c << 11) | (c >> 21);
  b += ((c & d) | (~ c & a)) + x[11];
  b = (b << 19) | (b >> 13);
  a += ((b & c) | (~ b & d)) + x[12];
  a = (a << 3) | (a >> 29);
  d += ((a & b) | (~ a & c)) + x[13];
  d = (d << 7) | (d >> 25);
  c += ((d & a) | (~ d & b)) + x[14];
  c = (c << 11) | (c >> 21);
  b += ((c & d) | (~ c & a)) + x[15];
  b = (b << 19) | (b >> 13);
  a += ((((b & c) | (b & d)) | (c & d)) + x[0]) + 1518500249U;
  a = (a << 3) | (a >> 29);
  d += ((((a & b) | (a & c)) | (b & c)) + x[4]) + 1518500249U;
  d = (d << 5) | (d >> 27);
  c += ((((d & a) | (d & b)) | (a & b)) + x[8]) + 1518500249U;
  c = (c << 9) | (c >> 23);
  b += ((((c & d) | (c & a)) | (d & a)) + x[12]) + 1518500249U;
  b = (b << 13) | (b >> 19);
  a += ((((b & c) | (b & d)) | (c & d)) + x[1]) + 1518500249U;
  a = (a << 3) | (a >> 29);
  d += ((((a & b) | (a & c)) | (b & c)) + x[5]) + 1518500249U;
  d = (d << 5) | (d >> 27);
  c += ((((d & a) | (d & b)) | (a & b)) + x[9]) + 1518500249U;
  c = (c << 9) | (c >> 23);
  b += ((((c & d) | (c & a)) | (d & a)) + x[13]) + 1518500249U;
  b = (b << 13) | (b >> 19);
  a += ((((b & c) | (b & d)) | (c & d)) + x[2]) + 1518500249U;
  a = (a << 3) | (a >> 29);
  d += ((((a & b) | (a & c)) | (b & c)) + x[6]) + 1518500249U;
  d = (d << 5) | (d >> 27);
  c += ((((d & a) | (d & b)) | (a & b)) + x[10]) + 1518500249U;
  c = (c << 9) | (c >> 23);
  b += ((((c & d) | (c & a)) | (d & a)) + x[14]) + 1518500249U;
  b = (b << 13) | (b >> 19);
  a += ((((b & c) | (b & d)) | (c & d)) + x[3]) + 1518500249U;
  a = (a << 3) | (a >> 29);
  d += ((((a & b) | (a & c)) | (b & c)) + x[7]) + 1518500249U;
  d = (d << 5) | (d >> 27);
  c += ((((d & a) | (d & b)) | (a & b)) + x[11]) + 1518500249U;
  c = (c << 9) | (c >> 23);
  b += ((((c & d) | (c & a)) | (d & a)) + x[15]) + 1518500249U;
  b = (b << 13) | (b >> 19);
  a += (((b ^ c) ^ d) + x[0]) + 1859775393U;
  a = (a << 3) | (a >> 29);
  d += (((a ^ b) ^ c) + x[8]) + 1859775393U;
  d = (d << 9) | (d >> 23);
  c += (((d ^ a) ^ b) + x[4]) + 1859775393U;
  c = (c << 11) | (c >> 21);
  b += (((c ^ d) ^ a) + x[12]) + 1859775393U;
  b = (b << 15) | (b >> 17);
  a += (((b ^ c) ^ d) + x[2]) + 1859775393U;
  a = (a << 3) | (a >> 29);
  d += (((a ^ b) ^ c) + x[10]) + 1859775393U;
  d = (d << 9) | (d >> 23);
  c += (((d ^ a) ^ b) + x[6]) + 1859775393U;
  c = (c << 11) | (c >> 21);
  b += (((c ^ d) ^ a) + x[14]) + 1859775393U;
  b = (b << 15) | (b >> 17);
  a += (((b ^ c) ^ d) + x[1]) + 1859775393U;
  a = (a << 3) | (a >> 29);
  d += (((a ^ b) ^ c) + x[9]) + 1859775393U;
  d = (d << 9) | (d >> 23);
  c += (((d ^ a) ^ b) + x[5]) + 1859775393U;
  c = (c << 11) | (c >> 21);
  b += (((c ^ d) ^ a) + x[13]) + 1859775393U;
  b = (b << 15) | (b >> 17);
  a += (((b ^ c) ^ d) + x[3]) + 1859775393U;
  a = (a << 3) | (a >> 29);
  d += (((a ^ b) ^ c) + x[11]) + 1859775393U;
  d = (d << 9) | (d >> 23);
  c += (((d ^ a) ^ b) + x[7]) + 1859775393U;
  c = (c << 11) | (c >> 21);
  b += (((c ^ d) ^ a) + x[15]) + 1859775393U;
  b = (b << 15) | (b >> 17);
  (*(state + 0)) = (*(state + 0)) + a;
  (*(state + 1)) = (*(state + 1)) + b;
  (*(state + 2)) = (*(state + 2)) + c;
  (*(state + 3)) = (*(state + 3)) + d;
  memset((void *)(x), 0, sizeof(x));
  return;
}
}
static void Encode(unsigned char *output , apr_uint32_t const   *input , unsigned int len ) 
{ unsigned int i ;
  unsigned int j ;
  apr_uint32_t k ;

  {
  i = 0U;
  j = 0U;
  while (j < len) {
    k = (*(input + i));
    (*(output + j)) = (unsigned char )(k & 255U);
    (*(output + (j + 1U))) = (unsigned char )((k >> 8) & 255U);
    (*(output + (j + 2U))) = (unsigned char )((k >> 16) & 255U);
    (*(output + (j + 3U))) = (unsigned char )((k >> 24) & 255U);
    i ++;
    j += 4U;
  }
  return;
}
}
static void Decode(apr_uint32_t *output , unsigned char const   *input , unsigned int len ) 
{ unsigned int i ;
  unsigned int j ;

  {
  i = 0U;
  j = 0U;
  while (j < len) {
    (*(output + i)) = (((unsigned int )(*(input + j)) | ((unsigned int )(*(input +
                                                                           (j + 1U))) <<
                                                         8)) | ((unsigned int )(*(input +
                                                                                  (j +
                                                                                   2U))) <<
                                                                16)) | ((unsigned int )(*(input +
                                                                                          (j +
                                                                                           3U))) <<
                                                                        24);
    i ++;
    j += 4U;
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-jDRrf2em.i","-g -pthread")
extern char *crypt(char const   *__key , char const   *__salt ) ;
static void MD5Transform(apr_uint32_t *state , unsigned char const   *block ) ;
static void Encode___0(unsigned char *output , apr_uint32_t const   *input , unsigned int len ) ;
static void Decode___0(apr_uint32_t *output , unsigned char const   *input , unsigned int len ) ;
static unsigned char PADDING___0[64]  = 
  {      (unsigned char)128,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
apr_status_t apr_md5_init(apr_md5_ctx_t *context ) 
{ 

  {
  context->count[1] = 0U;
  context->count[0] = context->count[1];
  context->state[0] = 1732584193U;
  context->state[1] = 4023233417U;
  context->state[2] = 2562383102U;
  context->state[3] = 271733878U;
  context->xlate = (apr_xlate_t *)((void *)0);
  return (0);
}
}
apr_status_t apr_md5_set_xlate(apr_md5_ctx_t *context , apr_xlate_t *xlate ) 
{ apr_status_t rv ;
  int is_sb ;

  {
  rv = apr_xlate_sb_get(xlate, & is_sb);
  if (rv != 0) {
    return (rv);
  }
  if (! is_sb) {
    return (22);
  }
  context->xlate = xlate;
  return (0);
}
}
apr_status_t apr_md5_update(apr_md5_ctx_t *context , unsigned char const   *input ,
                            apr_size_t inputLen ) 
{ unsigned int i ;
  unsigned int idx ;
  unsigned int partLen ;
  apr_size_t inbytes_left ;
  apr_size_t outbytes_left ;
  unsigned char inp_tmp[64] ;

  {
  idx = (context->count[0] >> 3) & 63U;
  context->count[0] = context->count[0] + (inputLen << 3);
  if (context->count[0] < inputLen << 3) {
    context->count[1] = context->count[1] + 1U;
  }
  context->count[1] = context->count[1] + (inputLen >> 29);
  partLen = 64U - idx;
  if (inputLen >= partLen) {
    if (context->xlate) {
      outbytes_left = partLen;
      inbytes_left = outbytes_left;
      apr_xlate_conv_buffer(context->xlate, (char const   *)input, & inbytes_left,
                            (char *)(& context->buffer[idx]), & outbytes_left);
    } else {
      memcpy((void * __restrict  )(& context->buffer[idx]), (void const   * __restrict  )input,
             partLen);
    }
    MD5Transform(context->state, (unsigned char const   *)(context->buffer));
    i = partLen;
    while (i + 63U < inputLen) {
      if (context->xlate) {
        outbytes_left = 64U;
        inbytes_left = outbytes_left;
        apr_xlate_conv_buffer(context->xlate, (char const   *)(input + i), & inbytes_left,
                              (char *)(inp_tmp), & outbytes_left);
        MD5Transform(context->state, (unsigned char const   *)(inp_tmp));
      } else {
        MD5Transform(context->state, input + i);
      }
      i += 64U;
    }
    idx = 0U;
  } else {
    i = 0U;
  }
  if (context->xlate) {
    outbytes_left = inputLen - i;
    inbytes_left = outbytes_left;
    apr_xlate_conv_buffer(context->xlate, (char const   *)(input + i), & inbytes_left,
                          (char *)(& context->buffer[idx]), & outbytes_left);
  } else {
    memcpy((void * __restrict  )(& context->buffer[idx]), (void const   * __restrict  )(input +
                                                                                        i),
           inputLen - i);
  }
  return (0);
}
}
apr_status_t apr_md5_final(unsigned char *digest , apr_md5_ctx_t *context ) 
{ unsigned char bits[8] ;
  unsigned int idx ;
  unsigned int padLen ;

  {
  Encode___0(bits, (apr_uint32_t const   *)(context->count), 8U);
  context->xlate = (apr_xlate_t *)((void *)0);
  idx = (context->count[0] >> 3) & 63U;
  if (idx < 56U) {
    padLen = 56U - idx;
  } else {
    padLen = 120U - idx;
  }
  apr_md5_update(context, (unsigned char const   *)(PADDING___0), padLen);
  apr_md5_update(context, (unsigned char const   *)(bits), 8U);
  Encode___0(digest, (apr_uint32_t const   *)(context->state), 16U);
  memset((void *)context, 0, sizeof((*context)));
  return (0);
}
}
apr_status_t apr_md5(unsigned char *digest , unsigned char const   *input , apr_size_t inputLen ) 
{ apr_md5_ctx_t ctx ;
  apr_status_t rv ;
  apr_status_t tmp ;

  {
  apr_md5_init(& ctx);
  rv = apr_md5_update(& ctx, input, inputLen);
  if (rv != 0) {
    return (rv);
  }
  tmp = apr_md5_final(digest, & ctx);
  return (tmp);
}
}
static void MD5Transform(apr_uint32_t *state , unsigned char const   *block ) 
{ apr_uint32_t a ;
  apr_uint32_t b ;
  apr_uint32_t c ;
  apr_uint32_t d ;
  apr_uint32_t x[16] ;

  {
  a = (*(state + 0));
  b = (*(state + 1));
  c = (*(state + 2));
  d = (*(state + 3));
  Decode___0(x, block, 64U);
  a += (((b & c) | (~ b & d)) + x[0]) + 3614090360U;
  a = (a << 7) | (a >> 25);
  a += b;
  d += (((a & b) | (~ a & c)) + x[1]) + 3905402710U;
  d = (d << 12) | (d >> 20);
  d += a;
  c += (((d & a) | (~ d & b)) + x[2]) + 606105819U;
  c = (c << 17) | (c >> 15);
  c += d;
  b += (((c & d) | (~ c & a)) + x[3]) + 3250441966U;
  b = (b << 22) | (b >> 10);
  b += c;
  a += (((b & c) | (~ b & d)) + x[4]) + 4118548399U;
  a = (a << 7) | (a >> 25);
  a += b;
  d += (((a & b) | (~ a & c)) + x[5]) + 1200080426U;
  d = (d << 12) | (d >> 20);
  d += a;
  c += (((d & a) | (~ d & b)) + x[6]) + 2821735955U;
  c = (c << 17) | (c >> 15);
  c += d;
  b += (((c & d) | (~ c & a)) + x[7]) + 4249261313U;
  b = (b << 22) | (b >> 10);
  b += c;
  a += (((b & c) | (~ b & d)) + x[8]) + 1770035416U;
  a = (a << 7) | (a >> 25);
  a += b;
  d += (((a & b) | (~ a & c)) + x[9]) + 2336552879U;
  d = (d << 12) | (d >> 20);
  d += a;
  c += (((d & a) | (~ d & b)) + x[10]) + 4294925233U;
  c = (c << 17) | (c >> 15);
  c += d;
  b += (((c & d) | (~ c & a)) + x[11]) + 2304563134U;
  b = (b << 22) | (b >> 10);
  b += c;
  a += (((b & c) | (~ b & d)) + x[12]) + 1804603682U;
  a = (a << 7) | (a >> 25);
  a += b;
  d += (((a & b) | (~ a & c)) + x[13]) + 4254626195U;
  d = (d << 12) | (d >> 20);
  d += a;
  c += (((d & a) | (~ d & b)) + x[14]) + 2792965006U;
  c = (c << 17) | (c >> 15);
  c += d;
  b += (((c & d) | (~ c & a)) + x[15]) + 1236535329U;
  b = (b << 22) | (b >> 10);
  b += c;
  a += (((b & d) | (c & ~ d)) + x[1]) + 4129170786U;
  a = (a << 5) | (a >> 27);
  a += b;
  d += (((a & c) | (b & ~ c)) + x[6]) + 3225465664U;
  d = (d << 9) | (d >> 23);
  d += a;
  c += (((d & b) | (a & ~ b)) + x[11]) + 643717713U;
  c = (c << 14) | (c >> 18);
  c += d;
  b += (((c & a) | (d & ~ a)) + x[0]) + 3921069994U;
  b = (b << 20) | (b >> 12);
  b += c;
  a += (((b & d) | (c & ~ d)) + x[5]) + 3593408605U;
  a = (a << 5) | (a >> 27);
  a += b;
  d += (((a & c) | (b & ~ c)) + x[10]) + 38016083U;
  d = (d << 9) | (d >> 23);
  d += a;
  c += (((d & b) | (a & ~ b)) + x[15]) + 3634488961U;
  c = (c << 14) | (c >> 18);
  c += d;
  b += (((c & a) | (d & ~ a)) + x[4]) + 3889429448U;
  b = (b << 20) | (b >> 12);
  b += c;
  a += (((b & d) | (c & ~ d)) + x[9]) + 568446438U;
  a = (a << 5) | (a >> 27);
  a += b;
  d += (((a & c) | (b & ~ c)) + x[14]) + 3275163606U;
  d = (d << 9) | (d >> 23);
  d += a;
  c += (((d & b) | (a & ~ b)) + x[3]) + 4107603335U;
  c = (c << 14) | (c >> 18);
  c += d;
  b += (((c & a) | (d & ~ a)) + x[8]) + 1163531501U;
  b = (b << 20) | (b >> 12);
  b += c;
  a += (((b & d) | (c & ~ d)) + x[13]) + 2850285829U;
  a = (a << 5) | (a >> 27);
  a += b;
  d += (((a & c) | (b & ~ c)) + x[2]) + 4243563512U;
  d = (d << 9) | (d >> 23);
  d += a;
  c += (((d & b) | (a & ~ b)) + x[7]) + 1735328473U;
  c = (c << 14) | (c >> 18);
  c += d;
  b += (((c & a) | (d & ~ a)) + x[12]) + 2368359562U;
  b = (b << 20) | (b >> 12);
  b += c;
  a += (((b ^ c) ^ d) + x[5]) + 4294588738U;
  a = (a << 4) | (a >> 28);
  a += b;
  d += (((a ^ b) ^ c) + x[8]) + 2272392833U;
  d = (d << 11) | (d >> 21);
  d += a;
  c += (((d ^ a) ^ b) + x[11]) + 1839030562U;
  c = (c << 16) | (c >> 16);
  c += d;
  b += (((c ^ d) ^ a) + x[14]) + 4259657740U;
  b = (b << 23) | (b >> 9);
  b += c;
  a += (((b ^ c) ^ d) + x[1]) + 2763975236U;
  a = (a << 4) | (a >> 28);
  a += b;
  d += (((a ^ b) ^ c) + x[4]) + 1272893353U;
  d = (d << 11) | (d >> 21);
  d += a;
  c += (((d ^ a) ^ b) + x[7]) + 4139469664U;
  c = (c << 16) | (c >> 16);
  c += d;
  b += (((c ^ d) ^ a) + x[10]) + 3200236656U;
  b = (b << 23) | (b >> 9);
  b += c;
  a += (((b ^ c) ^ d) + x[13]) + 681279174U;
  a = (a << 4) | (a >> 28);
  a += b;
  d += (((a ^ b) ^ c) + x[0]) + 3936430074U;
  d = (d << 11) | (d >> 21);
  d += a;
  c += (((d ^ a) ^ b) + x[3]) + 3572445317U;
  c = (c << 16) | (c >> 16);
  c += d;
  b += (((c ^ d) ^ a) + x[6]) + 76029189U;
  b = (b << 23) | (b >> 9);
  b += c;
  a += (((b ^ c) ^ d) + x[9]) + 3654602809U;
  a = (a << 4) | (a >> 28);
  a += b;
  d += (((a ^ b) ^ c) + x[12]) + 3873151461U;
  d = (d << 11) | (d >> 21);
  d += a;
  c += (((d ^ a) ^ b) + x[15]) + 530742520U;
  c = (c << 16) | (c >> 16);
  c += d;
  b += (((c ^ d) ^ a) + x[2]) + 3299628645U;
  b = (b << 23) | (b >> 9);
  b += c;
  a += ((c ^ (b | ~ d)) + x[0]) + 4096336452U;
  a = (a << 6) | (a >> 26);
  a += b;
  d += ((b ^ (a | ~ c)) + x[7]) + 1126891415U;
  d = (d << 10) | (d >> 22);
  d += a;
  c += ((a ^ (d | ~ b)) + x[14]) + 2878612391U;
  c = (c << 15) | (c >> 17);
  c += d;
  b += ((d ^ (c | ~ a)) + x[5]) + 4237533241U;
  b = (b << 21) | (b >> 11);
  b += c;
  a += ((c ^ (b | ~ d)) + x[12]) + 1700485571U;
  a = (a << 6) | (a >> 26);
  a += b;
  d += ((b ^ (a | ~ c)) + x[3]) + 2399980690U;
  d = (d << 10) | (d >> 22);
  d += a;
  c += ((a ^ (d | ~ b)) + x[10]) + 4293915773U;
  c = (c << 15) | (c >> 17);
  c += d;
  b += ((d ^ (c | ~ a)) + x[1]) + 2240044497U;
  b = (b << 21) | (b >> 11);
  b += c;
  a += ((c ^ (b | ~ d)) + x[8]) + 1873313359U;
  a = (a << 6) | (a >> 26);
  a += b;
  d += ((b ^ (a | ~ c)) + x[15]) + 4264355552U;
  d = (d << 10) | (d >> 22);
  d += a;
  c += ((a ^ (d | ~ b)) + x[6]) + 2734768916U;
  c = (c << 15) | (c >> 17);
  c += d;
  b += ((d ^ (c | ~ a)) + x[13]) + 1309151649U;
  b = (b << 21) | (b >> 11);
  b += c;
  a += ((c ^ (b | ~ d)) + x[4]) + 4149444226U;
  a = (a << 6) | (a >> 26);
  a += b;
  d += ((b ^ (a | ~ c)) + x[11]) + 3174756917U;
  d = (d << 10) | (d >> 22);
  d += a;
  c += ((a ^ (d | ~ b)) + x[2]) + 718787259U;
  c = (c << 15) | (c >> 17);
  c += d;
  b += ((d ^ (c | ~ a)) + x[9]) + 3951481745U;
  b = (b << 21) | (b >> 11);
  b += c;
  (*(state + 0)) = (*(state + 0)) + a;
  (*(state + 1)) = (*(state + 1)) + b;
  (*(state + 2)) = (*(state + 2)) + c;
  (*(state + 3)) = (*(state + 3)) + d;
  memset((void *)(x), 0, sizeof(x));
  return;
}
}
static void Encode___0(unsigned char *output , apr_uint32_t const   *input , unsigned int len ) 
{ unsigned int i ;
  unsigned int j ;
  apr_uint32_t k ;

  {
  i = 0U;
  j = 0U;
  while (j < len) {
    k = (*(input + i));
    (*(output + j)) = (unsigned char )(k & 255U);
    (*(output + (j + 1U))) = (unsigned char )((k >> 8) & 255U);
    (*(output + (j + 2U))) = (unsigned char )((k >> 16) & 255U);
    (*(output + (j + 3U))) = (unsigned char )((k >> 24) & 255U);
    i ++;
    j += 4U;
  }
  return;
}
}
static void Decode___0(apr_uint32_t *output , unsigned char const   *input , unsigned int len ) 
{ unsigned int i ;
  unsigned int j ;

  {
  i = 0U;
  j = 0U;
  while (j < len) {
    (*(output + i)) = (((unsigned int )(*(input + j)) | ((unsigned int )(*(input +
                                                                           (j + 1U))) <<
                                                         8)) | ((unsigned int )(*(input +
                                                                                  (j +
                                                                                   2U))) <<
                                                                16)) | ((unsigned int )(*(input +
                                                                                          (j +
                                                                                           3U))) <<
                                                                        24);
    i ++;
    j += 4U;
  }
  return;
}
}
static char const   *apr1_id  =    "$apr1$";
static void to64(char *s , unsigned long v , int n ) ;
static unsigned char itoa64[65]  = 
  {      (unsigned char )'.',      (unsigned char )'/',      (unsigned char )'0',      (unsigned char )'1', 
        (unsigned char )'2',      (unsigned char )'3',      (unsigned char )'4',      (unsigned char )'5', 
        (unsigned char )'6',      (unsigned char )'7',      (unsigned char )'8',      (unsigned char )'9', 
        (unsigned char )'A',      (unsigned char )'B',      (unsigned char )'C',      (unsigned char )'D', 
        (unsigned char )'E',      (unsigned char )'F',      (unsigned char )'G',      (unsigned char )'H', 
        (unsigned char )'I',      (unsigned char )'J',      (unsigned char )'K',      (unsigned char )'L', 
        (unsigned char )'M',      (unsigned char )'N',      (unsigned char )'O',      (unsigned char )'P', 
        (unsigned char )'Q',      (unsigned char )'R',      (unsigned char )'S',      (unsigned char )'T', 
        (unsigned char )'U',      (unsigned char )'V',      (unsigned char )'W',      (unsigned char )'X', 
        (unsigned char )'Y',      (unsigned char )'Z',      (unsigned char )'a',      (unsigned char )'b', 
        (unsigned char )'c',      (unsigned char )'d',      (unsigned char )'e',      (unsigned char )'f', 
        (unsigned char )'g',      (unsigned char )'h',      (unsigned char )'i',      (unsigned char )'j', 
        (unsigned char )'k',      (unsigned char )'l',      (unsigned char )'m',      (unsigned char )'n', 
        (unsigned char )'o',      (unsigned char )'p',      (unsigned char )'q',      (unsigned char )'r', 
        (unsigned char )'s',      (unsigned char )'t',      (unsigned char )'u',      (unsigned char )'v', 
        (unsigned char )'w',      (unsigned char )'x',      (unsigned char )'y',      (unsigned char )'z', 
        (unsigned char )'\000'};
static void to64(char *s , unsigned long v , int n ) 
{ char *tmp ;

  {
  while (1) {
    n --;
    if (! (n >= 0)) {
      break;
    }
    tmp = s;
    s ++;
    (*tmp) = (char )itoa64[v & 63UL];
    v >>= 6;
  }
  return;
}
}
apr_status_t apr_md5_encode(char const   *pw , char const   *salt , char *result ,
                            apr_size_t nbytes ) 
{ char passwd[120] ;
  char *p ;
  char const   *sp ;
  char const   *ep ;
  unsigned char final[16] ;
  apr_ssize_t sl ;
  apr_ssize_t pl ;
  apr_ssize_t i ;
  apr_md5_ctx_t ctx ;
  apr_md5_ctx_t ctx1 ;
  unsigned long l ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  apr_size_t tmp___2 ;
  apr_size_t tmp___3 ;
  apr_size_t tmp___4 ;
  apr_size_t tmp___5 ;
  int tmp___6 ;
  apr_size_t tmp___7 ;
  apr_size_t tmp___8 ;
  apr_size_t tmp___9 ;
  size_t tmp___10 ;

  {
  sp = salt;
  tmp___0 = strlen(apr1_id);
  tmp___1 = strncmp(sp, apr1_id, tmp___0);
  if (! tmp___1) {
    tmp = strlen(apr1_id);
    sp += tmp;
  }
  ep = sp;
  while (1) {
    if ((int const   )(*ep) != 0) {
      if ((int const   )(*ep) != 36) {
        if (! ((unsigned int )ep < (unsigned int )(sp + 8))) {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      break;
    }
    goto __Cont;
    __Cont: 
    ep ++;
  }
  sl = ep - sp;
  apr_md5_init(& ctx);
  tmp___2 = strlen(pw);
  apr_md5_update(& ctx, (unsigned char const   *)((unsigned char *)pw), tmp___2);
  tmp___3 = strlen(apr1_id);
  apr_md5_update(& ctx, (unsigned char const   *)((unsigned char *)apr1_id), tmp___3);
  apr_md5_update(& ctx, (unsigned char const   *)((unsigned char *)sp), (unsigned int )sl);
  apr_md5_init(& ctx1);
  tmp___4 = strlen(pw);
  apr_md5_update(& ctx1, (unsigned char const   *)((unsigned char *)pw), tmp___4);
  apr_md5_update(& ctx1, (unsigned char const   *)((unsigned char *)sp), (unsigned int )sl);
  tmp___5 = strlen(pw);
  apr_md5_update(& ctx1, (unsigned char const   *)((unsigned char *)pw), tmp___5);
  apr_md5_final(final, & ctx1);
  pl = (apr_ssize_t )strlen(pw);
  while (pl > 0) {
    if (pl > 16) {
      tmp___6 = 16;
    } else {
      tmp___6 = pl;
    }
    apr_md5_update(& ctx, (unsigned char const   *)(final), (unsigned int )tmp___6);
    pl -= 16;
  }
  memset((void *)(final), 0, sizeof(final));
  i = (apr_ssize_t )strlen(pw);
  while (i != 0) {
    if (i & 1) {
      apr_md5_update(& ctx, (unsigned char const   *)(final), 1U);
    } else {
      apr_md5_update(& ctx, (unsigned char const   *)((unsigned char *)pw), 1U);
    }
    i >>= 1;
  }
  strcpy((char * __restrict  )(passwd), (char const   * __restrict  )apr1_id);
  strncat((char * __restrict  )(passwd), (char const   * __restrict  )sp, (unsigned int )sl);
  strcat((char * __restrict  )(passwd), (char const   * __restrict  )"$");
  apr_md5_final(final, & ctx);
  i = 0;
  while (i < 1000) {
    apr_md5_init(& ctx1);
    if (i & 1) {
      tmp___7 = strlen(pw);
      apr_md5_update(& ctx1, (unsigned char const   *)((unsigned char *)pw), tmp___7);
    } else {
      apr_md5_update(& ctx1, (unsigned char const   *)(final), 16U);
    }
    if (i % 3) {
      apr_md5_update(& ctx1, (unsigned char const   *)((unsigned char *)sp), (unsigned int )sl);
    }
    if (i % 7) {
      tmp___8 = strlen(pw);
      apr_md5_update(& ctx1, (unsigned char const   *)((unsigned char *)pw), tmp___8);
    }
    if (i & 1) {
      apr_md5_update(& ctx1, (unsigned char const   *)(final), 16U);
    } else {
      tmp___9 = strlen(pw);
      apr_md5_update(& ctx1, (unsigned char const   *)((unsigned char *)pw), tmp___9);
    }
    apr_md5_final(final, & ctx1);
    i ++;
  }
  tmp___10 = strlen((char const   *)(passwd));
  p = passwd + tmp___10;
  l = (unsigned long )((((int )final[0] << 16) | ((int )final[6] << 8)) | (int )final[12]);
  to64(p, l, 4);
  p += 4;
  l = (unsigned long )((((int )final[1] << 16) | ((int )final[7] << 8)) | (int )final[13]);
  to64(p, l, 4);
  p += 4;
  l = (unsigned long )((((int )final[2] << 16) | ((int )final[8] << 8)) | (int )final[14]);
  to64(p, l, 4);
  p += 4;
  l = (unsigned long )((((int )final[3] << 16) | ((int )final[9] << 8)) | (int )final[15]);
  to64(p, l, 4);
  p += 4;
  l = (unsigned long )((((int )final[4] << 16) | ((int )final[10] << 8)) | (int )final[5]);
  to64(p, l, 4);
  p += 4;
  l = (unsigned long )final[11];
  to64(p, l, 2);
  p += 2;
  (*p) = (char )'\000';
  memset((void *)(final), 0, sizeof(final));
  apr_cpystrn(result, (char const   *)(passwd), nbytes - 1U);
  return (0);
}
}
apr_status_t apr_password_validate(char const   *passwd , char const   *hash ) 
{ char sample[120] ;
  char *crypt_pw ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = strlen(apr1_id);
  tmp___0 = strncmp(hash, apr1_id, tmp);
  if (tmp___0) {
    crypt_pw = crypt(passwd, hash);
    apr_cpystrn(sample, (char const   *)crypt_pw, sizeof(sample) - 1U);
  } else {
    apr_md5_encode(passwd, hash, sample, sizeof(sample));
  }
  tmp___3 = strcmp((char const   *)(sample), hash);
  if (tmp___3 == 0) {
    tmp___2 = 0;
  } else {
    tmp___2 = 70024;
  }
  return (tmp___2);
}
}
#pragma merger(0,"/tmp/cil-lDy1uCdd.i","-g -pthread")
void apr_uuid_format(char *buffer , apr_uuid_t const   *uuid ) 
{ unsigned char const   *d ;

  {
  d = (unsigned char const   *)(uuid->data);
  sprintf((char * __restrict  )buffer, (char const   * __restrict  )"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
          (*(d + 0)), (*(d + 1)), (*(d + 2)), (*(d + 3)), (*(d + 4)), (*(d + 5)),
          (*(d + 6)), (*(d + 7)), (*(d + 8)), (*(d + 9)), (*(d + 10)), (*(d + 11)),
          (*(d + 12)), (*(d + 13)), (*(d + 14)), (*(d + 15)));
  return;
}
}
static unsigned char parse_hexpair(char const   *s ) 
{ int result ;
  int temp ;

  {
  result = (int )((int const   )(*(s + 0)) - 48);
  if (result > 48) {
    result = (result - 39) << 4;
  } else {
    if (result > 16) {
      result = (result - 7) << 4;
    } else {
      result = result << 4;
    }
  }
  temp = (int )((int const   )(*(s + 1)) - 48);
  if (temp > 48) {
    result |= temp - 39;
  } else {
    if (temp > 16) {
      result |= temp - 7;
    } else {
      result |= temp;
    }
  }
  return ((unsigned char )result);
}
}
apr_status_t apr_uuid_parse(apr_uuid_t *uuid , char const   *uuid_str ) 
{ int i ;
  unsigned char *d ;
  char c ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  d = uuid->data;
  i = 0;
  while (i < 36) {
    c = (char )(*(uuid_str + i));
    tmp = __ctype_b_loc();
    if ((int const   )(*((*tmp) + (int )((unsigned char )c))) & 4096) {
      _L: ;
    } else {
      if ((int )c == 45) {
        if (i == 8) {
          goto _L___3;
        } else {
          if (i == 13) {
            _L___3: 
            goto _L___2;
          } else {
            if (i == 18) {
              _L___2: 
              goto _L___1;
            } else {
              if (i == 23) {
                _L___1: 
                goto _L;
              } else {
                goto _L___0;
              }
            }
          }
        }
      } else {
        _L___0: 
        return (70013);
      }
    }
    i ++;
  }
  if ((int const   )(*(uuid_str + 36)) != 0) {
    return (70013);
  }
  (*(d + 0)) = parse_hexpair(uuid_str + 0);
  (*(d + 1)) = parse_hexpair(uuid_str + 2);
  (*(d + 2)) = parse_hexpair(uuid_str + 4);
  (*(d + 3)) = parse_hexpair(uuid_str + 6);
  (*(d + 4)) = parse_hexpair(uuid_str + 9);
  (*(d + 5)) = parse_hexpair(uuid_str + 11);
  (*(d + 6)) = parse_hexpair(uuid_str + 14);
  (*(d + 7)) = parse_hexpair(uuid_str + 16);
  (*(d + 8)) = parse_hexpair(uuid_str + 19);
  (*(d + 9)) = parse_hexpair(uuid_str + 21);
  i = 6;
  while (1) {
    tmp___0 = i;
    i --;
    if (! tmp___0) {
      break;
    }
    (*(d + (10 + i))) = parse_hexpair(uuid_str + (i * 2 + 24));
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-QLmlW3Nz.i","-g -pthread")
extern int rand(void) ;
extern void srand(unsigned int __seed ) ;
static int uuid_state_seqnum  ;
static unsigned char uuid_state_node[6]  = {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
static void get_random_info(unsigned char *node ) 
{ 

  {
  apr_generate_random_bytes(node, 6);
  return;
}
}
static void get_pseudo_node_identifier(unsigned char *node ) 
{ 

  {
  get_random_info(node);
  (*(node + 0)) = (unsigned char )((int )(*(node + 0)) | 128);
  return;
}
}
static void get_system_time(apr_uint64_t *uuid_time ) 
{ 

  {
  (*uuid_time) = (apr_uint64_t )apr_time_now();
  (*uuid_time) = (*uuid_time) * 10ULL + 122192928000000000ULL;
  return;
}
}
static int true_random(void) 
{ apr_uint64_t time_now ;
  unsigned char buf[2] ;
  apr_status_t tmp ;
  int tmp___0 ;

  {
  tmp = apr_generate_random_bytes(buf, 2);
  if (tmp == 0) {
    return (((int )buf[0] << 8) | (int )buf[1]);
  }
  get_system_time(& time_now);
  srand((unsigned int )(((time_now >> 32) ^ time_now) & 4294967295ULL));
  tmp___0 = rand();
  return (tmp___0 & 65535);
}
}
static void init_state(void) 
{ 

  {
  uuid_state_seqnum = true_random();
  get_pseudo_node_identifier(uuid_state_node);
  return;
}
}
static void get_current_time(apr_uint64_t *timestamp ) ;
static long long time_last  =    0LL;
static long long fudge  =    0LL;
static void get_current_time(apr_uint64_t *timestamp ) 
{ apr_time_t time_now ;

  {
  time_now = apr_time_now();
  if (time_last != time_now) {
    if (time_last + fudge > time_now) {
      fudge = ((time_last + fudge) - time_now) + 1LL;
    } else {
      fudge = 0LL;
    }
    time_last = time_now;
  } else {
    fudge ++;
  }
  (*timestamp) = (unsigned long long )(time_now + fudge);
  return;
}
}
void apr_uuid_get(apr_uuid_t *uuid ) 
{ apr_uint64_t timestamp ;
  unsigned char *d ;

  {
  d = uuid->data;
  if (! uuid_state_node[0]) {
    init_state();
  }
  get_current_time(& timestamp);
  (*(d + 0)) = (unsigned char )timestamp;
  (*(d + 1)) = (unsigned char )(timestamp >> 8);
  (*(d + 2)) = (unsigned char )(timestamp >> 16);
  (*(d + 3)) = (unsigned char )(timestamp >> 24);
  (*(d + 4)) = (unsigned char )(timestamp >> 32);
  (*(d + 5)) = (unsigned char )(timestamp >> 40);
  (*(d + 6)) = (unsigned char )(timestamp >> 48);
  (*(d + 7)) = (unsigned char )(((timestamp >> 56) & 15ULL) | 16ULL);
  (*(d + 8)) = (unsigned char )(((uuid_state_seqnum >> 8) & 63) | 128);
  (*(d + 9)) = (unsigned char )uuid_state_seqnum;
  memcpy((void * __restrict  )(d + 10), (void const   * __restrict  )(uuid_state_node),
         6U);
  return;
}
}
#pragma merger(0,"/tmp/cil-2nv7zK2j.i","-g -pthread")
int sdbm__fitpair(char *pag , int need ) ;
void sdbm__putpair(char *pag , apr_sdbm_datum_t key , apr_sdbm_datum_t val ) ;
apr_sdbm_datum_t sdbm__getpair(char *pag , apr_sdbm_datum_t key ) ;
int sdbm__delpair(char *pag , apr_sdbm_datum_t key ) ;
int sdbm__chkpage(char *pag ) ;
apr_sdbm_datum_t sdbm__getnkey(char *pag , int num ) ;
void sdbm__splpage(char *pag , char *new , long sbit ) ;
int sdbm__duppair(char *pag , apr_sdbm_datum_t key ) ;
struct __anonstruct_apr_sdbm_datum_t_105  const  sdbm_nullitem ;
long sdbm_hash(char const   *str , int len ) ;
static int getdbit(apr_sdbm_t *db , long dbit ) ;
static apr_status_t setdbit(apr_sdbm_t *db , long dbit ) ;
static apr_status_t getpage(apr_sdbm_t *db , long hash ) ;
static apr_status_t getnext(apr_sdbm_datum_t *key , apr_sdbm_t *db ) ;
static apr_status_t makroom(apr_sdbm_t *db , long hash , int need ) ;
static long masks[32]  = 
  {      0L,      1L,      3L,      7L, 
        15L,      31L,      63L,      127L, 
        255L,      511L,      1023L,      2047L, 
        4095L,      8191L,      16383L,      32767L, 
        65535L,      131071L,      262143L,      524287L, 
        1048575L,      2097151L,      4194303L,      8388607L, 
        16777215L,      33554431L,      67108863L,      134217727L, 
        268435455L,      536870911L,      1073741823L,      2147483647L};
struct __anonstruct_apr_sdbm_datum_t_105  const  sdbm_nullitem  =    {(char *)((void *)0), 0};
static apr_status_t database_cleanup(void *data ) 
{ apr_sdbm_t *db ;

  {
  db = (apr_sdbm_t *)data;
  if (db->flags & 12) {
    apr_file_unlock(db->dirf);
  }
  apr_file_close(db->dirf);
  apr_file_close(db->pagf);
  free((void *)db);
  return (0);
}
}
static apr_status_t prep(apr_sdbm_t **pdb , char const   *dirname , char const   *pagname ,
                         apr_int32_t flags , apr_fileperms_t perms , apr_pool_t *p ) 
{ apr_sdbm_t *db ;
  apr_status_t status ;
  int tmp ;

  {
  (*pdb) = (apr_sdbm_t *)((void *)0);
  db = (apr_sdbm_t *)malloc(sizeof((*db)));
  memset((void *)db, 0, sizeof((*db)));
  db->pool = p;
  if (! (flags & 2)) {
    db->flags |= 1;
  }
  if (flags & 1024) {
    db->flags |= 2;
    flags &= -1025;
  }
  flags |= 33;
  status = apr_file_open(& db->dirf, dirname, flags, perms, p);
  if (status != 0) {
    goto error;
  }
  status = apr_file_open(& db->pagf, pagname, flags, perms, p);
  if (status != 0) {
    goto error;
  }
  if (db->flags & 1) {
    tmp = 1;
  } else {
    tmp = 2;
  }
  status = apr_sdbm_lock(db, tmp);
  if (status != 0) {
    goto error;
  }
  if (db->flags & 2) {
    status = apr_sdbm_unlock(db);
    if (status != 0) {
      goto error;
    }
  }
  apr_pool_cleanup_register(p, (void const   *)db, & database_cleanup, & apr_pool_cleanup_null);
  (*pdb) = db;
  return (0);
  error: 
  if (db->dirf) {
    if (db->pagf) {
      apr_sdbm_unlock(db);
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if ((unsigned int )db->dirf != (unsigned int )((void *)0)) {
    apr_file_close(db->dirf);
  }
  if ((unsigned int )db->pagf != (unsigned int )((void *)0)) {
    apr_file_close(db->pagf);
  }
  free((void *)db);
  return (status);
}
}
apr_status_t apr_sdbm_open(apr_sdbm_t **db , char const   *file , apr_int32_t flags ,
                           apr_fileperms_t perms , apr_pool_t *p ) 
{ char *dirname ;
  char *tmp ;
  char *pagname ;
  char *tmp___0 ;
  apr_status_t tmp___1 ;

  {
  tmp = apr_pstrcat(p, file, ".dir", (void *)0);
  dirname = tmp;
  tmp___0 = apr_pstrcat(p, file, ".pag", (void *)0);
  pagname = tmp___0;
  tmp___1 = prep(db, (char const   *)dirname, (char const   *)pagname, flags, perms,
                 p);
  return (tmp___1);
}
}
apr_status_t apr_sdbm_close(apr_sdbm_t *db ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_cleanup_run(db->pool, (void *)db, & database_cleanup);
  return (tmp);
}
}
apr_status_t apr_sdbm_fetch(apr_sdbm_t *db , apr_sdbm_datum_t *val , apr_sdbm_datum_t key ) 
{ apr_status_t status ;
  long tmp ;

  {
  if ((unsigned int )db == (unsigned int )((void *)0)) {
    goto _L___0;
  } else {
    if ((unsigned int )key.dptr == (unsigned int )((void *)0)) {
      goto _L___0;
    } else {
      if (key.dsize <= 0) {
        _L___0: 
        return (22);
      }
    }
  }
  status = apr_sdbm_lock(db, 1);
  if (status != 0) {
    return (status);
  }
  tmp = sdbm_hash((char const   *)key.dptr, key.dsize);
  status = getpage(db, tmp);
  if (status == 0) {
    (*val) = sdbm__getpair(db->pagbuf, key);
  }
  apr_sdbm_unlock(db);
  return (status);
}
}
static apr_status_t write_page(apr_sdbm_t *db , char const   *buf , long pagno ) 
{ apr_status_t status ;
  apr_off_t off ;

  {
  off = pagno * 1024L;
  status = apr_file_seek(db->pagf, 0, & off);
  if (status == 0) {
    status = apr_file_write_full(db->pagf, (void const   *)buf, 1024U, (apr_size_t *)((void *)0));
  }
  return (status);
}
}
apr_status_t apr_sdbm_delete(apr_sdbm_t *db , apr_sdbm_datum_t key ) 
{ apr_status_t status ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  if ((unsigned int )db == (unsigned int )((void *)0)) {
    goto _L___0;
  } else {
    if ((unsigned int )key.dptr == (unsigned int )((void *)0)) {
      goto _L___0;
    } else {
      if (key.dsize <= 0) {
        _L___0: 
        return (22);
      }
    }
  }
  tmp = apr_sdbm_rdonly(db);
  if (tmp) {
    return (22);
  }
  status = apr_sdbm_lock(db, 2);
  if (status != 0) {
    return (status);
  }
  tmp___1 = sdbm_hash((char const   *)key.dptr, key.dsize);
  status = getpage(db, tmp___1);
  if (status == 0) {
    tmp___0 = sdbm__delpair(db->pagbuf, key);
    if (tmp___0) {
      status = write_page(db, (char const   *)(db->pagbuf), db->pagbno);
    } else {
      status = 20014;
    }
  }
  apr_sdbm_unlock(db);
  return (status);
}
}
apr_status_t apr_sdbm_store(apr_sdbm_t *db , apr_sdbm_datum_t key , apr_sdbm_datum_t val ,
                            int flags ) 
{ int need ;
  register long hash ;
  apr_status_t status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned int )db == (unsigned int )((void *)0)) {
    goto _L___0;
  } else {
    if ((unsigned int )key.dptr == (unsigned int )((void *)0)) {
      goto _L___0;
    } else {
      if (key.dsize <= 0) {
        _L___0: 
        return (22);
      }
    }
  }
  tmp = apr_sdbm_rdonly(db);
  if (tmp) {
    return (22);
  }
  need = key.dsize + val.dsize;
  if (need < 0) {
    goto _L___1;
  } else {
    if (need > 1008) {
      _L___1: 
      return (22);
    }
  }
  status = apr_sdbm_lock(db, 2);
  if (status != 0) {
    return (status);
  }
  hash = sdbm_hash((char const   *)key.dptr, key.dsize);
  status = getpage(db, hash);
  if (status == 0) {
    if (flags == 1) {
      sdbm__delpair(db->pagbuf, key);
    } else {
      if (! (flags & 2)) {
        tmp___0 = sdbm__duppair(db->pagbuf, key);
        if (tmp___0) {
          status = 17;
          goto error;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: ;
      }
    }
    tmp___1 = sdbm__fitpair(db->pagbuf, need);
    if (! tmp___1) {
      status = makroom(db, hash, need);
      if (status != 0) {
        goto error;
      }
    }
    sdbm__putpair(db->pagbuf, key, val);
    status = write_page(db, (char const   *)(db->pagbuf), db->pagbno);
  }
  error: 
  apr_sdbm_unlock(db);
  return (status);
}
}
static apr_status_t makroom(apr_sdbm_t *db , long hash , int need ) 
{ long newp ;
  char twin[1024] ;
  char *pag ;
  char *new ;
  register int smax ;
  apr_status_t status ;
  int tmp ;
  int tmp___0 ;

  {
  pag = db->pagbuf;
  new = twin;
  smax = 10;
  while (1) {
    sdbm__splpage(pag, new, db->hmask + 1L);
    newp = (hash & db->hmask) | (db->hmask + 1L);
    if (hash & (db->hmask + 1L)) {
      status = write_page(db, (char const   *)(db->pagbuf), db->pagbno);
      if (status != 0) {
        return (status);
      }
      db->pagbno = newp;
      memcpy((void * __restrict  )pag, (void const   * __restrict  )new, 1024U);
    } else {
      status = write_page(db, (char const   *)new, newp);
      if (status != 0) {
        return (status);
      }
    }
    status = setdbit(db, db->curbit);
    if (status != 0) {
      return (status);
    }
    tmp = sdbm__fitpair(pag, need);
    if (tmp) {
      return (0);
    }
    if (hash & (db->hmask + 1L)) {
      tmp___0 = 2;
    } else {
      tmp___0 = 1;
    }
    db->curbit = 2L * db->curbit + (long )tmp___0;
    db->hmask |= db->hmask + 1L;
    status = write_page(db, (char const   *)(db->pagbuf), db->pagbno);
    if (status != 0) {
      return (status);
    }
    smax --;
    if (! smax) {
      break;
    }
  }
  return (28);
}
}
static apr_status_t read_from(apr_file_t *f , void *buf , apr_off_t off , apr_size_t len ) 
{ apr_status_t status ;

  {
  status = apr_file_seek(f, 0, & off);
  if (status != 0) {
    goto _L;
  } else {
    status = apr_file_read_full(f, buf, len, (apr_size_t *)((void *)0));
    if (status != 0) {
      _L: 
      if (status == 70014) {
        memset(buf, 0, len);
        status = 0;
      }
    }
  }
  return (status);
}
}
apr_status_t apr_sdbm_firstkey(apr_sdbm_t *db , apr_sdbm_datum_t *key ) 
{ apr_status_t status ;

  {
  status = apr_sdbm_lock(db, 1);
  if (status != 0) {
    return (status);
  }
  status = read_from(db->pagf, (void *)(db->pagbuf), 0L, 1024U);
  if (status == 0) {
    db->pagbno = 0L;
    db->blkptr = 0L;
    db->keyptr = 0;
    status = getnext(key, db);
  }
  apr_sdbm_unlock(db);
  return (status);
}
}
apr_status_t apr_sdbm_nextkey(apr_sdbm_t *db , apr_sdbm_datum_t *key ) 
{ apr_status_t status ;

  {
  status = apr_sdbm_lock(db, 1);
  if (status != 0) {
    return (status);
  }
  status = getnext(key, db);
  apr_sdbm_unlock(db);
  return (status);
}
}
static apr_status_t getpage(apr_sdbm_t *db , long hash ) 
{ register int hbit ;
  register long dbit ;
  register long pagb ;
  apr_status_t status ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  dbit = 0L;
  hbit = 0;
  while (1) {
    if (dbit < db->maxbno) {
      tmp___2 = getdbit(db, dbit);
      if (! tmp___2) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
    tmp___1 = hbit;
    hbit ++;
    if (hash & (long )(1 << tmp___1)) {
      tmp___0 = 2;
    } else {
      tmp___0 = 1;
    }
    dbit = 2L * dbit + (long )tmp___0;
  }
  db->curbit = dbit;
  db->hmask = masks[hbit];
  pagb = hash & db->hmask;
  if (pagb != db->pagbno) {
    status = read_from(db->pagf, (void *)(db->pagbuf), pagb * 1024L, 1024U);
    if (status != 0) {
      return (status);
    }
    tmp___3 = sdbm__chkpage(db->pagbuf);
    if (! tmp___3) {
      return (28);
    }
    db->pagbno = pagb;
  }
  return (0);
}
}
static int getdbit(apr_sdbm_t *db , long dbit ) 
{ register long c ;
  register long dirb ;
  apr_status_t tmp ;

  {
  c = dbit / 8L;
  dirb = c / 4096L;
  if (dirb != db->dirbno) {
    tmp = read_from(db->dirf, (void *)(db->dirbuf), dirb * 4096L, 4096U);
    if (tmp != 0) {
      return (0);
    }
    db->dirbno = dirb;
  }
  return ((int )db->dirbuf[c % 4096L] & (1 << dbit % 8L));
}
}
static apr_status_t setdbit(apr_sdbm_t *db , long dbit ) 
{ register long c ;
  register long dirb ;
  apr_status_t status ;
  apr_off_t off ;

  {
  c = dbit / 8L;
  dirb = c / 4096L;
  if (dirb != db->dirbno) {
    status = read_from(db->dirf, (void *)(db->dirbuf), dirb * 4096L, 4096U);
    if (status != 0) {
      return (status);
    }
    db->dirbno = dirb;
  }
  db->dirbuf[c % 4096L] = (char )((int )db->dirbuf[c % 4096L] | (1 << dbit % 8L));
  if (dbit >= db->maxbno) {
    db->maxbno += 32768L;
  }
  off = dirb * 4096L;
  status = apr_file_seek(db->dirf, 0, & off);
  if (status == 0) {
    status = apr_file_write_full(db->dirf, (void const   *)(db->dirbuf), 4096U, (apr_size_t *)((void *)0));
  }
  return (status);
}
}
static apr_status_t getnext(apr_sdbm_datum_t *key , apr_sdbm_t *db ) 
{ apr_status_t status ;
  apr_off_t off ;
  apr_status_t tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  while (1) {
    db->keyptr ++;
    (*key) = sdbm__getnkey(db->pagbuf, db->keyptr);
    if ((unsigned int )key->dptr != (unsigned int )((void *)0)) {
      return (0);
    }
    db->keyptr = 0;
    tmp___0 = db->blkptr;
    db->blkptr ++;
    if (db->pagbno != tmp___0) {
      off = db->blkptr * 1024L;
      tmp = apr_file_seek(db->pagf, 0, & off);
      status = tmp != 0;
      if (status) {
        return (status);
      }
    }
    db->pagbno = db->blkptr;
    status = apr_file_read_full(db->pagf, (void *)(db->pagbuf), 1024U, (apr_size_t *)((void *)0));
    if (status != 0) {
      return (status);
    }
    tmp___1 = sdbm__chkpage(db->pagbuf);
    if (! tmp___1) {
      return (20014);
    }
  }
  return (0);
}
}
int apr_sdbm_rdonly(apr_sdbm_t *db ) 
{ 

  {
  return ((db->flags & 1) != 0);
}
}
#pragma merger(0,"/tmp/cil-hSKU0g3Y.i","-g -pthread")
long sdbm_hash(char const   *str , int len ) 
{ register unsigned long n ;
  register int loop ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;

  {
  n = 0UL;
  if (len > 0) {
    loop = ((len + 8) - 1) >> 3;
    switch (len & 7) {
    case 0: ;
    while (1) {
      tmp = str;
      str ++;
      n = (unsigned long )(*tmp) + 65599UL * n;
      case 7: 
      tmp___0 = str;
      str ++;
      n = (unsigned long )(*tmp___0) + 65599UL * n;
      case 6: 
      tmp___1 = str;
      str ++;
      n = (unsigned long )(*tmp___1) + 65599UL * n;
      case 5: 
      tmp___2 = str;
      str ++;
      n = (unsigned long )(*tmp___2) + 65599UL * n;
      case 4: 
      tmp___3 = str;
      str ++;
      n = (unsigned long )(*tmp___3) + 65599UL * n;
      case 3: 
      tmp___4 = str;
      str ++;
      n = (unsigned long )(*tmp___4) + 65599UL * n;
      case 2: 
      tmp___5 = str;
      str ++;
      n = (unsigned long )(*tmp___5) + 65599UL * n;
      case 1: 
      tmp___6 = str;
      str ++;
      n = (unsigned long )(*tmp___6) + 65599UL * n;
      loop --;
      if (! loop) {
        break;
      }
    }
    }
  }
  return ((long )n);
}
}
#pragma merger(0,"/tmp/cil-e6emeXs4.i","-g -pthread")
apr_status_t apr_sdbm_lock(apr_sdbm_t *db , int type ) 
{ apr_status_t status ;
  apr_finfo_t finfo ;

  {
  if (type == 1) {
    goto _L;
  } else {
    if (type == 2) {
      _L: ;
    } else {
      return (22);
    }
  }
  if (db->flags & 8) {
    db->lckcnt = db->lckcnt + 1;
    return (0);
  } else {
    if (db->flags & 4) {
      if (type == 2) {
        return (22);
      }
      db->lckcnt = db->lckcnt + 1;
      return (0);
    }
  }
  status = apr_file_lock(db->dirf, type);
  if (status == 0) {
    status = apr_file_info_get(& finfo, 256, db->dirf);
    if (status != 0) {
      apr_file_unlock(db->dirf);
      return (status);
    }
    while (1) {
      if (! finfo.size) {
        db->dirbno = 0L;
      } else {
        db->dirbno = -1L;
      }
      db->pagbno = -1L;
      db->maxbno = finfo.size * 8L;
      break;
    }
    db->lckcnt = db->lckcnt + 1;
    if (type == 1) {
      db->flags = db->flags | 4;
    } else {
      if (type == 2) {
        db->flags = db->flags | 8;
      }
    }
  }
  return (status);
}
}
apr_status_t apr_sdbm_unlock(apr_sdbm_t *db ) 
{ apr_status_t tmp ;

  {
  if (! (db->flags & 12)) {
    return (22);
  }
  db->lckcnt = db->lckcnt - 1;
  if (db->lckcnt > 0) {
    return (0);
  }
  db->flags = db->flags & -13;
  tmp = apr_file_unlock(db->dirf);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-8WypKCOp.i","-g -pthread")
static int seepair(char *pag , int n , char *key , int siz ) ;
int sdbm__fitpair(char *pag , int need ) 
{ register int n ;
  register int off ;
  register int avail ;
  register short *ino ;

  {
  ino = (short *)pag;
  n = (int )(*(ino + 0));
  if (n > 0) {
    off = (int )(*(ino + n));
  } else {
    off = 1024;
  }
  avail = (int )((unsigned int )off - (unsigned int )(n + 1) * sizeof(short ));
  need = (int )((unsigned int )need + 2U * sizeof(short ));
  return (need <= avail);
}
}
void sdbm__putpair(char *pag , apr_sdbm_datum_t key , apr_sdbm_datum_t val ) 
{ register int n ;
  register int off ;
  register short *ino ;

  {
  ino = (short *)pag;
  n = (int )(*(ino + 0));
  if (n > 0) {
    off = (int )(*(ino + n));
  } else {
    off = 1024;
  }
  off -= key.dsize;
  memcpy((void * __restrict  )(pag + off), (void const   * __restrict  )key.dptr,
         (unsigned int )key.dsize);
  (*(ino + (n + 1))) = (short )off;
  off -= val.dsize;
  memcpy((void * __restrict  )(pag + off), (void const   * __restrict  )val.dptr,
         (unsigned int )val.dsize);
  (*(ino + (n + 2))) = (short )off;
  (*(ino + 0)) = (short )((int )(*(ino + 0)) + 2);
  return;
}
}
apr_sdbm_datum_t sdbm__getpair(char *pag , apr_sdbm_datum_t key ) 
{ register int i ;
  register int n ;
  apr_sdbm_datum_t val ;
  register short *ino ;

  {
  ino = (short *)pag;
  n = (int )(*(ino + 0));
  if (n == 0) {
    return (sdbm_nullitem);
  }
  i = seepair(pag, n, key.dptr, key.dsize);
  if (i == 0) {
    return (sdbm_nullitem);
  }
  val.dptr = pag + (int )(*(ino + (i + 1)));
  val.dsize = (int )(*(ino + i)) - (int )(*(ino + (i + 1)));
  return (val);
}
}
int sdbm__duppair(char *pag , apr_sdbm_datum_t key ) 
{ register short *ino ;
  int tmp ;
  int tmp___0 ;

  {
  ino = (short *)pag;
  if ((int )(*(ino + 0)) > 0) {
    tmp = seepair(pag, (int )(*(ino + 0)), key.dptr, key.dsize);
    if (tmp > 0) {
      tmp___0 = 1;
    } else {
      goto _L;
    }
  } else {
    _L: 
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
apr_sdbm_datum_t sdbm__getnkey(char *pag , int num ) 
{ apr_sdbm_datum_t key ;
  register int off ;
  register short *ino ;

  {
  ino = (short *)pag;
  num = num * 2 - 1;
  if ((int )(*(ino + 0)) == 0) {
    goto _L;
  } else {
    if (num > (int )(*(ino + 0))) {
      _L: 
      return (sdbm_nullitem);
    }
  }
  if (num > 1) {
    off = (int )(*(ino + (num - 1)));
  } else {
    off = 1024;
  }
  key.dptr = pag + (int )(*(ino + num));
  key.dsize = off - (int )(*(ino + num));
  return (key);
}
}
int sdbm__delpair(char *pag , apr_sdbm_datum_t key ) 
{ register int n ;
  register int i ;
  register short *ino ;
  register int m ;
  register char *dst ;
  int tmp ;
  register char *src ;
  register int zoo ;

  {
  ino = (short *)pag;
  n = (int )(*(ino + 0));
  if (n == 0) {
    return (0);
  }
  i = seepair(pag, n, key.dptr, key.dsize);
  if (i == 0) {
    return (0);
  }
  if (i < n - 1) {
    if (i == 1) {
      tmp = 1024;
    } else {
      tmp = (int )(*(ino + (i - 1)));
    }
    dst = pag + tmp;
    src = pag + (int )(*(ino + (i + 1)));
    zoo = dst - src;
    m = (int )(*(ino + (i + 1))) - (int )(*(ino + n));
    dst -= m;
    src -= m;
    memmove((void *)dst, (void const   *)src, (unsigned int )m);
    while (i < n - 1) {
      (*(ino + i)) = (short )((int )(*(ino + (i + 2))) + zoo);
      i ++;
    }
  }
  (*(ino + 0)) = (short )((int )(*(ino + 0)) - 2);
  return (1);
}
}
static int seepair(char *pag , int n , char *key , int siz ) 
{ register int i ;
  register int off ;
  register short *ino ;
  int tmp ;

  {
  off = 1024;
  ino = (short *)pag;
  i = 1;
  while (i < n) {
    if (siz == off - (int )(*(ino + i))) {
      tmp = memcmp((void const   *)key, (void const   *)(pag + (int )(*(ino + i))),
                   (unsigned int )siz);
      if (tmp == 0) {
        return (i);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    off = (int )(*(ino + (i + 1)));
    i += 2;
  }
  return (0);
}
}
void sdbm__splpage(char *pag , char *new , long sbit ) 
{ apr_sdbm_datum_t key ;
  apr_sdbm_datum_t val ;
  register int n ;
  register int off ;
  char cur[1024] ;
  register short *ino ;
  char *tmp___0 ;
  long tmp___1 ;

  {
  off = 1024;
  ino = (short *)(cur);
  memcpy((void * __restrict  )(cur), (void const   * __restrict  )pag, 1024U);
  memset((void *)pag, 0, 1024U);
  memset((void *)new, 0, 1024U);
  n = (int )(*(ino + 0));
  ino ++;
  while (n > 0) {
    key.dptr = cur + (int )(*(ino + 0));
    key.dsize = off - (int )(*(ino + 0));
    val.dptr = cur + (int )(*(ino + 1));
    val.dsize = (int )(*(ino + 0)) - (int )(*(ino + 1));
    tmp___1 = sdbm_hash((char const   *)key.dptr, key.dsize);
    if (tmp___1 & sbit) {
      tmp___0 = new;
    } else {
      tmp___0 = pag;
    }
    sdbm__putpair(tmp___0, key, val);
    off = (int )(*(ino + 1));
    n -= 2;
    ino += 2;
  }
  return;
}
}
int sdbm__chkpage(char *pag ) 
{ register int n ;
  register int off ;
  register short *ino ;

  {
  ino = (short *)pag;
  n = (int )(*(ino + 0));
  if (n < 0) {
    goto _L;
  } else {
    if ((unsigned int )n > 1024U / sizeof(short )) {
      _L: 
      return (0);
    }
  }
  if (n > 0) {
    off = 1024;
    ino ++;
    while (n > 0) {
      if ((int )(*(ino + 0)) > off) {
        goto _L___1;
      } else {
        if ((int )(*(ino + 1)) > off) {
          _L___1: 
          goto _L___0;
        } else {
          if ((int )(*(ino + 1)) > (int )(*(ino + 0))) {
            _L___0: 
            return (0);
          }
        }
      }
      off = (int )(*(ino + 1));
      n -= 2;
      ino += 2;
    }
  }
  return (1);
}
}
#pragma merger(0,"/tmp/cil-Sq1MQQlX.i","-g -pthread")
int apr_posix_perms2mode(apr_fileperms_t perm ) ;
struct __anonstruct_apr_dbm_type_t_53  const  apr_dbm_type_sdbm ;
struct __anonstruct_apr_dbm_type_t_53  const  apr_dbm_type_gdbm ;
struct __anonstruct_apr_dbm_type_t_53  const  apr_dbm_type_db ;
apr_status_t apr_dbm_open_ex(apr_dbm_t **pdb , char const   *type , char const   *pathname ,
                             apr_int32_t mode , apr_fileperms_t perm , apr_pool_t *pool ) 
{ apr_status_t tmp ;
  int tmp___0 ;
  apr_status_t tmp___1 ;
  int tmp___2 ;
  apr_status_t tmp___3 ;
  int tmp___4 ;
  apr_status_t tmp___5 ;
  int tmp___6 ;

  {
  tmp___0 = strcasecmp(type, "GDBM");
  if (! tmp___0) {
    tmp = ((*(apr_dbm_type_gdbm.open)))(pdb, pathname, mode, perm, pool);
    return (tmp);
  }
  tmp___2 = strcasecmp(type, "SDBM");
  if (! tmp___2) {
    tmp___1 = ((*(apr_dbm_type_sdbm.open)))(pdb, pathname, mode, perm, pool);
    return (tmp___1);
  }
  tmp___4 = strcasecmp(type, "DB");
  if (! tmp___4) {
    tmp___3 = ((*(apr_dbm_type_db.open)))(pdb, pathname, mode, perm, pool);
    return (tmp___3);
  }
  tmp___6 = strcasecmp(type, "default");
  if (! tmp___6) {
    tmp___5 = ((*(apr_dbm_type_sdbm.open)))(pdb, pathname, mode, perm, pool);
    return (tmp___5);
  }
  return (70023);
}
}
apr_status_t apr_dbm_open(apr_dbm_t **pdb , char const   *pathname , apr_int32_t mode ,
                          apr_fileperms_t perm , apr_pool_t *pool ) 
{ apr_status_t tmp ;

  {
  tmp = ((*(apr_dbm_type_sdbm.open)))(pdb, pathname, mode, perm, pool);
  return (tmp);
}
}
void apr_dbm_close(apr_dbm_t *dbm ) 
{ 

  {
  ((*((dbm->type)->close)))(dbm);
  return;
}
}
apr_status_t apr_dbm_fetch(apr_dbm_t *dbm , apr_datum_t key , apr_datum_t *pvalue ) 
{ apr_status_t tmp ;

  {
  tmp = ((*((dbm->type)->fetch)))(dbm, key, pvalue);
  return (tmp);
}
}
apr_status_t apr_dbm_store(apr_dbm_t *dbm , apr_datum_t key , apr_datum_t value ) 
{ apr_status_t tmp ;

  {
  tmp = ((*((dbm->type)->store)))(dbm, key, value);
  return (tmp);
}
}
apr_status_t apr_dbm_delete(apr_dbm_t *dbm , apr_datum_t key ) 
{ apr_status_t tmp ;

  {
  tmp = ((*((dbm->type)->del)))(dbm, key);
  return (tmp);
}
}
int apr_dbm_exists(apr_dbm_t *dbm , apr_datum_t key ) 
{ int tmp ;

  {
  tmp = ((*((dbm->type)->exists)))(dbm, key);
  return (tmp);
}
}
apr_status_t apr_dbm_firstkey(apr_dbm_t *dbm , apr_datum_t *pkey ) 
{ apr_status_t tmp ;

  {
  tmp = ((*((dbm->type)->firstkey)))(dbm, pkey);
  return (tmp);
}
}
apr_status_t apr_dbm_nextkey(apr_dbm_t *dbm , apr_datum_t *pkey ) 
{ apr_status_t tmp ;

  {
  tmp = ((*((dbm->type)->nextkey)))(dbm, pkey);
  return (tmp);
}
}
void apr_dbm_freedatum(apr_dbm_t *dbm , apr_datum_t data ) 
{ 

  {
  ((*((dbm->type)->freedatum)))(dbm, data);
  return;
}
}
char *apr_dbm_geterror(apr_dbm_t *dbm , int *errcode , char *errbuf , apr_size_t errbufsize ) 
{ 

  {
  if ((unsigned int )errcode != (unsigned int )((void *)0)) {
    (*errcode) = dbm->errcode;
  }
  if ((unsigned int )dbm->errmsg == (unsigned int )((void *)0)) {
    (*errbuf) = (char )'\000';
  } else {
    apr_cpystrn(errbuf, dbm->errmsg, errbufsize);
  }
  return (errbuf);
}
}
apr_status_t apr_dbm_get_usednames_ex(apr_pool_t *p , char const   *type , char const   *pathname ,
                                      char const   **used1 , char const   **used2 ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = strcasecmp(type, "GDBM");
  if (! tmp) {
    ((*(apr_dbm_type_gdbm.getusednames)))(p, pathname, used1, used2);
    return (0);
  }
  tmp___0 = strcasecmp(type, "SDBM");
  if (! tmp___0) {
    ((*(apr_dbm_type_sdbm.getusednames)))(p, pathname, used1, used2);
    return (0);
  }
  tmp___1 = strcasecmp(type, "DB");
  if (! tmp___1) {
    ((*(apr_dbm_type_db.getusednames)))(p, pathname, used1, used2);
    return (0);
  }
  tmp___2 = strcasecmp(type, "default");
  if (! tmp___2) {
    ((*(apr_dbm_type_sdbm.getusednames)))(p, pathname, used1, used2);
    return (0);
  }
  return (70023);
}
}
void apr_dbm_get_usednames(apr_pool_t *p , char const   *pathname , char const   **used1 ,
                           char const   **used2 ) 
{ 

  {
  ((*(apr_dbm_type_sdbm.getusednames)))(p, pathname, used1, used2);
  return;
}
}
int apr_posix_perms2mode(apr_fileperms_t perm ) 
{ int mode ;

  {
  mode = 0;
  mode |= 448 & (perm >> 2);
  mode |= 56 & (perm >> 1);
  mode |= 7 & perm;
  return (mode);
}
}
#pragma merger(0,"/tmp/cil-Wk6YWRQT.i","-g -pthread")
extern int db_create(DB ** , DB_ENV * , u_int32_t  ) ;
extern char *db_strerror(int  ) ;
static apr_status_t db2s(int dberr ) 
{ 

  {
  if (dberr != 0) {
    return (120000 + dberr);
  }
  return (0);
}
}
static apr_status_t set_error(apr_dbm_t *dbm , apr_status_t dbm_said ) 
{ apr_status_t rv ;

  {
  rv = 0;
  if (dbm_said == 0) {
    dbm->errcode = 0;
    dbm->errmsg = (char const   *)((void *)0);
  } else {
    dbm->errcode = dbm_said;
    dbm->errmsg = db_strerror(dbm_said - 120000);
    rv = dbm_said;
  }
  return (rv);
}
}
static apr_status_t vt_db_open(apr_dbm_t **pdb , char const   *pathname , apr_int32_t mode ,
                               apr_fileperms_t perm , apr_pool_t *pool ) 
{ real_file_t file ;
  int dbmode ;
  int dberr ;
  int tmp ;
  apr_status_t tmp___0 ;
  void *tmp___1 ;

  {
  (*pdb) = (apr_dbm_t *)((void *)0);
  switch (mode) {
  case 1: 
  dbmode = 16;
  break;
  case 2: 
  dbmode = 0;
  break;
  case 3: 
  dbmode = 1;
  break;
  case 4: 
  dbmode = 128;
  break;
  default: ;
  return (22);
  }
  dberr = db_create(& file.bdb, (DB_ENV *)((void *)0), 0U);
  if (dberr == 0) {
    tmp = apr_posix_perms2mode(perm);
    dberr = ((*((file.bdb)->open)))(file.bdb, (DB_TXN *)((void *)0), pathname, (char const   *)((void *)0),
                                    (enum __anonenum_DBTYPE_63 )2, (unsigned int )dbmode,
                                    tmp);
    if (dberr != 0) {
      ((*((file.bdb)->close)))(file.bdb, 0U);
    }
  }
  file.curs = (DBC *)((void *)0);
  if (dberr != 0) {
    tmp___0 = db2s(dberr);
    return (tmp___0);
  }
  tmp___1 = apr_palloc(pool, sizeof((*((*pdb)))));
  (*pdb) = (apr_dbm_t *)memset(tmp___1, 0, sizeof((*((*pdb)))));
  ((*pdb))->pool = pool;
  ((*pdb))->type = & apr_dbm_type_db;
  ((*pdb))->file = apr_pmemdup(pool, (void const   *)(& file), sizeof(file));
  return (0);
}
}
static void vt_db_close(apr_dbm_t *dbm ) 
{ 

  {
  ((*((((real_file_t *)dbm->file)->bdb)->close)))(((real_file_t *)dbm->file)->bdb,
                                                  0U);
  return;
}
}
static apr_status_t vt_db_fetch(apr_dbm_t *dbm , apr_datum_t key , apr_datum_t *pvalue ) 
{ DBT ckey ;
  DBT rd ;
  int dberr ;
  apr_status_t tmp ;
  apr_status_t tmp___0 ;

  {
  ckey.data = (void *)0;
  ckey.size = 0U;
  ckey.ulen = 0U;
  ckey.dlen = 0U;
  ckey.doff = 0U;
  ckey.flags = 0U;
  rd.data = (void *)0;
  rd.size = 0U;
  rd.ulen = 0U;
  rd.dlen = 0U;
  rd.doff = 0U;
  rd.flags = 0U;
  ckey.data = (void *)key.dptr;
  ckey.size = key.dsize;
  dberr = ((*((((real_file_t *)dbm->file)->bdb)->get)))(((real_file_t *)dbm->file)->bdb,
                                                        (DB_TXN *)((void *)0), & ckey,
                                                        & rd, 0U);
  if (dberr == -30991) {
    memset((void *)(& rd), 0, sizeof(rd));
    dberr = 0;
  }
  pvalue->dptr = (char *)rd.data;
  pvalue->dsize = rd.size;
  tmp = db2s(dberr);
  tmp___0 = set_error(dbm, tmp);
  return (tmp___0);
}
}
static apr_status_t vt_db_store(apr_dbm_t *dbm , apr_datum_t key , apr_datum_t value ) 
{ apr_status_t rv ;
  DBT ckey ;
  DBT cvalue ;
  int tmp ;
  apr_status_t tmp___0 ;

  {
  ckey.data = (void *)0;
  ckey.size = 0U;
  ckey.ulen = 0U;
  ckey.dlen = 0U;
  ckey.doff = 0U;
  ckey.flags = 0U;
  cvalue.data = (void *)0;
  cvalue.size = 0U;
  cvalue.ulen = 0U;
  cvalue.dlen = 0U;
  cvalue.doff = 0U;
  cvalue.flags = 0U;
  ckey.data = (void *)key.dptr;
  ckey.size = key.dsize;
  cvalue.data = (void *)value.dptr;
  cvalue.size = value.dsize;
  tmp = ((*((((real_file_t *)dbm->file)->bdb)->put)))(((real_file_t *)dbm->file)->bdb,
                                                      (DB_TXN *)((void *)0), & ckey,
                                                      & cvalue, 0U);
  rv = db2s(tmp);
  tmp___0 = set_error(dbm, rv);
  return (tmp___0);
}
}
static apr_status_t vt_db_del(apr_dbm_t *dbm , apr_datum_t key ) 
{ apr_status_t rv ;
  DBT ckey ;
  int tmp ;
  apr_status_t tmp___0 ;

  {
  ckey.data = (void *)0;
  ckey.size = 0U;
  ckey.ulen = 0U;
  ckey.dlen = 0U;
  ckey.doff = 0U;
  ckey.flags = 0U;
  ckey.data = (void *)key.dptr;
  ckey.size = key.dsize;
  tmp = ((*((((real_file_t *)dbm->file)->bdb)->del)))(((real_file_t *)dbm->file)->bdb,
                                                      (DB_TXN *)((void *)0), & ckey,
                                                      0U);
  rv = db2s(tmp);
  tmp___0 = set_error(dbm, rv);
  return (tmp___0);
}
}
static int vt_db_exists(apr_dbm_t *dbm , apr_datum_t key ) 
{ DBT ckey ;
  DBT data ;
  int dberr ;

  {
  ckey.data = (void *)0;
  ckey.size = 0U;
  ckey.ulen = 0U;
  ckey.dlen = 0U;
  ckey.doff = 0U;
  ckey.flags = 0U;
  data.data = (void *)0;
  data.size = 0U;
  data.ulen = 0U;
  data.dlen = 0U;
  data.doff = 0U;
  data.flags = 0U;
  ckey.data = (void *)key.dptr;
  ckey.size = key.dsize;
  dberr = ((*((((real_file_t *)dbm->file)->bdb)->get)))(((real_file_t *)dbm->file)->bdb,
                                                        (DB_TXN *)((void *)0), & ckey,
                                                        & data, 0U);
  return (dberr == 0);
}
}
static apr_status_t vt_db_firstkey(apr_dbm_t *dbm , apr_datum_t *pkey ) 
{ real_file_t *f ;
  DBT first ;
  DBT data ;
  int dberr ;
  apr_status_t tmp ;
  apr_status_t tmp___0 ;

  {
  f = (real_file_t *)dbm->file;
  first.data = (void *)0;
  first.size = 0U;
  first.ulen = 0U;
  first.dlen = 0U;
  first.doff = 0U;
  first.flags = 0U;
  data.data = (void *)0;
  data.size = 0U;
  data.ulen = 0U;
  data.dlen = 0U;
  data.doff = 0U;
  data.flags = 0U;
  dberr = ((*((f->bdb)->cursor)))(f->bdb, (DB_TXN *)((void *)0), & f->curs, 0U);
  if (dberr == 0) {
    dberr = ((*((f->curs)->c_get)))(f->curs, & first, & data, 10U);
    if (dberr == -30991) {
      memset((void *)(& first), 0, sizeof(first));
      ((*((f->curs)->c_close)))(f->curs);
      f->curs = (DBC *)((void *)0);
      dberr = 0;
    }
  }
  pkey->dptr = (char *)first.data;
  pkey->dsize = first.size;
  tmp = db2s(dberr);
  tmp___0 = set_error(dbm, tmp);
  return (tmp___0);
}
}
static apr_status_t vt_db_nextkey(apr_dbm_t *dbm , apr_datum_t *pkey ) 
{ real_file_t *f ;
  DBT ckey ;
  DBT data ;
  int dberr ;
  apr_status_t tmp ;

  {
  f = (real_file_t *)dbm->file;
  ckey.data = (void *)0;
  ckey.size = 0U;
  ckey.ulen = 0U;
  ckey.dlen = 0U;
  ckey.doff = 0U;
  ckey.flags = 0U;
  data.data = (void *)0;
  data.size = 0U;
  data.ulen = 0U;
  data.dlen = 0U;
  data.doff = 0U;
  data.flags = 0U;
  ckey.data = (void *)pkey->dptr;
  ckey.size = pkey->dsize;
  if ((unsigned int )f->curs == (unsigned int )((void *)0)) {
    return (22);
  }
  dberr = ((*((f->curs)->c_get)))(f->curs, & ckey, & data, 19U);
  if (dberr == -30991) {
    ((*((f->curs)->c_close)))(f->curs);
    f->curs = (DBC *)((void *)0);
    dberr = 0;
    ckey.data = (void *)0;
    ckey.size = 0U;
  }
  pkey->dptr = (char *)ckey.data;
  pkey->dsize = ckey.size;
  tmp = set_error(dbm, 0);
  return (tmp);
}
}
static void vt_db_freedatum(apr_dbm_t *dbm , apr_datum_t data ) 
{ 

  {
  return;
}
}
static void vt_db_usednames(apr_pool_t *pool , char const   *pathname , char const   **used1 ,
                            char const   **used2 ) 
{ 

  {
  (*used1) = apr_pstrdup(pool, pathname);
  (*used2) = (char const   *)((void *)0);
  return;
}
}
struct __anonstruct_apr_dbm_type_t_53  const  apr_dbm_type_db  = 
     {"db", & vt_db_open, & vt_db_close, & vt_db_fetch, & vt_db_store, & vt_db_del,
    & vt_db_exists, & vt_db_firstkey, & vt_db_nextkey, & vt_db_freedatum, & vt_db_usednames};
#pragma merger(0,"/tmp/cil-upP8OVBm.i","-g -pthread")
extern GDBM_FILE gdbm_open(char * , int  , int  , int  , void (*)() ) ;
extern void gdbm_close(GDBM_FILE  ) ;
extern int gdbm_store(GDBM_FILE  , apr_sdbm_datum_t  , apr_sdbm_datum_t  , int  ) ;
extern apr_sdbm_datum_t gdbm_fetch(GDBM_FILE  , apr_sdbm_datum_t  ) ;
extern int gdbm_delete(GDBM_FILE  , apr_sdbm_datum_t  ) ;
extern apr_sdbm_datum_t gdbm_firstkey(GDBM_FILE  ) ;
extern apr_sdbm_datum_t gdbm_nextkey(GDBM_FILE  , apr_sdbm_datum_t  ) ;
extern int gdbm_exists(GDBM_FILE  , apr_sdbm_datum_t  ) ;
extern gdbm_error gdbm_errno ;
extern char *gdbm_strerror(gdbm_error  ) ;
static apr_status_t g2s(int gerr ) 
{ 

  {
  if (gerr == -1) {
    return (20014);
  }
  return (0);
}
}
static apr_status_t datum_cleanup(void *dptr ) 
{ 

  {
  if (dptr) {
    free(dptr);
  }
  return (0);
}
}
static apr_status_t set_error___0(apr_dbm_t *dbm , apr_status_t dbm_said ) 
{ apr_status_t rv ;

  {
  rv = 0;
  dbm->errcode = gdbm_errno;
  if (dbm->errcode == 0) {
    dbm->errmsg = (char const   *)((void *)0);
  } else {
    dbm->errmsg = gdbm_strerror(gdbm_errno);
    rv = 20014;
  }
  gdbm_errno = 0;
  return (rv);
}
}
static apr_status_t vt_gdbm_open(apr_dbm_t **pdb , char const   *pathname , apr_int32_t mode ,
                                 apr_fileperms_t perm , apr_pool_t *pool ) 
{ real_file_t___0 file ;
  int dbmode ;
  int tmp ;
  void *tmp___0 ;

  {
  (*pdb) = (apr_dbm_t *)((void *)0);
  switch (mode) {
  case 1: 
  dbmode = 0;
  break;
  case 2: 
  dbmode = 1;
  break;
  case 3: 
  dbmode = 2;
  break;
  case 4: 
  dbmode = 3;
  break;
  default: ;
  return (22);
  }
  tmp = apr_posix_perms2mode(perm);
  file = gdbm_open((char *)pathname, 0, dbmode, tmp, (void (*)())((void *)0));
  if ((unsigned int )file == (unsigned int )((void *)0)) {
    return (20014);
  }
  tmp___0 = apr_palloc(pool, sizeof((*((*pdb)))));
  (*pdb) = (apr_dbm_t *)memset(tmp___0, 0, sizeof((*((*pdb)))));
  ((*pdb))->pool = pool;
  ((*pdb))->type = & apr_dbm_type_gdbm;
  ((*pdb))->file = (void *)file;
  return (0);
}
}
static void vt_gdbm_close(apr_dbm_t *dbm ) 
{ 

  {
  gdbm_close((struct __anonstruct_GDBM_FILE_58 *)dbm->file);
  return;
}
}
static apr_status_t vt_gdbm_fetch(apr_dbm_t *dbm , apr_datum_t key , apr_datum_t *pvalue ) 
{ apr_status_t rv ;
  cvt_datum_t ckey ;
  result_datum_t rd ;
  apr_status_t tmp ;

  {
  ckey = (apr_sdbm_datum_t *)(& key);
  rd = gdbm_fetch((struct __anonstruct_GDBM_FILE_58 *)dbm->file, (*ckey));
  rv = 0;
  (*pvalue) = (*((apr_datum_t *)(& rd)));
  if (pvalue->dptr) {
    apr_pool_cleanup_register(dbm->pool, (void const   *)pvalue->dptr, & datum_cleanup,
                              & apr_pool_cleanup_null);
  }
  tmp = set_error___0(dbm, rv);
  return (tmp);
}
}
static apr_status_t vt_gdbm_store(apr_dbm_t *dbm , apr_datum_t key , apr_datum_t value ) 
{ apr_status_t rv ;
  cvt_datum_t ckey ;
  cvt_datum_t cvalue ;
  int tmp ;
  apr_status_t tmp___0 ;

  {
  ckey = (apr_sdbm_datum_t *)(& key);
  cvalue = (apr_sdbm_datum_t *)(& value);
  tmp = gdbm_store((struct __anonstruct_GDBM_FILE_58 *)dbm->file, (*ckey), (*cvalue),
                   1);
  rv = g2s(tmp);
  tmp___0 = set_error___0(dbm, rv);
  return (tmp___0);
}
}
static apr_status_t vt_gdbm_del(apr_dbm_t *dbm , apr_datum_t key ) 
{ apr_status_t rv ;
  cvt_datum_t ckey ;
  int tmp ;
  apr_status_t tmp___0 ;

  {
  ckey = (apr_sdbm_datum_t *)(& key);
  tmp = gdbm_delete((struct __anonstruct_GDBM_FILE_58 *)dbm->file, (*ckey));
  rv = g2s(tmp);
  tmp___0 = set_error___0(dbm, rv);
  return (tmp___0);
}
}
static int vt_gdbm_exists(apr_dbm_t *dbm , apr_datum_t key ) 
{ apr_sdbm_datum_t *ckey ;
  int tmp ;

  {
  ckey = (apr_sdbm_datum_t *)(& key);
  tmp = gdbm_exists((struct __anonstruct_GDBM_FILE_58 *)dbm->file, (*ckey));
  return (tmp != 0);
}
}
static apr_status_t vt_gdbm_firstkey(apr_dbm_t *dbm , apr_datum_t *pkey ) 
{ apr_status_t rv ;
  result_datum_t rd ;
  apr_status_t tmp ;

  {
  rd = gdbm_firstkey((struct __anonstruct_GDBM_FILE_58 *)dbm->file);
  rv = 0;
  (*pkey) = (*((apr_datum_t *)(& rd)));
  if (pkey->dptr) {
    apr_pool_cleanup_register(dbm->pool, (void const   *)pkey->dptr, & datum_cleanup,
                              & apr_pool_cleanup_null);
  }
  tmp = set_error___0(dbm, rv);
  return (tmp);
}
}
static apr_status_t vt_gdbm_nextkey(apr_dbm_t *dbm , apr_datum_t *pkey ) 
{ apr_status_t rv ;
  cvt_datum_t ckey ;
  result_datum_t rd ;
  apr_status_t tmp ;

  {
  ckey = (apr_sdbm_datum_t *)pkey;
  rd = gdbm_nextkey((struct __anonstruct_GDBM_FILE_58 *)dbm->file, (*ckey));
  rv = 0;
  (*pkey) = (*((apr_datum_t *)(& rd)));
  if (pkey->dptr) {
    apr_pool_cleanup_register(dbm->pool, (void const   *)pkey->dptr, & datum_cleanup,
                              & apr_pool_cleanup_null);
  }
  tmp = set_error___0(dbm, 0);
  return (tmp);
}
}
static void vt_gdbm_freedatum(apr_dbm_t *dbm , apr_datum_t data ) 
{ 

  {
  apr_pool_cleanup_run(dbm->pool, (void *)data.dptr, & datum_cleanup);
  return;
}
}
static void vt_gdbm_usednames(apr_pool_t *pool , char const   *pathname , char const   **used1 ,
                              char const   **used2 ) 
{ 

  {
  (*used1) = apr_pstrdup(pool, pathname);
  (*used2) = (char const   *)((void *)0);
  return;
}
}
struct __anonstruct_apr_dbm_type_t_53  const  apr_dbm_type_gdbm  = 
     {"gdbm", & vt_gdbm_open, & vt_gdbm_close, & vt_gdbm_fetch, & vt_gdbm_store, & vt_gdbm_del,
    & vt_gdbm_exists, & vt_gdbm_firstkey, & vt_gdbm_nextkey, & vt_gdbm_freedatum,
    & vt_gdbm_usednames};
#pragma merger(0,"/tmp/cil-V7BdF4ZL.i","-g -pthread")
static apr_status_t set_error___1(apr_dbm_t *dbm , apr_status_t dbm_said ) 
{ apr_status_t rv ;

  {
  rv = 0;
  dbm->errcode = dbm_said;
  if (dbm->errcode == 0) {
    dbm->errmsg = (char const   *)((void *)0);
  } else {
    dbm->errmsg = "I/O error occurred.";
    rv = 20014;
  }
  return (rv);
}
}
static apr_status_t vt_sdbm_open(apr_dbm_t **pdb , char const   *pathname , apr_int32_t mode ,
                                 apr_fileperms_t perm , apr_pool_t *pool ) 
{ real_file_t___1 file ;
  int dbmode ;
  apr_status_t rv ;
  void *tmp ;

  {
  (*pdb) = (apr_dbm_t *)((void *)0);
  switch (mode) {
  case 1: 
  dbmode = 1;
  break;
  case 2: 
  dbmode = 3;
  break;
  case 3: 
  dbmode = 7;
  break;
  case 4: 
  dbmode = 23;
  break;
  default: ;
  return (22);
  }
  rv = apr_sdbm_open(& file, pathname, dbmode, perm, pool);
  if (rv != 0) {
    return (rv);
  }
  tmp = apr_palloc(pool, sizeof((*((*pdb)))));
  (*pdb) = (apr_dbm_t *)memset(tmp, 0, sizeof((*((*pdb)))));
  ((*pdb))->pool = pool;
  ((*pdb))->type = & apr_dbm_type_sdbm;
  ((*pdb))->file = (void *)file;
  return (0);
}
}
static void vt_sdbm_close(apr_dbm_t *dbm ) 
{ 

  {
  apr_sdbm_close((apr_sdbm_t *)dbm->file);
  return;
}
}
static apr_status_t vt_sdbm_fetch(apr_dbm_t *dbm , apr_datum_t key , apr_datum_t *pvalue ) 
{ apr_status_t rv ;
  cvt_datum_t ckey ;
  result_datum_t rd ;
  apr_status_t tmp ;

  {
  ckey = (apr_sdbm_datum_t *)(& key);
  rv = apr_sdbm_fetch((apr_sdbm_t *)dbm->file, & rd, (*ckey));
  (*pvalue) = (*((apr_datum_t *)(& rd)));
  tmp = set_error___1(dbm, rv);
  return (tmp);
}
}
static apr_status_t vt_sdbm_store(apr_dbm_t *dbm , apr_datum_t key , apr_datum_t value ) 
{ apr_status_t rv ;
  cvt_datum_t ckey ;
  cvt_datum_t cvalue ;
  apr_status_t tmp ;

  {
  ckey = (apr_sdbm_datum_t *)(& key);
  cvalue = (apr_sdbm_datum_t *)(& value);
  rv = apr_sdbm_store((apr_sdbm_t *)dbm->file, (*ckey), (*cvalue), 1);
  tmp = set_error___1(dbm, rv);
  return (tmp);
}
}
static apr_status_t vt_sdbm_del(apr_dbm_t *dbm , apr_datum_t key ) 
{ apr_status_t rv ;
  cvt_datum_t ckey ;
  apr_status_t tmp ;

  {
  ckey = (apr_sdbm_datum_t *)(& key);
  rv = apr_sdbm_delete((apr_sdbm_t *)dbm->file, (*ckey));
  tmp = set_error___1(dbm, rv);
  return (tmp);
}
}
static int vt_sdbm_exists(apr_dbm_t *dbm , apr_datum_t key ) 
{ int exists ;
  apr_sdbm_datum_t *ckey ;
  apr_sdbm_datum_t value ;
  apr_status_t tmp ;

  {
  ckey = (apr_sdbm_datum_t *)(& key);
  tmp = apr_sdbm_fetch((apr_sdbm_t *)dbm->file, & value, (*ckey));
  if (tmp != 0) {
    exists = 0;
  } else {
    exists = (unsigned int )value.dptr != (unsigned int )((void *)0);
  }
  return (exists);
}
}
static apr_status_t vt_sdbm_firstkey(apr_dbm_t *dbm , apr_datum_t *pkey ) 
{ apr_status_t rv ;
  result_datum_t rd ;
  apr_status_t tmp ;

  {
  rv = apr_sdbm_firstkey((apr_sdbm_t *)dbm->file, & rd);
  (*pkey) = (*((apr_datum_t *)(& rd)));
  tmp = set_error___1(dbm, rv);
  return (tmp);
}
}
static apr_status_t vt_sdbm_nextkey(apr_dbm_t *dbm , apr_datum_t *pkey ) 
{ apr_status_t rv ;
  cvt_datum_t ckey ;
  result_datum_t rd ;
  apr_status_t tmp ;

  {
  ckey = (apr_sdbm_datum_t *)pkey;
  rv = apr_sdbm_nextkey((apr_sdbm_t *)dbm->file, & rd);
  (*pkey) = (*((apr_datum_t *)(& rd)));
  tmp = set_error___1(dbm, 0);
  return (tmp);
}
}
static void vt_sdbm_freedatum(apr_dbm_t *dbm , apr_datum_t data ) 
{ 

  {
  return;
}
}
static void vt_sdbm_usednames(apr_pool_t *pool , char const   *pathname , char const   **used1 ,
                              char const   **used2 ) 
{ char *work ;
  size_t tmp ;

  {
  (*used1) = apr_pstrcat(pool, pathname, ".dir", (void *)0);
  work = apr_pstrdup(pool, (*used1));
  (*used2) = (char const   *)work;
  tmp = strlen((char const   *)work);
  memcpy((void * __restrict  )(work + (tmp - 4U)), (void const   * __restrict  )".pag",
         4U);
  return;
}
}
struct __anonstruct_apr_dbm_type_t_53  const  apr_dbm_type_sdbm  = 
     {"sdbm", & vt_sdbm_open, & vt_sdbm_close, & vt_sdbm_fetch, & vt_sdbm_store, & vt_sdbm_del,
    & vt_sdbm_exists, & vt_sdbm_firstkey, & vt_sdbm_nextkey, & vt_sdbm_freedatum,
    & vt_sdbm_usednames};
#pragma merger(0,"/tmp/cil-iBVtO03z.i","-g -pthread")
#pragma merger(0,"/tmp/cil-8cHHz7qQ.i","-g -pthread")
static unsigned char const   pr2six[256]  = 
  {      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )62, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )63, 
        (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )55, 
        (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6, 
        (unsigned char const   )7,      (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10, 
        (unsigned char const   )11,      (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14, 
        (unsigned char const   )15,      (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18, 
        (unsigned char const   )19,      (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22, 
        (unsigned char const   )23,      (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )26,      (unsigned char const   )27,      (unsigned char const   )28, 
        (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31,      (unsigned char const   )32, 
        (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35,      (unsigned char const   )36, 
        (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39,      (unsigned char const   )40, 
        (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43,      (unsigned char const   )44, 
        (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47,      (unsigned char const   )48, 
        (unsigned char const   )49,      (unsigned char const   )50,      (unsigned char const   )51,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64};
int apr_base64_decode_len(char const   *bufcoded ) 
{ int nbytesdecoded ;
  register unsigned char const   *bufin ;
  register int nprbytes ;
  unsigned char const   *tmp ;

  {
  bufin = (unsigned char const   *)bufcoded;
  while (1) {
    tmp = bufin;
    bufin ++;
    if (! ((int const   )pr2six[(*tmp)] <= 63)) {
      break;
    }
  }
  nprbytes = (bufin - (unsigned char const   *)bufcoded) - 1;
  nbytesdecoded = ((nprbytes + 3) / 4) * 3;
  return (nbytesdecoded + 1);
}
}
int apr_base64_decode(char *bufplain , char const   *bufcoded ) 
{ int len ;

  {
  len = apr_base64_decode_binary((unsigned char *)bufplain, bufcoded);
  (*(bufplain + len)) = (char )'\000';
  return (len);
}
}
int apr_base64_decode_binary(unsigned char *bufplain , char const   *bufcoded ) 
{ int nbytesdecoded ;
  register unsigned char const   *bufin ;
  register unsigned char *bufout ;
  register int nprbytes ;
  unsigned char const   *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;

  {
  bufin = (unsigned char const   *)bufcoded;
  while (1) {
    tmp = bufin;
    bufin ++;
    if (! ((int const   )pr2six[(*tmp)] <= 63)) {
      break;
    }
  }
  nprbytes = (bufin - (unsigned char const   *)bufcoded) - 1;
  nbytesdecoded = ((nprbytes + 3) / 4) * 3;
  bufout = bufplain;
  bufin = (unsigned char const   *)bufcoded;
  while (nprbytes > 4) {
    tmp___0 = bufout;
    bufout ++;
    (*tmp___0) = (unsigned char )(((int const   )pr2six[(*bufin)] << 2) | ((int const   )pr2six[(*(bufin +
                                                                                                   1))] >>
                                                                           4));
    tmp___1 = bufout;
    bufout ++;
    (*tmp___1) = (unsigned char )(((int const   )pr2six[(*(bufin + 1))] << 4) | ((int const   )pr2six[(*(bufin +
                                                                                                         2))] >>
                                                                                 2));
    tmp___2 = bufout;
    bufout ++;
    (*tmp___2) = (unsigned char )(((int const   )pr2six[(*(bufin + 2))] << 6) | (int const   )pr2six[(*(bufin +
                                                                                                        3))]);
    bufin += 4;
    nprbytes -= 4;
  }
  if (nprbytes > 1) {
    tmp___3 = bufout;
    bufout ++;
    (*tmp___3) = (unsigned char )(((int const   )pr2six[(*bufin)] << 2) | ((int const   )pr2six[(*(bufin +
                                                                                                   1))] >>
                                                                           4));
  }
  if (nprbytes > 2) {
    tmp___4 = bufout;
    bufout ++;
    (*tmp___4) = (unsigned char )(((int const   )pr2six[(*(bufin + 1))] << 4) | ((int const   )pr2six[(*(bufin +
                                                                                                         2))] >>
                                                                                 2));
  }
  if (nprbytes > 3) {
    tmp___5 = bufout;
    bufout ++;
    (*tmp___5) = (unsigned char )(((int const   )pr2six[(*(bufin + 2))] << 6) | (int const   )pr2six[(*(bufin +
                                                                                                        3))]);
  }
  nbytesdecoded -= (4 - nprbytes) & 3;
  return (nbytesdecoded);
}
}
static char const   basis_64___0[65]  = 
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'\000'};
int apr_base64_encode_len(int len ) 
{ 

  {
  return (((len + 2) / 3) * 4 + 1);
}
}
int apr_base64_encode(char *encoded , char const   *string , int len ) 
{ int tmp ;

  {
  tmp = apr_base64_encode_binary(encoded, (unsigned char const   *)string, len);
  return (tmp);
}
}
int apr_base64_encode_binary(char *encoded , unsigned char const   *string , int len ) 
{ int i ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
  p = encoded;
  i = 0;
  while (i < len - 2) {
    tmp = p;
    p ++;
    (*tmp) = (char )basis_64___0[((int const   )(*(string + i)) >> 2) & 63];
    tmp___0 = p;
    p ++;
    (*tmp___0) = (char )basis_64___0[(((int const   )(*(string + i)) & 3) << 4) |
                                     (int const   )((int )((int const   )(*(string +
                                                                            (i + 1))) &
                                                           240) >> 4)];
    tmp___1 = p;
    p ++;
    (*tmp___1) = (char )basis_64___0[(((int const   )(*(string + (i + 1))) & 15) <<
                                      2) | (int const   )((int )((int const   )(*(string +
                                                                                  (i +
                                                                                   2))) &
                                                                 192) >> 6)];
    tmp___2 = p;
    p ++;
    (*tmp___2) = (char )basis_64___0[(int const   )(*(string + (i + 2))) & 63];
    i += 3;
  }
  if (i < len) {
    tmp___3 = p;
    p ++;
    (*tmp___3) = (char )basis_64___0[((int const   )(*(string + i)) >> 2) & 63];
    if (i == len - 1) {
      tmp___4 = p;
      p ++;
      (*tmp___4) = (char )basis_64___0[((int const   )(*(string + i)) & 3) << 4];
      tmp___5 = p;
      p ++;
      (*tmp___5) = (char )'=';
    } else {
      tmp___6 = p;
      p ++;
      (*tmp___6) = (char )basis_64___0[(((int const   )(*(string + i)) & 3) << 4) |
                                       (int const   )((int )((int const   )(*(string +
                                                                              (i +
                                                                               1))) &
                                                             240) >> 4)];
      tmp___7 = p;
      p ++;
      (*tmp___7) = (char )basis_64___0[((int const   )(*(string + (i + 1))) & 15) <<
                                       2];
    }
    tmp___8 = p;
    p ++;
    (*tmp___8) = (char )'=';
  }
  tmp___9 = p;
  p ++;
  (*tmp___9) = (char )'\000';
  return (p - encoded);
}
}
#pragma merger(0,"/tmp/cil-4t1HZPhP.i","-g -pthread")
extern  __attribute__((__noreturn__)) void __assert_fail(char const   *__assertion ,
                                                         char const   *__file , unsigned int __line ,
                                                         char const   *__function ) ;
extern struct _IO_FILE *stdout ;
extern int fputc(int __c , FILE *__stream ) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
apr_pool_t *apr_global_hook_pool ;
int apr_debug_module_hooks ;
char const   *apr_current_hooking_module ;
apr_pool_t *apr_hook_global_pool  =    (apr_pool_t *)((void *)0);
int apr_hook_debug_enabled  =    0;
char const   *apr_hook_debug_current  =    (char const   *)((void *)0);
apr_pool_t *apr_global_hook_pool  =    (apr_pool_t *)((void *)0);
int apr_debug_module_hooks  =    0;
char const   *apr_current_hooking_module  =    (char const   *)((void *)0);
static int crude_order(void const   *a_ , void const   *b_ ) 
{ TSortData const   *a ;
  TSortData const   *b ;

  {
  a = (TSortData const   *)a_;
  b = (TSortData const   *)b_;
  return (a->nOrder - b->nOrder);
}
}
static TSort *prepare(apr_pool_t *p , TSortData *pItems , int nItems ) 
{ TSort *pData ;
  TSort *tmp ;
  int n ;
  void *tmp___0 ;
  int i ;
  int k ;
  int l ;
  int tmp___1 ;
  int l___0 ;
  int tmp___2 ;

  {
  tmp = (TSort *)apr_palloc(p, (unsigned int )nItems * sizeof((*pData)));
  pData = tmp;
  qsort((void *)pItems, (unsigned int )nItems, sizeof((*pItems)), & crude_order);
  n = 0;
  while (n < nItems) {
    (pData + n)->nPredecessors = 0;
    tmp___0 = apr_palloc(p, (unsigned int )nItems * sizeof((*((pData + n)->ppPredecessors))));
    (pData + n)->ppPredecessors = (struct tsort_ **)memset(tmp___0, 0, (unsigned int )nItems *
                                                                       sizeof((*((pData +
                                                                                  n)->ppPredecessors))));
    (pData + n)->pNext = (struct tsort_ *)((void *)0);
    (pData + n)->pData = (void *)(pItems + n);
    n ++;
  }
  n = 0;
  while (n < nItems) {
    i = 0;
    while (1) {
      if ((pItems + n)->aszPredecessors) {
        if (! (*((pItems + n)->aszPredecessors + i))) {
          goto _L;
        }
      } else {
        _L: 
        break;
      }
      k = 0;
      while (k < nItems) {
        tmp___1 = strcmp((pItems + k)->szName, (char const   *)(*((pItems + n)->aszPredecessors +
                                                                  i)));
        if (! tmp___1) {
          l = 0;
          while (l < (pData + n)->nPredecessors) {
            if ((unsigned int )(*((pData + n)->ppPredecessors + l)) == (unsigned int )(pData +
                                                                                       k)) {
              goto got_it;
            }
            l ++;
          }
          (*((pData + n)->ppPredecessors + (pData + n)->nPredecessors)) = pData +
                                                                          k;
          (pData + n)->nPredecessors = (pData + n)->nPredecessors + 1;
          got_it: 
          break;
        }
        k ++;
      }
      i ++;
    }
    i = 0;
    while (1) {
      if ((pItems + n)->aszSuccessors) {
        if (! (*((pItems + n)->aszSuccessors + i))) {
          goto _L___0;
        }
      } else {
        _L___0: 
        break;
      }
      k = 0;
      while (k < nItems) {
        tmp___2 = strcmp((pItems + k)->szName, (char const   *)(*((pItems + n)->aszSuccessors +
                                                                  i)));
        if (! tmp___2) {
          l___0 = 0;
          while (l___0 < (pData + k)->nPredecessors) {
            if ((unsigned int )(*((pData + k)->ppPredecessors + l___0)) == (unsigned int )(pData +
                                                                                           n)) {
              goto got_it2;
            }
            l___0 ++;
          }
          (*((pData + k)->ppPredecessors + (pData + k)->nPredecessors)) = pData +
                                                                          n;
          (pData + k)->nPredecessors = (pData + k)->nPredecessors + 1;
          got_it2: 
          break;
        }
        k ++;
      }
      i ++;
    }
    n ++;
  }
  return (pData);
}
}
static TSort *tsort(TSort *pData , int nItems ) 
{ int nTotal ;
  TSort *pHead ;
  TSort *pTail ;
  int n ;
  int i ;
  int k ;

  {
  pHead = (TSort *)((void *)0);
  pTail = (TSort *)((void *)0);
  nTotal = 0;
  while (nTotal < nItems) {
    n = 0;
    while (1) {
      if (n == nItems) {
        __assert_fail("0", "apr_hooks.c", 178U, "tsort");
      }
      if (! (pData + n)->pNext) {
        if (! (pData + n)->nPredecessors) {
          break;
        } else {
          goto _L;
        }
      } else {
        _L: ;
      }
      n ++;
    }
    if (pTail) {
      pTail->pNext = pData + n;
    } else {
      pHead = pData + n;
    }
    pTail = pData + n;
    pTail->pNext = pTail;
    i = 0;
    while (i < nItems) {
      k = 0;
      while ((*((pData + i)->ppPredecessors + k))) {
        if ((unsigned int )(*((pData + i)->ppPredecessors + k)) == (unsigned int )(pData +
                                                                                   n)) {
          (pData + i)->nPredecessors = (pData + i)->nPredecessors - 1;
          break;
        }
        k ++;
      }
      i ++;
    }
    nTotal ++;
  }
  pTail->pNext = (struct tsort_ *)((void *)0);
  return (pHead);
}
}
static apr_array_header_t *sort_hook(apr_array_header_t *pHooks , char const   *szName ) 
{ apr_pool_t *p ;
  TSort *pSort ;
  apr_array_header_t *pNew ;
  int n ;
  TSortData *pHook ;

  {
  apr_pool_create_ex(& p, apr_hook_global_pool, (int (*)(int retcode ))((void *)0),
                     (apr_allocator_t *)((void *)0));
  pSort = prepare(p, (TSortData *)pHooks->elts, pHooks->nelts);
  pSort = tsort(pSort, pHooks->nelts);
  pNew = apr_array_make(apr_hook_global_pool, pHooks->nelts, (int )sizeof(TSortData ));
  if (apr_hook_debug_enabled) {
    printf((char const   * __restrict  )"Sorting %s:", szName);
  }
  n = 0;
  while (pSort) {
    if (! (n < pHooks->nelts)) {
      __assert_fail("n < pHooks->nelts", "apr_hooks.c", 215U, "sort_hook");
    }
    pHook = (TSortData *)apr_array_push(pNew);
    memcpy((void * __restrict  )pHook, (void const   * __restrict  )pSort->pData,
           sizeof((*pHook)));
    if (apr_hook_debug_enabled) {
      printf((char const   * __restrict  )" %s", pHook->szName);
    }
    pSort = pSort->pNext;
    n ++;
  }
  if (apr_hook_debug_enabled) {
    fputc('\n', stdout);
  }
  return (pNew);
}
}
static apr_array_header_t *s_aHooksToSort  ;
void apr_hook_sort_register(char const   *szHookName , apr_array_header_t **paHooks ) 
{ HookSortEntry *pEntry ;

  {
  if (! s_aHooksToSort) {
    s_aHooksToSort = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(HookSortEntry ));
  }
  pEntry = (HookSortEntry *)apr_array_push(s_aHooksToSort);
  pEntry->szHookName = szHookName;
  pEntry->paHooks = paHooks;
  return;
}
}
void apr_hook_sort_all(void) 
{ int n ;
  HookSortEntry *pEntry ;

  {
  n = 0;
  while (n < s_aHooksToSort->nelts) {
    pEntry = (HookSortEntry *)s_aHooksToSort->elts + n;
    (*(pEntry->paHooks)) = sort_hook((*(pEntry->paHooks)), pEntry->szHookName);
    n ++;
  }
  return;
}
}
void apr_sort_hooks(void) 
{ 

  {
  apr_hook_sort_all();
  return;
}
}
static apr_hash_t *s_phOptionalHooks  ;
static apr_hash_t *s_phOptionalFunctions  ;
void apr_hook_deregister_all(void) 
{ int n ;
  HookSortEntry *pEntry ;

  {
  n = 0;
  while (n < s_aHooksToSort->nelts) {
    pEntry = (HookSortEntry *)s_aHooksToSort->elts + n;
    (*(pEntry->paHooks)) = (apr_array_header_t *)((void *)0);
    n ++;
  }
  s_aHooksToSort = (apr_array_header_t *)((void *)0);
  s_phOptionalHooks = (apr_hash_t *)((void *)0);
  s_phOptionalFunctions = (apr_hash_t *)((void *)0);
  return;
}
}
void apr_hook_debug_show(char const   *szName , char const   * const  *aszPre___1 ,
                         char const   * const  *aszSucc___2 ) 
{ int nFirst ;

  {
  printf((char const   * __restrict  )"  Hooked %s", szName);
  if (aszPre___1) {
    fputs((char const   * __restrict  )" pre(", (FILE * __restrict  )stdout);
    nFirst = 1;
    while ((*aszPre___1)) {
      if (! nFirst) {
        fputc(',', stdout);
      }
      nFirst = 0;
      fputs((char const   * __restrict  )(*aszPre___1), (FILE * __restrict  )stdout);
      aszPre___1 ++;
    }
    fputc(')', stdout);
  }
  if (aszSucc___2) {
    fputs((char const   * __restrict  )" succ(", (FILE * __restrict  )stdout);
    nFirst = 1;
    while ((*aszSucc___2)) {
      if (! nFirst) {
        fputc(',', stdout);
      }
      nFirst = 0;
      fputs((char const   * __restrict  )(*aszSucc___2), (FILE * __restrict  )stdout);
      aszSucc___2 ++;
    }
    fputc(')', stdout);
  }
  fputc('\n', stdout);
  return;
}
}
void apr_show_hook(char const   *szName , char const   * const  *aszPre___1 , char const   * const  *aszSucc___2 ) 
{ 

  {
  apr_hook_debug_show(szName, aszPre___1, aszSucc___2);
  return;
}
}
apr_array_header_t *apr_optional_hook_get(char const   *szName ) 
{ apr_array_header_t **ppArray ;
  apr_ssize_t tmp ;

  {
  if (! s_phOptionalHooks) {
    return ((apr_array_header_t *)((void *)0));
  }
  tmp = (apr_ssize_t )strlen(szName);
  ppArray = (apr_array_header_t **)apr_hash_get(s_phOptionalHooks, (void const   *)szName,
                                                tmp);
  if (! ppArray) {
    return ((apr_array_header_t *)((void *)0));
  }
  return ((*ppArray));
}
}
void apr_optional_hook_add(char const   *szName , void (*pfn)(void) , char const   * const  *aszPre___1 ,
                           char const   * const  *aszSucc___2 , int nOrder ) 
{ apr_array_header_t *pArray ;
  apr_array_header_t *tmp ;
  apr_LINK__optional_t *pHook ;
  apr_array_header_t **ppArray ;
  apr_ssize_t tmp___0 ;

  {
  tmp = apr_optional_hook_get(szName);
  pArray = tmp;
  if (! pArray) {
    pArray = apr_array_make(apr_hook_global_pool, 1, (int )sizeof(apr_LINK__optional_t ));
    if (! s_phOptionalHooks) {
      s_phOptionalHooks = apr_hash_make(apr_hook_global_pool);
    }
    ppArray = (apr_array_header_t **)apr_palloc(apr_hook_global_pool, sizeof((*ppArray)));
    (*ppArray) = pArray;
    tmp___0 = (apr_ssize_t )strlen(szName);
    apr_hash_set(s_phOptionalHooks, (void const   *)szName, tmp___0, (void const   *)ppArray);
    apr_hook_sort_register(szName, ppArray);
  }
  pHook = (apr_LINK__optional_t *)apr_array_push(pArray);
  pHook->pFunc = pfn;
  pHook->aszPredecessors = aszPre___1;
  pHook->aszSuccessors = aszSucc___2;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled) {
    apr_hook_debug_show(szName, aszPre___1, aszSucc___2);
  }
  return;
}
}
apr_opt_fn_t *apr_dynamic_fn_retrieve(char const   *szName ) 
{ apr_ssize_t tmp ;
  void (*tmp___0)(void) ;

  {
  if (! s_phOptionalFunctions) {
    return ((apr_opt_fn_t *)((void *)0));
  }
  tmp = (apr_ssize_t )strlen(szName);
  tmp___0 = (void (*)(void))apr_hash_get(s_phOptionalFunctions, (void const   *)szName,
                                         tmp);
  return (tmp___0);
}
}
apr_opt_fn_t *apr_retrieve_optional_fn(char const   *szName ) 
{ apr_opt_fn_t *tmp ;

  {
  tmp = apr_dynamic_fn_retrieve(szName);
  return (tmp);
}
}
void apr_dynamic_fn_register(char const   *szName , apr_opt_fn_t *pfn ) 
{ apr_ssize_t tmp ;

  {
  if (! s_phOptionalFunctions) {
    s_phOptionalFunctions = apr_hash_make(apr_hook_global_pool);
  }
  tmp = (apr_ssize_t )strlen(szName);
  apr_hash_set(s_phOptionalFunctions, (void const   *)szName, tmp, (void const   *)((void *)pfn));
  return;
}
}
void apr_register_optional_fn(char const   *szName , apr_opt_fn_t *pfn ) 
{ 

  {
  apr_dynamic_fn_register(szName, pfn);
  return;
}
}
#pragma merger(0,"/tmp/cil-KccMOmub.i","-g -pthread")
#pragma merger(0,"/tmp/cil-Zz2gj4rQ.i","-g -pthread")
#pragma merger(0,"/tmp/cil-Q1A8DrJa.i","-g -pthread")
static schemes_t schemes[21]  = 
  {      {"http", (unsigned short)80}, 
        {"ftp", (unsigned short)21}, 
        {"https", (unsigned short)443}, 
        {"gopher", (unsigned short)70}, 
        {"ldap", (unsigned short)389}, 
        {"nntp", (unsigned short)119}, 
        {"snews", (unsigned short)563}, 
        {"imap", (unsigned short)143}, 
        {"pop", (unsigned short)110}, 
        {"sip", (unsigned short)5060}, 
        {"rtsp", (unsigned short)554}, 
        {"wais", (unsigned short)210}, 
        {"z39.50r", (unsigned short)210}, 
        {"z39.50s", (unsigned short)210}, 
        {"prospero", (unsigned short)191}, 
        {"nfs", (unsigned short)2049}, 
        {"tip", (unsigned short)3372}, 
        {"acap", (unsigned short)674}, 
        {"telnet", (unsigned short)23}, 
        {"ssh", (unsigned short)22}, 
        {(char const   *)((void *)0), (unsigned short)65535}};
apr_port_t apr_uri_port_of_scheme(char const   *scheme_str ) 
{ schemes_t *scheme ;
  int tmp ;

  {
  scheme = schemes;
  while ((unsigned int )scheme->name != (unsigned int )((void *)0)) {
    tmp = strcasecmp(scheme_str, scheme->name);
    if (tmp == 0) {
      return (scheme->default_port);
    }
    scheme ++;
  }
  return ((unsigned short)0);
}
}
apr_port_t apr_uri_default_port_for_scheme(char const   *scheme_str ) 
{ apr_port_t tmp ;

  {
  tmp = apr_uri_port_of_scheme(scheme_str);
  return (tmp);
}
}
char *apr_uri_unparse(apr_pool_t *p , apr_uri_t const   *uptr , unsigned int flags ) 
{ char *ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int is_default_port ;
  char const   *lbrk ;
  char const   *rbrk ;
  char *tmp___4 ;
  apr_port_t tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;

  {
  ret = (char *)"";
  if (! (flags & 1U)) {
    if (uptr->user) {
      goto _L___5;
    } else {
      if (uptr->password) {
        _L___5: 
        if (uptr->user) {
          if (! (flags & 2U)) {
            goto _L;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          if (uptr->password) {
            if (! (flags & 4U)) {
              _L: 
              tmp = "@";
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
            tmp = "";
          }
        }
        if (uptr->password) {
          if (! (flags & 4U)) {
            if (flags & 8U) {
              tmp___1 = (char const   *)uptr->password;
            } else {
              tmp___1 = "XXXXXXXX";
            }
          } else {
            goto _L___2;
          }
        } else {
          _L___2: 
          tmp___1 = "";
        }
        if (uptr->password) {
          if (! (flags & 4U)) {
            tmp___2 = ":";
          } else {
            goto _L___3;
          }
        } else {
          _L___3: 
          tmp___2 = "";
        }
        if (uptr->user) {
          if (! (flags & 2U)) {
            tmp___3 = (char const   *)uptr->user;
          } else {
            goto _L___4;
          }
        } else {
          _L___4: 
          tmp___3 = "";
        }
        ret = apr_pstrcat(p, tmp___3, tmp___2, tmp___1, tmp, (void *)0);
      }
    }
    if (uptr->hostname) {
      lbrk = "";
      rbrk = "";
      tmp___4 = strchr((char const   *)uptr->hostname, ':');
      if (tmp___4) {
        lbrk = "[";
        rbrk = "]";
      }
      if ((unsigned int )uptr->port_str == (unsigned int )((void *)0)) {
        goto _L___7;
      } else {
        if ((int )uptr->port == 0) {
          _L___7: 
          goto _L___6;
        } else {
          tmp___5 = apr_uri_port_of_scheme((char const   *)uptr->scheme);
          if ((int )uptr->port == (int )tmp___5) {
            _L___6: 
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        }
      }
      is_default_port = tmp___6;
      if (is_default_port) {
        tmp___7 = "";
      } else {
        tmp___7 = (char const   *)uptr->port_str;
      }
      if (is_default_port) {
        tmp___8 = "";
      } else {
        tmp___8 = ":";
      }
      ret = apr_pstrcat(p, uptr->scheme, "://", ret, lbrk, uptr->hostname, rbrk, tmp___8,
                        tmp___7, (void *)0);
    }
  }
  if (! (flags & 16U)) {
    if (uptr->fragment) {
      if (! (flags & 32U)) {
        tmp___9 = uptr->fragment;
      } else {
        goto _L___8;
      }
    } else {
      _L___8: 
      tmp___9 = (char *)((void *)0);
    }
    if (uptr->fragment) {
      if (! (flags & 32U)) {
        tmp___10 = "#";
      } else {
        goto _L___9;
      }
    } else {
      _L___9: 
      tmp___10 = (char const   *)((void *)0);
    }
    if (uptr->query) {
      if (! (flags & 32U)) {
        tmp___11 = (char const   *)uptr->query;
      } else {
        goto _L___10;
      }
    } else {
      _L___10: 
      tmp___11 = "";
    }
    if (uptr->query) {
      if (! (flags & 32U)) {
        tmp___12 = "?";
      } else {
        goto _L___11;
      }
    } else {
      _L___11: 
      tmp___12 = "";
    }
    if (uptr->path) {
      tmp___13 = (char const   *)uptr->path;
    } else {
      tmp___13 = "";
    }
    ret = apr_pstrcat(p, ret, tmp___13, tmp___12, tmp___11, tmp___10, tmp___9, (void *)0);
  }
  return (ret);
}
}
static unsigned char const   uri_delims[256]  = 
  {      (unsigned char const   )128,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )8, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )4, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
int apr_uri_parse(apr_pool_t *p , char const   *uri , apr_uri_t *uptr ) 
{ char const   *s ;
  char const   *s1 ;
  char const   *hostinfo ;
  char *endstr ;
  int port ;
  int v6_offset1 ;
  int v6_offset2 ;

  {
  v6_offset1 = 0;
  v6_offset2 = 0;
  memset((void *)uptr, '\000', sizeof((*uptr)));
  uptr->is_initialized = 1U;
  if ((int const   )(*(uri + 0)) == 47) {
    deal_with_path: 
    s = uri;
    while (((int const   )uri_delims[(*((unsigned char *)s))] & 140) == 0) {
      s ++;
    }
    if ((unsigned int )s != (unsigned int )uri) {
      uptr->path = apr_pstrmemdup(p, uri, (unsigned int )(s - uri));
    }
    if ((int const   )(*s) == 0) {
      return (0);
    }
    if ((int const   )(*s) == 63) {
      s ++;
      s1 = strchr(s, '#');
      if (s1) {
        uptr->fragment = apr_pstrdup(p, s1 + 1);
        uptr->query = apr_pstrmemdup(p, s, (unsigned int )(s1 - s));
      } else {
        uptr->query = apr_pstrdup(p, s);
      }
      return (0);
    }
    uptr->fragment = apr_pstrdup(p, s + 1);
    return (0);
  }
  s = uri;
  while (((int const   )uri_delims[(*((unsigned char *)s))] & 255) == 0) {
    s ++;
  }
  if ((unsigned int )s == (unsigned int )uri) {
    goto _L___1;
  } else {
    if ((int const   )(*(s + 0)) != 58) {
      _L___1: 
      goto _L___0;
    } else {
      if ((int const   )(*(s + 1)) != 47) {
        _L___0: 
        goto _L;
      } else {
        if ((int const   )(*(s + 2)) != 47) {
          _L: 
          goto deal_with_path;
        }
      }
    }
  }
  uptr->scheme = apr_pstrmemdup(p, uri, (unsigned int )(s - uri));
  s += 3;
  hostinfo = s;
  while (((int const   )uri_delims[(*((unsigned char *)s))] & 142) == 0) {
    s ++;
  }
  uri = s;
  uptr->hostinfo = apr_pstrmemdup(p, hostinfo, (unsigned int )(uri - hostinfo));
  while (1) {
    s --;
    if ((unsigned int )s >= (unsigned int )hostinfo) {
      if (! ((int const   )(*s) != 64)) {
        goto _L___2;
      }
    } else {
      _L___2: 
      break;
    }
  }
  if ((unsigned int )s < (unsigned int )hostinfo) {
    deal_with_host: 
    if ((int const   )(*hostinfo) == 91) {
      v6_offset1 = 1;
      v6_offset2 = 2;
      s = uri;
      while (1) {
        s --;
        if ((unsigned int )s >= (unsigned int )hostinfo) {
          if ((int const   )(*s) != 58) {
            if (! ((int const   )(*s) != 93)) {
              goto _L___4;
            }
          } else {
            goto _L___4;
          }
        } else {
          _L___4: 
          break;
        }
      }
      if ((unsigned int )s < (unsigned int )hostinfo) {
        goto _L___5;
      } else {
        if ((int const   )(*s) == 93) {
          _L___5: 
          s = (char const   *)((void *)0);
        }
      }
    } else {
      s = (char const   *)memchr((void const   *)hostinfo, ':', (unsigned int )(uri -
                                                                                hostinfo));
    }
    if ((unsigned int )s == (unsigned int )((void *)0)) {
      uptr->hostname = apr_pstrmemdup(p, hostinfo + v6_offset1, (unsigned int )((uri -
                                                                                 hostinfo) -
                                                                                v6_offset2));
      goto deal_with_path;
    }
    uptr->hostname = apr_pstrmemdup(p, hostinfo + v6_offset1, (unsigned int )((s -
                                                                               hostinfo) -
                                                                              v6_offset2));
    s ++;
    uptr->port_str = apr_pstrmemdup(p, s, (unsigned int )(uri - s));
    if ((unsigned int )uri != (unsigned int )s) {
      port = (int )strtol((char const   * __restrict  )uptr->port_str, (char ** __restrict  )(& endstr),
                          10);
      uptr->port = (unsigned short )port;
      if ((int )(*endstr) == 0) {
        goto deal_with_path;
      }
      return (20014);
    }
    uptr->port = apr_uri_port_of_scheme((char const   *)uptr->scheme);
    goto deal_with_path;
  }
  s1 = (char const   *)memchr((void const   *)hostinfo, ':', (unsigned int )(s - hostinfo));
  if (s1) {
    uptr->user = apr_pstrmemdup(p, hostinfo, (unsigned int )(s1 - hostinfo));
    s1 ++;
    uptr->password = apr_pstrmemdup(p, s1, (unsigned int )(s - s1));
  } else {
    uptr->user = apr_pstrmemdup(p, hostinfo, (unsigned int )(s - hostinfo));
  }
  hostinfo = s + 1;
  goto deal_with_host;
}
}
int apr_uri_parse_hostinfo(apr_pool_t *p , char const   *hostinfo , apr_uri_t *uptr ) 
{ char const   *s ;
  char *endstr ;
  char const   *rsb ;
  int v6_offset1 ;

  {
  v6_offset1 = 0;
  memset((void *)uptr, '\000', sizeof((*uptr)));
  uptr->is_initialized = 1U;
  uptr->hostinfo = apr_pstrdup(p, hostinfo);
  if ((int const   )(*hostinfo) == 91) {
    rsb = strchr(hostinfo, ']');
    if ((unsigned int )rsb == (unsigned int )((void *)0)) {
      goto _L;
    } else {
      if ((int const   )(*(rsb + 1)) != 58) {
        _L: 
        return (20014);
      }
    }
    s = rsb + 1;
    hostinfo ++;
    v6_offset1 = 1;
  } else {
    s = strchr(hostinfo, ':');
  }
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    return (20014);
  }
  uptr->hostname = apr_pstrndup(p, hostinfo, (unsigned int )((s - hostinfo) - v6_offset1));
  s ++;
  uptr->port_str = apr_pstrdup(p, s);
  if ((int const   )(*s) != 0) {
    uptr->port = (apr_port_t )strtol((char const   * __restrict  )uptr->port_str,
                                     (char ** __restrict  )(& endstr), 10);
    if ((int )(*endstr) == 0) {
      return (0);
    }
  }
  return (20014);
}
}
#pragma merger(0,"/tmp/cil-7VdFezFE.i","-g -pthread")
extern XML_Parser XML_ParserCreate(XML_Char const   *encoding ) ;
extern void XML_SetElementHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                    XML_Char const   *name ,
                                                                    XML_Char const   **atts ) ,
                                  void (*end)(void *userData , XML_Char const   *name ) ) ;
extern void XML_SetCharacterDataHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                            XML_Char const   *s ,
                                                                            int len ) ) ;
extern void XML_SetUserData(XML_Parser parser , void *userData ) ;
extern enum XML_Status XML_Parse(XML_Parser parser , char const   *s , int len , int isFinal ) ;
extern enum XML_Error XML_GetErrorCode(XML_Parser parser ) ;
extern void XML_ParserFree(XML_Parser parser ) ;
extern XML_LChar const   *XML_ErrorString(enum XML_Error code ) ;
static int find_prefix(apr_xml_parser *parser , char const   *prefix ) 
{ apr_xml_elem *elem ;
  apr_xml_ns_scope *ns_scope ;
  int tmp ;

  {
  elem = parser->cur_elem;
  while (elem) {
    ns_scope = elem->ns_scope;
    ns_scope = elem->ns_scope;
    while (ns_scope) {
      tmp = strcmp(prefix, ns_scope->prefix);
      if (tmp == 0) {
        if (ns_scope->emptyURI) {
          return (-10);
        }
        return (ns_scope->ns);
      }
      ns_scope = ns_scope->next;
    }
    elem = elem->parent;
  }
  if ((int const   )(*prefix) == 0) {
    return (-10);
  }
  return (-1000);
}
}
static void start_handler(void *userdata , char const   *name , char const   **attrs ) 
{ apr_xml_parser *parser ;
  apr_xml_elem *elem ;
  apr_xml_attr *attr ;
  apr_xml_attr *prev ;
  char *colon ;
  char const   *quoted ;
  char *elem_name ;
  void *tmp ;
  char const   **tmp___0 ;
  char const   **tmp___1 ;
  char const   *prefix ;
  apr_xml_ns_scope *ns_scope ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *attr_name ;

  {
  parser = (apr_xml_parser *)userdata;
  if (parser->error) {
    return;
  }
  tmp = apr_palloc(parser->p, sizeof((*elem)));
  elem = (apr_xml_elem *)memset(tmp, 0, sizeof((*elem)));
  elem_name = apr_pstrdup(parser->p, name);
  elem->name = (char const   *)elem_name;
  while ((*attrs)) {
    attr = (apr_xml_attr *)apr_palloc(parser->p, sizeof((*attr)));
    tmp___0 = attrs;
    attrs ++;
    attr->name = apr_pstrdup(parser->p, (*tmp___0));
    tmp___1 = attrs;
    attrs ++;
    attr->value = apr_pstrdup(parser->p, (*tmp___1));
    attr->next = elem->attr;
    elem->attr = attr;
  }
  if ((unsigned int )parser->cur_elem == (unsigned int )((void *)0)) {
    (parser->doc)->root = elem;
    parser->cur_elem = (parser->doc)->root;
  } else {
    elem->parent = parser->cur_elem;
    if ((unsigned int )(elem->parent)->last_child == (unsigned int )((void *)0)) {
      (elem->parent)->last_child = elem;
      (elem->parent)->first_child = (elem->parent)->last_child;
    } else {
      ((elem->parent)->last_child)->next = elem;
      (elem->parent)->last_child = elem;
    }
    parser->cur_elem = elem;
  }
  prev = (apr_xml_attr *)((void *)0);
  attr = elem->attr;
  while (attr) {
    tmp___4 = strncmp(attr->name, "xmlns", 5U);
    if (tmp___4 == 0) {
      prefix = attr->name + 5;
      if ((int const   )(*prefix) == 58) {
        if ((int const   )(*(attr->value + 0)) == 0) {
          parser->error = -1001;
          return;
        }
        prefix ++;
      } else {
        if ((int const   )(*prefix) != 0) {
          prev = attr;
          goto __Cont;
        }
      }
      quoted = apr_xml_quote_string(parser->p, attr->value, 1);
      tmp___2 = apr_palloc(parser->p, sizeof((*ns_scope)));
      ns_scope = (apr_xml_ns_scope *)memset(tmp___2, 0, sizeof((*ns_scope)));
      ns_scope->prefix = prefix;
      ns_scope->ns = apr_xml_insert_uri((parser->doc)->namespaces, quoted);
      ns_scope->emptyURI = (int const   )(*quoted) == 0;
      ns_scope->next = elem->ns_scope;
      elem->ns_scope = ns_scope;
      if ((unsigned int )prev == (unsigned int )((void *)0)) {
        elem->attr = attr->next;
      } else {
        prev->next = attr->next;
      }
    } else {
      tmp___3 = strcmp(attr->name, "xml:lang");
      if (tmp___3 == 0) {
        elem->lang = apr_xml_quote_string(parser->p, attr->value, 1);
        if ((unsigned int )prev == (unsigned int )((void *)0)) {
          elem->attr = attr->next;
        } else {
          prev->next = attr->next;
        }
      } else {
        prev = attr;
      }
    }
    __Cont: 
    attr = attr->next;
  }
  if ((unsigned int )elem->lang == (unsigned int )((void *)0)) {
    if ((unsigned int )elem->parent != (unsigned int )((void *)0)) {
      elem->lang = (elem->parent)->lang;
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  colon = strchr((char const   *)elem_name, ':');
  if ((unsigned int )colon == (unsigned int )((void *)0)) {
    elem->ns = find_prefix(parser, "");
  } else {
    if ((int const   )(*(elem->name + 0)) == 88) {
      goto _L___4;
    } else {
      if ((int const   )(*(elem->name + 0)) == 120) {
        _L___4: 
        if ((int const   )(*(elem->name + 1)) == 77) {
          goto _L___3;
        } else {
          if ((int const   )(*(elem->name + 1)) == 109) {
            _L___3: 
            if ((int const   )(*(elem->name + 2)) == 76) {
              goto _L___1;
            } else {
              if ((int const   )(*(elem->name + 2)) == 108) {
                _L___1: 
                elem->ns = -10;
              } else {
                goto _L___2;
              }
            }
          } else {
            goto _L___2;
          }
        }
      } else {
        _L___2: 
        (*colon) = (char )'\000';
        elem->ns = find_prefix(parser, elem->name);
        elem->name = (char const   *)(colon + 1);
        if (elem->ns <= -100) {
          parser->error = elem->ns;
          return;
        }
      }
    }
  }
  attr = elem->attr;
  while (attr) {
    attr_name = (char *)attr->name;
    colon = strchr((char const   *)attr_name, ':');
    if ((unsigned int )colon == (unsigned int )((void *)0)) {
      attr->ns = -10;
    } else {
      if ((int const   )(*(attr->name + 0)) == 88) {
        goto _L___9;
      } else {
        if ((int const   )(*(attr->name + 0)) == 120) {
          _L___9: 
          if ((int const   )(*(attr->name + 1)) == 77) {
            goto _L___8;
          } else {
            if ((int const   )(*(attr->name + 1)) == 109) {
              _L___8: 
              if ((int const   )(*(attr->name + 2)) == 76) {
                goto _L___6;
              } else {
                if ((int const   )(*(attr->name + 2)) == 108) {
                  _L___6: 
                  attr->ns = -10;
                } else {
                  goto _L___7;
                }
              }
            } else {
              goto _L___7;
            }
          }
        } else {
          _L___7: 
          (*colon) = (char )'\000';
          attr->ns = find_prefix(parser, attr->name);
          attr->name = (char const   *)(colon + 1);
          if (attr->ns <= -100) {
            parser->error = attr->ns;
            return;
          }
        }
      }
    }
    attr = attr->next;
  }
  return;
}
}
static void end_handler(void *userdata , char const   *name ) 
{ apr_xml_parser *parser ;

  {
  parser = (apr_xml_parser *)userdata;
  if (parser->error) {
    return;
  }
  parser->cur_elem = (parser->cur_elem)->parent;
  return;
}
}
static void cdata_handler(void *userdata , char const   *data , int len ) 
{ apr_xml_parser *parser ;
  apr_xml_elem *elem ;
  apr_text_header *hdr ;
  char const   *s ;

  {
  parser = (apr_xml_parser *)userdata;
  if (parser->error) {
    return;
  }
  elem = parser->cur_elem;
  s = apr_pstrndup(parser->p, data, (unsigned int )len);
  if ((unsigned int )elem->last_child == (unsigned int )((void *)0)) {
    hdr = & elem->first_cdata;
  } else {
    hdr = & (elem->last_child)->following_cdata;
  }
  apr_text_append(parser->p, hdr, s);
  return;
}
}
static apr_status_t cleanup_parser(void *ctx ) 
{ apr_xml_parser *parser ;

  {
  parser = (apr_xml_parser *)ctx;
  XML_ParserFree(parser->xp);
  parser->xp = (struct XML_ParserStruct *)((void *)0);
  return (0);
}
}
apr_xml_parser *apr_xml_parser_create(apr_pool_t *pool ) 
{ apr_xml_parser *parser ;
  void *tmp ;
  apr_xml_parser *tmp___0 ;
  void *tmp___1 ;
  int (*tmp___2)(int retcode ) ;

  {
  tmp = apr_palloc(pool, sizeof((*parser)));
  tmp___0 = (apr_xml_parser *)memset(tmp, 0, sizeof((*parser)));
  parser = tmp___0;
  parser->p = pool;
  tmp___1 = apr_palloc(pool, sizeof((*(parser->doc))));
  parser->doc = (apr_xml_doc *)memset(tmp___1, 0, sizeof((*(parser->doc))));
  (parser->doc)->namespaces = apr_array_make(pool, 5, (int )sizeof(char const   *));
  apr_xml_insert_uri((parser->doc)->namespaces, "DAV:");
  parser->xp = XML_ParserCreate((XML_Char const   *)((void *)0));
  if ((unsigned int )parser->xp == (unsigned int )((void *)0)) {
    tmp___2 = apr_pool_get_abort(pool);
    ((*tmp___2))(12);
    return ((apr_xml_parser *)((void *)0));
  }
  apr_pool_cleanup_register(pool, (void const   *)parser, & cleanup_parser, & apr_pool_cleanup_null);
  XML_SetUserData(parser->xp, (void *)parser);
  XML_SetElementHandler(parser->xp, & start_handler, & end_handler);
  XML_SetCharacterDataHandler(parser->xp, & cdata_handler);
  return (parser);
}
}
static apr_status_t do_parse(apr_xml_parser *parser , char const   *data , apr_size_t len ,
                             int is_final ) 
{ int rv ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned int )parser->xp == (unsigned int )((void *)0)) {
    parser->error = 2;
  } else {
    tmp = (int )XML_Parse(parser->xp, data, (int )len, is_final);
    rv = tmp;
    if (rv == 0) {
      parser->error = 1;
      parser->xp_err = XML_GetErrorCode(parser->xp);
    }
  }
  if (parser->error) {
    tmp___0 = 20014;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
apr_status_t apr_xml_parser_feed(apr_xml_parser *parser , char const   *data , apr_size_t len ) 
{ apr_status_t tmp ;

  {
  tmp = do_parse(parser, data, len, 0);
  return (tmp);
}
}
apr_status_t apr_xml_parser_done(apr_xml_parser *parser , apr_xml_doc **pdoc ) 
{ char end ;
  apr_status_t status ;
  apr_status_t tmp ;

  {
  tmp = do_parse(parser, (char const   *)(& end), 0U, 1);
  status = tmp;
  apr_pool_cleanup_run(parser->p, (void *)parser, & cleanup_parser);
  if (status) {
    return (status);
  }
  if ((unsigned int )pdoc != (unsigned int )((void *)0)) {
    (*pdoc) = parser->doc;
  }
  return (0);
}
}
char *apr_xml_parser_geterror(apr_xml_parser *parser , char *errbuf , apr_size_t errbufsize ) 
{ int error ;
  char const   *msg ;
  XML_LChar const   *tmp ;

  {
  error = parser->error;
  parser->error = 0;
  switch (error) {
  case 0: 
  msg = "No error.";
  break;
  case -1000: 
  msg = "An undefined namespace prefix was used.";
  break;
  case -1001: 
  msg = "A namespace prefix was defined with an empty URI.";
  break;
  case 1: 
  tmp = XML_ErrorString(parser->xp_err);
  apr_snprintf(errbuf, errbufsize, "XML parser error code: %s (%d)", tmp, parser->xp_err);
  return (errbuf);
  case 2: 
  msg = "The parser is not active.";
  break;
  default: 
  msg = "There was an unknown error within the XML body.";
  break;
  }
  apr_cpystrn(errbuf, msg, errbufsize);
  return (errbuf);
}
}
apr_status_t apr_xml_parse_file(apr_pool_t *p , apr_xml_parser **parser , apr_xml_doc **ppdoc ,
                                apr_file_t *xmlfd , apr_size_t buffer_length ) 
{ apr_status_t rv ;
  char *buffer ;
  apr_size_t length ;

  {
  (*parser) = apr_xml_parser_create(p);
  if ((unsigned int )(*parser) == (unsigned int )((void *)0)) {
    return (20014);
  }
  buffer = (char *)apr_palloc(p, buffer_length);
  length = buffer_length;
  rv = apr_file_read(xmlfd, (void *)buffer, & length);
  while (rv == 0) {
    rv = apr_xml_parser_feed((*parser), (char const   *)buffer, length);
    if (rv != 0) {
      return (rv);
    }
    length = buffer_length;
    rv = apr_file_read(xmlfd, (void *)buffer, & length);
  }
  if (rv != 70014) {
    return (rv);
  }
  rv = apr_xml_parser_done((*parser), ppdoc);
  (*parser) = (apr_xml_parser *)((void *)0);
  return (rv);
}
}
void apr_text_append(apr_pool_t *p , apr_text_header *hdr , char const   *text ) 
{ apr_text *t ;
  apr_text *tmp ;

  {
  tmp = (apr_text *)apr_palloc(p, sizeof((*t)));
  t = tmp;
  t->text = text;
  t->next = (struct apr_text *)((void *)0);
  if ((unsigned int )hdr->first == (unsigned int )((void *)0)) {
    hdr->last = t;
    hdr->first = hdr->last;
  } else {
    (hdr->last)->next = t;
    hdr->last = t;
  }
  return;
}
}
char const   *apr_xml_quote_string(apr_pool_t *p , char const   *s , int quotes ) 
{ char const   *scan ;
  apr_size_t len ;
  apr_size_t extra ;
  char *qstr ;
  char *qscan ;
  char c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;

  {
  len = 0U;
  extra = 0U;
  scan = s;
  while (1) {
    c = (char )(*scan);
    if (! ((int )c != 0)) {
      break;
    }
    if ((int )c == 60) {
      goto _L___0;
    } else {
      if ((int )c == 62) {
        _L___0: 
        extra += 3U;
      } else {
        if ((int )c == 38) {
          extra += 4U;
        } else {
          if (quotes) {
            if ((int )c == 34) {
              extra += 5U;
            } else {
              goto _L;
            }
          } else {
            _L: ;
          }
        }
      }
    }
    scan ++;
    len ++;
  }
  if (extra == 0U) {
    return (s);
  }
  qstr = (char *)apr_palloc(p, (len + extra) + 1U);
  scan = s;
  qscan = qstr;
  while (1) {
    c = (char )(*scan);
    if (! ((int )c != 0)) {
      break;
    }
    if ((int )c == 60) {
      tmp = qscan;
      qscan ++;
      (*tmp) = (char )'&';
      tmp___0 = qscan;
      qscan ++;
      (*tmp___0) = (char )'l';
      tmp___1 = qscan;
      qscan ++;
      (*tmp___1) = (char )'t';
      tmp___2 = qscan;
      qscan ++;
      (*tmp___2) = (char )';';
    } else {
      if ((int )c == 62) {
        tmp___3 = qscan;
        qscan ++;
        (*tmp___3) = (char )'&';
        tmp___4 = qscan;
        qscan ++;
        (*tmp___4) = (char )'g';
        tmp___5 = qscan;
        qscan ++;
        (*tmp___5) = (char )'t';
        tmp___6 = qscan;
        qscan ++;
        (*tmp___6) = (char )';';
      } else {
        if ((int )c == 38) {
          tmp___7 = qscan;
          qscan ++;
          (*tmp___7) = (char )'&';
          tmp___8 = qscan;
          qscan ++;
          (*tmp___8) = (char )'a';
          tmp___9 = qscan;
          qscan ++;
          (*tmp___9) = (char )'m';
          tmp___10 = qscan;
          qscan ++;
          (*tmp___10) = (char )'p';
          tmp___11 = qscan;
          qscan ++;
          (*tmp___11) = (char )';';
        } else {
          if (quotes) {
            if ((int )c == 34) {
              tmp___12 = qscan;
              qscan ++;
              (*tmp___12) = (char )'&';
              tmp___13 = qscan;
              qscan ++;
              (*tmp___13) = (char )'q';
              tmp___14 = qscan;
              qscan ++;
              (*tmp___14) = (char )'u';
              tmp___15 = qscan;
              qscan ++;
              (*tmp___15) = (char )'o';
              tmp___16 = qscan;
              qscan ++;
              (*tmp___16) = (char )'t';
              tmp___17 = qscan;
              qscan ++;
              (*tmp___17) = (char )';';
            } else {
              goto _L___1;
            }
          } else {
            _L___1: 
            tmp___18 = qscan;
            qscan ++;
            (*tmp___18) = c;
          }
        }
      }
    }
    scan ++;
  }
  (*qscan) = (char )'\000';
  return ((char const   *)qstr);
}
}
static apr_size_t text_size(apr_text const   *t ) 
{ apr_size_t size ;
  size_t tmp ;

  {
  size = 0U;
  while (t) {
    tmp = strlen(t->text);
    size += tmp;
    t = (apr_text const   *)t->next;
  }
  return (size);
}
}
static apr_size_t elem_size(apr_xml_elem const   *elem , int style , apr_array_header_t *namespaces ,
                            int *ns_map ) 
{ apr_size_t size ;
  apr_xml_attr const   *attr ;
  int i ;
  int tmp___127 ;
  size_t tmp___255 ;
  int tmp___256 ;
  size_t tmp___257 ;
  size_t tmp___258 ;
  int ns ;
  int tmp___259 ;
  int tmp___388 ;
  size_t tmp___516 ;
  size_t tmp___517 ;
  size_t tmp___518 ;
  int tmp___647 ;
  size_t tmp___775 ;
  size_t tmp___776 ;
  size_t tmp___777 ;
  size_t tmp___779 ;
  apr_size_t tmp___780 ;
  apr_size_t tmp___781 ;
  apr_size_t tmp___782 ;

  {
  if (style == 0) {
    goto _L___2;
  } else {
    if (style == 3) {
      _L___2: 
      size = 0U;
      if (style == 3) {
        i = namespaces->nelts;
        while (1) {
          tmp___256 = i;
          i --;
          if (! tmp___256) {
            break;
          }
          if (i < 10) {
            tmp___127 = 1;
          } else {
            if (i < 100) {
              tmp___127 = 2;
            } else {
              if (i < 1000) {
                tmp___127 = 3;
              } else {
                if (i < 10000) {
                  tmp___127 = 4;
                } else {
                  if (i < 100000) {
                    tmp___127 = 5;
                  } else {
                    if (i < 1000000) {
                      tmp___127 = 6;
                    } else {
                      if (i < 10000000) {
                        tmp___127 = 7;
                      } else {
                        if (i < 100000000) {
                          tmp___127 = 8;
                        } else {
                          if (i < 1000000000) {
                            tmp___127 = 9;
                          } else {
                            tmp___127 = 10;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          tmp___255 = strlen((char const   *)(*((char const   * const  *)namespaces->elts +
                                                i)));
          size += ((unsigned int )((9 + tmp___127) + 2) + tmp___255) + 1U;
        }
        if ((unsigned int )elem->lang != (unsigned int )((void *)0)) {
          tmp___257 = strlen(elem->lang);
          size += (11U + tmp___257) + 1U;
        }
      }
      if (elem->ns == -10) {
        tmp___258 = strlen(elem->name);
        size += (1U + tmp___258) + 1U;
      } else {
        if (ns_map) {
          tmp___259 = (*(ns_map + elem->ns));
        } else {
          tmp___259 = elem->ns;
        }
        ns = tmp___259;
        if (ns < 10) {
          tmp___388 = 1;
        } else {
          if (ns < 100) {
            tmp___388 = 2;
          } else {
            if (ns < 1000) {
              tmp___388 = 3;
            } else {
              if (ns < 10000) {
                tmp___388 = 4;
              } else {
                if (ns < 100000) {
                  tmp___388 = 5;
                } else {
                  if (ns < 1000000) {
                    tmp___388 = 6;
                  } else {
                    if (ns < 10000000) {
                      tmp___388 = 7;
                    } else {
                      if (ns < 100000000) {
                        tmp___388 = 8;
                      } else {
                        if (ns < 1000000000) {
                          tmp___388 = 9;
                        } else {
                          tmp___388 = 10;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        tmp___516 = strlen(elem->name);
        size += ((unsigned int )((3 + tmp___388) + 1) + tmp___516) + 1U;
      }
      if ((unsigned int )elem->first_child == (unsigned int )((void *)0)) {
        if ((unsigned int )elem->first_cdata.first == (unsigned int )((void *)0)) {
          size ++;
        } else {
          goto _L;
        }
      } else {
        _L: 
        size = 2U * size + 1U;
      }
      attr = (apr_xml_attr const   *)elem->attr;
      while (attr) {
        if (attr->ns == -10) {
          tmp___517 = strlen(attr->name);
          tmp___518 = strlen(attr->value);
          size += (((1U + tmp___517) + 2U) + tmp___518) + 1U;
        } else {
          if (attr->ns < 10) {
            tmp___647 = 1;
          } else {
            if (attr->ns < 100) {
              tmp___647 = 2;
            } else {
              if (attr->ns < 1000) {
                tmp___647 = 3;
              } else {
                if (attr->ns < 10000) {
                  tmp___647 = 4;
                } else {
                  if (attr->ns < 100000) {
                    tmp___647 = 5;
                  } else {
                    if (attr->ns < 1000000) {
                      tmp___647 = 6;
                    } else {
                      if (attr->ns < 10000000) {
                        tmp___647 = 7;
                      } else {
                        if (attr->ns < 100000000) {
                          tmp___647 = 8;
                        } else {
                          if (attr->ns < 1000000000) {
                            tmp___647 = 9;
                          } else {
                            tmp___647 = 10;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          tmp___775 = strlen(attr->name);
          tmp___776 = strlen(attr->value);
          size += ((((unsigned int )((3 + tmp___647) + 1) + tmp___775) + 2U) + tmp___776) +
                  1U;
        }
        attr = (apr_xml_attr const   *)attr->next;
      }
      if ((unsigned int )elem->lang != (unsigned int )((void *)0)) {
        if ((unsigned int )elem->parent == (unsigned int )((void *)0)) {
          goto _L___1;
        } else {
          if ((unsigned int )elem->lang != (unsigned int )(elem->parent)->lang) {
            _L___1: 
            tmp___777 = strlen(elem->lang);
            size += (11U + tmp___777) + 1U;
          } else {
            goto _L___0;
          }
        }
      } else {
        _L___0: ;
      }
    } else {
      if (style == 2) {
        if (elem->lang) {
          tmp___779 = strlen(elem->lang);
          size = tmp___779 + 1U;
        } else {
          size = 1U;
        }
      } else {
        size = 0U;
      }
    }
  }
  tmp___780 = text_size((apr_text const   *)elem->first_cdata.first);
  size += tmp___780;
  elem = (apr_xml_elem const   *)elem->first_child;
  while (elem) {
    tmp___781 = elem_size(elem, 0, (apr_array_header_t *)((void *)0), ns_map);
    tmp___782 = text_size((apr_text const   *)elem->following_cdata.first);
    size += tmp___781 + tmp___782;
    elem = (apr_xml_elem const   *)elem->next;
  }
  return (size);
}
}
static char *write_text(char *s , apr_text const   *t ) 
{ apr_size_t len ;
  apr_size_t tmp ;

  {
  while (t) {
    tmp = strlen(t->text);
    len = tmp;
    memcpy((void * __restrict  )s, (void const   * __restrict  )t->text, len);
    s += len;
    t = (apr_text const   *)t->next;
  }
  return (s);
}
}
static char *write_elem(char *s , apr_xml_elem const   *elem , int style , apr_array_header_t *namespaces ,
                        int *ns_map ) 
{ apr_xml_elem const   *child ;
  apr_size_t len ;
  int ns ;
  int empty ;
  int tmp ;
  apr_xml_attr const   *attr ;
  int i ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  if (style == 0) {
    goto _L___3;
  } else {
    if (style == 3) {
      _L___3: 
      if ((unsigned int )elem->first_child == (unsigned int )((void *)0)) {
        if ((unsigned int )elem->first_cdata.first == (unsigned int )((void *)0)) {
          tmp = 1;
        } else {
          goto _L;
        }
      } else {
        _L: 
        tmp = 0;
      }
      empty = tmp;
      if (elem->ns == -10) {
        len = (apr_size_t )sprintf((char * __restrict  )s, (char const   * __restrict  )"<%s",
                                   elem->name);
      } else {
        if (ns_map) {
          ns = (*(ns_map + elem->ns));
        } else {
          ns = elem->ns;
        }
        len = (apr_size_t )sprintf((char * __restrict  )s, (char const   * __restrict  )"<ns%d:%s",
                                   ns, elem->name);
      }
      s += len;
      attr = (apr_xml_attr const   *)elem->attr;
      while (attr) {
        if (attr->ns == -10) {
          len = (apr_size_t )sprintf((char * __restrict  )s, (char const   * __restrict  )" %s=\"%s\"",
                                     attr->name, attr->value);
        } else {
          len = (apr_size_t )sprintf((char * __restrict  )s, (char const   * __restrict  )" ns%d:%s=\"%s\"",
                                     attr->ns, attr->name, attr->value);
        }
        s += len;
        attr = (apr_xml_attr const   *)attr->next;
      }
      if ((unsigned int )elem->lang != (unsigned int )((void *)0)) {
        if (style == 3) {
          goto _L___2;
        } else {
          if ((unsigned int )elem->parent == (unsigned int )((void *)0)) {
            _L___2: 
            goto _L___1;
          } else {
            if ((unsigned int )elem->lang != (unsigned int )(elem->parent)->lang) {
              _L___1: 
              len = (apr_size_t )sprintf((char * __restrict  )s, (char const   * __restrict  )" xml:lang=\"%s\"",
                                         elem->lang);
              s += len;
            } else {
              goto _L___0;
            }
          }
        }
      } else {
        _L___0: ;
      }
      if (style == 3) {
        i = namespaces->nelts;
        while (1) {
          tmp___0 = i;
          i --;
          if (! tmp___0) {
            break;
          }
          len = (apr_size_t )sprintf((char * __restrict  )s, (char const   * __restrict  )" xmlns:ns%d=\"%s\"",
                                     i, (*((char const   * const  *)namespaces->elts +
                                           i)));
          s += len;
        }
      }
      if (empty) {
        tmp___1 = s;
        s ++;
        (*tmp___1) = (char )'/';
        tmp___2 = s;
        s ++;
        (*tmp___2) = (char )'>';
        return (s);
      }
      tmp___3 = s;
      s ++;
      (*tmp___3) = (char )'>';
    } else {
      if (style == 2) {
        if ((unsigned int )elem->lang != (unsigned int )((void *)0)) {
          len = strlen(elem->lang);
          memcpy((void * __restrict  )s, (void const   * __restrict  )elem->lang,
                 len);
          s += len;
        }
        tmp___4 = s;
        s ++;
        (*tmp___4) = (char )'\000';
      }
    }
  }
  s = write_text(s, (apr_text const   *)elem->first_cdata.first);
  child = (apr_xml_elem const   *)elem->first_child;
  while (child) {
    s = write_elem(s, child, 0, (apr_array_header_t *)((void *)0), ns_map);
    s = write_text(s, (apr_text const   *)child->following_cdata.first);
    child = (apr_xml_elem const   *)child->next;
  }
  if (style == 0) {
    goto _L___4;
  } else {
    if (style == 3) {
      _L___4: 
      if (elem->ns == -10) {
        len = (apr_size_t )sprintf((char * __restrict  )s, (char const   * __restrict  )"</%s>",
                                   elem->name);
      } else {
        if (ns_map) {
          ns = (*(ns_map + elem->ns));
        } else {
          ns = elem->ns;
        }
        len = (apr_size_t )sprintf((char * __restrict  )s, (char const   * __restrict  )"</ns%d:%s>",
                                   ns, elem->name);
      }
      s += len;
    }
  }
  return (s);
}
}
void apr_xml_quote_elem(apr_pool_t *p , apr_xml_elem *elem ) 
{ apr_text *scan_txt ;
  apr_xml_attr *scan_attr ;
  apr_xml_elem *scan_elem ;

  {
  scan_txt = elem->first_cdata.first;
  while ((unsigned int )scan_txt != (unsigned int )((void *)0)) {
    scan_txt->text = apr_xml_quote_string(p, scan_txt->text, 0);
    scan_txt = scan_txt->next;
  }
  scan_txt = elem->following_cdata.first;
  while ((unsigned int )scan_txt != (unsigned int )((void *)0)) {
    scan_txt->text = apr_xml_quote_string(p, scan_txt->text, 0);
    scan_txt = scan_txt->next;
  }
  scan_attr = elem->attr;
  while ((unsigned int )scan_attr != (unsigned int )((void *)0)) {
    scan_attr->value = apr_xml_quote_string(p, scan_attr->value, 1);
    scan_attr = scan_attr->next;
  }
  scan_elem = elem->first_child;
  while ((unsigned int )scan_elem != (unsigned int )((void *)0)) {
    apr_xml_quote_elem(p, scan_elem);
    scan_elem = scan_elem->next;
  }
  return;
}
}
void apr_xml_to_text(apr_pool_t *p , apr_xml_elem const   *elem , int style , apr_array_header_t *namespaces ,
                     int *ns_map , char const   **pbuf , apr_size_t *psize ) 
{ apr_size_t size ;
  apr_size_t tmp ;
  char *s ;
  char *tmp___0 ;

  {
  tmp = elem_size(elem, style, namespaces, ns_map);
  size = tmp + 1U;
  tmp___0 = (char *)apr_palloc(p, size);
  s = tmp___0;
  write_elem(s, elem, style, namespaces, ns_map);
  (*(s + (size - 1U))) = (char )'\000';
  (*pbuf) = (char const   *)s;
  if (psize) {
    (*psize) = size;
  }
  return;
}
}
char const   *apr_xml_empty_elem(apr_pool_t *p , apr_xml_elem const   *elem ) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
  if (elem->ns == -10) {
    tmp = apr_psprintf(p, "<%s/>\r\n", elem->name);
    return (tmp);
  }
  tmp___0 = apr_psprintf(p, "<ns%d:%s/>\r\n", elem->ns, elem->name);
  return (tmp___0);
}
}
int apr_xml_insert_uri(apr_array_header_t *uri_array , char const   *uri ) 
{ int i ;
  char const   **pelt ;
  int tmp ;
  int tmp___0 ;

  {
  if ((int const   )(*uri) == 0) {
    return (-10);
  }
  i = uri_array->nelts;
  while (1) {
    tmp___0 = i;
    i --;
    if (! tmp___0) {
      break;
    }
    tmp = strcmp(uri, (char const   *)(*((char const   * const  *)uri_array->elts +
                                         i)));
    if (tmp == 0) {
      return (i);
    }
  }
  pelt = (char const   **)apr_array_push(uri_array);
  (*pelt) = uri;
  return (uri_array->nelts - 1);
}
}
#pragma merger(0,"/tmp/cil-jIrKUewd.i","-g -pthread")
int apr_date_checkmask(char const   *data , char const   *mask ) 
{ int i ;
  char d ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  i = 0;
  while (i < 256) {
    d = (char )(*(data + i));
    switch ((int )(*(mask + i))) {
    case 0: ;
    return ((int )d == 0);
    case 42: ;
    return (1);
    case 64: 
    tmp = __ctype_b_loc();
    if (! ((int const   )(*((*tmp) + (int )((unsigned char )d))) & 256)) {
      return (0);
    }
    break;
    case 36: 
    tmp___0 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___0) + (int )((unsigned char )d))) & 512)) {
      return (0);
    }
    break;
    case 35: 
    tmp___1 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___1) + (int )((unsigned char )d))) & 2048)) {
      return (0);
    }
    break;
    case 38: 
    tmp___2 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___2) + (int )((unsigned char )d))) & 4096)) {
      return (0);
    }
    break;
    case 126: ;
    if ((int )d != 32) {
      tmp___3 = __ctype_b_loc();
      if ((int const   )(*((*tmp___3) + (int )((unsigned char )d))) & 2048) {
        goto _L;
      } else {
        return (0);
      }
    } else {
      _L: ;
    }
    break;
    default: ;
    if ((int const   )(*(mask + i)) != (int const   )d) {
      return (0);
    }
    break;
    }
    i ++;
  }
  return (0);
}
}
static int const   months[12]  = 
  {      (int const   )4874606,      (int const   )4613474,      (int const   )5071218,      (int const   )4288626, 
        (int const   )5071225,      (int const   )4879726,      (int const   )4879724,      (int const   )4289895, 
        (int const   )5465456,      (int const   )5202804,      (int const   )5140342,      (int const   )4482403};
apr_time_t apr_date_parse_http(char const   *date ) 
{ apr_time_exp_t ds ;
  apr_time_t result ;
  int mint ;
  int mon ;
  char const   *monstr ;
  char const   *timstr ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  apr_status_t tmp___4 ;

  {
  if (! date) {
    return (0LL);
  }
  while (1) {
    if ((*date)) {
      tmp = __ctype_b_loc();
      if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*date)))) & 8192)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
    date ++;
  }
  if ((int const   )(*date) == 0) {
    return (0LL);
  }
  date = strchr(date, ' ');
  if ((unsigned int )date == (unsigned int )((void *)0)) {
    return (0LL);
  }
  date ++;
  tmp___3 = apr_date_checkmask(date, "## @$$ #### ##:##:## *");
  if (tmp___3) {
    ds.tm_year = (int )(((((int const   )(*(date + 7)) - 48) * 10 + ((int const   )(*(date +
                                                                                      8)) -
                                                                     48)) - 19) *
                        100);
    if (ds.tm_year < 0) {
      return (0LL);
    }
    ds.tm_year = ds.tm_year + (int )(((int const   )(*(date + 9)) - 48) * 10 + ((int const   )(*(date +
                                                                                                 10)) -
                                                                                48));
    ds.tm_mday = (int )(((int const   )(*(date + 0)) - 48) * 10 + ((int const   )(*(date +
                                                                                    1)) -
                                                                   48));
    monstr = date + 3;
    timstr = date + 12;
  } else {
    tmp___2 = apr_date_checkmask(date, "##-@$$-## ##:##:## *");
    if (tmp___2) {
      ds.tm_year = (int )(((int const   )(*(date + 7)) - 48) * 10 + ((int const   )(*(date +
                                                                                      8)) -
                                                                     48));
      if (ds.tm_year < 70) {
        ds.tm_year = ds.tm_year + 100;
      }
      ds.tm_mday = (int )(((int const   )(*(date + 0)) - 48) * 10 + ((int const   )(*(date +
                                                                                      1)) -
                                                                     48));
      monstr = date + 3;
      timstr = date + 10;
    } else {
      tmp___1 = apr_date_checkmask(date, "@$$ ~# ##:##:## ####*");
      if (tmp___1) {
        ds.tm_year = (int )(((((int const   )(*(date + 16)) - 48) * 10 + ((int const   )(*(date +
                                                                                           17)) -
                                                                          48)) - 19) *
                            100);
        if (ds.tm_year < 0) {
          return (0LL);
        }
        ds.tm_year = ds.tm_year + (int )(((int const   )(*(date + 18)) - 48) * 10 +
                                         ((int const   )(*(date + 19)) - 48));
        if ((int const   )(*(date + 4)) == 32) {
          ds.tm_mday = 0;
        } else {
          ds.tm_mday = (int )(((int const   )(*(date + 4)) - 48) * 10);
        }
        ds.tm_mday = ds.tm_mday + (int )((int const   )(*(date + 5)) - 48);
        monstr = date;
        timstr = date + 7;
      } else {
        tmp___0 = apr_date_checkmask(date, "# @$$ #### ##:##:## *");
        if (tmp___0) {
          ds.tm_year = (int )(((((int const   )(*(date + 6)) - 48) * 10 + ((int const   )(*(date +
                                                                                            7)) -
                                                                           48)) -
                               19) * 100);
          if (ds.tm_year < 0) {
            return (0LL);
          }
          ds.tm_year = ds.tm_year + (int )(((int const   )(*(date + 8)) - 48) * 10 +
                                           ((int const   )(*(date + 9)) - 48));
          ds.tm_mday = (int )((int const   )(*(date + 0)) - 48);
          monstr = date + 2;
          timstr = date + 11;
        } else {
          return (0LL);
        }
      }
    }
  }
  if (ds.tm_mday <= 0) {
    goto _L___0;
  } else {
    if (ds.tm_mday > 31) {
      _L___0: 
      return (0LL);
    }
  }
  ds.tm_hour = (int )(((int const   )(*(timstr + 0)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                    1)) -
                                                                   48));
  ds.tm_min = (int )(((int const   )(*(timstr + 3)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                   4)) -
                                                                  48));
  ds.tm_sec = (int )(((int const   )(*(timstr + 6)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                   7)) -
                                                                  48));
  if (ds.tm_hour > 23) {
    goto _L___2;
  } else {
    if (ds.tm_min > 59) {
      _L___2: 
      goto _L___1;
    } else {
      if (ds.tm_sec > 61) {
        _L___1: 
        return (0LL);
      }
    }
  }
  mint = (int )((((int const   )(*(monstr + 0)) << 16) | ((int const   )(*(monstr +
                                                                           1)) <<
                                                          8)) | (int const   )(*(monstr +
                                                                                 2)));
  mon = 0;
  while (mon < 12) {
    if (mint == (int )months[mon]) {
      break;
    }
    mon ++;
  }
  if (mon == 12) {
    return (0LL);
  }
  if (ds.tm_mday == 31) {
    if (mon == 3) {
      goto _L___6;
    } else {
      if (mon == 5) {
        _L___6: 
        goto _L___5;
      } else {
        if (mon == 8) {
          _L___5: 
          goto _L___4;
        } else {
          if (mon == 10) {
            _L___4: 
            return (0LL);
          } else {
            goto _L___3;
          }
        }
      }
    }
  } else {
    _L___3: ;
  }
  if (mon == 1) {
    if (ds.tm_mday > 29) {
      goto _L___10;
    } else {
      if (ds.tm_mday == 29) {
        if (ds.tm_year & 3) {
          goto _L___10;
        } else {
          if (ds.tm_year % 100 == 0) {
            if (ds.tm_year % 400 != 100) {
              _L___10: 
              return (0LL);
            } else {
              goto _L___11;
            }
          } else {
            _L___11: 
            goto _L___9;
          }
        }
      } else {
        _L___9: 
        goto _L___7;
      }
    }
  } else {
    _L___7: ;
  }
  ds.tm_mon = mon;
  ds.tm_usec = 0;
  ds.tm_gmtoff = 0;
  tmp___4 = apr_time_exp_get(& result, & ds);
  if (tmp___4 != 0) {
    return (0LL);
  }
  return (result);
}
}
static int const   months___0[12]  = 
  {      (int const   )4874606,      (int const   )4613474,      (int const   )5071218,      (int const   )4288626, 
        (int const   )5071225,      (int const   )4879726,      (int const   )4879724,      (int const   )4289895, 
        (int const   )5465456,      (int const   )5202804,      (int const   )5140342,      (int const   )4482403};
apr_time_t apr_date_parse_rfc(char const   *date ) 
{ apr_time_exp_t ds ;
  apr_time_t result ;
  int mint ;
  int mon ;
  char const   *monstr ;
  char const   *timstr ;
  char const   *gmtstr ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int offset ;
  char const   *tmp___12 ;
  apr_status_t tmp___13 ;

  {
  if (! date) {
    return (0LL);
  }
  tmp___0 = __ctype_b_loc();
  if (! ((int const   )(*((*tmp___0) + (int )((unsigned char )(*(date + 0))))) & 2048)) {
    while (1) {
      if ((*date)) {
        tmp = __ctype_b_loc();
        if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*date)))) & 8192)) {
          goto _L;
        }
      } else {
        _L: 
        break;
      }
      date ++;
    }
    if ((int const   )(*date) == 0) {
      return (0LL);
    }
    date = strchr(date, ' ');
    if ((unsigned int )date == (unsigned int )((void *)0)) {
      return (0LL);
    }
    date ++;
  }
  tmp___11 = apr_date_checkmask(date, "## @$$ #### ##:##:## *");
  if (tmp___11) {
    ds.tm_year = (int )(((((int const   )(*(date + 7)) - 48) * 10 + ((int const   )(*(date +
                                                                                      8)) -
                                                                     48)) - 19) *
                        100);
    if (ds.tm_year < 0) {
      return (0LL);
    }
    ds.tm_year = ds.tm_year + (int )(((int const   )(*(date + 9)) - 48) * 10 + ((int const   )(*(date +
                                                                                                 10)) -
                                                                                48));
    ds.tm_mday = (int )(((int const   )(*(date + 0)) - 48) * 10 + ((int const   )(*(date +
                                                                                    1)) -
                                                                   48));
    monstr = date + 3;
    timstr = date + 12;
    gmtstr = date + 20;
    ds.tm_hour = (int )(((int const   )(*(timstr + 0)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                      1)) -
                                                                     48));
    ds.tm_min = (int )(((int const   )(*(timstr + 3)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                     4)) -
                                                                    48));
    ds.tm_sec = (int )(((int const   )(*(timstr + 6)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                     7)) -
                                                                    48));
  } else {
    tmp___10 = apr_date_checkmask(date, "##-@$$-## ##:##:## *");
    if (tmp___10) {
      ds.tm_year = (int )(((int const   )(*(date + 7)) - 48) * 10 + ((int const   )(*(date +
                                                                                      8)) -
                                                                     48));
      if (ds.tm_year < 70) {
        ds.tm_year = ds.tm_year + 100;
      }
      ds.tm_mday = (int )(((int const   )(*(date + 0)) - 48) * 10 + ((int const   )(*(date +
                                                                                      1)) -
                                                                     48));
      monstr = date + 3;
      timstr = date + 10;
      gmtstr = date + 19;
      ds.tm_hour = (int )(((int const   )(*(timstr + 0)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                        1)) -
                                                                       48));
      ds.tm_min = (int )(((int const   )(*(timstr + 3)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                       4)) -
                                                                      48));
      ds.tm_sec = (int )(((int const   )(*(timstr + 6)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                       7)) -
                                                                      48));
    } else {
      tmp___9 = apr_date_checkmask(date, "@$$ ~# ##:##:## ####*");
      if (tmp___9) {
        ds.tm_year = (int )(((((int const   )(*(date + 16)) - 48) * 10 + ((int const   )(*(date +
                                                                                           17)) -
                                                                          48)) - 19) *
                            100);
        if (ds.tm_year < 0) {
          return (0LL);
        }
        ds.tm_year = ds.tm_year + (int )(((int const   )(*(date + 18)) - 48) * 10 +
                                         ((int const   )(*(date + 19)) - 48));
        if ((int const   )(*(date + 4)) == 32) {
          ds.tm_mday = 0;
        } else {
          ds.tm_mday = (int )(((int const   )(*(date + 4)) - 48) * 10);
        }
        ds.tm_mday = ds.tm_mday + (int )((int const   )(*(date + 5)) - 48);
        monstr = date;
        timstr = date + 7;
        gmtstr = (char const   *)((void *)0);
        ds.tm_hour = (int )(((int const   )(*(timstr + 0)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                          1)) -
                                                                         48));
        ds.tm_min = (int )(((int const   )(*(timstr + 3)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                         4)) -
                                                                        48));
        ds.tm_sec = (int )(((int const   )(*(timstr + 6)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                         7)) -
                                                                        48));
      } else {
        tmp___8 = apr_date_checkmask(date, "# @$$ #### ##:##:## *");
        if (tmp___8) {
          ds.tm_year = (int )(((((int const   )(*(date + 6)) - 48) * 10 + ((int const   )(*(date +
                                                                                            7)) -
                                                                           48)) -
                               19) * 100);
          if (ds.tm_year < 0) {
            return (0LL);
          }
          ds.tm_year = ds.tm_year + (int )(((int const   )(*(date + 8)) - 48) * 10 +
                                           ((int const   )(*(date + 9)) - 48));
          ds.tm_mday = (int )((int const   )(*(date + 0)) - 48);
          monstr = date + 2;
          timstr = date + 11;
          gmtstr = date + 20;
          ds.tm_hour = (int )(((int const   )(*(timstr + 0)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                            1)) -
                                                                           48));
          ds.tm_min = (int )(((int const   )(*(timstr + 3)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                           4)) -
                                                                          48));
          ds.tm_sec = (int )(((int const   )(*(timstr + 6)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                           7)) -
                                                                          48));
        } else {
          tmp___7 = apr_date_checkmask(date, "## @$$ ## ##:##:## *");
          if (tmp___7) {
            ds.tm_year = (int )(((int const   )(*(date + 7)) - 48) * 10 + ((int const   )(*(date +
                                                                                            8)) -
                                                                           48));
            if (ds.tm_year < 70) {
              ds.tm_year = ds.tm_year + 100;
            }
            ds.tm_mday = (int )(((int const   )(*(date + 0)) - 48) * 10 + ((int const   )(*(date +
                                                                                            1)) -
                                                                           48));
            monstr = date + 3;
            timstr = date + 10;
            gmtstr = date + 19;
            ds.tm_hour = (int )(((int const   )(*(timstr + 0)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                              1)) -
                                                                             48));
            ds.tm_min = (int )(((int const   )(*(timstr + 3)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                             4)) -
                                                                            48));
            ds.tm_sec = (int )(((int const   )(*(timstr + 6)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                             7)) -
                                                                            48));
          } else {
            tmp___6 = apr_date_checkmask(date, "# @$$ ## ##:##:## *");
            if (tmp___6) {
              ds.tm_year = (int )(((int const   )(*(date + 6)) - 48) * 10 + ((int const   )(*(date +
                                                                                              7)) -
                                                                             48));
              if (ds.tm_year < 70) {
                ds.tm_year = ds.tm_year + 100;
              }
              ds.tm_mday = (int )((int const   )(*(date + 0)) - 48);
              monstr = date + 2;
              timstr = date + 9;
              gmtstr = date + 18;
              ds.tm_hour = (int )(((int const   )(*(timstr + 0)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                                1)) -
                                                                               48));
              ds.tm_min = (int )(((int const   )(*(timstr + 3)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                               4)) -
                                                                              48));
              ds.tm_sec = (int )(((int const   )(*(timstr + 6)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                               7)) -
                                                                              48));
            } else {
              tmp___5 = apr_date_checkmask(date, "## @$$ ## ##:## *");
              if (tmp___5) {
                ds.tm_year = (int )(((int const   )(*(date + 7)) - 48) * 10 + ((int const   )(*(date +
                                                                                                8)) -
                                                                               48));
                if (ds.tm_year < 70) {
                  ds.tm_year = ds.tm_year + 100;
                }
                ds.tm_mday = (int )(((int const   )(*(date + 0)) - 48) * 10 + ((int const   )(*(date +
                                                                                                1)) -
                                                                               48));
                monstr = date + 3;
                timstr = date + 10;
                gmtstr = (char const   *)((void *)0);
                ds.tm_hour = (int )(((int const   )(*(timstr + 0)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                                  1)) -
                                                                                 48));
                ds.tm_min = (int )(((int const   )(*(timstr + 3)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                                 4)) -
                                                                                48));
                ds.tm_sec = 0;
              } else {
                tmp___4 = apr_date_checkmask(date, "# @$$ ## ##:## *");
                if (tmp___4) {
                  ds.tm_year = (int )(((int const   )(*(date + 6)) - 48) * 10 + ((int const   )(*(date +
                                                                                                  7)) -
                                                                                 48));
                  if (ds.tm_year < 70) {
                    ds.tm_year = ds.tm_year + 100;
                  }
                  ds.tm_mday = (int )((int const   )(*(date + 0)) - 48);
                  monstr = date + 2;
                  timstr = date + 9;
                  gmtstr = (char const   *)((void *)0);
                  ds.tm_hour = (int )(((int const   )(*(timstr + 0)) - 48) * 10 +
                                      ((int const   )(*(timstr + 1)) - 48));
                  ds.tm_min = (int )(((int const   )(*(timstr + 3)) - 48) * 10 + ((int const   )(*(timstr +
                                                                                                   4)) -
                                                                                  48));
                  ds.tm_sec = 0;
                } else {
                  tmp___3 = apr_date_checkmask(date, "## @$$ ## #:##:## *");
                  if (tmp___3) {
                    ds.tm_year = (int )(((int const   )(*(date + 7)) - 48) * 10 +
                                        ((int const   )(*(date + 8)) - 48));
                    if (ds.tm_year < 70) {
                      ds.tm_year = ds.tm_year + 100;
                    }
                    ds.tm_mday = (int )(((int const   )(*(date + 0)) - 48) * 10 +
                                        ((int const   )(*(date + 1)) - 48));
                    monstr = date + 3;
                    timstr = date + 9;
                    gmtstr = date + 18;
                    ds.tm_hour = (int )((int const   )(*(timstr + 1)) - 48);
                    ds.tm_min = (int )(((int const   )(*(timstr + 3)) - 48) * 10 +
                                       ((int const   )(*(timstr + 4)) - 48));
                    ds.tm_sec = (int )(((int const   )(*(timstr + 6)) - 48) * 10 +
                                       ((int const   )(*(timstr + 7)) - 48));
                  } else {
                    tmp___2 = apr_date_checkmask(date, "# @$$ ## #:##:## *");
                    if (tmp___2) {
                      ds.tm_year = (int )(((int const   )(*(date + 6)) - 48) * 10 +
                                          ((int const   )(*(date + 7)) - 48));
                      if (ds.tm_year < 70) {
                        ds.tm_year = ds.tm_year + 100;
                      }
                      ds.tm_mday = (int )((int const   )(*(date + 0)) - 48);
                      monstr = date + 2;
                      timstr = date + 8;
                      gmtstr = date + 17;
                      ds.tm_hour = (int )((int const   )(*(timstr + 1)) - 48);
                      ds.tm_min = (int )(((int const   )(*(timstr + 3)) - 48) * 10 +
                                         ((int const   )(*(timstr + 4)) - 48));
                      ds.tm_sec = (int )(((int const   )(*(timstr + 6)) - 48) * 10 +
                                         ((int const   )(*(timstr + 7)) - 48));
                    } else {
                      tmp___1 = apr_date_checkmask(date, " # @$$ #### ##:##:## *");
                      if (tmp___1) {
                        ds.tm_year = (int )(((((int const   )(*(date + 7)) - 48) *
                                              10 + ((int const   )(*(date + 8)) -
                                                    48)) - 19) * 100);
                        if (ds.tm_year < 0) {
                          return (0LL);
                        }
                        ds.tm_year = ds.tm_year + (int )(((int const   )(*(date +
                                                                           9)) - 48) *
                                                         10 + ((int const   )(*(date +
                                                                                10)) -
                                                               48));
                        ds.tm_mday = (int )((int const   )(*(date + 1)) - 48);
                        monstr = date + 3;
                        timstr = date + 12;
                        gmtstr = date + 20;
                        ds.tm_hour = (int )(((int const   )(*(timstr + 0)) - 48) *
                                            10 + ((int const   )(*(timstr + 1)) -
                                                  48));
                        ds.tm_min = (int )(((int const   )(*(timstr + 3)) - 48) *
                                           10 + ((int const   )(*(timstr + 4)) - 48));
                        ds.tm_sec = (int )(((int const   )(*(timstr + 6)) - 48) *
                                           10 + ((int const   )(*(timstr + 7)) - 48));
                      } else {
                        return (0LL);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (ds.tm_mday <= 0) {
    goto _L___0;
  } else {
    if (ds.tm_mday > 31) {
      _L___0: 
      return (0LL);
    }
  }
  if (ds.tm_hour > 23) {
    goto _L___2;
  } else {
    if (ds.tm_min > 59) {
      _L___2: 
      goto _L___1;
    } else {
      if (ds.tm_sec > 61) {
        _L___1: 
        return (0LL);
      }
    }
  }
  mint = (int )((((int const   )(*(monstr + 0)) << 16) | ((int const   )(*(monstr +
                                                                           1)) <<
                                                          8)) | (int const   )(*(monstr +
                                                                                 2)));
  mon = 0;
  while (mon < 12) {
    if (mint == (int )months___0[mon]) {
      break;
    }
    mon ++;
  }
  if (mon == 12) {
    return (0LL);
  }
  if (ds.tm_mday == 31) {
    if (mon == 3) {
      goto _L___6;
    } else {
      if (mon == 5) {
        _L___6: 
        goto _L___5;
      } else {
        if (mon == 8) {
          _L___5: 
          goto _L___4;
        } else {
          if (mon == 10) {
            _L___4: 
            return (0LL);
          } else {
            goto _L___3;
          }
        }
      }
    }
  } else {
    _L___3: ;
  }
  if (mon == 1) {
    if (ds.tm_mday > 29) {
      goto _L___10;
    } else {
      if (ds.tm_mday == 29) {
        if (ds.tm_year & 3) {
          goto _L___10;
        } else {
          if (ds.tm_year % 100 == 0) {
            if (ds.tm_year % 400 != 100) {
              _L___10: 
              return (0LL);
            } else {
              goto _L___11;
            }
          } else {
            _L___11: 
            goto _L___9;
          }
        }
      } else {
        _L___9: 
        goto _L___7;
      }
    }
  } else {
    _L___7: ;
  }
  ds.tm_mon = mon;
  ds.tm_gmtoff = 0;
  if (gmtstr) {
    if ((int const   )(*gmtstr) != 0) {
      gmtstr ++;
      if ((int const   )(*gmtstr) != 0) {
        tmp___12 = gmtstr;
        gmtstr ++;
        switch ((int )(*tmp___12)) {
        case 45: 
        offset = atoi(gmtstr);
        ds.tm_gmtoff = ds.tm_gmtoff - ((offset / 100) * 60) * 60;
        ds.tm_gmtoff = ds.tm_gmtoff - (offset % 100) * 60;
        break;
        case 43: 
        offset = atoi(gmtstr);
        ds.tm_gmtoff = ds.tm_gmtoff + ((offset / 100) * 60) * 60;
        ds.tm_gmtoff = ds.tm_gmtoff + (offset % 100) * 60;
        break;
        }
      }
    } else {
      goto _L___12;
    }
  } else {
    _L___12: ;
  }
  ds.tm_usec = 0;
  tmp___13 = apr_time_exp_gmt_get(& result, & ds);
  if (tmp___13 != 0) {
    return (0LL);
  }
  return (result);
}
}
#pragma merger(0,"/tmp/cil-EKfTbhU7.i","-g -pthread")
static apr_rmm_off_t find_block_by_offset(apr_rmm_t *rmm , apr_rmm_off_t next , apr_rmm_off_t find ,
                                          int includes ) 
{ apr_rmm_off_t prev ;
  struct rmm_block_t *blk ;
  apr_rmm_off_t tmp ;
  apr_rmm_off_t tmp___0 ;

  {
  prev = 0U;
  while (next) {
    blk = (rmm_block_t *)((char *)rmm->base + next);
    if (find == next) {
      return (next);
    }
    if (find < next) {
      if (includes) {
        tmp = prev;
      } else {
        tmp = 0U;
      }
      return (tmp);
    }
    prev = next;
    next = blk->next;
  }
  if (includes) {
    tmp___0 = prev;
  } else {
    tmp___0 = 0U;
  }
  return (tmp___0);
}
}
static apr_rmm_off_t find_block_of_size(apr_rmm_t *rmm , apr_size_t size ) 
{ apr_rmm_off_t next ;
  apr_rmm_off_t best ;
  apr_rmm_off_t bestsize ;
  struct rmm_block_t *blk ;
  struct rmm_block_t *blk___0 ;
  struct rmm_block_t *new ;

  {
  next = (rmm->base)->firstfree;
  best = 0U;
  bestsize = 0U;
  while (next) {
    blk = (rmm_block_t *)((char *)rmm->base + next);
    if (blk->size == size) {
      return (next);
    }
    if (blk->size >= size) {
      if (! bestsize) {
        goto _L;
      } else {
        if (blk->size < bestsize) {
          _L: 
          bestsize = blk->size;
          best = next;
        }
      }
    }
    next = blk->next;
  }
  if (bestsize - size > sizeof(struct rmm_block_t *)) {
    blk___0 = (rmm_block_t *)((char *)rmm->base + best);
    new = (rmm_block_t *)(((char *)rmm->base + best) + size);
    new->size = blk___0->size - size;
    new->next = blk___0->next;
    new->prev = best;
    blk___0->size = size;
    blk___0->next = best + size;
    if (new->next) {
      blk___0 = (rmm_block_t *)((char *)rmm->base + blk___0->next);
      blk___0->prev = best + size;
    }
  }
  if (best) {
    return (best);
  }
  return (0U);
}
}
static void move_block(apr_rmm_t *rmm , apr_rmm_off_t this , int free___0 ) 
{ struct rmm_block_t *blk ;
  struct rmm_block_t *prev ;
  struct rmm_block_t *next ;
  struct rmm_block_t *prev___0 ;
  struct rmm_block_t *next___0 ;

  {
  blk = (rmm_block_t *)((char *)rmm->base + this);
  if (blk->prev) {
    prev = (rmm_block_t *)((char *)rmm->base + blk->prev);
    prev->next = blk->next;
  } else {
    if (free___0) {
      (rmm->base)->firstused = blk->next;
    } else {
      (rmm->base)->firstfree = blk->next;
    }
  }
  if (blk->next) {
    next = (rmm_block_t *)((char *)rmm->base + blk->next);
    next->prev = blk->prev;
  }
  if (free___0) {
    blk->prev = find_block_by_offset(rmm, (rmm->base)->firstfree, this, 1);
    if (! blk->prev) {
      blk->next = (rmm->base)->firstfree;
      (rmm->base)->firstfree = this;
    }
  } else {
    blk->prev = find_block_by_offset(rmm, (rmm->base)->firstused, this, 1);
    if (! blk->prev) {
      blk->next = (rmm->base)->firstused;
      (rmm->base)->firstused = this;
    }
  }
  if (blk->prev) {
    prev___0 = (rmm_block_t *)((char *)rmm->base + blk->prev);
    if (free___0) {
      if (blk->prev + prev___0->size == this) {
        prev___0->size += blk->size;
        this = blk->prev;
        blk = prev___0;
      } else {
        goto _L;
      }
    } else {
      _L: 
      blk->next = prev___0->next;
      prev___0->next = this;
    }
  }
  if (blk->next) {
    next___0 = (rmm_block_t *)((char *)rmm->base + blk->next);
    if (free___0) {
      if (this + blk->size == blk->next) {
        blk->size += next___0->size;
        blk->next = next___0->next;
        if (blk->next) {
          next___0 = (rmm_block_t *)((char *)rmm->base + blk->next);
          next___0->prev = this;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      next___0->prev = this;
    }
  }
  return;
}
}
apr_status_t apr_rmm_init(apr_rmm_t **rmm , apr_anylock_t *lock , void *base , apr_size_t size ,
                          apr_pool_t *p ) 
{ apr_status_t rv ;
  rmm_block_t *blk ;
  apr_anylock_t nulllock ;
  void *tmp___44 ;

  {
  if (! lock) {
    nulllock.type = (enum tm_lock )0;
    nulllock.lock.pm = (apr_proc_mutex_t *)((void *)0);
    lock = & nulllock;
  }
  if ((int )lock->type == 0) {
    rv = 0;
  } else {
    if ((int )lock->type == 2) {
      rv = apr_thread_mutex_lock(lock->lock.tm);
    } else {
      if ((int )lock->type == 1) {
        rv = apr_proc_mutex_lock(lock->lock.pm);
      } else {
        if ((int )lock->type == 3) {
          rv = apr_thread_rwlock_rdlock(lock->lock.rw);
        } else {
          if ((int )lock->type == 4) {
            rv = apr_thread_rwlock_wrlock(lock->lock.rw);
          } else {
            rv = 22;
          }
        }
      }
    }
  }
  if (rv != 0) {
    return (rv);
  }
  tmp___44 = apr_palloc(p, sizeof(apr_rmm_t ));
  (*rmm) = (apr_rmm_t *)memset(tmp___44, 0, sizeof(apr_rmm_t ));
  ((*rmm))->p = p;
  ((*rmm))->base = (rmm_hdr_block_t *)base;
  ((*rmm))->size = size;
  ((*rmm))->lock = (*lock);
  (((*rmm))->base)->abssize = size;
  (((*rmm))->base)->firstused = 0U;
  (((*rmm))->base)->firstfree = sizeof(rmm_hdr_block_t );
  blk = (rmm_block_t *)((char *)base + (((*rmm))->base)->firstfree);
  blk->size = size - (((*rmm))->base)->firstfree;
  blk->prev = 0U;
  blk->next = 0U;
  if (! ((int )lock->type == 0)) {
    if ((int )lock->type == 2) {
      apr_thread_mutex_unlock(lock->lock.tm);
    } else {
      if ((int )lock->type == 1) {
        apr_proc_mutex_unlock(lock->lock.pm);
      } else {
        if ((int )lock->type == 3) {
          goto _L;
        } else {
          if ((int )lock->type == 4) {
            _L: 
            apr_thread_rwlock_unlock(lock->lock.rw);
          }
        }
      }
    }
  }
  return (0);
}
}
apr_status_t apr_rmm_destroy(apr_rmm_t *rmm ) 
{ apr_status_t rv ;
  rmm_block_t *blk ;
  apr_rmm_off_t this ;
  apr_rmm_off_t this___0 ;

  {
  if ((int )rmm->lock.type == 0) {
    rv = 0;
  } else {
    if ((int )rmm->lock.type == 2) {
      rv = apr_thread_mutex_lock(rmm->lock.lock.tm);
    } else {
      if ((int )rmm->lock.type == 1) {
        rv = apr_proc_mutex_lock(rmm->lock.lock.pm);
      } else {
        if ((int )rmm->lock.type == 3) {
          rv = apr_thread_rwlock_rdlock(rmm->lock.lock.rw);
        } else {
          if ((int )rmm->lock.type == 4) {
            rv = apr_thread_rwlock_wrlock(rmm->lock.lock.rw);
          } else {
            rv = 22;
          }
        }
      }
    }
  }
  if (rv != 0) {
    return (rv);
  }
  if ((rmm->base)->firstused) {
    this = (rmm->base)->firstused;
    while (1) {
      blk = (rmm_block_t *)((char *)rmm->base + this);
      this = blk->next;
      blk->prev = 0U;
      blk->next = blk->prev;
      if (! this) {
        break;
      }
    }
    (rmm->base)->firstused = 0U;
  }
  if ((rmm->base)->firstfree) {
    this___0 = (rmm->base)->firstfree;
    while (1) {
      blk = (rmm_block_t *)((char *)rmm->base + this___0);
      this___0 = blk->next;
      blk->prev = 0U;
      blk->next = blk->prev;
      if (! this___0) {
        break;
      }
    }
    (rmm->base)->firstfree = 0U;
  }
  (rmm->base)->abssize = 0U;
  rmm->size = 0U;
  if (! ((int )rmm->lock.type == 0)) {
    if ((int )rmm->lock.type == 2) {
      apr_thread_mutex_unlock(rmm->lock.lock.tm);
    } else {
      if ((int )rmm->lock.type == 1) {
        apr_proc_mutex_unlock(rmm->lock.lock.pm);
      } else {
        if ((int )rmm->lock.type == 3) {
          goto _L;
        } else {
          if ((int )rmm->lock.type == 4) {
            _L: 
            apr_thread_rwlock_unlock(rmm->lock.lock.rw);
          }
        }
      }
    }
  }
  return (0);
}
}
apr_status_t apr_rmm_attach(apr_rmm_t **rmm , apr_anylock_t *lock , void *base , apr_pool_t *p ) 
{ apr_anylock_t nulllock ;
  void *tmp ;

  {
  if (! lock) {
    nulllock.type = (enum tm_lock )0;
    nulllock.lock.pm = (apr_proc_mutex_t *)((void *)0);
    lock = & nulllock;
  }
  tmp = apr_palloc(p, sizeof(apr_rmm_t ));
  (*rmm) = (apr_rmm_t *)memset(tmp, 0, sizeof(apr_rmm_t ));
  ((*rmm))->p = p;
  ((*rmm))->base = (rmm_hdr_block_t *)base;
  ((*rmm))->size = (((*rmm))->base)->abssize;
  ((*rmm))->lock = (*lock);
  return (0);
}
}
apr_status_t apr_rmm_detach(apr_rmm_t *rmm ) 
{ 

  {
  return (0);
}
}
static unsigned int const   grain  =    (unsigned int const   )sizeof(union grainbit );
apr_rmm_off_t apr_rmm_malloc(apr_rmm_t *rmm , apr_size_t reqsize ) 
{ apr_rmm_off_t this ;

  {
  reqsize = (1U + (reqsize - 1U) / (unsigned int )grain) * (unsigned int )grain;
  if (! ((int )rmm->lock.type == 0)) {
    if ((int )rmm->lock.type == 2) {
      apr_thread_mutex_lock(rmm->lock.lock.tm);
    } else {
      if ((int )rmm->lock.type == 1) {
        apr_proc_mutex_lock(rmm->lock.lock.pm);
      } else {
        if ((int )rmm->lock.type == 3) {
          apr_thread_rwlock_rdlock(rmm->lock.lock.rw);
        } else {
          if ((int )rmm->lock.type == 4) {
            apr_thread_rwlock_wrlock(rmm->lock.lock.rw);
          }
        }
      }
    }
  }
  this = find_block_of_size(rmm, reqsize + sizeof(rmm_block_t ));
  if (this) {
    move_block(rmm, this, 0);
    this += sizeof(rmm_block_t );
  }
  if (! ((int )rmm->lock.type == 0)) {
    if ((int )rmm->lock.type == 2) {
      apr_thread_mutex_unlock(rmm->lock.lock.tm);
    } else {
      if ((int )rmm->lock.type == 1) {
        apr_proc_mutex_unlock(rmm->lock.lock.pm);
      } else {
        if ((int )rmm->lock.type == 3) {
          goto _L;
        } else {
          if ((int )rmm->lock.type == 4) {
            _L: 
            apr_thread_rwlock_unlock(rmm->lock.lock.rw);
          }
        }
      }
    }
  }
  return (this);
}
}
apr_rmm_off_t apr_rmm_calloc(apr_rmm_t *rmm , apr_size_t reqsize ) 
{ apr_rmm_off_t this ;

  {
  reqsize = (1U + (reqsize - 1U) / (unsigned int )grain) * (unsigned int )grain;
  if (! ((int )rmm->lock.type == 0)) {
    if ((int )rmm->lock.type == 2) {
      apr_thread_mutex_lock(rmm->lock.lock.tm);
    } else {
      if ((int )rmm->lock.type == 1) {
        apr_proc_mutex_lock(rmm->lock.lock.pm);
      } else {
        if ((int )rmm->lock.type == 3) {
          apr_thread_rwlock_rdlock(rmm->lock.lock.rw);
        } else {
          if ((int )rmm->lock.type == 4) {
            apr_thread_rwlock_wrlock(rmm->lock.lock.rw);
          }
        }
      }
    }
  }
  this = find_block_of_size(rmm, reqsize + sizeof(rmm_block_t ));
  if (this) {
    move_block(rmm, this, 0);
    this += sizeof(rmm_block_t );
    memset((void *)((char *)rmm->base + this), 0, reqsize);
  }
  if (! ((int )rmm->lock.type == 0)) {
    if ((int )rmm->lock.type == 2) {
      apr_thread_mutex_unlock(rmm->lock.lock.tm);
    } else {
      if ((int )rmm->lock.type == 1) {
        apr_proc_mutex_unlock(rmm->lock.lock.pm);
      } else {
        if ((int )rmm->lock.type == 3) {
          goto _L;
        } else {
          if ((int )rmm->lock.type == 4) {
            _L: 
            apr_thread_rwlock_unlock(rmm->lock.lock.rw);
          }
        }
      }
    }
  }
  return (this);
}
}
apr_rmm_off_t apr_rmm_realloc(apr_rmm_t *rmm , void *entity , apr_size_t reqsize ) 
{ apr_rmm_off_t this ;
  apr_rmm_off_t old ;
  apr_rmm_off_t tmp ;
  void const   * __restrict  tmp___0 ;
  void * __restrict  tmp___1 ;

  {
  if (! entity) {
    tmp = apr_rmm_malloc(rmm, reqsize);
    return (tmp);
  }
  reqsize = (1U + (reqsize - 1U) / (unsigned int )grain) * (unsigned int )grain;
  old = apr_rmm_offset_get(rmm, entity);
  this = apr_rmm_malloc(rmm, reqsize);
  if (this == 0U) {
    return (this);
  }
  tmp___0 = apr_rmm_addr_get(rmm, old);
  tmp___1 = apr_rmm_addr_get(rmm, this);
  memcpy(tmp___1, tmp___0, reqsize);
  apr_rmm_free(rmm, old);
  return (this);
}
}
apr_status_t apr_rmm_free(apr_rmm_t *rmm , apr_rmm_off_t this ) 
{ apr_status_t rv ;
  struct rmm_block_t *blk ;
  struct rmm_block_t *prev ;
  struct rmm_block_t *next ;

  {
  if (this < sizeof(rmm_hdr_block_t ) + sizeof(rmm_block_t )) {
    return (22);
  }
  this -= sizeof(rmm_block_t );
  blk = (rmm_block_t *)((char *)rmm->base + this);
  if ((int )rmm->lock.type == 0) {
    rv = 0;
  } else {
    if ((int )rmm->lock.type == 2) {
      rv = apr_thread_mutex_lock(rmm->lock.lock.tm);
    } else {
      if ((int )rmm->lock.type == 1) {
        rv = apr_proc_mutex_lock(rmm->lock.lock.pm);
      } else {
        if ((int )rmm->lock.type == 3) {
          rv = apr_thread_rwlock_rdlock(rmm->lock.lock.rw);
        } else {
          if ((int )rmm->lock.type == 4) {
            rv = apr_thread_rwlock_wrlock(rmm->lock.lock.rw);
          } else {
            rv = 22;
          }
        }
      }
    }
  }
  if (rv != 0) {
    return (rv);
  }
  if (blk->prev) {
    prev = (rmm_block_t *)((char *)rmm->base + blk->prev);
    if (prev->next != this) {
      if (! ((int )rmm->lock.type == 0)) {
        if ((int )rmm->lock.type == 2) {
          apr_thread_mutex_unlock(rmm->lock.lock.tm);
        } else {
          if ((int )rmm->lock.type == 1) {
            apr_proc_mutex_unlock(rmm->lock.lock.pm);
          } else {
            if ((int )rmm->lock.type == 3) {
              goto _L;
            } else {
              if ((int )rmm->lock.type == 4) {
                _L: 
                apr_thread_rwlock_unlock(rmm->lock.lock.rw);
              }
            }
          }
        }
      }
      return (22);
    }
  } else {
    if ((rmm->base)->firstused != this) {
      if (! ((int )rmm->lock.type == 0)) {
        if ((int )rmm->lock.type == 2) {
          apr_thread_mutex_unlock(rmm->lock.lock.tm);
        } else {
          if ((int )rmm->lock.type == 1) {
            apr_proc_mutex_unlock(rmm->lock.lock.pm);
          } else {
            if ((int )rmm->lock.type == 3) {
              goto _L___0;
            } else {
              if ((int )rmm->lock.type == 4) {
                _L___0: 
                apr_thread_rwlock_unlock(rmm->lock.lock.rw);
              }
            }
          }
        }
      }
      return (22);
    }
  }
  if (blk->next) {
    next = (rmm_block_t *)((char *)rmm->base + blk->next);
    if (next->prev != this) {
      if (! ((int )rmm->lock.type == 0)) {
        if ((int )rmm->lock.type == 2) {
          apr_thread_mutex_unlock(rmm->lock.lock.tm);
        } else {
          if ((int )rmm->lock.type == 1) {
            apr_proc_mutex_unlock(rmm->lock.lock.pm);
          } else {
            if ((int )rmm->lock.type == 3) {
              goto _L___1;
            } else {
              if ((int )rmm->lock.type == 4) {
                _L___1: 
                apr_thread_rwlock_unlock(rmm->lock.lock.rw);
              }
            }
          }
        }
      }
      return (22);
    }
  }
  move_block(rmm, this, 1);
  if (! ((int )rmm->lock.type == 0)) {
    if ((int )rmm->lock.type == 2) {
      apr_thread_mutex_unlock(rmm->lock.lock.tm);
    } else {
      if ((int )rmm->lock.type == 1) {
        apr_proc_mutex_unlock(rmm->lock.lock.pm);
      } else {
        if ((int )rmm->lock.type == 3) {
          goto _L___2;
        } else {
          if ((int )rmm->lock.type == 4) {
            _L___2: 
            apr_thread_rwlock_unlock(rmm->lock.lock.rw);
          }
        }
      }
    }
  }
  return (0);
}
}
void *apr_rmm_addr_get(apr_rmm_t *rmm , apr_rmm_off_t entity ) 
{ 

  {
  return ((void *)((char *)rmm->base + entity));
}
}
apr_rmm_off_t apr_rmm_offset_get(apr_rmm_t *rmm , void *entity ) 
{ 

  {
  return ((unsigned int )((char *)entity - (char *)rmm->base));
}
}
apr_size_t apr_rmm_overhead_get(int n ) 
{ 

  {
  return (sizeof(rmm_hdr_block_t ) + (unsigned int )n * sizeof(rmm_block_t ));
}
}
#pragma merger(0,"/tmp/cil-BRaNc2hX.i","-g -pthread")
static apr_res_t *pop_resource(apr_reslist_t *reslist ) 
{ apr_res_t *res ;

  {
  res = reslist->avail_list.next;
  while (1) {
    (res->link.prev)->link.next = res->link.next;
    (res->link.next)->link.prev = res->link.prev;
    break;
  }
  reslist->nidle --;
  return (res);
}
}
static void push_resource(apr_reslist_t *reslist , apr_res_t *resource ) 
{ 

  {
  while (1) {
    resource->link.next = (struct apr_res_t *)((char *)(& reslist->avail_list) - (long )((char *)(& ((struct apr_res_t *)((void *)0))->link) -
                                                                                         (char *)((void *)0)));
    resource->link.prev = ((struct apr_res_t *)((char *)(& reslist->avail_list) -
                                                (long )((char *)(& ((struct apr_res_t *)((void *)0))->link) -
                                                        (char *)((void *)0))))->link.prev;
    (((struct apr_res_t *)((char *)(& reslist->avail_list) - (long )((char *)(& ((struct apr_res_t *)((void *)0))->link) -
                                                                     (char *)((void *)0))))->link.prev)->link.next = resource;
    ((struct apr_res_t *)((char *)(& reslist->avail_list) - (long )((char *)(& ((struct apr_res_t *)((void *)0))->link) -
                                                                    (char *)((void *)0))))->link.prev = resource;
    break;
  }
  resource->freed = apr_time_now();
  reslist->nidle ++;
  return;
}
}
static apr_res_t *get_container(apr_reslist_t *reslist ) 
{ apr_res_t *res ;

  {
  if (! (! ((unsigned int )reslist->free_list.next == (unsigned int )((struct apr_res_t *)((char *)(& reslist->free_list) -
                                                                                           (long )((char *)(& ((struct apr_res_t *)((void *)0))->link) -
                                                                                                   (char *)((void *)0))))))) {
    __assert_fail("!(((&reslist->free_list))->next == (struct apr_res_t *)((char *)((&reslist->free_list)) - ((long) (((char *) (&(((struct apr_res_t*)((void *)0))->link))) - ((char *) ((void *)0))))))",
                  "apr_reslist.c", 132U, "get_container");
  }
  res = reslist->free_list.next;
  while (1) {
    (res->link.prev)->link.next = res->link.next;
    (res->link.next)->link.prev = res->link.prev;
    break;
  }
  return (res);
}
}
static void free_container(apr_reslist_t *reslist , apr_res_t *container ) 
{ 

  {
  while (1) {
    container->link.next = (struct apr_res_t *)((char *)(& reslist->free_list) - (long )((char *)(& ((struct apr_res_t *)((void *)0))->link) -
                                                                                         (char *)((void *)0)));
    container->link.prev = ((struct apr_res_t *)((char *)(& reslist->free_list) -
                                                 (long )((char *)(& ((struct apr_res_t *)((void *)0))->link) -
                                                         (char *)((void *)0))))->link.prev;
    (((struct apr_res_t *)((char *)(& reslist->free_list) - (long )((char *)(& ((struct apr_res_t *)((void *)0))->link) -
                                                                    (char *)((void *)0))))->link.prev)->link.next = container;
    ((struct apr_res_t *)((char *)(& reslist->free_list) - (long )((char *)(& ((struct apr_res_t *)((void *)0))->link) -
                                                                   (char *)((void *)0))))->link.prev = container;
    break;
  }
  return;
}
}
static apr_status_t create_resource(apr_reslist_t *reslist , apr_res_t **ret_res ) 
{ apr_status_t rv ;
  apr_res_t *res ;
  void *tmp ;

  {
  tmp = apr_palloc(reslist->pool, sizeof((*res)));
  res = (apr_res_t *)memset(tmp, 0, sizeof((*res)));
  rv = ((*(reslist->constructor)))(& res->opaque, reslist->params, reslist->pool);
  if (rv != 0) {
    return (rv);
  }
  (*ret_res) = res;
  return (0);
}
}
static apr_status_t destroy_resource(apr_reslist_t *reslist , apr_res_t *res ) 
{ apr_status_t rv ;

  {
  rv = ((*(reslist->destructor)))(res->opaque, reslist->params, reslist->pool);
  if (rv != 0) {
    return (rv);
  }
  return (0);
}
}
static apr_status_t reslist_cleanup(void *data_ ) 
{ apr_status_t rv ;
  apr_reslist_t *rl ;
  apr_res_t *res ;

  {
  rl = (apr_reslist_t *)data_;
  apr_thread_mutex_lock(rl->listlock);
  while (rl->nidle > 0) {
    res = pop_resource(rl);
    rl->ntotal --;
    rv = destroy_resource(rl, res);
    if (rv != 0) {
      return (rv);
    }
    free_container(rl, res);
  }
  if (! (rl->nidle == 0)) {
    __assert_fail("rl->nidle == 0", "apr_reslist.c", 202U, "reslist_cleanup");
  }
  if (! (rl->ntotal == 0)) {
    __assert_fail("rl->ntotal == 0", "apr_reslist.c", 203U, "reslist_cleanup");
  }
  apr_thread_mutex_destroy(rl->listlock);
  apr_thread_cond_destroy(rl->avail);
  return (0);
}
}
static apr_status_t reslist_maint(apr_reslist_t *reslist ) 
{ apr_time_t now ;
  apr_status_t rv ;
  apr_res_t *res ;
  int created_one ;

  {
  created_one = 0;
  apr_thread_mutex_lock(reslist->listlock);
  while (1) {
    if (reslist->nidle < reslist->min) {
      if (! (reslist->ntotal <= reslist->hmax)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
    rv = create_resource(reslist, & res);
    if (rv != 0) {
      apr_thread_mutex_unlock(reslist->listlock);
      return (rv);
    }
    push_resource(reslist, res);
    reslist->ntotal ++;
    rv = apr_thread_cond_signal(reslist->avail);
    if (rv != 0) {
      apr_thread_mutex_unlock(reslist->listlock);
      return (rv);
    }
    created_one ++;
  }
  if (created_one) {
    apr_thread_mutex_unlock(reslist->listlock);
    return (0);
  }
  now = apr_time_now();
  while (1) {
    if (reslist->nidle > reslist->smax) {
      if (! (reslist->nidle > 0)) {
        goto _L___0;
      }
    } else {
      _L___0: 
      break;
    }
    res = reslist->avail_list.next;
    if (now - res->freed < reslist->ttl) {
      break;
    }
    res = pop_resource(reslist);
    reslist->ntotal --;
    rv = destroy_resource(reslist, res);
    if (rv != 0) {
      apr_thread_mutex_unlock(reslist->listlock);
      return (rv);
    }
    free_container(reslist, res);
  }
  apr_thread_mutex_unlock(reslist->listlock);
  return (0);
}
}
apr_status_t apr_reslist_create(apr_reslist_t **reslist , int min , int smax , int hmax ,
                                apr_interval_time_t ttl , apr_status_t (*con)(void **resource ,
                                                                              void *params ,
                                                                              apr_pool_t *pool ) ,
                                apr_status_t (*de)(void *resource , void *params ,
                                                   apr_pool_t *pool ) , void *params ,
                                apr_pool_t *pool ) 
{ apr_status_t rv ;
  apr_reslist_t *rl ;
  void *tmp ;

  {
  if (min >= smax) {
    goto _L___1;
  } else {
    if (min >= hmax) {
      _L___1: 
      goto _L___0;
    } else {
      if (smax > hmax) {
        _L___0: 
        goto _L;
      } else {
        if (ttl < 0LL) {
          _L: 
          return (22);
        }
      }
    }
  }
  tmp = apr_palloc(pool, sizeof((*rl)));
  rl = (apr_reslist_t *)memset(tmp, 0, sizeof((*rl)));
  rl->pool = pool;
  rl->min = min;
  rl->smax = smax;
  rl->hmax = hmax;
  rl->ttl = ttl;
  rl->constructor = con;
  rl->destructor = de;
  rl->params = params;
  while (1) {
    rl->avail_list.next = (struct apr_res_t *)((char *)(& rl->avail_list) - (long )((char *)(& ((struct apr_res_t *)((void *)0))->link) -
                                                                                    (char *)((void *)0)));
    rl->avail_list.prev = (struct apr_res_t *)((char *)(& rl->avail_list) - (long )((char *)(& ((struct apr_res_t *)((void *)0))->link) -
                                                                                    (char *)((void *)0)));
    break;
  }
  while (1) {
    rl->free_list.next = (struct apr_res_t *)((char *)(& rl->free_list) - (long )((char *)(& ((struct apr_res_t *)((void *)0))->link) -
                                                                                  (char *)((void *)0)));
    rl->free_list.prev = (struct apr_res_t *)((char *)(& rl->free_list) - (long )((char *)(& ((struct apr_res_t *)((void *)0))->link) -
                                                                                  (char *)((void *)0)));
    break;
  }
  rv = apr_thread_mutex_create(& rl->listlock, 0U, pool);
  if (rv != 0) {
    return (rv);
  }
  rv = apr_thread_cond_create(& rl->avail, pool);
  if (rv != 0) {
    return (rv);
  }
  rv = reslist_maint(rl);
  if (rv != 0) {
    return (rv);
  }
  apr_pool_cleanup_register(rl->pool, (void const   *)rl, & reslist_cleanup, & apr_pool_cleanup_null);
  (*reslist) = rl;
  return (0);
}
}
apr_status_t apr_reslist_destroy(apr_reslist_t *reslist ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_cleanup_run(reslist->pool, (void *)reslist, & reslist_cleanup);
  return (tmp);
}
}
apr_status_t apr_reslist_acquire(apr_reslist_t *reslist , void **resource ) 
{ apr_status_t rv ;
  apr_res_t *res ;

  {
  apr_thread_mutex_lock(reslist->listlock);
  if (reslist->nidle > 0) {
    res = pop_resource(reslist);
    (*resource) = res->opaque;
    free_container(reslist, res);
    apr_thread_mutex_unlock(reslist->listlock);
    return (0);
  } else {
    while (1) {
      if (reslist->ntotal >= reslist->hmax) {
        if (! (reslist->nidle <= 0)) {
          goto _L;
        }
      } else {
        _L: 
        break;
      }
      apr_thread_cond_wait(reslist->avail, reslist->listlock);
    }
  }
  if (reslist->nidle > 0) {
    res = pop_resource(reslist);
    (*resource) = res->opaque;
    free_container(reslist, res);
    apr_thread_mutex_unlock(reslist->listlock);
    return (0);
  } else {
    rv = create_resource(reslist, & res);
    reslist->ntotal ++;
    (*resource) = res->opaque;
    free_container(reslist, res);
    apr_thread_mutex_unlock(reslist->listlock);
    return (0);
  }
}
}
apr_status_t apr_reslist_release(apr_reslist_t *reslist , void *resource ) 
{ apr_res_t *res ;
  apr_status_t tmp ;

  {
  apr_thread_mutex_lock(reslist->listlock);
  res = get_container(reslist);
  res->opaque = resource;
  push_resource(reslist, res);
  apr_thread_cond_signal(reslist->avail);
  apr_thread_mutex_unlock(reslist->listlock);
  tmp = reslist_maint(reslist);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-PYhW1U3q.i","-g -pthread")
static apr_status_t queue_destroy(void *data ) 
{ apr_queue_t *queue ;

  {
  queue = (apr_queue_t *)data;
  apr_thread_cond_destroy(queue->not_empty);
  apr_thread_cond_destroy(queue->not_full);
  apr_thread_mutex_destroy(queue->one_big_mutex);
  return (0);
}
}
apr_status_t apr_queue_create(apr_queue_t **q , unsigned int queue_capacity , apr_pool_t *a ) 
{ apr_status_t rv ;
  apr_queue_t *queue ;
  void *tmp ;

  {
  queue = (apr_queue_t *)apr_palloc(a, sizeof(apr_queue_t ));
  (*q) = queue;
  rv = apr_thread_mutex_create(& queue->one_big_mutex, 2U, a);
  if (rv != 0) {
    return (rv);
  }
  rv = apr_thread_cond_create(& queue->not_empty, a);
  if (rv != 0) {
    return (rv);
  }
  rv = apr_thread_cond_create(& queue->not_full, a);
  if (rv != 0) {
    return (rv);
  }
  tmp = apr_palloc(a, queue_capacity * sizeof(void *));
  queue->data = (void **)memset(tmp, 0, queue_capacity * sizeof(void *));
  queue->bounds = queue_capacity;
  queue->nelts = 0U;
  queue->in = 0U;
  queue->out = 0U;
  queue->terminated = 0;
  apr_pool_cleanup_register(a, (void const   *)queue, & queue_destroy, & apr_pool_cleanup_null);
  return (0);
}
}
apr_status_t apr_queue_push(apr_queue_t *queue , void *data ) 
{ apr_status_t rv ;
  int need_signal ;

  {
  need_signal = 0;
  if (queue->terminated) {
    return (70014);
  }
  rv = apr_thread_mutex_lock(queue->one_big_mutex);
  if (rv != 0) {
    return (rv);
  }
  if (queue->nelts == queue->bounds) {
    if (! queue->terminated) {
      rv = apr_thread_cond_wait(queue->not_full, queue->one_big_mutex);
      if (rv != 0) {
        apr_thread_mutex_unlock(queue->one_big_mutex);
        return (rv);
      }
    }
    if (queue->nelts == queue->bounds) {
      rv = apr_thread_mutex_unlock(queue->one_big_mutex);
      if (rv != 0) {
        return (rv);
      }
      if (queue->terminated) {
        return (70014);
      } else {
        return (4);
      }
    }
  }
  if (queue->nelts == 0U) {
    need_signal = 1;
  }
  (*(queue->data + queue->in)) = data;
  queue->in = (queue->in + 1U) % queue->bounds;
  queue->nelts ++;
  if (need_signal == 1) {
    rv = apr_thread_cond_signal(queue->not_empty);
    if (rv != 0) {
      apr_thread_mutex_unlock(queue->one_big_mutex);
      return (rv);
    }
  }
  rv = apr_thread_mutex_unlock(queue->one_big_mutex);
  return (rv);
}
}
apr_status_t apr_queue_trypush(apr_queue_t *queue , void *data ) 
{ apr_status_t rv ;
  int need_signal ;

  {
  need_signal = 0;
  if (queue->terminated) {
    return (70014);
  }
  rv = apr_thread_mutex_lock(queue->one_big_mutex);
  if (rv != 0) {
    return (rv);
  }
  if (queue->nelts == queue->bounds) {
    rv = apr_thread_mutex_unlock(queue->one_big_mutex);
    return (11);
  }
  if (queue->nelts == 0U) {
    need_signal = 1;
  }
  (*(queue->data + queue->in)) = data;
  queue->in = (queue->in + 1U) % queue->bounds;
  queue->nelts ++;
  if (need_signal == 1) {
    rv = apr_thread_cond_signal(queue->not_empty);
    if (rv != 0) {
      apr_thread_mutex_unlock(queue->one_big_mutex);
      return (rv);
    }
  }
  rv = apr_thread_mutex_unlock(queue->one_big_mutex);
  return (rv);
}
}
unsigned int apr_queue_size(apr_queue_t *queue ) 
{ 

  {
  return (queue->nelts);
}
}
apr_status_t apr_queue_pop(apr_queue_t *queue , void **data ) 
{ apr_status_t rv ;
  int need_signal ;

  {
  need_signal = 0;
  if (queue->terminated) {
    return (70014);
  }
  rv = apr_thread_mutex_lock(queue->one_big_mutex);
  if (rv != 0) {
    return (rv);
  }
  if (queue->nelts == 0U) {
    if (! queue->terminated) {
      rv = apr_thread_cond_wait(queue->not_empty, queue->one_big_mutex);
      if (rv != 0) {
        apr_thread_mutex_unlock(queue->one_big_mutex);
        return (rv);
      }
    }
    if (queue->nelts == 0U) {
      rv = apr_thread_mutex_unlock(queue->one_big_mutex);
      if (rv != 0) {
        return (rv);
      }
      if (queue->terminated) {
        return (70014);
      } else {
        return (4);
      }
    }
  }
  if (queue->nelts == queue->bounds) {
    need_signal = 1;
  }
  (*data) = (void *)(queue->data + queue->out);
  queue->nelts --;
  queue->out = (queue->out + 1U) % queue->bounds;
  if (need_signal == 1) {
    rv = apr_thread_cond_signal(queue->not_full);
    if (rv != 0) {
      apr_thread_mutex_unlock(queue->one_big_mutex);
      return (rv);
    }
  }
  rv = apr_thread_mutex_unlock(queue->one_big_mutex);
  return (rv);
}
}
apr_status_t apr_queue_trypop(apr_queue_t *queue , void **data ) 
{ apr_status_t rv ;
  int need_signal ;

  {
  need_signal = 0;
  if (queue->terminated) {
    return (70014);
  }
  rv = apr_thread_mutex_lock(queue->one_big_mutex);
  if (rv != 0) {
    return (rv);
  }
  if (queue->nelts == 0U) {
    rv = apr_thread_mutex_unlock(queue->one_big_mutex);
    return (11);
  }
  if (queue->nelts == queue->bounds) {
    need_signal = 1;
  }
  (*data) = (void *)(queue->data + queue->out);
  queue->nelts --;
  queue->out = (queue->out + 1U) % queue->bounds;
  if (need_signal == 1) {
    rv = apr_thread_cond_signal(queue->not_full);
    if (rv != 0) {
      apr_thread_mutex_unlock(queue->one_big_mutex);
      return (rv);
    }
  }
  rv = apr_thread_mutex_unlock(queue->one_big_mutex);
  return (rv);
}
}
apr_status_t apr_queue_interrupt_all(apr_queue_t *queue ) 
{ apr_status_t rv ;

  {
  rv = apr_thread_mutex_lock(queue->one_big_mutex);
  if (rv != 0) {
    return (rv);
  }
  apr_thread_cond_broadcast(queue->not_empty);
  apr_thread_cond_broadcast(queue->not_full);
  rv = apr_thread_mutex_unlock(queue->one_big_mutex);
  if (rv != 0) {
    return (rv);
  }
  return (0);
}
}
apr_status_t apr_queue_term(apr_queue_t *queue ) 
{ apr_status_t rv ;
  apr_status_t tmp ;

  {
  rv = apr_thread_mutex_lock(queue->one_big_mutex);
  if (rv != 0) {
    return (rv);
  }
  queue->terminated = 1;
  rv = apr_thread_mutex_unlock(queue->one_big_mutex);
  if (rv != 0) {
    return (rv);
  }
  tmp = apr_queue_interrupt_all(queue);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-esayxPfB.i","-g -pthread")
void apu_version(apr_version_t *pvsn ) 
{ 

  {
  pvsn->major = 0;
  pvsn->minor = 9;
  pvsn->patch = 2;
  pvsn->is_dev = 1;
  return;
}
}
char const   *apu_version_string(void) 
{ 

  {
  return ("0.9.2-dev");
}
}
#pragma merger(0,"/tmp/cil-c5eL6Ar0.i","-g -pthread")
static char const   *match_no_op(apr_strmatch_pattern const   *this_pattern , char const   *s ,
                                 apr_size_t slen ) 
{ 

  {
  return (s);
}
}
static char const   *match_boyer_moore_horspool(apr_strmatch_pattern const   *this_pattern ,
                                                char const   *s , apr_size_t slen ) 
{ char const   *s_end ;
  int *shift ;
  char const   *s_next ;
  char const   *p_start ;
  char const   *p_end ;
  char const   *s_tmp ;
  char const   *p_tmp ;

  {
  s_end = s + slen;
  shift = (int *)this_pattern->context;
  s_next = (s + this_pattern->length) - 1;
  p_start = this_pattern->pattern;
  p_end = (p_start + this_pattern->length) - 1;
  while ((unsigned int )s_next < (unsigned int )s_end) {
    s_tmp = s_next;
    p_tmp = p_end;
    while ((int const   )(*s_tmp) == (int const   )(*p_tmp)) {
      p_tmp --;
      if ((unsigned int )p_tmp < (unsigned int )p_start) {
        return (s_tmp);
      }
      s_tmp --;
    }
    s_next += (*(shift + (int )(*((unsigned char const   *)s_next))));
  }
  return ((char const   *)((void *)0));
}
}
static char const   *match_boyer_moore_horspool_nocase(apr_strmatch_pattern const   *this_pattern ,
                                                       char const   *s , apr_size_t slen ) 
{ char const   *s_end ;
  int *shift ;
  char const   *s_next ;
  char const   *p_start ;
  char const   *p_end ;
  char const   *s_tmp ;
  char const   *p_tmp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  s_end = s + slen;
  shift = (int *)this_pattern->context;
  s_next = (s + this_pattern->length) - 1;
  p_start = this_pattern->pattern;
  p_end = (p_start + this_pattern->length) - 1;
  while ((unsigned int )s_next < (unsigned int )s_end) {
    s_tmp = s_next;
    p_tmp = p_end;
    while (1) {
      tmp = tolower((int )((unsigned char )(*s_tmp)));
      tmp___0 = tolower((int )((unsigned char )(*p_tmp)));
      if (! (tmp == tmp___0)) {
        break;
      }
      p_tmp --;
      if ((unsigned int )p_tmp < (unsigned int )p_start) {
        return (s_tmp);
      }
      s_tmp --;
    }
    tmp___1 = tolower((int )((unsigned char )(*s_next)));
    s_next += (*(shift + tmp___1));
  }
  return ((char const   *)((void *)0));
}
}
apr_strmatch_pattern const   *apr_strmatch_precompile(apr_pool_t *p , char const   *s ,
                                                      int case_sensitive ) 
{ apr_strmatch_pattern *pattern ;
  apr_size_t i ;
  int *shift ;
  int tmp___0 ;

  {
  pattern = (apr_strmatch_pattern *)apr_palloc(p, sizeof((*pattern)));
  pattern->pattern = s;
  pattern->length = strlen(s);
  if (pattern->length == 0U) {
    pattern->compare = & match_no_op;
    pattern->context = (void *)0;
    return ((apr_strmatch_pattern const   *)pattern);
  }
  shift = (int *)apr_palloc(p, sizeof(int ) * 256U);
  i = 0U;
  while (i < 256U) {
    (*(shift + i)) = (int )pattern->length;
    i ++;
  }
  if (case_sensitive) {
    pattern->compare = & match_boyer_moore_horspool;
    i = 0U;
    while (i < pattern->length - 1U) {
      (*(shift + (int )(*(s + i)))) = (int )((pattern->length - i) - 1U);
      i ++;
    }
  } else {
    pattern->compare = & match_boyer_moore_horspool_nocase;
    i = 0U;
    while (i < pattern->length - 1U) {
      tmp___0 = tolower((int )((unsigned char )(*(s + i))));
      (*(shift + tmp___0)) = (int )((pattern->length - i) - 1U);
      i ++;
    }
  }
  pattern->context = (void *)shift;
  return ((apr_strmatch_pattern const   *)pattern);
}
}
#pragma merger(0,"/tmp/cil-2yYyPBHI.i","-g -pthread")
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
extern int iconv_close(iconv_t __cd ) ;
static char const   *handle_special_names(char const   *page , apr_pool_t *pool ) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
  if ((unsigned int )page == (unsigned int )((char const   *)0)) {
    tmp = apr_os_default_encoding(pool);
    return (tmp);
  } else {
    if ((unsigned int )page == (unsigned int )((char const   *)1)) {
      tmp___0 = apr_os_locale_encoding(pool);
      return (tmp___0);
    } else {
      return (page);
    }
  }
}
}
static apr_status_t apr_xlate_cleanup(void *convset ) 
{ apr_xlate_t *old ;
  int rv ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  old = (apr_xlate_t *)convset;
  if ((unsigned int )old->ich != (unsigned int )((void *)-1)) {
    tmp___1 = iconv_close(old->ich);
    if (tmp___1) {
      tmp = __errno_location();
      rv = (*tmp);
      if (rv) {
        tmp___0 = rv;
      } else {
        tmp___0 = 22;
      }
      return (tmp___0);
    }
  }
  return (0);
}
}
static void check_sbcs(apr_xlate_t *convset ) 
{ char inbuf[256] ;
  char outbuf[256] ;
  char *inbufptr ;
  char *outbufptr ;
  apr_size_t inbytes_left ;
  apr_size_t outbytes_left ;
  int i ;
  apr_size_t translated ;

  {
  inbufptr = inbuf;
  outbufptr = outbuf;
  i = 0;
  while ((unsigned int )i < sizeof(inbuf)) {
    inbuf[i] = (char )i;
    i ++;
  }
  outbytes_left = sizeof(inbuf);
  inbytes_left = outbytes_left;
  translated = iconv(convset->ich, (char ** __restrict  )(& inbufptr), (size_t * __restrict  )(& inbytes_left),
                     (char ** __restrict  )(& outbufptr), (size_t * __restrict  )(& outbytes_left));
  if (translated != 4294967295U) {
    if (inbytes_left == 0U) {
      if (outbytes_left == 0U) {
        convset->sbcs_table = (char *)apr_palloc(convset->pool, sizeof(outbuf));
        memcpy((void * __restrict  )convset->sbcs_table, (void const   * __restrict  )(outbuf),
               sizeof(outbuf));
        iconv_close(convset->ich);
        convset->ich = (void *)-1;
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
  }
  return;
}
}
static void make_identity_table(apr_xlate_t *convset ) 
{ int i ;

  {
  convset->sbcs_table = (char *)apr_palloc(convset->pool, 256U);
  i = 0;
  while (i < 256) {
    (*(convset->sbcs_table + i)) = (char )i;
    i ++;
  }
  return;
}
}
apr_status_t apr_xlate_open(apr_xlate_t **convset , char const   *topage , char const   *frompage ,
                            apr_pool_t *pool ) 
{ apr_status_t rv ;
  apr_xlate_t *new ;
  int found ;
  void *tmp ;
  int tmp___1 ;
  int rv___0 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  found = 0;
  (*convset) = (apr_xlate_t *)((void *)0);
  topage = handle_special_names(topage, pool);
  frompage = handle_special_names(frompage, pool);
  tmp = apr_palloc(pool, sizeof(apr_xlate_t ));
  new = (apr_xlate_t *)memset(tmp, 0, sizeof(apr_xlate_t ));
  if (! new) {
    return (12);
  }
  new->pool = pool;
  new->topage = apr_pstrdup(pool, topage);
  new->frompage = apr_pstrdup(pool, frompage);
  if (! new->topage) {
    goto _L;
  } else {
    if (! new->frompage) {
      _L: 
      return (12);
    }
  }
  if (! found) {
    tmp___1 = strcmp(topage, frompage);
    if (tmp___1 == 0) {
      found = 1;
      make_identity_table(new);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
  }
  if (! found) {
    new->ich = iconv_open(topage, frompage);
    if ((unsigned int )new->ich == (unsigned int )((void *)-1)) {
      tmp___2 = __errno_location();
      rv___0 = (*tmp___2);
      if (rv___0) {
        tmp___3 = rv___0;
      } else {
        tmp___3 = 22;
      }
      return (tmp___3);
    }
    found = 1;
    check_sbcs(new);
  } else {
    new->ich = (void *)-1;
  }
  if (found) {
    (*convset) = new;
    apr_pool_cleanup_register(pool, (void const   *)((void *)new), & apr_xlate_cleanup,
                              & apr_pool_cleanup_null);
    rv = 0;
  } else {
    rv = 22;
  }
  return (rv);
}
}
apr_status_t apr_xlate_sb_get(apr_xlate_t *convset , int *onoff ) 
{ 

  {
  (*onoff) = (unsigned int )convset->sbcs_table != (unsigned int )((void *)0);
  return (0);
}
}
apr_status_t apr_xlate_conv_buffer(apr_xlate_t *convset , char const   *inbuf , apr_size_t *inbytes_left ,
                                   char *outbuf , apr_size_t *outbytes_left ) 
{ apr_status_t status ;
  char const   *inbufptr ;
  char *outbufptr ;
  apr_size_t translated ;
  int rv ;
  int *tmp ;
  int to_convert ;
  apr_size_t tmp___0 ;
  int converted ;
  char *table ;

  {
  status = 0;
  if ((unsigned int )convset->ich != (unsigned int )((void *)-1)) {
    inbufptr = inbuf;
    outbufptr = outbuf;
    translated = iconv(convset->ich, (char ** __restrict  )((char **)(& inbufptr)),
                       (size_t * __restrict  )inbytes_left, (char ** __restrict  )(& outbufptr),
                       (size_t * __restrict  )outbytes_left);
    if (translated == 4294967295U) {
      tmp = __errno_location();
      rv = (*tmp);
      switch (rv) {
      case 7: 
      status = 0;
      break;
      case 22: 
      status = 70008;
      break;
      case 84: 
      status = 22;
      break;
      case 0: 
      status = 70008;
      break;
      default: 
      status = rv;
      break;
      }
    }
  } else {
    if ((*inbytes_left) <= (*outbytes_left)) {
      tmp___0 = (*inbytes_left);
    } else {
      tmp___0 = (*outbytes_left);
    }
    to_convert = (int )tmp___0;
    converted = to_convert;
    table = convset->sbcs_table;
    while (to_convert) {
      (*outbuf) = (*(table + (int )((unsigned char )(*inbuf))));
      outbuf ++;
      inbuf ++;
      to_convert --;
    }
    (*inbytes_left) -= (unsigned int )converted;
    (*outbytes_left) -= (unsigned int )converted;
  }
  return (status);
}
}
apr_int32_t apr_xlate_conv_byte(apr_xlate_t *convset , unsigned char inchar ) 
{ 

  {
  if (convset->sbcs_table) {
    return ((int )(*(convset->sbcs_table + (int )inchar)));
  } else {
    return (-1);
  }
}
}
apr_status_t apr_xlate_close(apr_xlate_t *convset ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_cleanup_run(convset->pool, (void *)convset, & apr_xlate_cleanup);
  return (tmp);
}
}
apr_status_t apr_xlate_get_sb(apr_xlate_t *convset , int *onoff ) 
{ apr_status_t tmp ;

  {
  tmp = apr_xlate_sb_get(convset, onoff);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-P5sOMI2f.i","-g -pthread")
char *apr_cpystrn(char *dst , char const   *src , apr_size_t dst_size ) 
{ char *d ;
  char *end ;

  {
  if (dst_size == 0U) {
    return (dst);
  }
  d = dst;
  end = (dst + dst_size) - 1;
  while ((unsigned int )d < (unsigned int )end) {
    (*d) = (char )(*src);
    if (! (*d)) {
      return (d);
    }
    d ++;
    src ++;
  }
  (*d) = (char )'\000';
  return (d);
}
}
apr_status_t apr_tokenize_to_argv(char const   *arg_str , char ***argv_out , apr_pool_t *token_context ) 
{ char const   *cp ;
  char const   *ct ;
  char *cleaned ;
  char *dirty ;
  int escaped ;
  int isquoted ;
  int numargs ;
  int argnum ;
  char *tmp ;

  {
  numargs = 0;
  cp = arg_str;
  while (1) {
    if ((int const   )(*cp) == 32) {
      goto _L;
    } else {
      if ((int const   )(*cp) == 9) {
        _L: ;
      } else {
        break;
      }
    }
    cp ++;
  }
  ct = cp;
  numargs = 1;
  while ((int const   )(*ct) != 0) {
    isquoted = 0;
    if ((int const   )(*ct) == 34) {
      isquoted = 1;
      ct ++;
    } else {
      if ((int const   )(*ct) == 39) {
        isquoted = 2;
        ct ++;
      }
    }
    while ((int const   )(*ct) != 0) {
      if (isquoted) {
        if ((int const   )(*ct) == 32) {
          goto _L___6;
        } else {
          if ((int const   )(*ct) == 9) {
            _L___6: 
            goto _L___2;
          } else {
            goto _L___5;
          }
        }
      } else {
        _L___5: 
        if ((int const   )(*ct) == 92) {
          if ((int const   )(*(ct + 1)) == 32) {
            goto _L___4;
          } else {
            if ((int const   )(*(ct + 1)) == 9) {
              _L___4: 
              goto _L___3;
            } else {
              if ((int const   )(*(ct + 1)) == 34) {
                _L___3: 
                goto _L___2;
              } else {
                if ((int const   )(*(ct + 1)) == 39) {
                  _L___2: 
                  ct ++;
                  goto __Cont;
                } else {
                  goto _L___1;
                }
              }
            }
          }
        } else {
          _L___1: ;
        }
      }
      if (! isquoted) {
        if ((int const   )(*ct) == 32) {
          goto _L___12;
        } else {
          if ((int const   )(*ct) == 9) {
            _L___12: 
            goto _L___9;
          } else {
            goto _L___11;
          }
        }
      } else {
        _L___11: 
        if (isquoted == 1) {
          if ((int const   )(*ct) == 34) {
            _L___9: 
            goto _L___7;
          } else {
            goto _L___10;
          }
        } else {
          _L___10: 
          if (isquoted == 2) {
            if ((int const   )(*ct) == 39) {
              _L___7: 
              break;
            } else {
              goto _L___8;
            }
          } else {
            _L___8: ;
          }
        }
      }
      __Cont: 
      ct ++;
    }
    if ((int const   )(*ct) != 0) {
      ct ++;
    }
    numargs ++;
    while (1) {
      if ((int const   )(*ct) == 32) {
        goto _L___13;
      } else {
        if ((int const   )(*ct) == 9) {
          _L___13: ;
        } else {
          break;
        }
      }
      ct ++;
    }
  }
  (*argv_out) = (char **)apr_palloc(token_context, (unsigned int )numargs * sizeof(char *));
  argnum = 0;
  while (argnum < numargs - 1) {
    isquoted = 0;
    if ((int const   )(*cp) == 34) {
      isquoted = 1;
      cp ++;
    } else {
      if ((int const   )(*cp) == 39) {
        isquoted = 2;
        cp ++;
      }
    }
    ct = cp;
    while ((int const   )(*cp) != 0) {
      if (isquoted) {
        if ((int const   )(*cp) == 32) {
          goto _L___20;
        } else {
          if ((int const   )(*cp) == 9) {
            _L___20: 
            goto _L___16;
          } else {
            goto _L___19;
          }
        }
      } else {
        _L___19: 
        if ((int const   )(*cp) == 92) {
          if ((int const   )(*(cp + 1)) == 32) {
            goto _L___18;
          } else {
            if ((int const   )(*(cp + 1)) == 9) {
              _L___18: 
              goto _L___17;
            } else {
              if ((int const   )(*(cp + 1)) == 34) {
                _L___17: 
                goto _L___16;
              } else {
                if ((int const   )(*(cp + 1)) == 39) {
                  _L___16: 
                  cp ++;
                  goto __Cont___0;
                } else {
                  goto _L___15;
                }
              }
            }
          }
        } else {
          _L___15: ;
        }
      }
      if (! isquoted) {
        if ((int const   )(*cp) == 32) {
          goto _L___26;
        } else {
          if ((int const   )(*cp) == 9) {
            _L___26: 
            goto _L___23;
          } else {
            goto _L___25;
          }
        }
      } else {
        _L___25: 
        if (isquoted == 1) {
          if ((int const   )(*cp) == 34) {
            _L___23: 
            goto _L___21;
          } else {
            goto _L___24;
          }
        } else {
          _L___24: 
          if (isquoted == 2) {
            if ((int const   )(*cp) == 39) {
              _L___21: 
              break;
            } else {
              goto _L___22;
            }
          } else {
            _L___22: ;
          }
        }
      }
      __Cont___0: 
      cp ++;
    }
    cp ++;
    (*((*argv_out) + argnum)) = (char *)apr_palloc(token_context, (unsigned int )(cp -
                                                                                  ct));
    apr_cpystrn((*((*argv_out) + argnum)), ct, (unsigned int )(cp - ct));
    dirty = (*((*argv_out) + argnum));
    cleaned = dirty;
    escaped = 0;
    while ((*dirty)) {
      if (! escaped) {
        if ((int )(*dirty) == 92) {
          escaped = 1;
        } else {
          goto _L___27;
        }
      } else {
        _L___27: 
        escaped = 0;
        tmp = cleaned;
        cleaned ++;
        (*tmp) = (*dirty);
      }
      dirty ++;
    }
    (*cleaned) = (char)0;
    while (1) {
      if ((int const   )(*cp) == 32) {
        goto _L___28;
      } else {
        if ((int const   )(*cp) == 9) {
          _L___28: ;
        } else {
          break;
        }
      }
      cp ++;
    }
    argnum ++;
  }
  (*((*argv_out) + argnum)) = (char *)((void *)0);
  return (0);
}
}
char const   *apr_filepath_name_get(char const   *pathname ) 
{ char path_separator ;
  char const   *s ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  path_separator = (char )'/';
  tmp = strrchr(pathname, (int )path_separator);
  s = tmp;
  if (s) {
    s ++;
    tmp___0 = s;
  } else {
    tmp___0 = pathname;
  }
  return (tmp___0);
}
}
char const   *apr_filename_of_pathname(char const   *pathname ) 
{ char const   *tmp ;

  {
  tmp = apr_filepath_name_get(pathname);
  return (tmp);
}
}
char *apr_collapse_spaces(char *dest , char const   *src ) 
{ char *tmp ;
  unsigned short const   **tmp___0 ;

  {
  while ((*src)) {
    tmp___0 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___0) + (int )((unsigned char )(*src)))) & 8192)) {
      tmp = dest;
      dest ++;
      (*tmp) = (char )(*src);
    }
    src ++;
  }
  (*dest) = (char)0;
  return (dest);
}
}
#pragma merger(0,"/tmp/cil-1nJFM0E5.i","-g -pthread")
static char const   *rangematch(char const   *pattern , int test , int flags ) ;
apr_status_t apr_fnmatch(char const   *pattern , char const   *string , int flags ) 
{ char const   *stringstart ;
  char c ;
  char test ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___2 ;
  char *tmp___3 ;
  apr_status_t tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  stringstart = string;
  while (1) {
    tmp = pattern;
    pattern ++;
    c = (char )(*tmp);
    switch ((int )c) {
    case 0: ;
    if ((int const   )(*string) == 0) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    return (tmp___0);
    case 63: ;
    if ((int const   )(*string) == 0) {
      return (1);
    }
    if ((int const   )(*string) == 47) {
      if (flags & 2) {
        return (1);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    if ((int const   )(*string) == 46) {
      if (flags & 4) {
        if ((unsigned int )string == (unsigned int )stringstart) {
          goto _L___1;
        } else {
          if (flags & 2) {
            if ((int const   )(*(string - 1)) == 47) {
              _L___1: 
              return (1);
            } else {
              goto _L___2;
            }
          } else {
            _L___2: 
            goto _L___3;
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: ;
    }
    string ++;
    break;
    case 42: 
    c = (char )(*pattern);
    while ((int )c == 42) {
      pattern ++;
      c = (char )(*pattern);
    }
    if ((int const   )(*string) == 46) {
      if (flags & 4) {
        if ((unsigned int )string == (unsigned int )stringstart) {
          goto _L___5;
        } else {
          if (flags & 2) {
            if ((int const   )(*(string - 1)) == 47) {
              _L___5: 
              return (1);
            } else {
              goto _L___6;
            }
          } else {
            _L___6: 
            goto _L___7;
          }
        }
      } else {
        goto _L___7;
      }
    } else {
      _L___7: ;
    }
    if ((int )c == 0) {
      if (flags & 2) {
        tmp___3 = strchr(string, '/');
        if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
          tmp___2 = 0;
        } else {
          tmp___2 = 1;
        }
        return (tmp___2);
      } else {
        return (0);
      }
    } else {
      if ((int )c == 47) {
        if (flags & 2) {
          string = strchr(string, '/');
          if ((unsigned int )string == (unsigned int )((void *)0)) {
            return (1);
          }
          break;
        } else {
          goto _L___8;
        }
      } else {
        _L___8: ;
      }
    }
    while (1) {
      test = (char )(*string);
      if (! ((int )test != 0)) {
        break;
      }
      tmp___4 = apr_fnmatch(pattern, string, flags & -5);
      if (! tmp___4) {
        return (0);
      }
      if ((int )test == 47) {
        if (flags & 2) {
          break;
        } else {
          goto _L___9;
        }
      } else {
        _L___9: ;
      }
      string ++;
    }
    return (1);
    case 91: ;
    if ((int const   )(*string) == 0) {
      return (1);
    }
    if ((int const   )(*string) == 47) {
      if (flags & 2) {
        return (1);
      } else {
        goto _L___10;
      }
    } else {
      _L___10: ;
    }
    if ((int const   )(*string) == 46) {
      if (flags & 4) {
        if ((unsigned int )string == (unsigned int )stringstart) {
          goto _L___12;
        } else {
          if (flags & 2) {
            if ((int const   )(*(string - 1)) == 47) {
              _L___12: 
              return (1);
            } else {
              goto _L___13;
            }
          } else {
            _L___13: 
            goto _L___14;
          }
        }
      } else {
        goto _L___14;
      }
    } else {
      _L___14: ;
    }
    pattern = rangematch(pattern, (int )(*string), flags);
    if ((unsigned int )pattern == (unsigned int )((void *)0)) {
      return (1);
    }
    string ++;
    break;
    case 92: ;
    if (! (flags & 1)) {
      tmp___5 = pattern;
      pattern ++;
      c = (char )(*tmp___5);
      if ((int )c == 0) {
        c = (char )'\\';
        pattern --;
      }
    }
    default: ;
    if (flags & 8) {
      tmp___6 = tolower((int )((unsigned char )c));
      tmp___7 = tolower((int )((unsigned char )(*string)));
      if (tmp___6 != tmp___7) {
        return (1);
      }
    } else {
      if ((int )c != (int )(*string)) {
        return (1);
      }
    }
    string ++;
    break;
    }
  }
  return (0);
}
}
static char const   *rangematch(char const   *pattern , int test , int flags ) 
{ int negate ;
  int ok ;
  char c ;
  char c2 ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
  if ((int const   )(*pattern) == 33) {
    goto _L;
  } else {
    if ((int const   )(*pattern) == 94) {
      _L: 
      tmp = 1;
    } else {
      tmp = 0;
    }
  }
  negate = tmp;
  if (negate) {
    pattern ++;
  }
  ok = 0;
  while (1) {
    tmp___8 = pattern;
    pattern ++;
    c = (char )(*tmp___8);
    if (! ((int )c != 93)) {
      break;
    }
    if ((int )c == 92) {
      if (! (flags & 1)) {
        tmp___0 = pattern;
        pattern ++;
        c = (char )(*tmp___0);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
    if ((int )c == 0) {
      return ((char const   *)((void *)0));
    }
    if ((int const   )(*pattern) == 45) {
      c2 = (char )(*(pattern + 1));
      if ((int )c2 != 0) {
        if ((int )c2 != 93) {
          pattern += 2;
          if ((int )c2 == 92) {
            if (! (flags & 1)) {
              tmp___1 = pattern;
              pattern ++;
              c2 = (char )(*tmp___1);
            } else {
              goto _L___1;
            }
          } else {
            _L___1: ;
          }
          if ((int )c2 == 0) {
            return ((char const   *)((void *)0));
          }
          if ((int )c <= test) {
            if (test <= (int )c2) {
              goto _L___2;
            } else {
              goto _L___5;
            }
          } else {
            _L___5: 
            if (flags & 8) {
              tmp___2 = tolower((int )((unsigned char )c));
              tmp___3 = tolower((int )((unsigned char )test));
              if (tmp___2 <= tmp___3) {
                tmp___4 = tolower((int )((unsigned char )test));
                tmp___5 = tolower((int )((unsigned char )c2));
                if (tmp___4 <= tmp___5) {
                  _L___2: 
                  ok = 1;
                } else {
                  goto _L___4;
                }
              } else {
                _L___4: 
                goto _L___3;
              }
            } else {
              _L___3: ;
            }
          }
        } else {
          goto _L___9;
        }
      } else {
        goto _L___9;
      }
    } else {
      _L___9: 
      if ((int )c == test) {
        goto _L___6;
      } else {
        if (flags & 8) {
          tmp___6 = tolower((int )((unsigned char )c));
          tmp___7 = tolower((int )((unsigned char )test));
          if (tmp___6 == tmp___7) {
            _L___6: 
            ok = 1;
          } else {
            goto _L___7;
          }
        } else {
          _L___7: ;
        }
      }
    }
  }
  if (ok == negate) {
    tmp___9 = (char const   *)((void *)0);
  } else {
    tmp___9 = pattern;
  }
  return (tmp___9);
}
}
int apr_fnmatch_test(char const   *pattern ) 
{ int nesting ;
  char const   *tmp ;

  {
  nesting = 0;
  while ((*pattern)) {
    switch ((int )(*pattern)) {
    case 63: ;
    case 42: ;
    return (1);
    case 92: 
    tmp = pattern;
    pattern ++;
    if ((int const   )(*tmp) == 0) {
      return (0);
    }
    break;
    case 91: 
    nesting ++;
    break;
    case 93: ;
    if (nesting) {
      return (1);
    }
    break;
    }
    pattern ++;
  }
  return (0);
}
}
int apr_is_fnmatch(char const   *pattern ) 
{ int tmp ;

  {
  tmp = apr_fnmatch_test(pattern);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-D8ATpaOo.i","-g -pthread")
extern uint32_t ntohl(uint32_t __netlong )  __attribute__((__const__)) ;
extern uint32_t htonl(uint32_t __hostlong )  __attribute__((__const__)) ;
extern double modf(double __x , double *__iptr ) ;
extern int __isinf(double __value )  __attribute__((__const__)) ;
extern int __isnan(double __value )  __attribute__((__const__)) ;
extern int __isinff(float __value )  __attribute__((__const__)) ;
extern int __isnanf(float __value )  __attribute__((__const__)) ;
extern int __isinfl(long double __value )  __attribute__((__const__)) ;
extern int __isnanl(long double __value )  __attribute__((__const__)) ;
static char *apr_cvt(double arg , int ndigits , int *decpt , int *sign , int eflag ,
                     char *buf ) 
{ register int r2 ;
  double fi ;
  double fj ;
  register char *p ;
  register char *p1 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  if (ndigits >= 79) {
    ndigits = 78;
  }
  r2 = 0;
  (*sign) = 0;
  p = buf + 0;
  if (arg < (double )0) {
    (*sign) = 1;
    arg = - arg;
  }
  arg = modf(arg, & fi);
  p1 = buf + 80;
  if (fi != (double )0) {
    p1 = buf + 80;
    while (1) {
      if ((unsigned int )p1 > (unsigned int )(buf + 0)) {
        if (! (fi != (double )0)) {
          goto _L;
        }
      } else {
        _L: 
        break;
      }
      fj = modf(fi / (double )10, & fi);
      p1 --;
      (*p1) = (char )((int )((fj + .03) * (double )10) + 48);
      r2 ++;
    }
    while ((unsigned int )p1 < (unsigned int )(buf + 80)) {
      tmp = p;
      p ++;
      tmp___0 = p1;
      p1 ++;
      (*tmp) = (*tmp___0);
    }
  } else {
    if (arg > (double )0) {
      while (1) {
        fj = arg * (double )10;
        if (! (fj < (double )1)) {
          break;
        }
        arg = fj;
        r2 --;
      }
    }
  }
  p1 = buf + ndigits;
  if (eflag == 0) {
    p1 += r2;
  }
  (*decpt) = r2;
  if ((unsigned int )p1 < (unsigned int )(buf + 0)) {
    (*(buf + 0)) = (char )'\000';
    return (buf);
  }
  while (1) {
    if ((unsigned int )p <= (unsigned int )p1) {
      if (! ((unsigned int )p < (unsigned int )(buf + 80))) {
        goto _L___0;
      }
    } else {
      _L___0: 
      break;
    }
    arg *= (double )10;
    arg = modf(arg, & fj);
    tmp___1 = p;
    p ++;
    (*tmp___1) = (char )((int )fj + 48);
  }
  if ((unsigned int )p1 >= (unsigned int )(buf + 80)) {
    (*(buf + 79)) = (char )'\000';
    return (buf);
  }
  p = p1;
  (*p1) = (char )((int )(*p1) + 5);
  while ((int )(*p1) > 57) {
    (*p1) = (char )'0';
    if ((unsigned int )p1 > (unsigned int )buf) {
      p1 --;
      (*p1) = (char )((int )(*p1) + 1);
    } else {
      (*p1) = (char )'1';
      (*decpt) ++;
      if (eflag == 0) {
        if ((unsigned int )p > (unsigned int )buf) {
          (*p) = (char )'0';
        }
        p ++;
      }
    }
  }
  (*p) = (char )'\000';
  return (buf);
}
}
static char *apr_ecvt(double arg , int ndigits , int *decpt , int *sign , char *buf ) 
{ char *tmp ;

  {
  tmp = apr_cvt(arg, ndigits, decpt, sign, 1, buf);
  return (tmp);
}
}
static char *apr_fcvt(double arg , int ndigits , int *decpt , int *sign , char *buf ) 
{ char *tmp ;

  {
  tmp = apr_cvt(arg, ndigits, decpt, sign, 0, buf);
  return (tmp);
}
}
static char *apr_gcvt(double number , int ndigit , char *buf , boolean_e altform ) 
{ int sign ;
  int decpt ;
  register char *p1 ;
  register char *p2 ;
  register int i ;
  char buf1[80] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;

  {
  p1 = apr_ecvt(number, ndigit, & decpt, & sign, buf1);
  p2 = buf;
  if (sign) {
    tmp = p2;
    p2 ++;
    (*tmp) = (char )'-';
  }
  i = ndigit - 1;
  while (1) {
    if (i > 0) {
      if (! ((int )(*(p1 + i)) == 48)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
    ndigit --;
    i --;
  }
  if (decpt >= 0) {
    if (decpt - ndigit > 4) {
      goto _L___0;
    } else {
      goto _L___2;
    }
  } else {
    _L___2: 
    if (decpt < 0) {
      if (decpt < -3) {
        _L___0: 
        decpt --;
        tmp___0 = p2;
        p2 ++;
        tmp___1 = p1;
        p1 ++;
        (*tmp___0) = (*tmp___1);
        tmp___2 = p2;
        p2 ++;
        (*tmp___2) = (char )'.';
        i = 1;
        while (i < ndigit) {
          tmp___3 = p2;
          p2 ++;
          tmp___4 = p1;
          p1 ++;
          (*tmp___3) = (*tmp___4);
          i ++;
        }
        tmp___5 = p2;
        p2 ++;
        (*tmp___5) = (char )'e';
        if (decpt < 0) {
          decpt = - decpt;
          tmp___6 = p2;
          p2 ++;
          (*tmp___6) = (char )'-';
        } else {
          tmp___7 = p2;
          p2 ++;
          (*tmp___7) = (char )'+';
        }
        if (decpt / 100 > 0) {
          tmp___8 = p2;
          p2 ++;
          (*tmp___8) = (char )(decpt / 100 + 48);
        }
        if (decpt / 10 > 0) {
          tmp___9 = p2;
          p2 ++;
          (*tmp___9) = (char )((decpt % 100) / 10 + 48);
        }
        tmp___10 = p2;
        p2 ++;
        (*tmp___10) = (char )(decpt % 10 + 48);
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if (decpt <= 0) {
        if ((int )(*p1) != 48) {
          tmp___11 = p2;
          p2 ++;
          (*tmp___11) = (char )'.';
        }
        while (decpt < 0) {
          decpt ++;
          tmp___12 = p2;
          p2 ++;
          (*tmp___12) = (char )'0';
        }
      }
      i = 1;
      while (i <= ndigit) {
        tmp___13 = p2;
        p2 ++;
        tmp___14 = p1;
        p1 ++;
        (*tmp___13) = (*tmp___14);
        if (i == decpt) {
          tmp___15 = p2;
          p2 ++;
          (*tmp___15) = (char )'.';
        }
        i ++;
      }
      if (ndigit < decpt) {
        while (1) {
          tmp___17 = ndigit;
          ndigit ++;
          if (! (tmp___17 < decpt)) {
            break;
          }
          tmp___16 = p2;
          p2 ++;
          (*tmp___16) = (char )'0';
        }
        tmp___18 = p2;
        p2 ++;
        (*tmp___18) = (char )'.';
      }
    }
  }
  if ((int )(*(p2 + -1)) == 46) {
    if (! altform) {
      p2 --;
    } else {
      goto _L___3;
    }
  } else {
    _L___3: ;
  }
  (*p2) = (char )'\000';
  return (buf);
}
}
static char *conv_10(wide_int num , bool_int is_unsigned , bool_int *is_negative ,
                     char *buf_end , int *len ) 
{ register char *p ;
  register u_wide_int magnitude ;
  wide_int t ;
  register u_wide_int new_magnitude ;

  {
  p = buf_end;
  if (is_unsigned) {
    magnitude = (unsigned long )num;
    (*is_negative) = 0;
  } else {
    (*is_negative) = num < 0L;
    if ((*is_negative)) {
      t = num + 1L;
      magnitude = (unsigned long )(- t) + 1UL;
    } else {
      magnitude = (unsigned long )num;
    }
  }
  while (1) {
    new_magnitude = magnitude / 10UL;
    p --;
    (*p) = (char )((magnitude - new_magnitude * 10UL) + 48UL);
    magnitude = new_magnitude;
    if (! magnitude) {
      break;
    }
  }
  (*len) = buf_end - p;
  return (p);
}
}
static char *conv_10_quad(widest_int num , bool_int is_unsigned , bool_int *is_negative ,
                          char *buf_end , int *len ) 
{ register char *p ;
  u_widest_int magnitude ;
  char *tmp ;
  widest_int t ;
  u_widest_int new_magnitude ;

  {
  p = buf_end;
  if (num <= 4294967295LL) {
    if (is_unsigned) {
      goto _L;
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    if (num <= 2147483647LL) {
      if (! is_unsigned) {
        _L: 
        tmp = conv_10((long )num, is_unsigned, is_negative, buf_end, len);
        return (tmp);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
  }
  if (is_unsigned) {
    magnitude = (unsigned long long )num;
    (*is_negative) = 0;
  } else {
    (*is_negative) = num < 0LL;
    if ((*is_negative)) {
      t = num + 1LL;
      magnitude = (unsigned long long )(- t) + 1ULL;
    } else {
      magnitude = (unsigned long long )num;
    }
  }
  while (1) {
    new_magnitude = magnitude / 10ULL;
    p --;
    (*p) = (char )((magnitude - new_magnitude * 10ULL) + 48ULL);
    magnitude = new_magnitude;
    if (! magnitude) {
      break;
    }
  }
  (*len) = buf_end - p;
  return (p);
}
}
static char *conv_in_addr(struct in_addr *ia , char *buf_end , int *len ) 
{ unsigned int addr ;
  unsigned int tmp ;
  char *p ;
  bool_int is_negative ;
  int sub_len ;

  {
  tmp = ntohl(ia->s_addr);
  addr = tmp;
  p = buf_end;
  p = conv_10((long )(addr & 255U), 1, & is_negative, p, & sub_len);
  p --;
  (*p) = (char )'.';
  p = conv_10((long )((addr & 65280U) >> 8), 1, & is_negative, p, & sub_len);
  p --;
  (*p) = (char )'.';
  p = conv_10((long )((addr & 16711680U) >> 16), 1, & is_negative, p, & sub_len);
  p --;
  (*p) = (char )'.';
  p = conv_10((long )((addr & 4278190080U) >> 24), 1, & is_negative, p, & sub_len);
  (*len) = buf_end - p;
  return (p);
}
}
static char *conv_apr_sockaddr(apr_sockaddr_t *sa , char *buf_end , int *len ) 
{ char *p ;
  bool_int is_negative ;
  int sub_len ;
  char *ipaddr_str ;
  uint32_t tmp ;

  {
  p = buf_end;
  p = conv_10((long )sa->port, 1, & is_negative, p, & sub_len);
  p --;
  (*p) = (char )':';
  apr_sockaddr_ip_get(& ipaddr_str, sa);
  sub_len = (int )strlen((char const   *)ipaddr_str);
  if (sa->family == 10) {
    if ((*((uint32_t const   *)(& sa->sa.sin6.sin6_addr) + 0)) == 0U) {
      if ((*((uint32_t const   *)(& sa->sa.sin6.sin6_addr) + 1)) == 0U) {
        tmp = htonl(65535U);
        if ((*((uint32_t const   *)(& sa->sa.sin6.sin6_addr) + 2)) == (uint32_t const   )tmp) {
          goto _L;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      (*(p - 1)) = (char )']';
      p -= sub_len + 2;
      (*p) = (char )'[';
      memcpy((void * __restrict  )(p + 1), (void const   * __restrict  )ipaddr_str,
             (unsigned int )sub_len);
    }
  } else {
    _L: 
    p -= sub_len;
    memcpy((void * __restrict  )p, (void const   * __restrict  )ipaddr_str, (unsigned int )sub_len);
  }
  (*len) = buf_end - p;
  return (p);
}
}
static char *conv_fp(char format , double num , boolean_e add_dp , int precision ,
                     bool_int *is_negative , char *buf , int *len ) 
{ register char *s ;
  register char *p ;
  int decimal_point ;
  char buf1[80] ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char temp[10] ;
  int t_len ;
  bool_int exponent_is_negative ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;

  {
  s = buf;
  if ((int )format == 102) {
    p = apr_fcvt(num, precision, & decimal_point, is_negative, buf1);
  } else {
    p = apr_ecvt(num, precision + 1, & decimal_point, is_negative, buf1);
  }
  tmp = __ctype_b_loc();
  if ((int const   )(*((*tmp) + (int )((unsigned char )(*p)))) & 1024) {
    (*len) = (int )strlen((char const   *)p);
    memcpy((void * __restrict  )buf, (void const   * __restrict  )p, (unsigned int )((*len) +
                                                                                     1));
    (*is_negative) = 0;
    return (buf);
  }
  if ((int )format == 102) {
    if (decimal_point <= 0) {
      tmp___0 = s;
      s ++;
      (*tmp___0) = (char )'0';
      if (precision > 0) {
        tmp___1 = s;
        s ++;
        (*tmp___1) = (char )'.';
        while (1) {
          tmp___3 = decimal_point;
          decimal_point ++;
          if (! (tmp___3 < 0)) {
            break;
          }
          tmp___2 = s;
          s ++;
          (*tmp___2) = (char )'0';
        }
      } else {
        if (add_dp) {
          tmp___4 = s;
          s ++;
          (*tmp___4) = (char )'.';
        }
      }
    } else {
      while (1) {
        tmp___7 = decimal_point;
        decimal_point --;
        if (! (tmp___7 > 0)) {
          break;
        }
        tmp___5 = s;
        s ++;
        tmp___6 = p;
        p ++;
        (*tmp___5) = (*tmp___6);
      }
      if (precision > 0) {
        goto _L;
      } else {
        if (add_dp) {
          _L: 
          tmp___8 = s;
          s ++;
          (*tmp___8) = (char )'.';
        }
      }
    }
  } else {
    tmp___9 = s;
    s ++;
    tmp___10 = p;
    p ++;
    (*tmp___9) = (*tmp___10);
    if (precision > 0) {
      goto _L___0;
    } else {
      if (add_dp) {
        _L___0: 
        tmp___11 = s;
        s ++;
        (*tmp___11) = (char )'.';
      }
    }
  }
  while ((*p)) {
    tmp___12 = s;
    s ++;
    tmp___13 = p;
    p ++;
    (*tmp___12) = (*tmp___13);
  }
  if ((int )format != 102) {
    tmp___14 = s;
    s ++;
    (*tmp___14) = format;
    decimal_point --;
    if (decimal_point != 0) {
      p = conv_10((long )decimal_point, 0, & exponent_is_negative, & temp[10], & t_len);
      tmp___15 = s;
      s ++;
      if (exponent_is_negative) {
        (*tmp___15) = (char )'-';
      } else {
        (*tmp___15) = (char )'+';
      }
      if (t_len == 1) {
        tmp___16 = s;
        s ++;
        (*tmp___16) = (char )'0';
      }
      while (1) {
        tmp___19 = t_len;
        t_len --;
        if (! tmp___19) {
          break;
        }
        tmp___17 = s;
        s ++;
        tmp___18 = p;
        p ++;
        (*tmp___17) = (*tmp___18);
      }
    } else {
      tmp___20 = s;
      s ++;
      (*tmp___20) = (char )'+';
      tmp___21 = s;
      s ++;
      (*tmp___21) = (char )'0';
      tmp___22 = s;
      s ++;
      (*tmp___22) = (char )'0';
    }
  }
  (*len) = s - buf;
  return (buf);
}
}
static char *conv_p2(u_wide_int num , int nbits , char format , char *buf_end , int *len ) ;
static char const   low_digits[17]  = 
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
static char const   upper_digits[17]  = 
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'\000'};
static char *conv_p2(u_wide_int num , int nbits , char format , char *buf_end , int *len ) 
{ register int mask ;
  register char *p ;
  register char const   *digits___0 ;
  char const   *tmp ;

  {
  mask = (1 << nbits) - 1;
  p = buf_end;
  if ((int )format == 88) {
    tmp = upper_digits;
  } else {
    tmp = low_digits;
  }
  digits___0 = tmp;
  while (1) {
    p --;
    (*p) = (char )(*(digits___0 + (num & (unsigned long )mask)));
    num >>= nbits;
    if (! num) {
      break;
    }
  }
  (*len) = buf_end - p;
  return (p);
}
}
static char *conv_p2_quad(u_widest_int num , int nbits , char format , char *buf_end ,
                          int *len ) ;
static char const   low_digits___0[17]  = 
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
static char const   upper_digits___0[17]  = 
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'\000'};
static char *conv_p2_quad(u_widest_int num , int nbits , char format , char *buf_end ,
                          int *len ) 
{ register int mask ;
  register char *p ;
  register char const   *digits___0 ;
  char const   *tmp ;
  char *tmp___0 ;

  {
  mask = (1 << nbits) - 1;
  p = buf_end;
  if ((int )format == 88) {
    tmp = upper_digits___0;
  } else {
    tmp = low_digits___0;
  }
  digits___0 = tmp;
  if (num <= 4294967295ULL) {
    tmp___0 = conv_p2((unsigned long )num, nbits, format, buf_end, len);
    return (tmp___0);
  }
  while (1) {
    p --;
    (*p) = (char )(*(digits___0 + (num & (unsigned long long )mask)));
    num >>= nbits;
    if (! num) {
      break;
    }
  }
  (*len) = buf_end - p;
  return (p);
}
}
int apr_vformatter(int (*flush_func)(apr_vformatter_buff_t *b ) , apr_vformatter_buff_t *vbuff ,
                   char const   *fmt , va_list ap ) 
{ register char *sp ;
  register char *bep ;
  register int cc ;
  register int i ;
  register char *s ;
  char *q ;
  int s_len ;
  register int min_width ;
  int precision ;
  enum __anonenum_adjust_62 adjust ;
  char pad_char ;
  char prefix_char ;
  double fp_num ;
  widest_int i_quad ;
  u_widest_int ui_quad ;
  wide_int i_num ;
  u_wide_int ui_num ;
  char num_buf[512] ;
  char char_buf[2] ;
  enum var_type_enum var_type ;
  boolean_e alternate_form ;
  boolean_e print_sign ;
  boolean_e print_blank ;
  boolean_e adjust_precision ;
  boolean_e adjust_width ;
  bool_int is_negative ;
  int tmp ;
  char *tmp___0 ;
  boolean_e print_something ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  u_wide_int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  int p ;
  int tmp___13 ;
  wide_int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int p___0 ;
  int tmp___17 ;
  u_wide_int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  int p___1 ;
  int tmp___21 ;
  u_wide_int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  int p___2 ;
  int tmp___25 ;
  char const   *walk ;
  int tmp___30 ;
  int tmp___37 ;
  int tmp___40 ;
  double tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  widest_int *tmp___45 ;
  long *tmp___46 ;
  short *tmp___47 ;
  int *tmp___48 ;
  void *tmp___49 ;
  apr_sockaddr_t *sa ;
  struct in_addr *ia ;
  int tmp___50 ;
  char *tmp___51 ;
  int tmp___52 ;
  char *tmp___53 ;
  int tmp___54 ;
  char *tmp___55 ;
  int tmp___56 ;
  char *tmp___57 ;

  {
  cc = 0;
  s = (char *)((void *)0);
  min_width = 0;
  precision = 0;
  i_quad = 0LL;
  i_num = 0L;
  var_type = (enum var_type_enum )3;
  sp = vbuff->curpos;
  bep = vbuff->endpos;
  while ((*fmt)) {
    if ((int const   )(*fmt) != 37) {
      if (sp) {
        if ((unsigned int )sp >= (unsigned int )bep) {
          vbuff->curpos = sp;
          tmp = ((*flush_func))(vbuff);
          if (tmp) {
            return (-1);
          }
          sp = vbuff->curpos;
          bep = vbuff->endpos;
        }
        tmp___0 = sp;
        sp ++;
        (*tmp___0) = (char )(*fmt);
      }
      cc ++;
    } else {
      print_something = (enum __anonenum_boolean_e_61 )1;
      adjust = (enum __anonenum_adjust_62 )1;
      print_blank = (enum __anonenum_boolean_e_61 )0;
      print_sign = print_blank;
      alternate_form = print_sign;
      pad_char = (char )' ';
      prefix_char = (char )'\000';
      fmt ++;
      tmp___9 = __ctype_b_loc();
      if ((int const   )(*((*tmp___9) + (int )((unsigned char )(*fmt)))) & 512) {
        adjust_width = (enum __anonenum_boolean_e_61 )0;
        adjust_precision = adjust_width;
      } else {
        while (1) {
          if ((int const   )(*fmt) == 45) {
            adjust = (enum __anonenum_adjust_62 )0;
          } else {
            if ((int const   )(*fmt) == 43) {
              print_sign = (enum __anonenum_boolean_e_61 )1;
            } else {
              if ((int const   )(*fmt) == 35) {
                alternate_form = (enum __anonenum_boolean_e_61 )1;
              } else {
                if ((int const   )(*fmt) == 32) {
                  print_blank = (enum __anonenum_boolean_e_61 )1;
                } else {
                  if ((int const   )(*fmt) == 48) {
                    pad_char = (char )'0';
                  } else {
                    break;
                  }
                }
              }
            }
          }
          fmt ++;
        }
        tmp___4 = __ctype_b_loc();
        if ((int const   )(*((*tmp___4) + (int )((unsigned char )(*fmt)))) & 2048) {
          tmp___1 = fmt;
          fmt ++;
          min_width = (int )((int const   )(*tmp___1) - 48);
          while (1) {
            tmp___3 = __ctype_b_loc();
            if (! ((int const   )(*((*tmp___3) + (int )((unsigned char )(*fmt)))) &
                   2048)) {
              break;
            }
            min_width *= 10;
            tmp___2 = fmt;
            fmt ++;
            min_width += (int )((int const   )(*tmp___2) - 48);
          }
          adjust_width = (enum __anonenum_boolean_e_61 )1;
        } else {
          if ((int const   )(*fmt) == 42) {
            min_width = __builtin_va_arg(ap, int );
            fmt ++;
            adjust_width = (enum __anonenum_boolean_e_61 )1;
            if (min_width < 0) {
              adjust = (enum __anonenum_adjust_62 )0;
              min_width = - min_width;
            }
          } else {
            adjust_width = (enum __anonenum_boolean_e_61 )0;
          }
        }
        if ((int const   )(*fmt) == 46) {
          adjust_precision = (enum __anonenum_boolean_e_61 )1;
          fmt ++;
          tmp___8 = __ctype_b_loc();
          if ((int const   )(*((*tmp___8) + (int )((unsigned char )(*fmt)))) & 2048) {
            tmp___5 = fmt;
            fmt ++;
            precision = (int )((int const   )(*tmp___5) - 48);
            while (1) {
              tmp___7 = __ctype_b_loc();
              if (! ((int const   )(*((*tmp___7) + (int )((unsigned char )(*fmt)))) &
                     2048)) {
                break;
              }
              precision *= 10;
              tmp___6 = fmt;
              fmt ++;
              precision += (int )((int const   )(*tmp___6) - 48);
            }
          } else {
            if ((int const   )(*fmt) == 42) {
              precision = __builtin_va_arg(ap, int );
              fmt ++;
              if (precision < 0) {
                precision = 0;
              }
            } else {
              precision = 0;
            }
          }
        } else {
          adjust_precision = (enum __anonenum_boolean_e_61 )0;
        }
      }
      if ((int const   )(*fmt) == (int const   )(*("lld" + 0))) {
        if ((int const   )(*(fmt + 1)) == (int const   )(*("lld" + 1))) {
          var_type = (enum var_type_enum )0;
          fmt += sizeof("lld") - 2U;
        } else {
          goto _L;
        }
      } else {
        _L: 
        if ((int const   )(*fmt) == 113) {
          var_type = (enum var_type_enum )0;
          fmt ++;
        } else {
          if ((int const   )(*fmt) == 108) {
            var_type = (enum var_type_enum )1;
            fmt ++;
          } else {
            if ((int const   )(*fmt) == 104) {
              var_type = (enum var_type_enum )2;
              fmt ++;
            } else {
              var_type = (enum var_type_enum )3;
            }
          }
        }
      }
      switch ((int )(*fmt)) {
      case 117: ;
      if ((int )var_type == 0) {
        i_quad = __builtin_va_arg(ap, u_widest_int );
        s = conv_10_quad(i_quad, 1, & is_negative, & num_buf[512], & s_len);
      } else {
        if ((int )var_type == 1) {
          tmp___10 = __builtin_va_arg(ap, u_wide_int );
          i_num = (long )tmp___10;
        } else {
          if ((int )var_type == 2) {
            tmp___11 = __builtin_va_arg(ap, unsigned int );
            i_num = (long )((unsigned short )tmp___11);
          } else {
            tmp___12 = __builtin_va_arg(ap, unsigned int );
            i_num = (long )tmp___12;
          }
        }
        s = conv_10(i_num, 1, & is_negative, & num_buf[512], & s_len);
      }
      if (adjust_precision) {
        if (precision < 511) {
          tmp___13 = precision;
        } else {
          tmp___13 = 511;
        }
        p = tmp___13;
        while (s_len < p) {
          s --;
          (*s) = (char )'0';
          s_len ++;
        }
      }
      break;
      case 100: ;
      case 105: ;
      if ((int )var_type == 0) {
        i_quad = __builtin_va_arg(ap, widest_int );
        s = conv_10_quad(i_quad, 0, & is_negative, & num_buf[512], & s_len);
      } else {
        if ((int )var_type == 1) {
          tmp___14 = __builtin_va_arg(ap, wide_int );
          i_num = tmp___14;
        } else {
          if ((int )var_type == 2) {
            tmp___15 = __builtin_va_arg(ap, int );
            i_num = (long )((short )tmp___15);
          } else {
            tmp___16 = __builtin_va_arg(ap, int );
            i_num = (long )tmp___16;
          }
        }
        s = conv_10(i_num, 0, & is_negative, & num_buf[512], & s_len);
      }
      if (adjust_precision) {
        if (precision < 511) {
          tmp___17 = precision;
        } else {
          tmp___17 = 511;
        }
        p___0 = tmp___17;
        while (s_len < p___0) {
          s --;
          (*s) = (char )'0';
          s_len ++;
        }
      }
      if (is_negative) {
        prefix_char = (char )'-';
      } else {
        if (print_sign) {
          prefix_char = (char )'+';
        } else {
          if (print_blank) {
            prefix_char = (char )' ';
          }
        }
      }
      break;
      case 111: ;
      if ((int )var_type == 0) {
        ui_quad = __builtin_va_arg(ap, u_widest_int );
        s = conv_p2_quad(ui_quad, 3, (char )(*fmt), & num_buf[512], & s_len);
      } else {
        if ((int )var_type == 1) {
          tmp___18 = __builtin_va_arg(ap, u_wide_int );
          ui_num = tmp___18;
        } else {
          if ((int )var_type == 2) {
            tmp___19 = __builtin_va_arg(ap, unsigned int );
            ui_num = (unsigned long )((unsigned short )tmp___19);
          } else {
            tmp___20 = __builtin_va_arg(ap, unsigned int );
            ui_num = (unsigned long )tmp___20;
          }
        }
        s = conv_p2(ui_num, 3, (char )(*fmt), & num_buf[512], & s_len);
      }
      if (adjust_precision) {
        if (precision < 511) {
          tmp___21 = precision;
        } else {
          tmp___21 = 511;
        }
        p___1 = tmp___21;
        while (s_len < p___1) {
          s --;
          (*s) = (char )'0';
          s_len ++;
        }
      }
      if (alternate_form) {
        if ((int )(*s) != 48) {
          s --;
          (*s) = (char )'0';
          s_len ++;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: ;
      }
      break;
      case 120: ;
      case 88: ;
      if ((int )var_type == 0) {
        ui_quad = __builtin_va_arg(ap, u_widest_int );
        s = conv_p2_quad(ui_quad, 4, (char )(*fmt), & num_buf[512], & s_len);
      } else {
        if ((int )var_type == 1) {
          tmp___22 = __builtin_va_arg(ap, u_wide_int );
          ui_num = tmp___22;
        } else {
          if ((int )var_type == 2) {
            tmp___23 = __builtin_va_arg(ap, unsigned int );
            ui_num = (unsigned long )((unsigned short )tmp___23);
          } else {
            tmp___24 = __builtin_va_arg(ap, unsigned int );
            ui_num = (unsigned long )tmp___24;
          }
        }
        s = conv_p2(ui_num, 4, (char )(*fmt), & num_buf[512], & s_len);
      }
      if (adjust_precision) {
        if (precision < 511) {
          tmp___25 = precision;
        } else {
          tmp___25 = 511;
        }
        p___2 = tmp___25;
        while (s_len < p___2) {
          s --;
          (*s) = (char )'0';
          s_len ++;
        }
      }
      if (alternate_form) {
        if (i_num != 0L) {
          s --;
          (*s) = (char )(*fmt);
          s --;
          (*s) = (char )'0';
          s_len += 2;
        } else {
          goto _L___1;
        }
      } else {
        _L___1: ;
      }
      break;
      case 115: 
      s = __builtin_va_arg(ap, char *);
      if ((unsigned int )s != (unsigned int )((void *)0)) {
        if (! adjust_precision) {
          s_len = (int )strlen((char const   *)s);
        } else {
          walk = (char const   *)s;
          s_len = 0;
          while (1) {
            if (s_len < precision) {
              if (! ((int const   )(*walk) != 0)) {
                goto _L___2;
              }
            } else {
              _L___2: 
              break;
            }
            walk ++;
            s_len ++;
          }
        }
      } else {
        s = (char *)"(null)";
        s_len = 6;
      }
      pad_char = (char )' ';
      break;
      case 102: ;
      case 101: ;
      case 69: 
      fp_num = __builtin_va_arg(ap, double );
      s = (char *)((void *)0);
      if (sizeof(fp_num) == sizeof(float )) {
        tmp___30 = __isnanf((float )fp_num);
      } else {
        if (sizeof(fp_num) == sizeof(double )) {
          tmp___30 = __isnan(fp_num);
        } else {
          tmp___30 = __isnanl((long double )fp_num);
        }
      }
      if (tmp___30) {
        s = (char *)"nan";
        s_len = 3;
      }
      if (! s) {
        if (sizeof(fp_num) == sizeof(float )) {
          tmp___37 = __isinff((float )fp_num);
        } else {
          if (sizeof(fp_num) == sizeof(double )) {
            tmp___37 = __isinf(fp_num);
          } else {
            tmp___37 = __isinfl((long double )fp_num);
          }
        }
        if (tmp___37) {
          s = (char *)"inf";
          s_len = 3;
        } else {
          goto _L___3;
        }
      } else {
        _L___3: ;
      }
      if (! s) {
        if ((int )adjust_precision == 0) {
          tmp___40 = 6;
        } else {
          tmp___40 = precision;
        }
        s = conv_fp((char )(*fmt), fp_num, alternate_form, tmp___40, & is_negative,
                    & num_buf[1], & s_len);
        if (is_negative) {
          prefix_char = (char )'-';
        } else {
          if (print_sign) {
            prefix_char = (char )'+';
          } else {
            if (print_blank) {
              prefix_char = (char )' ';
            }
          }
        }
      }
      break;
      case 103: ;
      case 71: ;
      if ((int )adjust_precision == 0) {
        precision = 6;
      } else {
        if (precision == 0) {
          precision = 1;
        }
      }
      tmp___41 = __builtin_va_arg(ap, double );
      s = apr_gcvt(tmp___41, precision, & num_buf[1], alternate_form);
      if ((int )(*s) == 45) {
        tmp___42 = s;
        s ++;
        prefix_char = (*tmp___42);
      } else {
        if (print_sign) {
          prefix_char = (char )'+';
        } else {
          if (print_blank) {
            prefix_char = (char )' ';
          }
        }
      }
      s_len = (int )strlen((char const   *)s);
      if (alternate_form) {
        q = strchr((char const   *)s, '.');
        if ((unsigned int )q == (unsigned int )((void *)0)) {
          tmp___43 = s_len;
          s_len ++;
          (*(s + tmp___43)) = (char )'.';
          (*(s + s_len)) = (char )'\000';
        } else {
          goto _L___4;
        }
      } else {
        _L___4: ;
      }
      if ((int const   )(*fmt) == 71) {
        q = strchr((char const   *)s, 'e');
        if ((unsigned int )q != (unsigned int )((void *)0)) {
          (*q) = (char )'E';
        } else {
          goto _L___5;
        }
      } else {
        _L___5: ;
      }
      break;
      case 99: 
      tmp___44 = __builtin_va_arg(ap, int );
      char_buf[0] = (char )tmp___44;
      s = char_buf;
      s_len = 1;
      pad_char = (char )' ';
      break;
      case 37: 
      char_buf[0] = (char )'%';
      s = char_buf;
      s_len = 1;
      pad_char = (char )' ';
      break;
      case 110: ;
      if ((int )var_type == 0) {
        tmp___45 = __builtin_va_arg(ap, widest_int *);
        (*tmp___45) = (long long )cc;
      } else {
        if ((int )var_type == 1) {
          tmp___46 = __builtin_va_arg(ap, long *);
          (*tmp___46) = (long )cc;
        } else {
          if ((int )var_type == 2) {
            tmp___47 = __builtin_va_arg(ap, short *);
            (*tmp___47) = (short )cc;
          } else {
            tmp___48 = __builtin_va_arg(ap, int *);
            (*tmp___48) = cc;
          }
        }
      }
      print_something = (enum __anonenum_boolean_e_61 )0;
      break;
      case 112: 
      fmt ++;
      switch ((int )(*fmt)) {
      case 112: ;
      if (sizeof(void *) <= sizeof(u_wide_int )) {
        tmp___49 = __builtin_va_arg(ap, void *);
        ui_num = (unsigned long )tmp___49;
        s = conv_p2(ui_num, 4, (char )'x', & num_buf[512], & s_len);
      } else {
        s = (char *)"%p";
        s_len = 2;
        prefix_char = (char )'\000';
      }
      pad_char = (char )' ';
      break;
      case 73: 
      sa = __builtin_va_arg(ap, apr_sockaddr_t *);
      if ((unsigned int )sa != (unsigned int )((void *)0)) {
        s = conv_apr_sockaddr(sa, & num_buf[512], & s_len);
        if (adjust_precision) {
          if (precision < s_len) {
            s_len = precision;
          } else {
            goto _L___6;
          }
        } else {
          _L___6: ;
        }
      } else {
        s = (char *)"(null)";
        s_len = 6;
      }
      pad_char = (char )' ';
      break;
      case 65: 
      ia = __builtin_va_arg(ap, struct in_addr *);
      if ((unsigned int )ia != (unsigned int )((void *)0)) {
        s = conv_in_addr(ia, & num_buf[512], & s_len);
        if (adjust_precision) {
          if (precision < s_len) {
            s_len = precision;
          } else {
            goto _L___7;
          }
        } else {
          _L___7: ;
        }
      } else {
        s = (char *)"(null)";
        s_len = 6;
      }
      pad_char = (char )' ';
      break;
      case 0: ;
      continue;
      default: 
      s = (char *)"bogus %p";
      s_len = 8;
      prefix_char = (char )'\000';
      break;
      }
      break;
      case 0: ;
      continue;
      default: 
      char_buf[0] = (char )'%';
      char_buf[1] = (char )(*fmt);
      s = char_buf;
      s_len = 2;
      pad_char = (char )' ';
      break;
      }
      if ((int )prefix_char != 0) {
        if ((unsigned int )s != (unsigned int )"(null)") {
          if ((unsigned int )s != (unsigned int )(char_buf)) {
            s --;
            (*s) = prefix_char;
            s_len ++;
          } else {
            goto _L___9;
          }
        } else {
          goto _L___9;
        }
      } else {
        _L___9: ;
      }
      if (adjust_width) {
        if ((int )adjust == 1) {
          if (min_width > s_len) {
            if ((int )pad_char == 48) {
              if ((int )prefix_char != 0) {
                if (sp) {
                  if ((unsigned int )sp >= (unsigned int )bep) {
                    vbuff->curpos = sp;
                    tmp___50 = ((*flush_func))(vbuff);
                    if (tmp___50) {
                      return (-1);
                    }
                    sp = vbuff->curpos;
                    bep = vbuff->endpos;
                  }
                  tmp___51 = sp;
                  sp ++;
                  (*tmp___51) = (*s);
                }
                cc ++;
                s ++;
                s_len --;
                min_width --;
              } else {
                goto _L___10;
              }
            } else {
              _L___10: ;
            }
            while (1) {
              if (sp) {
                if ((unsigned int )sp >= (unsigned int )bep) {
                  vbuff->curpos = sp;
                  tmp___52 = ((*flush_func))(vbuff);
                  if (tmp___52) {
                    return (-1);
                  }
                  sp = vbuff->curpos;
                  bep = vbuff->endpos;
                }
                tmp___53 = sp;
                sp ++;
                (*tmp___53) = pad_char;
              }
              cc ++;
              min_width --;
              if (! (min_width > s_len)) {
                break;
              }
            }
          } else {
            goto _L___12;
          }
        } else {
          goto _L___12;
        }
      } else {
        _L___12: ;
      }
      if ((int )print_something == 1) {
        i = s_len;
        while (i != 0) {
          if (sp) {
            if ((unsigned int )sp >= (unsigned int )bep) {
              vbuff->curpos = sp;
              tmp___54 = ((*flush_func))(vbuff);
              if (tmp___54) {
                return (-1);
              }
              sp = vbuff->curpos;
              bep = vbuff->endpos;
            }
            tmp___55 = sp;
            sp ++;
            (*tmp___55) = (*s);
          }
          cc ++;
          s ++;
          i --;
        }
      }
      if (adjust_width) {
        if ((int )adjust == 0) {
          if (min_width > s_len) {
            while (1) {
              if (sp) {
                if ((unsigned int )sp >= (unsigned int )bep) {
                  vbuff->curpos = sp;
                  tmp___56 = ((*flush_func))(vbuff);
                  if (tmp___56) {
                    return (-1);
                  }
                  sp = vbuff->curpos;
                  bep = vbuff->endpos;
                }
                tmp___57 = sp;
                sp ++;
                (*tmp___57) = pad_char;
              }
              cc ++;
              min_width --;
              if (! (min_width > s_len)) {
                break;
              }
            }
          } else {
            goto _L___14;
          }
        } else {
          goto _L___14;
        }
      } else {
        _L___14: ;
      }
    }
    fmt ++;
  }
  vbuff->curpos = sp;
  return (cc);
}
}
static int snprintf_flush(apr_vformatter_buff_t *vbuff ) 
{ 

  {
  return (-1);
}
}
int ( /* format attribute */  apr_snprintf)(char *buf , apr_size_t len , char const   *format 
                                            , ...) 
{ int cc ;
  va_list ap ;
  apr_vformatter_buff_t vbuff ;
  int tmp ;

  {
  if (len == 0U) {
    vbuff.curpos = (char *)((void *)0);
    vbuff.endpos = (char *)((void *)0);
  } else {
    vbuff.curpos = buf;
    vbuff.endpos = (buf + len) - 1;
  }
  __builtin_stdarg_start(ap, format);
  cc = apr_vformatter(& snprintf_flush, & vbuff, format, ap);
  __builtin_va_end(ap);
  if (len != 0U) {
    (*(vbuff.curpos)) = (char )'\000';
  }
  if (cc == -1) {
    tmp = (int )len;
  } else {
    tmp = cc;
  }
  return (tmp);
}
}
int apr_vsnprintf(char *buf , apr_size_t len , char const   *format , va_list ap ) 
{ int cc ;
  apr_vformatter_buff_t vbuff ;
  int tmp ;

  {
  if (len == 0U) {
    vbuff.curpos = (char *)((void *)0);
    vbuff.endpos = (char *)((void *)0);
  } else {
    vbuff.curpos = buf;
    vbuff.endpos = (buf + len) - 1;
  }
  cc = apr_vformatter(& snprintf_flush, & vbuff, format, ap);
  if (len != 0U) {
    (*(vbuff.curpos)) = (char )'\000';
  }
  if (cc == -1) {
    tmp = (int )len;
  } else {
    tmp = cc;
  }
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-DNCgLpJJ.i","-g -pthread")
extern long long strtoll(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                         int __base ) ;
char *apr_pstrdup(apr_pool_t *a , char const   *s ) 
{ char *res ;
  apr_size_t len ;
  size_t tmp ;

  {
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  }
  tmp = strlen(s);
  len = tmp + 1U;
  res = (char *)apr_palloc(a, len);
  memcpy((void * __restrict  )res, (void const   * __restrict  )s, len);
  return (res);
}
}
char *apr_pstrndup(apr_pool_t *a , char const   *s , apr_size_t n ) 
{ char *res ;
  char const   *end ;

  {
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  }
  end = (char const   *)memchr((void const   *)s, '\000', n);
  if ((unsigned int )end != (unsigned int )((void *)0)) {
    n = (unsigned int )(end - s);
  }
  res = (char *)apr_palloc(a, n + 1U);
  memcpy((void * __restrict  )res, (void const   * __restrict  )s, n);
  (*(res + n)) = (char )'\000';
  return (res);
}
}
char *apr_pstrmemdup(apr_pool_t *a , char const   *s , apr_size_t n ) 
{ char *res ;

  {
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  }
  res = (char *)apr_palloc(a, n + 1U);
  memcpy((void * __restrict  )res, (void const   * __restrict  )s, n);
  (*(res + n)) = (char )'\000';
  return (res);
}
}
void *apr_pmemdup(apr_pool_t *a , void const   *m , apr_size_t n ) 
{ void *res ;

  {
  if ((unsigned int )m == (unsigned int )((void *)0)) {
    return ((void *)0);
  }
  res = apr_palloc(a, n);
  memcpy((void * __restrict  )res, (void const   * __restrict  )m, n);
  return (res);
}
}
char *apr_pstrcat(apr_pool_t *a  , ...) 
{ char *cp ;
  char *argp ;
  char *res ;
  apr_size_t saved_lengths[6] ;
  int nargs ;
  apr_size_t len ;
  va_list adummy ;
  apr_size_t cplen ;
  apr_size_t tmp ;
  int tmp___0 ;
  int tmp___2 ;

  {
  nargs = 0;
  len = 0U;
  __builtin_stdarg_start(adummy, a);
  while (1) {
    cp = __builtin_va_arg(adummy, char *);
    if (! ((unsigned int )cp != (unsigned int )((void *)0))) {
      break;
    }
    tmp = strlen((char const   *)cp);
    cplen = tmp;
    if (nargs < 6) {
      tmp___0 = nargs;
      nargs ++;
      saved_lengths[tmp___0] = cplen;
    }
    len += cplen;
  }
  __builtin_va_end(adummy);
  res = (char *)apr_palloc(a, len + 1U);
  cp = res;
  __builtin_stdarg_start(adummy, a);
  nargs = 0;
  while (1) {
    argp = __builtin_va_arg(adummy, char *);
    if (! ((unsigned int )argp != (unsigned int )((void *)0))) {
      break;
    }
    if (nargs < 6) {
      tmp___2 = nargs;
      nargs ++;
      len = saved_lengths[tmp___2];
    } else {
      len = strlen((char const   *)argp);
    }
    memcpy((void * __restrict  )cp, (void const   * __restrict  )argp, len);
    cp += len;
  }
  __builtin_va_end(adummy);
  (*cp) = (char )'\000';
  return (res);
}
}
char *apr_pstrcatv(apr_pool_t *a , struct iovec  const  *vec , apr_size_t nvec , apr_size_t *nbytes ) 
{ apr_size_t i ;
  apr_size_t len ;
  struct iovec  const  *src ;
  char *res ;
  char *dst ;

  {
  len = 0U;
  src = vec;
  i = nvec;
  while (i) {
    len += src->iov_len;
    src ++;
    i --;
  }
  if (nbytes) {
    (*nbytes) = len;
  }
  res = (char *)apr_palloc(a, len + 1U);
  src = vec;
  dst = res;
  i = nvec;
  while (i) {
    memcpy((void * __restrict  )dst, (void const   * __restrict  )src->iov_base, src->iov_len);
    dst += src->iov_len;
    src ++;
    i --;
  }
  (*dst) = (char )'\000';
  return (res);
}
}
apr_int64_t apr_strtoi64(char const   *nptr , char **endptr , int base ) 
{ apr_int64_t tmp ;

  {
  tmp = strtoll((char const   * __restrict  )nptr, (char ** __restrict  )endptr, base);
  return (tmp);
}
}
apr_int64_t apr_atoi64(char const   *buf ) 
{ apr_int64_t tmp ;

  {
  tmp = apr_strtoi64(buf, (char **)((void *)0), 10);
  return (tmp);
}
}
char *apr_itoa(apr_pool_t *p , int n ) 
{ int BUFFER_SIZE ;
  char *buf ;
  char *tmp ;
  char *start ;
  int negative ;

  {
  BUFFER_SIZE = (int )(sizeof(int ) * 3U + 2U);
  tmp = (char *)apr_palloc(p, (unsigned int )BUFFER_SIZE);
  buf = tmp;
  start = (buf + BUFFER_SIZE) - 1;
  if (n < 0) {
    negative = 1;
    n = - n;
  } else {
    negative = 0;
  }
  (*start) = (char)0;
  while (1) {
    start --;
    (*start) = (char )(48 + n % 10);
    n /= 10;
    if (! n) {
      break;
    }
  }
  if (negative) {
    start --;
    (*start) = (char )'-';
  }
  return (start);
}
}
char *apr_ltoa(apr_pool_t *p , long n ) 
{ int BUFFER_SIZE ;
  char *buf ;
  char *tmp ;
  char *start ;
  int negative ;

  {
  BUFFER_SIZE = (int )(sizeof(long ) * 3U + 2U);
  tmp = (char *)apr_palloc(p, (unsigned int )BUFFER_SIZE);
  buf = tmp;
  start = (buf + BUFFER_SIZE) - 1;
  if (n < 0L) {
    negative = 1;
    n = - n;
  } else {
    negative = 0;
  }
  (*start) = (char)0;
  while (1) {
    start --;
    (*start) = (char )(48L + n % 10L);
    n /= 10L;
    if (! n) {
      break;
    }
  }
  if (negative) {
    start --;
    (*start) = (char )'-';
  }
  return (start);
}
}
char *apr_off_t_toa(apr_pool_t *p , apr_off_t n ) 
{ int BUFFER_SIZE ;
  char *buf ;
  char *tmp ;
  char *start ;
  int negative ;

  {
  BUFFER_SIZE = (int )(sizeof(apr_off_t ) * 3U + 2U);
  tmp = (char *)apr_palloc(p, (unsigned int )BUFFER_SIZE);
  buf = tmp;
  start = (buf + BUFFER_SIZE) - 1;
  if (n < 0L) {
    negative = 1;
    n = - n;
  } else {
    negative = 0;
  }
  (*start) = (char)0;
  while (1) {
    start --;
    (*start) = (char )(48 + (int )((char )(n % 10L)));
    n /= 10L;
    if (! n) {
      break;
    }
  }
  if (negative) {
    start --;
    (*start) = (char )'-';
  }
  return (start);
}
}
char *apr_strfsize(apr_off_t size , char *buf ) 
{ char ord[7] ;
  char const   *o ;
  int remain ;
  char *tmp ;

  {
  ord[0] = (char )'K';
  ord[1] = (char )'M';
  ord[2] = (char )'G';
  ord[3] = (char )'T';
  ord[4] = (char )'P';
  ord[5] = (char )'E';
  ord[6] = (char )'\000';
  o = (char const   *)(ord);
  if (size < 0L) {
    tmp = strcpy((char * __restrict  )buf, (char const   * __restrict  )"  - ");
    return (tmp);
  }
  if (size < 973L) {
    sprintf((char * __restrict  )buf, (char const   * __restrict  )"%3d ", (int )size);
    return (buf);
  }
  while (1) {
    remain = (int )(size & 1023L);
    size >>= 10;
    if (size >= 973L) {
      o ++;
      goto __Cont;
    }
    if (size < 9L) {
      goto _L;
    } else {
      if (size == 9L) {
        if (remain < 973) {
          _L: 
          remain = (remain * 5 + 256) / 512;
          if (remain >= 10) {
            size ++;
            remain = 0;
          }
          sprintf((char * __restrict  )buf, (char const   * __restrict  )"%d.%d%c",
                  (int )size, remain, (*o));
          return (buf);
        } else {
          goto _L___0;
        }
      } else {
        _L___0: ;
      }
    }
    if (remain >= 512) {
      size ++;
    }
    sprintf((char * __restrict  )buf, (char const   * __restrict  )"%3d%c", (int )size,
            (*o));
    return (buf);
    __Cont: ;
  }
  return ((char *)0);
}
}
#pragma merger(0,"/tmp/cil-h8nOJtsN.i","-g -pthread")
static int compare_right(char const   *a , char const   *b ) 
{ int bias ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  bias = 0;
  while (1) {
    tmp___1 = __ctype_b_loc();
    if ((int const   )(*((*tmp___1) + (int )((unsigned char )(*a)))) & 2048) {
      _L___0: 
      tmp___0 = __ctype_b_loc();
      if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*a)))) & 2048) {
        tmp = __ctype_b_loc();
        if ((int const   )(*((*tmp) + (int )((unsigned char )(*b)))) & 2048) {
          if ((int const   )(*a) < (int const   )(*b)) {
            if (! bias) {
              bias = -1;
            }
          } else {
            if ((int const   )(*a) > (int const   )(*b)) {
              if (! bias) {
                bias = 1;
              }
            } else {
              if (! (*a)) {
                if (! (*b)) {
                  return (bias);
                } else {
                  goto _L;
                }
              } else {
                _L: ;
              }
            }
          }
        } else {
          return (1);
        }
      } else {
        return (-1);
      }
    } else {
      tmp___2 = __ctype_b_loc();
      if ((int const   )(*((*tmp___2) + (int )((unsigned char )(*b)))) & 2048) {
        goto _L___0;
      } else {
        return (bias);
      }
    }
    a ++;
    b ++;
  }
  return (0);
}
}
static int compare_left(char const   *a , char const   *b ) 
{ unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  while (1) {
    tmp___1 = __ctype_b_loc();
    if ((int const   )(*((*tmp___1) + (int )((unsigned char )(*a)))) & 2048) {
      _L: 
      tmp___0 = __ctype_b_loc();
      if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*a)))) & 2048) {
        tmp = __ctype_b_loc();
        if ((int const   )(*((*tmp) + (int )((unsigned char )(*b)))) & 2048) {
          if ((int const   )(*a) < (int const   )(*b)) {
            return (-1);
          } else {
            if ((int const   )(*a) > (int const   )(*b)) {
              return (1);
            }
          }
        } else {
          return (1);
        }
      } else {
        return (-1);
      }
    } else {
      tmp___2 = __ctype_b_loc();
      if ((int const   )(*((*tmp___2) + (int )((unsigned char )(*b)))) & 2048) {
        goto _L;
      } else {
        return (0);
      }
    }
    a ++;
    b ++;
  }
  return (0);
}
}
static int strnatcmp0(char const   *a , char const   *b , int fold_case ) 
{ int ai ;
  int bi ;
  char ca ;
  char cb ;
  int fractional ;
  int result ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  bi = 0;
  ai = bi;
  while (1) {
    ca = (char )(*(a + ai));
    cb = (char )(*(b + bi));
    while (1) {
      tmp = __ctype_b_loc();
      if (! ((int const   )(*((*tmp) + (int )((unsigned char )ca))) & 8192)) {
        break;
      }
      ai ++;
      ca = (char )(*(a + ai));
    }
    while (1) {
      tmp___0 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___0) + (int )((unsigned char )cb))) & 8192)) {
        break;
      }
      bi ++;
      cb = (char )(*(b + bi));
    }
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + (int )((unsigned char )ca))) & 2048) {
      tmp___3 = __ctype_b_loc();
      if ((int const   )(*((*tmp___3) + (int )((unsigned char )cb))) & 2048) {
        if ((int )ca == 48) {
          goto _L;
        } else {
          if ((int )cb == 48) {
            _L: 
            tmp___1 = 1;
          } else {
            tmp___1 = 0;
          }
        }
        fractional = tmp___1;
        if (fractional) {
          result = compare_left(a + ai, b + bi);
          if (result != 0) {
            return (result);
          }
        } else {
          result = compare_right(a + ai, b + bi);
          if (result != 0) {
            return (result);
          }
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
    if (! ca) {
      if (! cb) {
        return (0);
      } else {
        goto _L___1;
      }
    } else {
      _L___1: ;
    }
    if (fold_case) {
      ca = (char )toupper((int )((unsigned char )ca));
      cb = (char )toupper((int )((unsigned char )cb));
    }
    if ((int )ca < (int )cb) {
      return (-1);
    } else {
      if ((int )ca > (int )cb) {
        return (1);
      }
    }
    ai ++;
    bi ++;
  }
  return (0);
}
}
int apr_strnatcmp(char const   *a , char const   *b ) 
{ int tmp ;

  {
  tmp = strnatcmp0(a, b, 0);
  return (tmp);
}
}
int apr_strnatcasecmp(char const   *a , char const   *b ) 
{ int tmp ;

  {
  tmp = strnatcmp0(a, b, 1);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-2eAApWEn.i","-g -pthread")
char *apr_strtok(char *str , char const   *sep , char **last ) 
{ char *token ;
  char *tmp ;
  char *tmp___0 ;

  {
  if (! str) {
    str = (*last);
  }
  while (1) {
    if ((*str)) {
      tmp = strchr(sep, (int )(*str));
      if (! tmp) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
    str ++;
  }
  if (! (*str)) {
    return ((char *)((void *)0));
  }
  token = str;
  (*last) = token + 1;
  while (1) {
    if ((*((*last)))) {
      tmp___0 = strchr(sep, (int )(*((*last))));
      if (tmp___0) {
        goto _L___0;
      }
    } else {
      _L___0: 
      break;
    }
    (*last) ++;
  }
  if ((*((*last)))) {
    (*((*last))) = (char )'\000';
    (*last) ++;
  }
  return (token);
}
}
#pragma merger(0,"/tmp/cil-K4J5f6Zp.i","-g -pthread")
extern char *getpass(char const   *__prompt ) ;
apr_status_t apr_password_get(char const   *prompt , char *pwbuf , apr_size_t *bufsiz ) 
{ char *pw_got ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  tmp = getpass(prompt);
  pw_got = tmp;
  if (! pw_got) {
    return (22);
  }
  apr_cpystrn(pwbuf, (char const   *)pw_got, (*bufsiz));
  tmp___0 = strlen((char const   *)pw_got);
  memset((void *)pw_got, 0, tmp___0);
  tmp___1 = strlen((char const   *)pw_got);
  if (tmp___1 >= (*bufsiz)) {
    return (36);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-7pW8INx2.i","-g -pthread")
static apr_hash_entry_t **alloc_array(apr_hash_t *ht , unsigned int max ) 
{ void *tmp ;
  apr_hash_entry_t **tmp___0 ;

  {
  tmp = apr_palloc(ht->pool, sizeof((*(ht->array))) * (max + 1U));
  tmp___0 = (apr_hash_entry_t **)memset(tmp, 0, sizeof((*(ht->array))) * (max + 1U));
  return (tmp___0);
}
}
apr_hash_t *apr_hash_make(apr_pool_t *pool ) 
{ apr_hash_t *ht ;

  {
  ht = (apr_hash_t *)apr_palloc(pool, sizeof(apr_hash_t ));
  ht->pool = pool;
  ht->count = 0U;
  ht->max = 15U;
  ht->array = alloc_array(ht, ht->max);
  return (ht);
}
}
apr_hash_index_t *apr_hash_next(apr_hash_index_t *hi ) 
{ unsigned int tmp ;

  {
  hi->this = hi->next;
  while (! hi->this) {
    if (hi->index > (hi->ht)->max) {
      return ((apr_hash_index_t *)((void *)0));
    }
    tmp = hi->index;
    hi->index ++;
    hi->this = (*((hi->ht)->array + tmp));
  }
  hi->next = (hi->this)->next;
  return (hi);
}
}
apr_hash_index_t *apr_hash_first(apr_pool_t *p , apr_hash_t *ht ) 
{ apr_hash_index_t *hi ;
  apr_hash_index_t *tmp ;

  {
  if (p) {
    hi = (apr_hash_index_t *)apr_palloc(p, sizeof((*hi)));
  } else {
    hi = & ht->iterator;
  }
  hi->ht = ht;
  hi->index = 0U;
  hi->this = (apr_hash_entry_t *)((void *)0);
  hi->next = (apr_hash_entry_t *)((void *)0);
  tmp = apr_hash_next(hi);
  return (tmp);
}
}
void apr_hash_this(apr_hash_index_t *hi , void const   **key , apr_ssize_t *klen ,
                   void **val ) 
{ 

  {
  if (key) {
    (*key) = (hi->this)->key;
  }
  if (klen) {
    (*klen) = (hi->this)->klen;
  }
  if (val) {
    (*val) = (void *)(hi->this)->val;
  }
  return;
}
}
static void expand_array(apr_hash_t *ht ) 
{ apr_hash_index_t *hi ;
  apr_hash_entry_t **new_array ;
  unsigned int new_max ;
  unsigned int i ;

  {
  new_max = ht->max * 2U + 1U;
  new_array = alloc_array(ht, new_max);
  hi = apr_hash_first((apr_pool_t *)((void *)0), ht);
  while (hi) {
    i = (hi->this)->hash & new_max;
    (hi->this)->next = (*(new_array + i));
    (*(new_array + i)) = hi->this;
    hi = apr_hash_next(hi);
  }
  ht->array = new_array;
  ht->max = new_max;
  return;
}
}
static apr_hash_entry_t **find_entry(apr_hash_t *ht , void const   *key , apr_ssize_t klen ,
                                     void const   *val ) 
{ apr_hash_entry_t **hep ;
  apr_hash_entry_t *he ;
  unsigned char const   *p ;
  unsigned int hash ;
  apr_ssize_t i ;
  int tmp ;

  {
  hash = 0U;
  if (klen == -1) {
    p = (unsigned char const   *)key;
    while ((*p)) {
      hash = hash * 33U + (unsigned int )(*p);
      p ++;
    }
    klen = p - (unsigned char const   *)key;
  } else {
    p = (unsigned char const   *)key;
    i = klen;
    while (i) {
      hash = hash * 33U + (unsigned int )(*p);
      i --;
      p ++;
    }
  }
  hep = ht->array + (hash & ht->max);
  he = (*hep);
  while (he) {
    if (he->hash == hash) {
      if (he->klen == klen) {
        tmp = memcmp(he->key, key, (unsigned int )klen);
        if (tmp == 0) {
          break;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
    hep = & he->next;
    he = (*hep);
  }
  if (he) {
    goto _L___1;
  } else {
    if (! val) {
      _L___1: 
      return (hep);
    }
  }
  he = (apr_hash_entry_t *)apr_palloc(ht->pool, sizeof((*he)));
  he->next = (apr_hash_entry_t *)((void *)0);
  he->hash = hash;
  he->key = key;
  he->klen = klen;
  he->val = val;
  (*hep) = he;
  ht->count ++;
  return (hep);
}
}
apr_hash_t *apr_hash_copy(apr_pool_t *pool , apr_hash_t const   *orig ) 
{ apr_hash_t *ht ;
  apr_hash_entry_t *new_vals ;
  unsigned int i ;
  unsigned int j ;
  apr_hash_entry_t **new_entry ;
  apr_hash_entry_t *orig_entry ;
  unsigned int tmp ;

  {
  ht = (apr_hash_t *)apr_palloc(pool, (sizeof(apr_hash_t ) + sizeof((*(ht->array))) *
                                                             (orig->max + 1U)) + sizeof(apr_hash_entry_t ) *
                                                                                 orig->count);
  ht->pool = pool;
  ht->count = orig->count;
  ht->max = orig->max;
  ht->array = (apr_hash_entry_t **)((char *)ht + sizeof(apr_hash_t ));
  new_vals = (apr_hash_entry_t *)(((char *)ht + sizeof(apr_hash_t )) + sizeof((*(ht->array))) *
                                                                       (orig->max +
                                                                        1U));
  j = 0U;
  i = 0U;
  while (i <= ht->max) {
    new_entry = ht->array + i;
    orig_entry = (*(orig->array + i));
    while (orig_entry) {
      tmp = j;
      j ++;
      (*new_entry) = new_vals + tmp;
      ((*new_entry))->hash = orig_entry->hash;
      ((*new_entry))->key = orig_entry->key;
      ((*new_entry))->klen = orig_entry->klen;
      ((*new_entry))->val = orig_entry->val;
      new_entry = & ((*new_entry))->next;
      orig_entry = orig_entry->next;
    }
    (*new_entry) = (apr_hash_entry_t *)((void *)0);
    i ++;
  }
  return (ht);
}
}
void *apr_hash_get(apr_hash_t *ht , void const   *key , apr_ssize_t klen ) 
{ apr_hash_entry_t *he ;
  apr_hash_entry_t **tmp ;

  {
  tmp = find_entry(ht, key, klen, (void const   *)((void *)0));
  he = (*tmp);
  if (he) {
    return ((void *)he->val);
  } else {
    return ((void *)0);
  }
}
}
void apr_hash_set(apr_hash_t *ht , void const   *key , apr_ssize_t klen , void const   *val ) 
{ apr_hash_entry_t **hep ;

  {
  hep = find_entry(ht, key, klen, val);
  if ((*hep)) {
    if (! val) {
      (*hep) = ((*hep))->next;
      ht->count --;
    } else {
      ((*hep))->val = val;
      if (ht->count > ht->max) {
        expand_array(ht);
      }
    }
  }
  return;
}
}
unsigned int apr_hash_count(apr_hash_t *ht ) 
{ 

  {
  return (ht->count);
}
}
apr_hash_t *apr_hash_overlay(apr_pool_t *p , apr_hash_t const   *overlay , apr_hash_t const   *base ) 
{ apr_hash_t *tmp ;

  {
  tmp = apr_hash_merge(p, overlay, base, (void *(*)(apr_pool_t *p , void const   *key ,
                                                    apr_ssize_t klen , void const   *h1_val ,
                                                    void const   *h2_val , void const   *data ))((void *)0),
                       (void const   *)((void *)0));
  return (tmp);
}
}
apr_hash_t *apr_hash_merge(apr_pool_t *p , apr_hash_t const   *overlay , apr_hash_t const   *base ,
                           void *(*merger)(apr_pool_t *p , void const   *key , apr_ssize_t klen ,
                                           void const   *h1_val , void const   *h2_val ,
                                           void const   *data ) , void const   *data ) 
{ apr_hash_t *res ;
  apr_hash_entry_t *new_vals ;
  apr_hash_entry_t *iter ;
  apr_hash_entry_t *ent ;
  unsigned int i ;
  unsigned int j ;
  unsigned int k ;
  int tmp ;

  {
  new_vals = (apr_hash_entry_t *)((void *)0);
  res = (apr_hash_t *)apr_palloc(p, sizeof(apr_hash_t ));
  res->pool = p;
  res->count = base->count;
  if (overlay->max > base->max) {
    res->max = overlay->max;
  } else {
    res->max = base->max;
  }
  if (base->count + overlay->count > res->max) {
    res->max = res->max * 2U + 1U;
  }
  res->array = alloc_array(res, res->max);
  if (base->count + overlay->count) {
    new_vals = (apr_hash_entry_t *)apr_palloc(p, sizeof(apr_hash_entry_t ) * (base->count +
                                                                              overlay->count));
  }
  j = 0U;
  k = 0U;
  while (k <= base->max) {
    iter = (*(base->array + k));
    while (iter) {
      i = iter->hash & res->max;
      (new_vals + j)->klen = iter->klen;
      (new_vals + j)->key = iter->key;
      (new_vals + j)->val = iter->val;
      (new_vals + j)->hash = iter->hash;
      (new_vals + j)->next = (*(res->array + i));
      (*(res->array + i)) = new_vals + j;
      j ++;
      iter = iter->next;
    }
    k ++;
  }
  k = 0U;
  while (k <= overlay->max) {
    iter = (*(overlay->array + k));
    while (iter) {
      i = iter->hash & res->max;
      ent = (*(res->array + i));
      while (ent) {
        if (ent->klen == iter->klen) {
          tmp = memcmp(ent->key, iter->key, (unsigned int )iter->klen);
          if (tmp == 0) {
            if (merger) {
              ent->val = ((*merger))(p, iter->key, iter->klen, iter->val, ent->val,
                                     data);
            } else {
              ent->val = iter->val;
            }
            break;
          } else {
            goto _L;
          }
        } else {
          _L: ;
        }
        ent = ent->next;
      }
      if (! ent) {
        (new_vals + j)->klen = iter->klen;
        (new_vals + j)->key = iter->key;
        (new_vals + j)->val = iter->val;
        (new_vals + j)->hash = iter->hash;
        (new_vals + j)->next = (*(res->array + i));
        (*(res->array + i)) = new_vals + j;
        res->count ++;
        j ++;
      }
      iter = iter->next;
    }
    k ++;
  }
  return (res);
}
}
apr_pool_t *apr_hash_pool_get(apr_hash_t const   *ob ) 
{ 

  {
  return (ob->pool);
}
}
#pragma merger(0,"/tmp/cil-SE8Ws5DI.i","-g -pthread")
static void make_array_core(apr_array_header_t *res , apr_pool_t *p , int nelts ,
                            int elt_size , int clear ) 
{ void *tmp ;

  {
  if (nelts < 1) {
    nelts = 1;
  }
  if (clear) {
    tmp = apr_palloc(p, (unsigned int )(nelts * elt_size));
    res->elts = (char *)memset(tmp, 0, (unsigned int )(nelts * elt_size));
  } else {
    res->elts = (char *)apr_palloc(p, (unsigned int )(nelts * elt_size));
  }
  res->pool = p;
  res->elt_size = elt_size;
  res->nelts = 0;
  res->nalloc = nelts;
  return;
}
}
int apr_is_empty_array(apr_array_header_t const   *a ) 
{ int tmp ;

  {
  if ((unsigned int )a == (unsigned int )((void *)0)) {
    goto _L;
  } else {
    if (a->nelts == 0) {
      _L: 
      tmp = 1;
    } else {
      tmp = 0;
    }
  }
  return (tmp);
}
}
apr_array_header_t *apr_array_make(apr_pool_t *p , int nelts , int elt_size ) 
{ apr_array_header_t *res ;

  {
  res = (apr_array_header_t *)apr_palloc(p, sizeof(apr_array_header_t ));
  make_array_core(res, p, nelts, elt_size, 1);
  return (res);
}
}
void *apr_array_pop(apr_array_header_t *arr ) 
{ int tmp ;

  {
  tmp = apr_is_empty_array((apr_array_header_t const   *)arr);
  if (tmp) {
    return ((void *)0);
  }
  arr->nelts = arr->nelts - 1;
  return ((void *)(arr->elts + arr->elt_size * arr->nelts));
}
}
void *apr_array_push(apr_array_header_t *arr ) 
{ int new_size ;
  int tmp ;
  char *new_data ;

  {
  if (arr->nelts == arr->nalloc) {
    if (arr->nalloc <= 0) {
      tmp = 1;
    } else {
      tmp = arr->nalloc * 2;
    }
    new_size = tmp;
    new_data = (char *)apr_palloc(arr->pool, (unsigned int )(arr->elt_size * new_size));
    memcpy((void * __restrict  )new_data, (void const   * __restrict  )arr->elts,
           (unsigned int )(arr->nalloc * arr->elt_size));
    memset((void *)(new_data + arr->nalloc * arr->elt_size), 0, (unsigned int )(arr->elt_size *
                                                                                (new_size -
                                                                                 arr->nalloc)));
    arr->elts = new_data;
    arr->nalloc = new_size;
  }
  arr->nelts = arr->nelts + 1;
  return ((void *)(arr->elts + arr->elt_size * (arr->nelts - 1)));
}
}
static void *apr_array_push_noclear(apr_array_header_t *arr ) 
{ int new_size ;
  int tmp ;
  char *new_data ;

  {
  if (arr->nelts == arr->nalloc) {
    if (arr->nalloc <= 0) {
      tmp = 1;
    } else {
      tmp = arr->nalloc * 2;
    }
    new_size = tmp;
    new_data = (char *)apr_palloc(arr->pool, (unsigned int )(arr->elt_size * new_size));
    memcpy((void * __restrict  )new_data, (void const   * __restrict  )arr->elts,
           (unsigned int )(arr->nalloc * arr->elt_size));
    arr->elts = new_data;
    arr->nalloc = new_size;
  }
  arr->nelts = arr->nelts + 1;
  return ((void *)(arr->elts + arr->elt_size * (arr->nelts - 1)));
}
}
void apr_array_cat(apr_array_header_t *dst , apr_array_header_t const   *src ) 
{ int elt_size ;
  int new_size ;
  int tmp ;
  char *new_data ;
  void *tmp___0 ;

  {
  elt_size = dst->elt_size;
  if (dst->nelts + src->nelts > dst->nalloc) {
    if (dst->nalloc <= 0) {
      tmp = 1;
    } else {
      tmp = dst->nalloc * 2;
    }
    new_size = tmp;
    while (dst->nelts + src->nelts > new_size) {
      new_size *= 2;
    }
    tmp___0 = apr_palloc(dst->pool, (unsigned int )(elt_size * new_size));
    new_data = (char *)memset(tmp___0, 0, (unsigned int )(elt_size * new_size));
    memcpy((void * __restrict  )new_data, (void const   * __restrict  )dst->elts,
           (unsigned int )(dst->nalloc * elt_size));
    dst->elts = new_data;
    dst->nalloc = new_size;
  }
  memcpy((void * __restrict  )(dst->elts + dst->nelts * elt_size), (void const   * __restrict  )src->elts,
         (unsigned int )(elt_size * src->nelts));
  dst->nelts = dst->nelts + src->nelts;
  return;
}
}
apr_array_header_t *apr_array_copy(apr_pool_t *p , apr_array_header_t const   *arr ) 
{ apr_array_header_t *res ;
  apr_array_header_t *tmp ;

  {
  tmp = (apr_array_header_t *)apr_palloc(p, sizeof(apr_array_header_t ));
  res = tmp;
  make_array_core(res, p, arr->nalloc, arr->elt_size, 0);
  memcpy((void * __restrict  )res->elts, (void const   * __restrict  )arr->elts, (unsigned int )(arr->elt_size *
                                                                                                 arr->nelts));
  res->nelts = arr->nelts;
  memset((void *)(res->elts + res->elt_size * res->nelts), 0, (unsigned int )(res->elt_size *
                                                                              (res->nalloc -
                                                                               res->nelts)));
  return (res);
}
}
__inline static void copy_array_hdr_core(apr_array_header_t *res , apr_array_header_t const   *arr ) 
{ 

  {
  res->elts = arr->elts;
  res->elt_size = arr->elt_size;
  res->nelts = arr->nelts;
  res->nalloc = arr->nelts;
  return;
}
}
apr_array_header_t *apr_array_copy_hdr(apr_pool_t *p , apr_array_header_t const   *arr ) 
{ apr_array_header_t *res ;

  {
  res = (apr_array_header_t *)apr_palloc(p, sizeof(apr_array_header_t ));
  res->pool = p;
  copy_array_hdr_core(res, arr);
  return (res);
}
}
apr_array_header_t *apr_array_append(apr_pool_t *p , apr_array_header_t const   *first ,
                                     apr_array_header_t const   *second ) 
{ apr_array_header_t *res ;
  apr_array_header_t *tmp ;

  {
  tmp = apr_array_copy_hdr(p, first);
  res = tmp;
  apr_array_cat(res, second);
  return (res);
}
}
char *apr_array_pstrcat(apr_pool_t *p , apr_array_header_t const   *arr , char sep ) 
{ char *cp ;
  char *res ;
  char **strpp ;
  apr_size_t len ;
  int i ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___3 ;

  {
  if (arr->nelts <= 0) {
    goto _L;
  } else {
    if ((unsigned int )arr->elts == (unsigned int )((void *)0)) {
      _L: 
      tmp = apr_palloc(p, 1U);
      tmp___0 = (char *)memset(tmp, 0, 1U);
      return (tmp___0);
    }
  }
  len = 0U;
  i = 0;
  strpp = (char **)arr->elts;
  while (1) {
    if (strpp) {
      if ((unsigned int )(*strpp) != (unsigned int )((void *)0)) {
        tmp___1 = strlen((char const   *)(*strpp));
        len += tmp___1;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
    i ++;
    if (i >= arr->nelts) {
      break;
    }
    if (sep) {
      len ++;
    }
    strpp ++;
  }
  res = (char *)apr_palloc(p, len + 1U);
  cp = res;
  i = 0;
  strpp = (char **)arr->elts;
  while (1) {
    if (strpp) {
      if ((unsigned int )(*strpp) != (unsigned int )((void *)0)) {
        len = strlen((char const   *)(*strpp));
        memcpy((void * __restrict  )cp, (void const   * __restrict  )(*strpp), len);
        cp += len;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: ;
    }
    i ++;
    if (i >= arr->nelts) {
      break;
    }
    if (sep) {
      tmp___3 = cp;
      cp ++;
      (*tmp___3) = sep;
    }
    strpp ++;
  }
  (*cp) = (char )'\000';
  return (res);
}
}
apr_array_header_t const   *apr_table_elts(apr_table_t const   *t ) 
{ 

  {
  return ((apr_array_header_t const   *)t);
}
}
int apr_is_empty_table(apr_table_t const   *t ) 
{ int tmp ;

  {
  if ((unsigned int )t == (unsigned int )((void *)0)) {
    goto _L;
  } else {
    if (t->a.nelts == 0) {
      _L: 
      tmp = 1;
    } else {
      tmp = 0;
    }
  }
  return (tmp);
}
}
apr_table_t *apr_table_make(apr_pool_t *p , int nelts ) 
{ apr_table_t *t ;
  apr_table_t *tmp ;

  {
  tmp = (apr_table_t *)apr_palloc(p, sizeof(apr_table_t ));
  t = tmp;
  make_array_core(& t->a, p, nelts, (int )sizeof(apr_table_entry_t ), 0);
  t->index_initialized = 0U;
  return (t);
}
}
apr_table_t *apr_table_copy(apr_pool_t *p , apr_table_t const   *t ) 
{ apr_table_t *new ;
  apr_table_t *tmp ;

  {
  tmp = (apr_table_t *)apr_palloc(p, sizeof(apr_table_t ));
  new = tmp;
  make_array_core(& new->a, p, t->a.nalloc, (int )sizeof(apr_table_entry_t ), 0);
  memcpy((void * __restrict  )new->a.elts, (void const   * __restrict  )t->a.elts,
         (unsigned int )t->a.nelts * sizeof(apr_table_entry_t ));
  new->a.nelts = t->a.nelts;
  memcpy((void * __restrict  )(new->index_first), (void const   * __restrict  )(t->index_first),
         sizeof(int ) * 32U);
  memcpy((void * __restrict  )(new->index_last), (void const   * __restrict  )(t->index_last),
         sizeof(int ) * 32U);
  new->index_initialized = t->index_initialized;
  return (new);
}
}
static void table_reindex(apr_table_t *t ) 
{ int i ;
  int hash ;
  apr_table_entry_t *next_elt ;

  {
  next_elt = (apr_table_entry_t *)t->a.elts;
  t->index_initialized = 0U;
  i = 0;
  while (i < t->a.nelts) {
    hash = 31 & (int )(*((unsigned char *)next_elt->key));
    t->index_last[hash] = i;
    if (! (t->index_initialized & (unsigned int )(1 << hash))) {
      t->index_first[hash] = i;
      t->index_initialized |= (unsigned int )(1 << hash);
    }
    i ++;
    next_elt ++;
  }
  return;
}
}
void apr_table_clear(apr_table_t *t ) 
{ 

  {
  t->a.nelts = 0;
  t->index_initialized = 0U;
  return;
}
}
char const   *apr_table_get(apr_table_t const   *t , char const   *key ) 
{ apr_table_entry_t *next_elt ;
  apr_table_entry_t *end_elt ;
  apr_uint32_t checksum ;
  int hash ;
  char const   *k ;
  apr_uint32_t c ;
  int tmp ;

  {
  if ((unsigned int )key == (unsigned int )((void *)0)) {
    return ((char const   *)((void *)0));
  }
  hash = 31 & (int )(*((unsigned char *)key));
  if (! (t->index_initialized & (unsigned int )(1 << hash))) {
    return ((char const   *)((void *)0));
  }
  k = key;
  c = (unsigned int )(*k);
  checksum = c;
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum &= 3755991007U;
  next_elt = (apr_table_entry_t *)t->a.elts + t->index_first[hash];
  end_elt = (apr_table_entry_t *)t->a.elts + t->index_last[hash];
  while ((unsigned int )next_elt <= (unsigned int )end_elt) {
    if (checksum == next_elt->key_checksum) {
      tmp = strcasecmp((char const   *)next_elt->key, key);
      if (tmp) {
        goto _L;
      } else {
        return ((char const   *)next_elt->val);
      }
    } else {
      _L: ;
    }
    next_elt ++;
  }
  return ((char const   *)((void *)0));
}
}
void apr_table_set(apr_table_t *t , char const   *key , char const   *val ) 
{ apr_table_entry_t *next_elt ;
  apr_table_entry_t *end_elt ;
  apr_table_entry_t *table_end ;
  apr_uint32_t checksum ;
  int hash ;
  char const   *k ;
  apr_uint32_t c ;
  int must_reindex ;
  apr_table_entry_t *dst_elt ;
  apr_table_entry_t *tmp ;
  int tmp___0 ;
  apr_table_entry_t *tmp___1 ;
  int tmp___2 ;

  {
  k = key;
  c = (unsigned int )(*k);
  checksum = c;
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum &= 3755991007U;
  hash = 31 & (int )(*((unsigned char *)key));
  if (! (t->index_initialized & (unsigned int )(1 << hash))) {
    t->index_first[hash] = t->a.nelts;
    t->index_initialized |= (unsigned int )(1 << hash);
    goto add_new_elt;
  }
  next_elt = (apr_table_entry_t *)t->a.elts + t->index_first[hash];
  end_elt = (apr_table_entry_t *)t->a.elts + t->index_last[hash];
  table_end = (apr_table_entry_t *)t->a.elts + t->a.nelts;
  while ((unsigned int )next_elt <= (unsigned int )end_elt) {
    if (checksum == next_elt->key_checksum) {
      tmp___2 = strcasecmp((char const   *)next_elt->key, key);
      if (tmp___2) {
        goto _L___0;
      } else {
        must_reindex = 0;
        dst_elt = (apr_table_entry_t *)((void *)0);
        next_elt->val = apr_pstrdup(t->a.pool, val);
        next_elt ++;
        while ((unsigned int )next_elt <= (unsigned int )end_elt) {
          if (checksum == next_elt->key_checksum) {
            tmp___0 = strcasecmp((char const   *)next_elt->key, key);
            if (tmp___0) {
              goto _L;
            } else {
              t->a.nelts = t->a.nelts - 1;
              if (! dst_elt) {
                dst_elt = next_elt;
              }
            }
          } else {
            _L: 
            if (dst_elt) {
              tmp = dst_elt;
              dst_elt ++;
              (*tmp) = (*next_elt);
              must_reindex = 1;
            }
          }
          next_elt ++;
        }
        if (dst_elt) {
          while ((unsigned int )next_elt < (unsigned int )table_end) {
            tmp___1 = dst_elt;
            dst_elt ++;
            (*tmp___1) = (*next_elt);
            next_elt ++;
          }
          must_reindex = 1;
        }
        if (must_reindex) {
          table_reindex(t);
        }
        return;
      }
    } else {
      _L___0: ;
    }
    next_elt ++;
  }
  add_new_elt: 
  t->index_last[hash] = t->a.nelts;
  next_elt = (apr_table_entry_t *)apr_array_push_noclear(& t->a);
  next_elt->key = apr_pstrdup(t->a.pool, key);
  next_elt->val = apr_pstrdup(t->a.pool, val);
  next_elt->key_checksum = checksum;
  return;
}
}
void apr_table_setn(apr_table_t *t , char const   *key , char const   *val ) 
{ apr_table_entry_t *next_elt ;
  apr_table_entry_t *end_elt ;
  apr_table_entry_t *table_end ;
  apr_uint32_t checksum ;
  int hash ;
  char const   *k ;
  apr_uint32_t c ;
  int must_reindex ;
  apr_table_entry_t *dst_elt ;
  apr_table_entry_t *tmp ;
  int tmp___0 ;
  apr_table_entry_t *tmp___1 ;
  int tmp___2 ;

  {
  k = key;
  c = (unsigned int )(*k);
  checksum = c;
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum &= 3755991007U;
  hash = 31 & (int )(*((unsigned char *)key));
  if (! (t->index_initialized & (unsigned int )(1 << hash))) {
    t->index_first[hash] = t->a.nelts;
    t->index_initialized |= (unsigned int )(1 << hash);
    goto add_new_elt;
  }
  next_elt = (apr_table_entry_t *)t->a.elts + t->index_first[hash];
  end_elt = (apr_table_entry_t *)t->a.elts + t->index_last[hash];
  table_end = (apr_table_entry_t *)t->a.elts + t->a.nelts;
  while ((unsigned int )next_elt <= (unsigned int )end_elt) {
    if (checksum == next_elt->key_checksum) {
      tmp___2 = strcasecmp((char const   *)next_elt->key, key);
      if (tmp___2) {
        goto _L___0;
      } else {
        must_reindex = 0;
        dst_elt = (apr_table_entry_t *)((void *)0);
        next_elt->val = (char *)val;
        next_elt ++;
        while ((unsigned int )next_elt <= (unsigned int )end_elt) {
          if (checksum == next_elt->key_checksum) {
            tmp___0 = strcasecmp((char const   *)next_elt->key, key);
            if (tmp___0) {
              goto _L;
            } else {
              t->a.nelts = t->a.nelts - 1;
              if (! dst_elt) {
                dst_elt = next_elt;
              }
            }
          } else {
            _L: 
            if (dst_elt) {
              tmp = dst_elt;
              dst_elt ++;
              (*tmp) = (*next_elt);
              must_reindex = 1;
            }
          }
          next_elt ++;
        }
        if (dst_elt) {
          while ((unsigned int )next_elt < (unsigned int )table_end) {
            tmp___1 = dst_elt;
            dst_elt ++;
            (*tmp___1) = (*next_elt);
            next_elt ++;
          }
          must_reindex = 1;
        }
        if (must_reindex) {
          table_reindex(t);
        }
        return;
      }
    } else {
      _L___0: ;
    }
    next_elt ++;
  }
  add_new_elt: 
  t->index_last[hash] = t->a.nelts;
  next_elt = (apr_table_entry_t *)apr_array_push_noclear(& t->a);
  next_elt->key = (char *)key;
  next_elt->val = (char *)val;
  next_elt->key_checksum = checksum;
  return;
}
}
void apr_table_unset(apr_table_t *t , char const   *key ) 
{ apr_table_entry_t *next_elt ;
  apr_table_entry_t *end_elt ;
  apr_table_entry_t *dst_elt ;
  apr_uint32_t checksum ;
  int hash ;
  int must_reindex ;
  char const   *k ;
  apr_uint32_t c ;
  apr_table_entry_t *table_end ;
  apr_table_entry_t *tmp ;
  int tmp___0 ;
  apr_table_entry_t *tmp___1 ;
  int tmp___2 ;

  {
  hash = 31 & (int )(*((unsigned char *)key));
  if (! (t->index_initialized & (unsigned int )(1 << hash))) {
    return;
  }
  k = key;
  c = (unsigned int )(*k);
  checksum = c;
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum &= 3755991007U;
  next_elt = (apr_table_entry_t *)t->a.elts + t->index_first[hash];
  end_elt = (apr_table_entry_t *)t->a.elts + t->index_last[hash];
  must_reindex = 0;
  while ((unsigned int )next_elt <= (unsigned int )end_elt) {
    if (checksum == next_elt->key_checksum) {
      tmp___2 = strcasecmp((char const   *)next_elt->key, key);
      if (tmp___2) {
        goto _L___0;
      } else {
        table_end = (apr_table_entry_t *)t->a.elts + t->a.nelts;
        t->a.nelts = t->a.nelts - 1;
        dst_elt = next_elt;
        next_elt ++;
        while ((unsigned int )next_elt <= (unsigned int )end_elt) {
          if (checksum == next_elt->key_checksum) {
            tmp___0 = strcasecmp((char const   *)next_elt->key, key);
            if (tmp___0) {
              goto _L;
            } else {
              t->a.nelts = t->a.nelts - 1;
            }
          } else {
            _L: 
            tmp = dst_elt;
            dst_elt ++;
            (*tmp) = (*next_elt);
          }
          next_elt ++;
        }
        while ((unsigned int )next_elt < (unsigned int )table_end) {
          tmp___1 = dst_elt;
          dst_elt ++;
          (*tmp___1) = (*next_elt);
          next_elt ++;
        }
        must_reindex = 1;
        break;
      }
    } else {
      _L___0: ;
    }
    next_elt ++;
  }
  if (must_reindex) {
    table_reindex(t);
  }
  return;
}
}
void apr_table_merge(apr_table_t *t , char const   *key , char const   *val ) 
{ apr_table_entry_t *next_elt ;
  apr_table_entry_t *end_elt ;
  apr_uint32_t checksum ;
  int hash ;
  char const   *k ;
  apr_uint32_t c ;
  int tmp ;

  {
  k = key;
  c = (unsigned int )(*k);
  checksum = c;
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum &= 3755991007U;
  hash = 31 & (int )(*((unsigned char *)key));
  if (! (t->index_initialized & (unsigned int )(1 << hash))) {
    t->index_first[hash] = t->a.nelts;
    t->index_initialized |= (unsigned int )(1 << hash);
    goto add_new_elt;
  }
  next_elt = (apr_table_entry_t *)t->a.elts + t->index_first[hash];
  end_elt = (apr_table_entry_t *)t->a.elts + t->index_last[hash];
  while ((unsigned int )next_elt <= (unsigned int )end_elt) {
    if (checksum == next_elt->key_checksum) {
      tmp = strcasecmp((char const   *)next_elt->key, key);
      if (tmp) {
        goto _L;
      } else {
        next_elt->val = apr_pstrcat(t->a.pool, next_elt->val, ", ", val, (void *)0);
        return;
      }
    } else {
      _L: ;
    }
    next_elt ++;
  }
  add_new_elt: 
  t->index_last[hash] = t->a.nelts;
  next_elt = (apr_table_entry_t *)apr_array_push_noclear(& t->a);
  next_elt->key = apr_pstrdup(t->a.pool, key);
  next_elt->val = apr_pstrdup(t->a.pool, val);
  next_elt->key_checksum = checksum;
  return;
}
}
void apr_table_mergen(apr_table_t *t , char const   *key , char const   *val ) 
{ apr_table_entry_t *next_elt ;
  apr_table_entry_t *end_elt ;
  apr_uint32_t checksum ;
  int hash ;
  char const   *k ;
  apr_uint32_t c ;
  int tmp ;

  {
  k = key;
  c = (unsigned int )(*k);
  checksum = c;
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum &= 3755991007U;
  hash = 31 & (int )(*((unsigned char *)key));
  if (! (t->index_initialized & (unsigned int )(1 << hash))) {
    t->index_first[hash] = t->a.nelts;
    t->index_initialized |= (unsigned int )(1 << hash);
    goto add_new_elt;
  }
  next_elt = (apr_table_entry_t *)t->a.elts + t->index_first[hash];
  end_elt = (apr_table_entry_t *)t->a.elts + t->index_last[hash];
  while ((unsigned int )next_elt <= (unsigned int )end_elt) {
    if (checksum == next_elt->key_checksum) {
      tmp = strcasecmp((char const   *)next_elt->key, key);
      if (tmp) {
        goto _L;
      } else {
        next_elt->val = apr_pstrcat(t->a.pool, next_elt->val, ", ", val, (void *)0);
        return;
      }
    } else {
      _L: ;
    }
    next_elt ++;
  }
  add_new_elt: 
  t->index_last[hash] = t->a.nelts;
  next_elt = (apr_table_entry_t *)apr_array_push_noclear(& t->a);
  next_elt->key = (char *)key;
  next_elt->val = (char *)val;
  next_elt->key_checksum = checksum;
  return;
}
}
void apr_table_add(apr_table_t *t , char const   *key , char const   *val ) 
{ apr_table_entry_t *elts ;
  apr_uint32_t checksum ;
  int hash ;
  char const   *k ;
  apr_uint32_t c ;

  {
  hash = 31 & (int )(*((unsigned char *)key));
  t->index_last[hash] = t->a.nelts;
  if (! (t->index_initialized & (unsigned int )(1 << hash))) {
    t->index_first[hash] = t->a.nelts;
    t->index_initialized |= (unsigned int )(1 << hash);
  }
  k = key;
  c = (unsigned int )(*k);
  checksum = c;
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum &= 3755991007U;
  elts = (apr_table_entry_t *)apr_array_push_noclear(& t->a);
  elts->key = apr_pstrdup(t->a.pool, key);
  elts->val = apr_pstrdup(t->a.pool, val);
  elts->key_checksum = checksum;
  return;
}
}
void apr_table_addn(apr_table_t *t , char const   *key , char const   *val ) 
{ apr_table_entry_t *elts ;
  apr_uint32_t checksum ;
  int hash ;
  char const   *k ;
  apr_uint32_t c ;

  {
  hash = 31 & (int )(*((unsigned char *)key));
  t->index_last[hash] = t->a.nelts;
  if (! (t->index_initialized & (unsigned int )(1 << hash))) {
    t->index_first[hash] = t->a.nelts;
    t->index_initialized |= (unsigned int )(1 << hash);
  }
  k = key;
  c = (unsigned int )(*k);
  checksum = c;
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum <<= 8;
  if (c) {
    k ++;
    c = (unsigned int )(*k);
    checksum |= c;
  }
  checksum &= 3755991007U;
  elts = (apr_table_entry_t *)apr_array_push_noclear(& t->a);
  elts->key = (char *)key;
  elts->val = (char *)val;
  elts->key_checksum = checksum;
  return;
}
}
apr_table_t *apr_table_overlay(apr_pool_t *p , apr_table_t const   *overlay , apr_table_t const   *base ) 
{ apr_table_t *res ;

  {
  res = (apr_table_t *)apr_palloc(p, sizeof(apr_table_t ));
  res->a.pool = p;
  copy_array_hdr_core(& res->a, (apr_array_header_t const   *)(& overlay->a));
  apr_array_cat(& res->a, (apr_array_header_t const   *)(& base->a));
  table_reindex(res);
  return (res);
}
}
int apr_table_do(apr_table_do_callback_fn_t *comp , void *rec , apr_table_t const   *t 
                 , ...) 
{ int rv ;
  va_list vp ;

  {
  __builtin_stdarg_start(vp, t);
  rv = apr_table_vdo(comp, rec, t, vp);
  __builtin_va_end(vp);
  return (rv);
}
}
int apr_table_vdo(apr_table_do_callback_fn_t *comp , void *rec , apr_table_t const   *t ,
                  va_list vp ) 
{ char *argp ;
  apr_table_entry_t *elts ;
  int vdorv ;
  int rv ;
  int i ;
  int hash ;
  apr_uint32_t checksum ;
  char const   *k ;
  apr_uint32_t c ;
  int tmp ;

  {
  elts = (apr_table_entry_t *)t->a.elts;
  vdorv = 1;
  argp = __builtin_va_arg(vp, char *);
  while (1) {
    rv = 1;
    if (argp) {
      hash = 31 & (int )(*((unsigned char *)argp));
      if (t->index_initialized & (unsigned int )(1 << hash)) {
        k = (char const   *)argp;
        c = (unsigned int )(*k);
        checksum = c;
        checksum <<= 8;
        if (c) {
          k ++;
          c = (unsigned int )(*k);
          checksum |= c;
        }
        checksum <<= 8;
        if (c) {
          k ++;
          c = (unsigned int )(*k);
          checksum |= c;
        }
        checksum <<= 8;
        if (c) {
          k ++;
          c = (unsigned int )(*k);
          checksum |= c;
        }
        checksum &= 3755991007U;
        i = t->index_first[hash];
        while (1) {
          if (rv) {
            if (! (i <= t->index_last[hash])) {
              goto _L___1;
            }
          } else {
            _L___1: 
            break;
          }
          if ((elts + i)->key) {
            if (checksum == (elts + i)->key_checksum) {
              tmp = strcasecmp((char const   *)(elts + i)->key, (char const   *)argp);
              if (tmp) {
                goto _L___0;
              } else {
                rv = ((*comp))(rec, (char const   *)(elts + i)->key, (char const   *)(elts +
                                                                                      i)->val);
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: ;
          }
          i ++;
        }
      }
    } else {
      i = 0;
      while (1) {
        if (rv) {
          if (! (i < t->a.nelts)) {
            goto _L___2;
          }
        } else {
          _L___2: 
          break;
        }
        if ((elts + i)->key) {
          rv = ((*comp))(rec, (char const   *)(elts + i)->key, (char const   *)(elts +
                                                                                i)->val);
        }
        i ++;
      }
    }
    if (rv == 0) {
      vdorv = 0;
    }
    if (argp) {
      argp = __builtin_va_arg(vp, char *);
      if (! ((unsigned int )argp != (unsigned int )((void *)0))) {
        goto _L___3;
      }
    } else {
      _L___3: 
      break;
    }
  }
  return (vdorv);
}
}
static void rotate_counterclockwise(overlap_key **root , overlap_key *rotate_node ) 
{ overlap_key *child ;

  {
  child = rotate_node->tree_right;
  rotate_node->tree_right = child->tree_left;
  if (rotate_node->tree_right) {
    (rotate_node->tree_right)->tree_parent = rotate_node;
  }
  child->tree_parent = rotate_node->tree_parent;
  if ((unsigned int )child->tree_parent == (unsigned int )((void *)0)) {
    (*root) = child;
  } else {
    if ((unsigned int )rotate_node == (unsigned int )(rotate_node->tree_parent)->tree_left) {
      (rotate_node->tree_parent)->tree_left = child;
    } else {
      (rotate_node->tree_parent)->tree_right = child;
    }
  }
  child->tree_left = rotate_node;
  rotate_node->tree_parent = child;
  return;
}
}
static void rotate_clockwise(overlap_key **root , overlap_key *rotate_node ) 
{ overlap_key *child ;

  {
  child = rotate_node->tree_left;
  rotate_node->tree_left = child->tree_right;
  if (rotate_node->tree_left) {
    (rotate_node->tree_left)->tree_parent = rotate_node;
  }
  child->tree_parent = rotate_node->tree_parent;
  if ((unsigned int )child->tree_parent == (unsigned int )((void *)0)) {
    (*root) = child;
  } else {
    if ((unsigned int )rotate_node == (unsigned int )(rotate_node->tree_parent)->tree_left) {
      (rotate_node->tree_parent)->tree_left = child;
    } else {
      (rotate_node->tree_parent)->tree_right = child;
    }
  }
  child->tree_right = rotate_node;
  rotate_node->tree_parent = child;
  return;
}
}
static void overlap_hash(overlap_key *elt , overlap_key **hash_table , int nhash ,
                         unsigned int flags ) 
{ overlap_key **child ;
  overlap_key **root ;
  overlap_key *parent ;
  overlap_key *next ;
  int direction ;
  int tmp ;
  overlap_key *grandparent ;
  overlap_key *parent_sibling ;
  overlap_key *parent_sibling___0 ;

  {
  child = hash_table + ((elt->elt)->key_checksum & (unsigned int )(nhash - 1));
  root = child;
  parent = (overlap_key *)((void *)0);
  while (1) {
    next = (*child);
    if (! ((unsigned int )next != (unsigned int )((void *)0))) {
      break;
    }
    tmp = strcasecmp((char const   *)(elt->elt)->key, (char const   *)(next->elt)->key);
    direction = tmp;
    if (direction < 0) {
      parent = next;
      child = & next->tree_left;
    } else {
      if (direction > 0) {
        parent = next;
        child = & next->tree_right;
      } else {
        if (flags == 1U) {
          elt->skip = 1;
          elt->merge_next = (struct overlap_key *)((void *)0);
          if (next->merge_last) {
            (next->merge_last)->merge_next = elt;
          } else {
            next->merge_next = elt;
          }
          next->merge_last = elt;
        } else {
          if (elt->level > next->level) {
            elt->tree_left = next->tree_left;
            if (next->tree_left) {
              (next->tree_left)->tree_parent = elt;
            }
            elt->tree_right = next->tree_right;
            if (next->tree_right) {
              (next->tree_right)->tree_parent = elt;
            }
            elt->tree_parent = next->tree_parent;
            elt->color = next->color;
            (*child) = elt;
            elt->merge_next = (struct overlap_key *)((void *)0);
            elt->merge_last = (struct overlap_key *)((void *)0);
            elt->skip = 0;
            next->skip = 1;
          } else {
            elt->skip = 1;
          }
        }
        return;
      }
    }
  }
  elt->tree_left = (struct overlap_key *)((void *)0);
  elt->tree_right = (struct overlap_key *)((void *)0);
  elt->tree_parent = parent;
  (*child) = elt;
  elt->merge_next = (struct overlap_key *)((void *)0);
  elt->merge_last = (struct overlap_key *)((void *)0);
  elt->skip = 0;
  elt->color = 0;
  next = elt;
  while (1) {
    if (next->tree_parent) {
      if (! ((next->tree_parent)->color == 0)) {
        goto _L___1;
      }
    } else {
      _L___1: 
      break;
    }
    grandparent = (next->tree_parent)->tree_parent;
    if ((unsigned int )next->tree_parent == (unsigned int )grandparent->tree_left) {
      parent_sibling = grandparent->tree_right;
      if (parent_sibling) {
        if (parent_sibling->color == 0) {
          (next->tree_parent)->color = 1;
          parent_sibling->color = 1;
          grandparent->color = 0;
          next = grandparent;
        } else {
          goto _L;
        }
      } else {
        _L: 
        if ((unsigned int )next == (unsigned int )(next->tree_parent)->tree_right) {
          next = next->tree_parent;
          rotate_counterclockwise(root, next);
        }
        (next->tree_parent)->color = 1;
        ((next->tree_parent)->tree_parent)->color = 0;
        rotate_clockwise(root, (next->tree_parent)->tree_parent);
      }
    } else {
      parent_sibling___0 = grandparent->tree_left;
      if (parent_sibling___0) {
        if (parent_sibling___0->color == 0) {
          (next->tree_parent)->color = 1;
          parent_sibling___0->color = 1;
          grandparent->color = 0;
          next = grandparent;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
        if ((unsigned int )next == (unsigned int )(next->tree_parent)->tree_left) {
          next = next->tree_parent;
          rotate_clockwise(root, next);
        }
        (next->tree_parent)->color = 1;
        ((next->tree_parent)->tree_parent)->color = 0;
        rotate_counterclockwise(root, (next->tree_parent)->tree_parent);
      }
    }
  }
  ((*root))->color = 1;
  return;
}
}
void apr_table_overlap(apr_table_t *a , apr_table_t const   *b , unsigned int flags ) 
{ int max_keys ;
  int nkeys ;
  overlap_key *cat_keys ;
  overlap_key **hash_table ;
  int nhash ;
  int i ;
  apr_table_entry_t *elts ;
  apr_table_entry_t *dst_elt ;
  void *tmp ;
  char *new_val ;
  char *val_next ;
  overlap_key *next ;
  int len ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;

  {
  max_keys = a->a.nelts + b->a.nelts;
  if (! max_keys) {
    return;
  }
  cat_keys = (overlap_key *)apr_palloc(b->a.pool, sizeof(overlap_key ) * (unsigned int )max_keys);
  nhash = 16;
  while (nhash < max_keys) {
    nhash <<= 1;
  }
  tmp = apr_palloc(b->a.pool, sizeof(overlap_key *) * (unsigned int )nhash);
  hash_table = (overlap_key **)memset(tmp, 0, sizeof(overlap_key *) * (unsigned int )nhash);
  nkeys = 0;
  elts = (apr_table_entry_t *)a->a.elts;
  i = 0;
  while (i < a->a.nelts) {
    (cat_keys + nkeys)->elt = elts + i;
    (cat_keys + nkeys)->level = 0;
    overlap_hash(cat_keys + nkeys, hash_table, nhash, flags);
    i ++;
    nkeys ++;
  }
  elts = (apr_table_entry_t *)b->a.elts;
  i = 0;
  while (i < b->a.nelts) {
    (cat_keys + nkeys)->elt = elts + i;
    (cat_keys + nkeys)->level = 1;
    overlap_hash(cat_keys + nkeys, hash_table, nhash, flags);
    i ++;
    nkeys ++;
  }
  make_array_core(& a->a, b->a.pool, max_keys, (int )sizeof(apr_table_entry_t ), 0);
  nkeys = 0;
  dst_elt = (apr_table_entry_t *)a->a.elts;
  i = 0;
  while (i < max_keys) {
    if ((cat_keys + i)->skip) {
      goto __Cont;
    }
    if ((cat_keys + i)->merge_next) {
      next = (cat_keys + i)->merge_next;
      if (((cat_keys + i)->elt)->val) {
        tmp___2 = strlen((char const   *)((cat_keys + i)->elt)->val);
      } else {
        tmp___2 = 0U;
      }
      len = (int )tmp___2;
      while (1) {
        len += 2;
        if ((next->elt)->val) {
          tmp___3 = strlen((char const   *)(next->elt)->val);
          len = (int )((unsigned int )len + tmp___3);
        }
        next = next->merge_next;
        if (! next) {
          break;
        }
      }
      len ++;
      new_val = (char *)apr_palloc(b->a.pool, (unsigned int )len);
      val_next = new_val;
      if (((cat_keys + i)->elt)->val) {
        strcpy((char * __restrict  )val_next, (char const   * __restrict  )((cat_keys +
                                                                             i)->elt)->val);
        tmp___5 = strlen((char const   *)((cat_keys + i)->elt)->val);
        val_next += tmp___5;
      }
      next = (cat_keys + i)->merge_next;
      while (1) {
        tmp___6 = val_next;
        val_next ++;
        (*tmp___6) = (char )',';
        tmp___7 = val_next;
        val_next ++;
        (*tmp___7) = (char )' ';
        if ((next->elt)->val) {
          strcpy((char * __restrict  )val_next, (char const   * __restrict  )(next->elt)->val);
          tmp___8 = strlen((char const   *)(next->elt)->val);
          val_next += tmp___8;
        }
        next = next->merge_next;
        if (! next) {
          break;
        }
      }
      (*val_next) = (char)0;
      dst_elt->key = ((cat_keys + i)->elt)->key;
      dst_elt->val = new_val;
      dst_elt->key_checksum = ((cat_keys + i)->elt)->key_checksum;
      dst_elt ++;
    } else {
      dst_elt->key = ((cat_keys + i)->elt)->key;
      dst_elt->val = ((cat_keys + i)->elt)->val;
      dst_elt->key_checksum = ((cat_keys + i)->elt)->key_checksum;
      dst_elt ++;
    }
    __Cont: 
    i ++;
  }
  a->a.nelts = dst_elt - (apr_table_entry_t *)a->a.elts;
  table_reindex(a);
  return;
}
}
#pragma merger(0,"/tmp/cil-D9HSoRce.i","-g -pthread")
static apr_status_t apr_file_transfer_contents(char const   *from_path , char const   *to_path ,
                                               apr_int32_t flags , apr_fileperms_t to_perms ,
                                               apr_pool_t *pool ) 
{ apr_file_t *s ;
  apr_file_t *d ;
  apr_status_t status ;
  apr_finfo_t finfo ;
  apr_fileperms_t perms ;
  char buf[8192] ;
  apr_size_t bytes_this_time ;
  apr_status_t read_err ;
  apr_status_t write_err ;
  apr_status_t tmp ;

  {
  s = (apr_file_t *)((void *)0);
  d = (apr_file_t *)((void *)0);
  status = apr_file_open(& s, from_path, 1, 4095, pool);
  if (status) {
    return (status);
  }
  if (to_perms == 4096) {
    status = apr_file_info_get(& finfo, 7340032, s);
    if (status != 0) {
      if (status != 70008) {
        apr_file_close(s);
        return (status);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    perms = finfo.protection;
  } else {
    perms = to_perms;
  }
  status = apr_file_open(& d, to_path, flags, perms, pool);
  if (status) {
    apr_file_close(s);
    return (status);
  }
  while (1) {
    bytes_this_time = sizeof(buf);
    read_err = apr_file_read(s, (void *)(buf), & bytes_this_time);
    if (read_err) {
      if (! (read_err == 70014)) {
        apr_file_close(s);
        apr_file_close(d);
        return (read_err);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
    write_err = apr_file_write_full(d, (void const   *)(buf), bytes_this_time, (apr_size_t *)((void *)0));
    if (write_err) {
      apr_file_close(s);
      apr_file_close(d);
      return (write_err);
    }
    if (read_err) {
      if (read_err == 70014) {
        status = apr_file_close(s);
        if (status) {
          apr_file_close(d);
          return (status);
        }
        tmp = apr_file_close(d);
        return (tmp);
      } else {
        goto _L___1;
      }
    } else {
      _L___1: ;
    }
  }
  return (0);
}
}
apr_status_t apr_file_copy(char const   *from_path , char const   *to_path , apr_fileperms_t perms ,
                           apr_pool_t *pool ) 
{ apr_status_t tmp ;

  {
  tmp = apr_file_transfer_contents(from_path, to_path, 22, perms, pool);
  return (tmp);
}
}
apr_status_t apr_file_append(char const   *from_path , char const   *to_path , apr_fileperms_t perms ,
                             apr_pool_t *pool ) 
{ apr_status_t tmp ;

  {
  tmp = apr_file_transfer_contents(from_path, to_path, 14, perms, pool);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-MuSOMbvW.i","-g -pthread")
extern int mkdir(char const   *__path , __mode_t __mode ) ;
extern DIR *opendir(char const   *__name ) ;
extern int closedir(DIR *__dirp ) ;
extern int readdir_r(DIR * __restrict  __dirp , struct dirent * __restrict  __entry ,
                     struct dirent ** __restrict  __result ) ;
extern void rewinddir(DIR *__dirp ) ;
extern int rmdir(char const   *__path ) ;
mode_t apr_unix_perms2mode(apr_fileperms_t perms ) ;
static apr_status_t dir_cleanup(void *thedir ) 
{ apr_dir_t *dir ;
  int *tmp ;
  int tmp___0 ;

  {
  dir = (apr_dir_t *)thedir;
  tmp___0 = closedir(dir->dirstruct);
  if (tmp___0 == 0) {
    return (0);
  } else {
    tmp = __errno_location();
    return ((*tmp));
  }
}
}
static char const   *path_canonicalize(char const   *path , apr_pool_t *pool ) 
{ apr_size_t len ;
  apr_size_t tmp ;
  apr_size_t orig_len ;
  char const   *tmp___0 ;

  {
  tmp = strlen(path);
  len = tmp;
  orig_len = len;
  while (1) {
    if (len > 0U) {
      if (! ((int const   )(*(path + (len - 1U))) == 47)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
    len --;
  }
  if (len != orig_len) {
    tmp___0 = apr_pstrndup(pool, path, len);
    return (tmp___0);
  } else {
    return (path);
  }
}
}
static char *path_remove_last_component(char const   *path , apr_pool_t *pool ) 
{ char const   *newpath ;
  char const   *tmp ;
  int i ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  tmp = path_canonicalize(path, pool);
  newpath = tmp;
  tmp___0 = strlen(newpath);
  i = (int )(tmp___0 - 1U);
  while (i >= 0) {
    if ((int const   )(*(path + i)) == 47) {
      break;
    }
    i --;
  }
  if (i < 0) {
    tmp___1 = 0;
  } else {
    tmp___1 = i;
  }
  tmp___2 = apr_pstrndup(pool, path, (unsigned int )tmp___1);
  return (tmp___2);
}
}
apr_status_t apr_dir_open(apr_dir_t **new , char const   *dirname , apr_pool_t *pool ) 
{ apr_size_t dirent_size ;
  unsigned int tmp ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  if (sizeof((((*new))->entry)->d_name) > 1U) {
    tmp = sizeof(struct dirent );
  } else {
    tmp = sizeof(struct dirent ) + 255U;
  }
  dirent_size = tmp;
  (*new) = (apr_dir_t *)apr_palloc(pool, sizeof(apr_dir_t ));
  ((*new))->pool = pool;
  ((*new))->dirname = apr_pstrdup(pool, dirname);
  ((*new))->dirstruct = opendir(dirname);
  tmp___1 = apr_palloc(pool, dirent_size);
  ((*new))->entry = (struct dirent *)memset(tmp___1, 0, dirent_size);
  if ((unsigned int )((*new))->dirstruct == (unsigned int )((void *)0)) {
    tmp___2 = __errno_location();
    return ((*tmp___2));
  } else {
    apr_pool_cleanup_register(((*new))->pool, (void const   *)((void *)(*new)), & dir_cleanup,
                              & apr_pool_cleanup_null);
    return (0);
  }
}
}
apr_status_t apr_dir_close(apr_dir_t *thedir ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_cleanup_run(thedir->pool, (void *)thedir, & dir_cleanup);
  return (tmp);
}
}
static apr_filetype_e filetype_from_dirent_type(int type ) 
{ 

  {
  switch (type) {
  case 8: ;
  return ((enum __anonenum_apr_filetype_e_42 )1);
  case 4: ;
  return ((enum __anonenum_apr_filetype_e_42 )2);
  case 10: ;
  return ((enum __anonenum_apr_filetype_e_42 )6);
  case 2: ;
  return ((enum __anonenum_apr_filetype_e_42 )3);
  case 6: ;
  return ((enum __anonenum_apr_filetype_e_42 )4);
  case 1: ;
  return ((enum __anonenum_apr_filetype_e_42 )5);
  case 12: ;
  return ((enum __anonenum_apr_filetype_e_42 )7);
  default: ;
  return ((enum __anonenum_apr_filetype_e_42 )127);
  }
}
}
apr_status_t apr_dir_read(apr_finfo_t *finfo , apr_int32_t wanted , apr_dir_t *thedir ) 
{ apr_status_t ret ;
  apr_filetype_e type ;
  struct dirent *retent ;
  char fspec[4096] ;
  int off ;
  int tmp ;

  {
  ret = 0;
  ret = readdir_r((DIR * __restrict  )thedir->dirstruct, (struct dirent * __restrict  )thedir->entry,
                  (struct dirent ** __restrict  )(& retent));
  if (! ret) {
    if ((unsigned int )thedir->entry != (unsigned int )retent) {
      ret = 2;
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if (ret == 22) {
    ret = 2;
  }
  finfo->fname = (char const   *)((void *)0);
  if (ret) {
    finfo->valid = 0;
    return (ret);
  }
  type = filetype_from_dirent_type((int )(thedir->entry)->d_type);
  if ((int )type != 127) {
    wanted &= -32769;
  }
  if ((thedir->entry)->d_ino) {
    if ((thedir->entry)->d_ino != 4294967295UL) {
      wanted &= -8193;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
  }
  wanted &= -33554433;
  if (wanted) {
    apr_cpystrn(fspec, (char const   *)thedir->dirname, sizeof(fspec));
    off = (int )strlen((char const   *)(fspec));
    if ((int )fspec[off - 1] != 47) {
      if ((unsigned int )(off + 1) < sizeof(fspec)) {
        tmp = off;
        off ++;
        fspec[tmp] = (char )'/';
      } else {
        goto _L___1;
      }
    } else {
      _L___1: ;
    }
    apr_cpystrn(fspec + off, (char const   *)((thedir->entry)->d_name), sizeof(fspec) -
                                                                        (unsigned int )off);
    ret = apr_lstat(finfo, (char const   *)(fspec), wanted, thedir->pool);
    finfo->fname = (char const   *)((void *)0);
  }
  if (wanted) {
    if (ret == 0) {
      goto _L___4;
    } else {
      if (ret == 70008) {
        _L___4: 
        wanted &= ~ finfo->valid;
      } else {
        goto _L___3;
      }
    }
  } else {
    _L___3: 
    finfo->pool = thedir->pool;
    finfo->valid = 0;
    if ((int )type != 127) {
      finfo->filetype = type;
      finfo->valid = finfo->valid | 32768;
    }
    if ((thedir->entry)->d_ino) {
      if ((thedir->entry)->d_ino != 4294967295UL) {
        finfo->inode = (thedir->entry)->d_ino;
        finfo->valid = finfo->valid | 8192;
      } else {
        goto _L___2;
      }
    } else {
      _L___2: ;
    }
  }
  finfo->name = apr_pstrdup(thedir->pool, (char const   *)((thedir->entry)->d_name));
  finfo->valid = finfo->valid | 33554432;
  if (wanted) {
    return (70008);
  }
  return (0);
}
}
apr_status_t apr_dir_rewind(apr_dir_t *thedir ) 
{ 

  {
  rewinddir(thedir->dirstruct);
  return (0);
}
}
apr_status_t apr_dir_make(char const   *path , apr_fileperms_t perm , apr_pool_t *pool ) 
{ mode_t mode ;
  mode_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  tmp = apr_unix_perms2mode(perm);
  mode = tmp;
  tmp___1 = mkdir(path, mode);
  if (tmp___1 == 0) {
    return (0);
  } else {
    tmp___0 = __errno_location();
    return ((*tmp___0));
  }
}
}
apr_status_t apr_dir_make_recursive(char const   *path , apr_fileperms_t perm , apr_pool_t *pool ) 
{ apr_status_t apr_err ;
  char *dir ;

  {
  apr_err = 0;
  apr_err = apr_dir_make(path, perm, pool);
  if (apr_err == 17) {
    return (0);
  }
  if (apr_err == 2) {
    dir = path_remove_last_component(path, pool);
    apr_err = apr_dir_make_recursive((char const   *)dir, perm, pool);
    if (! apr_err) {
      apr_err = apr_dir_make(path, perm, pool);
    }
  }
  return (apr_err);
}
}
apr_status_t apr_dir_remove(char const   *path , apr_pool_t *pool ) 
{ int *tmp ;
  int tmp___0 ;

  {
  tmp___0 = rmdir(path);
  if (tmp___0 == 0) {
    return (0);
  } else {
    tmp = __errno_location();
    return ((*tmp));
  }
}
}
apr_status_t apr_os_dir_get(apr_os_dir_t **thedir , apr_dir_t *dir ) 
{ 

  {
  if ((unsigned int )dir == (unsigned int )((void *)0)) {
    return (20008);
  }
  (*thedir) = dir->dirstruct;
  return (0);
}
}
apr_status_t apr_os_dir_put(apr_dir_t **dir , apr_os_dir_t *thedir , apr_pool_t *pool ) 
{ void *tmp ;

  {
  if ((unsigned int )(*dir) == (unsigned int )((void *)0)) {
    tmp = apr_palloc(pool, sizeof(apr_dir_t ));
    (*dir) = (apr_dir_t *)memset(tmp, 0, sizeof(apr_dir_t ));
    ((*dir))->pool = pool;
  }
  ((*dir))->dirstruct = thedir;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-HRvFEfsS.i","-g -pthread")
apr_fileperms_t apr_unix_mode2perms(mode_t mode ) ;
apr_status_t apr_file_name_get(char const   **fname , apr_file_t *thefile ) 
{ 

  {
  (*fname) = (char const   *)thefile->fname;
  return (0);
}
}
apr_int32_t apr_file_flags_get(apr_file_t *f ) 
{ 

  {
  return (f->flags);
}
}
mode_t apr_unix_perms2mode(apr_fileperms_t perms ) 
{ mode_t mode ;

  {
  mode = 0U;
  if (perms & 1024) {
    mode |= 256U;
  }
  if (perms & 512) {
    mode |= 128U;
  }
  if (perms & 256) {
    mode |= 64U;
  }
  if (perms & 64) {
    mode |= 32U;
  }
  if (perms & 32) {
    mode |= 16U;
  }
  if (perms & 16) {
    mode |= 8U;
  }
  if (perms & 4) {
    mode |= 4U;
  }
  if (perms & 2) {
    mode |= 2U;
  }
  if (perms & 1) {
    mode |= 1U;
  }
  return (mode);
}
}
apr_fileperms_t apr_unix_mode2perms(mode_t mode ) 
{ apr_fileperms_t perms ;

  {
  perms = 0;
  if (mode & 256U) {
    perms |= 1024;
  }
  if (mode & 128U) {
    perms |= 512;
  }
  if (mode & 64U) {
    perms |= 256;
  }
  if (mode & 32U) {
    perms |= 64;
  }
  if (mode & 16U) {
    perms |= 32;
  }
  if (mode & 8U) {
    perms |= 16;
  }
  if (mode & 4U) {
    perms |= 4;
  }
  if (mode & 2U) {
    perms |= 2;
  }
  if (mode & 1U) {
    perms |= 1;
  }
  return (perms);
}
}
apr_status_t apr_file_data_get(void **data , char const   *key , apr_file_t *file ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_userdata_get(data, key, file->pool);
  return (tmp);
}
}
apr_status_t apr_file_data_set(apr_file_t *file , void *data , char const   *key ,
                               apr_status_t (*cleanup)(void * ) ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_userdata_set((void const   *)data, key, cleanup, file->pool);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-ruJmeNO2.i","-g -pthread")
extern int dup(int __fd ) ;
extern int dup2(int __fd , int __fd2 ) ;
apr_status_t apr_unix_file_cleanup(void *thefile ) ;
static apr_status_t _file_dup(apr_file_t **new_file , apr_file_t *old_file , apr_pool_t *p ,
                              int which_dup ) 
{ int rv ;
  void *tmp ;
  int *tmp___1 ;

  {
  if ((unsigned int )(*new_file) == (unsigned int )((void *)0)) {
    if (which_dup == 1) {
      tmp = apr_palloc(p, sizeof(apr_file_t ));
      (*new_file) = (apr_file_t *)memset(tmp, 0, sizeof(apr_file_t ));
      if ((unsigned int )(*new_file) == (unsigned int )((void *)0)) {
        return (12);
      }
      ((*new_file))->pool = p;
    } else {
      return (22);
    }
  }
  if (which_dup == 2) {
    rv = dup2(old_file->filedes, ((*new_file))->filedes);
  } else {
    ((*new_file))->filedes = dup(old_file->filedes);
    rv = ((*new_file))->filedes;
  }
  if (rv == -1) {
    tmp___1 = __errno_location();
    return ((*tmp___1));
  }
  ((*new_file))->fname = apr_pstrdup(p, (char const   *)old_file->fname);
  ((*new_file))->buffered = old_file->buffered;
  if (((*new_file))->buffered) {
    if (! ((*new_file))->thlock) {
      if (old_file->thlock) {
        apr_thread_mutex_create(& ((*new_file))->thlock, 0U, p);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
  }
  if (((*new_file))->buffered) {
    if (! ((*new_file))->buffer) {
      ((*new_file))->buffer = (char *)apr_palloc(p, 4096U);
    } else {
      goto _L___1;
    }
  } else {
    _L___1: ;
  }
  ((*new_file))->blocking = old_file->blocking;
  ((*new_file))->ungetchar = old_file->ungetchar;
  ((*new_file))->flags = old_file->flags & -16777217;
  return (0);
}
}
apr_status_t apr_file_dup(apr_file_t **new_file , apr_file_t *old_file , apr_pool_t *p ) 
{ apr_status_t rv ;

  {
  rv = _file_dup(new_file, old_file, p, 1);
  if (rv != 0) {
    return (rv);
  }
  apr_pool_cleanup_register(((*new_file))->pool, (void const   *)((void *)(*new_file)),
                            & apr_unix_file_cleanup, & apr_unix_file_cleanup);
  return (rv);
}
}
apr_status_t apr_file_dup2(apr_file_t *new_file , apr_file_t *old_file , apr_pool_t *p ) 
{ apr_status_t tmp ;

  {
  tmp = _file_dup(& new_file, old_file, p, 2);
  return (tmp);
}
}
apr_status_t apr_file_setaside(apr_file_t **new_file , apr_file_t *old_file , apr_pool_t *p ) 
{ 

  {
  (*new_file) = (apr_file_t *)apr_palloc(p, sizeof(apr_file_t ));
  memcpy((void * __restrict  )(*new_file), (void const   * __restrict  )old_file,
         sizeof(apr_file_t ));
  ((*new_file))->pool = p;
  if (old_file->buffered) {
    ((*new_file))->buffer = (char *)apr_palloc(p, 4096U);
    if (old_file->direction == 1) {
      memcpy((void * __restrict  )((*new_file))->buffer, (void const   * __restrict  )old_file->buffer,
             (unsigned int )old_file->bufpos);
    } else {
      memcpy((void * __restrict  )((*new_file))->buffer, (void const   * __restrict  )old_file->buffer,
             (unsigned int )old_file->dataRead);
    }
    if (old_file->thlock) {
      apr_thread_mutex_create(& ((*new_file))->thlock, 0U, p);
      apr_thread_mutex_destroy(old_file->thlock);
    }
  }
  if (old_file->fname) {
    ((*new_file))->fname = apr_pstrdup(p, (char const   *)old_file->fname);
  }
  if (! (old_file->flags & 2048)) {
    apr_pool_cleanup_register(p, (void const   *)((void *)(*new_file)), & apr_unix_file_cleanup,
                              & apr_unix_file_cleanup);
  }
  old_file->filedes = -1;
  apr_pool_cleanup_kill(old_file->pool, (void const   *)((void *)old_file), & apr_unix_file_cleanup);
  return (0);
}
}
#pragma merger(0,"/tmp/cil-6DxFFYcO.i","-g -pthread")
extern char *getcwd(char *__buf , size_t __size ) ;
apr_status_t apr_filepath_get(char **defpath , apr_int32_t flags , apr_pool_t *p ) 
{ char path[4096] ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  tmp___1 = getcwd(path, sizeof(path));
  if (! tmp___1) {
    tmp___0 = __errno_location();
    if ((*tmp___0) == 34) {
      return (36);
    } else {
      tmp = __errno_location();
      return ((*tmp));
    }
  }
  (*defpath) = apr_pstrdup(p, (char const   *)(path));
  return (0);
}
}
apr_status_t apr_filepath_set(char const   *path , apr_pool_t *p ) 
{ int *tmp ;
  int tmp___0 ;

  {
  tmp___0 = chdir(path);
  if (tmp___0 != 0) {
    tmp = __errno_location();
    return ((*tmp));
  }
  return (0);
}
}
apr_status_t apr_filepath_root(char const   **rootpath , char const   **inpath , apr_int32_t flags ,
                               apr_pool_t *p ) 
{ 

  {
  if ((int const   )(*((*inpath))) == 47) {
    (*rootpath) = apr_pstrdup(p, "/");
    while (1) {
      (*inpath) ++;
      if (! ((int const   )(*((*inpath))) == 47)) {
        break;
      }
    }
    return (0);
  }
  return (20021);
}
}
apr_status_t apr_filepath_merge(char **newpath , char const   *rootpath , char const   *addpath ,
                                apr_int32_t flags , apr_pool_t *p ) 
{ char *path ;
  apr_size_t rootlen ;
  apr_size_t maxlen ;
  apr_size_t keptlen ;
  apr_size_t pathlen ;
  apr_size_t seglen ;
  apr_status_t rv ;
  char *getpath ;
  int *tmp ;
  size_t tmp___0 ;
  apr_size_t tmp___2 ;
  char const   *next ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  if (! addpath) {
    addpath = "";
  }
  if ((int const   )(*(addpath + 0)) == 47) {
    if (flags & 2) {
      return (20023);
    }
    if (flags & 8) {
      return (20020);
    }
    if (! rootpath) {
      if (! (flags & 1)) {
        rootpath = "";
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
  } else {
    if (flags & 8) {
      if (! rootpath) {
        rootpath = "";
      } else {
        if ((int const   )(*(rootpath + 0)) == 47) {
          return (20020);
        }
      }
    }
  }
  if (! rootpath) {
    rv = apr_filepath_get(& getpath, flags, p);
    rootpath = (char const   *)getpath;
    if (rv != 0) {
      tmp = __errno_location();
      return ((*tmp));
    }
  }
  rootlen = strlen(rootpath);
  tmp___0 = strlen(addpath);
  maxlen = (rootlen + tmp___0) + 4U;
  if (maxlen > 4096U) {
    return (36);
  }
  path = (char *)apr_palloc(p, maxlen);
  if ((int const   )(*(addpath + 0)) == 47) {
    keptlen = 0U;
    while ((int const   )(*(addpath + 0)) == 47) {
      addpath ++;
    }
    (*(path + 0)) = (char )'/';
    pathlen = 1U;
  } else {
    if ((int const   )(*(rootpath + 0)) != 47) {
      if (flags & 4) {
        return (20021);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
    keptlen = rootlen;
    memcpy((void * __restrict  )path, (void const   * __restrict  )rootpath, rootlen);
    if (keptlen) {
      if ((int )(*(path + (keptlen - 1U))) != 47) {
        tmp___2 = keptlen;
        keptlen ++;
        (*(path + tmp___2)) = (char )'/';
      } else {
        goto _L___1;
      }
    } else {
      _L___1: ;
    }
    pathlen = keptlen;
  }
  while ((*addpath)) {
    next = addpath;
    while (1) {
      if ((*next)) {
        if (! ((int const   )(*next) != 47)) {
          goto _L___2;
        }
      } else {
        _L___2: 
        break;
      }
      next ++;
    }
    seglen = (unsigned int )(next - addpath);
    if (seglen == 0U) {
      goto _L___11;
    } else {
      if (seglen == 1U) {
        if ((int const   )(*(addpath + 0)) == 46) {
          _L___11: ;
        } else {
          goto _L___12;
        }
      } else {
        _L___12: 
        if (seglen == 2U) {
          if ((int const   )(*(addpath + 0)) == 46) {
            if ((int const   )(*(addpath + 1)) == 46) {
              if (pathlen == 1U) {
                if ((int )(*(path + 0)) == 47) {
                  if (flags & 2) {
                    return (20023);
                  }
                  keptlen = 0U;
                } else {
                  goto _L___8;
                }
              } else {
                _L___8: 
                if (pathlen == 0U) {
                  goto _L___6;
                } else {
                  if (pathlen == 3U) {
                    tmp___3 = memcmp((void const   *)((path + pathlen) - 3), (void const   *)"../",
                                     3U);
                    if (tmp___3) {
                      goto _L___7;
                    } else {
                      _L___6: 
                      goto _L___4;
                    }
                  } else {
                    _L___7: 
                    if (pathlen > 3U) {
                      tmp___4 = memcmp((void const   *)((path + pathlen) - 4), (void const   *)"/../",
                                       4U);
                      if (tmp___4) {
                        goto _L___5;
                      } else {
                        _L___4: 
                        if (flags & 2) {
                          return (20023);
                        }
                        memcpy((void * __restrict  )(path + pathlen), (void const   * __restrict  )"../",
                               3U);
                        pathlen += 3U;
                      }
                    } else {
                      _L___5: 
                      while (1) {
                        pathlen --;
                        if (pathlen) {
                          if (! ((int )(*(path + (pathlen - 1U))) != 47)) {
                            goto _L___3;
                          }
                        } else {
                          _L___3: 
                          break;
                        }
                      }
                    }
                  }
                }
              }
              if (pathlen < keptlen) {
                if (flags & 2) {
                  return (20023);
                }
                keptlen = pathlen;
              }
            } else {
              goto _L___10;
            }
          } else {
            goto _L___10;
          }
        } else {
          _L___10: 
          if ((*next)) {
            seglen ++;
          }
          memcpy((void * __restrict  )(path + pathlen), (void const   * __restrict  )addpath,
                 seglen);
          pathlen += seglen;
        }
      }
    }
    if ((*next)) {
      next ++;
    }
    addpath = next;
  }
  (*(path + pathlen)) = (char )'\000';
  if (flags & 1) {
    if (keptlen < rootlen) {
      tmp___5 = strncmp(rootpath, (char const   *)path, rootlen);
      if (tmp___5) {
        return (20023);
      }
      if ((int const   )(*(rootpath + (rootlen - 1U))) != 47) {
        if ((*(path + rootlen))) {
          if ((int )(*(path + rootlen)) != 47) {
            return (20023);
          } else {
            goto _L___14;
          }
        } else {
          goto _L___14;
        }
      } else {
        _L___14: ;
      }
    } else {
      goto _L___15;
    }
  } else {
    _L___15: ;
  }
  (*newpath) = path;
  return (0);
}
}
apr_status_t apr_filepath_encoding(int *style , apr_pool_t *p ) 
{ 

  {
  (*style) = 1;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-dsEoM91f.i","-g -pthread")
extern int chmod(char const   *__file , __mode_t __mode ) ;
extern int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
extern int __xstat(int __ver , char const   *__filename , struct stat *__stat_buf ) ;
extern int __lxstat(int __ver , char const   *__filename , struct stat *__stat_buf ) ;
__inline static int stat__extinline(char const   *__path , struct stat *__statbuf ) 
{ int tmp ;

  {
  tmp = __xstat(3, __path, __statbuf);
  return (tmp);
}
}
__inline static int lstat__extinline(char const   *__path , struct stat *__statbuf ) 
{ int tmp ;

  {
  tmp = __lxstat(3, __path, __statbuf);
  return (tmp);
}
}
__inline static int fstat__extinline(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
  tmp = __fxstat(3, __fd, __statbuf);
  return (tmp);
}
}
static apr_filetype_e filetype_from_mode(mode_t mode ) 
{ apr_filetype_e type ;

  {
  switch ((int )(mode & 61440U)) {
  case 32768: 
  type = (enum __anonenum_apr_filetype_e_42 )1;
  break;
  case 16384: 
  type = (enum __anonenum_apr_filetype_e_42 )2;
  break;
  case 40960: 
  type = (enum __anonenum_apr_filetype_e_42 )6;
  break;
  case 8192: 
  type = (enum __anonenum_apr_filetype_e_42 )3;
  break;
  case 24576: 
  type = (enum __anonenum_apr_filetype_e_42 )4;
  break;
  case 49152: 
  type = (enum __anonenum_apr_filetype_e_42 )7;
  break;
  default: ;
  if ((mode & 61440U) == 4096U) {
    type = (enum __anonenum_apr_filetype_e_42 )5;
  } else {
    type = (enum __anonenum_apr_filetype_e_42 )127;
  }
  }
  return (type);
}
}
static void fill_out_finfo(apr_finfo_t *finfo , struct stat *info , apr_int32_t wanted ) 
{ 

  {
  finfo->valid = 7598448;
  finfo->protection = apr_unix_mode2perms(info->st_mode);
  finfo->filetype = filetype_from_mode(info->st_mode);
  finfo->user = info->st_uid;
  finfo->group = info->st_gid;
  finfo->size = info->st_size;
  finfo->inode = info->st_ino;
  finfo->device = info->st_dev;
  finfo->nlink = (int )info->st_nlink;
  apr_time_ansi_put(& finfo->atime, info->st_atim.tv_sec);
  apr_time_ansi_put(& finfo->mtime, info->st_mtim.tv_sec);
  apr_time_ansi_put(& finfo->ctime, info->st_ctim.tv_sec);
  return;
}
}
apr_status_t apr_file_info_get(apr_finfo_t *finfo , apr_int32_t wanted , apr_file_t *thefile ) 
{ struct stat info ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  tmp___1 = fstat__extinline(thefile->filedes, & info);
  if (tmp___1 == 0) {
    finfo->pool = thefile->pool;
    finfo->fname = (char const   *)thefile->fname;
    fill_out_finfo(finfo, & info, wanted);
    if (wanted & ~ finfo->valid) {
      tmp = 70008;
    } else {
      tmp = 0;
    }
    return (tmp);
  } else {
    tmp___0 = __errno_location();
    return ((*tmp___0));
  }
}
}
apr_status_t apr_file_perms_set(char const   *fname , apr_fileperms_t perms ) 
{ mode_t mode ;
  mode_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  tmp = apr_unix_perms2mode(perms);
  mode = tmp;
  tmp___1 = chmod(fname, mode);
  if (tmp___1 == -1) {
    tmp___0 = __errno_location();
    return ((*tmp___0));
  }
  return (0);
}
}
apr_status_t apr_file_attrs_set(char const   *fname , apr_fileattrs_t attributes ,
                                apr_fileattrs_t attr_mask , apr_pool_t *pool ) 
{ apr_status_t status ;
  apr_finfo_t finfo ;
  apr_status_t tmp ;

  {
  status = apr_stat(& finfo, fname, 7340032, pool);
  if (! (status == 0)) {
    return (status);
  }
  if (attr_mask & 1U) {
    if (attributes & 1U) {
      finfo.protection = finfo.protection & -513;
      finfo.protection = finfo.protection & -33;
      finfo.protection = finfo.protection & -3;
    } else {
      finfo.protection = finfo.protection | 512;
      finfo.protection = finfo.protection | 32;
      finfo.protection = finfo.protection | 2;
    }
  }
  if (attr_mask & 2U) {
    if (attributes & 2U) {
      finfo.protection = finfo.protection | 256;
      finfo.protection = finfo.protection | 16;
      finfo.protection = finfo.protection | 1;
    } else {
      finfo.protection = finfo.protection & -257;
      finfo.protection = finfo.protection & -17;
      finfo.protection = finfo.protection & -2;
    }
  }
  tmp = apr_file_perms_set(fname, finfo.protection);
  return (tmp);
}
}
apr_status_t apr_stat(apr_finfo_t *finfo , char const   *fname , apr_int32_t wanted ,
                      apr_pool_t *pool ) 
{ struct stat info ;
  int srv ;
  int tmp ;
  int *tmp___0 ;

  {
  if (wanted & 1) {
    srv = lstat__extinline(fname, & info);
  } else {
    srv = stat__extinline(fname, & info);
  }
  if (srv == 0) {
    finfo->pool = pool;
    finfo->fname = fname;
    fill_out_finfo(finfo, & info, wanted);
    if (wanted & 1) {
      wanted &= -2;
    }
    if (wanted & ~ finfo->valid) {
      tmp = 70008;
    } else {
      tmp = 0;
    }
    return (tmp);
  } else {
    tmp___0 = __errno_location();
    return ((*tmp___0));
  }
}
}
apr_status_t apr_lstat(apr_finfo_t *finfo , char const   *fname , apr_int32_t wanted ,
                       apr_pool_t *pool ) 
{ apr_status_t tmp ;

  {
  tmp = apr_stat(finfo, fname, wanted | 1, pool);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-HVrVq5Gn.i","-g -pthread")
extern int fcntl(int __fd , int __cmd  , ...) ;
apr_status_t apr_file_lock(apr_file_t *thefile , int type ) 
{ int rc ;
  struct flock l ;
  int fc ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  l.l_type = (short)0;
  l.l_whence = (short)0;
  l.l_start = 0L;
  l.l_len = 0L;
  l.l_pid = 0;
  l.l_whence = (short)0;
  l.l_start = 0L;
  l.l_len = 0L;
  if ((type & 15) == 1) {
    l.l_type = (short)0;
  } else {
    l.l_type = (short)1;
  }
  if (type & 16) {
    fc = 6;
  } else {
    fc = 7;
  }
  while (1) {
    rc = fcntl(thefile->filedes, fc, & l);
    if (rc < 0) {
      tmp = __errno_location();
      if (! ((*tmp) == 4)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
    continue;
  }
  if (rc == -1) {
    tmp___0 = __errno_location();
    if ((*tmp___0) == 13) {
      return (11);
    }
    tmp___1 = __errno_location();
    return ((*tmp___1));
  }
  return (0);
}
}
apr_status_t apr_file_unlock(apr_file_t *thefile ) 
{ int rc ;
  struct flock l ;
  int *tmp ;
  int *tmp___0 ;

  {
  l.l_type = (short)0;
  l.l_whence = (short)0;
  l.l_start = 0L;
  l.l_len = 0L;
  l.l_pid = 0;
  l.l_whence = (short)0;
  l.l_start = 0L;
  l.l_len = 0L;
  l.l_type = (short)2;
  while (1) {
    rc = fcntl(thefile->filedes, 7, & l);
    if (rc < 0) {
      tmp = __errno_location();
      if (! ((*tmp) == 4)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
    continue;
  }
  if (rc == -1) {
    tmp___0 = __errno_location();
    return ((*tmp___0));
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-KZsAMTr5.i","-g -pthread")
apr_status_t apr_file_read_full(apr_file_t *thefile , void *buf , apr_size_t nbytes ,
                                apr_size_t *bytes_read ) 
{ apr_status_t status ;
  apr_size_t total_read ;
  apr_size_t amt ;

  {
  total_read = 0U;
  while (1) {
    amt = nbytes;
    status = apr_file_read(thefile, buf, & amt);
    buf = (void *)((char *)buf + amt);
    nbytes -= amt;
    total_read += amt;
    if (status == 0) {
      if (! (nbytes > 0U)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
  }
  if ((unsigned int )bytes_read != (unsigned int )((void *)0)) {
    (*bytes_read) = total_read;
  }
  return (status);
}
}
apr_status_t apr_file_write_full(apr_file_t *thefile , void const   *buf , apr_size_t nbytes ,
                                 apr_size_t *bytes_written ) 
{ apr_status_t status ;
  apr_size_t total_written ;
  apr_size_t amt ;

  {
  total_written = 0U;
  while (1) {
    amt = nbytes;
    status = apr_file_write(thefile, buf, & amt);
    buf = (void const   *)((char *)buf + amt);
    nbytes -= amt;
    total_written += amt;
    if (status == 0) {
      if (! (nbytes > 0U)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
  }
  if ((unsigned int )bytes_written != (unsigned int )((void *)0)) {
    (*bytes_written) = total_written;
  }
  return (status);
}
}
#pragma merger(0,"/tmp/cil-jyOQejXv.i","-g -pthread")
extern int mkstemp(char *__template ) ;
apr_status_t apr_file_mktemp(apr_file_t **fp , char *template , apr_int32_t flags ,
                             apr_pool_t *p ) 
{ int fd ;
  int *tmp ;

  {
  if (! flags) {
    flags = 327;
  } else {
    flags = flags;
  }
  fd = mkstemp(template);
  if (fd == -1) {
    tmp = __errno_location();
    return ((*tmp));
  }
  apr_os_file_put(fp, & fd, flags, p);
  ((*fp))->fname = apr_pstrdup(p, (char const   *)template);
  apr_pool_cleanup_register(((*fp))->pool, (void const   *)((void *)(*fp)), & apr_unix_file_cleanup,
                            & apr_unix_file_cleanup);
  return (0);
}
}
#pragma merger(0,"/tmp/cil-qDiiIzZz.i","-g -pthread")
extern int rename(char const   *__old , char const   *__new ) ;
extern int open(char const   *__file , int __oflag  , ...) ;
extern int close(int __fd ) ;
apr_status_t apr_unix_file_cleanup(void *thefile ) 
{ apr_file_t *file ;
  apr_status_t flush_rv ;
  apr_status_t rv ;
  int rc ;
  int *tmp ;
  apr_status_t tmp___0 ;

  {
  file = (apr_file_t *)thefile;
  flush_rv = 0;
  rv = 0;
  if (file->buffered) {
    flush_rv = apr_file_flush(file);
  }
  rc = close(file->filedes);
  if (rc == 0) {
    file->filedes = -1;
    if (file->flags & 256) {
      unlink((char const   *)file->fname);
    }
    if (file->thlock) {
      rv = apr_thread_mutex_destroy(file->thlock);
    }
  } else {
    tmp = __errno_location();
    rv = (*tmp);
  }
  if (rv != 0) {
    tmp___0 = rv;
  } else {
    tmp___0 = flush_rv;
  }
  return (tmp___0);
}
}
apr_status_t apr_file_open(apr_file_t **new , char const   *fname , apr_int32_t flag ,
                           apr_fileperms_t perm , apr_pool_t *pool ) 
{ apr_os_file_t fd ;
  int oflags ;
  apr_thread_mutex_t *thlock ;
  apr_status_t rv ;
  mode_t tmp ;
  int *tmp___0 ;
  void *tmp___1 ;

  {
  oflags = 0;
  if (flag & 1) {
    if (flag & 2) {
      oflags = 2;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (flag & 1) {
      oflags = 0;
    } else {
      if (flag & 2) {
        oflags = 1;
      } else {
        return (13);
      }
    }
  }
  if (flag & 4) {
    oflags |= 64;
    if (flag & 64) {
      oflags |= 128;
    }
  }
  if (flag & 64) {
    if (! (flag & 4)) {
      return (13);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
  }
  if (flag & 8) {
    oflags |= 1024;
  }
  if (flag & 16) {
    oflags |= 512;
  }
  if (flag & 128) {
    if (flag & 512) {
      rv = apr_thread_mutex_create(& thlock, 0U, pool);
      if (rv) {
        return (rv);
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: ;
  }
  if (perm == 4095) {
    fd = open(fname, oflags, 438);
  } else {
    tmp = apr_unix_perms2mode(perm);
    fd = open(fname, oflags, tmp);
  }
  if (fd < 0) {
    tmp___0 = __errno_location();
    return ((*tmp___0));
  }
  tmp___1 = apr_palloc(pool, sizeof(apr_file_t ));
  (*new) = (apr_file_t *)memset(tmp___1, 0, sizeof(apr_file_t ));
  ((*new))->pool = pool;
  ((*new))->flags = flag;
  ((*new))->filedes = fd;
  ((*new))->fname = apr_pstrdup(pool, fname);
  ((*new))->blocking = (enum __anonenum_blocking_60 )2;
  ((*new))->buffered = (flag & 128) > 0;
  if (((*new))->buffered) {
    ((*new))->buffer = (char *)apr_palloc(pool, 4096U);
    if (((*new))->flags & 512) {
      ((*new))->thlock = thlock;
    }
  } else {
    ((*new))->buffer = (char *)((void *)0);
  }
  ((*new))->is_pipe = 0;
  ((*new))->timeout = -1LL;
  ((*new))->ungetchar = -1;
  ((*new))->eof_hit = 0;
  ((*new))->filePtr = 0UL;
  ((*new))->bufpos = 0;
  ((*new))->dataRead = 0UL;
  ((*new))->direction = 0;
  if (! (flag & 2048)) {
    apr_pool_cleanup_register(((*new))->pool, (void const   *)((void *)(*new)), & apr_unix_file_cleanup,
                              & apr_unix_file_cleanup);
  }
  return (0);
}
}
apr_status_t apr_file_close(apr_file_t *file ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_cleanup_run(file->pool, (void *)file, & apr_unix_file_cleanup);
  return (tmp);
}
}
apr_status_t apr_file_remove(char const   *path , apr_pool_t *pool ) 
{ int *tmp ;
  int tmp___0 ;

  {
  tmp___0 = unlink(path);
  if (tmp___0 == 0) {
    return (0);
  } else {
    tmp = __errno_location();
    return ((*tmp));
  }
}
}
apr_status_t apr_file_rename(char const   *from_path , char const   *to_path , apr_pool_t *p ) 
{ int *tmp ;
  int tmp___0 ;

  {
  tmp___0 = rename(from_path, to_path);
  if (tmp___0 != 0) {
    tmp = __errno_location();
    return ((*tmp));
  }
  return (0);
}
}
apr_status_t apr_os_file_get(apr_os_file_t *thefile , apr_file_t *file ) 
{ 

  {
  (*thefile) = file->filedes;
  return (0);
}
}
apr_status_t apr_os_file_put(apr_file_t **file , apr_os_file_t *thefile , apr_int32_t flags ,
                             apr_pool_t *pool ) 
{ int *dafile ;
  void *tmp ;
  apr_status_t rv ;

  {
  dafile = thefile;
  tmp = apr_palloc(pool, sizeof(apr_file_t ));
  (*file) = (apr_file_t *)memset(tmp, 0, sizeof(apr_file_t ));
  ((*file))->pool = pool;
  ((*file))->eof_hit = 0;
  ((*file))->blocking = (enum __anonenum_blocking_60 )0;
  ((*file))->timeout = -1LL;
  ((*file))->ungetchar = -1;
  ((*file))->filedes = (*dafile);
  ((*file))->flags = flags;
  ((*file))->buffered = (flags & 128) > 0;
  if (((*file))->buffered) {
    ((*file))->buffer = (char *)apr_palloc(pool, 4096U);
    if (((*file))->flags & 512) {
      rv = apr_thread_mutex_create(& ((*file))->thlock, 0U, pool);
      if (rv) {
        return (rv);
      }
    }
  }
  return (0);
}
}
apr_status_t apr_file_eof(apr_file_t *fptr ) 
{ 

  {
  if (fptr->eof_hit == 1) {
    return (70014);
  }
  return (0);
}
}
apr_status_t apr_file_open_stderr(apr_file_t **thefile , apr_pool_t *pool ) 
{ int fd ;
  apr_status_t tmp ;

  {
  fd = 2;
  tmp = apr_os_file_put(thefile, & fd, 0, pool);
  return (tmp);
}
}
apr_status_t apr_file_open_stdout(apr_file_t **thefile , apr_pool_t *pool ) 
{ int fd ;
  apr_status_t tmp ;

  {
  fd = 1;
  tmp = apr_os_file_put(thefile, & fd, 0, pool);
  return (tmp);
}
}
apr_status_t apr_file_open_stdin(apr_file_t **thefile , apr_pool_t *pool ) 
{ int fd ;
  apr_status_t tmp ;

  {
  fd = 0;
  tmp = apr_os_file_put(thefile, & fd, 0, pool);
  return (tmp);
}
}
apr_status_t apr_file_inherit_set(apr_file_t *thefile ) 
{ 

  {
  if (! (thefile->flags & 16777216)) {
    thefile->flags = thefile->flags | 16777216;
    apr_pool_child_cleanup_set(thefile->pool, (void const   *)((void *)thefile), & apr_unix_file_cleanup,
                               & apr_pool_cleanup_null);
  }
  return (0);
}
}
void apr_file_set_inherit(apr_file_t *thefile ) 
{ 

  {
  apr_file_inherit_set(thefile);
  return;
}
}
apr_status_t apr_file_inherit_unset(apr_file_t *thefile ) 
{ 

  {
  if (thefile->flags & 16777216) {
    thefile->flags = thefile->flags & -16777217;
    apr_pool_child_cleanup_set(thefile->pool, (void const   *)((void *)thefile), & apr_unix_file_cleanup,
                               & apr_unix_file_cleanup);
  }
  return (0);
}
}
void apr_file_unset_inherit(apr_file_t *thefile ) 
{ 

  {
  apr_file_inherit_unset(thefile);
  return;
}
}
apr_pool_t *apr_file_pool_get(apr_file_t const   *ob ) 
{ 

  {
  return (ob->pool);
}
}
#pragma merger(0,"/tmp/cil-iZJM8B9q.i","-g -pthread")
extern int mkfifo(char const   *__path , __mode_t __mode ) ;
extern int pipe(int *__pipedes ) ;
static apr_status_t pipeblock(apr_file_t *thepipe ) 
{ int fd_flags ;
  int *tmp ;
  int tmp___0 ;

  {
  fd_flags = fcntl(thepipe->filedes, 3, 0);
  fd_flags &= -2049;
  tmp___0 = fcntl(thepipe->filedes, 4, fd_flags);
  if (tmp___0 == -1) {
    tmp = __errno_location();
    return ((*tmp));
  }
  thepipe->blocking = (enum __anonenum_blocking_60 )2;
  return (0);
}
}
static apr_status_t pipenonblock(apr_file_t *thepipe ) 
{ int fd_flags ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  tmp = fcntl(thepipe->filedes, 3, 0);
  fd_flags = tmp;
  fd_flags |= 2048;
  tmp___1 = fcntl(thepipe->filedes, 4, fd_flags);
  if (tmp___1 == -1) {
    tmp___0 = __errno_location();
    return ((*tmp___0));
  }
  thepipe->blocking = (enum __anonenum_blocking_60 )1;
  return (0);
}
}
apr_status_t apr_file_pipe_timeout_set(apr_file_t *thepipe , apr_interval_time_t timeout ) 
{ apr_status_t tmp ;
  apr_status_t tmp___0 ;

  {
  if (thepipe->is_pipe == 1) {
    thepipe->timeout = timeout;
    if (timeout >= 0LL) {
      if ((int )thepipe->blocking != 1) {
        tmp = pipenonblock(thepipe);
        return (tmp);
      }
    } else {
      if ((int )thepipe->blocking != 2) {
        tmp___0 = pipeblock(thepipe);
        return (tmp___0);
      }
    }
    return (0);
  }
  return (22);
}
}
apr_status_t apr_file_pipe_timeout_get(apr_file_t *thepipe , apr_interval_time_t *timeout ) 
{ 

  {
  if (thepipe->is_pipe == 1) {
    (*timeout) = thepipe->timeout;
    return (0);
  }
  return (22);
}
}
apr_status_t apr_os_pipe_put(apr_file_t **file , apr_os_file_t *thefile , apr_pool_t *pool ) 
{ int *dafile ;
  void *tmp ;

  {
  dafile = thefile;
  tmp = apr_palloc(pool, sizeof(apr_file_t ));
  (*file) = (apr_file_t *)memset(tmp, 0, sizeof(apr_file_t ));
  ((*file))->pool = pool;
  ((*file))->eof_hit = 0;
  ((*file))->is_pipe = 1;
  ((*file))->blocking = (enum __anonenum_blocking_60 )0;
  ((*file))->timeout = -1LL;
  ((*file))->ungetchar = -1;
  ((*file))->filedes = (*dafile);
  ((*file))->flags = 0;
  ((*file))->buffered = 0;
  ((*file))->thlock = (struct apr_thread_mutex_t *)((void *)0);
  return (0);
}
}
apr_status_t apr_file_pipe_create(apr_file_t **in , apr_file_t **out , apr_pool_t *pool ) 
{ int filedes[2] ;
  int *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___3 ;

  {
  tmp___0 = pipe(filedes);
  if (tmp___0 == -1) {
    tmp = __errno_location();
    return ((*tmp));
  }
  tmp___1 = apr_palloc(pool, sizeof(apr_file_t ));
  (*in) = (apr_file_t *)memset(tmp___1, 0, sizeof(apr_file_t ));
  ((*in))->pool = pool;
  ((*in))->filedes = filedes[0];
  ((*in))->is_pipe = 1;
  ((*in))->fname = (char *)((void *)0);
  ((*in))->buffered = 0;
  ((*in))->blocking = (enum __anonenum_blocking_60 )2;
  ((*in))->timeout = -1LL;
  ((*in))->ungetchar = -1;
  ((*in))->thlock = (struct apr_thread_mutex_t *)((void *)0);
  tmp___3 = apr_palloc(pool, sizeof(apr_file_t ));
  (*out) = (apr_file_t *)memset(tmp___3, 0, sizeof(apr_file_t ));
  ((*out))->pool = pool;
  ((*out))->filedes = filedes[1];
  ((*out))->is_pipe = 1;
  ((*out))->fname = (char *)((void *)0);
  ((*out))->buffered = 0;
  ((*out))->blocking = (enum __anonenum_blocking_60 )2;
  ((*out))->timeout = -1LL;
  ((*out))->thlock = (struct apr_thread_mutex_t *)((void *)0);
  apr_pool_cleanup_register(((*in))->pool, (void const   *)((void *)(*in)), & apr_unix_file_cleanup,
                            & apr_pool_cleanup_null);
  apr_pool_cleanup_register(((*out))->pool, (void const   *)((void *)(*out)), & apr_unix_file_cleanup,
                            & apr_pool_cleanup_null);
  return (0);
}
}
apr_status_t apr_file_namedpipe_create(char const   *filename , apr_fileperms_t perm ,
                                       apr_pool_t *pool ) 
{ mode_t mode ;
  mode_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  tmp = apr_unix_perms2mode(perm);
  mode = tmp;
  tmp___1 = mkfifo(filename, mode);
  if (tmp___1 == -1) {
    tmp___0 = __errno_location();
    return ((*tmp___0));
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-WKelat86.i","-g -pthread")
extern ssize_t writev(int __fd , struct iovec  const  *__vector , int __count ) ;
extern __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
apr_status_t apr_wait_for_io_or_timeout(apr_file_t *f , apr_socket_t *s , int for_read ) ;
apr_status_t apr_file_read(apr_file_t *thefile , void *buf , apr_size_t *nbytes ) 
{ apr_ssize_t rv ;
  apr_size_t bytes_read ;
  char *pos ;
  apr_uint64_t blocksize ;
  apr_uint64_t size ;
  int bytesread ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  apr_status_t arv ;
  apr_status_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
  if ((*nbytes) <= 0U) {
    (*nbytes) = 0U;
    return (0);
  }
  if (thefile->buffered) {
    pos = (char *)buf;
    size = (unsigned long long )(*nbytes);
    if (thefile->thlock) {
      apr_thread_mutex_lock(thefile->thlock);
    }
    if (thefile->direction == 1) {
      apr_file_flush(thefile);
      thefile->bufpos = 0;
      thefile->direction = 0;
      thefile->dataRead = 0UL;
    }
    rv = 0;
    if (thefile->ungetchar != -1) {
      (*pos) = (char )thefile->ungetchar;
      pos ++;
      size --;
      thefile->ungetchar = -1;
    }
    while (1) {
      if (rv == 0) {
        if (! (size > 0ULL)) {
          goto _L;
        }
      } else {
        _L: 
        break;
      }
      if ((unsigned long )thefile->bufpos >= thefile->dataRead) {
        tmp = read(thefile->filedes, (void *)thefile->buffer, 4096U);
        bytesread = tmp;
        if (bytesread == 0) {
          thefile->eof_hit = 1;
          rv = 70014;
          break;
        } else {
          if (bytesread == -1) {
            tmp___0 = __errno_location();
            rv = (*tmp___0);
            break;
          }
        }
        thefile->dataRead = (unsigned long )bytesread;
        thefile->filePtr = thefile->filePtr + thefile->dataRead;
        thefile->bufpos = 0;
      }
      if (size > (unsigned long long )(thefile->dataRead - (unsigned long )thefile->bufpos)) {
        blocksize = (unsigned long long )(thefile->dataRead - (unsigned long )thefile->bufpos);
      } else {
        blocksize = size;
      }
      memcpy((void * __restrict  )pos, (void const   * __restrict  )(thefile->buffer +
                                                                     thefile->bufpos),
             (unsigned int )blocksize);
      thefile->bufpos = (int )((unsigned long long )thefile->bufpos + blocksize);
      pos += blocksize;
      size -= blocksize;
    }
    (*nbytes) = (unsigned int )(pos - (char *)buf);
    if ((*nbytes)) {
      rv = 0;
    }
    if (thefile->thlock) {
      apr_thread_mutex_unlock(thefile->thlock);
    }
    return (rv);
  } else {
    bytes_read = 0U;
    if (thefile->ungetchar != -1) {
      bytes_read = 1U;
      (*((char *)buf)) = (char )thefile->ungetchar;
      buf = (void *)((char *)buf + 1);
      (*nbytes) --;
      thefile->ungetchar = -1;
      if ((*nbytes) == 0U) {
        (*nbytes) = bytes_read;
        return (0);
      }
    }
    while (1) {
      rv = read(thefile->filedes, buf, (*nbytes));
      if (rv == -1) {
        tmp___1 = __errno_location();
        if (! ((*tmp___1) == 4)) {
          goto _L___0;
        }
      } else {
        _L___0: 
        break;
      }
    }
    if (rv == -1) {
      tmp___4 = __errno_location();
      if ((*tmp___4) == 11) {
        goto _L___4;
      } else {
        tmp___5 = __errno_location();
        if ((*tmp___5) == 11) {
          _L___4: 
          if (thefile->timeout != 0LL) {
            tmp___2 = apr_wait_for_io_or_timeout(thefile, (apr_socket_t *)((void *)0),
                                                 1);
            arv = tmp___2;
            if (arv != 0) {
              (*nbytes) = bytes_read;
              return (arv);
            } else {
              while (1) {
                rv = read(thefile->filedes, buf, (*nbytes));
                if (rv == -1) {
                  tmp___3 = __errno_location();
                  if (! ((*tmp___3) == 4)) {
                    goto _L___1;
                  }
                } else {
                  _L___1: 
                  break;
                }
              }
            }
          } else {
            goto _L___3;
          }
        } else {
          goto _L___3;
        }
      }
    } else {
      _L___3: ;
    }
    (*nbytes) = bytes_read;
    if (rv == 0) {
      thefile->eof_hit = 1;
      return (70014);
    }
    if (rv > 0) {
      (*nbytes) += (unsigned int )rv;
      return (0);
    }
    tmp___6 = __errno_location();
    return ((*tmp___6));
  }
}
}
apr_status_t apr_file_write(apr_file_t *thefile , void const   *buf , apr_size_t *nbytes ) 
{ apr_size_t rv ;
  char *pos ;
  int blocksize ;
  int size ;
  apr_int64_t offset ;
  int *tmp ;
  apr_status_t arv ;
  apr_status_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  if (thefile->buffered) {
    pos = (char *)buf;
    size = (int )(*nbytes);
    if (thefile->thlock) {
      apr_thread_mutex_lock(thefile->thlock);
    }
    if (thefile->direction == 0) {
      offset = (long long )((thefile->filePtr - thefile->dataRead) + (unsigned long )thefile->bufpos);
      if (offset != (long long )thefile->filePtr) {
        lseek(thefile->filedes, (long )offset, 0);
      }
      thefile->dataRead = 0UL;
      thefile->bufpos = (int )thefile->dataRead;
      thefile->direction = 1;
    }
    rv = 0U;
    while (1) {
      if (rv == 0U) {
        if (! (size > 0)) {
          goto _L;
        }
      } else {
        _L: 
        break;
      }
      if (thefile->bufpos == 4096) {
        apr_file_flush(thefile);
      }
      if (size > 4096 - thefile->bufpos) {
        blocksize = 4096 - thefile->bufpos;
      } else {
        blocksize = size;
      }
      memcpy((void * __restrict  )(thefile->buffer + thefile->bufpos), (void const   * __restrict  )pos,
             (unsigned int )blocksize);
      thefile->bufpos = thefile->bufpos + blocksize;
      pos += blocksize;
      size -= blocksize;
    }
    if (thefile->thlock) {
      apr_thread_mutex_unlock(thefile->thlock);
    }
    return ((int )rv);
  } else {
    while (1) {
      rv = (apr_size_t )write(thefile->filedes, buf, (*nbytes));
      if (rv == 4294967295U) {
        tmp = __errno_location();
        if (! ((*tmp) == 4)) {
          goto _L___0;
        }
      } else {
        _L___0: 
        break;
      }
    }
    if (rv == 4294967295U) {
      tmp___2 = __errno_location();
      if ((*tmp___2) == 11) {
        goto _L___4;
      } else {
        tmp___3 = __errno_location();
        if ((*tmp___3) == 11) {
          _L___4: 
          if (thefile->timeout != 0LL) {
            tmp___0 = apr_wait_for_io_or_timeout(thefile, (apr_socket_t *)((void *)0),
                                                 0);
            arv = tmp___0;
            if (arv != 0) {
              (*nbytes) = 0U;
              return (arv);
            } else {
              while (1) {
                rv = (apr_size_t )write(thefile->filedes, buf, (*nbytes));
                if (rv == 4294967295U) {
                  tmp___1 = __errno_location();
                  if (! ((*tmp___1) == 4)) {
                    goto _L___1;
                  }
                } else {
                  _L___1: 
                  break;
                }
              }
            }
          } else {
            goto _L___3;
          }
        } else {
          goto _L___3;
        }
      }
    } else {
      _L___3: ;
    }
    if (rv == 4294967295U) {
      (*nbytes) = 0U;
      tmp___4 = __errno_location();
      return ((*tmp___4));
    }
    (*nbytes) = rv;
    return (0);
  }
}
}
apr_status_t apr_file_writev(apr_file_t *thefile , struct iovec  const  *vec , apr_size_t nvec ,
                             apr_size_t *nbytes ) 
{ int bytes ;
  int *tmp ;

  {
  bytes = writev(thefile->filedes, vec, (int )nvec);
  if (bytes < 0) {
    (*nbytes) = 0U;
    tmp = __errno_location();
    return ((*tmp));
  } else {
    (*nbytes) = (unsigned int )bytes;
    return (0);
  }
}
}
apr_status_t apr_file_putc(char ch , apr_file_t *thefile ) 
{ apr_size_t nbytes ;
  apr_status_t tmp ;

  {
  nbytes = 1U;
  tmp = apr_file_write(thefile, (void const   *)(& ch), & nbytes);
  return (tmp);
}
}
apr_status_t apr_file_ungetc(char ch , apr_file_t *thefile ) 
{ 

  {
  thefile->ungetchar = (int )((unsigned char )ch);
  return (0);
}
}
apr_status_t apr_file_getc(char *ch , apr_file_t *thefile ) 
{ apr_size_t nbytes ;
  apr_status_t tmp ;

  {
  nbytes = 1U;
  tmp = apr_file_read(thefile, (void *)ch, & nbytes);
  return (tmp);
}
}
apr_status_t apr_file_puts(char const   *str , apr_file_t *thefile ) 
{ apr_size_t nbytes ;
  apr_size_t tmp ;
  apr_status_t tmp___0 ;

  {
  tmp = strlen(str);
  nbytes = tmp;
  tmp___0 = apr_file_write(thefile, (void const   *)str, & nbytes);
  return (tmp___0);
}
}
apr_status_t apr_file_flush(apr_file_t *thefile ) 
{ apr_int64_t written ;
  int *tmp ;
  int *tmp___0 ;

  {
  if (thefile->buffered) {
    written = 0LL;
    if (thefile->direction == 1) {
      if (thefile->bufpos) {
        while (1) {
          written = (apr_int64_t )write(thefile->filedes, (void const   *)thefile->buffer,
                                        (unsigned int )thefile->bufpos);
          if (written == -1LL) {
            tmp = __errno_location();
            if (! ((*tmp) == 4)) {
              goto _L;
            }
          } else {
            _L: 
            break;
          }
        }
        if (written == -1LL) {
          tmp___0 = __errno_location();
          return ((*tmp___0));
        }
        thefile->filePtr = (unsigned long )((long long )thefile->filePtr + written);
        thefile->bufpos = 0;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
  }
  return (0);
}
}
apr_status_t apr_file_gets(char *str , int len , apr_file_t *thefile ) 
{ apr_status_t rv ;
  apr_size_t nbytes ;
  char *final ;

  {
  rv = 0;
  final = (str + len) - 1;
  if (len <= 1) {
    return (0);
  }
  while ((unsigned int )str < (unsigned int )final) {
    nbytes = 1U;
    rv = apr_file_read(thefile, (void *)str, & nbytes);
    if (rv != 0) {
      break;
    }
    if ((int )(*str) == 10) {
      str ++;
      break;
    }
    str ++;
  }
  (*str) = (char )'\000';
  return (rv);
}
}
int ( /* format attribute */  apr_file_printf)(apr_file_t *fptr , char const   *format 
                                               , ...) 
{ apr_status_t cc ;
  va_list ap ;
  char *buf ;
  int len ;
  int tmp ;

  {
  buf = (char *)malloc(8192U);
  if ((unsigned int )buf == (unsigned int )((void *)0)) {
    return (0);
  }
  __builtin_stdarg_start(ap, format);
  len = apr_vsnprintf(buf, 8192U, format, ap);
  cc = apr_file_puts((char const   *)buf, fptr);
  __builtin_va_end(ap);
  free((void *)buf);
  if (cc == 0) {
    tmp = len;
  } else {
    tmp = -1;
  }
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-QzoLvxP0.i","-g -pthread")
extern int ftruncate(int __fd , __off_t __length ) ;
static apr_status_t setptr(apr_file_t *thefile , unsigned long pos ) 
{ long newbufpos ;
  int rc ;
  int *tmp ;

  {
  if (thefile->direction == 1) {
    apr_file_flush(thefile);
    thefile->dataRead = 0UL;
    thefile->direction = (int )thefile->dataRead;
    thefile->bufpos = thefile->direction;
  }
  newbufpos = (long )(pos - (thefile->filePtr - thefile->dataRead));
  if (newbufpos >= 0L) {
    if ((unsigned long )newbufpos <= thefile->dataRead) {
      thefile->bufpos = (int )newbufpos;
      rc = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    rc = (int )lseek(thefile->filedes, (long )pos, 0);
    if (rc != -1) {
      thefile->dataRead = 0UL;
      thefile->bufpos = (int )thefile->dataRead;
      thefile->filePtr = pos;
      rc = 0;
    } else {
      tmp = __errno_location();
      rc = (*tmp);
    }
  }
  return (rc);
}
}
apr_status_t apr_file_seek(apr_file_t *thefile , apr_seek_where_t where , apr_off_t *offset ) 
{ apr_off_t rv ;
  int rc ;
  apr_finfo_t finfo ;
  int *tmp ;

  {
  thefile->eof_hit = 0;
  if (thefile->buffered) {
    rc = 22;
    switch (where) {
    case 0: 
    rc = setptr(thefile, (unsigned long )(*offset));
    break;
    case 1: 
    rc = setptr(thefile, ((thefile->filePtr - thefile->dataRead) + (unsigned long )thefile->bufpos) +
                         (unsigned long )(*offset));
    break;
    case 2: 
    rc = apr_file_info_get(& finfo, 256, thefile);
    if (rc == 0) {
      rc = setptr(thefile, (unsigned long )(finfo.size - (*offset)));
    }
    break;
    }
    (*offset) = (long )((thefile->filePtr - thefile->dataRead) + (unsigned long )thefile->bufpos);
    return (rc);
  } else {
    rv = lseek(thefile->filedes, (*offset), where);
    if (rv == -1L) {
      (*offset) = -1L;
      tmp = __errno_location();
      return ((*tmp));
    } else {
      (*offset) = rv;
      return (0);
    }
  }
}
}
apr_status_t apr_file_trunc(apr_file_t *fp , apr_off_t offset ) 
{ int *tmp ;
  int tmp___0 ;
  apr_status_t tmp___1 ;

  {
  tmp___0 = ftruncate(fp->filedes, offset);
  if (tmp___0 == -1) {
    tmp = __errno_location();
    return ((*tmp));
  }
  tmp___1 = setptr(fp, (unsigned long )offset);
  return (tmp___1);
}
}
#pragma merger(0,"/tmp/cil-SRNGPrQ8.i","-g -pthread")
char const   *apr_inet_ntop(int af , void const   *src , char *dst , apr_size_t size ) ;
static char const   *inet_ntop4(unsigned char const   *src , char *dst , apr_size_t size ) ;
static char const   *inet_ntop6(unsigned char const   *src , char *dst , apr_size_t size ) ;
char const   *apr_inet_ntop(int af , void const   *src , char *dst , apr_size_t size ) 
{ char const   *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;

  {
  switch (af) {
  case 2: 
  tmp = inet_ntop4((unsigned char const   *)src, dst, size);
  return (tmp);
  case 10: 
  tmp___0 = inet_ntop6((unsigned char const   *)src, dst, size);
  return (tmp___0);
  default: 
  tmp___1 = __errno_location();
  (*tmp___1) = 97;
  return ((char const   *)((void *)0));
  }
}
}
static char const   *inet_ntop4(unsigned char const   *src , char *dst , apr_size_t size ) 
{ apr_size_t MIN_SIZE ;
  int n ;
  char *next ;
  int *tmp ;
  unsigned char u___0 ;
  unsigned char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  MIN_SIZE = 16U;
  n = 0;
  next = dst;
  if (size < MIN_SIZE) {
    tmp = __errno_location();
    (*tmp) = 28;
    return ((char const   *)((void *)0));
  }
  while (1) {
    tmp___0 = src;
    src ++;
    u___0 = (unsigned char )(*tmp___0);
    if ((int )u___0 > 99) {
      tmp___1 = next;
      next ++;
      (*tmp___1) = (char )(48 + (int )u___0 / 100);
      u___0 = (unsigned char )((int )u___0 % 100);
      tmp___2 = next;
      next ++;
      (*tmp___2) = (char )(48 + (int )u___0 / 10);
      u___0 = (unsigned char )((int )u___0 % 10);
    } else {
      if ((int )u___0 > 9) {
        tmp___3 = next;
        next ++;
        (*tmp___3) = (char )(48 + (int )u___0 / 10);
        u___0 = (unsigned char )((int )u___0 % 10);
      }
    }
    tmp___4 = next;
    next ++;
    (*tmp___4) = (char )(48 + (int )u___0);
    tmp___5 = next;
    next ++;
    (*tmp___5) = (char )'.';
    n ++;
    if (! (n < 4)) {
      break;
    }
  }
  next --;
  (*next) = (char)0;
  return ((char const   *)dst);
}
}
static char const   *inet_ntop6(unsigned char const   *src , char *dst , apr_size_t size ) 
{ char tmp[(int )sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")] ;
  char *tp ;
  struct __anonstruct_best_63 best ;
  struct __anonstruct_best_63 cur ;
  unsigned int words[(int )(16U / sizeof(apr_int16_t ))] ;
  int i ;
  unsigned char const   *next_src ;
  unsigned char const   *src_end ;
  unsigned int *next_dest ;
  unsigned int next_word ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;

  {
  next_src = src;
  src_end = src + 16;
  next_dest = words;
  best.base = -1;
  cur.base = -1;
  i = 0;
  while (1) {
    tmp___0 = next_src;
    next_src ++;
    next_word = (unsigned int )(*tmp___0);
    next_word <<= 8;
    tmp___1 = next_src;
    next_src ++;
    next_word |= (unsigned int )(*tmp___1);
    tmp___2 = next_dest;
    next_dest ++;
    (*tmp___2) = next_word;
    if (next_word == 0U) {
      if (cur.base == -1) {
        cur.base = i;
        cur.len = 1;
      } else {
        cur.len ++;
      }
    } else {
      if (cur.base != -1) {
        if (best.base == -1) {
          goto _L;
        } else {
          if (cur.len > best.len) {
            _L: 
            best = cur;
          }
        }
        cur.base = -1;
      }
    }
    i ++;
    if (! ((unsigned int )next_src < (unsigned int )src_end)) {
      break;
    }
  }
  if (cur.base != -1) {
    if (best.base == -1) {
      goto _L___0;
    } else {
      if (cur.len > best.len) {
        _L___0: 
        best = cur;
      }
    }
  }
  if (best.base != -1) {
    if (best.len < 2) {
      best.base = -1;
    } else {
      goto _L___1;
    }
  } else {
    _L___1: ;
  }
  tp = tmp;
  i = 0;
  while ((unsigned int )i < 16U / sizeof(apr_int16_t )) {
    if (i == best.base) {
      tmp___3 = tp;
      tp ++;
      (*tmp___3) = (char )':';
      i += best.len;
      goto __Cont;
    }
    if (i != 0) {
      tmp___4 = tp;
      tp ++;
      (*tmp___4) = (char )':';
    }
    if (i == 6) {
      if (best.base == 0) {
        if (best.len == 6) {
          goto _L___3;
        } else {
          if (best.len == 5) {
            if (words[5] == 65535U) {
              _L___3: 
              tmp___5 = inet_ntop4(src + 12, tp, sizeof(tmp) - (unsigned int )(tp -
                                                                               tmp));
              if (! tmp___5) {
                return ((char const   *)((void *)0));
              }
              tmp___6 = strlen((char const   *)tp);
              tp += tmp___6;
              break;
            } else {
              goto _L___4;
            }
          } else {
            _L___4: 
            goto _L___5;
          }
        }
      } else {
        goto _L___5;
      }
    } else {
      _L___5: ;
    }
    tmp___7 = apr_snprintf(tp, sizeof(tmp) - (unsigned int )(tp - tmp), "%x", words[i]);
    tp += tmp___7;
    i ++;
    __Cont: ;
  }
  if (best.base != -1) {
    if ((unsigned int )(best.base + best.len) == 16U / sizeof(apr_int16_t )) {
      tmp___8 = tp;
      tp ++;
      (*tmp___8) = (char )':';
    } else {
      goto _L___6;
    }
  } else {
    _L___6: ;
  }
  tmp___9 = tp;
  tp ++;
  (*tmp___9) = (char )'\000';
  if ((unsigned int )(tp - tmp) > size) {
    tmp___10 = __errno_location();
    (*tmp___10) = 28;
    return ((char const   *)((void *)0));
  }
  strcpy((char * __restrict  )dst, (char const   * __restrict  )(tmp));
  return ((char const   *)dst);
}
}
#pragma merger(0,"/tmp/cil-IIrG3fMc.i","-g -pthread")
int apr_inet_pton(int af , char const   *src , void *dst ) ;
static int inet_pton4(char const   *src , unsigned char *dst ) ;
static int inet_pton6(char const   *src , unsigned char *dst ) ;
int apr_inet_pton(int af , char const   *src , void *dst ) 
{ int tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
  switch (af) {
  case 2: 
  tmp = inet_pton4(src, (unsigned char *)dst);
  return (tmp);
  case 10: 
  tmp___0 = inet_pton6(src, (unsigned char *)dst);
  return (tmp___0);
  default: 
  tmp___1 = __errno_location();
  (*tmp___1) = 97;
  return (-1);
  }
}
}
static char const   digits[11]  = 
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
static int inet_pton4(char const   *src , unsigned char *dst ) 
{ int saw_digit ;
  int octets ;
  int ch ;
  unsigned char tmp[4] ;
  unsigned char *tp ;
  char const   *pch ;
  unsigned int new ;
  char const   *tmp___0 ;

  {
  saw_digit = 0;
  octets = 0;
  tp = tmp;
  (*tp) = (unsigned char)0;
  while (1) {
    tmp___0 = src;
    src ++;
    ch = (int )(*tmp___0);
    if (! (ch != 0)) {
      break;
    }
    pch = strchr(digits, ch);
    if ((unsigned int )pch != (unsigned int )((void *)0)) {
      new = (unsigned int )((int )(*tp) * 10 + (pch - digits));
      if (new > 255U) {
        return (0);
      }
      (*tp) = (unsigned char )new;
      if (! saw_digit) {
        octets ++;
        if (octets > 4) {
          return (0);
        }
        saw_digit = 1;
      }
    } else {
      if (ch == 46) {
        if (saw_digit) {
          if (octets == 4) {
            return (0);
          }
          tp ++;
          (*tp) = (unsigned char)0;
          saw_digit = 0;
        } else {
          goto _L;
        }
      } else {
        _L: 
        return (0);
      }
    }
  }
  if (octets < 4) {
    return (0);
  }
  memcpy((void * __restrict  )dst, (void const   * __restrict  )(tmp), 4U);
  return (1);
}
}
static char const   xdigits_l[17]  = 
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
static char const   xdigits_u[17]  = 
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'\000'};
static int inet_pton6(char const   *src , unsigned char *dst ) 
{ unsigned char tmp[16] ;
  unsigned char *tp ;
  unsigned char *endp ;
  unsigned char *colonp ;
  char const   *xdigits ;
  char const   *curtok ;
  int ch ;
  int saw_xdigit ;
  unsigned int val ;
  char const   *pch ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  int n ;
  int i ;

  {
  tp = tmp;
  memset((void *)tp, '\000', 16U);
  endp = tp + 16;
  colonp = (unsigned char *)((void *)0);
  if ((int const   )(*src) == 58) {
    src ++;
    if ((int const   )(*src) != 58) {
      return (0);
    }
  }
  curtok = src;
  saw_xdigit = 0;
  val = 0U;
  while (1) {
    tmp___3 = src;
    src ++;
    ch = (int )(*tmp___3);
    if (! (ch != 0)) {
      break;
    }
    xdigits = xdigits_l;
    pch = strchr(xdigits, ch);
    if ((unsigned int )pch == (unsigned int )((void *)0)) {
      xdigits = xdigits_u;
      pch = strchr(xdigits, ch);
    }
    if ((unsigned int )pch != (unsigned int )((void *)0)) {
      val <<= 4;
      val |= (unsigned int )(pch - xdigits);
      if (val > 65535U) {
        return (0);
      }
      saw_xdigit = 1;
      continue;
    }
    if (ch == 58) {
      curtok = src;
      if (! saw_xdigit) {
        if (colonp) {
          return (0);
        }
        colonp = tp;
        continue;
      }
      if ((unsigned int )(tp + sizeof(apr_int16_t )) > (unsigned int )endp) {
        return (0);
      }
      tmp___0 = tp;
      tp ++;
      (*tmp___0) = (unsigned char )((int )((unsigned char )(val >> 8)) & 255);
      tmp___1 = tp;
      tp ++;
      (*tmp___1) = (unsigned char )((int )((unsigned char )val) & 255);
      saw_xdigit = 0;
      val = 0U;
      continue;
    }
    if (ch == 46) {
      if ((unsigned int )(tp + 4) <= (unsigned int )endp) {
        tmp___2 = inet_pton4(curtok, tp);
        if (tmp___2 > 0) {
          tp += 4;
          saw_xdigit = 0;
          break;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
    return (0);
  }
  if (saw_xdigit) {
    if ((unsigned int )(tp + sizeof(apr_int16_t )) > (unsigned int )endp) {
      return (0);
    }
    tmp___4 = tp;
    tp ++;
    (*tmp___4) = (unsigned char )((int )((unsigned char )(val >> 8)) & 255);
    tmp___5 = tp;
    tp ++;
    (*tmp___5) = (unsigned char )((int )((unsigned char )val) & 255);
  }
  if ((unsigned int )colonp != (unsigned int )((void *)0)) {
    n = tp - colonp;
    i = 1;
    while (i <= n) {
      (*(endp + - i)) = (*(colonp + (n - i)));
      (*(colonp + (n - i))) = (unsigned char)0;
      i ++;
    }
    tp = endp;
  }
  if ((unsigned int )tp != (unsigned int )endp) {
    return (0);
  }
  memcpy((void * __restrict  )dst, (void const   * __restrict  )(tmp), 16U);
  return (1);
}
}
#pragma merger(0,"/tmp/cil-tk2gvDkf.i","-g -pthread")
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
extern ssize_t sendfile(int __out_fd , int __in_fd , off_t *__offset , size_t __count ) ;
apr_status_t apr_socket_send(apr_socket_t *sock , char const   *buf , apr_size_t *len ) 
{ apr_ssize_t rv ;
  int *tmp ;
  apr_status_t arv ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  if (sock->netmask & 8192) {
    sock->netmask &= -8193;
    goto do_select;
  }
  while (1) {
    rv = write(sock->socketdes, (void const   *)buf, (*len));
    if (rv == -1) {
      tmp = __errno_location();
      if (! ((*tmp) == 4)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
  }
  if (rv == -1) {
    tmp___1 = __errno_location();
    if ((*tmp___1) == 11) {
      goto _L___3;
    } else {
      tmp___2 = __errno_location();
      if ((*tmp___2) == 11) {
        _L___3: 
        if (sock->timeout != 0LL) {
          do_select: 
          arv = apr_wait_for_io_or_timeout((apr_file_t *)((void *)0), sock, 0);
          if (arv != 0) {
            (*len) = 0U;
            return (arv);
          } else {
            while (1) {
              rv = write(sock->socketdes, (void const   *)buf, (*len));
              if (rv == -1) {
                tmp___0 = __errno_location();
                if (! ((*tmp___0) == 4)) {
                  goto _L___0;
                }
              } else {
                _L___0: 
                break;
              }
            }
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    }
  } else {
    _L___2: ;
  }
  if (rv == -1) {
    (*len) = 0U;
    tmp___3 = __errno_location();
    return ((*tmp___3));
  }
  if (sock->timeout) {
    if ((unsigned int )rv < (*len)) {
      sock->netmask |= 8192;
    } else {
      goto _L___4;
    }
  } else {
    _L___4: ;
  }
  (*len) = (unsigned int )rv;
  return (0);
}
}
apr_status_t apr_socket_recv(apr_socket_t *sock , char *buf , apr_size_t *len ) 
{ apr_ssize_t rv ;
  apr_status_t arv ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  if (sock->netmask & 4096) {
    sock->netmask &= -4097;
    goto do_select;
  }
  while (1) {
    rv = read(sock->socketdes, (void *)buf, (*len));
    if (rv == -1) {
      tmp = __errno_location();
      if (! ((*tmp) == 4)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
  }
  if (rv == -1) {
    tmp___1 = __errno_location();
    if ((*tmp___1) == 11) {
      goto _L___3;
    } else {
      tmp___2 = __errno_location();
      if ((*tmp___2) == 11) {
        _L___3: 
        if (sock->timeout != 0LL) {
          do_select: 
          arv = apr_wait_for_io_or_timeout((apr_file_t *)((void *)0), sock, 1);
          if (arv != 0) {
            (*len) = 0U;
            return (arv);
          } else {
            while (1) {
              rv = read(sock->socketdes, (void *)buf, (*len));
              if (rv == -1) {
                tmp___0 = __errno_location();
                if (! ((*tmp___0) == 4)) {
                  goto _L___0;
                }
              } else {
                _L___0: 
                break;
              }
            }
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    }
  } else {
    _L___2: ;
  }
  if (rv == -1) {
    (*len) = 0U;
    tmp___3 = __errno_location();
    return ((*tmp___3));
  }
  if (sock->timeout) {
    if ((unsigned int )rv < (*len)) {
      sock->netmask |= 4096;
    } else {
      goto _L___4;
    }
  } else {
    _L___4: ;
  }
  (*len) = (unsigned int )rv;
  if (rv == 0) {
    return (70014);
  }
  return (0);
}
}
apr_status_t apr_socket_sendto(apr_socket_t *sock , apr_sockaddr_t *where , apr_int32_t flags ,
                               char const   *buf , apr_size_t *len ) 
{ apr_ssize_t rv ;
  int *tmp ;
  apr_status_t arv ;
  apr_status_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  while (1) {
    rv = sendto(sock->socketdes, (void const   *)buf, (*len), flags, (struct sockaddr  const  * __restrict  )((struct sockaddr  const  *)(& where->sa)),
                where->salen);
    if (rv == -1) {
      tmp = __errno_location();
      if (! ((*tmp) == 4)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
  }
  if (rv == -1) {
    tmp___2 = __errno_location();
    if ((*tmp___2) == 11) {
      goto _L___3;
    } else {
      tmp___3 = __errno_location();
      if ((*tmp___3) == 11) {
        _L___3: 
        if (sock->timeout != 0LL) {
          tmp___0 = apr_wait_for_io_or_timeout((apr_file_t *)((void *)0), sock, 0);
          arv = tmp___0;
          if (arv != 0) {
            (*len) = 0U;
            return (arv);
          } else {
            while (1) {
              rv = sendto(sock->socketdes, (void const   *)buf, (*len), flags, (struct sockaddr  const  * __restrict  )((struct sockaddr  const  *)(& where->sa)),
                          where->salen);
              if (rv == -1) {
                tmp___1 = __errno_location();
                if (! ((*tmp___1) == 4)) {
                  goto _L___0;
                }
              } else {
                _L___0: 
                break;
              }
            }
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    }
  } else {
    _L___2: ;
  }
  if (rv == -1) {
    (*len) = 0U;
    tmp___4 = __errno_location();
    return ((*tmp___4));
  }
  (*len) = (unsigned int )rv;
  return (0);
}
}
apr_status_t apr_socket_recvfrom(apr_sockaddr_t *from , apr_socket_t *sock , apr_int32_t flags ,
                                 char *buf , apr_size_t *len ) 
{ apr_ssize_t rv ;
  int *tmp ;
  apr_status_t arv ;
  apr_status_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  while (1) {
    rv = recvfrom(sock->socketdes, (void * __restrict  )buf, (*len), flags, (struct sockaddr * __restrict  )((struct sockaddr *)(& from->sa)),
                  (socklen_t * __restrict  )(& from->salen));
    if (rv == -1) {
      tmp = __errno_location();
      if (! ((*tmp) == 4)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
  }
  if (rv == -1) {
    tmp___2 = __errno_location();
    if ((*tmp___2) == 11) {
      goto _L___3;
    } else {
      tmp___3 = __errno_location();
      if ((*tmp___3) == 11) {
        _L___3: 
        if (sock->timeout != 0LL) {
          tmp___0 = apr_wait_for_io_or_timeout((apr_file_t *)((void *)0), sock, 1);
          arv = tmp___0;
          if (arv != 0) {
            (*len) = 0U;
            return (arv);
          } else {
            while (1) {
              rv = recvfrom(sock->socketdes, (void * __restrict  )buf, (*len), flags,
                            (struct sockaddr * __restrict  )((struct sockaddr *)(& from->sa)),
                            (socklen_t * __restrict  )(& from->salen));
              if (rv == -1) {
                tmp___1 = __errno_location();
                if (! ((*tmp___1) == 4)) {
                  goto _L___0;
                }
              } else {
                _L___0: 
                break;
              }
            }
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    }
  } else {
    _L___2: ;
  }
  if (rv == -1) {
    (*len) = 0U;
    tmp___4 = __errno_location();
    return ((*tmp___4));
  }
  (*len) = (unsigned int )rv;
  if (rv == 0) {
    if (sock->type == 1) {
      return (70014);
    } else {
      goto _L___4;
    }
  } else {
    _L___4: ;
  }
  return (0);
}
}
apr_status_t apr_socket_sendv(apr_socket_t *sock , struct iovec  const  *vec , apr_int32_t nvec ,
                              apr_size_t *len ) 
{ apr_ssize_t rv ;
  apr_size_t requested_len ;
  apr_int32_t i ;
  int *tmp ;
  apr_status_t arv ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  requested_len = 0U;
  i = 0;
  while (i < nvec) {
    requested_len += (vec + i)->iov_len;
    i ++;
  }
  if (sock->netmask & 8192) {
    sock->netmask &= -8193;
    goto do_select;
  }
  while (1) {
    rv = writev(sock->socketdes, vec, nvec);
    if (rv == -1) {
      tmp = __errno_location();
      if (! ((*tmp) == 4)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
  }
  if (rv == -1) {
    tmp___1 = __errno_location();
    if ((*tmp___1) == 11) {
      goto _L___3;
    } else {
      tmp___2 = __errno_location();
      if ((*tmp___2) == 11) {
        _L___3: 
        if (sock->timeout != 0LL) {
          do_select: 
          arv = apr_wait_for_io_or_timeout((apr_file_t *)((void *)0), sock, 0);
          if (arv != 0) {
            (*len) = 0U;
            return (arv);
          } else {
            while (1) {
              rv = writev(sock->socketdes, vec, nvec);
              if (rv == -1) {
                tmp___0 = __errno_location();
                if (! ((*tmp___0) == 4)) {
                  goto _L___0;
                }
              } else {
                _L___0: 
                break;
              }
            }
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    }
  } else {
    _L___2: ;
  }
  if (rv == -1) {
    (*len) = 0U;
    tmp___3 = __errno_location();
    return ((*tmp___3));
  }
  if (sock->timeout) {
    if ((unsigned int )rv < requested_len) {
      sock->netmask |= 8192;
    } else {
      goto _L___4;
    }
  } else {
    _L___4: ;
  }
  (*len) = (unsigned int )rv;
  return (0);
}
}
static apr_hdtr_t no_hdtr  ;
apr_status_t apr_socket_sendfile(apr_socket_t *sock , apr_file_t *file , apr_hdtr_t *hdtr ,
                                 apr_off_t *offset , apr_size_t *len , apr_int32_t flags ) 
{ off_t off ;
  int rv ;
  int nbytes ;
  int total_hdrbytes ;
  int i ;
  apr_status_t arv ;
  apr_size_t hdrbytes ;
  int *tmp ;
  apr_status_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  apr_size_t trbytes ;
  int *tmp___6 ;
  int tmp___8 ;
  int *tmp___9 ;

  {
  off = (*offset);
  nbytes = 0;
  if (! hdtr) {
    hdtr = & no_hdtr;
  }
  flags = 0;
  if (hdtr->numheaders > 0) {
    rv = apr_socket_opt_set(sock, 1024, 1);
    if (rv != 0) {
      return (rv);
    }
    arv = apr_socket_sendv(sock, (struct iovec  const  *)hdtr->headers, hdtr->numheaders,
                           & hdrbytes);
    if (arv != 0) {
      (*len) = 0U;
      tmp = __errno_location();
      return ((*tmp));
    }
    nbytes = (int )((unsigned int )nbytes + hdrbytes);
    total_hdrbytes = 0;
    i = 0;
    while (i < hdtr->numheaders) {
      total_hdrbytes = (int )((unsigned int )total_hdrbytes + (hdtr->headers + i)->iov_len);
      i ++;
    }
    if (hdrbytes < (unsigned int )total_hdrbytes) {
      (*len) = hdrbytes;
      tmp___0 = apr_socket_opt_set(sock, 1024, 0);
      return (tmp___0);
    }
  }
  if (sock->netmask & 8192) {
    sock->netmask &= -8193;
    goto do_select;
  }
  while (1) {
    rv = sendfile(sock->socketdes, file->filedes, & off, (*len));
    if (rv == -1) {
      tmp___1 = __errno_location();
      if (! ((*tmp___1) == 4)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
  }
  if (rv == -1) {
    tmp___3 = __errno_location();
    if ((*tmp___3) == 11) {
      goto _L___3;
    } else {
      tmp___4 = __errno_location();
      if ((*tmp___4) == 11) {
        _L___3: 
        if (sock->timeout > 0LL) {
          do_select: 
          arv = apr_wait_for_io_or_timeout((apr_file_t *)((void *)0), sock, 0);
          if (arv != 0) {
            (*len) = 0U;
            return (arv);
          } else {
            while (1) {
              rv = sendfile(sock->socketdes, file->filedes, & off, (*len));
              if (rv == -1) {
                tmp___2 = __errno_location();
                if (! ((*tmp___2) == 4)) {
                  goto _L___0;
                }
              } else {
                _L___0: 
                break;
              }
            }
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    }
  } else {
    _L___2: ;
  }
  if (rv == -1) {
    (*len) = (unsigned int )nbytes;
    tmp___5 = __errno_location();
    rv = (*tmp___5);
    apr_socket_opt_set(sock, 1024, 0);
    return (rv);
  }
  nbytes += rv;
  if ((unsigned int )rv < (*len)) {
    (*len) = (unsigned int )nbytes;
    arv = apr_socket_opt_set(sock, 1024, 0);
    if (rv > 0) {
      if (sock->timeout) {
        sock->netmask |= 8192;
      }
      return (arv);
    } else {
      return (70014);
    }
  }
  if (hdtr->numtrailers > 0) {
    arv = apr_socket_sendv(sock, (struct iovec  const  *)hdtr->trailers, hdtr->numtrailers,
                           & trbytes);
    nbytes = (int )((unsigned int )nbytes + trbytes);
    if (arv != 0) {
      (*len) = (unsigned int )nbytes;
      tmp___6 = __errno_location();
      rv = (*tmp___6);
      apr_socket_opt_set(sock, 1024, 0);
      return (rv);
    }
  }
  apr_socket_opt_set(sock, 1024, 0);
  (*len) = (unsigned int )nbytes;
  if (rv < 0) {
    tmp___9 = __errno_location();
    tmp___8 = (*tmp___9);
  } else {
    tmp___8 = 0;
  }
  return (tmp___8);
}
}
apr_status_t apr_send(apr_socket_t *sock , char const   *buf , apr_size_t *len ) 
{ apr_status_t tmp ;

  {
  tmp = apr_socket_send(sock, buf, len);
  return (tmp);
}
}
apr_status_t apr_sendv(apr_socket_t *sock , struct iovec  const  *vec , apr_int32_t nvec ,
                       apr_size_t *len ) 
{ apr_status_t tmp ;

  {
  tmp = apr_socket_sendv(sock, vec, nvec, len);
  return (tmp);
}
}
apr_status_t apr_sendto(apr_socket_t *sock , apr_sockaddr_t *where , apr_int32_t flags ,
                        char const   *buf , apr_size_t *len ) 
{ apr_status_t tmp ;

  {
  tmp = apr_socket_sendto(sock, where, flags, buf, len);
  return (tmp);
}
}
apr_status_t apr_recvfrom(apr_sockaddr_t *from , apr_socket_t *sock , apr_int32_t flags ,
                          char *buf , apr_size_t *len ) 
{ apr_status_t tmp ;

  {
  tmp = apr_socket_recvfrom(from, sock, flags, buf, len);
  return (tmp);
}
}
apr_status_t apr_sendfile(apr_socket_t *sock , apr_file_t *file , apr_hdtr_t *hdtr ,
                          apr_off_t *offset , apr_size_t *len , apr_int32_t flags ) 
{ apr_status_t tmp ;

  {
  tmp = apr_socket_sendfile(sock, file, hdtr, offset, len, flags);
  return (tmp);
}
}
apr_status_t apr_recv(apr_socket_t *sock , char *buf , apr_size_t *len ) 
{ apr_status_t tmp ;

  {
  tmp = apr_socket_recv(sock, buf, len);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-IALr34Vv.i","-g -pthread")
extern int getsockname(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __len ) ;
extern int getpeername(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __len ) ;
extern uint16_t ntohs(uint16_t __netshort )  __attribute__((__const__)) ;
extern uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
extern in_addr_t inet_addr(char const   *__cp ) ;
extern int *__h_errno_location(void)  __attribute__((__const__)) ;
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
extern void freeaddrinfo(struct addrinfo *__ai ) ;
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
void apr_sockaddr_vars_set(apr_sockaddr_t *addr , int family , apr_port_t port ) ;
static apr_status_t get_local_addr(apr_socket_t *sock ) 
{ int *tmp ;
  int tmp___0 ;

  {
  (sock->local_addr)->salen = sizeof((sock->local_addr)->sa);
  tmp___0 = getsockname(sock->socketdes, (struct sockaddr * __restrict  )((struct sockaddr *)(& (sock->local_addr)->sa)),
                        (socklen_t * __restrict  )(& (sock->local_addr)->salen));
  if (tmp___0 < 0) {
    tmp = __errno_location();
    return ((*tmp));
  } else {
    sock->local_interface_unknown = 0;
    sock->local_port_unknown = sock->local_interface_unknown;
    (sock->local_addr)->port = ntohs((sock->local_addr)->sa.sin.sin_port);
    return (0);
  }
}
}
static apr_status_t get_remote_addr(apr_socket_t *sock ) 
{ int *tmp ;
  int tmp___0 ;

  {
  (sock->remote_addr)->salen = sizeof((sock->remote_addr)->sa);
  tmp___0 = getpeername(sock->socketdes, (struct sockaddr * __restrict  )((struct sockaddr *)(& (sock->remote_addr)->sa)),
                        (socklen_t * __restrict  )(& (sock->remote_addr)->salen));
  if (tmp___0 < 0) {
    tmp = __errno_location();
    return ((*tmp));
  } else {
    sock->remote_addr_unknown = 0;
    (sock->remote_addr)->port = ntohs((sock->remote_addr)->sa.sin.sin_port);
    return (0);
  }
}
}
apr_status_t apr_sockaddr_port_set(apr_sockaddr_t *sockaddr , apr_port_t port ) 
{ 

  {
  sockaddr->port = port;
  sockaddr->sa.sin.sin_port = htons(port);
  return (0);
}
}
apr_status_t apr_sockaddr_ip_set(apr_sockaddr_t *sockaddr , char const   *addr ) 
{ apr_uint32_t ipaddr ;
  int tmp ;
  int *tmp___0 ;

  {
  tmp = strcmp(addr, "0.0.0.0");
  if (! tmp) {
    sockaddr->sa.sin.sin_addr.s_addr = htonl(0U);
    return (0);
  }
  ipaddr = inet_addr(addr);
  if (ipaddr == 4294967295U) {
    tmp___0 = __errno_location();
    return ((*tmp___0));
  }
  sockaddr->sa.sin.sin_addr.s_addr = ipaddr;
  return (0);
}
}
apr_status_t apr_sockaddr_port_get(apr_port_t *port , apr_sockaddr_t *sockaddr ) 
{ 

  {
  (*port) = sockaddr->port;
  return (0);
}
}
apr_status_t apr_sockaddr_ip_get(char **addr , apr_sockaddr_t *sockaddr ) 
{ size_t tmp ;
  uint32_t tmp___0 ;

  {
  (*addr) = (char *)apr_palloc(sockaddr->pool, (unsigned int )sockaddr->addr_str_len);
  apr_inet_ntop(sockaddr->family, (void const   *)sockaddr->ipaddr_ptr, (*addr), (unsigned int )sockaddr->addr_str_len);
  if (sockaddr->family == 10) {
    if ((*((uint32_t const   *)((struct in6_addr *)sockaddr->ipaddr_ptr) + 0)) ==
        0U) {
      if ((*((uint32_t const   *)((struct in6_addr *)sockaddr->ipaddr_ptr) + 1)) ==
          0U) {
        tmp___0 = htonl(65535U);
        if ((*((uint32_t const   *)((struct in6_addr *)sockaddr->ipaddr_ptr) + 2)) ==
            (uint32_t const   )tmp___0) {
          tmp = strlen("::ffff:");
          (*addr) += tmp;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      goto _L;
    }
  } else {
    _L: ;
  }
  return (0);
}
}
void apr_sockaddr_vars_set(apr_sockaddr_t *addr , int family , apr_port_t port ) 
{ 

  {
  addr->family = family;
  addr->sa.sin.sin_family = (unsigned short )family;
  if (port) {
    addr->sa.sin.sin_port = htons(port);
    addr->port = port;
  }
  if (family == 2) {
    addr->salen = sizeof(struct sockaddr_in );
    addr->addr_str_len = 16;
    addr->ipaddr_ptr = (void *)(& addr->sa.sin.sin_addr);
    addr->ipaddr_len = (int )sizeof(struct in_addr );
  } else {
    if (family == 10) {
      addr->salen = sizeof(struct sockaddr_in6 );
      addr->addr_str_len = 46;
      addr->ipaddr_ptr = (void *)(& addr->sa.sin6.sin6_addr);
      addr->ipaddr_len = (int )sizeof(struct in6_addr );
    }
  }
  return;
}
}
apr_status_t apr_socket_addr_get(apr_sockaddr_t **sa , apr_interface_e which , apr_socket_t *sock ) 
{ apr_status_t rv ;
  apr_status_t tmp ;
  apr_status_t rv___0 ;
  apr_status_t tmp___0 ;

  {
  if ((int )which == 0) {
    if (sock->local_interface_unknown) {
      goto _L;
    } else {
      if (sock->local_port_unknown) {
        _L: 
        tmp = get_local_addr(sock);
        rv = tmp;
        if (rv != 0) {
          return (rv);
        }
      }
    }
    (*sa) = sock->local_addr;
  } else {
    if ((int )which == 1) {
      if (sock->remote_addr_unknown) {
        tmp___0 = get_remote_addr(sock);
        rv___0 = tmp___0;
        if (rv___0 != 0) {
          return (rv___0);
        }
      }
      (*sa) = sock->remote_addr;
    } else {
      (*sa) = (apr_sockaddr_t *)((void *)0);
      return (22);
    }
  }
  return (0);
}
}
apr_status_t apr_parse_addr_port(char **addr , char **scope_id , apr_port_t *port ,
                                 char const   *str , apr_pool_t *p ) 
{ char const   *ch ;
  char const   *lastchar ;
  int big_port ;
  apr_size_t addrlen ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  char const   *end_bracket ;
  char const   *tmp___1 ;
  struct in6_addr ipaddr ;
  char const   *scope_delim ;
  int tmp___2 ;

  {
  (*addr) = (char *)((void *)0);
  (*scope_id) = (char *)((void *)0);
  (*port) = (unsigned short)0;
  tmp = strlen(str);
  lastchar = (str + tmp) - 1;
  ch = lastchar;
  while (1) {
    if ((unsigned int )ch >= (unsigned int )str) {
      tmp___0 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___0) + (int )((unsigned char )(*ch)))) & 2048)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
    ch --;
  }
  if ((unsigned int )ch < (unsigned int )str) {
    big_port = atoi(str);
    if (big_port < 1) {
      goto _L___0;
    } else {
      if (big_port > 65535) {
        _L___0: 
        return (22);
      }
    }
    (*port) = (unsigned short )big_port;
    return (0);
  }
  if ((int const   )(*ch) == 58) {
    if ((unsigned int )ch < (unsigned int )lastchar) {
      if ((unsigned int )ch == (unsigned int )str) {
        return (22);
      }
      big_port = atoi(ch + 1);
      if (big_port < 1) {
        goto _L___1;
      } else {
        if (big_port > 65535) {
          _L___1: 
          return (22);
        }
      }
      (*port) = (unsigned short )big_port;
      lastchar = ch - 1;
    } else {
      goto _L___2;
    }
  } else {
    _L___2: ;
  }
  addrlen = (unsigned int )((lastchar - str) + 1);
  if ((int const   )(*str) == 91) {
    tmp___1 = (char const   *)memchr((void const   *)str, ']', addrlen);
    end_bracket = tmp___1;
    if (! end_bracket) {
      goto _L___3;
    } else {
      if ((unsigned int )end_bracket != (unsigned int )lastchar) {
        _L___3: 
        (*port) = (unsigned short)0;
        return (22);
      }
    }
    scope_delim = (char const   *)memchr((void const   *)str, '%', addrlen);
    if (scope_delim) {
      if ((unsigned int )scope_delim == (unsigned int )(end_bracket - 1)) {
        (*port) = (unsigned short)0;
        return (22);
      }
      addrlen = (unsigned int )((scope_delim - str) - 1);
      (*scope_id) = (char *)apr_palloc(p, (unsigned int )(end_bracket - scope_delim));
      memcpy((void * __restrict  )(*scope_id), (void const   * __restrict  )(scope_delim +
                                                                             1), (unsigned int )((end_bracket -
                                                                                                  scope_delim) -
                                                                                                 1));
      (*((*scope_id) + ((end_bracket - scope_delim) - 1))) = (char )'\000';
    } else {
      addrlen = addrlen - 2U;
    }
    (*addr) = (char *)apr_palloc(p, addrlen + 1U);
    memcpy((void * __restrict  )(*addr), (void const   * __restrict  )(str + 1), addrlen);
    (*((*addr) + addrlen)) = (char )'\000';
    tmp___2 = apr_inet_pton(10, (char const   *)(*addr), (void *)(& ipaddr));
    if (tmp___2 != 1) {
      (*addr) = (char *)((void *)0);
      (*scope_id) = (char *)((void *)0);
      (*port) = (unsigned short)0;
      return (22);
    }
  } else {
    (*addr) = (char *)apr_palloc(p, addrlen + 1U);
    memcpy((void * __restrict  )(*addr), (void const   * __restrict  )str, addrlen);
    (*((*addr) + addrlen)) = (char )'\000';
  }
  return (0);
}
}
static apr_status_t call_resolver(apr_sockaddr_t **sa , char const   *hostname , apr_int32_t family ,
                                  apr_port_t port , apr_int32_t flags , apr_pool_t *p ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *ai_list ;
  apr_sockaddr_t *prev_sa ;
  int error ;
  int *tmp ;
  apr_sockaddr_t *new_sa ;
  void *tmp___0 ;
  apr_sockaddr_t *tmp___1 ;

  {
  memset((void *)(& hints), 0, sizeof(hints));
  hints.ai_family = family;
  hints.ai_socktype = 1;
  error = getaddrinfo((char const   * __restrict  )hostname, (char const   * __restrict  )((void *)0),
                      (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& ai_list));
  if (error) {
    if (error == -11) {
      tmp = __errno_location();
      return ((*tmp));
    } else {
      error = - error;
      return (error + 670000);
    }
  }
  prev_sa = (apr_sockaddr_t *)((void *)0);
  ai = ai_list;
  while (ai) {
    tmp___0 = apr_palloc(p, sizeof(apr_sockaddr_t ));
    tmp___1 = (apr_sockaddr_t *)memset(tmp___0, 0, sizeof(apr_sockaddr_t ));
    new_sa = tmp___1;
    new_sa->pool = p;
    memcpy((void * __restrict  )(& new_sa->sa), (void const   * __restrict  )ai->ai_addr,
           ai->ai_addrlen);
    apr_sockaddr_vars_set(new_sa, ai->ai_family, port);
    if (! prev_sa) {
      new_sa->hostname = apr_pstrdup(p, hostname);
      (*sa) = new_sa;
    } else {
      prev_sa->next = new_sa;
    }
    prev_sa = new_sa;
    ai = ai->ai_next;
  }
  freeaddrinfo(ai_list);
  return (0);
}
}
static apr_status_t find_addresses(apr_sockaddr_t **sa , char const   *hostname ,
                                   apr_int32_t family , apr_port_t port , apr_int32_t flags ,
                                   apr_pool_t *p ) 
{ apr_status_t error ;
  apr_status_t tmp ;
  apr_status_t error___0 ;
  apr_status_t tmp___0 ;
  apr_status_t tmp___1 ;

  {
  if (flags & 1) {
    tmp = call_resolver(sa, hostname, 2, port, flags, p);
    error = tmp;
    if (error) {
      family = 10;
    } else {
      return (error);
    }
  } else {
    if (flags & 2) {
      tmp___0 = call_resolver(sa, hostname, 10, port, flags, p);
      error___0 = tmp___0;
      if (error___0) {
        family = 2;
      } else {
        return (0);
      }
    }
  }
  tmp___1 = call_resolver(sa, hostname, family, port, flags, p);
  return (tmp___1);
}
}
apr_status_t apr_sockaddr_info_get(apr_sockaddr_t **sa , char const   *hostname ,
                                   apr_int32_t family , apr_port_t port , apr_int32_t flags ,
                                   apr_pool_t *p ) 
{ apr_int32_t masked ;
  apr_status_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  (*sa) = (apr_sockaddr_t *)((void *)0);
  masked = flags & 3;
  if (masked) {
    if (! hostname) {
      goto _L___0;
    } else {
      if (family != 0) {
        _L___0: 
        goto _L;
      } else {
        if (masked == 3) {
          _L: 
          return (22);
        }
      }
    }
  }
  if (hostname) {
    tmp = find_addresses(sa, hostname, family, port, flags, p);
    return (tmp);
  }
  tmp___0 = apr_palloc(p, sizeof(apr_sockaddr_t ));
  (*sa) = (apr_sockaddr_t *)memset(tmp___0, 0, sizeof(apr_sockaddr_t ));
  ((*sa))->pool = p;
  if (family == 0) {
    tmp___1 = 2;
  } else {
    tmp___1 = family;
  }
  apr_sockaddr_vars_set((*sa), tmp___1, port);
  return (0);
}
}
apr_status_t apr_getnameinfo(char **hostname , apr_sockaddr_t *sockaddr , apr_int32_t flags ) 
{ int rc ;
  char tmphostname[1025] ;
  int *tmp ;
  apr_int32_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  tmp = __h_errno_location();
  (*tmp) = 0;
  if (flags != 0) {
    tmp___0 = flags;
  } else {
    tmp___0 = 8;
  }
  rc = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr  const  *)(& sockaddr->sa)),
                   sockaddr->salen, (char * __restrict  )(tmphostname), sizeof(tmphostname),
                   (char * __restrict  )((void *)0), 0U, (unsigned int )tmp___0);
  if (rc != 0) {
    (*hostname) = (char *)((void *)0);
    if (rc == -11) {
      tmp___3 = __h_errno_location();
      if ((*tmp___3)) {
        tmp___1 = __h_errno_location();
        return ((*tmp___1) + 720000);
      } else {
        tmp___2 = __errno_location();
        return ((*tmp___2) + 720000);
      }
    } else {
      if (rc < 0) {
        rc = - rc;
      }
      return (rc + 670000);
    }
  }
  sockaddr->hostname = apr_pstrdup(sockaddr->pool, (char const   *)(tmphostname));
  (*hostname) = sockaddr->hostname;
  return (0);
}
}
apr_status_t apr_getservbyname(apr_sockaddr_t *sockaddr , char const   *servname ) 
{ struct servent *se ;
  int *tmp ;

  {
  if ((unsigned int )servname == (unsigned int )((void *)0)) {
    return (22);
  }
  se = getservbyname(servname, (char const   *)((void *)0));
  if ((unsigned int )se != (unsigned int )((void *)0)) {
    sockaddr->port = htons((unsigned short )se->s_port);
    sockaddr->servname = apr_pstrdup(sockaddr->pool, servname);
    sockaddr->sa.sin.sin_port = (unsigned short )se->s_port;
    return (0);
  }
  tmp = __errno_location();
  return ((*tmp));
}
}
int apr_sockaddr_equal(apr_sockaddr_t const   *addr1 , apr_sockaddr_t const   *addr2 ) 
{ int tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;

  {
  if (addr1->ipaddr_len == addr2->ipaddr_len) {
    tmp = memcmp((void const   *)addr1->ipaddr_ptr, (void const   *)addr2->ipaddr_ptr,
                 (unsigned int )addr1->ipaddr_len);
    if (tmp) {
      goto _L;
    } else {
      return (1);
    }
  } else {
    _L: ;
  }
  if ((int )addr1->sa.sin.sin_family == 2) {
    if ((int )addr2->sa.sin.sin_family == 10) {
      if ((*((uint32_t const   *)((struct in6_addr *)addr2->ipaddr_ptr) + 0)) == 0U) {
        if ((*((uint32_t const   *)((struct in6_addr *)addr2->ipaddr_ptr) + 1)) ==
            0U) {
          tmp___0 = htonl(65535U);
          if ((*((uint32_t const   *)((struct in6_addr *)addr2->ipaddr_ptr) + 2)) ==
              (uint32_t const   )tmp___0) {
            tmp___1 = memcmp((void const   *)addr1->ipaddr_ptr, (void const   *)(& ((struct in6_addr *)addr2->ipaddr_ptr)->in6_u.u6_addr8[12]),
                             (unsigned int )addr1->ipaddr_len);
            if (tmp___1) {
              goto _L___4;
            } else {
              return (1);
            }
          } else {
            goto _L___3;
          }
        } else {
          goto _L___3;
        }
      } else {
        _L___3: 
        goto _L___4;
      }
    } else {
      goto _L___4;
    }
  } else {
    _L___4: ;
  }
  if ((int )addr2->sa.sin.sin_family == 2) {
    if ((int )addr1->sa.sin.sin_family == 10) {
      if ((*((uint32_t const   *)((struct in6_addr *)addr1->ipaddr_ptr) + 0)) == 0U) {
        if ((*((uint32_t const   *)((struct in6_addr *)addr1->ipaddr_ptr) + 1)) ==
            0U) {
          tmp___2 = htonl(65535U);
          if ((*((uint32_t const   *)((struct in6_addr *)addr1->ipaddr_ptr) + 2)) ==
              (uint32_t const   )tmp___2) {
            tmp___3 = memcmp((void const   *)addr2->ipaddr_ptr, (void const   *)(& ((struct in6_addr *)addr1->ipaddr_ptr)->in6_u.u6_addr8[12]),
                             (unsigned int )addr2->ipaddr_len);
            if (tmp___3) {
              goto _L___9;
            } else {
              return (1);
            }
          } else {
            goto _L___8;
          }
        } else {
          goto _L___8;
        }
      } else {
        _L___8: 
        goto _L___9;
      }
    } else {
      goto _L___9;
    }
  } else {
    _L___9: ;
  }
  return (0);
}
}
static apr_status_t parse_network(apr_ipsubnet_t *ipsub , char const   *network ) 
{ int shift ;
  char *s ;
  char *t ;
  int octet ;
  char buf[(int )sizeof("255.255.255.255")] ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;

  {
  tmp = strlen(network);
  if (tmp < sizeof(buf)) {
    strcpy((char * __restrict  )(buf), (char const   * __restrict  )network);
  } else {
    return (20016);
  }
  s = buf;
  ipsub->sub[0] = 0U;
  ipsub->mask[0] = 0U;
  shift = 24;
  while ((*s)) {
    t = s;
    tmp___0 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___0) + (int )((unsigned char )(*t)))) & 2048)) {
      return (20016);
    }
    while (1) {
      tmp___1 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___1) + (int )((unsigned char )(*t)))) & 2048)) {
        break;
      }
      t ++;
    }
    if ((int )(*t) == 46) {
      tmp___2 = t;
      t ++;
      (*tmp___2) = (char)0;
    } else {
      if ((*t)) {
        return (20016);
      }
    }
    if (shift < 0) {
      return (20016);
    }
    octet = atoi((char const   *)s);
    if (octet < 0) {
      goto _L;
    } else {
      if (octet > 255) {
        _L: 
        return (20016);
      }
    }
    ipsub->sub[0] |= (unsigned int )(octet << shift);
    ipsub->mask[0] = (unsigned int )((unsigned long )ipsub->mask[0] | (255UL << shift));
    s = t;
    shift -= 8;
  }
  ipsub->sub[0] = ntohl(ipsub->sub[0]);
  ipsub->mask[0] = ntohl(ipsub->mask[0]);
  ipsub->family = 2;
  return (0);
}
}
static apr_status_t parse_ip(apr_ipsubnet_t *ipsub , char const   *ipstr , int network_allowed ) 
{ int rc ;
  uint32_t tmp ;
  apr_status_t tmp___0 ;

  {
  rc = apr_inet_pton(10, ipstr, (void *)(ipsub->sub));
  if (rc == 1) {
    if ((*((uint32_t const   *)((struct in6_addr *)(ipsub->sub)) + 0)) == 0U) {
      if ((*((uint32_t const   *)((struct in6_addr *)(ipsub->sub)) + 1)) == 0U) {
        tmp = htonl(65535U);
        if ((*((uint32_t const   *)((struct in6_addr *)(ipsub->sub)) + 2)) == (uint32_t const   )tmp) {
          return (20016);
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
    ipsub->family = 10;
  } else {
    rc = apr_inet_pton(2, ipstr, (void *)(ipsub->sub));
    if (rc == 1) {
      ipsub->family = 2;
    }
  }
  if (rc != 1) {
    if (network_allowed) {
      tmp___0 = parse_network(ipsub, ipstr);
      return (tmp___0);
    } else {
      return (20016);
    }
  }
  return (0);
}
}
static int looks_like_ip(char const   *ipstr ) 
{ char *tmp ;
  unsigned short const   **tmp___0 ;

  {
  tmp = strchr(ipstr, ':');
  if (tmp) {
    return (1);
  }
  while (1) {
    if ((int const   )(*ipstr) == 46) {
      goto _L;
    } else {
      tmp___0 = __ctype_b_loc();
      if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*ipstr)))) & 2048) {
        _L: ;
      } else {
        break;
      }
    }
    ipstr ++;
  }
  return ((int const   )(*ipstr) == 0);
}
}
static void fix_subnet(apr_ipsubnet_t *ipsub ) 
{ int i ;

  {
  i = 0;
  while ((unsigned int )i < sizeof(ipsub->mask) / sizeof(apr_int32_t )) {
    ipsub->sub[i] &= ipsub->mask[i];
    i ++;
  }
  return;
}
}
apr_status_t apr_ipsubnet_create(apr_ipsubnet_t **ipsub , char const   *ipstr , char const   *mask_or_numbits ,
                                 apr_pool_t *p ) 
{ apr_status_t rv ;
  char *endptr ;
  long bits ;
  long maxbits ;
  int tmp ;
  void *tmp___0 ;
  int cur_entry ;
  apr_int32_t cur_bit_value ;
  int tmp___1 ;

  {
  maxbits = 32L;
  tmp = looks_like_ip(ipstr);
  if (! tmp) {
    return (22);
  }
  tmp___0 = apr_palloc(p, sizeof(apr_ipsubnet_t ));
  (*ipsub) = (apr_ipsubnet_t *)memset(tmp___0, 0, sizeof(apr_ipsubnet_t ));
  memset((void *)(((*ipsub))->mask), 255, sizeof(((*ipsub))->mask));
  rv = parse_ip((*ipsub), ipstr, (unsigned int )mask_or_numbits == (unsigned int )((void *)0));
  if (rv != 0) {
    return (rv);
  }
  if (mask_or_numbits) {
    if (((*ipsub))->family == 10) {
      maxbits = 128L;
    }
    bits = strtol((char const   * __restrict  )mask_or_numbits, (char ** __restrict  )(& endptr),
                  10);
    if ((int )(*endptr) == 0) {
      if (bits > 0L) {
        if (bits <= maxbits) {
          cur_entry = 0;
          memset((void *)(((*ipsub))->mask), 0, sizeof(((*ipsub))->mask));
          while (bits > 32L) {
            ((*ipsub))->mask[cur_entry] = 4294967295U;
            bits -= 32L;
            cur_entry ++;
          }
          cur_bit_value = (-0x7FFFFFFF-1);
          while (bits) {
            ((*ipsub))->mask[cur_entry] |= (unsigned int )cur_bit_value;
            bits --;
            cur_bit_value /= 2;
          }
          ((*ipsub))->mask[cur_entry] = htonl(((*ipsub))->mask[cur_entry]);
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      tmp___1 = apr_inet_pton(2, mask_or_numbits, (void *)(((*ipsub))->mask));
      if (tmp___1 == 1) {
        if (! (((*ipsub))->family == 2)) {
          goto _L;
        }
      } else {
        _L: 
        return (20017);
      }
    }
  }
  fix_subnet((*ipsub));
  return (0);
}
}
int apr_ipsubnet_test(apr_ipsubnet_t *ipsub , apr_sockaddr_t *sa ) 
{ apr_uint32_t *addr ;
  uint32_t tmp ;

  {
  if ((int )sa->sa.sin.sin_family == 2) {
    if (ipsub->family == 2) {
      if ((sa->sa.sin.sin_addr.s_addr & ipsub->mask[0]) == ipsub->sub[0]) {
        return (1);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
  } else {
    if ((*((uint32_t const   *)((struct in6_addr *)sa->ipaddr_ptr) + 0)) == 0U) {
      if ((*((uint32_t const   *)((struct in6_addr *)sa->ipaddr_ptr) + 1)) == 0U) {
        tmp = htonl(65535U);
        if ((*((uint32_t const   *)((struct in6_addr *)sa->ipaddr_ptr) + 2)) == (uint32_t const   )tmp) {
          if (ipsub->family == 2) {
            if (((*((apr_uint32_t *)sa->ipaddr_ptr + 3)) & ipsub->mask[0]) == ipsub->sub[0]) {
              return (1);
            } else {
              goto _L___0;
            }
          } else {
            _L___0: ;
          }
        } else {
          goto _L___5;
        }
      } else {
        goto _L___5;
      }
    } else {
      _L___5: 
      addr = (apr_uint32_t *)sa->ipaddr_ptr;
      if (((*(addr + 0)) & ipsub->mask[0]) == ipsub->sub[0]) {
        if (((*(addr + 1)) & ipsub->mask[1]) == ipsub->sub[1]) {
          if (((*(addr + 2)) & ipsub->mask[2]) == ipsub->sub[2]) {
            if (((*(addr + 3)) & ipsub->mask[3]) == ipsub->sub[3]) {
              return (1);
            } else {
              goto _L___3;
            }
          } else {
            goto _L___3;
          }
        } else {
          goto _L___3;
        }
      } else {
        _L___3: ;
      }
    }
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-c5F3oItF.i","-g -pthread")
extern int socket(int __domain , int __type , int __protocol ) ;
extern int bind(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
extern int getsockopt(int __fd , int __level , int __optname , void * __restrict  __optval ,
                      socklen_t * __restrict  __optlen ) ;
extern int listen(int __fd , int __n ) ;
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
extern int shutdown(int __fd , int __how ) ;
static char generic_inaddr_any[16]  = 
  {      (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0};
static apr_status_t socket_cleanup(void *sock ) 
{ apr_socket_t *thesocket ;
  int *tmp ;
  int tmp___0 ;

  {
  thesocket = (apr_socket_t *)sock;
  tmp___0 = close(thesocket->socketdes);
  if (tmp___0 == 0) {
    thesocket->socketdes = -1;
    return (0);
  } else {
    tmp = __errno_location();
    return ((*tmp));
  }
}
}
static void set_socket_vars(apr_socket_t *sock , int family , int type , int protocol ) 
{ 

  {
  sock->type = type;
  sock->protocol = protocol;
  apr_sockaddr_vars_set(sock->local_addr, family, (unsigned short)0);
  apr_sockaddr_vars_set(sock->remote_addr, family, (unsigned short)0);
  sock->netmask = 0;
  return;
}
}
static void alloc_socket(apr_socket_t **new , apr_pool_t *p ) 
{ void *tmp ;
  void *tmp___1 ;
  void *tmp___3 ;

  {
  tmp = apr_palloc(p, sizeof(apr_socket_t ));
  (*new) = (apr_socket_t *)memset(tmp, 0, sizeof(apr_socket_t ));
  ((*new))->cntxt = p;
  tmp___1 = apr_palloc(((*new))->cntxt, sizeof(apr_sockaddr_t ));
  ((*new))->local_addr = (apr_sockaddr_t *)memset(tmp___1, 0, sizeof(apr_sockaddr_t ));
  (((*new))->local_addr)->pool = p;
  tmp___3 = apr_palloc(((*new))->cntxt, sizeof(apr_sockaddr_t ));
  ((*new))->remote_addr = (apr_sockaddr_t *)memset(tmp___3, 0, sizeof(apr_sockaddr_t ));
  (((*new))->remote_addr)->pool = p;
  return;
}
}
apr_status_t apr_socket_protocol_get(apr_socket_t *sock , int *protocol ) 
{ 

  {
  (*protocol) = sock->protocol;
  return (0);
}
}
apr_status_t apr_socket_create_ex(apr_socket_t **new , int ofamily , int type , int protocol ,
                                  apr_pool_t *cont ) 
{ int family ;
  int *tmp ;

  {
  family = ofamily;
  if (family == 0) {
    family = 10;
  }
  alloc_socket(new, cont);
  ((*new))->socketdes = socket(family, type, protocol);
  if (((*new))->socketdes < 0) {
    if (ofamily == 0) {
      family = 2;
      ((*new))->socketdes = socket(family, type, protocol);
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if (((*new))->socketdes < 0) {
    tmp = __errno_location();
    return ((*tmp));
  }
  set_socket_vars((*new), family, type, protocol);
  ((*new))->timeout = -1LL;
  ((*new))->inherit = 0;
  apr_pool_cleanup_register(((*new))->cntxt, (void const   *)((void *)(*new)), & socket_cleanup,
                            & socket_cleanup);
  return (0);
}
}
apr_status_t apr_socket_create(apr_socket_t **new , int family , int type , apr_pool_t *cont ) 
{ apr_status_t tmp ;

  {
  tmp = apr_socket_create_ex(new, family, type, 0, cont);
  return (tmp);
}
}
apr_status_t apr_socket_shutdown(apr_socket_t *thesocket , apr_shutdown_how_e how ) 
{ int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  tmp___3 = shutdown(thesocket->socketdes, (int )how);
  if (tmp___3 == -1) {
    tmp___2 = __errno_location();
    tmp___1 = (*tmp___2);
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
apr_status_t apr_socket_close(apr_socket_t *thesocket ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_cleanup_run(thesocket->cntxt, (void *)thesocket, & socket_cleanup);
  return (tmp);
}
}
apr_status_t apr_socket_bind(apr_socket_t *sock , apr_sockaddr_t *sa ) 
{ int *tmp ;
  int tmp___0 ;

  {
  tmp___0 = bind(sock->socketdes, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& sa->sa)),
                 sa->salen);
  if (tmp___0 == -1) {
    tmp = __errno_location();
    return ((*tmp));
  } else {
    sock->local_addr = sa;
    if ((int )(sock->local_addr)->sa.sin.sin_port == 0) {
      sock->local_port_unknown = 1;
    }
    return (0);
  }
}
}
apr_status_t apr_socket_listen(apr_socket_t *sock , apr_int32_t backlog ) 
{ int *tmp ;
  int tmp___0 ;

  {
  tmp___0 = listen(sock->socketdes, backlog);
  if (tmp___0 == -1) {
    tmp = __errno_location();
    return ((*tmp));
  } else {
    return (0);
  }
}
}
apr_status_t apr_socket_accept(apr_socket_t **new , apr_socket_t *sock , apr_pool_t *connection_context ) 
{ int *tmp ;
  int tmp___0 ;

  {
  alloc_socket(new, connection_context);
  set_socket_vars((*new), (int )(sock->local_addr)->sa.sin.sin_family, 1, sock->protocol);
  ((*new))->timeout = -1LL;
  ((*new))->socketdes = accept(sock->socketdes, (struct sockaddr * __restrict  )((struct sockaddr *)(& (((*new))->remote_addr)->sa)),
                               (socklen_t * __restrict  )(& (((*new))->remote_addr)->salen));
  if (((*new))->socketdes < 0) {
    tmp = __errno_location();
    return ((*tmp));
  }
  (*(((*new))->local_addr)) = (*(sock->local_addr));
  (((*new))->local_addr)->pool = connection_context;
  if ((int )(sock->local_addr)->sa.sin.sin_family == 2) {
    (((*new))->local_addr)->ipaddr_ptr = (void *)(& (((*new))->local_addr)->sa.sin.sin_addr);
  } else {
    if ((int )(sock->local_addr)->sa.sin.sin_family == 10) {
      (((*new))->local_addr)->ipaddr_ptr = (void *)(& (((*new))->local_addr)->sa.sin6.sin6_addr);
    }
  }
  (((*new))->remote_addr)->port = ntohs((((*new))->remote_addr)->sa.sin.sin_port);
  if (sock->local_port_unknown) {
    ((*new))->local_port_unknown = 1;
  }
  if (((sock->netmask & 512) == 512) == 1) {
    while (1) {
      ((*new))->netmask = ((*new))->netmask | 512;
      break;
    }
  }
  if (sock->local_interface_unknown) {
    goto _L;
  } else {
    tmp___0 = memcmp((void const   *)(sock->local_addr)->ipaddr_ptr, (void const   *)(generic_inaddr_any),
                     (unsigned int )(sock->local_addr)->ipaddr_len);
    if (! tmp___0) {
      _L: 
      ((*new))->local_interface_unknown = 1;
    }
  }
  ((*new))->inherit = 0;
  apr_pool_cleanup_register(((*new))->cntxt, (void const   *)((void *)(*new)), & socket_cleanup,
                            & socket_cleanup);
  return (0);
}
}
apr_status_t apr_socket_connect(apr_socket_t *sock , apr_sockaddr_t *sa ) 
{ int rc ;
  int *tmp ;
  int error ;
  apr_socklen_t len ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  while (1) {
    rc = connect(sock->socketdes, (struct sockaddr  const  * __restrict  )((struct sockaddr  const  *)(& sa->sa.sin)),
                 sa->salen);
    if (rc == -1) {
      tmp = __errno_location();
      if (! ((*tmp) == 4)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
  }
  if (rc == -1) {
    tmp___1 = __errno_location();
    if ((*tmp___1) == 115) {
      goto _L___2;
    } else {
      tmp___2 = __errno_location();
      if ((*tmp___2) == 114) {
        _L___2: 
        if (sock->timeout != 0LL) {
          rc = apr_wait_for_io_or_timeout((apr_file_t *)((void *)0), sock, 0);
          if (rc != 0) {
            return (rc);
          }
          len = sizeof(error);
          rc = getsockopt(sock->socketdes, 1, 4, (void * __restrict  )((char *)(& error)),
                          (socklen_t * __restrict  )(& len));
          if (rc < 0) {
            tmp___0 = __errno_location();
            return ((*tmp___0));
          }
          if (error) {
            return (error);
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    }
  } else {
    _L___1: ;
  }
  if (rc == -1) {
    tmp___3 = __errno_location();
    return ((*tmp___3));
  }
  sock->remote_addr = sa;
  if ((int )(sock->local_addr)->port == 0) {
    sock->local_port_unknown = 1;
  }
  tmp___4 = memcmp((void const   *)(sock->local_addr)->ipaddr_ptr, (void const   *)(generic_inaddr_any),
                   (unsigned int )(sock->local_addr)->ipaddr_len);
  if (! tmp___4) {
    sock->local_interface_unknown = 1;
  }
  return (0);
}
}
apr_status_t apr_socket_data_get(void **data , char const   *key , apr_socket_t *sock ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_userdata_get(data, key, sock->cntxt);
  return (tmp);
}
}
apr_status_t apr_socket_data_set(apr_socket_t *sock , void *data , char const   *key ,
                                 apr_status_t (*cleanup)(void * ) ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_userdata_set((void const   *)data, key, cleanup, sock->cntxt);
  return (tmp);
}
}
apr_status_t apr_os_sock_get(apr_os_sock_t *thesock , apr_socket_t *sock ) 
{ 

  {
  (*thesock) = sock->socketdes;
  return (0);
}
}
apr_status_t apr_os_sock_make(apr_socket_t **apr_sock , apr_os_sock_info_t *os_sock_info ,
                              apr_pool_t *cont ) 
{ 

  {
  alloc_socket(apr_sock, cont);
  set_socket_vars((*apr_sock), os_sock_info->family, os_sock_info->type, 0);
  ((*apr_sock))->timeout = -1LL;
  ((*apr_sock))->socketdes = (*(os_sock_info->os_sock));
  if (os_sock_info->local) {
    memcpy((void * __restrict  )(& (((*apr_sock))->local_addr)->sa.sin), (void const   * __restrict  )os_sock_info->local,
           (((*apr_sock))->local_addr)->salen);
    (((*apr_sock))->local_addr)->port = ntohs((((*apr_sock))->local_addr)->sa.sin.sin_port);
  } else {
    ((*apr_sock))->local_interface_unknown = 1;
    ((*apr_sock))->local_port_unknown = ((*apr_sock))->local_interface_unknown;
  }
  if (os_sock_info->remote) {
    memcpy((void * __restrict  )(& (((*apr_sock))->remote_addr)->sa.sin), (void const   * __restrict  )os_sock_info->remote,
           (((*apr_sock))->remote_addr)->salen);
    (((*apr_sock))->remote_addr)->port = ntohs((((*apr_sock))->remote_addr)->sa.sin.sin_port);
  } else {
    ((*apr_sock))->remote_addr_unknown = 1;
  }
  ((*apr_sock))->inherit = 0;
  apr_pool_cleanup_register(((*apr_sock))->cntxt, (void const   *)((void *)(*apr_sock)),
                            & socket_cleanup, & socket_cleanup);
  return (0);
}
}
apr_status_t apr_os_sock_put(apr_socket_t **sock , apr_os_sock_t *thesock , apr_pool_t *cont ) 
{ 

  {
  if ((unsigned int )(*sock) == (unsigned int )((void *)0)) {
    alloc_socket(sock, cont);
    set_socket_vars((*sock), 2, 1, 0);
    ((*sock))->timeout = -1LL;
  }
  ((*sock))->local_interface_unknown = 1;
  ((*sock))->local_port_unknown = ((*sock))->local_interface_unknown;
  ((*sock))->remote_addr_unknown = 1;
  ((*sock))->socketdes = (*thesock);
  return (0);
}
}
apr_status_t apr_socket_inherit_set(apr_socket_t *thesocket ) 
{ 

  {
  if (! (thesocket->inherit & 16777216)) {
    thesocket->inherit = thesocket->inherit | 16777216;
    apr_pool_child_cleanup_set(thesocket->cntxt, (void const   *)((void *)thesocket),
                               & socket_cleanup, & apr_pool_cleanup_null);
  }
  return (0);
}
}
void apr_socket_set_inherit(apr_socket_t *thesocket ) 
{ 

  {
  apr_socket_inherit_set(thesocket);
  return;
}
}
apr_status_t apr_socket_inherit_unset(apr_socket_t *thesocket ) 
{ 

  {
  if (thesocket->inherit & 16777216) {
    thesocket->inherit = thesocket->inherit & -16777217;
    apr_pool_child_cleanup_set(thesocket->cntxt, (void const   *)((void *)thesocket),
                               & socket_cleanup, & socket_cleanup);
  }
  return (0);
}
}
void apr_socket_unset_inherit(apr_socket_t *thesocket ) 
{ 

  {
  apr_socket_inherit_unset(thesocket);
  return;
}
}
apr_status_t apr_shutdown(apr_socket_t *thesocket , apr_shutdown_how_e how ) 
{ apr_status_t tmp ;

  {
  tmp = apr_socket_shutdown(thesocket, how);
  return (tmp);
}
}
apr_status_t apr_bind(apr_socket_t *sock , apr_sockaddr_t *sa ) 
{ apr_status_t tmp ;

  {
  tmp = apr_socket_bind(sock, sa);
  return (tmp);
}
}
apr_status_t apr_listen(apr_socket_t *sock , apr_int32_t backlog ) 
{ apr_status_t tmp ;

  {
  tmp = apr_socket_listen(sock, backlog);
  return (tmp);
}
}
apr_status_t apr_accept(apr_socket_t **new , apr_socket_t *sock , apr_pool_t *connection_context ) 
{ apr_status_t tmp ;

  {
  tmp = apr_socket_accept(new, sock, connection_context);
  return (tmp);
}
}
apr_status_t apr_connect(apr_socket_t *sock , apr_sockaddr_t *sa ) 
{ apr_status_t tmp ;

  {
  tmp = apr_socket_connect(sock, sa);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-qWDvSidD.i","-g -pthread")
extern int setsockopt(int __fd , int __level , int __optname , void const   *__optval ,
                      socklen_t __optlen ) ;
static apr_status_t soblock(int sd ) 
{ int fd_flags ;
  int *tmp ;
  int tmp___0 ;

  {
  fd_flags = fcntl(sd, 3, 0);
  fd_flags &= -2049;
  tmp___0 = fcntl(sd, 4, fd_flags);
  if (tmp___0 == -1) {
    tmp = __errno_location();
    return ((*tmp));
  }
  return (0);
}
}
static apr_status_t sononblock(int sd ) 
{ int fd_flags ;
  int *tmp ;
  int tmp___0 ;

  {
  fd_flags = fcntl(sd, 3, 0);
  fd_flags |= 2048;
  tmp___0 = fcntl(sd, 4, fd_flags);
  if (tmp___0 == -1) {
    tmp = __errno_location();
    return ((*tmp));
  }
  return (0);
}
}
apr_status_t apr_socket_timeout_set(apr_socket_t *sock , apr_interval_time_t t ) 
{ apr_status_t stat___0 ;

  {
  if (t >= 0LL) {
    if (sock->timeout < 0LL) {
      if (((sock->netmask & 8) == 8) != 1) {
        stat___0 = sononblock(sock->socketdes);
        if (stat___0 != 0) {
          return (stat___0);
        }
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    if (t < 0LL) {
      if (sock->timeout >= 0LL) {
        if (((sock->netmask & 8) == 8) != 0) {
          stat___0 = soblock(sock->socketdes);
          if (stat___0 != 0) {
            return (stat___0);
          }
        }
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
  }
  if (t == 0LL) {
    sock->netmask = sock->netmask & -4097;
  }
  sock->timeout = t;
  while (1) {
    if (t) {
      sock->netmask = sock->netmask | 32;
    } else {
      sock->netmask = sock->netmask & -33;
    }
    break;
  }
  return (0);
}
}
apr_status_t apr_socket_opt_set(apr_socket_t *sock , apr_int32_t opt , apr_int32_t on ) 
{ int one ;
  apr_status_t rv ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  struct linger li ;
  int *tmp___7 ;
  int tmp___8 ;
  apr_status_t tmp___9 ;
  int optlevel ;
  int optname ;
  int *tmp___10 ;
  int tmp___11 ;
  int optlevel___0 ;
  int optname___0 ;
  int tmpflag ;
  int *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int tmpflag___0 ;
  int *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;

  {
  if (on) {
    one = 1;
  } else {
    one = 0;
  }
  if (opt & 2) {
    if (on != ((sock->netmask & 2) == 2)) {
      tmp___0 = setsockopt(sock->socketdes, 1, 9, (void const   *)((void *)(& one)),
                           sizeof(int ));
      if (tmp___0 == -1) {
        tmp = __errno_location();
        return ((*tmp));
      }
      while (1) {
        if (on) {
          sock->netmask = sock->netmask | 2;
        } else {
          sock->netmask = sock->netmask & -3;
        }
        break;
      }
    }
  }
  if (opt & 4) {
    if (on != ((sock->netmask & 4) == 4)) {
      tmp___2 = setsockopt(sock->socketdes, 1, 1, (void const   *)((void *)(& one)),
                           sizeof(int ));
      if (tmp___2 == -1) {
        tmp___1 = __errno_location();
        return ((*tmp___1));
      }
      while (1) {
        if (on) {
          sock->netmask = sock->netmask | 4;
        } else {
          sock->netmask = sock->netmask & -5;
        }
        break;
      }
    }
  }
  if (opt & 16) {
    if (on != ((sock->netmask & 16) == 16)) {
      tmp___4 = setsockopt(sock->socketdes, 1, 2, (void const   *)((void *)(& one)),
                           sizeof(int ));
      if (tmp___4 == -1) {
        tmp___3 = __errno_location();
        return ((*tmp___3));
      }
      while (1) {
        if (on) {
          sock->netmask = sock->netmask | 16;
        } else {
          sock->netmask = sock->netmask & -17;
        }
        break;
      }
    }
  }
  if (opt & 64) {
    if (((sock->netmask & 64) == 64) != on) {
      tmp___6 = setsockopt(sock->socketdes, 1, 7, (void const   *)((void *)(& on)),
                           sizeof(int ));
      if (tmp___6 == -1) {
        tmp___5 = __errno_location();
        return ((*tmp___5));
      }
      while (1) {
        if (on) {
          sock->netmask = sock->netmask | 64;
        } else {
          sock->netmask = sock->netmask & -65;
        }
        break;
      }
    }
  }
  if (opt & 8) {
    if (((sock->netmask & 8) == 8) != on) {
      if (on) {
        rv = sononblock(sock->socketdes);
        if (rv != 0) {
          return (rv);
        }
      } else {
        rv = soblock(sock->socketdes);
        if (rv != 0) {
          return (rv);
        }
      }
      while (1) {
        if (on) {
          sock->netmask = sock->netmask | 8;
        } else {
          sock->netmask = sock->netmask & -9;
        }
        break;
      }
    }
  }
  if (opt & 1) {
    if (((sock->netmask & 1) == 1) != on) {
      li.l_onoff = on;
      li.l_linger = 30;
      tmp___8 = setsockopt(sock->socketdes, 1, 13, (void const   *)((char *)(& li)),
                           sizeof(struct linger ));
      if (tmp___8 == -1) {
        tmp___7 = __errno_location();
        return ((*tmp___7));
      }
      while (1) {
        if (on) {
          sock->netmask = sock->netmask | 1;
        } else {
          sock->netmask = sock->netmask & -2;
        }
        break;
      }
    }
  }
  if (opt & 32) {
    tmp___9 = apr_socket_timeout_set(sock, (long long )on);
    return (tmp___9);
  }
  if (opt & 512) {
    if (((sock->netmask & 512) == 512) != on) {
      optlevel = 6;
      optname = 1;
      tmp___11 = setsockopt(sock->socketdes, optlevel, optname, (void const   *)((void *)(& on)),
                            sizeof(int ));
      if (tmp___11 == -1) {
        tmp___10 = __errno_location();
        return ((*tmp___10));
      }
      while (1) {
        if (on) {
          sock->netmask = sock->netmask | 512;
        } else {
          sock->netmask = sock->netmask & -513;
        }
        break;
      }
    }
  }
  if (opt & 1024) {
    if (((sock->netmask & 1024) == 1024) != on) {
      optlevel___0 = 6;
      optname___0 = 1;
      if (((sock->netmask & 512) == 512) == 1) {
        if (on) {
          tmpflag = 0;
          tmp___13 = setsockopt(sock->socketdes, optlevel___0, optname___0, (void const   *)((void *)(& tmpflag)),
                                sizeof(int ));
          if (tmp___13 == -1) {
            tmp___12 = __errno_location();
            return ((*tmp___12));
          }
          while (1) {
            sock->netmask = sock->netmask | 2048;
            break;
          }
          while (1) {
            sock->netmask = sock->netmask & -513;
            break;
          }
        } else {
          goto _L;
        }
      } else {
        _L: 
        if (on) {
          while (1) {
            sock->netmask = sock->netmask & -2049;
            break;
          }
        }
      }
      tmp___15 = setsockopt(sock->socketdes, 6, 3, (void const   *)((void *)(& on)),
                            sizeof(int ));
      if (tmp___15 == -1) {
        tmp___14 = __errno_location();
        return ((*tmp___14));
      }
      while (1) {
        if (on) {
          sock->netmask = sock->netmask | 1024;
        } else {
          sock->netmask = sock->netmask & -1025;
        }
        break;
      }
      if (! on) {
        if ((sock->netmask & 2048) == 2048) {
          tmpflag___0 = 1;
          tmp___17 = setsockopt(sock->socketdes, optlevel___0, optname___0, (void const   *)((void *)(& tmpflag___0)),
                                sizeof(int ));
          if (tmp___17 == -1) {
            tmp___16 = __errno_location();
            return ((*tmp___16));
          }
          while (1) {
            sock->netmask = sock->netmask & -2049;
            break;
          }
          while (1) {
            sock->netmask = sock->netmask | 512;
            break;
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: ;
      }
    }
  }
  if (opt & 4096) {
    while (1) {
      if (on) {
        sock->netmask = sock->netmask | 4096;
      } else {
        sock->netmask = sock->netmask & -4097;
      }
      break;
    }
  }
  if (opt & 16384) {
    tmp___19 = setsockopt(sock->socketdes, 41, 26, (void const   *)((void *)(& on)),
                          sizeof(int ));
    if (tmp___19 == -1) {
      tmp___18 = __errno_location();
      return ((*tmp___18));
    }
  }
  return (0);
}
}
apr_status_t apr_socket_timeout_get(apr_socket_t *sock , apr_interval_time_t *t ) 
{ 

  {
  (*t) = sock->timeout;
  return (0);
}
}
apr_status_t apr_socket_opt_get(apr_socket_t *sock , apr_int32_t opt , apr_int32_t *on ) 
{ 

  {
  switch (opt) {
  case 32: 
  (*on) = (int )sock->timeout;
  break;
  default: 
  (*on) = (sock->netmask & opt) == opt;
  }
  return (0);
}
}
apr_status_t apr_setsocketopt(apr_socket_t *sock , apr_int32_t opt , apr_int32_t on ) 
{ apr_status_t tmp ;

  {
  tmp = apr_socket_opt_set(sock, opt, on);
  return (tmp);
}
}
apr_status_t apr_getsocketopt(apr_socket_t *sock , apr_int32_t opt , apr_int32_t *on ) 
{ apr_status_t tmp ;

  {
  tmp = apr_socket_opt_get(sock, opt, on);
  return (tmp);
}
}
apr_status_t apr_gethostname(char *buf , int len , apr_pool_t *cont ) 
{ int *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp___1 = gethostname(buf, (unsigned int )len);
  if (tmp___1 == -1) {
    (*(buf + 0)) = (char )'\000';
    tmp = __errno_location();
    return ((*tmp));
  } else {
    tmp___0 = memchr((void const   *)buf, '\000', (unsigned int )len);
    if (! tmp___0) {
      (*(buf + 0)) = (char )'\000';
      return (36);
    }
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-GVuQrkNb.i","-g -pthread")
extern int setrlimit(__rlimit_resource_t __resource , struct rlimit  const  *__rlimits ) ;
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
extern int execve(char const   *__path , char * const  *__argv , char * const  *__envp ) ;
extern int execv(char const   *__path , char * const  *__argv ) ;
extern int execvp(char const   *__file , char * const  *__argv ) ;
apr_status_t apr_procattr_create(apr_procattr_t **new , apr_pool_t *pool ) 
{ void *tmp ;

  {
  tmp = apr_palloc(pool, sizeof(apr_procattr_t ));
  (*new) = (apr_procattr_t *)memset(tmp, 0, sizeof(apr_procattr_t ));
  if ((unsigned int )(*new) == (unsigned int )((void *)0)) {
    return (12);
  }
  ((*new))->pool = pool;
  ((*new))->cmdtype = 1;
  return (0);
}
}
apr_status_t apr_procattr_io_set(apr_procattr_t *attr , apr_int32_t in , apr_int32_t out ,
                                 apr_int32_t err ) 
{ apr_status_t status ;

  {
  if (in != 0) {
    status = apr_file_pipe_create(& attr->child_in, & attr->parent_in, attr->pool);
    if (status != 0) {
      return (status);
    }
    switch (in) {
    case 1: ;
    break;
    case 3: 
    apr_file_pipe_timeout_set(attr->child_in, 0LL);
    break;
    case 4: 
    apr_file_pipe_timeout_set(attr->parent_in, 0LL);
    break;
    default: 
    apr_file_pipe_timeout_set(attr->child_in, 0LL);
    apr_file_pipe_timeout_set(attr->parent_in, 0LL);
    }
  }
  if (out) {
    status = apr_file_pipe_create(& attr->parent_out, & attr->child_out, attr->pool);
    if (status != 0) {
      return (status);
    }
    switch (out) {
    case 1: ;
    break;
    case 3: 
    apr_file_pipe_timeout_set(attr->child_out, 0LL);
    break;
    case 4: 
    apr_file_pipe_timeout_set(attr->parent_out, 0LL);
    break;
    default: 
    apr_file_pipe_timeout_set(attr->child_out, 0LL);
    apr_file_pipe_timeout_set(attr->parent_out, 0LL);
    }
  }
  if (err) {
    status = apr_file_pipe_create(& attr->parent_err, & attr->child_err, attr->pool);
    if (status != 0) {
      return (status);
    }
    switch (err) {
    case 1: ;
    break;
    case 3: 
    apr_file_pipe_timeout_set(attr->child_err, 0LL);
    break;
    case 4: 
    apr_file_pipe_timeout_set(attr->parent_err, 0LL);
    break;
    default: 
    apr_file_pipe_timeout_set(attr->child_err, 0LL);
    apr_file_pipe_timeout_set(attr->parent_err, 0LL);
    }
  }
  return (0);
}
}
apr_status_t apr_procattr_child_in_set(struct apr_procattr_t *attr , apr_file_t *child_in ,
                                       apr_file_t *parent_in ) 
{ 

  {
  if ((unsigned int )attr->child_in == (unsigned int )((void *)0)) {
    if ((unsigned int )attr->parent_in == (unsigned int )((void *)0)) {
      apr_file_pipe_create(& attr->child_in, & attr->parent_in, attr->pool);
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if ((unsigned int )child_in != (unsigned int )((void *)0)) {
    apr_file_dup2(attr->child_in, child_in, attr->pool);
  }
  if ((unsigned int )parent_in != (unsigned int )((void *)0)) {
    apr_file_dup2(attr->parent_in, parent_in, attr->pool);
  }
  return (0);
}
}
apr_status_t apr_procattr_child_out_set(struct apr_procattr_t *attr , apr_file_t *child_out ,
                                        apr_file_t *parent_out ) 
{ 

  {
  if ((unsigned int )attr->child_out == (unsigned int )((void *)0)) {
    if ((unsigned int )attr->parent_out == (unsigned int )((void *)0)) {
      apr_file_pipe_create(& attr->child_out, & attr->parent_out, attr->pool);
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if ((unsigned int )child_out != (unsigned int )((void *)0)) {
    apr_file_dup2(attr->child_out, child_out, attr->pool);
  }
  if ((unsigned int )parent_out != (unsigned int )((void *)0)) {
    apr_file_dup2(attr->parent_out, parent_out, attr->pool);
  }
  return (0);
}
}
apr_status_t apr_procattr_child_err_set(struct apr_procattr_t *attr , apr_file_t *child_err ,
                                        apr_file_t *parent_err ) 
{ 

  {
  if ((unsigned int )attr->child_err == (unsigned int )((void *)0)) {
    if ((unsigned int )attr->parent_err == (unsigned int )((void *)0)) {
      apr_file_pipe_create(& attr->child_err, & attr->parent_err, attr->pool);
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if ((unsigned int )child_err != (unsigned int )((void *)0)) {
    apr_file_dup2(attr->child_err, child_err, attr->pool);
  }
  if ((unsigned int )parent_err != (unsigned int )((void *)0)) {
    apr_file_dup2(attr->parent_err, parent_err, attr->pool);
  }
  return (0);
}
}
apr_status_t apr_procattr_dir_set(apr_procattr_t *attr , char const   *dir ) 
{ 

  {
  attr->currdir = apr_pstrdup(attr->pool, dir);
  if (attr->currdir) {
    return (0);
  }
  return (12);
}
}
apr_status_t apr_procattr_cmdtype_set(apr_procattr_t *attr , apr_cmdtype_e cmd ) 
{ 

  {
  attr->cmdtype = (int )cmd;
  return (0);
}
}
apr_status_t apr_procattr_detach_set(apr_procattr_t *attr , apr_int32_t detach ) 
{ 

  {
  attr->detached = detach;
  return (0);
}
}
apr_status_t apr_proc_fork(apr_proc_t *proc , apr_pool_t *pool ) 
{ int pid ;
  int *tmp ;

  {
  pid = fork();
  if (pid < 0) {
    tmp = __errno_location();
    return ((*tmp));
  } else {
    if (pid == 0) {
      proc->pid = pid;
      proc->in = (apr_file_t *)((void *)0);
      proc->out = (apr_file_t *)((void *)0);
      proc->err = (apr_file_t *)((void *)0);
      return (70001);
    }
  }
  proc->pid = pid;
  proc->in = (apr_file_t *)((void *)0);
  proc->out = (apr_file_t *)((void *)0);
  proc->err = (apr_file_t *)((void *)0);
  return (70002);
}
}
static apr_status_t limit_proc(apr_procattr_t *attr ) 
{ int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  if ((unsigned int )attr->limit_cpu != (unsigned int )((void *)0)) {
    tmp___0 = setrlimit((enum __rlimit_resource )0, (struct rlimit  const  *)attr->limit_cpu);
    if (tmp___0 != 0) {
      tmp = __errno_location();
      return ((*tmp));
    }
  }
  if ((unsigned int )attr->limit_nproc != (unsigned int )((void *)0)) {
    tmp___2 = setrlimit((enum __rlimit_resource )6, (struct rlimit  const  *)attr->limit_nproc);
    if (tmp___2 != 0) {
      tmp___1 = __errno_location();
      return ((*tmp___1));
    }
  }
  if ((unsigned int )attr->limit_nofile != (unsigned int )((void *)0)) {
    tmp___4 = setrlimit((enum __rlimit_resource )7, (struct rlimit  const  *)attr->limit_nofile);
    if (tmp___4 != 0) {
      tmp___3 = __errno_location();
      return ((*tmp___3));
    }
  }
  if ((unsigned int )attr->limit_mem != (unsigned int )((void *)0)) {
    tmp___6 = setrlimit((enum __rlimit_resource )9, (struct rlimit  const  *)attr->limit_mem);
    if (tmp___6 != 0) {
      tmp___5 = __errno_location();
      return ((*tmp___5));
    }
  }
  return (0);
}
}
apr_status_t apr_proc_create(apr_proc_t *new , char const   *progname , char const   * const  *args ,
                             char const   * const  *env , apr_procattr_t *attr , apr_pool_t *pool ) 
{ int i ;
  char const   **newargs ;
  int *tmp ;
  int status ;
  apr_pool_t *tmp___0 ;
  apr_pool_t *tmp___1 ;
  apr_pool_t *tmp___2 ;
  int tmp___3 ;

  {
  new->in = attr->parent_in;
  new->err = attr->parent_err;
  new->out = attr->parent_out;
  new->pid = fork();
  if (new->pid < 0) {
    tmp = __errno_location();
    return ((*tmp));
  } else {
    if (new->pid == 0) {
      if (attr->child_in) {
        tmp___0 = apr_file_pool_get((apr_file_t const   *)attr->child_in);
        apr_pool_cleanup_kill(tmp___0, (void const   *)attr->child_in, & apr_unix_file_cleanup);
      }
      if (attr->child_out) {
        tmp___1 = apr_file_pool_get((apr_file_t const   *)attr->child_out);
        apr_pool_cleanup_kill(tmp___1, (void const   *)attr->child_out, & apr_unix_file_cleanup);
      }
      if (attr->child_err) {
        tmp___2 = apr_file_pool_get((apr_file_t const   *)attr->child_err);
        apr_pool_cleanup_kill(tmp___2, (void const   *)attr->child_err, & apr_unix_file_cleanup);
      }
      apr_pool_cleanup_for_exec();
      if (attr->child_in) {
        apr_file_close(attr->parent_in);
        dup2((attr->child_in)->filedes, 0);
        apr_file_close(attr->child_in);
      }
      if (attr->child_out) {
        apr_file_close(attr->parent_out);
        dup2((attr->child_out)->filedes, 1);
        apr_file_close(attr->child_out);
      }
      if (attr->child_err) {
        apr_file_close(attr->parent_err);
        dup2((attr->child_err)->filedes, 2);
        apr_file_close(attr->child_err);
      }
      apr_signal(17, (void (*)(int  ))0);
      if ((unsigned int )attr->currdir != (unsigned int )((void *)0)) {
        tmp___3 = chdir((char const   *)attr->currdir);
        if (tmp___3 == -1) {
          exit(-1);
        }
      }
      status = limit_proc(attr);
      if (status != 0) {
        return (status);
      }
      if (attr->cmdtype == 0) {
        i = 0;
        while ((*(args + i))) {
          i ++;
        }
        newargs = (char const   **)apr_palloc(pool, sizeof(char *) * (unsigned int )(i +
                                                                                     3));
        (*(newargs + 0)) = "/bin/sh";
        (*(newargs + 1)) = "-c";
        i = 0;
        while ((*(args + i))) {
          (*(newargs + (i + 2))) = (char const   *)(*(args + i));
          i ++;
        }
        (*(newargs + (i + 2))) = (char const   *)((void *)0);
        if (attr->detached) {
          apr_proc_detach(1);
        }
        execve("/bin/sh", (char * const  *)newargs, (char * const  *)env);
      } else {
        if (attr->cmdtype == 1) {
          if (attr->detached) {
            apr_proc_detach(1);
          }
          execve(progname, (char * const  *)args, (char * const  *)env);
        } else {
          if (attr->cmdtype == 2) {
            if (attr->detached) {
              apr_proc_detach(1);
            }
            execv(progname, (char * const  *)args);
          } else {
            if (attr->detached) {
              apr_proc_detach(1);
            }
            execvp(progname, (char * const  *)args);
          }
        }
      }
      exit(-1);
    }
  }
  if (attr->child_in) {
    apr_file_close(attr->child_in);
  }
  if (attr->child_out) {
    apr_file_close(attr->child_out);
  }
  if (attr->child_err) {
    apr_file_close(attr->child_err);
  }
  return (0);
}
}
apr_status_t apr_proc_wait_all_procs(apr_proc_t *proc , int *exitcode , apr_exit_why_e *exitwhy ,
                                     apr_wait_how_e waithow , apr_pool_t *p ) 
{ apr_status_t tmp ;

  {
  proc->pid = -1;
  tmp = apr_proc_wait(proc, exitcode, exitwhy, waithow);
  return (tmp);
}
}
apr_status_t apr_proc_wait(apr_proc_t *proc , int *exitcode , apr_exit_why_e *exitwhy ,
                           apr_wait_how_e waithow ) 
{ pid_t pstatus ;
  int waitpid_options ;
  int exit_int ;
  int ignore ;
  apr_exit_why_e ignorewhy ;
  union __anonunion___u_81 __u ;
  union __anonunion___u_82 __u___0 ;
  union __anonunion___u_83 __u___1 ;
  int __status ;
  union __anonunion___u_84 __u___2 ;
  int tmp ;
  union __anonunion___u_85 __u___3 ;
  int *tmp___0 ;

  {
  waitpid_options = 2;
  if ((unsigned int )exitcode == (unsigned int )((void *)0)) {
    exitcode = & ignore;
  }
  if ((unsigned int )exitwhy == (unsigned int )((void *)0)) {
    exitwhy = & ignorewhy;
  }
  if ((int )waithow != 0) {
    waitpid_options |= 1;
  }
  pstatus = waitpid(proc->pid, & exit_int, waitpid_options);
  if (pstatus > 0) {
    proc->pid = pstatus;
    __u___3.__in = exit_int;
    if ((__u___3.__i & 127) == 0) {
      (*exitwhy) = (enum __anonenum_apr_exit_why_e_54 )1;
      __u.__in = exit_int;
      (*exitcode) = (__u.__i & 65280) >> 8;
    } else {
      __u___2.__in = exit_int;
      __status = __u___2.__i;
      if (! ((__status & 255) == 127)) {
        if (! ((__status & 127) == 0)) {
          tmp = 1;
        } else {
          goto _L;
        }
      } else {
        _L: 
        tmp = 0;
      }
      if (tmp) {
        (*exitwhy) = (enum __anonenum_apr_exit_why_e_54 )2;
        __u___0.__in = exit_int;
        if (__u___0.__i & 128) {
          (*exitwhy) = (enum __anonenum_apr_exit_why_e_54 )((int )(*exitwhy) | 4);
        }
        __u___1.__in = exit_int;
        (*exitcode) = __u___1.__i & 127;
      } else {
        return (20014);
      }
    }
    return (70005);
  } else {
    if (pstatus == 0) {
      return (70006);
    }
  }
  tmp___0 = __errno_location();
  return ((*tmp___0));
}
}
apr_status_t apr_procattr_limit_set(apr_procattr_t *attr , apr_int32_t what , struct rlimit *limit ) 
{ 

  {
  switch (what) {
  case 0: 
  attr->limit_cpu = limit;
  break;
  case 1: 
  attr->limit_mem = limit;
  break;
  case 2: 
  attr->limit_nproc = limit;
  break;
  case 3: 
  attr->limit_nofile = limit;
  break;
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-lMTUVEOF.i","-g -pthread")
extern struct _IO_FILE *stdin ;
extern void perror(char const   *__s ) ;
extern __pid_t setsid(void) ;
apr_status_t apr_proc_detach(int daemonize ) 
{ int x ;
  int *tmp ;
  __pid_t tmp___0 ;
  int *tmp___1 ;
  FILE *tmp___2 ;
  int *tmp___3 ;
  FILE *tmp___4 ;
  int *tmp___5 ;
  FILE *tmp___6 ;

  {
  chdir("/");
  if (daemonize) {
    x = fork();
    if (x > 0) {
      exit(0);
    } else {
      if (x == -1) {
        perror("fork");
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"unable to fork new process\n");
        exit(1);
      }
    }
  }
  tmp___0 = setsid();
  if (tmp___0 == -1) {
    tmp = __errno_location();
    return ((*tmp));
  }
  tmp___2 = freopen((char const   * __restrict  )"/dev/null", (char const   * __restrict  )"r",
                    (FILE * __restrict  )stdin);
  if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
    tmp___1 = __errno_location();
    return ((*tmp___1));
  }
  tmp___4 = freopen((char const   * __restrict  )"/dev/null", (char const   * __restrict  )"w",
                    (FILE * __restrict  )stdout);
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
    tmp___3 = __errno_location();
    return ((*tmp___3));
  }
  tmp___6 = freopen((char const   * __restrict  )"/dev/null", (char const   * __restrict  )"w",
                    (FILE * __restrict  )stderr);
  if ((unsigned int )tmp___6 == (unsigned int )((void *)0)) {
    tmp___5 = __errno_location();
    return ((*tmp___5));
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-MfYzQYiS.i","-g -pthread")
extern int sigfillset(sigset_t *__set ) ;
extern int sigdelset(sigset_t *__set , int __signo ) ;
extern int sigwait(sigset_t const   * __restrict  __set , int * __restrict  __sig ) ;
extern char const   * const  sys_siglist[65] ;
extern int pthread_sigmask(int __how , __sigset_t const   * __restrict  __newmask ,
                           __sigset_t * __restrict  __oldmask ) ;
void apr_signal_init(apr_pool_t *pglobal ) ;
apr_status_t apr_proc_kill(apr_proc_t *proc , int signum ) 
{ int *tmp ;
  int tmp___0 ;

  {
  tmp___0 = kill(proc->pid, signum);
  if (tmp___0 == -1) {
    tmp = __errno_location();
    return ((*tmp));
  }
  return (0);
}
}
apr_sigfunc_t *apr_signal(int signo , apr_sigfunc_t *func ) 
{ struct sigaction act ;
  struct sigaction oact ;
  int tmp ;

  {
  act.__sigaction_handler.sa_handler = func;
  sigemptyset(& act.sa_mask);
  act.sa_flags = 0;
  act.sa_flags = act.sa_flags | 536870912;
  tmp = sigaction(signo, (struct sigaction  const  * __restrict  )(& act), (struct sigaction * __restrict  )(& oact));
  if (tmp < 0) {
    return ((void (*)(int  ))-1);
  }
  return (oact.__sigaction_handler.sa_handler);
}
}
void apr_signal_init(apr_pool_t *pglobal ) 
{ 

  {
  return;
}
}
char const   *apr_signal_description_get(int signum ) 
{ 

  {
  return ((char const   *)sys_siglist[signum]);
}
}
static void remove_sync_sigs(sigset_t *sig_mask ) 
{ 

  {
  sigdelset(sig_mask, 6);
  sigdelset(sig_mask, 7);
  sigdelset(sig_mask, 8);
  sigdelset(sig_mask, 4);
  sigdelset(sig_mask, 6);
  sigdelset(sig_mask, 13);
  sigdelset(sig_mask, 11);
  sigdelset(sig_mask, 31);
  sigdelset(sig_mask, 5);
  sigdelset(sig_mask, 12);
  return;
}
}
apr_status_t apr_signal_thread(int (*signal_handler)(int signum ) ) 
{ sigset_t sig_mask ;
  int (*sig_func)(int signum ) ;
  int signal_received ;
  int tmp ;
  int tmp___0 ;

  {
  sig_func = signal_handler;
  sigfillset(& sig_mask);
  sigdelset(& sig_mask, 9);
  sigdelset(& sig_mask, 19);
  sigdelset(& sig_mask, 18);
  remove_sync_sigs(& sig_mask);
  while (1) {
    tmp = sigwait((sigset_t const   * __restrict  )(& sig_mask), (int * __restrict  )(& signal_received));
    if (tmp != 0) {

    }
    tmp___0 = ((*sig_func))(signal_received);
    if (tmp___0 == 1) {
      return (0);
    }
  }
  return (0);
}
}
apr_status_t apr_setup_signal_thread(void) 
{ sigset_t sig_mask ;
  int rv ;

  {
  sigfillset(& sig_mask);
  remove_sync_sigs(& sig_mask);
  rv = pthread_sigmask(2, (__sigset_t const   * __restrict  )(& sig_mask), (__sigset_t * __restrict  )((void *)0));
  if (rv != 0) {

  }
  return (rv);
}
}
char const   *apr_signal_get_description(int signum ) 
{ char const   *tmp ;

  {
  tmp = apr_signal_description_get(signum);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-quEivuni.i","-g -pthread")
extern int pthread_create(pthread_t * __restrict  __threadp , pthread_attr_t const   * __restrict  __attr ,
                          void *(*__start_routine)(void * ) , void * __restrict  __arg ) ;
extern pthread_t pthread_self(void) ;
extern int pthread_equal(pthread_t __thread1 , pthread_t __thread2 ) ;
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern int pthread_detach(pthread_t __th ) ;
extern int pthread_attr_init(pthread_attr_t *__attr ) ;
extern int pthread_attr_setdetachstate(pthread_attr_t *__attr , int __detachstate ) ;
extern int pthread_attr_getdetachstate(pthread_attr_t const   *__attr , int *__detachstate ) ;
extern int pthread_once(pthread_once_t *__once_control , void (*__init_routine)(void) ) ;
apr_status_t apr_threadattr_create(apr_threadattr_t **new , apr_pool_t *pool ) 
{ apr_status_t stat___0 ;
  void *tmp ;
  void *tmp___1 ;

  {
  tmp = apr_palloc(pool, sizeof(apr_threadattr_t ));
  (*new) = (apr_threadattr_t *)memset(tmp, 0, sizeof(apr_threadattr_t ));
  tmp___1 = apr_palloc(pool, sizeof(pthread_attr_t ));
  ((*new))->attr = (pthread_attr_t *)memset(tmp___1, 0, sizeof(pthread_attr_t ));
  if ((unsigned int )(*new) == (unsigned int )((void *)0)) {
    goto _L;
  } else {
    if ((unsigned int )((*new))->attr == (unsigned int )((void *)0)) {
      _L: 
      return (12);
    }
  }
  ((*new))->pool = pool;
  stat___0 = pthread_attr_init(((*new))->attr);
  if (stat___0 == 0) {
    return (0);
  }
  return (stat___0);
}
}
apr_status_t apr_threadattr_detach_set(apr_threadattr_t *attr , apr_int32_t on ) 
{ apr_status_t stat___0 ;

  {
  stat___0 = pthread_attr_setdetachstate(attr->attr, on);
  if (stat___0 == 0) {
    return (0);
  } else {
    return (stat___0);
  }
}
}
apr_status_t apr_threadattr_detach_get(apr_threadattr_t *attr ) 
{ int state ;

  {
  pthread_attr_getdetachstate((pthread_attr_t const   *)attr->attr, & state);
  if (state == 1) {
    return (70003);
  }
  return (70004);
}
}
static void *dummy_worker(void *opaque ) 
{ apr_thread_t *thread ;
  void *tmp ;

  {
  thread = (apr_thread_t *)opaque;
  tmp = ((*(thread->func)))(thread, thread->data);
  return (tmp);
}
}
apr_status_t apr_thread_create(apr_thread_t **new , apr_threadattr_t *attr , void *(*func)(apr_thread_t * ,
                                                                                           void * ) ,
                               void *data , apr_pool_t *pool ) 
{ apr_status_t stat___0 ;
  pthread_attr_t *temp ;
  void *tmp ;
  void *tmp___1 ;

  {
  tmp = apr_palloc(pool, sizeof(apr_thread_t ));
  (*new) = (apr_thread_t *)memset(tmp, 0, sizeof(apr_thread_t ));
  if ((unsigned int )(*new) == (unsigned int )((void *)0)) {
    return (12);
  }
  tmp___1 = apr_palloc(pool, sizeof(pthread_t ));
  ((*new))->td = (pthread_t *)memset(tmp___1, 0, sizeof(pthread_t ));
  if ((unsigned int )((*new))->td == (unsigned int )((void *)0)) {
    return (12);
  }
  ((*new))->pool = pool;
  ((*new))->data = data;
  ((*new))->func = func;
  if (attr) {
    temp = attr->attr;
  } else {
    temp = (pthread_attr_t *)((void *)0);
  }
  stat___0 = apr_pool_create_ex(& ((*new))->pool, pool, (int (*)(int retcode ))((void *)0),
                                (apr_allocator_t *)((void *)0));
  if (stat___0 != 0) {
    return (stat___0);
  }
  stat___0 = pthread_create((pthread_t * __restrict  )((*new))->td, (pthread_attr_t const   * __restrict  )temp,
                            & dummy_worker, (void * __restrict  )(*new));
  if (stat___0 == 0) {
    return (0);
  } else {
    return (stat___0);
  }
}
}
apr_os_thread_t apr_os_thread_current(void) 
{ apr_os_thread_t tmp ;

  {
  tmp = pthread_self();
  return (tmp);
}
}
int apr_os_thread_equal(apr_os_thread_t tid1 , apr_os_thread_t tid2 ) 
{ int tmp ;

  {
  tmp = pthread_equal(tid1, tid2);
  return (tmp);
}
}
apr_status_t apr_thread_exit(apr_thread_t *thd , apr_status_t retval ) 
{ 

  {
  thd->exitval = retval;
  apr_pool_destroy(thd->pool);
  pthread_exit((void *)0);
  return (0);
}
}
apr_status_t apr_thread_join(apr_status_t *retval , apr_thread_t *thd ) 
{ apr_status_t stat___0 ;
  apr_status_t *thread_stat ;

  {
  stat___0 = pthread_join((*(thd->td)), (void **)((void *)(& thread_stat)));
  if (stat___0 == 0) {
    (*retval) = thd->exitval;
    return (0);
  } else {
    return (stat___0);
  }
}
}
apr_status_t apr_thread_detach(apr_thread_t *thd ) 
{ apr_status_t stat___0 ;

  {
  stat___0 = pthread_detach((*(thd->td)));
  if (stat___0 == 0) {
    return (0);
  } else {
    return (stat___0);
  }
}
}
void apr_thread_yield(void) 
{ 

  {
  return;
}
}
apr_status_t apr_thread_data_get(void **data , char const   *key , apr_thread_t *thread ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_userdata_get(data, key, thread->pool);
  return (tmp);
}
}
apr_status_t apr_thread_data_set(void *data , char const   *key , apr_status_t (*cleanup)(void * ) ,
                                 apr_thread_t *thread ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_userdata_set((void const   *)data, key, cleanup, thread->pool);
  return (tmp);
}
}
apr_status_t apr_os_thread_get(apr_os_thread_t **thethd , apr_thread_t *thd ) 
{ 

  {
  (*thethd) = thd->td;
  return (0);
}
}
apr_status_t apr_os_thread_put(apr_thread_t **thd , apr_os_thread_t *thethd , apr_pool_t *pool ) 
{ void *tmp ;

  {
  if ((unsigned int )pool == (unsigned int )((void *)0)) {
    return (20002);
  }
  if ((unsigned int )(*thd) == (unsigned int )((void *)0)) {
    tmp = apr_palloc(pool, sizeof(apr_thread_t ));
    (*thd) = (apr_thread_t *)memset(tmp, 0, sizeof(apr_thread_t ));
    ((*thd))->pool = pool;
  }
  ((*thd))->td = thethd;
  return (0);
}
}
static int const   once_init  =    (int const   )0;
apr_status_t apr_thread_once_init(apr_thread_once_t **control , apr_pool_t *p ) 
{ 

  {
  (*control) = (apr_thread_once_t *)apr_palloc(p, sizeof((*((*control)))));
  ((*control))->once = (int )once_init;
  return (0);
}
}
apr_status_t apr_thread_once(apr_thread_once_t *control , void (*func)(void) ) 
{ apr_status_t tmp ;

  {
  tmp = pthread_once(& control->once, func);
  return (tmp);
}
}
apr_pool_t *apr_thread_pool_get(apr_thread_t const   *ob ) 
{ 

  {
  return (ob->pool);
}
}
#pragma merger(0,"/tmp/cil-K6R4fkLm.i","-g -pthread")
extern int pthread_key_create(pthread_key_t *__key , void (*__destr_function)(void * ) ) ;
extern int pthread_key_delete(pthread_key_t __key ) ;
extern int pthread_setspecific(pthread_key_t __key , void const   *__pointer ) ;
extern void *pthread_getspecific(pthread_key_t __key ) ;
apr_status_t apr_threadkey_private_create(apr_threadkey_t **key , void (*dest)(void * ) ,
                                          apr_pool_t *pool ) 
{ void *tmp ;
  apr_status_t tmp___1 ;

  {
  tmp = apr_palloc(pool, sizeof(apr_threadkey_t ));
  (*key) = (apr_threadkey_t *)memset(tmp, 0, sizeof(apr_threadkey_t ));
  if ((unsigned int )(*key) == (unsigned int )((void *)0)) {
    return (12);
  }
  ((*key))->pool = pool;
  tmp___1 = pthread_key_create(& ((*key))->key, dest);
  return (tmp___1);
}
}
apr_status_t apr_threadkey_private_get(void **new , apr_threadkey_t *key ) 
{ 

  {
  (*new) = pthread_getspecific(key->key);
  return (0);
}
}
apr_status_t apr_threadkey_private_set(void *priv , apr_threadkey_t *key ) 
{ apr_status_t stat___0 ;

  {
  stat___0 = pthread_setspecific(key->key, (void const   *)priv);
  if (stat___0 == 0) {
    return (0);
  } else {
    return (stat___0);
  }
}
}
apr_status_t apr_threadkey_private_delete(apr_threadkey_t *key ) 
{ apr_status_t stat___0 ;

  {
  stat___0 = pthread_key_delete(key->key);
  if (stat___0 == 0) {
    return (0);
  }
  return (stat___0);
}
}
apr_status_t apr_threadkey_data_get(void **data , char const   *key , apr_threadkey_t *threadkey ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_userdata_get(data, key, threadkey->pool);
  return (tmp);
}
}
apr_status_t apr_threadkey_data_set(void *data , char const   *key , apr_status_t (*cleanup)(void * ) ,
                                    apr_threadkey_t *threadkey ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_userdata_set((void const   *)data, key, cleanup, threadkey->pool);
  return (tmp);
}
}
apr_status_t apr_os_threadkey_get(apr_os_threadkey_t *thekey , apr_threadkey_t *key ) 
{ 

  {
  (*thekey) = key->key;
  return (0);
}
}
apr_status_t apr_os_threadkey_put(apr_threadkey_t **key , apr_os_threadkey_t *thekey ,
                                  apr_pool_t *pool ) 
{ void *tmp ;

  {
  if ((unsigned int )pool == (unsigned int )((void *)0)) {
    return (20002);
  }
  if ((unsigned int )(*key) == (unsigned int )((void *)0)) {
    tmp = apr_palloc(pool, sizeof(apr_threadkey_t ));
    (*key) = (apr_threadkey_t *)memset(tmp, 0, sizeof(apr_threadkey_t ));
    ((*key))->pool = pool;
  }
  ((*key))->key = (*thekey);
  return (0);
}
}
#pragma merger(0,"/tmp/cil-ZvEH7TVu.i","-g -pthread")
char const   *apr_os_default_encoding(apr_pool_t *pool ) 
{ 

  {
  return ("ISO8859-1");
  return ("unknown");
}
}
char const   *apr_os_locale_encoding(apr_pool_t *pool ) 
{ char const   *tmp ;

  {
  tmp = apr_os_default_encoding(pool);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-sChblxsv.i","-g -pthread")
extern char *strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
extern char const   *hstrerror(int __err_num ) ;
extern char const   *gai_strerror(int __ecode ) ;
static char *stuffbuffer(char *buf , apr_size_t bufsize , char const   *s ) 
{ 

  {
  apr_cpystrn(buf, s, bufsize);
  return (buf);
}
}
static char *apr_error_string(apr_status_t statcode ) 
{ 

  {
  switch (statcode) {
  case 20002: ;
  return ((char *)"A new pool could not be created.");
  case 20004: ;
  return ((char *)"An invalid date has been provided");
  case 20005: ;
  return ((char *)"An invalid socket was returned");
  case 20006: ;
  return ((char *)"No process was provided and one was required.");
  case 20007: ;
  return ((char *)"No time was provided and one was required.");
  case 20008: ;
  return ((char *)"No directory was provided and one was required.");
  case 20009: ;
  return ((char *)"No lock was provided and one was required.");
  case 20010: ;
  return ((char *)"No poll structure was provided and one was required.");
  case 20011: ;
  return ((char *)"No socket was provided and one was required.");
  case 20012: ;
  return ((char *)"No thread was provided and one was required.");
  case 20013: ;
  return ((char *)"No thread key structure was provided and one was required.");
  case 20015: ;
  return ((char *)"No shared memory is currently available");
  case 20019: ;
  return ((char *)"DSO load failed");
  case 20016: ;
  return ((char *)"The specified IP address is invalid.");
  case 20017: ;
  return ((char *)"The specified network mask is invalid.");
  case 70001: ;
  return ((char *)"Your code just forked, and you are currently executing in the child process");
  case 70002: ;
  return ((char *)"Your code just forked, and you are currently executing in the parent process");
  case 70003: ;
  return ((char *)"The specified thread is detached");
  case 70004: ;
  return ((char *)"The specified thread is not detached");
  case 70005: ;
  return ((char *)"The specified child process is done executing");
  case 70006: ;
  return ((char *)"The specified child process is not done executing");
  case 70007: ;
  return ((char *)"The timeout specified has expired");
  case 70008: ;
  return ((char *)"Partial results are valid but processing is incomplete");
  case 70012: ;
  return ((char *)"Bad character specified on command line");
  case 70013: ;
  return ((char *)"Missing parameter for the specified command line option");
  case 70014: ;
  return ((char *)"End of file found");
  case 70015: ;
  return ((char *)"Could not find specified socket in poll list.");
  case 70019: ;
  return ((char *)"Shared memory is implemented anonymously");
  case 70020: ;
  return ((char *)"Shared memory is implemented using files");
  case 70021: ;
  return ((char *)"Shared memory is implemented using a key system");
  case 70022: ;
  return ((char *)"There is no error, this value signifies an initialized error code");
  case 70023: ;
  return ((char *)"This function has not been implemented on this platform");
  case 70024: ;
  return ((char *)"passwords do not match");
  case 20020: ;
  return ((char *)"The given path is absolute");
  case 20021: ;
  return ((char *)"The given path is relative");
  case 20022: ;
  return ((char *)"The given path is incomplete");
  case 20023: ;
  return ((char *)"The given path was above the root path");
  case 20024: ;
  return ((char *)"The given path misformatted or contained invalid characters");
  default: ;
  return ((char *)"Error string not specified yet");
  }
}
}
static char *apr_os_strerror(char *buf , apr_size_t bufsize , int err ) 
{ char const   *tmp ;
  char *tmp___0 ;

  {
  tmp = hstrerror(err);
  tmp___0 = stuffbuffer(buf, bufsize, tmp);
  return (tmp___0);
}
}
static char *native_strerror(apr_status_t statcode , char *buf , apr_size_t bufsize ) 
{ char const   *msg ;
  char *tmp ;

  {
  (*(buf + 0)) = (char )'\000';
  msg = strerror_r(statcode, buf, bufsize);
  if ((int )(*(buf + 0)) == 0) {
    tmp = stuffbuffer(buf, bufsize, msg);
    return (tmp);
  } else {
    return (buf);
  }
}
}
char *apr_strerror(apr_status_t statcode , char *buf , apr_size_t bufsize ) 
{ char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  if (statcode < 20000) {
    tmp = native_strerror(statcode, buf, bufsize);
    return (tmp);
  } else {
    if (statcode < 120000) {
      tmp___0 = apr_error_string(statcode);
      tmp___1 = stuffbuffer(buf, bufsize, tmp___0);
      return (tmp___1);
    } else {
      if (statcode < 670000) {
        tmp___2 = stuffbuffer(buf, bufsize, "APR does not understand this error code");
        return (tmp___2);
      } else {
        if (statcode < 720000) {
          statcode -= 670000;
          statcode = - statcode;
          tmp___3 = gai_strerror(statcode);
          tmp___4 = stuffbuffer(buf, bufsize, tmp___3);
          return (tmp___4);
        } else {
          tmp___5 = apr_os_strerror(buf, bufsize, statcode - 720000);
          return (tmp___5);
        }
      }
    }
  }
}
}
#pragma merger(0,"/tmp/cil-8F8kS3VI.i","-g -pthread")
apr_status_t apr_getopt_init(apr_getopt_t **os , apr_pool_t *cont , int argc , char const   * const  *argv ) 
{ void *argv_buff ;

  {
  (*os) = (apr_getopt_t *)apr_palloc(cont, sizeof(apr_getopt_t ));
  ((*os))->cont = cont;
  ((*os))->reset = 0;
  ((*os))->errfn = (apr_getopt_err_fn_t *)(& fprintf);
  ((*os))->errarg = (void *)stderr;
  ((*os))->place = "";
  ((*os))->argc = argc;
  argv_buff = apr_palloc(cont, (unsigned int )(argc + 1) * sizeof(char const   *));
  memcpy((void * __restrict  )argv_buff, (void const   * __restrict  )argv, (unsigned int )argc *
                                                                            sizeof(char const   *));
  ((*os))->argv = (char const   **)argv_buff;
  (*(((*os))->argv + argc)) = (char const   *)((void *)0);
  ((*os))->interleave = 0;
  ((*os))->ind = 1;
  ((*os))->skip_start = 1;
  ((*os))->skip_end = 1;
  return (0);
}
}
apr_status_t apr_getopt(apr_getopt_t *os , char const   *opts , char *optch , char const   **optarg ) 
{ char const   *oli ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  if (os->reset) {
    goto _L___1;
  } else {
    if (! (*(os->place))) {
      _L___1: 
      os->reset = 0;
      if (os->ind >= os->argc) {
        goto _L;
      } else {
        os->place = (*(os->argv + os->ind));
        if ((int const   )(*(os->place)) != 45) {
          _L: 
          os->place = "";
          (*optch) = (char )os->opt;
          return (70014);
        }
      }
      if ((*(os->place + 1))) {
        os->place = os->place + 1;
        if ((int const   )(*(os->place)) == 45) {
          os->ind = os->ind + 1;
          os->place = "";
          (*optch) = (char )os->opt;
          return (70014);
        } else {
          goto _L___0;
        }
      } else {
        _L___0: ;
      }
    }
  }
  tmp___0 = os->place;
  os->place = os->place + 1;
  os->opt = (int )(*tmp___0);
  if (os->opt == 58) {
    goto _L___3;
  } else {
    oli = strchr(opts, os->opt);
    if (! oli) {
      _L___3: 
      if (os->opt == 45) {
        (*optch) = (char )os->opt;
        return (70014);
      }
      if (! (*(os->place))) {
        os->ind = os->ind + 1;
      }
      if (os->errfn) {
        if ((int const   )(*opts) != 58) {
          tmp = apr_filepath_name_get((*(os->argv)));
          ((*(os->errfn)))(os->errarg, "%s: illegal option -- %c\n", tmp, os->opt);
        } else {
          goto _L___2;
        }
      } else {
        _L___2: ;
      }
      (*optch) = (char )os->opt;
      return (70012);
    }
  }
  oli ++;
  if ((int const   )(*oli) != 58) {
    (*optarg) = (char const   *)((void *)0);
    if (! (*(os->place))) {
      os->ind = os->ind + 1;
    }
  } else {
    if ((*(os->place))) {
      (*optarg) = os->place;
    } else {
      os->ind = os->ind + 1;
      if (os->argc <= os->ind) {
        os->place = "";
        if ((int const   )(*opts) == 58) {
          (*optch) = (char )os->opt;
          return (70013);
        }
        if (os->errfn) {
          tmp___1 = apr_filepath_name_get((*(os->argv)));
          ((*(os->errfn)))(os->errarg, "%s: option requires an argument -- %c\n",
                           tmp___1, os->opt);
        }
        (*optch) = (char )os->opt;
        return (70012);
      } else {
        (*optarg) = (*(os->argv + os->ind));
      }
    }
    os->place = "";
    os->ind = os->ind + 1;
  }
  (*optch) = (char )os->opt;
  return (0);
}
}
static void reverse(char const   **argv , int start , int len ) 
{ char const   *temp ;

  {
  while (len >= 2) {
    temp = (*(argv + start));
    (*(argv + start)) = (*(argv + ((start + len) - 1)));
    (*(argv + ((start + len) - 1))) = temp;
    start ++;
    len -= 2;
  }
  return;
}
}
static void permute(apr_getopt_t *os ) 
{ int len1 ;
  int len2 ;

  {
  len1 = os->skip_end - os->skip_start;
  len2 = os->ind - os->skip_end;
  if (os->interleave) {
    reverse(os->argv, os->skip_start, len1 + len2);
    reverse(os->argv, os->skip_start, len2);
    reverse(os->argv, os->skip_start + len2, len1);
  }
  os->skip_start = os->skip_start + len2;
  os->skip_end = os->skip_end + len2;
  return;
}
}
static apr_status_t serr(apr_getopt_t *os , char const   *err , char const   *str ,
                         apr_status_t status ) 
{ char const   *tmp ;

  {
  if (os->errfn) {
    tmp = apr_filepath_name_get((*(os->argv)));
    ((*(os->errfn)))(os->errarg, "%s: %s: %s\n", tmp, err, str);
  }
  return (status);
}
}
static apr_status_t cerr(apr_getopt_t *os , char const   *err , int ch , apr_status_t status ) 
{ char const   *tmp ;

  {
  if (os->errfn) {
    tmp = apr_filepath_name_get((*(os->argv)));
    ((*(os->errfn)))(os->errarg, "%s: %s: %c\n", tmp, err, ch);
  }
  return (status);
}
}
apr_status_t apr_getopt_long(apr_getopt_t *os , apr_getopt_option_t const   *opts ,
                             int *optch , char const   **optarg ) 
{ char const   *p ;
  int i ;
  int tmp ;
  apr_size_t len ;
  apr_status_t tmp___0 ;
  int tmp___1 ;
  apr_status_t tmp___2 ;
  int tmp___3 ;
  apr_status_t tmp___4 ;
  apr_status_t tmp___5 ;
  apr_status_t tmp___6 ;
  char const   *tmp___7 ;
  apr_status_t tmp___8 ;
  int tmp___9 ;

  {
  if (os->reset) {
    os->place = "";
    os->ind = 1;
    os->reset = 0;
  }
  p = os->place;
  if ((int const   )(*p) == 0) {
    if (os->interleave) {
      while (1) {
        if (os->ind < os->argc) {
          if (! ((int const   )(*((*(os->argv + os->ind)))) != 45)) {
            goto _L;
          }
        } else {
          _L: 
          break;
        }
        os->ind = os->ind + 1;
      }
      os->skip_end = os->ind;
    }
    if (os->ind >= os->argc) {
      goto _L___0;
    } else {
      if ((int const   )(*((*(os->argv + os->ind)))) != 45) {
        _L___0: 
        os->ind = os->skip_start;
        return (70014);
      }
    }
    tmp = os->ind;
    os->ind = os->ind + 1;
    p = (*(os->argv + tmp)) + 1;
    if ((int const   )(*p) == 45) {
      if ((int const   )(*(p + 1)) != 0) {
        len = 0U;
        p ++;
        i = 0;
        while (1) {
          if ((opts + i)->optch == 0) {
            tmp___0 = serr(os, "invalid option", p - 2, 70012);
            return (tmp___0);
          }
          if ((opts + i)->name) {
            len = strlen((opts + i)->name);
            tmp___1 = strncmp(p, (opts + i)->name, len);
            if (tmp___1 == 0) {
              if ((int const   )(*(p + len)) == 0) {
                goto _L___2;
              } else {
                if ((int const   )(*(p + len)) == 61) {
                  _L___2: 
                  break;
                } else {
                  goto _L___1;
                }
              }
            } else {
              _L___1: ;
            }
          }
          i ++;
        }
        (*optch) = (opts + i)->optch;
        if ((opts + i)->has_arg) {
          if ((int const   )(*(p + len)) == 61) {
            (*optarg) = (p + len) + 1;
          } else {
            if (os->ind >= os->argc) {
              tmp___2 = serr(os, "missing argument", p - 2, 70013);
              return (tmp___2);
            } else {
              tmp___3 = os->ind;
              os->ind = os->ind + 1;
              (*optarg) = (*(os->argv + tmp___3));
            }
          }
        } else {
          (*optarg) = (char const   *)((void *)0);
          if ((int const   )(*(p + len)) == 61) {
            tmp___4 = serr(os, "erroneous argument", p - 2, 70013);
            return (tmp___4);
          }
        }
        permute(os);
        return (0);
      } else {
        goto _L___3;
      }
    } else {
      _L___3: 
      if ((int const   )(*p) == 45) {
        permute(os);
        os->ind = os->skip_start;
        return (70014);
      } else {
        if ((int const   )(*p) == 0) {
          tmp___5 = serr(os, "invalid option", p, 70012);
          return (tmp___5);
        }
      }
    }
  }
  i = 0;
  while (1) {
    if ((opts + i)->optch == 0) {
      tmp___6 = cerr(os, "invalid option character", (int )(*p), 70012);
      return (tmp___6);
    }
    if ((int const   )(*p) == (int const   )(opts + i)->optch) {
      break;
    }
    i ++;
  }
  tmp___7 = p;
  p ++;
  (*optch) = (int )(*tmp___7);
  if ((opts + i)->has_arg) {
    if ((int const   )(*p) != 0) {
      (*optarg) = p;
    } else {
      if (os->ind >= os->argc) {
        tmp___8 = cerr(os, "missing argument", (*optch), 70013);
        return (tmp___8);
      } else {
        tmp___9 = os->ind;
        os->ind = os->ind + 1;
        (*optarg) = (*(os->argv + tmp___9));
      }
    }
    os->place = "";
  } else {
    (*optarg) = (char const   *)((void *)0);
    os->place = p;
  }
  permute(os);
  return (0);
}
}
#pragma merger(0,"/tmp/cil-RO3HKINU.i","-g -pthread")
static apr_other_child_rec_t *other_children  =    (apr_other_child_rec_t *)((void *)0);
static apr_status_t other_child_cleanup(void *data ) 
{ apr_other_child_rec_t **pocr ;
  apr_other_child_rec_t *nocr ;

  {
  pocr = & other_children;
  while ((*pocr)) {
    if ((unsigned int )((*pocr))->data == (unsigned int )data) {
      nocr = ((*pocr))->next;
      ((*(((*pocr))->maintenance)))(3, ((*pocr))->data, -1);
      (*pocr) = nocr;
      return (0);
    }
    pocr = & ((*pocr))->next;
  }
  return (0);
}
}
void apr_proc_other_child_register(apr_proc_t *pid , void (*maintenance)(int reason ,
                                                                         void * ,
                                                                         int status ) ,
                                   void *data , apr_file_t *write_fd , apr_pool_t *p ) 
{ apr_other_child_rec_t *ocr ;

  {
  ocr = (apr_other_child_rec_t *)apr_palloc(p, sizeof((*ocr)));
  ocr->p = p;
  ocr->proc = pid;
  ocr->maintenance = maintenance;
  ocr->data = data;
  if ((unsigned int )write_fd == (unsigned int )((void *)0)) {
    ocr->write_fd = -1;
  } else {
    ocr->write_fd = write_fd->filedes;
  }
  ocr->next = other_children;
  other_children = ocr;
  apr_pool_cleanup_register(p, (void const   *)ocr->data, & other_child_cleanup, & apr_pool_cleanup_null);
  return;
}
}
void apr_proc_other_child_unregister(void *data ) 
{ apr_other_child_rec_t *cur ;

  {
  cur = other_children;
  while (cur) {
    if ((unsigned int )cur->data == (unsigned int )data) {
      break;
    }
    cur = cur->next;
  }
  apr_pool_cleanup_kill(cur->p, (void const   *)cur->data, & other_child_cleanup);
  other_child_cleanup(data);
  return;
}
}
apr_status_t apr_proc_other_child_read(apr_proc_t *pid , int status ) 
{ apr_other_child_rec_t *ocr ;
  apr_other_child_rec_t *nocr ;

  {
  ocr = other_children;
  while (ocr) {
    nocr = ocr->next;
    if ((ocr->proc)->pid != pid->pid) {
      goto __Cont;
    }
    ocr->proc = (apr_proc_t *)((void *)0);
    ((*(ocr->maintenance)))(0, ocr->data, status);
    return (0);
    __Cont: 
    ocr = nocr;
  }
  return (70006);
}
}
void apr_proc_other_child_check(void) 
{ apr_other_child_rec_t *ocr ;
  apr_other_child_rec_t *nocr ;
  pid_t waitret ;
  int status ;

  {
  ocr = other_children;
  while (ocr) {
    nocr = ocr->next;
    if ((unsigned int )ocr->proc == (unsigned int )((void *)0)) {
      goto __Cont;
    }
    waitret = waitpid((ocr->proc)->pid, & status, 1);
    if (waitret == (ocr->proc)->pid) {
      ocr->proc = (apr_proc_t *)((void *)0);
      ((*(ocr->maintenance)))(0, ocr->data, status);
    } else {
      if (waitret == 0) {
        ((*(ocr->maintenance)))(2, ocr->data, -1);
      } else {
        if (waitret == -1) {
          ocr->proc = (apr_proc_t *)((void *)0);
          ((*(ocr->maintenance)))(4, ocr->data, -1);
        }
      }
    }
    __Cont: 
    ocr = nocr;
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-NXs76rTQ.i","-g -pthread")
apr_status_t apr_generate_random_bytes(unsigned char *buf , int length ) 
{ int fd ;
  apr_ssize_t rc ;
  int *tmp ;
  int errnum ;
  int *tmp___0 ;

  {
  fd = -1;
  while (1) {
    if (fd == -1) {
      fd = open("/dev/random", 0);
      if (fd == -1) {
        tmp = __errno_location();
        return ((*tmp));
      }
    }
    rc = read(fd, (void *)buf, (unsigned int )length);
    if (rc < 0) {
      tmp___0 = __errno_location();
      errnum = (*tmp___0);
      close(fd);
      return (errnum);
    } else {
      if (rc == 0) {
        close(fd);
        fd = -1;
      } else {
        buf += rc;
        length -= rc;
      }
    }
    if (! (length > 0)) {
      break;
    }
  }
  close(fd);
  return (0);
}
}
#pragma merger(0,"/tmp/cil-iQhuvkeN.i","-g -pthread")
apr_status_t apr_atomic_init(apr_pool_t *p ) ;
void apr_proc_mutex_unix_setup_lock(void) ;
void apr_unix_setup_time(void) ;
apr_status_t apr_app_initialize(int *argc , char const   * const  **argv , char const   * const  **env ) 
{ apr_status_t tmp ;

  {
  tmp = apr_initialize();
  return (tmp);
}
}
static int initialized  =    0;
apr_status_t apr_initialize(void) 
{ apr_pool_t *pool ;
  apr_status_t status ;
  int tmp ;
  apr_status_t tmp___0 ;

  {
  tmp = initialized;
  initialized ++;
  if (tmp) {
    return (0);
  }
  apr_proc_mutex_unix_setup_lock();
  apr_unix_setup_time();
  status = apr_pool_initialize();
  if (status != 0) {
    return (status);
  }
  tmp___0 = apr_pool_create_ex(& pool, (apr_pool_t *)((void *)0), (int (*)(int retcode ))((void *)0),
                               (apr_allocator_t *)((void *)0));
  if (tmp___0 != 0) {
    return (20002);
  }
  apr_pool_tag(pool, "apr_initialize");
  status = apr_atomic_init(pool);
  if (status != 0) {
    return (status);
  }
  apr_signal_init(pool);
  return (0);
}
}
void apr_terminate(void) 
{ 

  {
  initialized --;
  if (initialized) {
    return;
  }
  apr_pool_terminate();
  return;
}
}
void apr_terminate2(void) 
{ 

  {
  apr_terminate();
  return;
}
}
#pragma merger(0,"/tmp/cil-omEagWin.i","-g -pthread")
void apr_version(apr_version_t *pvsn ) 
{ 

  {
  pvsn->major = 0;
  pvsn->minor = 9;
  pvsn->patch = 2;
  pvsn->is_dev = 1;
  return;
}
}
char const   *apr_version_string(void) 
{ 

  {
  return ("0.9.2-dev");
}
}
#pragma merger(0,"/tmp/cil-4gRn33do.i","-g -pthread")
static apr_status_t global_mutex_cleanup(void *data ) 
{ apr_global_mutex_t *m ;
  apr_status_t rv ;

  {
  m = (apr_global_mutex_t *)data;
  rv = apr_proc_mutex_destroy(m->proc_mutex);
  if (m->thread_mutex) {
    if (rv != 0) {
      apr_thread_mutex_destroy(m->thread_mutex);
    } else {
      rv = apr_thread_mutex_destroy(m->thread_mutex);
    }
  }
  return (rv);
}
}
apr_status_t apr_global_mutex_create(apr_global_mutex_t **mutex , char const   *fname ,
                                     apr_lockmech_e mech , apr_pool_t *pool ) 
{ apr_status_t rv ;
  apr_global_mutex_t *m ;

  {
  m = (apr_global_mutex_t *)apr_palloc(pool, sizeof((*m)));
  m->pool = pool;
  rv = apr_proc_mutex_create(& m->proc_mutex, fname, mech, m->pool);
  if (rv != 0) {
    return (rv);
  }
  if (((m->proc_mutex)->inter_meth)->flags & 1U) {
    m->thread_mutex = (apr_thread_mutex_t *)((void *)0);
  } else {
    rv = apr_thread_mutex_create(& m->thread_mutex, 0U, m->pool);
    if (rv != 0) {
      rv = apr_proc_mutex_destroy(m->proc_mutex);
      return (rv);
    }
  }
  apr_pool_cleanup_register(m->pool, (void const   *)((void *)m), & global_mutex_cleanup,
                            & apr_pool_cleanup_null);
  (*mutex) = m;
  return (0);
}
}
apr_status_t apr_global_mutex_child_init(apr_global_mutex_t **mutex , char const   *fname ,
                                         apr_pool_t *pool ) 
{ 

  {
  return (0);
}
}
apr_status_t apr_global_mutex_lock(apr_global_mutex_t *mutex ) 
{ apr_status_t rv ;

  {
  if (mutex->thread_mutex) {
    rv = apr_thread_mutex_lock(mutex->thread_mutex);
    if (rv != 0) {
      return (rv);
    }
  }
  rv = apr_proc_mutex_lock(mutex->proc_mutex);
  if (rv != 0) {
    if (mutex->thread_mutex) {
      apr_thread_mutex_unlock(mutex->thread_mutex);
    }
  }
  return (rv);
}
}
apr_status_t apr_global_mutex_trylock(apr_global_mutex_t *mutex ) 
{ apr_status_t rv ;

  {
  if (mutex->thread_mutex) {
    rv = apr_thread_mutex_trylock(mutex->thread_mutex);
    if (rv != 0) {
      return (rv);
    }
  }
  rv = apr_proc_mutex_trylock(mutex->proc_mutex);
  if (rv != 0) {
    if (mutex->thread_mutex) {
      apr_thread_mutex_unlock(mutex->thread_mutex);
    }
  }
  return (rv);
}
}
apr_status_t apr_global_mutex_unlock(apr_global_mutex_t *mutex ) 
{ apr_status_t rv ;

  {
  rv = apr_proc_mutex_unlock(mutex->proc_mutex);
  if (mutex->thread_mutex) {
    if (rv != 0) {
      apr_thread_mutex_unlock(mutex->thread_mutex);
    } else {
      rv = apr_thread_mutex_unlock(mutex->thread_mutex);
    }
  }
  return (rv);
}
}
apr_status_t apr_os_global_mutex_get(apr_os_global_mutex_t *ospmutex , apr_global_mutex_t *pmutex ) 
{ 

  {
  ospmutex->pool = pmutex->pool;
  ospmutex->proc_mutex = pmutex->proc_mutex;
  ospmutex->thread_mutex = pmutex->thread_mutex;
  return (0);
}
}
apr_status_t apr_global_mutex_destroy(apr_global_mutex_t *mutex ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_cleanup_run(mutex->pool, (void *)mutex, & global_mutex_cleanup);
  return (tmp);
}
}
apr_pool_t *apr_global_mutex_pool_get(apr_global_mutex_t const   *ob ) 
{ 

  {
  return (ob->pool);
}
}
#pragma merger(0,"/tmp/cil-l4bTAjCf.i","-g -pthread")
extern int pthread_mutex_init(pthread_mutex_t * __restrict  __mutex , pthread_mutexattr_t const   * __restrict  __mutex_attr ) ;
extern int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
extern int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
extern int pthread_mutexattr_init(pthread_mutexattr_t *__attr ) ;
extern int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr ) ;
extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr , int __pshared ) ;
extern int semget(key_t __key , int __nsems , int __semflg ) ;
extern int semop(int __semid , struct sembuf *__sops , size_t __nsops ) ;
extern int flock(int __fd , int __operation ) ;
extern void *mmap(void *__addr , size_t __len , int __prot , int __flags , int __fd ,
                  __off_t __offset ) ;
extern int munmap(void *__addr , size_t __len ) ;
extern sem_t *sem_open(char const   *__name , int __oflag  , ...) ;
extern int sem_close(sem_t *__sem ) ;
extern int sem_unlink(char const   *__name ) ;
extern int sem_wait(sem_t *__sem ) ;
extern int sem_post(sem_t *__sem ) ;
struct apr_proc_mutex_unix_lock_methods_t  const  apr_proc_mutex_unix_posix_methods ;
struct apr_proc_mutex_unix_lock_methods_t  const  apr_proc_mutex_unix_sysv_methods ;
struct apr_proc_mutex_unix_lock_methods_t  const  apr_proc_mutex_unix_fcntl_methods ;
struct apr_proc_mutex_unix_lock_methods_t  const  apr_proc_mutex_unix_flock_methods ;
struct apr_proc_mutex_unix_lock_methods_t  const  apr_proc_mutex_unix_proc_pthread_methods ;
apr_status_t apr_proc_mutex_destroy(apr_proc_mutex_t *mutex ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_cleanup_run(mutex->pool, (void *)mutex, & apr_proc_mutex_cleanup);
  return (tmp);
}
}
static void proc_mutex_posix_setup(void) 
{ 

  {
  return;
}
}
static apr_status_t proc_mutex_posix_cleanup(void *mutex_ ) 
{ apr_proc_mutex_t *mutex ;
  apr_status_t stat___0 ;
  int *tmp ;
  int tmp___0 ;

  {
  mutex = (apr_proc_mutex_t *)mutex_;
  stat___0 = 0;
  if ((mutex->interproc)->filedes != -1) {
    tmp___0 = sem_close((sem_t *)(mutex->interproc)->filedes);
    if (tmp___0 < 0) {
      tmp = __errno_location();
      stat___0 = (*tmp);
    }
  }
  return (stat___0);
}
}
static apr_status_t proc_mutex_posix_create(apr_proc_mutex_t *new_mutex , char const   *fname ) 
{ sem_t *psem ;
  apr_status_t stat___0 ;
  char semname[14] ;
  apr_time_t now ;
  unsigned long epoch ;
  int *tmp ;

  {
  new_mutex->interproc = (apr_file_t *)apr_palloc(new_mutex->pool, sizeof((*(new_mutex->interproc))));
  now = apr_time_now();
  epoch = (unsigned long )(now / 1000000LL);
  apr_snprintf(semname, sizeof(semname), "/ApR.%lx", epoch);
  psem = sem_open((char const   *)(semname), 64, 420, 1);
  if ((unsigned int )psem == (unsigned int )((sem_t *)0)) {
    tmp = __errno_location();
    stat___0 = (*tmp);
    proc_mutex_posix_cleanup((void *)new_mutex);
    return (stat___0);
  }
  sem_unlink((char const   *)(semname));
  (new_mutex->interproc)->filedes = (int )psem;
  apr_pool_cleanup_register(new_mutex->pool, (void const   *)((void *)new_mutex),
                            & apr_proc_mutex_cleanup, & apr_pool_cleanup_null);
  return (0);
}
}
static apr_status_t proc_mutex_posix_acquire(apr_proc_mutex_t *mutex ) 
{ int rc ;
  int *tmp ;

  {
  rc = sem_wait((sem_t *)(mutex->interproc)->filedes);
  if (rc < 0) {
    tmp = __errno_location();
    return ((*tmp));
  }
  mutex->curr_locked = 1;
  return (0);
}
}
static apr_status_t proc_mutex_posix_release(apr_proc_mutex_t *mutex ) 
{ int rc ;
  int *tmp ;

  {
  rc = sem_post((sem_t *)(mutex->interproc)->filedes);
  if (rc < 0) {
    tmp = __errno_location();
    return ((*tmp));
  }
  mutex->curr_locked = 0;
  return (0);
}
}
static apr_status_t proc_mutex_posix_child_init(apr_proc_mutex_t **mutex , apr_pool_t *cont ,
                                                char const   *fname ) 
{ 

  {
  return (0);
}
}
struct apr_proc_mutex_unix_lock_methods_t  const  apr_proc_mutex_unix_posix_methods  = 
     {0U, & proc_mutex_posix_create, & proc_mutex_posix_acquire, (apr_status_t (*)(apr_proc_mutex_t * ))((void *)0),
    & proc_mutex_posix_release, & proc_mutex_posix_cleanup, & proc_mutex_posix_child_init,
    "posixsem"};
static struct sembuf proc_mutex_op_on  ;
static struct sembuf proc_mutex_op_off  ;
static void proc_mutex_sysv_setup(void) 
{ 

  {
  proc_mutex_op_on.sem_num = (unsigned short)0;
  proc_mutex_op_on.sem_op = (short)-1;
  proc_mutex_op_on.sem_flg = (short)4096;
  proc_mutex_op_off.sem_num = (unsigned short)0;
  proc_mutex_op_off.sem_op = (short)1;
  proc_mutex_op_off.sem_flg = (short)4096;
  return;
}
}
static apr_status_t proc_mutex_sysv_cleanup(void *mutex_ ) 
{ apr_proc_mutex_t *mutex ;
  union semun___0 ick ;

  {
  mutex = (apr_proc_mutex_t *)mutex_;
  if ((mutex->interproc)->filedes != -1) {
    ick.val = 0;
    semctl((mutex->interproc)->filedes, 0, 0, ick);
  }
  return (0);
}
}
static apr_status_t proc_mutex_sysv_create(apr_proc_mutex_t *new_mutex , char const   *fname ) 
{ union semun___0 ick ;
  apr_status_t rv ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  new_mutex->interproc = (apr_file_t *)apr_palloc(new_mutex->pool, sizeof((*(new_mutex->interproc))));
  (new_mutex->interproc)->filedes = semget(0, 1, 896);
  if ((new_mutex->interproc)->filedes < 0) {
    tmp = __errno_location();
    rv = (*tmp);
    proc_mutex_sysv_cleanup((void *)new_mutex);
    return (rv);
  }
  ick.val = 1;
  tmp___1 = semctl((new_mutex->interproc)->filedes, 0, 16, ick);
  if (tmp___1 < 0) {
    tmp___0 = __errno_location();
    rv = (*tmp___0);
    proc_mutex_sysv_cleanup((void *)new_mutex);
    return (rv);
  }
  new_mutex->curr_locked = 0;
  apr_pool_cleanup_register(new_mutex->pool, (void const   *)((void *)new_mutex),
                            & apr_proc_mutex_cleanup, & apr_pool_cleanup_null);
  return (0);
}
}
static apr_status_t proc_mutex_sysv_acquire(apr_proc_mutex_t *mutex ) 
{ int rc ;
  int *tmp ;
  int *tmp___0 ;

  {
  while (1) {
    rc = semop((mutex->interproc)->filedes, & proc_mutex_op_on, 1U);
    if (rc < 0) {
      tmp = __errno_location();
      if (! ((*tmp) == 4)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
  }
  if (rc < 0) {
    tmp___0 = __errno_location();
    return ((*tmp___0));
  }
  mutex->curr_locked = 1;
  return (0);
}
}
static apr_status_t proc_mutex_sysv_release(apr_proc_mutex_t *mutex ) 
{ int rc ;
  int *tmp ;
  int *tmp___0 ;

  {
  while (1) {
    rc = semop((mutex->interproc)->filedes, & proc_mutex_op_off, 1U);
    if (rc < 0) {
      tmp = __errno_location();
      if (! ((*tmp) == 4)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
  }
  if (rc < 0) {
    tmp___0 = __errno_location();
    return ((*tmp___0));
  }
  mutex->curr_locked = 0;
  return (0);
}
}
static apr_status_t proc_mutex_sysv_child_init(apr_proc_mutex_t **mutex , apr_pool_t *cont ,
                                               char const   *fname ) 
{ 

  {
  return (0);
}
}
struct apr_proc_mutex_unix_lock_methods_t  const  apr_proc_mutex_unix_sysv_methods  = 
     {0U, & proc_mutex_sysv_create, & proc_mutex_sysv_acquire, (apr_status_t (*)(apr_proc_mutex_t * ))((void *)0),
    & proc_mutex_sysv_release, & proc_mutex_sysv_cleanup, & proc_mutex_sysv_child_init,
    "sysvsem"};
static void proc_mutex_proc_pthread_setup(void) 
{ 

  {
  return;
}
}
static apr_status_t proc_mutex_proc_pthread_cleanup(void *mutex_ ) 
{ apr_proc_mutex_t *mutex ;
  apr_status_t rv ;
  int *tmp ;
  int tmp___0 ;

  {
  mutex = (apr_proc_mutex_t *)mutex_;
  if (mutex->curr_locked == 1) {
    rv = pthread_mutex_unlock(mutex->pthread_interproc);
    if (rv) {
      return (rv);
    }
    tmp___0 = munmap((void *)((char *)mutex->pthread_interproc), sizeof(pthread_mutex_t ));
    if (tmp___0) {
      tmp = __errno_location();
      return ((*tmp));
    }
  }
  return (0);
}
}
static apr_status_t proc_mutex_proc_pthread_create(apr_proc_mutex_t *new_mutex , char const   *fname ) 
{ apr_status_t rv ;
  int fd ;
  pthread_mutexattr_t mattr ;
  int *tmp ;
  int *tmp___1 ;

  {
  fd = open("/dev/zero", 2);
  if (fd < 0) {
    tmp = __errno_location();
    return ((*tmp));
  }
  new_mutex->pthread_interproc = (pthread_mutex_t *)mmap((void *)((char *)0), sizeof(pthread_mutex_t ),
                                                         3, 1, fd, 0L);
  if ((unsigned int )new_mutex->pthread_interproc == (unsigned int )((pthread_mutex_t *)((char *)-1))) {
    tmp___1 = __errno_location();
    return ((*tmp___1));
  }
  close(fd);
  rv = pthread_mutexattr_init(& mattr);
  if (rv) {
    proc_mutex_proc_pthread_cleanup((void *)new_mutex);
    return (rv);
  }
  rv = pthread_mutexattr_setpshared(& mattr, 1);
  if (rv) {
    proc_mutex_proc_pthread_cleanup((void *)new_mutex);
    return (rv);
  }
  rv = pthread_mutex_init((pthread_mutex_t * __restrict  )new_mutex->pthread_interproc,
                          (pthread_mutexattr_t const   * __restrict  )(& mattr));
  if (rv) {
    proc_mutex_proc_pthread_cleanup((void *)new_mutex);
    return (rv);
  }
  rv = pthread_mutexattr_destroy(& mattr);
  if (rv) {
    proc_mutex_proc_pthread_cleanup((void *)new_mutex);
    return (rv);
  }
  new_mutex->curr_locked = 0;
  apr_pool_cleanup_register(new_mutex->pool, (void const   *)((void *)new_mutex),
                            & apr_proc_mutex_cleanup, & apr_pool_cleanup_null);
  return (0);
}
}
static apr_status_t proc_mutex_proc_pthread_acquire(apr_proc_mutex_t *mutex ) 
{ apr_status_t rv ;

  {
  rv = pthread_mutex_lock(mutex->pthread_interproc);
  if (rv) {
    return (rv);
  }
  mutex->curr_locked = 1;
  return (0);
}
}
static apr_status_t proc_mutex_proc_pthread_release(apr_proc_mutex_t *mutex ) 
{ apr_status_t rv ;

  {
  rv = pthread_mutex_unlock(mutex->pthread_interproc);
  if (rv) {
    return (rv);
  }
  mutex->curr_locked = 0;
  return (0);
}
}
static apr_status_t proc_mutex_proc_pthread_child_init(apr_proc_mutex_t **mutex ,
                                                       apr_pool_t *cont , char const   *fname ) 
{ 

  {
  return (0);
}
}
struct apr_proc_mutex_unix_lock_methods_t  const  apr_proc_mutex_unix_proc_pthread_methods  = 
     {1U, & proc_mutex_proc_pthread_create, & proc_mutex_proc_pthread_acquire, (apr_status_t (*)(apr_proc_mutex_t * ))((void *)0),
    & proc_mutex_proc_pthread_release, & proc_mutex_proc_pthread_cleanup, & proc_mutex_proc_pthread_child_init,
    "pthread"};
static struct flock proc_mutex_lock_it  ;
static struct flock proc_mutex_unlock_it  ;
static apr_status_t proc_mutex_fcntl_release(apr_proc_mutex_t *mutex ) ;
static void proc_mutex_fcntl_setup(void) 
{ 

  {
  proc_mutex_lock_it.l_whence = (short)0;
  proc_mutex_lock_it.l_start = 0L;
  proc_mutex_lock_it.l_len = 0L;
  proc_mutex_lock_it.l_type = (short)1;
  proc_mutex_lock_it.l_pid = 0;
  proc_mutex_unlock_it.l_whence = (short)0;
  proc_mutex_unlock_it.l_start = 0L;
  proc_mutex_unlock_it.l_len = 0L;
  proc_mutex_unlock_it.l_type = (short)2;
  proc_mutex_unlock_it.l_pid = 0;
  return;
}
}
static apr_status_t proc_mutex_fcntl_cleanup(void *mutex_ ) 
{ apr_status_t status ;
  apr_proc_mutex_t *mutex ;

  {
  mutex = (apr_proc_mutex_t *)mutex_;
  if (mutex->curr_locked == 1) {
    status = proc_mutex_fcntl_release(mutex);
    if (status != 0) {
      return (status);
    }
  }
  apr_file_close(mutex->interproc);
  return (0);
}
}
static apr_status_t proc_mutex_fcntl_create(apr_proc_mutex_t *new_mutex , char const   *fname ) 
{ int rv ;

  {
  if (fname) {
    new_mutex->fname = apr_pstrdup(new_mutex->pool, fname);
    rv = apr_file_open(& new_mutex->interproc, (char const   *)new_mutex->fname, 70,
                       1604, new_mutex->pool);
  } else {
    new_mutex->fname = apr_pstrdup(new_mutex->pool, "/tmp/aprXXXXXX");
    rv = apr_file_mktemp(& new_mutex->interproc, new_mutex->fname, 0, new_mutex->pool);
  }
  if (rv != 0) {
    proc_mutex_fcntl_cleanup((void *)new_mutex);
    return (rv);
  }
  new_mutex->curr_locked = 0;
  unlink((char const   *)new_mutex->fname);
  apr_pool_cleanup_register(new_mutex->pool, (void const   *)((void *)new_mutex),
                            & apr_proc_mutex_cleanup, & apr_pool_cleanup_null);
  return (0);
}
}
static apr_status_t proc_mutex_fcntl_acquire(apr_proc_mutex_t *mutex ) 
{ int rc ;
  int *tmp ;
  int *tmp___0 ;

  {
  while (1) {
    rc = fcntl((mutex->interproc)->filedes, 7, & proc_mutex_lock_it);
    if (rc < 0) {
      tmp = __errno_location();
      if (! ((*tmp) == 4)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
  }
  if (rc < 0) {
    tmp___0 = __errno_location();
    return ((*tmp___0));
  }
  mutex->curr_locked = 1;
  return (0);
}
}
static apr_status_t proc_mutex_fcntl_release(apr_proc_mutex_t *mutex ) 
{ int rc ;
  int *tmp ;
  int *tmp___0 ;

  {
  while (1) {
    rc = fcntl((mutex->interproc)->filedes, 7, & proc_mutex_unlock_it);
    if (rc < 0) {
      tmp = __errno_location();
      if (! ((*tmp) == 4)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
  }
  if (rc < 0) {
    tmp___0 = __errno_location();
    return ((*tmp___0));
  }
  mutex->curr_locked = 0;
  return (0);
}
}
static apr_status_t proc_mutex_fcntl_child_init(apr_proc_mutex_t **mutex , apr_pool_t *pool ,
                                                char const   *fname ) 
{ 

  {
  return (0);
}
}
struct apr_proc_mutex_unix_lock_methods_t  const  apr_proc_mutex_unix_fcntl_methods  = 
     {0U, & proc_mutex_fcntl_create, & proc_mutex_fcntl_acquire, (apr_status_t (*)(apr_proc_mutex_t * ))((void *)0),
    & proc_mutex_fcntl_release, & proc_mutex_fcntl_cleanup, & proc_mutex_fcntl_child_init,
    "fcntl"};
static apr_status_t proc_mutex_flock_release(apr_proc_mutex_t *mutex ) ;
static void proc_mutex_flock_setup(void) 
{ 

  {
  return;
}
}
static apr_status_t proc_mutex_flock_cleanup(void *mutex_ ) 
{ apr_status_t status ;
  apr_proc_mutex_t *mutex ;

  {
  mutex = (apr_proc_mutex_t *)mutex_;
  if (mutex->curr_locked == 1) {
    status = proc_mutex_flock_release(mutex);
    if (status != 0) {
      return (status);
    }
  }
  apr_file_close(mutex->interproc);
  unlink((char const   *)mutex->fname);
  return (0);
}
}
static apr_status_t proc_mutex_flock_create(apr_proc_mutex_t *new_mutex , char const   *fname ) 
{ int rv ;
  int *tmp ;

  {
  if (fname) {
    new_mutex->fname = apr_pstrdup(new_mutex->pool, fname);
    rv = apr_file_open(& new_mutex->interproc, (char const   *)new_mutex->fname, 70,
                       1536, new_mutex->pool);
  } else {
    new_mutex->fname = apr_pstrdup(new_mutex->pool, "/tmp/aprXXXXXX");
    rv = apr_file_mktemp(& new_mutex->interproc, new_mutex->fname, 0, new_mutex->pool);
  }
  if (rv != 0) {
    proc_mutex_flock_cleanup((void *)new_mutex);
    tmp = __errno_location();
    return ((*tmp));
  }
  new_mutex->curr_locked = 0;
  apr_pool_cleanup_register(new_mutex->pool, (void const   *)((void *)new_mutex),
                            & apr_proc_mutex_cleanup, & apr_pool_cleanup_null);
  return (0);
}
}
static apr_status_t proc_mutex_flock_acquire(apr_proc_mutex_t *mutex ) 
{ int rc ;
  int *tmp ;
  int *tmp___0 ;

  {
  while (1) {
    rc = flock((mutex->interproc)->filedes, 2);
    if (rc < 0) {
      tmp = __errno_location();
      if (! ((*tmp) == 4)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
  }
  if (rc < 0) {
    tmp___0 = __errno_location();
    return ((*tmp___0));
  }
  mutex->curr_locked = 1;
  return (0);
}
}
static apr_status_t proc_mutex_flock_release(apr_proc_mutex_t *mutex ) 
{ int rc ;
  int *tmp ;
  int *tmp___0 ;

  {
  while (1) {
    rc = flock((mutex->interproc)->filedes, 8);
    if (rc < 0) {
      tmp = __errno_location();
      if (! ((*tmp) == 4)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
  }
  if (rc < 0) {
    tmp___0 = __errno_location();
    return ((*tmp___0));
  }
  mutex->curr_locked = 0;
  return (0);
}
}
static apr_status_t proc_mutex_flock_child_init(apr_proc_mutex_t **mutex , apr_pool_t *pool ,
                                                char const   *fname ) 
{ apr_proc_mutex_t *new_mutex ;
  int rv ;

  {
  new_mutex = (apr_proc_mutex_t *)apr_palloc(pool, sizeof(apr_proc_mutex_t ));
  memcpy((void * __restrict  )new_mutex, (void const   * __restrict  )(*mutex), sizeof((*new_mutex)));
  new_mutex->pool = pool;
  new_mutex->fname = apr_pstrdup(pool, fname);
  rv = apr_file_open(& new_mutex->interproc, (char const   *)new_mutex->fname, 2,
                     0, new_mutex->pool);
  if (rv != 0) {
    proc_mutex_flock_cleanup((void *)new_mutex);
    return (rv);
  }
  (*mutex) = new_mutex;
  return (0);
}
}
struct apr_proc_mutex_unix_lock_methods_t  const  apr_proc_mutex_unix_flock_methods  = 
     {0U, & proc_mutex_flock_create, & proc_mutex_flock_acquire, (apr_status_t (*)(apr_proc_mutex_t * ))((void *)0),
    & proc_mutex_flock_release, & proc_mutex_flock_cleanup, & proc_mutex_flock_child_init,
    "flock"};
void apr_proc_mutex_unix_setup_lock(void) 
{ 

  {
  proc_mutex_posix_setup();
  proc_mutex_sysv_setup();
  proc_mutex_proc_pthread_setup();
  proc_mutex_fcntl_setup();
  proc_mutex_flock_setup();
  return;
}
}
static apr_status_t proc_mutex_choose_method(apr_proc_mutex_t *new_mutex , apr_lockmech_e mech ) 
{ 

  {
  switch ((int )mech) {
  case 0: 
  new_mutex->inter_meth = & apr_proc_mutex_unix_fcntl_methods;
  break;
  case 1: 
  new_mutex->inter_meth = & apr_proc_mutex_unix_flock_methods;
  break;
  case 2: 
  new_mutex->inter_meth = & apr_proc_mutex_unix_sysv_methods;
  break;
  case 4: 
  new_mutex->inter_meth = & apr_proc_mutex_unix_posix_methods;
  break;
  case 3: 
  new_mutex->inter_meth = & apr_proc_mutex_unix_proc_pthread_methods;
  break;
  case 5: 
  new_mutex->inter_meth = & apr_proc_mutex_unix_proc_pthread_methods;
  break;
  default: ;
  return (70023);
  }
  return (0);
}
}
char const   *apr_proc_mutex_defname(void) 
{ apr_status_t rv ;
  apr_proc_mutex_t mutex ;
  char const   *tmp ;

  {
  rv = proc_mutex_choose_method(& mutex, (int )5);
  if (rv != 0) {
    return ("unknown");
  }
  mutex.meth = mutex.inter_meth;
  tmp = apr_proc_mutex_name(& mutex);
  return (tmp);
}
}
static apr_status_t proc_mutex_create(apr_proc_mutex_t *new_mutex , apr_lockmech_e mech ,
                                      char const   *fname ) 
{ apr_status_t rv ;

  {
  rv = proc_mutex_choose_method(new_mutex, mech);
  if (rv != 0) {
    return (rv);
  }
  new_mutex->meth = new_mutex->inter_meth;
  rv = ((*((new_mutex->meth)->create)))(new_mutex, fname);
  if (rv != 0) {
    return (rv);
  }
  return (0);
}
}
apr_status_t apr_proc_mutex_create(apr_proc_mutex_t **mutex , char const   *fname ,
                                   apr_lockmech_e mech , apr_pool_t *pool ) 
{ apr_proc_mutex_t *new_mutex ;
  apr_status_t rv ;
  void *tmp ;

  {
  tmp = apr_palloc(pool, sizeof(apr_proc_mutex_t ));
  new_mutex = (apr_proc_mutex_t *)memset(tmp, 0, sizeof(apr_proc_mutex_t ));
  new_mutex->pool = pool;
  new_mutex->interproc = (apr_file_t *)((void *)0);
  rv = proc_mutex_create(new_mutex, mech, fname);
  if (rv != 0) {
    return (rv);
  }
  (*mutex) = new_mutex;
  return (0);
}
}
apr_status_t apr_proc_mutex_child_init(apr_proc_mutex_t **mutex , char const   *fname ,
                                       apr_pool_t *pool ) 
{ apr_status_t tmp ;

  {
  tmp = ((*((((*mutex))->meth)->child_init)))(mutex, pool, fname);
  return (tmp);
}
}
apr_status_t apr_proc_mutex_lock(apr_proc_mutex_t *mutex ) 
{ apr_status_t tmp ;

  {
  tmp = ((*((mutex->meth)->acquire)))(mutex);
  return (tmp);
}
}
apr_status_t apr_proc_mutex_trylock(apr_proc_mutex_t *mutex ) 
{ apr_status_t tmp ;

  {
  tmp = ((*((mutex->meth)->tryacquire)))(mutex);
  return (tmp);
}
}
apr_status_t apr_proc_mutex_unlock(apr_proc_mutex_t *mutex ) 
{ apr_status_t tmp ;

  {
  tmp = ((*((mutex->meth)->release)))(mutex);
  return (tmp);
}
}
apr_status_t apr_proc_mutex_cleanup(void *mutex ) 
{ apr_status_t tmp ;

  {
  tmp = ((*((((apr_proc_mutex_t *)mutex)->meth)->cleanup)))(mutex);
  return (tmp);
}
}
char const   *apr_proc_mutex_name(apr_proc_mutex_t *mutex ) 
{ 

  {
  return ((mutex->meth)->name);
}
}
apr_pool_t *apr_proc_mutex_pool_get(apr_proc_mutex_t const   *ob ) 
{ 

  {
  return (ob->pool);
}
}
apr_status_t apr_os_proc_mutex_get(apr_os_proc_mutex_t *ospmutex , apr_proc_mutex_t *pmutex ) 
{ 

  {
  ospmutex->crossproc = (pmutex->interproc)->filedes;
  ospmutex->pthread_interproc = pmutex->pthread_interproc;
  return (0);
}
}
apr_status_t apr_os_proc_mutex_put(apr_proc_mutex_t **pmutex , apr_os_proc_mutex_t *ospmutex ,
                                   apr_pool_t *pool ) 
{ void *tmp ;

  {
  if ((unsigned int )pool == (unsigned int )((void *)0)) {
    return (20002);
  }
  if ((unsigned int )(*pmutex) == (unsigned int )((void *)0)) {
    tmp = apr_palloc(pool, sizeof(apr_proc_mutex_t ));
    (*pmutex) = (apr_proc_mutex_t *)memset(tmp, 0, sizeof(apr_proc_mutex_t ));
    ((*pmutex))->pool = pool;
  }
  apr_os_file_put(& ((*pmutex))->interproc, & ospmutex->crossproc, 0, pool);
  ((*pmutex))->pthread_interproc = ospmutex->pthread_interproc;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-EnRMZB5a.i","-g -pthread")
extern int pthread_cond_init(pthread_cond_t * __restrict  __cond , pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern int pthread_cond_destroy(pthread_cond_t *__cond ) ;
extern int pthread_cond_signal(pthread_cond_t *__cond ) ;
extern int pthread_cond_broadcast(pthread_cond_t *__cond ) ;
extern int pthread_cond_wait(pthread_cond_t * __restrict  __cond , pthread_mutex_t * __restrict  __mutex ) ;
extern int pthread_cond_timedwait(pthread_cond_t * __restrict  __cond , pthread_mutex_t * __restrict  __mutex ,
                                  struct timespec  const  * __restrict  __abstime ) ;
static apr_status_t thread_cond_cleanup(void *data ) 
{ apr_thread_cond_t *cond ;
  apr_status_t rv ;

  {
  cond = (apr_thread_cond_t *)data;
  rv = pthread_cond_destroy(cond->cond);
  return (rv);
}
}
apr_status_t apr_thread_cond_create(apr_thread_cond_t **cond , apr_pool_t *pool ) 
{ apr_thread_cond_t *new_cond ;
  apr_status_t rv ;
  void *tmp ;

  {
  tmp = apr_palloc(pool, sizeof(apr_thread_cond_t ));
  new_cond = (apr_thread_cond_t *)memset(tmp, 0, sizeof(apr_thread_cond_t ));
  if ((unsigned int )new_cond == (unsigned int )((void *)0)) {
    return (12);
  }
  new_cond->pool = pool;
  new_cond->cond = (pthread_cond_t *)apr_palloc(pool, sizeof(pthread_cond_t ));
  if ((unsigned int )new_cond->cond == (unsigned int )((void *)0)) {
    return (12);
  }
  rv = pthread_cond_init((pthread_cond_t * __restrict  )new_cond->cond, (pthread_condattr_t const   * __restrict  )((void *)0));
  if (rv) {
    thread_cond_cleanup((void *)new_cond);
    return (rv);
  }
  apr_pool_cleanup_register(new_cond->pool, (void const   *)((void *)new_cond), & thread_cond_cleanup,
                            & apr_pool_cleanup_null);
  (*cond) = new_cond;
  return (0);
}
}
apr_status_t apr_thread_cond_wait(apr_thread_cond_t *cond , apr_thread_mutex_t *mutex ) 
{ apr_status_t rv ;

  {
  rv = pthread_cond_wait((pthread_cond_t * __restrict  )cond->cond, (pthread_mutex_t * __restrict  )(& mutex->mutex));
  return (rv);
}
}
apr_status_t apr_thread_cond_timedwait(apr_thread_cond_t *cond , apr_thread_mutex_t *mutex ,
                                       apr_interval_time_t timeout ) 
{ apr_status_t rv ;
  apr_time_t then ;
  struct timespec abstime ;
  apr_time_t tmp ;

  {
  tmp = apr_time_now();
  then = tmp + timeout;
  abstime.tv_sec = (long )(then / 1000000LL);
  abstime.tv_nsec = (long )((then % 1000000LL) * 1000LL);
  rv = pthread_cond_timedwait((pthread_cond_t * __restrict  )cond->cond, (pthread_mutex_t * __restrict  )(& mutex->mutex),
                              (struct timespec  const  * __restrict  )(& abstime));
  if (110 == rv) {
    return (70007);
  }
  return (rv);
}
}
apr_status_t apr_thread_cond_signal(apr_thread_cond_t *cond ) 
{ apr_status_t rv ;

  {
  rv = pthread_cond_signal(cond->cond);
  return (rv);
}
}
apr_status_t apr_thread_cond_broadcast(apr_thread_cond_t *cond ) 
{ apr_status_t rv ;

  {
  rv = pthread_cond_broadcast(cond->cond);
  return (rv);
}
}
apr_status_t apr_thread_cond_destroy(apr_thread_cond_t *cond ) 
{ apr_status_t rv ;

  {
  rv = thread_cond_cleanup((void *)cond);
  if (rv == 0) {
    apr_pool_cleanup_kill(cond->pool, (void const   *)cond, & thread_cond_cleanup);
    return (0);
  }
  return (rv);
}
}
apr_pool_t *apr_thread_cond_pool_get(apr_thread_cond_t const   *ob ) 
{ 

  {
  return (ob->pool);
}
}
#pragma merger(0,"/tmp/cil-NkMlpEAp.i","-g -pthread")
extern int pthread_mutex_destroy(pthread_mutex_t *__mutex ) ;
extern int pthread_mutex_trylock(pthread_mutex_t *__mutex ) ;
static apr_status_t thread_mutex_cleanup(void *data ) 
{ apr_thread_mutex_t *mutex ;
  apr_status_t rv ;

  {
  mutex = (apr_thread_mutex_t *)data;
  rv = pthread_mutex_destroy(& mutex->mutex);
  return (rv);
}
}
apr_status_t apr_thread_mutex_create(apr_thread_mutex_t **mutex , unsigned int flags ,
                                     apr_pool_t *pool ) 
{ apr_thread_mutex_t *new_mutex ;
  pthread_mutexattr_t mattr ;
  apr_status_t rv ;
  void *tmp ;

  {
  tmp = apr_palloc(pool, sizeof(apr_thread_mutex_t ));
  new_mutex = (apr_thread_mutex_t *)memset(tmp, 0, sizeof(apr_thread_mutex_t ));
  if ((unsigned int )new_mutex == (unsigned int )((void *)0)) {
    return (12);
  }
  new_mutex->pool = pool;
  new_mutex->nested = (char )(flags & 1U);
  rv = pthread_mutexattr_init(& mattr);
  if (rv) {
    thread_mutex_cleanup((void *)new_mutex);
    return (rv);
  }
  rv = pthread_mutex_init((pthread_mutex_t * __restrict  )(& new_mutex->mutex), (pthread_mutexattr_t const   * __restrict  )(& mattr));
  if (rv) {
    thread_mutex_cleanup((void *)new_mutex);
    return (rv);
  }
  rv = pthread_mutexattr_destroy(& mattr);
  if (rv) {
    thread_mutex_cleanup((void *)new_mutex);
    return (rv);
  }
  apr_pool_cleanup_register(new_mutex->pool, (void const   *)((void *)new_mutex),
                            & thread_mutex_cleanup, & apr_pool_cleanup_null);
  (*mutex) = new_mutex;
  return (0);
}
}
apr_status_t apr_thread_mutex_lock(apr_thread_mutex_t *mutex ) 
{ apr_status_t rv ;
  apr_os_thread_t tmp ;
  int tmp___0 ;

  {
  if (mutex->nested) {
    tmp = apr_os_thread_current();
    tmp___0 = apr_os_thread_equal(mutex->owner, tmp);
    if (tmp___0) {
      mutex->owner_ref = mutex->owner_ref + 1;
      return (0);
    }
    rv = pthread_mutex_lock(& mutex->mutex);
    if (rv) {
      return (rv);
    }
    mutex->owner = apr_os_thread_current();
    mutex->owner_ref = 1;
    return (rv);
  } else {
    rv = pthread_mutex_lock(& mutex->mutex);
    return (rv);
  }
}
}
apr_status_t apr_thread_mutex_trylock(apr_thread_mutex_t *mutex ) 
{ apr_status_t rv ;
  apr_os_thread_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (mutex->nested) {
    tmp = apr_os_thread_current();
    tmp___0 = apr_os_thread_equal(mutex->owner, tmp);
    if (tmp___0) {
      mutex->owner_ref = mutex->owner_ref + 1;
      return (0);
    }
    rv = pthread_mutex_trylock(& mutex->mutex);
    if (rv) {
      if (rv == 16) {
        tmp___1 = 70025;
      } else {
        tmp___1 = rv;
      }
      return (tmp___1);
    }
    mutex->owner = apr_os_thread_current();
    mutex->owner_ref = 1;
  } else {
    rv = pthread_mutex_trylock(& mutex->mutex);
    if (rv) {
      if (rv == 16) {
        tmp___2 = 70025;
      } else {
        tmp___2 = rv;
      }
      return (tmp___2);
    }
  }
  return (rv);
}
}
apr_status_t apr_thread_mutex_unlock(apr_thread_mutex_t *mutex ) 
{ apr_status_t status ;
  apr_os_thread_t tmp ;
  int tmp___0 ;

  {
  if (mutex->nested) {
    tmp = apr_os_thread_current();
    tmp___0 = apr_os_thread_equal(mutex->owner, tmp);
    if (tmp___0) {
      mutex->owner_ref = mutex->owner_ref - 1;
      if (mutex->owner_ref > 0) {
        return (0);
      }
    }
    status = pthread_mutex_unlock(& mutex->mutex);
    if (status) {
      return (status);
    }
    memset((void *)(& mutex->owner), 0, sizeof(mutex->owner));
    mutex->owner_ref = 0;
    return (status);
  } else {
    status = pthread_mutex_unlock(& mutex->mutex);
    return (status);
  }
}
}
apr_status_t apr_thread_mutex_destroy(apr_thread_mutex_t *mutex ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_cleanup_run(mutex->pool, (void *)mutex, & thread_mutex_cleanup);
  return (tmp);
}
}
apr_pool_t *apr_thread_mutex_pool_get(apr_thread_mutex_t const   *ob ) 
{ 

  {
  return (ob->pool);
}
}
#pragma merger(0,"/tmp/cil-hssAkTFu.i","-g -pthread")
extern int pthread_rwlock_init(pthread_rwlock_t * __restrict  __rwlock , pthread_rwlockattr_t const   * __restrict  __attr ) ;
extern int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock ) ;
extern int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock ) ;
extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock ) ;
extern int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock ) ;
extern int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock ) ;
extern int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock ) ;
static apr_status_t thread_rwlock_cleanup(void *data ) 
{ apr_thread_rwlock_t *rwlock ;
  apr_status_t stat ;

  {
  rwlock = (apr_thread_rwlock_t *)data;
  pthread_rwlock_unlock(rwlock->rwlock);
  stat = pthread_rwlock_destroy(rwlock->rwlock);
  return (stat);
}
}
apr_status_t apr_thread_rwlock_create(apr_thread_rwlock_t **rwlock , apr_pool_t *pool ) 
{ apr_thread_rwlock_t *new_rwlock ;
  apr_status_t stat ;
  void *tmp ;

  {
  tmp = apr_palloc(pool, sizeof(apr_thread_rwlock_t ));
  new_rwlock = (apr_thread_rwlock_t *)memset(tmp, 0, sizeof(apr_thread_rwlock_t ));
  if ((unsigned int )new_rwlock == (unsigned int )((void *)0)) {
    return (12);
  }
  new_rwlock->pool = pool;
  new_rwlock->rwlock = (pthread_rwlock_t *)apr_palloc(pool, sizeof(pthread_rwlock_t ));
  if ((unsigned int )new_rwlock->rwlock == (unsigned int )((void *)0)) {
    return (12);
  }
  stat = pthread_rwlock_init((pthread_rwlock_t * __restrict  )new_rwlock->rwlock,
                             (pthread_rwlockattr_t const   * __restrict  )((void *)0));
  if (stat) {
    thread_rwlock_cleanup((void *)new_rwlock);
    return (stat);
  }
  apr_pool_cleanup_register(new_rwlock->pool, (void const   *)((void *)new_rwlock),
                            & thread_rwlock_cleanup, & apr_pool_cleanup_null);
  (*rwlock) = new_rwlock;
  return (0);
}
}
apr_status_t apr_thread_rwlock_rdlock(apr_thread_rwlock_t *rwlock ) 
{ apr_status_t stat ;

  {
  stat = pthread_rwlock_rdlock(rwlock->rwlock);
  return (stat);
}
}
apr_status_t apr_thread_rwlock_tryrdlock(apr_thread_rwlock_t *rwlock ) 
{ apr_status_t stat ;

  {
  stat = pthread_rwlock_tryrdlock(rwlock->rwlock);
  if (stat == 16) {
    stat = 70025;
  }
  return (stat);
}
}
apr_status_t apr_thread_rwlock_wrlock(apr_thread_rwlock_t *rwlock ) 
{ apr_status_t stat ;

  {
  stat = pthread_rwlock_wrlock(rwlock->rwlock);
  return (stat);
}
}
apr_status_t apr_thread_rwlock_trywrlock(apr_thread_rwlock_t *rwlock ) 
{ apr_status_t stat ;

  {
  stat = pthread_rwlock_trywrlock(rwlock->rwlock);
  if (stat == 16) {
    stat = 70025;
  }
  return (stat);
}
}
apr_status_t apr_thread_rwlock_unlock(apr_thread_rwlock_t *rwlock ) 
{ apr_status_t stat ;

  {
  stat = pthread_rwlock_unlock(rwlock->rwlock);
  return (stat);
}
}
apr_status_t apr_thread_rwlock_destroy(apr_thread_rwlock_t *rwlock ) 
{ apr_status_t stat ;

  {
  stat = thread_rwlock_cleanup((void *)rwlock);
  if (stat == 0) {
    apr_pool_cleanup_kill(rwlock->pool, (void const   *)rwlock, & thread_rwlock_cleanup);
    return (0);
  }
  return (stat);
}
}
apr_pool_t *apr_thread_rwlock_pool_get(apr_thread_rwlock_t const   *ob ) 
{ 

  {
  return (ob->pool);
}
}
#pragma merger(0,"/tmp/cil-PD6F1H6U.i","-g -pthread")
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
extern int gettimeofday(struct timeval * __restrict  __tv , __timezone_ptr_t __tz ) ;
extern struct tm *gmtime_r(time_t const   * __restrict  __timer , struct tm * __restrict  __tp ) ;
extern struct tm *localtime_r(time_t const   * __restrict  __timer , struct tm * __restrict  __tp ) ;
static apr_int32_t get_offset(struct tm *tm ) 
{ 

  {
  return ((int )tm->tm_gmtoff);
}
}
apr_status_t apr_time_ansi_put(apr_time_t *result , time_t input ) 
{ 

  {
  (*result) = (long long )input * 1000000LL;
  return (0);
}
}
apr_time_t apr_time_now(void) 
{ struct timeval tv ;

  {
  gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((void *)0));
  return ((long long )tv.tv_sec * 1000000LL + (long long )tv.tv_usec);
}
}
static void explode_time(apr_time_exp_t *xt , apr_time_t t , apr_int32_t offset ,
                         int use_localtime ) 
{ struct tm tm ;
  time_t tt ;

  {
  tt = (long )(t / 1000000LL + (long long )offset);
  xt->tm_usec = (int )(t % 1000000LL);
  if (use_localtime) {
    localtime_r((time_t const   * __restrict  )(& tt), (struct tm * __restrict  )(& tm));
  } else {
    gmtime_r((time_t const   * __restrict  )(& tt), (struct tm * __restrict  )(& tm));
  }
  xt->tm_sec = tm.tm_sec;
  xt->tm_min = tm.tm_min;
  xt->tm_hour = tm.tm_hour;
  xt->tm_mday = tm.tm_mday;
  xt->tm_mon = tm.tm_mon;
  xt->tm_year = tm.tm_year;
  xt->tm_wday = tm.tm_wday;
  xt->tm_yday = tm.tm_yday;
  xt->tm_isdst = tm.tm_isdst;
  xt->tm_gmtoff = get_offset(& tm);
  return;
}
}
apr_status_t apr_time_exp_tz(apr_time_exp_t *result , apr_time_t input , apr_int32_t offs ) 
{ 

  {
  explode_time(result, input, offs, 0);
  result->tm_gmtoff = offs;
  return (0);
}
}
apr_status_t apr_time_exp_gmt(apr_time_exp_t *result , apr_time_t input ) 
{ apr_status_t tmp ;

  {
  tmp = apr_time_exp_tz(result, input, 0);
  return (tmp);
}
}
apr_status_t apr_time_exp_lt(apr_time_exp_t *result , apr_time_t input ) 
{ 

  {
  explode_time(result, input, 0, 1);
  return (0);
}
}
static int const   dayoffset[12]  = 
  {      (int const   )306,      (int const   )337,      (int const   )0,      (int const   )31, 
        (int const   )61,      (int const   )92,      (int const   )122,      (int const   )153, 
        (int const   )184,      (int const   )214,      (int const   )245,      (int const   )275};
apr_status_t apr_time_exp_get(apr_time_t *t , apr_time_exp_t *xt ) 
{ int year ;
  time_t days ;

  {
  year = xt->tm_year;
  if (year < 70) {
    goto _L;
  } else {
    if (sizeof(time_t ) <= 4U) {
      if (year >= 138) {
        _L: 
        return (20004);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
    }
  }
  if (xt->tm_mon < 2) {
    year --;
  }
  days = (long )(((year * 365 + year / 4) - year / 100) + (year / 100 + 3) / 4);
  days += (long )((dayoffset[xt->tm_mon] + (int const   )xt->tm_mday) - 1);
  days -= 25508L;
  days = ((days * 24L + (long )xt->tm_hour) * 60L + (long )xt->tm_min) * 60L + (long )xt->tm_sec;
  if (days < 0L) {
    return (20004);
  }
  (*t) = (long long )days * 1000000LL + (long long )xt->tm_usec;
  return (0);
}
}
apr_status_t apr_time_exp_gmt_get(apr_time_t *t , apr_time_exp_t *xt ) 
{ apr_status_t status ;
  apr_status_t tmp ;

  {
  tmp = apr_time_exp_get(t, xt);
  status = tmp;
  if (status == 0) {
    (*t) -= (long long )xt->tm_gmtoff * 1000000LL;
  }
  return (status);
}
}
apr_status_t apr_os_imp_time_get(apr_os_imp_time_t **ostime , apr_time_t *aprtime ) 
{ 

  {
  ((*ostime))->tv_usec = (long )((*aprtime) % 1000000LL);
  ((*ostime))->tv_sec = (long )((*aprtime) / 1000000LL);
  return (0);
}
}
apr_status_t apr_os_exp_time_get(apr_os_exp_time_t **ostime , apr_time_exp_t *aprtime ) 
{ 

  {
  ((*ostime))->tm_sec = aprtime->tm_sec;
  ((*ostime))->tm_min = aprtime->tm_min;
  ((*ostime))->tm_hour = aprtime->tm_hour;
  ((*ostime))->tm_mday = aprtime->tm_mday;
  ((*ostime))->tm_mon = aprtime->tm_mon;
  ((*ostime))->tm_year = aprtime->tm_year;
  ((*ostime))->tm_wday = aprtime->tm_wday;
  ((*ostime))->tm_yday = aprtime->tm_yday;
  ((*ostime))->tm_isdst = aprtime->tm_isdst;
  ((*ostime))->tm_gmtoff = (long )aprtime->tm_gmtoff;
  return (0);
}
}
apr_status_t apr_os_imp_time_put(apr_time_t *aprtime , apr_os_imp_time_t **ostime ,
                                 apr_pool_t *cont ) 
{ 

  {
  (*aprtime) = (long long )((*ostime))->tv_sec * 1000000LL + (long long )((*ostime))->tv_usec;
  return (0);
}
}
apr_status_t apr_os_exp_time_put(apr_time_exp_t *aprtime , apr_os_exp_time_t **ostime ,
                                 apr_pool_t *cont ) 
{ 

  {
  aprtime->tm_sec = ((*ostime))->tm_sec;
  aprtime->tm_min = ((*ostime))->tm_min;
  aprtime->tm_hour = ((*ostime))->tm_hour;
  aprtime->tm_mday = ((*ostime))->tm_mday;
  aprtime->tm_mon = ((*ostime))->tm_mon;
  aprtime->tm_year = ((*ostime))->tm_year;
  aprtime->tm_wday = ((*ostime))->tm_wday;
  aprtime->tm_yday = ((*ostime))->tm_yday;
  aprtime->tm_isdst = ((*ostime))->tm_isdst;
  aprtime->tm_gmtoff = (int )((*ostime))->tm_gmtoff;
  return (0);
}
}
void apr_sleep(apr_interval_time_t t ) 
{ struct timeval tv ;

  {
  tv.tv_usec = (long )(t % 1000000LL);
  tv.tv_sec = (long )(t / 1000000LL);
  select(0, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )((void *)0),
         (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& tv));
  return;
}
}
void apr_unix_setup_time(void) 
{ 

  {
  return;
}
}
void apr_time_clock_hires(apr_pool_t *p ) 
{ 

  {
  return;
}
}
apr_status_t apr_explode_time(apr_time_exp_t *result , apr_time_t input , apr_int32_t offs ) 
{ apr_status_t tmp ;

  {
  tmp = apr_time_exp_tz(result, input, offs);
  return (tmp);
}
}
apr_status_t apr_explode_localtime(apr_time_exp_t *result , apr_time_t input ) 
{ apr_status_t tmp ;

  {
  tmp = apr_time_exp_lt(result, input);
  return (tmp);
}
}
apr_status_t apr_implode_gmt(apr_time_t *t , apr_time_exp_t *xt ) 
{ apr_status_t tmp ;

  {
  tmp = apr_time_exp_gmt_get(t, xt);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-EzlaFfrJ.i","-g -pthread")
extern size_t strftime(char * __restrict  __s , size_t __maxsize , char const   * __restrict  __format ,
                       struct tm  const  * __restrict  __tp ) ;
char const   apr_month_snames[12][4]  = 
  { {        (char const   )'J',        (char const   )'a',        (char const   )'n',        (char const   )'\000'}, 
   {        (char const   )'F',        (char const   )'e',        (char const   )'b',        (char const   )'\000'}, 
   {        (char const   )'M',        (char const   )'a',        (char const   )'r',        (char const   )'\000'}, 
   {        (char const   )'A',        (char const   )'p',        (char const   )'r',        (char const   )'\000'}, 
   {        (char const   )'M',        (char const   )'a',        (char const   )'y',        (char const   )'\000'}, 
   {        (char const   )'J',        (char const   )'u',        (char const   )'n',        (char const   )'\000'}, 
   {        (char const   )'J',        (char const   )'u',        (char const   )'l',        (char const   )'\000'}, 
   {        (char const   )'A',        (char const   )'u',        (char const   )'g',        (char const   )'\000'}, 
   {        (char const   )'S',        (char const   )'e',        (char const   )'p',        (char const   )'\000'}, 
   {        (char const   )'O',        (char const   )'c',        (char const   )'t',        (char const   )'\000'}, 
   {        (char const   )'N',        (char const   )'o',        (char const   )'v',        (char const   )'\000'}, 
   {        (char const   )'D',        (char const   )'e',        (char const   )'c',        (char const   )'\000'}};
char const   apr_day_snames[7][4]  = { {        (char const   )'S',        (char const   )'u',        (char const   )'n',        (char const   )'\000'}, 
   {        (char const   )'M',        (char const   )'o',        (char const   )'n',        (char const   )'\000'}, 
   {        (char const   )'T',        (char const   )'u',        (char const   )'e',        (char const   )'\000'}, 
   {        (char const   )'W',        (char const   )'e',        (char const   )'d',        (char const   )'\000'}, 
   {        (char const   )'T',        (char const   )'h',        (char const   )'u',        (char const   )'\000'}, 
   {        (char const   )'F',        (char const   )'r',        (char const   )'i',        (char const   )'\000'}, 
   {        (char const   )'S',        (char const   )'a',        (char const   )'t',        (char const   )'\000'}};
apr_status_t apr_rfc822_date(char *date_str , apr_time_t t ) 
{ apr_time_exp_t xt ;
  char const   *s ;
  int real_year ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;

  {
  apr_time_exp_gmt(& xt, t);
  s = & apr_day_snames[xt.tm_wday][0];
  tmp = date_str;
  date_str ++;
  tmp___0 = s;
  s ++;
  (*tmp) = (char )(*tmp___0);
  tmp___1 = date_str;
  date_str ++;
  tmp___2 = s;
  s ++;
  (*tmp___1) = (char )(*tmp___2);
  tmp___3 = date_str;
  date_str ++;
  tmp___4 = s;
  s ++;
  (*tmp___3) = (char )(*tmp___4);
  tmp___5 = date_str;
  date_str ++;
  (*tmp___5) = (char )',';
  tmp___6 = date_str;
  date_str ++;
  (*tmp___6) = (char )' ';
  tmp___7 = date_str;
  date_str ++;
  (*tmp___7) = (char )(xt.tm_mday / 10 + 48);
  tmp___8 = date_str;
  date_str ++;
  (*tmp___8) = (char )(xt.tm_mday % 10 + 48);
  tmp___9 = date_str;
  date_str ++;
  (*tmp___9) = (char )' ';
  s = & apr_month_snames[xt.tm_mon][0];
  tmp___10 = date_str;
  date_str ++;
  tmp___11 = s;
  s ++;
  (*tmp___10) = (char )(*tmp___11);
  tmp___12 = date_str;
  date_str ++;
  tmp___13 = s;
  s ++;
  (*tmp___12) = (char )(*tmp___13);
  tmp___14 = date_str;
  date_str ++;
  tmp___15 = s;
  s ++;
  (*tmp___14) = (char )(*tmp___15);
  tmp___16 = date_str;
  date_str ++;
  (*tmp___16) = (char )' ';
  real_year = 1900 + xt.tm_year;
  tmp___17 = date_str;
  date_str ++;
  (*tmp___17) = (char )(real_year / 1000 + 48);
  tmp___18 = date_str;
  date_str ++;
  (*tmp___18) = (char )((real_year % 1000) / 100 + 48);
  tmp___19 = date_str;
  date_str ++;
  (*tmp___19) = (char )((real_year % 100) / 10 + 48);
  tmp___20 = date_str;
  date_str ++;
  (*tmp___20) = (char )(real_year % 10 + 48);
  tmp___21 = date_str;
  date_str ++;
  (*tmp___21) = (char )' ';
  tmp___22 = date_str;
  date_str ++;
  (*tmp___22) = (char )(xt.tm_hour / 10 + 48);
  tmp___23 = date_str;
  date_str ++;
  (*tmp___23) = (char )(xt.tm_hour % 10 + 48);
  tmp___24 = date_str;
  date_str ++;
  (*tmp___24) = (char )':';
  tmp___25 = date_str;
  date_str ++;
  (*tmp___25) = (char )(xt.tm_min / 10 + 48);
  tmp___26 = date_str;
  date_str ++;
  (*tmp___26) = (char )(xt.tm_min % 10 + 48);
  tmp___27 = date_str;
  date_str ++;
  (*tmp___27) = (char )':';
  tmp___28 = date_str;
  date_str ++;
  (*tmp___28) = (char )(xt.tm_sec / 10 + 48);
  tmp___29 = date_str;
  date_str ++;
  (*tmp___29) = (char )(xt.tm_sec % 10 + 48);
  tmp___30 = date_str;
  date_str ++;
  (*tmp___30) = (char )' ';
  tmp___31 = date_str;
  date_str ++;
  (*tmp___31) = (char )'G';
  tmp___32 = date_str;
  date_str ++;
  (*tmp___32) = (char )'M';
  tmp___33 = date_str;
  date_str ++;
  (*tmp___33) = (char )'T';
  tmp___34 = date_str;
  date_str ++;
  (*tmp___34) = (char)0;
  return (0);
}
}
apr_status_t apr_ctime(char *date_str , apr_time_t t ) 
{ apr_time_exp_t xt ;
  char const   *s ;
  int real_year ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;

  {
  apr_time_exp_lt(& xt, t);
  s = & apr_day_snames[xt.tm_wday][0];
  tmp = date_str;
  date_str ++;
  tmp___0 = s;
  s ++;
  (*tmp) = (char )(*tmp___0);
  tmp___1 = date_str;
  date_str ++;
  tmp___2 = s;
  s ++;
  (*tmp___1) = (char )(*tmp___2);
  tmp___3 = date_str;
  date_str ++;
  tmp___4 = s;
  s ++;
  (*tmp___3) = (char )(*tmp___4);
  tmp___5 = date_str;
  date_str ++;
  (*tmp___5) = (char )' ';
  s = & apr_month_snames[xt.tm_mon][0];
  tmp___6 = date_str;
  date_str ++;
  tmp___7 = s;
  s ++;
  (*tmp___6) = (char )(*tmp___7);
  tmp___8 = date_str;
  date_str ++;
  tmp___9 = s;
  s ++;
  (*tmp___8) = (char )(*tmp___9);
  tmp___10 = date_str;
  date_str ++;
  tmp___11 = s;
  s ++;
  (*tmp___10) = (char )(*tmp___11);
  tmp___12 = date_str;
  date_str ++;
  (*tmp___12) = (char )' ';
  tmp___13 = date_str;
  date_str ++;
  (*tmp___13) = (char )(xt.tm_mday / 10 + 48);
  tmp___14 = date_str;
  date_str ++;
  (*tmp___14) = (char )(xt.tm_mday % 10 + 48);
  tmp___15 = date_str;
  date_str ++;
  (*tmp___15) = (char )' ';
  tmp___16 = date_str;
  date_str ++;
  (*tmp___16) = (char )(xt.tm_hour / 10 + 48);
  tmp___17 = date_str;
  date_str ++;
  (*tmp___17) = (char )(xt.tm_hour % 10 + 48);
  tmp___18 = date_str;
  date_str ++;
  (*tmp___18) = (char )':';
  tmp___19 = date_str;
  date_str ++;
  (*tmp___19) = (char )(xt.tm_min / 10 + 48);
  tmp___20 = date_str;
  date_str ++;
  (*tmp___20) = (char )(xt.tm_min % 10 + 48);
  tmp___21 = date_str;
  date_str ++;
  (*tmp___21) = (char )':';
  tmp___22 = date_str;
  date_str ++;
  (*tmp___22) = (char )(xt.tm_sec / 10 + 48);
  tmp___23 = date_str;
  date_str ++;
  (*tmp___23) = (char )(xt.tm_sec % 10 + 48);
  tmp___24 = date_str;
  date_str ++;
  (*tmp___24) = (char )' ';
  real_year = 1900 + xt.tm_year;
  tmp___25 = date_str;
  date_str ++;
  (*tmp___25) = (char )(real_year / 1000 + 48);
  tmp___26 = date_str;
  date_str ++;
  (*tmp___26) = (char )((real_year % 1000) / 100 + 48);
  tmp___27 = date_str;
  date_str ++;
  (*tmp___27) = (char )((real_year % 100) / 10 + 48);
  tmp___28 = date_str;
  date_str ++;
  (*tmp___28) = (char )(real_year % 10 + 48);
  tmp___29 = date_str;
  date_str ++;
  (*tmp___29) = (char)0;
  return (0);
}
}
apr_status_t apr_strftime(char *s , apr_size_t *retsize , apr_size_t max , char const   *format ,
                          apr_time_exp_t *xt ) 
{ struct tm tm ;

  {
  memset((void *)(& tm), 0, sizeof(tm));
  tm.tm_sec = xt->tm_sec;
  tm.tm_min = xt->tm_min;
  tm.tm_hour = xt->tm_hour;
  tm.tm_mday = xt->tm_mday;
  tm.tm_mon = xt->tm_mon;
  tm.tm_year = xt->tm_year;
  tm.tm_wday = xt->tm_wday;
  tm.tm_yday = xt->tm_yday;
  tm.tm_isdst = xt->tm_isdst;
  tm.tm_gmtoff = (long )xt->tm_gmtoff;
  (*retsize) = strftime((char * __restrict  )s, max, (char const   * __restrict  )format,
                        (struct tm  const  * __restrict  )(& tm));
  return (0);
}
}
#pragma merger(0,"/tmp/cil-5YXRPOOT.i","-g -pthread")
apr_status_t apr_mmap_offset(void **addr , apr_mmap_t *mmap___0 , apr_off_t offset ) 
{ 

  {
  if (offset < 0L) {
    goto _L;
  } else {
    if ((unsigned long )offset > (unsigned long )mmap___0->size) {
      _L: 
      return (22);
    }
  }
  (*addr) = (void *)((char *)mmap___0->mm + offset);
  return (0);
}
}
#pragma merger(0,"/tmp/cil-l1s7MCCP.i","-g -pthread")
static apr_status_t mmap_cleanup(void *themmap ) 
{ apr_mmap_t *mm ;
  apr_mmap_t *next ;
  int rv ;
  int *tmp ;

  {
  mm = (apr_mmap_t *)themmap;
  next = mm->link.next;
  rv = 0;
  while (1) {
    (mm->link.prev)->link.next = mm->link.next;
    (mm->link.next)->link.prev = mm->link.prev;
    break;
  }
  mm->link.next = (struct apr_mmap_t *)((void *)0);
  mm->link.prev = (struct apr_mmap_t *)((void *)0);
  if ((unsigned int )next != (unsigned int )mm) {
    return (0);
  }
  rv = munmap(mm->mm, mm->size);
  mm->mm = (void *)-1;
  if (rv == 0) {
    return (0);
  }
  tmp = __errno_location();
  return ((*tmp));
}
}
apr_status_t apr_mmap_create(apr_mmap_t **new , apr_file_t *file , apr_off_t offset ,
                             apr_size_t size , apr_int32_t flag , apr_pool_t *cont ) 
{ void *mm ;
  apr_int32_t native_flags ;
  void *tmp ;

  {
  native_flags = 0;
  if ((unsigned int )file == (unsigned int )((void *)0)) {
    goto _L___0;
  } else {
    if (file->filedes == -1) {
      _L___0: 
      goto _L;
    } else {
      if (file->buffered) {
        _L: 
        return (9);
      }
    }
  }
  tmp = apr_palloc(cont, sizeof(apr_mmap_t ));
  (*new) = (apr_mmap_t *)memset(tmp, 0, sizeof(apr_mmap_t ));
  if (flag & 2) {
    native_flags |= 2;
  }
  if (flag & 1) {
    native_flags |= 1;
  }
  mm = mmap((void *)0, size, native_flags, 1, file->filedes, offset);
  if ((unsigned int )mm == (unsigned int )((void *)-1)) {
    return (12);
  }
  ((*new))->mm = mm;
  ((*new))->size = size;
  ((*new))->cntxt = cont;
  while (1) {
    ((*new))->link.next = (*new);
    ((*new))->link.prev = (*new);
    break;
  }
  apr_pool_cleanup_register(((*new))->cntxt, (void const   *)((void *)(*new)), & mmap_cleanup,
                            & apr_pool_cleanup_null);
  return (0);
}
}
apr_status_t apr_mmap_dup(apr_mmap_t **new_mmap , apr_mmap_t *old_mmap , apr_pool_t *p ,
                          int transfer_ownership ) 
{ 

  {
  (*new_mmap) = (apr_mmap_t *)apr_pmemdup(p, (void const   *)old_mmap, sizeof(apr_mmap_t ));
  ((*new_mmap))->cntxt = p;
  while (1) {
    ((*new_mmap))->link.prev = old_mmap;
    ((*new_mmap))->link.next = old_mmap->link.next;
    (old_mmap->link.next)->link.prev = (*new_mmap);
    old_mmap->link.next = (*new_mmap);
    break;
  }
  apr_pool_cleanup_register(p, (void const   *)(*new_mmap), & mmap_cleanup, & apr_pool_cleanup_null);
  return (0);
}
}
apr_status_t apr_mmap_delete(apr_mmap_t *mm ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_cleanup_run(mm->cntxt, (void *)mm, & mmap_cleanup);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-J0p4uACs.i","-g -pthread")
extern key_t ftok(char const   *__pathname , int __proj_id ) ;
extern int shmctl(int __shmid , int __cmd , struct shmid_ds *__buf ) ;
extern int shmget(key_t __key , size_t __size , int __shmflg ) ;
extern void *shmat(int __shmid , void const   *__shmaddr , int __shmflg ) ;
extern int shmdt(void const   *__shmaddr ) ;
static apr_status_t shm_cleanup_owner(void *m_ ) 
{ apr_shm_t *m ;
  int *tmp ;
  int tmp___0 ;
  apr_status_t rv ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  m = (apr_shm_t *)m_;
  if ((unsigned int )m->filename == (unsigned int )((void *)0)) {
    tmp___0 = munmap(m->base, m->realsize);
    if (tmp___0 == -1) {
      tmp = __errno_location();
      return ((*tmp));
    }
    return (0);
  } else {
    tmp___2 = shmctl(m->shmid, 0, (struct shmid_ds *)((void *)0));
    if (tmp___2 == -1) {
      tmp___1 = __errno_location();
      return ((*tmp___1));
    }
    tmp___4 = shmdt((void const   *)m->base);
    if (tmp___4 == -1) {
      tmp___3 = __errno_location();
      return ((*tmp___3));
    }
    rv = apr_file_remove(m->filename, m->pool);
    if (rv != 0) {
      return (rv);
    }
    return (0);
  }
  return (70023);
}
}
apr_status_t apr_shm_create(apr_shm_t **m , apr_size_t reqsize , char const   *filename ,
                            apr_pool_t *pool ) 
{ apr_shm_t *new_m ;
  apr_status_t status ;
  struct shmid_ds shmbuf ;
  apr_uid_t uid ;
  apr_gid_t gid ;
  apr_size_t nbytes ;
  key_t shmkey ;
  apr_file_t *file ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  if ((unsigned int )filename == (unsigned int )((void *)0)) {
    new_m = (apr_shm_t *)apr_palloc(pool, sizeof(apr_shm_t ));
    if (! new_m) {
      return (12);
    }
    new_m->pool = pool;
    new_m->reqsize = reqsize;
    new_m->realsize = reqsize + ((sizeof(apr_size_t ) + 7U) & 4294967288U);
    new_m->filename = (char const   *)((void *)0);
    new_m->base = mmap((void *)0, new_m->realsize, 3, 33, -1, 0L);
    if ((unsigned int )new_m->base == (unsigned int )((void *)-1)) {
      tmp = __errno_location();
      return ((*tmp));
    }
    (*((apr_size_t *)new_m->base)) = new_m->realsize;
    new_m->usable = (void *)((char *)new_m->base + ((sizeof(apr_size_t ) + 7U) & 4294967288U));
    apr_pool_cleanup_register(new_m->pool, (void const   *)new_m, & shm_cleanup_owner,
                              & apr_pool_cleanup_null);
    (*m) = new_m;
    return (0);
    return (70023);
  } else {
    new_m = (apr_shm_t *)apr_palloc(pool, sizeof(apr_shm_t ));
    if (! new_m) {
      return (12);
    }
    new_m->pool = pool;
    new_m->reqsize = reqsize;
    new_m->filename = apr_pstrdup(pool, filename);
    new_m->realsize = reqsize;
    status = apr_file_open(& file, filename, 70, 4095, pool);
    if (status != 0) {
      return (status);
    }
    shmkey = ftok(filename, 1);
    if (shmkey == -1) {
      tmp___0 = __errno_location();
      return ((*tmp___0));
    }
    new_m->shmid = shmget(shmkey, new_m->realsize, 1920);
    if (new_m->shmid < 0) {
      tmp___1 = __errno_location();
      return ((*tmp___1));
    }
    new_m->base = shmat(new_m->shmid, (void const   *)((void *)0), 0);
    if ((unsigned int )new_m->base == (unsigned int )((void *)-1)) {
      tmp___2 = __errno_location();
      return ((*tmp___2));
    }
    new_m->usable = new_m->base;
    tmp___4 = shmctl(new_m->shmid, 2, & shmbuf);
    if (tmp___4 == -1) {
      tmp___3 = __errno_location();
      return ((*tmp___3));
    }
    apr_uid_current(& uid, & gid, pool);
    shmbuf.shm_perm.uid = uid;
    shmbuf.shm_perm.gid = gid;
    tmp___6 = shmctl(new_m->shmid, 1, & shmbuf);
    if (tmp___6 == -1) {
      tmp___5 = __errno_location();
      return ((*tmp___5));
    }
    nbytes = sizeof(reqsize);
    status = apr_file_write(file, (void const   *)(& reqsize), & nbytes);
    if (status != 0) {
      return (status);
    }
    status = apr_file_close(file);
    if (status != 0) {
      return (status);
    }
    apr_pool_cleanup_register(new_m->pool, (void const   *)new_m, & shm_cleanup_owner,
                              & apr_pool_cleanup_null);
    (*m) = new_m;
    return (0);
  }
  return (70023);
}
}
apr_status_t apr_shm_destroy(apr_shm_t *m ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_cleanup_run(m->pool, (void *)m, & shm_cleanup_owner);
  return (tmp);
}
}
static apr_status_t shm_cleanup_attach(void *m_ ) 
{ apr_shm_t *m ;
  int *tmp ;
  int tmp___0 ;

  {
  m = (apr_shm_t *)m_;
  if ((unsigned int )m->filename == (unsigned int )((void *)0)) {
    return (22);
  } else {
    tmp___0 = shmdt((void const   *)m->base);
    if (tmp___0 == -1) {
      tmp = __errno_location();
      return ((*tmp));
    }
    return (0);
  }
  return (70023);
}
}
apr_status_t apr_shm_attach(apr_shm_t **m , char const   *filename , apr_pool_t *pool ) 
{ apr_shm_t *new_m ;
  apr_status_t status ;
  apr_file_t *file ;
  apr_size_t nbytes ;
  key_t shmkey ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  if ((unsigned int )filename == (unsigned int )((void *)0)) {
    return (22);
  } else {
    new_m = (apr_shm_t *)apr_palloc(pool, sizeof(apr_shm_t ));
    if (! new_m) {
      return (12);
    }
    status = apr_file_open(& file, filename, 1, 4095, pool);
    if (status != 0) {
      return (status);
    }
    nbytes = sizeof(new_m->reqsize);
    status = apr_file_read(file, (void *)(& new_m->reqsize), & nbytes);
    if (status != 0) {
      return (status);
    }
    status = apr_file_close(file);
    if (status != 0) {
      return (status);
    }
    new_m->filename = apr_pstrdup(pool, filename);
    new_m->pool = pool;
    shmkey = ftok(filename, 1);
    if (shmkey == -1) {
      tmp = __errno_location();
      return ((*tmp));
    }
    new_m->shmid = shmget(shmkey, 0U, 384);
    if (new_m->shmid == -1) {
      tmp___0 = __errno_location();
      return ((*tmp___0));
    }
    new_m->base = shmat(new_m->shmid, (void const   *)((void *)0), 0);
    if ((unsigned int )new_m->base == (unsigned int )((void *)-1)) {
      tmp___1 = __errno_location();
      return ((*tmp___1));
    }
    new_m->usable = new_m->base;
    new_m->realsize = new_m->reqsize;
    apr_pool_cleanup_register(new_m->pool, (void const   *)new_m, & shm_cleanup_attach,
                              & apr_pool_cleanup_null);
    (*m) = new_m;
    return (0);
  }
  return (70023);
}
}
apr_status_t apr_shm_detach(apr_shm_t *m ) 
{ apr_status_t rv ;
  apr_status_t tmp ;

  {
  tmp = shm_cleanup_attach((void *)m);
  rv = tmp;
  apr_pool_cleanup_kill(m->pool, (void const   *)m, & shm_cleanup_attach);
  return (rv);
}
}
void *apr_shm_baseaddr_get(apr_shm_t const   *m ) 
{ 

  {
  return (m->usable);
}
}
apr_size_t apr_shm_size_get(apr_shm_t const   *m ) 
{ 

  {
  return (m->reqsize);
}
}
apr_pool_t *apr_shm_pool_get(apr_shm_t const   *ob ) 
{ 

  {
  return (ob->pool);
}
}
apr_status_t apr_os_shm_get(apr_os_shm_t *osshm , apr_shm_t *shm ) 
{ 

  {
  return (70023);
}
}
apr_status_t apr_os_shm_put(apr_shm_t **m , apr_os_shm_t *osshm , apr_pool_t *pool ) 
{ 

  {
  return (70023);
}
}
#pragma merger(0,"/tmp/cil-qyBkEclx.i","-g -pthread")
extern int getgrgid_r(__gid_t __gid , struct group * __restrict  __resultbuf , char * __restrict  __buffer ,
                      size_t __buflen , struct group ** __restrict  __result ) ;
extern int getgrnam_r(char const   * __restrict  __name , struct group * __restrict  __resultbuf ,
                      char * __restrict  __buffer , size_t __buflen , struct group ** __restrict  __result ) ;
apr_status_t apr_gid_name_get(char **groupname , apr_gid_t groupid , apr_pool_t *p ) 
{ struct group *gr ;
  struct group grp ;
  char grbuf[512] ;
  int *tmp ;
  int tmp___0 ;

  {
  tmp___0 = getgrgid_r(groupid, (struct group * __restrict  )(& grp), (char * __restrict  )(grbuf),
                       sizeof(grbuf), (struct group ** __restrict  )(& gr));
  if (tmp___0) {
    tmp = __errno_location();
    return ((*tmp));
  }
  (*groupname) = apr_pstrdup(p, (char const   *)gr->gr_name);
  return (0);
}
}
apr_status_t apr_gid_get(apr_gid_t *groupid , char const   *groupname , apr_pool_t *p ) 
{ struct group *gr ;
  struct group grp ;
  char grbuf[512] ;
  int *tmp ;
  int tmp___0 ;

  {
  tmp___0 = getgrnam_r((char const   * __restrict  )groupname, (struct group * __restrict  )(& grp),
                       (char * __restrict  )(grbuf), sizeof(grbuf), (struct group ** __restrict  )(& gr));
  if (tmp___0) {
    tmp = __errno_location();
    return ((*tmp));
  }
  (*groupid) = gr->gr_gid;
  return (0);
}
}
apr_status_t apr_get_groupname(char **groupname , apr_gid_t groupid , apr_pool_t *p ) 
{ apr_status_t tmp ;

  {
  tmp = apr_gid_name_get(groupname, groupid, p);
  return (tmp);
}
}
apr_status_t apr_group_name_get(char **groupname , apr_gid_t groupid , apr_pool_t *p ) 
{ apr_status_t tmp ;

  {
  tmp = apr_gid_name_get(groupname, groupid, p);
  return (tmp);
}
}
apr_status_t apr_get_groupid(apr_gid_t *groupid , char const   *groupname , apr_pool_t *p ) 
{ apr_status_t tmp ;

  {
  tmp = apr_gid_get(groupid, groupname, p);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-uLmptdtZ.i","-g -pthread")
extern int getpwuid_r(__uid_t __uid , struct passwd * __restrict  __resultbuf , char * __restrict  __buffer ,
                      size_t __buflen , struct passwd ** __restrict  __result ) ;
extern int getpwnam_r(char const   * __restrict  __name , struct passwd * __restrict  __resultbuf ,
                      char * __restrict  __buffer , size_t __buflen , struct passwd ** __restrict  __result ) ;
extern __uid_t getuid(void) ;
extern __gid_t getgid(void) ;
static apr_status_t getpwnam_safe(char const   *username , struct passwd *pw , char *pwbuf ) 
{ struct passwd *pwptr ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  tmp___1 = getpwnam_r((char const   * __restrict  )username, (struct passwd * __restrict  )pw,
                       (char * __restrict  )pwbuf, 512U, (struct passwd ** __restrict  )(& pwptr));
  if (tmp___1) {
    _L: 
    tmp = __errno_location();
    if ((*tmp) == 0) {
      return (20014);
    }
    tmp___0 = __errno_location();
    return ((*tmp___0));
  } else {
    if (! pwptr) {
      goto _L;
    }
  }
  return (0);
}
}
apr_status_t apr_uid_homepath_get(char **dirname , char const   *username , apr_pool_t *p ) 
{ struct passwd pw ;
  char pwbuf[512] ;
  apr_status_t rv ;

  {
  rv = getpwnam_safe(username, & pw, pwbuf);
  if (rv != 0) {
    return (rv);
  }
  (*dirname) = apr_pstrdup(p, (char const   *)pw.pw_dir);
  return (0);
}
}
apr_status_t apr_uid_current(apr_uid_t *uid , apr_gid_t *gid , apr_pool_t *p ) 
{ 

  {
  (*uid) = getuid();
  (*gid) = getgid();
  return (0);
}
}
apr_status_t apr_uid_get(apr_uid_t *uid , apr_gid_t *gid , char const   *username ,
                         apr_pool_t *p ) 
{ struct passwd pw ;
  char pwbuf[512] ;
  apr_status_t rv ;

  {
  rv = getpwnam_safe(username, & pw, pwbuf);
  if (rv != 0) {
    return (rv);
  }
  (*uid) = pw.pw_uid;
  (*gid) = pw.pw_gid;
  return (0);
}
}
apr_status_t apr_uid_name_get(char **username , apr_uid_t userid , apr_pool_t *p ) 
{ struct passwd *pw ;
  struct passwd pwd ;
  char pwbuf[512] ;
  int *tmp ;
  int tmp___0 ;

  {
  tmp___0 = getpwuid_r(userid, (struct passwd * __restrict  )(& pwd), (char * __restrict  )(pwbuf),
                       sizeof(pwbuf), (struct passwd ** __restrict  )(& pw));
  if (tmp___0) {
    tmp = __errno_location();
    return ((*tmp));
  }
  (*username) = apr_pstrdup(p, (char const   *)pw->pw_name);
  return (0);
}
}
apr_status_t apr_get_home_directory(char **dirname , char const   *username , apr_pool_t *p ) 
{ apr_status_t tmp ;

  {
  tmp = apr_uid_homepath_get(dirname, username, p);
  return (tmp);
}
}
apr_status_t apr_get_userid(apr_uid_t *uid , apr_gid_t *gid , char const   *username ,
                            apr_pool_t *p ) 
{ apr_status_t tmp ;

  {
  tmp = apr_uid_get(uid, gid, username, p);
  return (tmp);
}
}
apr_status_t apr_current_userid(apr_uid_t *uid , apr_gid_t *gid , apr_pool_t *p ) 
{ apr_status_t tmp ;

  {
  tmp = apr_uid_current(uid, gid, p);
  return (tmp);
}
}
apr_status_t apr_get_username(char **username , apr_uid_t userid , apr_pool_t *p ) 
{ apr_status_t tmp ;

  {
  tmp = apr_uid_name_get(username, userid, p);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-27MDZOH5.i","-g -pthread")
apr_status_t apr_allocator_create(apr_allocator_t **allocator ) 
{ apr_allocator_t *new_allocator ;

  {
  (*allocator) = (apr_allocator_t *)((void *)0);
  new_allocator = (apr_allocator_t *)malloc((sizeof(apr_allocator_t ) + 7U) & 4294967288U);
  if ((unsigned int )new_allocator == (unsigned int )((void *)0)) {
    return (12);
  }
  memset((void *)new_allocator, 0, (sizeof(apr_allocator_t ) + 7U) & 4294967288U);
  new_allocator->max_free_index = 0U;
  (*allocator) = new_allocator;
  return (0);
}
}
void apr_allocator_destroy(apr_allocator_t *allocator ) 
{ apr_uint32_t index___0 ;
  apr_memnode_t *node ;
  apr_memnode_t **ref ;

  {
  index___0 = 0U;
  while (index___0 < 20U) {
    ref = & allocator->free[index___0];
    while (1) {
      node = (*ref);
      if (! ((unsigned int )node != (unsigned int )((void *)0))) {
        break;
      }
      (*ref) = node->next;
      free((void *)node);
    }
    index___0 ++;
  }
  free((void *)allocator);
  return;
}
}
void apr_allocator_mutex_set(apr_allocator_t *allocator , apr_thread_mutex_t *mutex ) 
{ 

  {
  allocator->mutex = mutex;
  return;
}
}
apr_thread_mutex_t *apr_allocator_mutex_get(apr_allocator_t *allocator ) 
{ 

  {
  return (allocator->mutex);
}
}
void apr_allocator_owner_set(apr_allocator_t *allocator , apr_pool_t *pool ) 
{ 

  {
  allocator->owner = pool;
  return;
}
}
apr_pool_t *apr_allocator_owner_get(apr_allocator_t *allocator ) 
{ 

  {
  return (allocator->owner);
}
}
void apr_allocator_max_free_set(apr_allocator_t *allocator , apr_size_t size ) 
{ apr_uint32_t max_free_index ;
  apr_thread_mutex_t *mutex ;

  {
  mutex = apr_allocator_mutex_get(allocator);
  if ((unsigned int )mutex != (unsigned int )((void *)0)) {
    apr_thread_mutex_lock(mutex);
  }
  max_free_index = ((size + 4095U) & 4294963200U) >> 12;
  allocator->current_free_index += max_free_index;
  allocator->current_free_index -= allocator->max_free_index;
  allocator->max_free_index = max_free_index;
  if (allocator->current_free_index > max_free_index) {
    allocator->current_free_index = max_free_index;
  }
  if ((unsigned int )mutex != (unsigned int )((void *)0)) {
    apr_thread_mutex_unlock(mutex);
  }
  return;
}
}
__inline static apr_memnode_t *allocator_alloc(apr_allocator_t *allocator , apr_size_t size ) 
{ apr_memnode_t *node ;
  apr_memnode_t **ref ;
  apr_uint32_t i ;
  apr_uint32_t index___0 ;
  apr_uint32_t max_index ;

  {
  size = ((size + ((sizeof(apr_memnode_t ) + 7U) & 4294967288U)) + 4095U) & 4294963200U;
  if (size < 8192U) {
    size = 8192U;
  }
  index___0 = (size >> 12) - 1U;
  if (index___0 <= allocator->max_index) {
    if (allocator->mutex) {
      apr_thread_mutex_lock(allocator->mutex);
    }
    max_index = allocator->max_index;
    ref = & allocator->free[index___0];
    i = index___0;
    while (1) {
      if ((unsigned int )(*ref) == (unsigned int )((void *)0)) {
        if (! (i < max_index)) {
          goto _L;
        }
      } else {
        _L: 
        break;
      }
      ref ++;
      i ++;
    }
    node = (*ref);
    if ((unsigned int )node != (unsigned int )((void *)0)) {
      (*ref) = node->next;
      if ((unsigned int )(*ref) == (unsigned int )((void *)0)) {
        if (i >= max_index) {
          while (1) {
            ref --;
            max_index --;
            if ((unsigned int )(*ref) == (unsigned int )((void *)0)) {
              if (! (max_index > 0U)) {
                goto _L___0;
              }
            } else {
              _L___0: 
              break;
            }
          }
          allocator->max_index = max_index;
        } else {
          goto _L___1;
        }
      } else {
        _L___1: ;
      }
      allocator->current_free_index += node->index;
      if (allocator->current_free_index > allocator->max_free_index) {
        allocator->current_free_index = allocator->max_free_index;
      }
      if (allocator->mutex) {
        apr_thread_mutex_unlock(allocator->mutex);
      }
      node->next = (apr_memnode_t *)((void *)0);
      node->first_avail = (char *)node + ((sizeof(apr_memnode_t ) + 7U) & 4294967288U);
      return (node);
    }
    if (allocator->mutex) {
      apr_thread_mutex_unlock(allocator->mutex);
    }
  } else {
    if (allocator->free[0]) {
      if (allocator->mutex) {
        apr_thread_mutex_lock(allocator->mutex);
      }
      ref = & allocator->free[0];
      while (1) {
        node = (*ref);
        if ((unsigned int )node != (unsigned int )((void *)0)) {
          if (! (index___0 > node->index)) {
            goto _L___2;
          }
        } else {
          _L___2: 
          break;
        }
        ref = & node->next;
      }
      if (node) {
        (*ref) = node->next;
        allocator->current_free_index += node->index;
        if (allocator->current_free_index > allocator->max_free_index) {
          allocator->current_free_index = allocator->max_free_index;
        }
        if (allocator->mutex) {
          apr_thread_mutex_unlock(allocator->mutex);
        }
        node->next = (apr_memnode_t *)((void *)0);
        node->first_avail = (char *)node + ((sizeof(apr_memnode_t ) + 7U) & 4294967288U);
        return (node);
      }
      if (allocator->mutex) {
        apr_thread_mutex_unlock(allocator->mutex);
      }
    }
  }
  node = (apr_memnode_t *)malloc(size);
  if ((unsigned int )node == (unsigned int )((void *)0)) {
    return ((apr_memnode_t *)((void *)0));
  }
  node->next = (apr_memnode_t *)((void *)0);
  node->index = index___0;
  node->first_avail = (char *)node + ((sizeof(apr_memnode_t ) + 7U) & 4294967288U);
  node->endp = (char *)node + size;
  return (node);
}
}
__inline static void allocator_free(apr_allocator_t *allocator , apr_memnode_t *node ) 
{ apr_memnode_t *next ;
  apr_memnode_t *freelist ;
  apr_uint32_t index___0 ;
  apr_uint32_t max_index ;
  apr_uint32_t max_free_index ;
  apr_uint32_t current_free_index ;

  {
  freelist = (apr_memnode_t *)((void *)0);
  if (allocator->mutex) {
    apr_thread_mutex_lock(allocator->mutex);
  }
  max_index = allocator->max_index;
  max_free_index = allocator->max_free_index;
  current_free_index = allocator->current_free_index;
  while (1) {
    next = node->next;
    index___0 = node->index;
    if (max_free_index != 0U) {
      if (index___0 > current_free_index) {
        node->next = freelist;
        freelist = node;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if (index___0 < 20U) {
        node->next = allocator->free[index___0];
        if ((unsigned int )node->next == (unsigned int )((void *)0)) {
          if (index___0 > max_index) {
            max_index = index___0;
          } else {
            goto _L;
          }
        } else {
          _L: ;
        }
        allocator->free[index___0] = node;
        current_free_index -= index___0;
      } else {
        node->next = allocator->free[0];
        allocator->free[0] = node;
        current_free_index -= index___0;
      }
    }
    node = next;
    if (! ((unsigned int )node != (unsigned int )((void *)0))) {
      break;
    }
  }
  allocator->max_index = max_index;
  allocator->current_free_index = current_free_index;
  if (allocator->mutex) {
    apr_thread_mutex_unlock(allocator->mutex);
  }
  while ((unsigned int )freelist != (unsigned int )((void *)0)) {
    node = freelist;
    freelist = node->next;
    free((void *)node);
  }
  return;
}
}
apr_memnode_t *apr_allocator_alloc(apr_allocator_t *allocator , apr_size_t size ) 
{ apr_memnode_t *tmp ;

  {
  tmp = allocator_alloc(allocator, size);
  return (tmp);
}
}
void apr_allocator_free(apr_allocator_t *allocator , apr_memnode_t *node ) 
{ 

  {
  allocator_free(allocator, node);
  return;
}
}
static unsigned char apr_pools_initialized  =    (unsigned char)0;
static apr_pool_t *global_pool  =    (apr_pool_t *)((void *)0);
static apr_allocator_t *global_allocator  =    (apr_allocator_t *)((void *)0);
static void run_cleanups(cleanup_t **cref ) ;
static void run_child_cleanups(cleanup_t **cref ) ;
static void free_proc_chain(struct process_chain *procs ) ;
apr_status_t apr_pool_initialize(void) 
{ apr_status_t rv ;
  unsigned char tmp ;
  apr_thread_mutex_t *mutex ;

  {
  tmp = apr_pools_initialized;
  apr_pools_initialized = (unsigned char )((int )apr_pools_initialized + 1);
  if (tmp) {
    return (0);
  }
  rv = apr_allocator_create(& global_allocator);
  if (rv != 0) {
    apr_pools_initialized = (unsigned char)0;
    return (rv);
  }
  rv = apr_pool_create_ex(& global_pool, (apr_pool_t *)((void *)0), (int (*)(int retcode ))((void *)0),
                          global_allocator);
  if (rv != 0) {
    apr_allocator_destroy(global_allocator);
    global_allocator = (apr_allocator_t *)((void *)0);
    apr_pools_initialized = (unsigned char)0;
    return (rv);
  }
  apr_pool_tag(global_pool, "apr_global_pool");
  rv = apr_thread_mutex_create(& mutex, 0U, global_pool);
  if (rv != 0) {
    return (rv);
  }
  apr_allocator_mutex_set(global_allocator, mutex);
  apr_allocator_owner_set(global_allocator, global_pool);
  return (0);
}
}
void apr_pool_terminate(void) 
{ 

  {
  if (! apr_pools_initialized) {
    return;
  }
  apr_pools_initialized = (unsigned char )((int )apr_pools_initialized - 1);
  if (apr_pools_initialized) {
    return;
  }
  apr_pool_destroy(global_pool);
  global_pool = (apr_pool_t *)((void *)0);
  global_allocator = (apr_allocator_t *)((void *)0);
  return;
}
}
void *apr_palloc(apr_pool_t *pool , apr_size_t size ) 
{ apr_memnode_t *active ;
  apr_memnode_t *node ;
  void *mem ;
  apr_uint32_t free_index ;

  {
  size = (size + 7U) & 4294967288U;
  active = pool->active;
  if (size < (unsigned int )(active->endp - active->first_avail)) {
    mem = (void *)active->first_avail;
    active->first_avail = active->first_avail + size;
    return (mem);
  }
  node = active->next;
  if (size < (unsigned int )(node->endp - node->first_avail)) {
    (*(node->ref)) = node->next;
    (node->next)->ref = node->ref;
  } else {
    node = allocator_alloc(pool->allocator, size);
    if ((unsigned int )node == (unsigned int )((void *)0)) {
      if (pool->abort_fn) {
        ((*(pool->abort_fn)))(12);
      }
      return ((void *)0);
    }
  }
  node->free_index = 0U;
  mem = (void *)node->first_avail;
  node->first_avail = node->first_avail + size;
  node->ref = active->ref;
  (*(node->ref)) = node;
  node->next = active;
  active->ref = & node->next;
  pool->active = node;
  free_index = (unsigned int )((((((active->endp - active->first_avail) + 1) + 4095) &
                                 -4096) - 4096) >> 12);
  active->free_index = free_index;
  node = active->next;
  if (free_index >= node->free_index) {
    return (mem);
  }
  while (1) {
    node = node->next;
    if (! (free_index < node->free_index)) {
      break;
    }
  }
  (*(active->ref)) = active->next;
  (active->next)->ref = active->ref;
  active->ref = node->ref;
  (*(active->ref)) = active;
  active->next = node;
  node->ref = & active->next;
  return (mem);
}
}
void *apr_pcalloc(apr_pool_t *pool , apr_size_t size ) ;
void *apr_pcalloc(apr_pool_t *pool , apr_size_t size ) 
{ void *mem ;

  {
  size = (size + 7U) & 4294967288U;
  mem = apr_palloc(pool, size);
  if ((unsigned int )mem != (unsigned int )((void *)0)) {
    memset(mem, 0, size);
  }
  return (mem);
}
}
void apr_pool_clear(apr_pool_t *pool ) 
{ apr_memnode_t *active ;

  {
  while (pool->child) {
    apr_pool_destroy(pool->child);
  }
  run_cleanups(& pool->cleanups);
  pool->cleanups = (cleanup_t *)((void *)0);
  free_proc_chain(pool->subprocesses);
  pool->subprocesses = (struct process_chain *)((void *)0);
  pool->user_data = (apr_hash_t *)((void *)0);
  pool->active = pool->self;
  active = pool->active;
  active->first_avail = pool->self_first_avail;
  if ((unsigned int )active->next == (unsigned int )active) {
    return;
  }
  (*(active->ref)) = (apr_memnode_t *)((void *)0);
  allocator_free(pool->allocator, active->next);
  active->next = active;
  active->ref = & active->next;
  return;
}
}
void apr_pool_destroy(apr_pool_t *pool ) 
{ apr_memnode_t *active ;
  apr_allocator_t *allocator ;
  apr_thread_mutex_t *mutex ;
  apr_pool_t *tmp ;
  apr_pool_t *tmp___0 ;

  {
  while (pool->child) {
    apr_pool_destroy(pool->child);
  }
  run_cleanups(& pool->cleanups);
  free_proc_chain(pool->subprocesses);
  if (pool->parent) {
    mutex = apr_allocator_mutex_get((pool->parent)->allocator);
    if ((unsigned int )mutex != (unsigned int )((void *)0)) {
      apr_thread_mutex_lock(mutex);
    }
    (*(pool->ref)) = pool->sibling;
    if ((unsigned int )(*(pool->ref)) != (unsigned int )((void *)0)) {
      (pool->sibling)->ref = pool->ref;
    }
    if (mutex) {
      apr_thread_mutex_unlock(mutex);
    }
  }
  allocator = pool->allocator;
  active = pool->self;
  (*(active->ref)) = (apr_memnode_t *)((void *)0);
  tmp = apr_allocator_owner_get(allocator);
  if ((unsigned int )tmp == (unsigned int )pool) {
    apr_allocator_mutex_set(allocator, (apr_thread_mutex_t *)((void *)0));
  }
  allocator_free(allocator, active);
  tmp___0 = apr_allocator_owner_get(allocator);
  if ((unsigned int )tmp___0 == (unsigned int )pool) {
    apr_allocator_destroy(allocator);
  }
  return;
}
}
apr_status_t apr_pool_create_ex(apr_pool_t **newpool , apr_pool_t *parent , int (*abort_fn)(int retcode ) ,
                                apr_allocator_t *allocator ) 
{ apr_pool_t *pool ;
  apr_memnode_t *node ;
  apr_thread_mutex_t *mutex ;

  {
  (*newpool) = (apr_pool_t *)((void *)0);
  if (! parent) {
    parent = global_pool;
  }
  if (! abort_fn) {
    if (parent) {
      abort_fn = parent->abort_fn;
    } else {
      goto _L;
    }
  } else {
    _L: ;
  }
  if ((unsigned int )allocator == (unsigned int )((void *)0)) {
    allocator = parent->allocator;
  }
  node = allocator_alloc(allocator, 8192U - ((sizeof(apr_memnode_t ) + 7U) & 4294967288U));
  if ((unsigned int )node == (unsigned int )((void *)0)) {
    if (abort_fn) {
      ((*abort_fn))(12);
    }
    return (12);
  }
  node->next = node;
  node->ref = & node->next;
  pool = (apr_pool_t *)node->first_avail;
  pool->self_first_avail = (char *)pool + ((sizeof(apr_pool_t ) + 7U) & 4294967288U);
  node->first_avail = pool->self_first_avail;
  pool->allocator = allocator;
  pool->self = node;
  pool->active = pool->self;
  pool->abort_fn = abort_fn;
  pool->child = (apr_pool_t *)((void *)0);
  pool->cleanups = (cleanup_t *)((void *)0);
  pool->subprocesses = (struct process_chain *)((void *)0);
  pool->user_data = (apr_hash_t *)((void *)0);
  pool->tag = (char const   *)((void *)0);
  pool->parent = parent;
  if ((unsigned int )pool->parent != (unsigned int )((void *)0)) {
    mutex = apr_allocator_mutex_get(allocator);
    if ((unsigned int )mutex != (unsigned int )((void *)0)) {
      apr_thread_mutex_lock(mutex);
    }
    pool->sibling = parent->child;
    if ((unsigned int )pool->sibling != (unsigned int )((void *)0)) {
      (pool->sibling)->ref = & pool->sibling;
    }
    parent->child = pool;
    pool->ref = & parent->child;
    if (mutex) {
      apr_thread_mutex_unlock(mutex);
    }
  } else {
    pool->sibling = (apr_pool_t *)((void *)0);
    pool->ref = (apr_pool_t **)((void *)0);
  }
  (*newpool) = pool;
  return (0);
}
}
static int psprintf_flush(apr_vformatter_buff_t *vbuff ) 
{ struct psprintf_data *ps ;
  apr_memnode_t *node ;
  apr_memnode_t *active ;
  apr_size_t cur_len ;
  apr_size_t size ;
  char *strp ;
  apr_pool_t *pool ;
  apr_uint32_t free_index ;

  {
  ps = (struct psprintf_data *)vbuff;
  pool = ps->pool;
  active = ps->node;
  strp = ps->vbuff.curpos;
  cur_len = (unsigned int )(strp - active->first_avail);
  size = cur_len << 1;
  if (size < 32U) {
    size = 32U;
  }
  node = active->next;
  if (! ps->got_a_new_node) {
    if (size < (unsigned int )(node->endp - node->first_avail)) {
      (*(node->ref)) = node->next;
      (node->next)->ref = node->ref;
      node->ref = active->ref;
      (*(node->ref)) = node;
      node->next = active;
      active->ref = & node->next;
      node->free_index = 0U;
      pool->active = node;
      free_index = (unsigned int )((((((active->endp - active->first_avail) + 1) +
                                      4095) & -4096) - 4096) >> 12);
      active->free_index = free_index;
      node = active->next;
      if (free_index < node->free_index) {
        while (1) {
          node = node->next;
          if (! (free_index < node->free_index)) {
            break;
          }
        }
        (*(active->ref)) = active->next;
        (active->next)->ref = active->ref;
        active->ref = node->ref;
        (*(active->ref)) = active;
        active->next = node;
        node->ref = & active->next;
      }
      node = pool->active;
    } else {
      goto _L;
    }
  } else {
    _L: 
    node = allocator_alloc(pool->allocator, size);
    if ((unsigned int )node == (unsigned int )((void *)0)) {
      return (-1);
    }
    if (ps->got_a_new_node) {
      active->next = ps->free;
      ps->free = node;
    }
    ps->got_a_new_node = (unsigned char)1;
  }
  memcpy((void * __restrict  )node->first_avail, (void const   * __restrict  )active->first_avail,
         cur_len);
  ps->node = node;
  ps->vbuff.curpos = node->first_avail + cur_len;
  ps->vbuff.endpos = node->endp - 1;
  return (0);
}
}
char *apr_pvsprintf(apr_pool_t *pool , char const   *fmt , va_list ap ) 
{ struct psprintf_data ps ;
  char *strp ;
  apr_size_t size ;
  apr_memnode_t *active ;
  apr_memnode_t *node ;
  apr_uint32_t free_index ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  active = pool->active;
  ps.node = active;
  ps.pool = pool;
  ps.vbuff.curpos = (ps.node)->first_avail;
  ps.vbuff.endpos = (ps.node)->endp - 1;
  ps.got_a_new_node = (unsigned char)0;
  ps.free = (apr_memnode_t *)((void *)0);
  if ((unsigned int )(ps.node)->first_avail == (unsigned int )(ps.node)->endp) {
    tmp = psprintf_flush(& ps.vbuff);
    if (tmp == -1) {
      if (pool->abort_fn) {
        ((*(pool->abort_fn)))(12);
      }
      return ((char *)((void *)0));
    }
  }
  tmp___0 = apr_vformatter(& psprintf_flush, & ps.vbuff, fmt, ap);
  if (tmp___0 == -1) {
    if (pool->abort_fn) {
      ((*(pool->abort_fn)))(12);
    }
    return ((char *)((void *)0));
  }
  strp = ps.vbuff.curpos;
  tmp___1 = strp;
  strp ++;
  (*tmp___1) = (char )'\000';
  size = (unsigned int )(strp - (ps.node)->first_avail);
  size = (size + 7U) & 4294967288U;
  strp = (ps.node)->first_avail;
  (ps.node)->first_avail = (ps.node)->first_avail + size;
  if (ps.free) {
    allocator_free(pool->allocator, ps.free);
  }
  if (! ps.got_a_new_node) {
    return (strp);
  }
  active = pool->active;
  node = ps.node;
  node->free_index = 0U;
  node->ref = active->ref;
  (*(node->ref)) = node;
  node->next = active;
  active->ref = & node->next;
  pool->active = node;
  free_index = (unsigned int )((((((active->endp - active->first_avail) + 1) + 4095) &
                                 -4096) - 4096) >> 12);
  active->free_index = free_index;
  node = active->next;
  if (free_index >= node->free_index) {
    return (strp);
  }
  while (1) {
    node = node->next;
    if (! (free_index < node->free_index)) {
      break;
    }
  }
  (*(active->ref)) = active->next;
  (active->next)->ref = active->ref;
  active->ref = node->ref;
  (*(active->ref)) = active;
  active->next = node;
  node->ref = & active->next;
  return (strp);
}
}
char *( /* format attribute */  apr_psprintf)(apr_pool_t *p , char const   *fmt  , ...) 
{ va_list ap ;
  char *res ;

  {
  __builtin_stdarg_start(ap, fmt);
  res = apr_pvsprintf(p, fmt, ap);
  __builtin_va_end(ap);
  return (res);
}
}
void apr_pool_abort_set(int (*abort_fn)(int retcode ) , apr_pool_t *pool ) 
{ 

  {
  pool->abort_fn = abort_fn;
  return;
}
}
apr_abortfunc_t apr_pool_abort_get(apr_pool_t *pool ) 
{ 

  {
  return (pool->abort_fn);
}
}
apr_pool_t *apr_pool_parent_get(apr_pool_t *pool ) 
{ 

  {
  return (pool->parent);
}
}
apr_allocator_t *apr_pool_allocator_get(apr_pool_t *pool ) 
{ 

  {
  return (pool->allocator);
}
}
int apr_pool_is_ancestor(apr_pool_t *a , apr_pool_t *b ) 
{ 

  {
  if ((unsigned int )a == (unsigned int )((void *)0)) {
    return (1);
  }
  while (b) {
    if ((unsigned int )a == (unsigned int )b) {
      return (1);
    }
    b = b->parent;
  }
  return (0);
}
}
void apr_pool_tag(apr_pool_t *pool , char const   *tag ) 
{ 

  {
  pool->tag = tag;
  return;
}
}
apr_status_t apr_pool_userdata_set(void const   *data , char const   *key , apr_status_t (*cleanup)(void * ) ,
                                   apr_pool_t *pool ) 
{ char *new_key ;
  char *tmp ;
  void *tmp___0 ;

  {
  if ((unsigned int )pool->user_data == (unsigned int )((void *)0)) {
    pool->user_data = apr_hash_make(pool);
  }
  tmp___0 = apr_hash_get(pool->user_data, (void const   *)key, -1);
  if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
    tmp = apr_pstrdup(pool, key);
    new_key = tmp;
    apr_hash_set(pool->user_data, (void const   *)new_key, -1, data);
  } else {
    apr_hash_set(pool->user_data, (void const   *)key, -1, data);
  }
  if (cleanup) {
    apr_pool_cleanup_register(pool, data, cleanup, cleanup);
  }
  return (0);
}
}
apr_status_t apr_pool_userdata_setn(void const   *data , char const   *key , apr_status_t (*cleanup)(void * ) ,
                                    apr_pool_t *pool ) 
{ 

  {
  if ((unsigned int )pool->user_data == (unsigned int )((void *)0)) {
    pool->user_data = apr_hash_make(pool);
  }
  apr_hash_set(pool->user_data, (void const   *)key, -1, data);
  if (cleanup) {
    apr_pool_cleanup_register(pool, data, cleanup, cleanup);
  }
  return (0);
}
}
apr_status_t apr_pool_userdata_get(void **data , char const   *key , apr_pool_t *pool ) 
{ 

  {
  if ((unsigned int )pool->user_data == (unsigned int )((void *)0)) {
    (*data) = (void *)0;
  } else {
    (*data) = apr_hash_get(pool->user_data, (void const   *)key, -1);
  }
  return (0);
}
}
void apr_pool_cleanup_register(apr_pool_t *p , void const   *data , apr_status_t (*plain_cleanup_fn)(void *data ) ,
                               apr_status_t (*child_cleanup_fn)(void *data ) ) 
{ cleanup_t *c ;

  {
  if ((unsigned int )p != (unsigned int )((void *)0)) {
    c = (cleanup_t *)apr_palloc(p, sizeof(cleanup_t ));
    c->data = data;
    c->plain_cleanup_fn = plain_cleanup_fn;
    c->child_cleanup_fn = child_cleanup_fn;
    c->next = p->cleanups;
    p->cleanups = c;
  }
  return;
}
}
void apr_pool_cleanup_kill(apr_pool_t *p , void const   *data , apr_status_t (*cleanup_fn)(void * ) ) 
{ cleanup_t *c ;
  cleanup_t **lastp ;

  {
  if ((unsigned int )p == (unsigned int )((void *)0)) {
    return;
  }
  c = p->cleanups;
  lastp = & p->cleanups;
  while (c) {
    if ((unsigned int )c->data == (unsigned int )data) {
      if ((unsigned int )c->plain_cleanup_fn == (unsigned int )cleanup_fn) {
        (*lastp) = c->next;
        break;
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    lastp = & c->next;
    c = c->next;
  }
  return;
}
}
void apr_pool_child_cleanup_set(apr_pool_t *p , void const   *data , apr_status_t (*plain_cleanup_fn)(void * ) ,
                                apr_status_t (*child_cleanup_fn)(void * ) ) 
{ cleanup_t *c ;

  {
  if ((unsigned int )p == (unsigned int )((void *)0)) {
    return;
  }
  c = p->cleanups;
  while (c) {
    if ((unsigned int )c->data == (unsigned int )data) {
      if ((unsigned int )c->plain_cleanup_fn == (unsigned int )plain_cleanup_fn) {
        c->child_cleanup_fn = child_cleanup_fn;
        break;
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    c = c->next;
  }
  return;
}
}
apr_status_t apr_pool_cleanup_run(apr_pool_t *p , void *data , apr_status_t (*cleanup_fn)(void * ) ) 
{ apr_status_t tmp ;

  {
  apr_pool_cleanup_kill(p, (void const   *)data, cleanup_fn);
  tmp = ((*cleanup_fn))(data);
  return (tmp);
}
}
static void run_cleanups(cleanup_t **cref ) 
{ cleanup_t *c ;

  {
  c = (*cref);
  while (c) {
    (*cref) = c->next;
    ((*(c->plain_cleanup_fn)))((void *)c->data);
    c = (*cref);
  }
  return;
}
}
static void run_child_cleanups(cleanup_t **cref ) 
{ cleanup_t *c ;

  {
  c = (*cref);
  while (c) {
    (*cref) = c->next;
    ((*(c->child_cleanup_fn)))((void *)c->data);
    c = (*cref);
  }
  return;
}
}
static void cleanup_pool_for_exec(apr_pool_t *p ) 
{ 

  {
  run_child_cleanups(& p->cleanups);
  p = p->child;
  while (p) {
    cleanup_pool_for_exec(p);
    p = p->sibling;
  }
  return;
}
}
void apr_pool_cleanup_for_exec(void) 
{ 

  {
  cleanup_pool_for_exec(global_pool);
  return;
}
}
apr_status_t apr_pool_cleanup_null(void *data ) 
{ 

  {
  return (0);
}
}
void apr_pool_note_subprocess(apr_pool_t *pool , apr_proc_t *pid , apr_kill_conditions_e how ) 
{ struct process_chain *pc ;
  struct process_chain *tmp ;

  {
  tmp = (struct process_chain *)apr_palloc(pool, sizeof(struct process_chain ));
  pc = tmp;
  pc->pid = pid;
  pc->kill_how = how;
  pc->next = pool->subprocesses;
  pool->subprocesses = pc;
  return;
}
}
static void free_proc_chain(struct process_chain *procs ) 
{ struct process_chain *pc ;
  int need_timeout ;
  apr_time_t timeout_interval ;
  apr_status_t tmp ;
  apr_status_t tmp___0 ;
  apr_status_t tmp___1 ;

  {
  need_timeout = 0;
  if (! procs) {
    return;
  }
  pc = procs;
  while (pc) {
    tmp = apr_proc_wait(pc->pid, (int *)((void *)0), (apr_exit_why_e *)((void *)0),
                        (enum __anonenum_apr_wait_how_e_53 )1);
    if (tmp != 70006) {
      pc->kill_how = (enum __anonenum_apr_kill_conditions_e_55 )0;
    }
    pc = pc->next;
  }
  pc = procs;
  while (pc) {
    if ((int )pc->kill_how == 2) {
      goto _L;
    } else {
      if ((int )pc->kill_how == 4) {
        _L: 
        tmp___0 = apr_proc_kill(pc->pid, 15);
        if (tmp___0 == 0) {
          need_timeout = 1;
        }
      } else {
        if ((int )pc->kill_how == 1) {
          apr_proc_kill(pc->pid, 9);
        }
      }
    }
    pc = pc->next;
  }
  if (need_timeout) {
    timeout_interval = 46875LL;
    apr_sleep(timeout_interval);
    while (1) {
      need_timeout = 0;
      pc = procs;
      while (pc) {
        if ((int )pc->kill_how == 2) {
          tmp___1 = apr_proc_wait(pc->pid, (int *)((void *)0), (apr_exit_why_e *)((void *)0),
                                  (enum __anonenum_apr_wait_how_e_53 )1);
          if (tmp___1 == 70006) {
            need_timeout = 1;
          } else {
            pc->kill_how = (enum __anonenum_apr_kill_conditions_e_55 )0;
          }
        }
        pc = pc->next;
      }
      if (need_timeout) {
        if (timeout_interval >= 3000000LL) {
          break;
        }
        apr_sleep(timeout_interval);
        timeout_interval *= 2LL;
      }
      if (! need_timeout) {
        break;
      }
    }
  }
  pc = procs;
  while (pc) {
    if ((int )pc->kill_how == 2) {
      apr_proc_kill(pc->pid, 9);
    }
    pc = pc->next;
  }
  pc = procs;
  while (pc) {
    if ((int )pc->kill_how != 0) {
      apr_proc_wait(pc->pid, (int *)((void *)0), (apr_exit_why_e *)((void *)0), (enum __anonenum_apr_wait_how_e_53 )0);
    }
    pc = pc->next;
  }
  return;
}
}
void *apr_palloc_debug(apr_pool_t *pool , apr_size_t size , char const   *file_line ) 
{ void *tmp ;

  {
  tmp = apr_palloc(pool, size);
  return (tmp);
}
}
void *apr_pcalloc_debug(apr_pool_t *pool , apr_size_t size , char const   *file_line ) 
{ void *tmp ;

  {
  tmp = apr_pcalloc(pool, size);
  return (tmp);
}
}
void apr_pool_clear_debug(apr_pool_t *pool , char const   *file_line ) 
{ 

  {
  apr_pool_clear(pool);
  return;
}
}
void apr_pool_destroy_debug(apr_pool_t *pool , char const   *file_line ) 
{ 

  {
  apr_pool_destroy(pool);
  return;
}
}
apr_status_t apr_pool_create_ex_debug(apr_pool_t **newpool , apr_pool_t *parent ,
                                      int (*abort_fn)(int retcode ) , apr_allocator_t *allocator ,
                                      char const   *file_line ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_create_ex(newpool, parent, abort_fn, allocator);
  return (tmp);
}
}
void apr_allocator_set_max_free(apr_allocator_t *allocator , apr_size_t size ) 
{ 

  {
  apr_allocator_max_free_set(allocator, size);
  return;
}
}
void apr_pool_set_abort(int (*abort_fn)(int retcode ) , apr_pool_t *pool ) 
{ 

  {
  apr_pool_abort_set(abort_fn, pool);
  return;
}
}
apr_abortfunc_t apr_pool_get_abort(apr_pool_t *pool ) 
{ int (*tmp)(int retcode ) ;

  {
  tmp = apr_pool_abort_get(pool);
  return (tmp);
}
}
apr_pool_t *apr_pool_get_parent(apr_pool_t *pool ) 
{ apr_pool_t *tmp ;

  {
  tmp = apr_pool_parent_get(pool);
  return (tmp);
}
}
void apr_allocator_set_owner(apr_allocator_t *allocator , apr_pool_t *pool ) 
{ 

  {
  apr_allocator_owner_set(allocator, pool);
  return;
}
}
apr_pool_t *apr_allocator_get_owner(apr_allocator_t *allocator ) 
{ apr_pool_t *tmp ;

  {
  tmp = apr_allocator_owner_get(allocator);
  return (tmp);
}
}
apr_thread_mutex_t *apr_allocator_get_mutex(apr_allocator_t *allocator ) 
{ apr_thread_mutex_t *tmp ;

  {
  tmp = apr_allocator_mutex_get(allocator);
  return (tmp);
}
}
void apr_allocator_set_mutex(apr_allocator_t *allocator , apr_thread_mutex_t *mutex ) 
{ 

  {
  apr_allocator_mutex_set(allocator, mutex);
  return;
}
}
#pragma merger(0,"/tmp/cil-1aKzDO1b.i","-g -pthread")
void apr_atomic_set(apr_uint32_t volatile   *mem , apr_uint32_t val ) ;
void apr_atomic_add(apr_uint32_t volatile   *mem , apr_uint32_t val ) ;
void apr_atomic_inc(apr_uint32_t volatile   *mem ) ;
int apr_atomic_dec(apr_uint32_t volatile   *mem ) ;
apr_uint32_t apr_atomic_cas(apr_uint32_t volatile   *mem , long with , long cmp ) ;
static apr_thread_mutex_t **hash_mutex  ;
apr_status_t apr_atomic_init(apr_pool_t *p ) 
{ int i ;
  apr_status_t rv ;

  {
  hash_mutex = (apr_thread_mutex_t **)apr_palloc(p, sizeof(apr_thread_mutex_t *) *
                                                    7U);
  i = 0;
  while (i < 7) {
    rv = apr_thread_mutex_create(hash_mutex + i, 0U, p);
    if (rv != 0) {
      return (rv);
    }
    i ++;
  }
  return (0);
}
}
void apr_atomic_add(apr_uint32_t volatile   *mem , apr_uint32_t val ) 
{ apr_thread_mutex_t *lock ;
  apr_uint32_t prev ;
  apr_status_t tmp ;

  {
  lock = (*(hash_mutex + (unsigned int )(((unsigned long )mem >> 2) % 7UL)));
  tmp = apr_thread_mutex_lock(lock);
  if (tmp == 0) {
    prev = (*mem);
    (*mem) += (apr_uint32_t volatile   )val;
    apr_thread_mutex_unlock(lock);
  }
  return;
}
}
void apr_atomic_set(apr_uint32_t volatile   *mem , apr_uint32_t val ) 
{ apr_thread_mutex_t *lock ;
  apr_uint32_t prev ;
  apr_status_t tmp ;

  {
  lock = (*(hash_mutex + (unsigned int )(((unsigned long )mem >> 2) % 7UL)));
  tmp = apr_thread_mutex_lock(lock);
  if (tmp == 0) {
    prev = (*mem);
    (*mem) = val;
    apr_thread_mutex_unlock(lock);
  }
  return;
}
}
void apr_atomic_inc(apr_uint32_t volatile   *mem ) 
{ apr_thread_mutex_t *lock ;
  apr_uint32_t prev ;
  apr_status_t tmp ;

  {
  lock = (*(hash_mutex + (unsigned int )(((unsigned long )mem >> 2) % 7UL)));
  tmp = apr_thread_mutex_lock(lock);
  if (tmp == 0) {
    prev = (*mem);
    (*mem) ++;
    apr_thread_mutex_unlock(lock);
  }
  return;
}
}
int apr_atomic_dec(apr_uint32_t volatile   *mem ) 
{ apr_thread_mutex_t *lock ;
  apr_uint32_t new ;
  apr_status_t tmp ;

  {
  lock = (*(hash_mutex + (unsigned int )(((unsigned long )mem >> 2) % 7UL)));
  tmp = apr_thread_mutex_lock(lock);
  if (tmp == 0) {
    (*mem) --;
    new = (*mem);
    apr_thread_mutex_unlock(lock);
    return ((int )new);
  }
  return ((int )(*mem));
}
}
apr_uint32_t apr_atomic_cas(apr_uint32_t volatile   *mem , long with , long cmp ) 
{ long prev ;
  apr_thread_mutex_t *lock ;
  apr_status_t tmp ;

  {
  lock = (*(hash_mutex + (unsigned int )(((unsigned long )mem >> 2) % 7UL)));
  tmp = apr_thread_mutex_lock(lock);
  if (tmp == 0) {
    prev = (*((long *)mem));
    if (prev == cmp) {
      (*((long *)mem)) = with;
    }
    apr_thread_mutex_unlock(lock);
    return ((unsigned int )prev);
  }
  return ((unsigned int )(*((long *)mem)));
}
}
#pragma merger(0,"/tmp/cil-1dybLzB5.i","-g -pthread")
apr_status_t apr_poll_setup(apr_pollfd_t **new , apr_int32_t num , apr_pool_t *cont ) 
{ void *tmp ;

  {
  tmp = apr_palloc(cont, sizeof(apr_pollfd_t ) * (unsigned int )(num + 1));
  (*new) = (apr_pollfd_t *)memset(tmp, 0, sizeof(apr_pollfd_t ) * (unsigned int )(num +
                                                                                  1));
  if ((unsigned int )(*new) == (unsigned int )((void *)0)) {
    return (12);
  }
  ((*new) + num)->desc_type = (enum __anonenum_apr_datatype_e_103 )3;
  ((*new) + 0)->p = cont;
  return (0);
}
}
static apr_pollfd_t *find_poll_sock(apr_pollfd_t *aprset , apr_socket_t *sock ) 
{ apr_pollfd_t *curr ;

  {
  curr = aprset;
  while ((unsigned int )curr->desc.s != (unsigned int )sock) {
    if ((int )curr->desc_type == 3) {
      return ((apr_pollfd_t *)((void *)0));
    }
    curr ++;
  }
  return (curr);
}
}
apr_status_t apr_poll_socket_add(apr_pollfd_t *aprset , apr_socket_t *sock , apr_int16_t event ) 
{ apr_pollfd_t *curr ;

  {
  curr = aprset;
  while ((int )curr->desc_type != 0) {
    if ((int )curr->desc_type == 3) {
      return (12);
    }
    curr ++;
  }
  curr->desc.s = sock;
  curr->desc_type = (enum __anonenum_apr_datatype_e_103 )1;
  curr->reqevents = event;
  return (0);
}
}
apr_status_t apr_poll_revents_get(apr_int16_t *event , apr_socket_t *sock , apr_pollfd_t *aprset ) 
{ apr_pollfd_t *curr ;
  apr_pollfd_t *tmp ;

  {
  tmp = find_poll_sock(aprset, sock);
  curr = tmp;
  if ((unsigned int )curr == (unsigned int )((void *)0)) {
    return (70015);
  }
  (*event) = curr->rtnevents;
  return (0);
}
}
apr_status_t apr_poll_socket_mask(apr_pollfd_t *aprset , apr_socket_t *sock , apr_int16_t events ) 
{ apr_pollfd_t *curr ;
  apr_pollfd_t *tmp ;

  {
  tmp = find_poll_sock(aprset, sock);
  curr = tmp;
  if ((unsigned int )curr == (unsigned int )((void *)0)) {
    return (70015);
  }
  if ((int )curr->reqevents & (int )events) {
    curr->reqevents = (short )((int )curr->reqevents ^ (int )events);
  }
  return (0);
}
}
apr_status_t apr_poll_socket_remove(apr_pollfd_t *aprset , apr_socket_t *sock ) 
{ apr_pollfd_t *match___0 ;
  apr_pollfd_t *curr ;

  {
  match___0 = (apr_pollfd_t *)((void *)0);
  curr = aprset;
  while (1) {
    if ((int )curr->desc_type != 3) {
      if (! ((int )curr->desc_type != 0)) {
        goto _L;
      }
    } else {
      _L: 
      break;
    }
    if ((unsigned int )curr->desc.s == (unsigned int )sock) {
      match___0 = curr;
    }
    curr ++;
  }
  if ((unsigned int )match___0 == (unsigned int )((void *)0)) {
    return (70015);
  }
  curr --;
  if ((unsigned int )curr != (unsigned int )match___0) {
    (*match___0) = (*curr);
  }
  curr->desc_type = (enum __anonenum_apr_datatype_e_103 )0;
  return (0);
}
}
apr_status_t apr_poll_socket_clear(apr_pollfd_t *aprset , apr_int16_t events ) 
{ apr_pollfd_t *curr ;

  {
  curr = aprset;
  while ((int )curr->desc_type != 3) {
    if ((int )curr->reqevents & (int )events) {
      curr->reqevents = (short )((int )curr->reqevents & ~ ((int )events));
    }
    curr ++;
  }
  return (0);
}
}
apr_status_t apr_socket_from_file(apr_socket_t **newsock , apr_file_t *file ) 
{ void *tmp ;

  {
  tmp = apr_palloc(file->pool, sizeof((*((*newsock)))));
  (*newsock) = (apr_socket_t *)memset(tmp, 0, sizeof((*((*newsock)))));
  ((*newsock))->socketdes = file->filedes;
  ((*newsock))->cntxt = file->pool;
  ((*newsock))->timeout = file->timeout;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-7eVy4TWc.i","-g -pthread")
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
static apr_int16_t get_event(apr_int16_t event ) 
{ apr_int16_t rv ;

  {
  rv = (short)0;
  if ((int )event & 1) {
    rv = (short )((int )rv | 1);
  }
  if ((int )event & 2) {
    rv = (short )((int )rv | 2);
  }
  if ((int )event & 4) {
    rv = (short )((int )rv | 4);
  }
  if ((int )event & 16) {
    rv = (short )((int )rv | 8);
  }
  if ((int )event & 32) {
    rv = (short )((int )rv | 16);
  }
  if ((int )event & 64) {
    rv = (short )((int )rv | 32);
  }
  return (rv);
}
}
static apr_int16_t get_revent(apr_int16_t event ) 
{ apr_int16_t rv ;

  {
  rv = (short)0;
  if ((int )event & 1) {
    rv = (short )((int )rv | 1);
  }
  if ((int )event & 2) {
    rv = (short )((int )rv | 2);
  }
  if ((int )event & 4) {
    rv = (short )((int )rv | 4);
  }
  if ((int )event & 8) {
    rv = (short )((int )rv | 16);
  }
  if ((int )event & 16) {
    rv = (short )((int )rv | 32);
  }
  if ((int )event & 32) {
    rv = (short )((int )rv | 64);
  }
  return (rv);
}
}
apr_status_t apr_poll(apr_pollfd_t *aprset , apr_int32_t num , apr_int32_t *nsds ,
                      apr_interval_time_t timeout ) 
{ int i ;
  int num_to_poll ;
  struct pollfd tmp_pollset[8] ;
  struct pollfd *pollset ;
  int *tmp ;

  {
  if (num <= 8) {
    pollset = tmp_pollset;
  } else {
    pollset = (struct pollfd *)malloc(sizeof(struct pollfd ) * (unsigned int )num);
    if (! pollset) {
      return (12);
    }
  }
  i = 0;
  while (i < num) {
    if ((int )(aprset + i)->desc_type == 1) {
      (pollset + i)->fd = ((aprset + i)->desc.s)->socketdes;
    } else {
      if ((int )(aprset + i)->desc_type == 2) {
        (pollset + i)->fd = ((aprset + i)->desc.f)->filedes;
      } else {
        break;
      }
    }
    (pollset + i)->events = get_event((aprset + i)->reqevents);
    i ++;
  }
  num_to_poll = i;
  if (timeout > 0LL) {
    timeout /= 1000LL;
  }
  i = poll(pollset, (unsigned long )num_to_poll, (int )timeout);
  (*nsds) = i;
  i = 0;
  while (i < num) {
    (aprset + i)->rtnevents = get_revent((pollset + i)->revents);
    i ++;
  }
  if ((*nsds) < 0) {
    tmp = __errno_location();
    return ((*tmp));
  }
  if ((*nsds) == 0) {
    return (70007);
  }
  return (0);
}
}
apr_status_t apr_pollset_create(apr_pollset_t **pollset , apr_uint32_t size , apr_pool_t *p ,
                                apr_uint32_t flags ) 
{ 

  {
  (*pollset) = (apr_pollset_t *)apr_palloc(p, sizeof((*((*pollset)))));
  ((*pollset))->nelts = 0U;
  ((*pollset))->nalloc = size;
  ((*pollset))->pollset = (struct pollfd *)apr_palloc(p, size * sizeof(struct pollfd ));
  ((*pollset))->query_set = (apr_pollfd_t *)apr_palloc(p, size * sizeof(apr_pollfd_t ));
  ((*pollset))->result_set = (apr_pollfd_t *)apr_palloc(p, size * sizeof(apr_pollfd_t ));
  ((*pollset))->pool = p;
  return (0);
}
}
apr_status_t apr_pollset_destroy(apr_pollset_t *pollset ) 
{ 

  {
  return (0);
}
}
apr_status_t apr_pollset_add(apr_pollset_t *pollset , apr_pollfd_t const   *descriptor ) 
{ 

  {
  if (pollset->nelts == pollset->nalloc) {
    return (12);
  }
  (*(pollset->query_set + pollset->nelts)) = (*descriptor);
  if ((int )descriptor->desc_type == 1) {
    (pollset->pollset + pollset->nelts)->fd = (descriptor->desc.s)->socketdes;
  } else {
    (pollset->pollset + pollset->nelts)->fd = (descriptor->desc.f)->filedes;
  }
  (pollset->pollset + pollset->nelts)->events = get_event(descriptor->reqevents);
  pollset->nelts ++;
  return (0);
}
}
apr_status_t apr_pollset_remove(apr_pollset_t *pollset , apr_pollfd_t const   *descriptor ) 
{ apr_uint32_t i ;
  apr_uint32_t dst ;
  apr_uint32_t old_nelts ;

  {
  i = 0U;
  while (i < pollset->nelts) {
    if ((unsigned int )descriptor->desc.s == (unsigned int )(pollset->query_set +
                                                             i)->desc.s) {
      dst = i;
      old_nelts = pollset->nelts;
      pollset->nelts --;
      i ++;
      while (i < old_nelts) {
        if ((unsigned int )descriptor->desc.s == (unsigned int )(pollset->query_set +
                                                                 i)->desc.s) {
          pollset->nelts --;
        } else {
          (*(pollset->pollset + dst)) = (*(pollset->pollset + i));
          (*(pollset->query_set + dst)) = (*(pollset->query_set + i));
          dst ++;
        }
        i ++;
      }
      return (0);
    }
    i ++;
  }
  return (70015);
}
}
apr_status_t apr_pollset_poll(apr_pollset_t *pollset , apr_interval_time_t timeout ,
                              apr_int32_t *num , apr_pollfd_t const   **descriptors ) 
{ int rv ;
  apr_uint32_t i ;
  apr_uint32_t j ;
  int *tmp ;

  {
  if (timeout > 0LL) {
    timeout /= 1000LL;
  }
  rv = poll(pollset->pollset, (unsigned long )pollset->nelts, (int )timeout);
  (*num) = rv;
  if (rv < 0) {
    tmp = __errno_location();
    return ((*tmp));
  }
  if (rv == 0) {
    return (70007);
  }
  j = 0U;
  i = 0U;
  while (i < pollset->nelts) {
    if ((int )(pollset->pollset + i)->revents != 0) {
      (*(pollset->result_set + j)) = (*(pollset->query_set + i));
      (pollset->result_set + j)->rtnevents = get_revent((pollset->pollset + i)->revents);
      j ++;
    }
    i ++;
  }
  (*descriptors) = (apr_pollfd_t const   *)pollset->result_set;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-bOzG2L1f.i","-g -pthread")
apr_status_t apr_wait_for_io_or_timeout(apr_file_t *f , apr_socket_t *s , int for_read ) 
{ apr_interval_time_t timeout ;
  apr_pollfd_t pollset ;
  int srv ;
  int n ;
  int type ;
  int tmp ;

  {
  if (for_read) {
    tmp = 1;
  } else {
    tmp = 4;
  }
  type = tmp;
  if (f) {
    pollset.desc_type = (enum __anonenum_apr_datatype_e_103 )2;
    pollset.desc.f = f;
    pollset.p = f->pool;
    timeout = f->timeout;
  } else {
    pollset.desc_type = (enum __anonenum_apr_datatype_e_103 )1;
    pollset.desc.s = s;
    pollset.p = s->cntxt;
    timeout = s->timeout;
  }
  pollset.reqevents = (short )type;
  while (1) {
    srv = apr_poll(& pollset, 1, & n, timeout);
    if (n == 1) {
      if ((int )pollset.rtnevents & type) {
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: ;
    }
    if (! (srv == 4)) {
      break;
    }
  }
  return (srv);
}
}
#pragma merger(0,"/tmp/cil-gnzlHdpP.i","-g -pthread")
extern void *dlopen(char const   *__file , int __mode ) ;
extern int dlclose(void *__handle ) ;
extern void *dlsym(void * __restrict  __handle , char const   * __restrict  __name ) ;
extern char *dlerror(void) ;
apr_status_t apr_os_dso_handle_put(apr_dso_handle_t **aprdso , apr_os_dso_handle_t osdso ,
                                   apr_pool_t *pool ) 
{ void *tmp ;

  {
  tmp = apr_palloc(pool, sizeof((*((*aprdso)))));
  (*aprdso) = (apr_dso_handle_t *)memset(tmp, 0, sizeof((*((*aprdso)))));
  ((*aprdso))->handle = osdso;
  ((*aprdso))->pool = pool;
  return (0);
}
}
apr_status_t apr_os_dso_handle_get(apr_os_dso_handle_t *osdso , apr_dso_handle_t *aprdso ) 
{ 

  {
  (*osdso) = aprdso->handle;
  return (0);
}
}
static apr_status_t dso_cleanup(void *thedso ) 
{ apr_dso_handle_t *dso ;
  int tmp ;

  {
  dso = (apr_dso_handle_t *)thedso;
  if ((unsigned int )dso->handle == (unsigned int )((void *)0)) {
    return (0);
  }
  tmp = dlclose(dso->handle);
  if (tmp != 0) {
    return (70022);
  }
  dso->handle = (void *)0;
  return (0);
}
}
apr_status_t apr_dso_load(apr_dso_handle_t **res_handle , char const   *path , apr_pool_t *pool ) 
{ int flags ;
  void *os_handle ;
  void *tmp ;

  {
  flags = 258;
  os_handle = dlopen(path, flags);
  tmp = apr_palloc(pool, sizeof((*((*res_handle)))));
  (*res_handle) = (apr_dso_handle_t *)memset(tmp, 0, sizeof((*((*res_handle)))));
  if ((unsigned int )os_handle == (unsigned int )((void *)0)) {
    ((*res_handle))->errormsg = dlerror();
    return (20019);
  }
  ((*res_handle))->handle = os_handle;
  ((*res_handle))->pool = pool;
  ((*res_handle))->errormsg = (char const   *)((void *)0);
  apr_pool_cleanup_register(pool, (void const   *)(*res_handle), & dso_cleanup, & apr_pool_cleanup_null);
  return (0);
}
}
apr_status_t apr_dso_unload(apr_dso_handle_t *handle ) 
{ apr_status_t tmp ;

  {
  tmp = apr_pool_cleanup_run(handle->pool, (void *)handle, & dso_cleanup);
  return (tmp);
}
}
apr_status_t apr_dso_sym(apr_dso_handle_sym_t *ressym , apr_dso_handle_t *handle ,
                         char const   *symname ) 
{ void *retval ;
  void *tmp ;

  {
  tmp = dlsym((void * __restrict  )handle->handle, (char const   * __restrict  )symname);
  retval = tmp;
  if ((unsigned int )retval == (unsigned int )((void *)0)) {
    handle->errormsg = dlerror();
    return (20026);
  }
  (*ressym) = retval;
  return (0);
}
}
char const   *apr_dso_error(apr_dso_handle_t *dso , char *buffer , apr_size_t buflen ) 
{ 

  {
  if (dso->errormsg) {
    apr_cpystrn(buffer, dso->errormsg, buflen);
    return (dso->errormsg);
  }
  return ("No Error");
}
}
