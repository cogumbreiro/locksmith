/* Generated by CIL v. 1.3.4 */
/* print_CIL_Input is true */

typedef int Ns_ServerInitProc(char *server );
typedef unsigned int size_t;
typedef long __time_t;
typedef __time_t time_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct sockaddr_in;
typedef uint16_t in_port_t;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[(int )(((sizeof(struct sockaddr ) - sizeof(unsigned short )) -
                                  sizeof(in_port_t )) - sizeof(struct in_addr ))] ;
};
typedef void *ClientData;
typedef long long Tcl_WideInt;
struct Tcl_Interp {
   char *result ;
   void (*freeProc)(char *blockPtr ) ;
   int errorLine ;
};
typedef struct Tcl_Interp Tcl_Interp;
struct Tcl_Encoding_;
typedef struct Tcl_Encoding_ *Tcl_Encoding;
struct Tcl_Obj;
typedef void Tcl_DupInternalRepProc(struct Tcl_Obj *srcPtr , struct Tcl_Obj *dupPtr );
typedef void Tcl_FreeInternalRepProc(struct Tcl_Obj *objPtr );
typedef void Tcl_FreeProc(char *blockPtr );
typedef int Tcl_SetFromAnyProc(Tcl_Interp *interp , struct Tcl_Obj *objPtr );
typedef void Tcl_UpdateStringProc(struct Tcl_Obj *objPtr );
struct Tcl_ObjType {
   char *name ;
   Tcl_FreeInternalRepProc *freeIntRepProc ;
   Tcl_DupInternalRepProc *dupIntRepProc ;
   Tcl_UpdateStringProc *updateStringProc ;
   Tcl_SetFromAnyProc *setFromAnyProc ;
};
typedef struct Tcl_ObjType Tcl_ObjType;
struct __anonstruct_twoPtrValue_37 {
   void *ptr1 ;
   void *ptr2 ;
};
union __anonunion_internalRep_36 {
   long longValue ;
   double doubleValue ;
   void *otherValuePtr ;
   Tcl_WideInt wideValue ;
   struct __anonstruct_twoPtrValue_37 twoPtrValue ;
};
struct Tcl_Obj {
   int refCount ;
   char *bytes ;
   int length ;
   Tcl_ObjType *typePtr ;
   union __anonunion_internalRep_36 internalRep ;
};
typedef struct Tcl_Obj Tcl_Obj;
struct Tcl_DString {
   char *string ;
   int length ;
   int spaceAvl ;
   char staticSpace[200] ;
};
typedef struct Tcl_DString Tcl_DString;
struct Tcl_HashKeyType;
typedef struct Tcl_HashKeyType Tcl_HashKeyType;
struct Tcl_HashTable;
typedef struct Tcl_HashTable Tcl_HashTable;
struct Tcl_HashEntry;
typedef struct Tcl_HashEntry Tcl_HashEntry;
typedef unsigned int Tcl_HashKeyProc(Tcl_HashTable *tablePtr , void *keyPtr );
typedef int Tcl_CompareHashKeysProc(void *keyPtr , Tcl_HashEntry *hPtr );
typedef Tcl_HashEntry *Tcl_AllocHashEntryProc(Tcl_HashTable *tablePtr , void *keyPtr );
typedef void Tcl_FreeHashEntryProc(Tcl_HashEntry *hPtr );
union __anonunion_key_38 {
   char *oneWordValue ;
   Tcl_Obj *objPtr ;
   int words[1] ;
   char string[4] ;
};
struct Tcl_HashEntry {
   Tcl_HashEntry *nextPtr ;
   Tcl_HashTable *tablePtr ;
   void *hash ;
   ClientData clientData ;
   union __anonunion_key_38 key ;
};
struct Tcl_HashKeyType {
   int version ;
   int flags ;
   Tcl_HashKeyProc *hashKeyProc ;
   Tcl_CompareHashKeysProc *compareKeysProc ;
   Tcl_AllocHashEntryProc *allocEntryProc ;
   Tcl_FreeHashEntryProc *freeEntryProc ;
};
struct Tcl_HashTable {
   Tcl_HashEntry **buckets ;
   Tcl_HashEntry *staticBuckets[4] ;
   int numBuckets ;
   int numEntries ;
   int rebuildSize ;
   int downShift ;
   int mask ;
   int keyType ;
   Tcl_HashEntry *(*findProc)(Tcl_HashTable *tablePtr , char *key ) ;
   Tcl_HashEntry *(*createProc)(Tcl_HashTable *tablePtr , char *key , int *newPtr ) ;
   Tcl_HashKeyType *typePtr ;
};
struct Ns_Thread_;
typedef struct Ns_Thread_ *Ns_Thread;
struct Ns_Mutex_;
typedef struct Ns_Mutex_ *Ns_Mutex;
struct Ns_Cond_;
typedef struct Ns_Cond_ *Ns_Cond;
struct Ns_Cs_;
typedef struct Ns_Cs_ *Ns_Cs;
struct Ns_RWLock_;
typedef struct Ns_RWLock_ *Ns_RWLock;
struct Ns_Time {
   time_t sec ;
   long usec ;
};
typedef struct Ns_Time Ns_Time;
enum __anonenum_Ns_HeaderCaseDisposition_68 {
    Preserve = 0,
    ToLower = 1,
    ToUpper = 2
};
typedef enum __anonenum_Ns_HeaderCaseDisposition_68 Ns_HeaderCaseDisposition;
typedef int Ns_RequestAuthorizeProc(char *server , char *method , char *url , char *user ,
                                    char *pass , char *peer );
struct Ns_SetField {
   char *name ;
   char *value ;
};
typedef struct Ns_SetField Ns_SetField;
struct Ns_Set {
   char *name ;
   int size ;
   int maxSize ;
   Ns_SetField *fields ;
};
typedef struct Ns_Set Ns_Set;
struct Ns_Request {
   char *line ;
   char *method ;
   char *protocol ;
   char *host ;
   unsigned short port ;
   char *url ;
   char *query ;
   int urlc ;
   char **urlv ;
   double version ;
};
typedef struct Ns_Request Ns_Request;
struct Ns_Conn {
   Ns_Request *request ;
   Ns_Set *headers ;
   Ns_Set *outputheaders ;
   char *authUser ;
   char *authPasswd ;
   int contentLength ;
   int flags ;
};
typedef struct Ns_Conn Ns_Conn;
struct Ns_Driver {
   void *arg ;
   char *server ;
   char *module ;
   char *name ;
   char *location ;
   char *address ;
   int sendwait ;
   int recvwait ;
   int bufsize ;
   int sndbuf ;
   int rcvbuf ;
};
typedef struct Ns_Driver Ns_Driver;
struct Ns_Sock {
   Ns_Driver *driver ;
   int sock ;
   void *arg ;
};
typedef struct Ns_Sock Ns_Sock;
enum __anonenum_Ns_DriverCmd_69 {
    DriverRecv = 0,
    DriverSend = 1,
    DriverKeep = 2,
    DriverClose = 3
};
typedef enum __anonenum_Ns_DriverCmd_69 Ns_DriverCmd;
typedef int Ns_DriverProc(Ns_DriverCmd cmd , Ns_Sock *sock , struct iovec *bufs ,
                          int nbufs );
typedef int Ns_UrlToFileProc(Tcl_DString *dsPtr , char *server , char *url );
typedef char *Ns_LocationProc(Ns_Conn *conn );
struct _Ns_Cache;
typedef struct _Ns_Cache *Ns_Cache;
typedef int bool;
struct Request {
   struct Request *nextPtr ;
   Ns_Request *request ;
   Ns_Set *headers ;
   char peer[16] ;
   int port ;
   char *next ;
   char *content ;
   int length ;
   int avail ;
   int leadblanks ;
   int woff ;
   int roff ;
   int coff ;
   Tcl_DString buffer ;
};
typedef struct Request Request;
struct NsServer;
struct Driver {
   void *arg ;
   char *server ;
   char *module ;
   char *name ;
   char *location ;
   char *address ;
   int sendwait ;
   int recvwait ;
   int bufsize ;
   int sndbuf ;
   int rcvbuf ;
   struct Driver *nextPtr ;
   struct NsServer *servPtr ;
   Ns_DriverProc *proc ;
   int opts ;
   int closewait ;
   int keepwait ;
   int sock ;
   int pidx ;
   char *bindaddr ;
   int port ;
   int backlog ;
   int maxinput ;
   unsigned int loggingFlags ;
};
struct Sock {
   struct Driver *drvPtr ;
   int sock ;
   void *arg ;
   struct Sock *nextPtr ;
   struct NsServer *servPtr ;
   char *location ;
   struct sockaddr_in sa ;
   int keep ;
   int pidx ;
   Ns_Time timeout ;
   Request *reqPtr ;
};
struct Conn {
   Ns_Request *request ;
   Ns_Set *headers ;
   Ns_Set *outputheaders ;
   char *authUser ;
   char *authPasswd ;
   int contentLength ;
   int flags ;
   struct Conn *prevPtr ;
   struct Conn *nextPtr ;
   struct Sock *sockPtr ;
   char *server ;
   char *location ;
   struct Request *reqPtr ;
   struct NsServer *servPtr ;
   struct Driver *drvPtr ;
   int id ;
   char idstr[16] ;
   Ns_Time startTime ;
   Tcl_Interp *interp ;
   Tcl_Encoding encoding ;
   Tcl_Encoding urlEncoding ;
   int nContentSent ;
   int responseStatus ;
   int responseLength ;
   int recursionCount ;
   Ns_Set *query ;
   Tcl_HashTable files ;
   Tcl_DString queued ;
   void *cls[16] ;
};
typedef struct Conn Conn;
struct __anonstruct_wait_87 {
   int num ;
   Conn *firstPtr ;
   Conn *lastPtr ;
};
struct __anonstruct_active_88 {
   Conn *firstPtr ;
   Conn *lastPtr ;
};
struct __anonstruct_queue_86 {
   Conn *freePtr ;
   struct __anonstruct_wait_87 wait ;
   struct __anonstruct_active_88 active ;
   Ns_Cond cond ;
};
struct __anonstruct_threads_89 {
   unsigned int nextid ;
   int min ;
   int max ;
   int current ;
   int idle ;
   int timeout ;
};
struct ConnPool {
   char *pool ;
   struct ConnPool *nextPtr ;
   struct NsServer *servPtr ;
   struct __anonstruct_queue_86 queue ;
   struct __anonstruct_threads_89 threads ;
};
typedef struct ConnPool ConnPool;
struct __anonstruct_pools_90 {
   Ns_Mutex lock ;
   int nextconnid ;
   bool shutdown ;
   ConnPool *firstPtr ;
   ConnPool *defaultPtr ;
   Ns_Thread joinThread ;
};
struct __anonstruct_opts_91 {
   bool aolpress ;
   bool flushcontent ;
   bool modsince ;
   bool noticedetail ;
   char *realm ;
   Ns_HeaderCaseDisposition hdrcase ;
};
struct __anonstruct_encoding_92 {
   char *outputCharset ;
   Tcl_Encoding outputEncoding ;
   bool hackContentTypeP ;
   char *urlCharset ;
   Tcl_Encoding urlEncoding ;
};
struct __anonstruct_limits_93 {
   int maxheaders ;
   int maxline ;
   int maxpost ;
   int sendfdmin ;
   int errorminsize ;
};
struct __anonstruct_fastpath_94 {
   char *pageroot ;
   char **dirv ;
   int dirc ;
   char *dirproc ;
   char *diradp ;
   bool mmap ;
   int cachemaxentry ;
   Ns_UrlToFileProc *url2file ;
   Ns_Cache *cache ;
};
struct __anonstruct_request_95 {
   Ns_RequestAuthorizeProc *authProc ;
   Tcl_HashTable redirect ;
   Tcl_HashTable proxy ;
   Ns_Mutex plock ;
};
struct Filter;
struct Trace;
struct __anonstruct_filter_96 {
   struct Filter *firstFilterPtr ;
   struct Trace *firstTracePtr ;
   struct Trace *firstCleanupPtr ;
};
struct __anonstruct_tcl_97 {
   char *library ;
   struct Trace *traces[4] ;
   char *initfile ;
   Ns_RWLock lock ;
   char *script ;
   int length ;
   int epoch ;
   Tcl_Obj *modules ;
};
struct __anonstruct_compress_99 {
   bool enable ;
   int level ;
   int minsize ;
};
struct __anonstruct_adp_98 {
   char *errorpage ;
   char *startpage ;
   bool enableexpire ;
   bool enabledebug ;
   char *debuginit ;
   char *defaultparser ;
   size_t cachesize ;
   Ns_Cond pagecond ;
   Ns_Mutex pagelock ;
   Tcl_HashTable pages ;
   Ns_RWLock taglock ;
   Tcl_HashTable tags ;
   struct __anonstruct_compress_99 compress ;
};
struct __anonstruct_sets_100 {
   Ns_Mutex lock ;
   Tcl_HashTable table ;
};
struct Bucket;
struct __anonstruct_nsv_101 {
   struct Bucket *buckets ;
   int nbuckets ;
};
struct __anonstruct_var_102 {
   Ns_Mutex lock ;
   Tcl_HashTable table ;
};
struct __anonstruct_share_103 {
   Ns_Cs cs ;
   Ns_Mutex lock ;
   Ns_Cond cond ;
   Tcl_HashTable inits ;
   Tcl_HashTable vars ;
};
struct __anonstruct_chans_104 {
   Ns_Mutex lock ;
   Tcl_HashTable table ;
};
struct NsServer {
   char *server ;
   Ns_LocationProc *locationProc ;
   struct __anonstruct_pools_90 pools ;
   struct __anonstruct_opts_91 opts ;
   struct __anonstruct_encoding_92 encoding ;
   struct __anonstruct_limits_93 limits ;
   struct __anonstruct_fastpath_94 fastpath ;
   struct __anonstruct_request_95 request ;
   struct __anonstruct_filter_96 filter ;
   struct __anonstruct_tcl_97 tcl ;
   struct __anonstruct_adp_98 adp ;
   struct __anonstruct_sets_100 sets ;
   struct __anonstruct_nsv_101 nsv ;
   struct __anonstruct_var_102 var ;
   struct __anonstruct_share_103 share ;
   struct __anonstruct_chans_104 chans ;
};
typedef struct NsServer NsServer;
struct Defer;
struct AtClose;
struct __anonstruct_nsconn_105 {
   int flags ;
   char form[16] ;
   char hdrs[16] ;
   char outhdrs[16] ;
};
struct __anonstruct_adp_106 {
   bool stream ;
   bool compress ;
   int exception ;
   int depth ;
   int objc ;
   Tcl_Obj **objv ;
   char *cwd ;
   int errorLevel ;
   int debugLevel ;
   int debugInit ;
   char *debugFile ;
   Ns_Cache *cache ;
   Tcl_DString *outputPtr ;
   Tcl_DString *responsePtr ;
   Tcl_DString *typePtr ;
};
struct NsInterp {
   struct NsInterp *nextPtr ;
   Tcl_Interp *interp ;
   NsServer *servPtr ;
   int delete ;
   int epoch ;
   struct Defer *firstDeferPtr ;
   struct AtClose *firstAtClosePtr ;
   Ns_Conn *conn ;
   struct __anonstruct_nsconn_105 nsconn ;
   struct __anonstruct_adp_106 adp ;
   Tcl_HashTable sets ;
   Tcl_HashTable chans ;
   Tcl_HashTable https ;
};
typedef struct NsInterp NsInterp;
typedef unsigned long long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef long __off_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef int __ssize_t;
typedef __ino_t ino_t;
typedef __dev_t dev_t;
typedef __off_t off_t;
typedef __ssize_t ssize_t;
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
struct stat;
struct Tcl_HashSearch {
   Tcl_HashTable *tablePtr ;
   int nextIndex ;
   Tcl_HashEntry *nextEntryPtr ;
};
typedef struct Tcl_HashSearch Tcl_HashSearch;
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
typedef void Ns_Callback(void *arg );
struct _Ns_Entry;
typedef struct _Ns_Entry *Ns_Entry;
struct FileKey {
   dev_t dev ;
   ino_t ino ;
};
typedef struct FileKey FileKey;
struct AdpCode {
   int nblocks ;
   int nscripts ;
   char *base ;
   int *len ;
};
typedef struct AdpCode AdpCode;
struct AdpParse {
   AdpCode code ;
   Tcl_DString hdr ;
   Tcl_DString text ;
};
typedef struct AdpParse AdpParse;
struct Page {
   NsServer *servPtr ;
   Tcl_HashEntry *hPtr ;
   time_t mtime ;
   off_t size ;
   int refcnt ;
   int evals ;
   char *file ;
   AdpCode code ;
};
typedef struct Page Page;
struct InterpPage {
   Page *pagePtr ;
   Tcl_Obj *objs[1] ;
};
typedef struct InterpPage InterpPage;
struct Frame {
   int objc ;
   Tcl_Obj **objv ;
   char *cwd ;
   Tcl_DString cwdBuf ;
   Tcl_DString *outputPtr ;
};
typedef struct Frame Frame;
typedef void Ns_AdpParserProc(Tcl_DString *outPtr , char *page );
struct __anonstruct_Tag_107 {
   int type ;
   char *tag ;
   char *endtag ;
   char *string ;
};
typedef struct __anonstruct_Tag_107 Tag;
typedef int Ns_UserAuthorizeProc(char *user , char *passwd );
typedef long long __off64_t;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[(int )(15U * sizeof(int ) - 2U * sizeof(void *))] ;
};
enum __anonenum_Ns_LogSeverity_67 {
    Notice = 0,
    Warning = 1,
    Error = 2,
    Fatal = 3,
    Bug = 4,
    Debug = 5,
    Dev = 6
};
typedef enum __anonenum_Ns_LogSeverity_67 Ns_LogSeverity;
typedef Tcl_HashSearch Ns_CacheSearch;
struct Cache;
struct Entry {
   struct Entry *nextPtr ;
   struct Entry *prevPtr ;
   struct Cache *cachePtr ;
   Tcl_HashEntry *hPtr ;
   Ns_Time mtime ;
   size_t size ;
   void *value ;
};
typedef struct Entry Entry;
struct Cache {
   Entry *firstEntryPtr ;
   Entry *lastEntryPtr ;
   Tcl_HashEntry *hPtr ;
   int keys ;
   time_t timeout ;
   int schedId ;
   int schedStop ;
   size_t maxSize ;
   size_t currentSize ;
   Ns_Callback *freeProc ;
   Ns_Mutex lock ;
   Ns_Cond cond ;
   unsigned int nhit ;
   unsigned int nmiss ;
   unsigned int nflush ;
   Tcl_HashTable entriesTable ;
   char name[1] ;
};
typedef struct Cache Cache;
typedef void Ns_ThreadProc(void *arg );
struct Callback {
   struct Callback *nextPtr ;
   Ns_Callback *proc ;
   void *arg ;
};
typedef struct Callback Callback;
struct _Ns_Cls;
typedef struct _Ns_Cls *Ns_Cls;
typedef unsigned char Byte;
typedef unsigned int uInt;
typedef unsigned long uLong;
typedef Byte Bytef;
typedef uLong uLongf;
typedef int __int32_t;
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct Tcl_Command_;
typedef struct Tcl_Command_ *Tcl_Command;
typedef void Tcl_CmdDeleteProc(ClientData clientData );
typedef int Tcl_CmdProc(ClientData clientData , Tcl_Interp *interp , int argc , char **argv );
typedef long long ns_int64;
struct __anonstruct_state_80 {
   Ns_Mutex lock ;
   Ns_Cond cond ;
   int started ;
   int stopping ;
};
struct __anonstruct_log_81 {
   char *file ;
   int flags ;
   int maxlevel ;
   int maxback ;
   int maxbuffer ;
   int flushint ;
};
struct __anonstruct_sched_82 {
   int maxelapsed ;
};
struct __anonstruct_keepalive_83 {
   bool enabled ;
   int timeout ;
   int maxkeep ;
   int npending ;
   int allmethods ;
};
struct __anonstruct_tcl_84 {
   char *sharedlibrary ;
   char *version ;
   bool lockoninit ;
};
struct __anonstruct_encoding_85 {
   char *outputCharset ;
   Tcl_Encoding outputEncoding ;
   bool hackContentTypeP ;
   char *urlCharset ;
   Tcl_Encoding urlEncoding ;
};
struct _nsconf {
   char *argv0 ;
   char *nsd ;
   char *name ;
   char *version ;
   char *home ;
   char *config ;
   char *build ;
   int pid ;
   time_t boot_t ;
   char hostname[255] ;
   char address[16] ;
   int shutdowntimeout ;
   int backlog ;
   Tcl_HashTable servertable ;
   Tcl_DString servers ;
   Tcl_HashTable sections ;
   struct __anonstruct_state_80 state ;
   struct __anonstruct_log_81 log ;
   struct __anonstruct_sched_82 sched ;
   struct __anonstruct_keepalive_83 keepalive ;
   struct __anonstruct_tcl_84 tcl ;
   struct __anonstruct_encoding_85 encoding ;
};
struct Tcl_Channel_;
typedef struct Tcl_Channel_ *Tcl_Channel;
struct FormFile {
   Ns_Set *hdrs ;
   off_t off ;
   off_t len ;
};
typedef struct FormFile FormFile;
struct Tcl_EncodingState_;
typedef struct Tcl_EncodingState_ *Tcl_EncodingState;
typedef struct Sock Sock;
struct sched {
   char C[28] ;
   char D[28] ;
   char KS[16][48] ;
   char E[48] ;
};
typedef unsigned char __uint8_t;
typedef unsigned int __socklen_t;
typedef __socklen_t socklen_t;
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
struct Value {
   time_t expires ;
   char value[1] ;
};
typedef struct Value Value;
typedef int GetProc(Tcl_DString *dsPtr , char *key );
union __anonunion___u_107 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
struct Ns_DriverInitData {
   int version ;
   char *name ;
   Ns_DriverProc *proc ;
   int opts ;
   void *arg ;
   char *path ;
};
typedef struct Ns_DriverInitData Ns_DriverInitData;
typedef unsigned long nfds_t;
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
typedef struct Driver Driver;
enum __anonenum_ReleaseReasons_107 {
    Reason_CloseTimeout = 0,
    Reason_ReadTimeout = 1,
    Reason_ServerReject = 2,
    Reason_SockError = 3,
    Reason_SockShutError = 4
};
typedef enum __anonenum_ReleaseReasons_107 ReleaseReasons;
struct ServerMap {
   NsServer *servPtr ;
   char location[1] ;
};
typedef struct ServerMap ServerMap;
typedef unsigned int __u_int;
typedef unsigned long __u_long;
typedef __u_int u_int;
typedef __u_long u_long;
typedef unsigned long long ns_uint64;
enum __anonenum_base_107 {
    OCT = 0,
    DEC = 1,
    HEX = 2
};
struct __anonstruct_builtinExt_107 {
   char *extension ;
   char *name ;
};
struct __anonstruct_builtinChar_108 {
   char *charset ;
   char *name ;
};
typedef int __pid_t;
union __anonunion___u_107___0 {
   int __in ;
   int __i ;
};
union __anonunion___u_108 {
   int __in ;
   int __i ;
};
union __anonunion___u_109 {
   int __in ;
   int __i ;
};
union __anonunion___u_110 {
   int __in ;
   int __i ;
};
union __anonunion___u_111 {
   int __in ;
   int __i ;
};
struct __anonstruct_File_107 {
   time_t mtime ;
   int size ;
   int refcnt ;
   char bytes[1] ;
};
typedef struct __anonstruct_File_107 File;
struct Tmp {
   struct Tmp *nextPtr ;
   int fd ;
};
typedef struct Tmp Tmp;
typedef void Ns_TraceProc(void *arg , Ns_Conn *conn );
typedef int Ns_FilterProc(void *arg , Ns_Conn *conn , int why );
struct Filter {
   struct Filter *nextPtr ;
   Ns_FilterProc *proc ;
   char *method ;
   char *url ;
   int when ;
   void *arg ;
};
typedef struct Filter Filter;
struct Trace {
   struct Trace *nextPtr ;
   Ns_TraceProc *proc ;
   void *arg ;
};
typedef struct Trace Trace;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
typedef int Ns_IndexCmpProc(void const   * , void const   * );
struct Ns_Index {
   void **el ;
   Ns_IndexCmpProc *CmpEls ;
   Ns_IndexCmpProc *CmpKeyWithEl ;
   int n ;
   int max ;
   int inc ;
};
typedef struct Ns_Index Ns_Index;
typedef void Ns_ThreadArgProc(Tcl_DString * , void *proc , void *arg );
enum __anonenum_opt_107 {
    IAddressIdx = 0,
    IArgv0Idx = 1,
    IBoottimeIdx = 2,
    IBuilddateIdx = 3,
    ICallbacksIdx = 4,
    IConfigIdx = 5,
    IHomeIdx = 6,
    hostINameIdx = 7,
    ILabelIdx = 8,
    ILocksIdx = 9,
    ILogIdx = 10,
    IMajorIdx = 11,
    IMinorIdx = 12,
    INameIdx = 13,
    INsdIdx = 14,
    IPageRootIdx = 15,
    IPatchLevelIdx = 16,
    IPidIdx = 17,
    IPlatformIdx = 18,
    IPoolsIdx = 19,
    IScheduledIdx = 20,
    IServerIdx = 21,
    IServersIdx = 22,
    sockICallbacksIdx = 23,
    ITagIdx = 24,
    ITclLibIdx = 25,
    IThreadsIdx = 26,
    IUptimeIdx = 27,
    IVersionIdx = 28,
    IWinntIdx = 29
};
typedef int Ns_SortProc(void * , void * );
typedef int Ns_EqualProc(void * , void * );
typedef void Ns_ElemVoidProc(void * );
typedef void *Ns_ElemValProc(void * );
typedef int Ns_ElemTestProc(void * );
struct Ns_List {
   void *first ;
   float weight ;
   struct Ns_List *rest ;
};
typedef struct Ns_List Ns_List;
typedef int Ns_SockProc(int sock , void *arg , int why );
struct ListenData {
   Ns_SockProc *proc ;
   void *arg ;
};
typedef struct ListenData ListenData;
struct Ns_Tls_;
typedef struct Ns_Tls_ *Ns_Tls;
typedef void Ns_TlsCleanup(void *arg );
typedef int Ns_LogFlushProc(char *msg , size_t len );
typedef int Ns_LogProc(Tcl_DString *dsPtr , Ns_LogSeverity severity , char *fmt ,
                       va_list ap );
struct Cache___0 {
   int hold ;
   int count ;
   time_t gtime ;
   time_t ltime ;
   char gbuf[100] ;
   char lbuf[100] ;
   Tcl_DString buffer ;
};
typedef struct Cache___0 Cache___0;
enum __anonenum_opt_107___0 {
    CHoldIdx = 0,
    CCountIdx = 1,
    CGetIdx = 2,
    CPeekIdx = 3,
    CFlushIdx = 4,
    CReleaseIdx = 5,
    CTruncIdx = 6
};
struct exttype {
   char *ext ;
   char *type ;
};
typedef int Ns_ModuleInitProc(char *server , char *module );
struct Module {
   struct Module *nextPtr ;
   char *name ;
   Ns_ModuleInitProc *proc ;
};
typedef struct Module Module;
typedef unsigned long __rlim_t;
typedef __gid_t gid_t;
typedef __uid_t uid_t;
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    RLIMIT_NPROC = 6,
    RLIMIT_MEMLOCK = 8,
    RLIMIT_LOCKS = 10,
    RLIMIT_NLIMITS = 11,
    RLIM_NLIMITS = 11
};
typedef __rlim_t rlim_t;
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
typedef enum __rlimit_resource __rlimit_resource_t;
typedef int Ns_OpProc(void *arg , Ns_Conn *conn );
struct __anonstruct_Req_107 {
   int refcnt ;
   Ns_OpProc *proc ;
   Ns_Callback *delete ;
   void *arg ;
   unsigned int flags ;
};
typedef struct __anonstruct_Req_107 Req;
typedef void Ns_SchedProc(void *arg , int id );
typedef void Ns_ArgProc(Tcl_DString *dsPtr , void *arg );
struct Info {
   Ns_ArgProc *proc ;
   char *desc ;
};
typedef struct Info Info;
struct proc {
   void *procAddr ;
   char *desc ;
   Ns_ArgProc *argProc ;
};
struct __anonstruct_Arg_107 {
   ConnPool *poolPtr ;
   Conn *connPtr ;
};
typedef struct __anonstruct_Arg_107 Arg;
enum __anonenum_opt_108 {
    SActiveIdx = 0,
    SAllIdx = 1,
    SConnectionsIdx = 2,
    SKeepaliveIdx = 3,
    SPoolsIdx = 4,
    SQueuedIdx = 5,
    SThreadsIdx = 6,
    SWaitingIdx = 7
};
typedef long __suseconds_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef long __fd_mask;
struct __anonstruct_fd_set_3 {
   __fd_mask fds_bits[(int )(1024U / (8U * sizeof(__fd_mask )))] ;
};
typedef struct __anonstruct_fd_set_3 fd_set;
struct Ns_Sema_;
typedef struct Ns_Sema_ *Ns_Sema;
struct __anonstruct_reasons_107 {
   int status ;
   char *reason ;
};
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream;
typedef struct __dirstream DIR;
struct File {
   time_t mtime ;
   char name[4] ;
};
typedef struct File File___0;
struct Event {
   struct Event *nextPtr ;
   Tcl_HashEntry *hPtr ;
   unsigned int id ;
   int qid ;
   time_t nextqueue ;
   time_t lastqueue ;
   time_t laststart ;
   time_t lastend ;
   int flags ;
   int interval ;
   Ns_SchedProc *proc ;
   void *arg ;
   Ns_SchedProc *deleteProc ;
};
typedef struct Event Event;
union __anonunion___u_107___1 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
struct Callback___0 {
   struct Callback___0 *nextPtr ;
   int sock ;
   int idx ;
   int when ;
   Ns_SockProc *proc ;
   void *arg ;
};
typedef struct Callback___0 Callback___0;
struct AtClose {
   struct AtClose *nextPtr ;
   char script[1] ;
};
typedef struct AtClose AtClose;
typedef int Tcl_ObjCmdProc(ClientData clientData , Tcl_Interp *interp , int objc ,
                           struct Tcl_Obj **objv );
struct Cmd {
   char *name ;
   Tcl_CmdProc *proc ;
   Tcl_ObjCmdProc *objProc ;
};
typedef struct Cmd Cmd;
struct utimbuf;
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
enum __anonenum_opt_107___1 {
    CCleanupIdx = 0,
    CListIdx = 1,
    CCreateIdx = 2,
    CPutIdx = 3,
    CGetIdx___0 = 4
};
struct __anonstruct_Http_107 {
   int sock ;
   int state ;
   char *next ;
   size_t len ;
   Ns_Time stime ;
   Ns_Time etime ;
   Tcl_DString ds ;
};
typedef struct __anonstruct_Http_107 Http;
enum __anonenum_opt_108___0 {
    HCancelIdx = 0,
    HCleanupIdx = 1,
    HQueueIdx = 2,
    HWaitIdx = 3
};
typedef void Tcl_InterpDeleteProc(ClientData clientData , Tcl_Interp *interp );
typedef int Ns_TclInterpInitProc(Tcl_Interp *interp , void *arg );
typedef int Ns_TclTraceProc(Tcl_Interp *interp , void *arg );
typedef void Ns_TclDeferProc(Tcl_Interp *interp , void *arg );
struct Trace1 {
   struct Trace1 *nextPtr ;
   Ns_TclInterpInitProc *proc ;
   void *arg ;
};
typedef struct Trace1 Trace___0;
struct Defer {
   struct Defer *nextPtr ;
   Ns_TclDeferProc *proc ;
   void *arg ;
};
typedef struct Defer Defer;
enum __anonenum_opt_107___2 {
    IAddModuleIdx = 0,
    ICleanupIdx = 1,
    IEpochIdx = 2,
    IGetIdx = 3,
    IGetModulesIdx = 4,
    ISaveIdx = 5,
    IUpdateIdx = 6,
    IOnCreateIdx = 7,
    IOnCleanupIdx = 8,
    IOnInitIdx = 9,
    IOnDeleteIdx = 10
};
enum JobStates {
    JOB_SCHEDULED = 0,
    JOB_RUNNING = 1,
    JOB_DONE = 2
};
typedef enum JobStates JobStates;
enum JobTypes {
    JOB_NON_DETACHED = 0,
    JOB_DETACHED = 1
};
typedef enum JobTypes JobTypes;
enum JobRequests {
    JOB_NONE = 0,
    JOB_WAIT = 1,
    JOB_CANCEL = 2
};
typedef enum JobRequests JobRequests;
enum QueueRequests {
    QUEUE_REQ_NONE = 0,
    QUEUE_REQ_DELETE = 1
};
typedef enum QueueRequests QueueRequests;
enum ThreadPoolRequests {
    THREADPOOL_REQ_NONE = 0,
    THREADPOOL_REQ_STOP = 1
};
typedef enum ThreadPoolRequests ThreadPoolRequests;
struct Job {
   struct Job *nextPtr ;
   char *server ;
   JobStates state ;
   int code ;
   JobTypes type ;
   JobRequests req ;
   char *errorCode ;
   char *errorInfo ;
   char *queueId ;
   Tcl_DString id ;
   Tcl_DString script ;
   Tcl_DString results ;
   Ns_Time startTime ;
   Ns_Time endTime ;
};
typedef struct Job Job;
struct Queue {
   char *name ;
   char *desc ;
   Ns_Mutex lock ;
   Ns_Cond cond ;
   unsigned int nextid ;
   QueueRequests req ;
   int maxThreads ;
   int nRunning ;
   Tcl_HashTable jobs ;
   int refCount ;
};
typedef struct Queue Queue___0;
struct ThreadPool {
   Ns_Cond cond ;
   Ns_Mutex queuelock ;
   Tcl_HashTable queues ;
   ThreadPoolRequests req ;
   int nextThreadId ;
   unsigned long nextQueueId ;
   int maxThreads ;
   int nthreads ;
   int nidle ;
   Job *firstPtr ;
};
typedef struct ThreadPool ThreadPool;
enum __anonenum_opt_107___3 {
    JCancelIdx = 0,
    JCreateIdx = 1,
    JDeleteIdx = 2,
    JGenIDIdx = 3,
    JJobsIdx = 4,
    JJobsListIdx = 5,
    JThreadListIdx = 6,
    JQueueIdx = 7,
    JQueuesIdx = 8,
    JQueueListIdx = 9,
    JWaitIdx = 10,
    JWaitAnyIdx = 11
};
enum __anonenum_opt_107___4 {
    TAdjustIdx = 0,
    TDiffIdx = 1,
    TGetIdx = 2,
    TIncrIdx = 3,
    TMakeIdx = 4,
    TSecondsIdx = 5,
    TMicroSecondsIdx = 6
};
struct __anonstruct_Proc_107 {
   char *name ;
   char *args ;
   int nargs ;
};
typedef struct __anonstruct_Proc_107 Proc;
typedef void *AtProc(Ns_Callback * , void * );
struct __anonstruct_Callback_107 {
   char *server ;
   char *script ;
};
typedef struct __anonstruct_Callback_107 Callback___1;
typedef char *Tcl_VarTraceProc(ClientData clientData , Tcl_Interp *interp , char *part1 ,
                               char *part2 , int flags );
struct NsShareVar {
   Ns_Cs lock ;
   int shareCount ;
   int flags ;
   Tcl_Obj *objPtr ;
   Tcl_HashTable array ;
};
typedef struct NsShareVar NsShareVar;
struct Callback___1 {
   char *server ;
   Tcl_Channel chan ;
   int when ;
   char script[1] ;
};
typedef struct Callback___1 Callback___2;
struct ListenCallback {
   char *server ;
   char script[1] ;
};
typedef struct ListenCallback ListenCallback___0;
struct Ns_Event_;
typedef struct Ns_Event_ *Ns_Event;
struct ThreadArg {
   int detached ;
   char *server ;
   char script[1] ;
};
typedef struct ThreadArg ThreadArg;
enum __anonenum_opt_107___5 {
    MCreateIdx = 0,
    MDestroyIdx = 1,
    MLockIdx = 2,
    MUnlockIdx = 3
};
enum __anonenum_opt_108___1 {
    CCreateIdx___0 = 0,
    CDestroyIdx = 1,
    CEnterIdx = 2,
    CLeaveIdx = 3
};
enum __anonenum_opt_109 {
    SCreateIdx = 0,
    SDestroyIdx = 1,
    SReleaseIdx = 2,
    SWaitIdx = 3
};
enum __anonenum_opt_110 {
    EAbsWaitIdx = 0,
    EBroadcastIdx = 1,
    ECreateIdx = 2,
    EDestroyIdx = 3,
    ESetIdx = 4,
    ESignalIdx = 5,
    ETimedWaitIdx = 6,
    EWaitIdx = 7
};
enum __anonenum_opt_111 {
    RCreateIdx = 0,
    RDestroyIdx = 1,
    RReadLockIdx = 2,
    RReadUnlockIdx = 3,
    RWriteLockIdx = 4,
    RWriteUnlockIdx = 5,
    RUnlockIdx = 6
};
struct Bucket {
   Ns_Mutex lock ;
   Tcl_HashTable arrays ;
};
typedef struct Bucket Bucket;
struct Array {
   Bucket *bucketPtr ;
   Tcl_HashEntry *entryPtr ;
   Tcl_HashTable vars ;
};
typedef struct Array Array;
enum __anonenum_opt_107___6 {
    VExistsIdx = 0,
    VGetIdx = 1,
    VListIdx = 2,
    VSetIdx = 3,
    VUnsetIdx = 4
};
struct fieldInfo_t {
   int argc ;
   char **argv ;
   int foundIdx ;
   char *valuePtr ;
   int valueSize ;
};
typedef struct fieldInfo_t fieldInfo_t;
struct __anonstruct___sigset_t_2 {
   unsigned long __val[(int )(1024U / (8U * sizeof(unsigned long )))] ;
};
typedef struct __anonstruct___sigset_t_2 __sigset_t;
typedef __sigset_t sigset_t;
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
struct __anonstruct_enc_107 {
   int hex ;
   int len ;
   char *str ;
};
struct Stream {
   int sock ;
   int error ;
   int cnt ;
   char *ptr ;
   char buf[2049] ;
};
typedef struct Stream Stream;
struct __anonstruct_Node_107 {
   int id ;
   void *dataInherit ;
   void *dataNoInherit ;
   void (*deletefuncInherit)(void * ) ;
   void (*deletefuncNoInherit)(void * ) ;
};
typedef struct __anonstruct_Node_107 Node;
struct __anonstruct_Trie_108 {
   Ns_Index branches ;
   Ns_Index *indexnode ;
};
typedef struct __anonstruct_Trie_108 Trie;
struct __anonstruct_Branch_109 {
   char *word ;
   Trie node ;
};
typedef struct __anonstruct_Branch_109 Branch;
struct __anonstruct_Channel_110 {
   char *filter ;
   Trie trie ;
};
typedef struct __anonstruct_Channel_110 Channel;
struct __anonstruct_Junction_111 {
   Ns_Index byname ;
   Ns_Index byuse ;
};
typedef struct __anonstruct_Junction_111 Junction;
union __anonunion___u_55 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
struct Mutex {
   void *lock ;
   struct Mutex *nextPtr ;
   unsigned int id ;
   unsigned long nlock ;
   unsigned long nbusy ;
   char name[33] ;
};
typedef struct Mutex Mutex;
struct CsLock {
   Ns_Mutex mutex ;
   Ns_Cond cond ;
   int tid ;
   int count ;
};
typedef struct CsLock CsLock;
struct RwLock {
   Ns_Mutex mutex ;
   Ns_Cond rcond ;
   Ns_Cond wcond ;
   int nreaders ;
   int nwriters ;
   int lockcnt ;
};
typedef struct RwLock RwLock;
struct __anonstruct_rdbuf_55 {
   struct dirent ent ;
   char name[4097] ;
};
struct Tls {
   char nabuf[16] ;
   char *stbuf ;
   struct tm gtbuf ;
   struct tm ltbuf ;
   char ctbuf[27] ;
   char asbuf[27] ;
   struct __anonstruct_rdbuf_55 rdbuf ;
};
typedef struct Tls Tls;
union __anonunion_u_56 {
   unsigned long l ;
   unsigned char b[4] ;
};
struct __anonstruct_Sema_55 {
   Ns_Mutex lock ;
   Ns_Cond cond ;
   int count ;
};
typedef struct __anonstruct_Sema_55 Sema;
struct Thread {
   struct Thread *nextPtr ;
   time_t ctime ;
   int flags ;
   Ns_ThreadProc *proc ;
   void *arg ;
   int tid ;
   char name[33] ;
   char parent[33] ;
};
typedef struct Thread Thread;
typedef long __clock_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_32 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
struct __anonstruct__timer_33 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
struct __anonstruct__rt_34 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
struct __anonstruct__sigchld_35 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
struct __anonstruct__sigfault_36 {
   void *si_addr ;
};
struct __anonstruct__sigpoll_37 {
   long si_band ;
   int si_fd ;
};
union __anonunion__sifields_31 {
   int _pad[(int )(128U / sizeof(int ) - 3U)] ;
   struct __anonstruct__kill_32 _kill ;
   struct __anonstruct__timer_33 _timer ;
   struct __anonstruct__rt_34 _rt ;
   struct __anonstruct__sigchld_35 _sigchld ;
   struct __anonstruct__sigfault_36 _sigfault ;
   struct __anonstruct__sigpoll_37 _sigpoll ;
};
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_31 _sifields ;
};
typedef struct siginfo siginfo_t;
union __anonunion___sigaction_handler_49 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
struct sigaction {
   union __anonunion___sigaction_handler_49 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
struct Ns_Semaphore_;
typedef struct Ns_Semaphore_ *Ns_Semaphore;
struct Ns_CriticalSection_;
typedef struct Ns_CriticalSection_ *Ns_CriticalSection;
struct Ns_ThreadLocalStorage_;
typedef struct Ns_ThreadLocalStorage_ *Ns_ThreadLocalStorage;
struct Ns_Pool_;
typedef struct Ns_Pool_ *Ns_Pool;
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
typedef struct timezone * __restrict  __timezone_ptr_t;
struct __sched_param {
   int __sched_priority ;
};
struct _pthread_fastlock {
   long __status ;
   int __spinlock ;
};
struct _pthread_descr_struct;
typedef struct _pthread_descr_struct *_pthread_descr;
struct __pthread_attr_s {
   int __detachstate ;
   int __schedpolicy ;
   struct __sched_param __schedparam ;
   int __inheritsched ;
   int __scope ;
   size_t __guardsize ;
   int __stackaddr_set ;
   void *__stackaddr ;
   size_t __stacksize ;
};
typedef struct __pthread_attr_s pthread_attr_t;
typedef long long __pthread_cond_align_t;
struct __anonstruct_pthread_cond_t_4 {
   struct _pthread_fastlock __c_lock ;
   _pthread_descr __c_waiting ;
   char __padding[(int )(((48U - sizeof(struct _pthread_fastlock )) - sizeof(_pthread_descr )) -
                         sizeof(__pthread_cond_align_t ))] ;
   __pthread_cond_align_t __align ;
};
typedef struct __anonstruct_pthread_cond_t_4 pthread_cond_t;
struct __anonstruct_pthread_condattr_t_5 {
   int __dummy ;
};
typedef struct __anonstruct_pthread_condattr_t_5 pthread_condattr_t;
typedef unsigned int pthread_key_t;
struct __anonstruct_pthread_mutex_t_6 {
   int __m_reserved ;
   int __m_count ;
   _pthread_descr __m_owner ;
   int __m_kind ;
   struct _pthread_fastlock __m_lock ;
};
typedef struct __anonstruct_pthread_mutex_t_6 pthread_mutex_t;
struct __anonstruct_pthread_mutexattr_t_7 {
   int __mutexkind ;
};
typedef struct __anonstruct_pthread_mutexattr_t_7 pthread_mutexattr_t;
typedef unsigned long pthread_t;
union __anonunion___u_107___2 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
enum __anonenum_base_107___0 {
    OCT___0 = 0,
    DEC___0 = 1,
    HEX___0 = 2
};
struct __anonstruct_builtinExt_107___0 {
   char *extension ;
   char *name ;
};
struct __anonstruct_builtinChar_108___0 {
   char *charset ;
   char *name ;
};
union __anonunion___u_107___3 {
   int __in ;
   int __i ;
};
union __anonunion___u_108___0 {
   int __in ;
   int __i ;
};
union __anonunion___u_109___0 {
   int __in ;
   int __i ;
};
union __anonunion___u_110___0 {
   int __in ;
   int __i ;
};
union __anonunion___u_111___0 {
   int __in ;
   int __i ;
};
enum __anonenum_opt_107___7 {
    IAddressIdx___0 = 0,
    IArgv0Idx___0 = 1,
    IBoottimeIdx___0 = 2,
    IBuilddateIdx___0 = 3,
    ICallbacksIdx___0 = 4,
    IConfigIdx___0 = 5,
    IHomeIdx___0 = 6,
    hostINameIdx___0 = 7,
    ILabelIdx___0 = 8,
    ILocksIdx___0 = 9,
    ILogIdx___0 = 10,
    IMajorIdx___0 = 11,
    IMinorIdx___0 = 12,
    INameIdx___0 = 13,
    INsdIdx___0 = 14,
    IPageRootIdx___0 = 15,
    IPatchLevelIdx___0 = 16,
    IPidIdx___0 = 17,
    IPlatformIdx___0 = 18,
    IPoolsIdx___0 = 19,
    IScheduledIdx___0 = 20,
    IServerIdx___0 = 21,
    IServersIdx___0 = 22,
    sockICallbacksIdx___0 = 23,
    ITagIdx___0 = 24,
    ITclLibIdx___0 = 25,
    IThreadsIdx___0 = 26,
    IUptimeIdx___0 = 27,
    IVersionIdx___0 = 28,
    IWinntIdx___0 = 29
};
enum __anonenum_opt_107___8 {
    CHoldIdx___0 = 0,
    CCountIdx___0 = 1,
    CGetIdx___1 = 2,
    CPeekIdx___0 = 3,
    CFlushIdx___0 = 4,
    CReleaseIdx___0 = 5,
    CTruncIdx___0 = 6
};
enum __anonenum_opt_108___2 {
    SActiveIdx___0 = 0,
    SAllIdx___0 = 1,
    SConnectionsIdx___0 = 2,
    SKeepaliveIdx___0 = 3,
    SPoolsIdx___0 = 4,
    SQueuedIdx___0 = 5,
    SThreadsIdx___0 = 6,
    SWaitingIdx___0 = 7
};
struct __anonstruct_reasons_107___0 {
   int status ;
   char *reason ;
};
union __anonunion___u_107___4 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
enum __anonenum_opt_107___9 {
    CCleanupIdx___0 = 0,
    CListIdx___0 = 1,
    CCreateIdx___1 = 2,
    CPutIdx___0 = 3,
    CGetIdx___2 = 4
};
enum __anonenum_opt_108___3 {
    HCancelIdx___0 = 0,
    HCleanupIdx___0 = 1,
    HQueueIdx___0 = 2,
    HWaitIdx___0 = 3
};
enum __anonenum_opt_107___10 {
    IAddModuleIdx___0 = 0,
    ICleanupIdx___0 = 1,
    IEpochIdx___0 = 2,
    IGetIdx___0 = 3,
    IGetModulesIdx___0 = 4,
    ISaveIdx___0 = 5,
    IUpdateIdx___0 = 6,
    IOnCreateIdx___0 = 7,
    IOnCleanupIdx___0 = 8,
    IOnInitIdx___0 = 9,
    IOnDeleteIdx___0 = 10
};
enum __anonenum_opt_107___11 {
    JCancelIdx___0 = 0,
    JCreateIdx___0 = 1,
    JDeleteIdx___0 = 2,
    JGenIDIdx___0 = 3,
    JJobsIdx___0 = 4,
    JJobsListIdx___0 = 5,
    JThreadListIdx___0 = 6,
    JQueueIdx___0 = 7,
    JQueuesIdx___0 = 8,
    JQueueListIdx___0 = 9,
    JWaitIdx___0 = 10,
    JWaitAnyIdx___0 = 11
};
enum __anonenum_opt_107___12 {
    TAdjustIdx___0 = 0,
    TDiffIdx___0 = 1,
    TGetIdx___0 = 2,
    TIncrIdx___0 = 3,
    TMakeIdx___0 = 4,
    TSecondsIdx___0 = 5,
    TMicroSecondsIdx___0 = 6
};
enum __anonenum_opt_107___13 {
    MCreateIdx___0 = 0,
    MDestroyIdx___0 = 1,
    MLockIdx___0 = 2,
    MUnlockIdx___0 = 3
};
enum __anonenum_opt_108___4 {
    CCreateIdx___2 = 0,
    CDestroyIdx___0 = 1,
    CEnterIdx___0 = 2,
    CLeaveIdx___0 = 3
};
enum __anonenum_opt_109___0 {
    SCreateIdx___0 = 0,
    SDestroyIdx___0 = 1,
    SReleaseIdx___0 = 2,
    SWaitIdx___0 = 3
};
enum __anonenum_opt_110___0 {
    EAbsWaitIdx___0 = 0,
    EBroadcastIdx___0 = 1,
    ECreateIdx___0 = 2,
    EDestroyIdx___0 = 3,
    ESetIdx___0 = 4,
    ESignalIdx___0 = 5,
    ETimedWaitIdx___0 = 6,
    EWaitIdx___0 = 7
};
enum __anonenum_opt_111___0 {
    RCreateIdx___0 = 0,
    RDestroyIdx___0 = 1,
    RReadLockIdx___0 = 2,
    RReadUnlockIdx___0 = 3,
    RWriteLockIdx___0 = 4,
    RWriteUnlockIdx___0 = 5,
    RUnlockIdx___0 = 6
};
enum __anonenum_opt_107___14 {
    VExistsIdx___0 = 0,
    VGetIdx___0 = 1,
    VListIdx___0 = 2,
    VSetIdx___0 = 3,
    VUnsetIdx___0 = 4
};
int Ns_Main(int argc , char **argv , Ns_ServerInitProc *initProc ) ;
static int ServerInit(char *server ) ;
int main(int argc , char **argv ) 
{ int tmp ;

  {
  tmp = Ns_Main(argc, argv, & ServerInit);
  return (tmp);
}
}
static int ServerInit(char *server ) 
{ 

  {
  return (0);
}
}
extern int memcmp(void const   *__s1 , void const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
extern int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
extern size_t strlen(char const   *__s )  __attribute__((__pure__)) ;
extern int sprintf(char * __restrict  __s , char const   * __restrict  __format  , ...) ;
extern int Tcl_GetBooleanFromObj(Tcl_Interp *interp , Tcl_Obj *objPtr , int *boolPtr ) ;
extern int Tcl_GetIntFromObj(Tcl_Interp *interp , Tcl_Obj *objPtr , int *intPtr ) ;
extern char *Tcl_GetStringFromObj(Tcl_Obj *objPtr , int *lengthPtr ) ;
extern Tcl_Obj *Tcl_NewIntObj(int intValue ) ;
extern Tcl_Obj *Tcl_NewStringObj(char *bytes , int length ) ;
extern void Tcl_SetBooleanObj(Tcl_Obj *objPtr , int boolValue ) ;
extern void Tcl_SetListObj(Tcl_Obj *objPtr , int objc , Tcl_Obj **objv ) ;
extern void Tcl_AppendResult(Tcl_Interp *interp  , ...) ;
extern char *Tcl_DStringAppend(Tcl_DString *dsPtr , char *str , int length ) ;
extern void Tcl_DStringFree(Tcl_DString *dsPtr ) ;
extern void Tcl_DStringInit(Tcl_DString *dsPtr ) ;
extern void Tcl_DStringSetLength(Tcl_DString *dsPtr , int length ) ;
extern Tcl_Obj *Tcl_GetObjResult(Tcl_Interp *interp ) ;
extern Tcl_Obj *Tcl_ObjSetVar2(Tcl_Interp *interp , Tcl_Obj *part1Ptr , Tcl_Obj *part2Ptr ,
                               Tcl_Obj *newValuePtr , int flags ) ;
extern void Tcl_SetResult(Tcl_Interp *interp , char *str , Tcl_FreeProc *freeProc ) ;
extern void Tcl_SetObjResult(Tcl_Interp *interp , Tcl_Obj *resultObjPtr ) ;
extern void Tcl_WrongNumArgs(Tcl_Interp *interp , int objc , Tcl_Obj **objv , char *message ) ;
extern char *Tcl_GetString(Tcl_Obj *objPtr ) ;
void NsAdpSetMimeType(NsInterp *itPtr , char *type ) ;
void NsAdpFlush(NsInterp *itPtr ) ;
void NsAdpStream(NsInterp *itPtr ) ;
void NsAdpCompress(NsInterp *itPtr , int compress ) ;
int NsAdpDebug(NsInterp *itPtr , char *host , char *port , char *procs___0 ) ;
int NsAdpEval(NsInterp *itPtr , int objc , Tcl_Obj **objv , int safe , char *resvar ) ;
int NsAdpSource(NsInterp *itPtr , int objc , Tcl_Obj **objv , char *resvar ) ;
int NsAdpInclude(NsInterp *itPtr , char *file___1 , int objc , Tcl_Obj **objv ) ;
static int ReturnObjCmd(NsInterp *itPtr , int objc , Tcl_Obj **objv , int exception ) ;
static int EvalObjCmd(NsInterp *itPtr , int objc , Tcl_Obj **objv , int safe ) ;
static int IsValidAdpContext(NsInterp *itPtr ) ;
int NsTclAdpEvalObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = EvalObjCmd((NsInterp *)arg, objc, objv, 0);
  return (tmp);
}
}
int NsTclAdpSafeEvalObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = EvalObjCmd((NsInterp *)arg, objc, objv, 1);
  return (tmp);
}
}
static int EvalObjCmd(NsInterp *itPtr , int objc , Tcl_Obj **objv , int safe ) 
{ int tmp ;

  {
  if (objc < 2) {
    Tcl_WrongNumArgs(itPtr->interp, 1, objv, (char *)"page ?args ...?");
    return (1);
  }
  tmp = NsAdpEval(itPtr, objc - 1, objv + 1, safe, (char *)((void *)0));
  return (tmp);
}
}
int NsTclAdpIncludeObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ char *tmp ;
  int tmp___0 ;

  {
  if (objc < 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"file ?args ...?");
    return (1);
  }
  tmp = Tcl_GetString((*(objv + 1)));
  tmp___0 = NsAdpInclude((NsInterp *)arg, tmp, objc - 1, objv + 1);
  return (tmp___0);
}
}
int NsTclAdpParseObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int isfile ;
  int i ;
  int safe ;
  char *opt ;
  char *resvarname ;
  char *cwd___1 ;
  NsInterp *itPtr ;
  Tcl_DString tds ;
  bool lcl_bufs ;
  int ret_status ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___19 ;
  size_t tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___27 ;
  size_t tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___35 ;
  size_t tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___43 ;
  size_t tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___51 ;
  size_t tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;

  {
  resvarname = (char *)((void *)0);
  cwd___1 = (char *)((void *)0);
  itPtr = (NsInterp *)arg;
  lcl_bufs = 0;
  if (objc < 2) {
    badargs: 
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-file|-string? ?-savedresult varname? ?-cwd path? arg ?arg ...?");
    return (1);
  }
  safe = 0;
  isfile = safe;
  i = 1;
  while (i < objc) {
    opt = Tcl_GetString((*(objv + i)));
    if ((int )(*opt) == (int )(*"-global")) {
      if (0) {
        __s1_len___5 = strlen((char const   *)opt);
        __s2_len___5 = strlen("-global");
        if (! ((unsigned int )((void const   *)(opt + 1)) - (unsigned int )((void const   *)opt) ==
               1U)) {
          goto _L___17;
        } else {
          if (__s1_len___5 >= 4U) {
            _L___17: 
            if (! ((unsigned int )((void const   *)("-global" + 1)) - (unsigned int )((void const   *)"-global") ==
                   1U)) {
              tmp___54 = 1;
            } else {
              if (__s2_len___5 >= 4U) {
                tmp___54 = 1;
              } else {
                tmp___54 = 0;
              }
            }
          } else {
            tmp___54 = 0;
          }
        }
        if (tmp___54) {
          if (__s1_len___5 < __s2_len___5) {
            tmp___52 = __s1_len___5;
          } else {
            tmp___52 = __s2_len___5;
          }
          tmp___51 = memcmp((void const   *)((char const   *)opt), (void const   *)"-global",
                            tmp___52 + 1U);
        } else {
          tmp___53 = strcmp((char const   *)opt, "-global");
          tmp___51 = tmp___53;
        }
      } else {
        tmp___53 = strcmp((char const   *)opt, "-global");
        tmp___51 = tmp___53;
      }
      if (tmp___51 == 0) {
        Tcl_SetResult(interp, (char *)"option -global unsupported", (Tcl_FreeProc *)0);
        return (1);
      } else {
        goto _L___18;
      }
    } else {
      _L___18: 
      if ((int )(*opt) == (int )(*"-file")) {
        if (0) {
          __s1_len___4 = strlen((char const   *)opt);
          __s2_len___4 = strlen("-file");
          if (! ((unsigned int )((void const   *)(opt + 1)) - (unsigned int )((void const   *)opt) ==
                 1U)) {
            goto _L___14;
          } else {
            if (__s1_len___4 >= 4U) {
              _L___14: 
              if (! ((unsigned int )((void const   *)("-file" + 1)) - (unsigned int )((void const   *)"-file") ==
                     1U)) {
                tmp___46 = 1;
              } else {
                if (__s2_len___4 >= 4U) {
                  tmp___46 = 1;
                } else {
                  tmp___46 = 0;
                }
              }
            } else {
              tmp___46 = 0;
            }
          }
          if (tmp___46) {
            if (__s1_len___4 < __s2_len___4) {
              tmp___44 = __s1_len___4;
            } else {
              tmp___44 = __s2_len___4;
            }
            tmp___43 = memcmp((void const   *)((char const   *)opt), (void const   *)"-file",
                              tmp___44 + 1U);
          } else {
            tmp___45 = strcmp((char const   *)opt, "-file");
            tmp___43 = tmp___45;
          }
        } else {
          tmp___45 = strcmp((char const   *)opt, "-file");
          tmp___43 = tmp___45;
        }
        if (tmp___43 == 0) {
          isfile = 1;
        } else {
          goto _L___15;
        }
      } else {
        _L___15: 
        if ((int )(*opt) == (int )(*"-savedresult")) {
          if (0) {
            __s1_len___3 = strlen((char const   *)opt);
            __s2_len___3 = strlen("-savedresult");
            if (! ((unsigned int )((void const   *)(opt + 1)) - (unsigned int )((void const   *)opt) ==
                   1U)) {
              goto _L___11;
            } else {
              if (__s1_len___3 >= 4U) {
                _L___11: 
                if (! ((unsigned int )((void const   *)("-savedresult" + 1)) - (unsigned int )((void const   *)"-savedresult") ==
                       1U)) {
                  tmp___38 = 1;
                } else {
                  if (__s2_len___3 >= 4U) {
                    tmp___38 = 1;
                  } else {
                    tmp___38 = 0;
                  }
                }
              } else {
                tmp___38 = 0;
              }
            }
            if (tmp___38) {
              if (__s1_len___3 < __s2_len___3) {
                tmp___36 = __s1_len___3;
              } else {
                tmp___36 = __s2_len___3;
              }
              tmp___35 = memcmp((void const   *)((char const   *)opt), (void const   *)"-savedresult",
                                tmp___36 + 1U);
            } else {
              tmp___37 = strcmp((char const   *)opt, "-savedresult");
              tmp___35 = tmp___37;
            }
          } else {
            tmp___37 = strcmp((char const   *)opt, "-savedresult");
            tmp___35 = tmp___37;
          }
          if (tmp___35 == 0) {
            i ++;
            if (i < objc) {
              resvarname = Tcl_GetString((*(objv + i)));
            } else {
              goto badargs;
            }
          } else {
            goto _L___12;
          }
        } else {
          _L___12: 
          if ((int )(*opt) == (int )(*"-cwd")) {
            if (0) {
              __s1_len___2 = strlen((char const   *)opt);
              __s2_len___2 = strlen("-cwd");
              if (! ((unsigned int )((void const   *)(opt + 1)) - (unsigned int )((void const   *)opt) ==
                     1U)) {
                goto _L___8;
              } else {
                if (__s1_len___2 >= 4U) {
                  _L___8: 
                  if (! ((unsigned int )((void const   *)("-cwd" + 1)) - (unsigned int )((void const   *)"-cwd") ==
                         1U)) {
                    tmp___30 = 1;
                  } else {
                    if (__s2_len___2 >= 4U) {
                      tmp___30 = 1;
                    } else {
                      tmp___30 = 0;
                    }
                  }
                } else {
                  tmp___30 = 0;
                }
              }
              if (tmp___30) {
                if (__s1_len___2 < __s2_len___2) {
                  tmp___28 = __s1_len___2;
                } else {
                  tmp___28 = __s2_len___2;
                }
                tmp___27 = memcmp((void const   *)((char const   *)opt), (void const   *)"-cwd",
                                  tmp___28 + 1U);
              } else {
                tmp___29 = strcmp((char const   *)opt, "-cwd");
                tmp___27 = tmp___29;
              }
            } else {
              tmp___29 = strcmp((char const   *)opt, "-cwd");
              tmp___27 = tmp___29;
            }
            if (tmp___27 == 0) {
              i ++;
              if (i < objc) {
                cwd___1 = Tcl_GetString((*(objv + i)));
              } else {
                goto badargs;
              }
            } else {
              goto _L___9;
            }
          } else {
            _L___9: 
            if ((int )(*opt) == (int )(*"-safe")) {
              if (0) {
                __s1_len___1 = strlen((char const   *)opt);
                __s2_len___1 = strlen("-safe");
                if (! ((unsigned int )((void const   *)(opt + 1)) - (unsigned int )((void const   *)opt) ==
                       1U)) {
                  goto _L___5;
                } else {
                  if (__s1_len___1 >= 4U) {
                    _L___5: 
                    if (! ((unsigned int )((void const   *)("-safe" + 1)) - (unsigned int )((void const   *)"-safe") ==
                           1U)) {
                      tmp___22 = 1;
                    } else {
                      if (__s2_len___1 >= 4U) {
                        tmp___22 = 1;
                      } else {
                        tmp___22 = 0;
                      }
                    }
                  } else {
                    tmp___22 = 0;
                  }
                }
                if (tmp___22) {
                  if (__s1_len___1 < __s2_len___1) {
                    tmp___20 = __s1_len___1;
                  } else {
                    tmp___20 = __s2_len___1;
                  }
                  tmp___19 = memcmp((void const   *)((char const   *)opt), (void const   *)"-safe",
                                    tmp___20 + 1U);
                } else {
                  tmp___21 = strcmp((char const   *)opt, "-safe");
                  tmp___19 = tmp___21;
                }
              } else {
                tmp___21 = strcmp((char const   *)opt, "-safe");
                tmp___19 = tmp___21;
              }
              if (tmp___19 == 0) {
                safe = 1;
              } else {
                goto _L___6;
              }
            } else {
              _L___6: 
              if ((int )(*opt) == (int )(*"-string")) {
                if (0) {
                  __s1_len = strlen((char const   *)opt);
                  __s2_len = strlen("-string");
                  if (! ((unsigned int )((void const   *)(opt + 1)) - (unsigned int )((void const   *)opt) ==
                         1U)) {
                    goto _L___0;
                  } else {
                    if (__s1_len >= 4U) {
                      _L___0: 
                      if (! ((unsigned int )((void const   *)("-string" + 1)) - (unsigned int )((void const   *)"-string") ==
                             1U)) {
                        tmp___6 = 1;
                      } else {
                        if (__s2_len >= 4U) {
                          tmp___6 = 1;
                        } else {
                          tmp___6 = 0;
                        }
                      }
                    } else {
                      tmp___6 = 0;
                    }
                  }
                  if (tmp___6) {
                    if (__s1_len < __s2_len) {
                      tmp___4 = __s1_len;
                    } else {
                      tmp___4 = __s2_len;
                    }
                    tmp___3 = memcmp((void const   *)((char const   *)opt), (void const   *)"-string",
                                     tmp___4 + 1U);
                  } else {
                    tmp___5 = strcmp((char const   *)opt, "-string");
                    tmp___3 = tmp___5;
                  }
                } else {
                  tmp___5 = strcmp((char const   *)opt, "-string");
                  tmp___3 = tmp___5;
                }
                if (! (tmp___3 == 0)) {
                  goto _L___3;
                }
              } else {
                _L___3: 
                if ((int )(*opt) == (int )(*"-local")) {
                  if (0) {
                    __s1_len___0 = strlen((char const   *)opt);
                    __s2_len___0 = strlen("-local");
                    if (! ((unsigned int )((void const   *)(opt + 1)) - (unsigned int )((void const   *)opt) ==
                           1U)) {
                      goto _L___2;
                    } else {
                      if (__s1_len___0 >= 4U) {
                        _L___2: 
                        if (! ((unsigned int )((void const   *)("-local" + 1)) - (unsigned int )((void const   *)"-local") ==
                               1U)) {
                          tmp___14 = 1;
                        } else {
                          if (__s2_len___0 >= 4U) {
                            tmp___14 = 1;
                          } else {
                            tmp___14 = 0;
                          }
                        }
                      } else {
                        tmp___14 = 0;
                      }
                    }
                    if (tmp___14) {
                      if (__s1_len___0 < __s2_len___0) {
                        tmp___12 = __s1_len___0;
                      } else {
                        tmp___12 = __s2_len___0;
                      }
                      tmp___11 = memcmp((void const   *)((char const   *)opt), (void const   *)"-local",
                                        tmp___12 + 1U);
                    } else {
                      tmp___13 = strcmp((char const   *)opt, "-local");
                      tmp___11 = tmp___13;
                    }
                  } else {
                    tmp___13 = strcmp((char const   *)opt, "-local");
                    tmp___11 = tmp___13;
                  }
                  if (! (tmp___11 == 0)) {
                    break;
                  }
                } else {
                  break;
                }
              }
            }
          }
        }
      }
    }
    i ++;
  }
  if (objc == i) {
    goto badargs;
  }
  objc -= i;
  objv += i;
  if ((unsigned int )itPtr->adp.typePtr == (unsigned int )((void *)0)) {
    Tcl_DStringInit(& tds);
    itPtr->adp.typePtr = & tds;
    lcl_bufs = 1;
  }
  if ((unsigned int )cwd___1 != (unsigned int )((void *)0)) {
    itPtr->adp.cwd = cwd___1;
  }
  if (isfile) {
    ret_status = NsAdpSource((NsInterp *)arg, objc, objv, resvarname);
  } else {
    ret_status = NsAdpEval((NsInterp *)arg, objc, objv, safe, resvarname);
  }
  if (lcl_bufs) {
    itPtr->adp.responsePtr = (Tcl_DString *)((void *)0);
    itPtr->adp.typePtr = (Tcl_DString *)((void *)0);
    Tcl_DStringFree(& tds);
  }
  return (ret_status);
}
}
int NsTclAdpAppendObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  int i ;
  int len ;
  char *s ;
  int tmp ;

  {
  itPtr = (NsInterp *)arg;
  if (objc < 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"string ?string ...?");
    return (1);
  }
  tmp = IsValidAdpContext(itPtr);
  if (! tmp) {
    Tcl_AppendResult(interp, "This function cannot be used outside of an ADP", (void *)0);
    return (1);
  }
  i = 1;
  while (i < objc) {
    s = Tcl_GetStringFromObj((*(objv + i)), & len);
    Tcl_DStringAppend(itPtr->adp.outputPtr, s, len);
    i ++;
  }
  NsAdpFlush(itPtr);
  return (0);
}
}
int NsTclAdpPutsObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  char *s ;
  int len ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 2) {
    if (objc != 3) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-nonewline? string");
      return (1);
    }
  }
  if (objc == 3) {
    s = Tcl_GetString((*(objv + 1)));
    if ((int )(*s) == (int )(*"-nonewline")) {
      if (0) {
        __s1_len = strlen((char const   *)s);
        __s2_len = strlen("-nonewline");
        if (! ((unsigned int )((void const   *)(s + 1)) - (unsigned int )((void const   *)s) ==
               1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("-nonewline" + 1)) - (unsigned int )((void const   *)"-nonewline") ==
                   1U)) {
              tmp___6 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___6 = 1;
              } else {
                tmp___6 = 0;
              }
            }
          } else {
            tmp___6 = 0;
          }
        }
        if (tmp___6) {
          if (__s1_len < __s2_len) {
            tmp___4 = __s1_len;
          } else {
            tmp___4 = __s2_len;
          }
          tmp___3 = memcmp((void const   *)((char const   *)s), (void const   *)"-nonewline",
                           tmp___4 + 1U);
        } else {
          tmp___5 = strcmp((char const   *)s, "-nonewline");
          tmp___3 = tmp___5;
        }
      } else {
        tmp___5 = strcmp((char const   *)s, "-nonewline");
        tmp___3 = tmp___5;
      }
      if (! (tmp___3 == 0)) {
        Tcl_AppendResult(interp, "invalid flag \"", s, "\": expected -nonewline",
                         (void *)0);
        return (1);
      }
    } else {
      Tcl_AppendResult(interp, "invalid flag \"", s, "\": expected -nonewline", (void *)0);
      return (1);
    }
  }
  tmp___7 = IsValidAdpContext(itPtr);
  if (! tmp___7) {
    Tcl_AppendResult(interp, "This function cannot be used outside of an ADP", (void *)0);
    return (1);
  }
  s = Tcl_GetStringFromObj((*(objv + (objc - 1))), & len);
  Tcl_DStringAppend(itPtr->adp.outputPtr, s, len);
  if (objc == 2) {
    Tcl_DStringAppend(itPtr->adp.outputPtr, (char *)"\n", 1);
  }
  NsAdpFlush(itPtr);
  return (0);
}
}
int NsTclAdpDirObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 1) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)((void *)0));
    return (1);
  }
  if ((unsigned int )itPtr->adp.cwd != (unsigned int )((void *)0)) {
    if ((*(itPtr->adp.cwd))) {
      Tcl_SetResult(interp, itPtr->adp.cwd, (Tcl_FreeProc *)1);
    } else {
      Tcl_SetResult(interp, (char *)"/", (Tcl_FreeProc *)0);
    }
  } else {
    Tcl_SetResult(interp, (char *)"/", (Tcl_FreeProc *)0);
  }
  return (0);
}
}
int NsTclAdpReturnObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = ReturnObjCmd((NsInterp *)arg, objc, objv, 4);
  return (tmp);
}
}
int NsTclAdpBreakObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = ReturnObjCmd((NsInterp *)arg, objc, objv, 1);
  return (tmp);
}
}
int NsTclAdpAbortObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = ReturnObjCmd((NsInterp *)arg, objc, objv, 2);
  return (tmp);
}
}
static int ReturnObjCmd(NsInterp *itPtr , int objc , Tcl_Obj **objv , int exception ) 
{ 

  {
  if (objc != 1) {
    if (objc != 2) {
      Tcl_WrongNumArgs(itPtr->interp, 1, objv, (char *)"?retval?");
      return (1);
    }
  }
  itPtr->adp.exception = exception;
  if (objc == 2) {
    Tcl_SetObjResult(itPtr->interp, (*(objv + 1)));
  }
  return (1);
}
}
int NsTclAdpTellObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  int tmp ;
  Tcl_Obj *tmp___0 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 1) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)((void *)0));
    return (1);
  }
  tmp = IsValidAdpContext(itPtr);
  if (! tmp) {
    Tcl_AppendResult(interp, "This function cannot be used outside of an ADP", (void *)0);
    return (1);
  }
  tmp___0 = Tcl_NewIntObj((itPtr->adp.outputPtr)->length);
  Tcl_SetObjResult(interp, tmp___0);
  return (0);
}
}
int NsTclAdpTruncObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  int length ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 1) {
    if (objc != 2) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?length?");
      return (1);
    }
  }
  if (objc == 1) {
    length = 0;
  } else {
    tmp = Tcl_GetIntFromObj(interp, (*(objv + 1)), & length);
    if (tmp != 0) {
      return (1);
    }
    if (length < 0) {
      tmp___0 = Tcl_GetString((*(objv + 1)));
      Tcl_AppendResult(interp, "invalid length: ", tmp___0, (void *)0);
      return (1);
    }
  }
  tmp___1 = IsValidAdpContext(itPtr);
  if (! tmp___1) {
    Tcl_AppendResult(interp, "This function cannot be used outside of an ADP", (void *)0);
    return (1);
  }
  Tcl_DStringSetLength(itPtr->adp.outputPtr, length);
  return (0);
}
}
int NsTclAdpDumpObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  int tmp ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 1) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)((void *)0));
    return (1);
  }
  tmp = IsValidAdpContext(itPtr);
  if (! tmp) {
    Tcl_AppendResult(interp, "This function cannot be used outside of an ADP", (void *)0);
    return (1);
  }
  Tcl_SetResult(interp, (itPtr->adp.outputPtr)->string, (Tcl_FreeProc *)1);
  return (0);
}
}
int NsTclAdpArgcObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  Tcl_Obj *tmp ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 1) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)((void *)0));
    return (1);
  }
  tmp = Tcl_NewIntObj(itPtr->adp.objc);
  Tcl_SetObjResult(interp, tmp);
  return (0);
}
}
int NsTclAdpArgvObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  int i ;
  int tmp ;
  Tcl_Obj *tmp___0 ;
  int tmp___1 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 1) {
    if (objc != 2) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?index?");
      return (1);
    }
  }
  tmp = IsValidAdpContext(itPtr);
  if (! tmp) {
    Tcl_AppendResult(interp, "This function cannot be used outside of an ADP", (void *)0);
    return (1);
  }
  if (objc == 1) {
    tmp___0 = Tcl_GetObjResult(interp);
    Tcl_SetListObj(tmp___0, itPtr->adp.objc, itPtr->adp.objv);
  } else {
    tmp___1 = Tcl_GetIntFromObj(interp, (*(objv + 1)), & i);
    if (tmp___1 != 0) {
      return (1);
    }
    if (i + 1 <= itPtr->adp.objc) {
      Tcl_SetObjResult(interp, (*(itPtr->adp.objv + i)));
    }
  }
  return (0);
}
}
int NsTclAdpBindArgsObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  int i ;
  int tmp ;
  Tcl_Obj *tmp___0 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc < 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"varName ?varName ...?");
    return (1);
  }
  tmp = IsValidAdpContext(itPtr);
  if (! tmp) {
    Tcl_AppendResult(interp, "This function cannot be used outside of an ADP", (void *)0);
    return (1);
  }
  if (objc != itPtr->adp.objc) {
    Tcl_AppendResult(interp, "invalid #variables", (void *)0);
    return (1);
  }
  i = 1;
  while (i < objc) {
    tmp___0 = Tcl_ObjSetVar2(interp, (*(objv + i)), (Tcl_Obj *)((void *)0), (*(itPtr->adp.objv +
                                                                               i)),
                             512);
    if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
      return (1);
    }
    i ++;
  }
  return (0);
}
}
int NsTclAdpExceptionObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  char *exception ;
  int bool___0 ;
  Tcl_Obj *tmp ;
  Tcl_Obj *tmp___0 ;
  Tcl_Obj *tmp___1 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 1) {
    if (objc != 2) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?varName?");
      return (1);
    }
  }
  if (itPtr->adp.exception == 0) {
    bool___0 = 0;
  } else {
    bool___0 = 1;
  }
  tmp = Tcl_GetObjResult(interp);
  Tcl_SetBooleanObj(tmp, bool___0);
  if (objc == 2) {
    switch (itPtr->adp.exception) {
    case 0: 
    exception = (char *)"ok";
    break;
    case 1: 
    exception = (char *)"break";
    break;
    case 2: 
    exception = (char *)"abort";
    break;
    case 4: 
    exception = (char *)"return";
    break;
    default: 
    exception = (char *)"unknown";
    break;
    }
    tmp___0 = Tcl_NewStringObj(exception, -1);
    tmp___1 = Tcl_ObjSetVar2(interp, (*(objv + 1)), (Tcl_Obj *)((void *)0), tmp___0,
                             512);
    if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
      return (1);
    }
  }
  return (0);
}
}
int NsTclAdpStreamObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 1) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)((void *)0));
    return (1);
  }
  NsAdpStream(itPtr);
  return (0);
}
}
int NsTclAdpCompressObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  int compress ;
  int tmp ;

  {
  itPtr = (NsInterp *)arg;
  compress = 1;
  if (objc != 1) {
    if (objc != 2) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?boolean?");
      return (1);
    }
  }
  if (objc >= 2) {
    tmp = Tcl_GetBooleanFromObj(interp, (*(objv + 1)), & compress);
    if (tmp != 0) {
      return (1);
    }
  }
  NsAdpCompress(itPtr, compress);
  return (0);
}
}
int NsTclAdpDebugCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ NsInterp *itPtr ;
  char *host ;
  char *port ;
  char *procs___0 ;
  char buf[20] ;
  int tmp ;

  {
  itPtr = (NsInterp *)arg;
  if (argc > 4) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " ?procs? ?host? ?port?\"",
                     (void *)0);
    return (1);
  }
  if (argc > 1) {
    procs___0 = (*(argv + 1));
  } else {
    procs___0 = (char *)((void *)0);
  }
  if (argc > 2) {
    host = (*(argv + 2));
  } else {
    host = (char *)((void *)0);
  }
  if (argc > 3) {
    port = (*(argv + 3));
  } else {
    port = (char *)((void *)0);
  }
  tmp = NsAdpDebug(itPtr, host, port, procs___0);
  if (tmp != 0) {
    Tcl_SetResult(interp, (char *)"could not initialize debugger", (Tcl_FreeProc *)0);
    return (1);
  }
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", itPtr->adp.debugLevel);
  Tcl_SetResult(interp, buf, (Tcl_FreeProc *)1);
  return (0);
}
}
int NsTclAdpMimeTypeObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  char *tmp ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 1) {
    if (objc != 2) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?mimetype?");
      return (1);
    }
  }
  if ((unsigned int )itPtr->adp.typePtr != (unsigned int )((void *)0)) {
    if (objc == 2) {
      tmp = Tcl_GetString((*(objv + 1)));
      NsAdpSetMimeType(itPtr, tmp);
    }
    Tcl_SetResult(interp, (itPtr->adp.typePtr)->string, (Tcl_FreeProc *)1);
  }
  return (0);
}
}
static int IsValidAdpContext(NsInterp *itPtr ) 
{ 

  {
  return ((unsigned int )itPtr->adp.outputPtr != (unsigned int )((void *)0));
}
}
extern void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                    size_t __n ) ;
extern char *strcpy(char * __restrict  __dest , char const   * __restrict  __src ) ;
extern char *strrchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
extern __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern int unlink(char const   *__name ) ;
extern void TclFreeObj(Tcl_Obj *objPtr ) ;
extern void Tcl_AddErrorInfo(Tcl_Interp *interp , char *message ) ;
extern void Tcl_AppendElement(Tcl_Interp *interp , char *string ) ;
extern void Tcl_DeleteHashEntry(Tcl_HashEntry *entryPtr ) ;
extern char *Tcl_DStringAppendElement(Tcl_DString *dsPtr , char *string ) ;
extern void Tcl_DStringResult(Tcl_Interp *interp , Tcl_DString *dsPtr ) ;
extern Tcl_HashEntry *Tcl_FirstHashEntry(Tcl_HashTable *tablePtr , Tcl_HashSearch *searchPtr ) ;
extern char *Tcl_GetStringResult(Tcl_Interp *interp ) ;
extern int Tcl_LinkVar(Tcl_Interp *interp , char *varName , char *addr , int type ) ;
extern Tcl_HashEntry *Tcl_NextHashEntry(Tcl_HashSearch *searchPtr ) ;
extern char *Tcl_PosixError(Tcl_Interp *interp ) ;
extern int Tcl_StringMatch(char *str , char *pattern ) ;
extern int Tcl_EvalEx(Tcl_Interp *interp , char *script , int numBytes , int flags ) ;
extern int Tcl_EvalObjEx(Tcl_Interp *interp , Tcl_Obj *objPtr , int flags ) ;
extern char *Tcl_ExternalToUtfDString(Tcl_Encoding encoding , char *src , int srcLen ,
                                      Tcl_DString *dsPtr ) ;
extern Tcl_Obj *Tcl_GetVar2Ex(Tcl_Interp *interp , char *part1 , char *part2 , int flags ) ;
extern Tcl_Obj *Tcl_SetVar2Ex(Tcl_Interp *interp , char *part1 , char *part2 , Tcl_Obj *newValuePtr ,
                              int flags ) ;
extern int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
extern int __xstat(int __ver , char const   *__filename , struct stat *__stat_buf ) ;
__inline static int stat__extinline(char const   *__path , struct stat *__statbuf ) 
{ int tmp ;

  {
  tmp = __xstat(3, __path, __statbuf);
  return (tmp);
}
}
__inline static int fstat__extinline(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
  tmp = __fxstat(3, __fd, __statbuf);
  return (tmp);
}
}
extern int open(char const   *__file , int __oflag  , ...) ;
extern char *mktemp(char *__template ) ;
void *ns_malloc(size_t size ) ;
void *ns_calloc(size_t num , size_t esize ) ;
void ns_free(void *ptr ) ;
void *ns_realloc(void *ptr , size_t size ) ;
void Ns_MutexLock(Ns_Mutex *mutex ) ;
void Ns_MutexUnlock(Ns_Mutex *mutex ) ;
void Ns_CondBroadcast(Ns_Cond *cond___9 ) ;
void Ns_CondWait(Ns_Cond *cond___9 , Ns_Mutex *mutex ) ;
void Ns_ThreadYield(void) ;
Ns_Cache *Ns_CacheCreateSz(char *name , int keys , size_t maxSize , Ns_Callback *freeProc ) ;
Ns_Entry *Ns_CacheFindEntry(Ns_Cache *cache , char *key___1 ) ;
Ns_Entry *Ns_CacheCreateEntry(Ns_Cache *cache , char *key___1 , int *newPtr ) ;
void *Ns_CacheGetValue(Ns_Entry *entry ) ;
void Ns_CacheSetValueSz(Ns_Entry *entry , void *value , size_t size ) ;
void Ns_CacheUnsetValue(Ns_Entry *entry ) ;
void Ns_CacheFlushEntry(Ns_Entry *entry ) ;
Ns_Set *Ns_ConnGetQuery(Ns_Conn *conn ) ;
char *Ns_DStringVarAppend(Tcl_DString *dsPtr  , ...) ;
char *Ns_DStringPrintf(Tcl_DString *dsPtr , char *fmt  , ...) ;
Tcl_Encoding Ns_GetFileEncoding(char *file___1 ) ;
int Ns_PathIsAbsolute(char *path ) ;
char *Ns_NormalizePath(Tcl_DString *dsPtr , char *path ) ;
char *Ns_MakePath(Tcl_DString *dest  , ...) ;
int Ns_ConnReturnNotice(Ns_Conn *conn , int status , char *title , char *notice ) ;
char *Ns_SetIGet(Ns_Set *set , char *key___1 ) ;
char *Ns_TclLogError(Tcl_Interp *interp ) ;
void NsAdpParse(AdpParse *parsePtr , NsServer *servPtr , char *utf , int safe ) ;
static Page *ParseFile(NsInterp *itPtr , char *file___1 , struct stat *stPtr ) ;
static void PushFrame(NsInterp *itPtr , Frame *framePtr , char *file___1 , int objc ,
                      Tcl_Obj **objv , Tcl_DString *outputPtr ) ;
static void PopFrame(NsInterp *itPtr , Frame *framePtr ) ;
static void LogError(NsInterp *itPtr , int nscript ) ;
static int AdpRun(NsInterp *itPtr , char *file___1 , int objc , Tcl_Obj **objv , Tcl_DString *outputPtr ) ;
static int AdpEval(NsInterp *itPtr , AdpCode *codePtr , Tcl_Obj **objs ) ;
static void ParseFree(AdpParse *parsePtr ) ;
static int AdpDebug(NsInterp *itPtr , char *ptr , int len , int nscript ) ;
static void FreeInterpPage(void *arg ) ;
int NsAdpEval(NsInterp *itPtr , int objc , Tcl_Obj **objv , int safe , char *resvar ) 
{ AdpParse parse ;
  Frame frame ;
  Tcl_DString output ;
  int result ;
  Tcl_Obj *resPtr ;
  bool lcl_resp ;
  char *tmp ;
  Tcl_Obj *tmp___0 ;

  {
  lcl_resp = 0;
  Tcl_DStringInit(& output);
  if ((unsigned int )itPtr->adp.responsePtr == (unsigned int )((void *)0)) {
    itPtr->adp.responsePtr = & output;
    lcl_resp = 1;
  }
  PushFrame(itPtr, & frame, (char *)((void *)0), objc, objv, & output);
  tmp = Tcl_GetString((*(objv + 0)));
  NsAdpParse(& parse, itPtr->servPtr, tmp, safe);
  result = AdpEval(itPtr, & parse.code, (Tcl_Obj **)((void *)0));
  PopFrame(itPtr, & frame);
  if (lcl_resp) {
    itPtr->adp.responsePtr = (Tcl_DString *)((void *)0);
  }
  if (result == 0) {
    if ((unsigned int )resvar != (unsigned int )((void *)0)) {
      resPtr = Tcl_GetObjResult(itPtr->interp);
      tmp___0 = Tcl_SetVar2Ex(itPtr->interp, resvar, (char *)((void *)0), resPtr,
                              512);
      if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
        return (1);
      }
    }
    Tcl_SetResult(itPtr->interp, output.string, (Tcl_FreeProc *)1);
  }
  Tcl_DStringFree(& output);
  ParseFree(& parse);
  return (result);
}
}
int NsAdpSource(NsInterp *itPtr , int objc , Tcl_Obj **objv , char *resvar ) 
{ Tcl_DString output ;
  int code ;
  Tcl_Obj *resPtr ;
  bool lcl_resp ;
  char *tmp ;
  Tcl_Obj *tmp___0 ;

  {
  lcl_resp = 0;
  Tcl_DStringInit(& output);
  if ((unsigned int )itPtr->adp.responsePtr == (unsigned int )((void *)0)) {
    itPtr->adp.responsePtr = & output;
    lcl_resp = 1;
  }
  tmp = Tcl_GetString((*(objv + 0)));
  code = AdpRun(itPtr, tmp, objc, objv, & output);
  if (lcl_resp) {
    itPtr->adp.responsePtr = (Tcl_DString *)((void *)0);
  }
  if (code == 0) {
    if ((unsigned int )resvar != (unsigned int )((void *)0)) {
      resPtr = Tcl_GetObjResult(itPtr->interp);
      tmp___0 = Tcl_SetVar2Ex(itPtr->interp, resvar, (char *)((void *)0), resPtr,
                              512);
      if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
        return (1);
      }
    }
    Tcl_DStringResult(itPtr->interp, & output);
  }
  Tcl_DStringFree(& output);
  return (code);
}
}
int NsAdpInclude(NsInterp *itPtr , char *file___1 , int objc , Tcl_Obj **objv ) 
{ int tmp ;

  {
  if ((unsigned int )itPtr->adp.outputPtr == (unsigned int )((void *)0)) {
    Tcl_SetResult(itPtr->interp, (char *)"no connection", (Tcl_FreeProc *)0);
    return (1);
  }
  tmp = AdpRun(itPtr, file___1, objc, objv, itPtr->adp.outputPtr);
  return (tmp);
}
}
static int AdpRun(NsInterp *itPtr , char *file___1 , int objc , Tcl_Obj **objv , Tcl_DString *outputPtr ) 
{ NsServer *servPtr ;
  Tcl_Interp *interp ;
  Tcl_HashEntry *hPtr ;
  struct stat st ;
  Tcl_DString tmp ;
  Tcl_DString path ;
  Frame frame ;
  InterpPage *ipagePtr ;
  Page *pagePtr ;
  Page *oldPagePtr ;
  Ns_Entry *ePtr ;
  int new ;
  int n ;
  char *p ;
  char *key___1 ;
  FileKey ukey ;
  int status ;
  int tmp___0 ;
  Ns_Set *hdrs ;
  char *host ;
  char *port ;
  char *procs___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  servPtr = itPtr->servPtr;
  interp = itPtr->interp;
  ipagePtr = (InterpPage *)((void *)0);
  pagePtr = (Page *)((void *)0);
  status = 1;
  Tcl_DStringInit(& tmp);
  Tcl_DStringInit(& path);
  key___1 = (char *)(& ukey);
  tmp___0 = Ns_PathIsAbsolute(file___1);
  if (tmp___0) {
    Ns_NormalizePath(& path, file___1);
  } else {
    Ns_MakePath(& tmp, itPtr->adp.cwd, file___1, (void *)0);
    Ns_NormalizePath(& path, tmp.string);
    Tcl_DStringSetLength(& tmp, 0);
  }
  file___1 = path.string;
  if (itPtr->adp.debugLevel > 0) {
    itPtr->adp.debugLevel = itPtr->adp.debugLevel + 1;
  } else {
    if (servPtr->adp.enabledebug != 0) {
      if ((unsigned int )itPtr->adp.debugFile != (unsigned int )((void *)0)) {
        p = strrchr((char const   *)file___1, '/');
        if ((unsigned int )p != (unsigned int )((void *)0)) {
          tmp___3 = Tcl_StringMatch(p + 1, itPtr->adp.debugFile);
          if (tmp___3) {
            hdrs = Ns_ConnGetQuery(itPtr->conn);
            host = Ns_SetIGet(hdrs, (char *)"dhost");
            port = Ns_SetIGet(hdrs, (char *)"dport");
            procs___0 = Ns_SetIGet(hdrs, (char *)"dprocs");
            tmp___2 = NsAdpDebug(itPtr, host, port, procs___0);
            if (tmp___2 != 0) {
              tmp___1 = Tcl_GetStringResult(interp);
              Ns_ConnReturnNotice(itPtr->conn, 200, (char *)"Debug Init Failed", tmp___1);
              itPtr->adp.exception = 2;
              goto done;
            }
          }
        }
      }
    }
  }
  if ((unsigned int )itPtr->adp.cache == (unsigned int )((void *)0)) {
    Ns_DStringPrintf(& tmp, (char *)"nsadp:%s:%p", (itPtr->servPtr)->server, itPtr);
    itPtr->adp.cache = Ns_CacheCreateSz(tmp.string, (int )(sizeof(FileKey ) / sizeof(int )),
                                        (itPtr->servPtr)->adp.cachesize, & FreeInterpPage);
    Tcl_DStringSetLength(& tmp, 0);
  }
  tmp___5 = stat__extinline((char const   *)file___1, & st);
  if (tmp___5 != 0) {
    tmp___4 = Tcl_PosixError(interp);
    Tcl_AppendResult(interp, "could not stat \"", file___1, "\": ", tmp___4, (void *)0);
  } else {
    if (((st.st_mode & 61440U) == 32768U) == 0) {
      Tcl_AppendResult(interp, "not an ordinary file: ", file___1, (void *)0);
    } else {
      ukey.dev = st.st_dev;
      ukey.ino = st.st_ino;
      ePtr = Ns_CacheFindEntry(itPtr->adp.cache, key___1);
      if ((unsigned int )ePtr != (unsigned int )((void *)0)) {
        ipagePtr = (InterpPage *)Ns_CacheGetValue(ePtr);
        if ((ipagePtr->pagePtr)->mtime != st.st_mtim.tv_sec) {
          Ns_CacheFlushEntry(ePtr);
          ipagePtr = (InterpPage *)((void *)0);
        } else {
          if ((ipagePtr->pagePtr)->size != st.st_size) {
            Ns_CacheFlushEntry(ePtr);
            ipagePtr = (InterpPage *)((void *)0);
          }
        }
      }
      if ((unsigned int )ipagePtr == (unsigned int )((void *)0)) {
        Ns_MutexLock(& servPtr->adp.pagelock);
        hPtr = ((*(servPtr->adp.pages.createProc)))(& servPtr->adp.pages, key___1,
                                                    & new);
        while (1) {
          if (! new) {
            pagePtr = (Page *)hPtr->clientData;
            if (! ((unsigned int )pagePtr == (unsigned int )((void *)0))) {
              break;
            }
          } else {
            break;
          }
          Ns_CondWait(& servPtr->adp.pagecond, & servPtr->adp.pagelock);
          hPtr = ((*(servPtr->adp.pages.createProc)))(& servPtr->adp.pages, key___1,
                                                      & new);
        }
        if (! new) {
          if (pagePtr->mtime != st.st_mtim.tv_sec) {
            hPtr->clientData = (void *)0;
            pagePtr->hPtr = (Tcl_HashEntry *)((void *)0);
            new = 1;
          } else {
            if (pagePtr->size != st.st_size) {
              hPtr->clientData = (void *)0;
              pagePtr->hPtr = (Tcl_HashEntry *)((void *)0);
              new = 1;
            }
          }
        }
        if (new) {
          Ns_MutexUnlock(& servPtr->adp.pagelock);
          pagePtr = ParseFile(itPtr, file___1, & st);
          Ns_MutexLock(& servPtr->adp.pagelock);
          if ((unsigned int )pagePtr == (unsigned int )((void *)0)) {
            Tcl_DeleteHashEntry(hPtr);
          } else {
            if (ukey.dev != st.st_dev) {
              goto _L;
            } else {
              if (ukey.ino != st.st_ino) {
                _L: 
                Tcl_DeleteHashEntry(hPtr);
                ukey.dev = st.st_dev;
                ukey.ino = st.st_ino;
                hPtr = ((*(servPtr->adp.pages.createProc)))(& servPtr->adp.pages,
                                                            key___1, & new);
                if (! new) {
                  oldPagePtr = (Page *)hPtr->clientData;
                  oldPagePtr->hPtr = (Tcl_HashEntry *)((void *)0);
                }
              }
            }
            pagePtr->hPtr = hPtr;
            hPtr->clientData = (void *)pagePtr;
          }
          Ns_CondBroadcast(& servPtr->adp.pagecond);
        }
        if ((unsigned int )pagePtr != (unsigned int )((void *)0)) {
          pagePtr->refcnt ++;
        }
        Ns_MutexUnlock(& servPtr->adp.pagelock);
        if ((unsigned int )pagePtr != (unsigned int )((void *)0)) {
          n = (int )(sizeof(Tcl_Obj *) * (unsigned int )pagePtr->code.nscripts);
          ipagePtr = (InterpPage *)ns_calloc(1U, sizeof(InterpPage ) + (unsigned int )n);
          ipagePtr->pagePtr = pagePtr;
          ePtr = Ns_CacheCreateEntry(itPtr->adp.cache, key___1, & new);
          if (! new) {
            Ns_CacheUnsetValue(ePtr);
          }
          Ns_CacheSetValueSz(ePtr, (void *)ipagePtr, (unsigned int )(ipagePtr->pagePtr)->size);
        }
      }
    }
  }
  if ((unsigned int )ipagePtr != (unsigned int )((void *)0)) {
    PushFrame(itPtr, & frame, file___1, objc, objv, outputPtr);
    status = AdpEval(itPtr, & (ipagePtr->pagePtr)->code, ipagePtr->objs);
    PopFrame(itPtr, & frame);
    Ns_MutexLock(& servPtr->adp.pagelock);
    (ipagePtr->pagePtr)->evals ++;
    Ns_MutexUnlock(& servPtr->adp.pagelock);
  }
  if (itPtr->adp.debugLevel > 0) {
    itPtr->adp.debugLevel = itPtr->adp.debugLevel - 1;
  }
  done: 
  Tcl_DStringFree(& path);
  Tcl_DStringFree(& tmp);
  return (status);
}
}
int NsAdpDebug(NsInterp *itPtr , char *host , char *port , char *procs___0 ) 
{ Tcl_Interp *interp ;
  Tcl_DString ds ;
  int code ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  interp = itPtr->interp;
  code = 0;
  if (! itPtr->adp.debugInit) {
    itPtr->delete = 1;
    Tcl_DStringInit(& ds);
    Tcl_DStringAppendElement(& ds, (itPtr->servPtr)->adp.debuginit);
    if (procs___0) {
      tmp = (char const   *)procs___0;
    } else {
      tmp = "";
    }
    Tcl_DStringAppendElement(& ds, (char *)tmp);
    if (host) {
      tmp___0 = (char const   *)host;
    } else {
      tmp___0 = "";
    }
    Tcl_DStringAppendElement(& ds, (char *)tmp___0);
    if (port) {
      tmp___1 = (char const   *)port;
    } else {
      tmp___1 = "";
    }
    Tcl_DStringAppendElement(& ds, (char *)tmp___1);
    code = Tcl_EvalEx(interp, ds.string, ds.length, 0);
    Tcl_DStringFree(& ds);
    if (code != 0) {
      Ns_TclLogError(interp);
      return (1);
    }
    if ((unsigned int )itPtr->adp.responsePtr != (unsigned int )((void *)0)) {
      tmp___2 = Tcl_LinkVar(interp, (char *)"ns_adp_output", (char *)(& (itPtr->adp.responsePtr)->string),
                            132);
      if (tmp___2 != 0) {
        Ns_TclLogError(interp);
      }
    }
    itPtr->adp.debugInit = 1;
    itPtr->adp.debugLevel = 1;
  }
  return (code);
}
}
int NsTclAdpStatsCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ NsInterp *itPtr ;
  NsServer *servPtr ;
  FileKey *keyPtr ;
  char buf[200] ;
  Tcl_HashSearch search ;
  Tcl_HashEntry *hPtr ;
  Page *pagePtr ;
  char *tmp ;

  {
  itPtr = (NsInterp *)arg;
  servPtr = itPtr->servPtr;
  Ns_MutexLock(& servPtr->adp.pagelock);
  hPtr = Tcl_FirstHashEntry(& servPtr->adp.pages, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    pagePtr = (Page *)hPtr->clientData;
    if (servPtr->adp.pages.keyType == 1) {
      tmp = hPtr->key.oneWordValue;
    } else {
      if (servPtr->adp.pages.keyType == -1) {
        tmp = hPtr->key.oneWordValue;
      } else {
        tmp = hPtr->key.string;
      }
    }
    keyPtr = (FileKey *)tmp;
    Tcl_AppendElement(interp, pagePtr->file);
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"dev %ld ino %ld mtime %ld refcnt %d evals %d size %ld blocks %d scripts %d",
            keyPtr->dev, keyPtr->ino, pagePtr->mtime, pagePtr->refcnt, pagePtr->evals,
            pagePtr->size, pagePtr->code.nblocks, pagePtr->code.nscripts);
    Tcl_AppendElement(interp, buf);
    hPtr = Tcl_NextHashEntry(& search);
  }
  Ns_MutexUnlock(& servPtr->adp.pagelock);
  return (0);
}
}
static void PushFrame(NsInterp *itPtr , Frame *framePtr , char *file___1 , int objc ,
                      Tcl_Obj **objv , Tcl_DString *outputPtr ) 
{ char *slash ;

  {
  framePtr->cwd = itPtr->adp.cwd;
  framePtr->objc = itPtr->adp.objc;
  framePtr->objv = itPtr->adp.objv;
  framePtr->outputPtr = itPtr->adp.outputPtr;
  itPtr->adp.outputPtr = outputPtr;
  itPtr->adp.objc = objc;
  itPtr->adp.objv = objv;
  itPtr->adp.depth = itPtr->adp.depth + 1;
  Tcl_DStringInit(& framePtr->cwdBuf);
  if ((unsigned int )file___1 != (unsigned int )((void *)0)) {
    slash = strrchr((char const   *)file___1, '/');
    Tcl_DStringAppend(& framePtr->cwdBuf, file___1, slash - file___1);
    itPtr->adp.cwd = framePtr->cwdBuf.string;
  }
  return;
}
}
static void PopFrame(NsInterp *itPtr , Frame *framePtr ) 
{ 

  {
  itPtr->adp.objc = framePtr->objc;
  itPtr->adp.objv = framePtr->objv;
  itPtr->adp.cwd = framePtr->cwd;
  itPtr->adp.outputPtr = framePtr->outputPtr;
  itPtr->adp.depth = itPtr->adp.depth - 1;
  Tcl_DStringFree(& framePtr->cwdBuf);
  return;
}
}
static Page *ParseFile(NsInterp *itPtr , char *file___1 , struct stat *stPtr ) 
{ Tcl_Interp *interp ;
  Tcl_Encoding encoding ;
  Tcl_DString utf ;
  char *page ;
  char *buf ;
  int fd ;
  int n ;
  int trys ;
  size_t size ;
  Page *pagePtr ;
  AdpParse parse ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  __off_t tmp___4 ;
  size_t tmp___5 ;

  {
  interp = itPtr->interp;
  fd = open((char const   *)file___1, 0);
  if (fd < 0) {
    tmp = Tcl_PosixError(interp);
    Tcl_AppendResult(interp, "could not open \"", file___1, "\": ", tmp, (void *)0);
    return ((Page *)((void *)0));
  }
  pagePtr = (Page *)((void *)0);
  buf = (char *)((void *)0);
  trys = 0;
  while (1) {
    tmp___1 = fstat__extinline(fd, stPtr);
    if (tmp___1 != 0) {
      tmp___0 = Tcl_PosixError(interp);
      Tcl_AppendResult(interp, "could not fstat \"", file___1, "\": ", tmp___0, (void *)0);
      goto done;
    }
    size = (unsigned int )stPtr->st_size;
    buf = (char *)ns_realloc((void *)buf, size + 1U);
    n = read(fd, (void *)buf, size + 1U);
    if (n < 0) {
      tmp___2 = Tcl_PosixError(interp);
      Tcl_AppendResult(interp, "could not read \"", file___1, "\": ", tmp___2, (void *)0);
      goto done;
    }
    if ((unsigned int )n != size) {
      tmp___4 = lseek(fd, 0L, 0);
      if (tmp___4 != 0L) {
        tmp___3 = Tcl_PosixError(interp);
        Tcl_AppendResult(interp, "could not lseek \"", file___1, "\": ", tmp___3,
                         (void *)0);
        goto done;
      }
      Ns_ThreadYield();
    }
    if ((unsigned int )n != size) {
      trys ++;
      if (! (trys < 10)) {
        break;
      }
    } else {
      break;
    }
  }
  if ((unsigned int )n != size) {
    Tcl_AppendResult(interp, "inconsistant file: ", file___1, (void *)0);
  } else {
    (*(buf + n)) = (char )'\000';
    Tcl_DStringInit(& utf);
    encoding = Ns_GetFileEncoding(file___1);
    if ((unsigned int )encoding == (unsigned int )((void *)0)) {
      page = buf;
    } else {
      Tcl_ExternalToUtfDString(encoding, buf, n, & utf);
      page = utf.string;
    }
    NsAdpParse(& parse, itPtr->servPtr, page, 0);
    Tcl_DStringFree(& utf);
    tmp___5 = strlen((char const   *)file___1);
    n = (int )(((unsigned int )(parse.hdr.length + parse.text.length) + tmp___5) +
               1U);
    pagePtr = (Page *)ns_malloc(sizeof(Page ) + (unsigned int )n);
    pagePtr->servPtr = itPtr->servPtr;
    pagePtr->refcnt = 0;
    pagePtr->evals = 0;
    pagePtr->mtime = stPtr->st_mtim.tv_sec;
    pagePtr->size = stPtr->st_size;
    pagePtr->code.nblocks = parse.code.nblocks;
    pagePtr->code.nscripts = parse.code.nscripts;
    pagePtr->code.len = (int *)(pagePtr + 1);
    pagePtr->code.base = (char *)(pagePtr->code.len + parse.code.nblocks);
    pagePtr->file = pagePtr->code.base + parse.text.length;
    memcpy((void * __restrict  )pagePtr->code.len, (void const   * __restrict  )parse.hdr.string,
           (unsigned int )parse.hdr.length);
    memcpy((void * __restrict  )pagePtr->code.base, (void const   * __restrict  )parse.text.string,
           (unsigned int )parse.text.length);
    strcpy((char * __restrict  )pagePtr->file, (char const   * __restrict  )file___1);
    ParseFree(& parse);
  }
  done: 
  ns_free((void *)buf);
  close(fd);
  return (pagePtr);
}
}
static void LogError(NsInterp *itPtr , int nscript ) 
{ Tcl_Interp *interp ;
  Tcl_DString ds ;
  Tcl_Obj *objv[2] ;
  char *file___1 ;
  char *script ;
  char buffer[154] ;
  size_t tmp ;

  {
  interp = itPtr->interp;
  Tcl_DStringInit(& ds);
  Tcl_DStringAppend(& ds, (char *)"\n    invoked from within chunk: ", -1);
  Ns_DStringPrintf(& ds, (char *)"%d", nscript);
  Tcl_DStringAppend(& ds, (char *)" of adp: ", -1);
  script = Tcl_GetString((*(itPtr->adp.objv + 0)));
  tmp = strlen((char const   *)script);
  if (tmp > 150U) {
    sprintf((char * __restrict  )(buffer), (char const   * __restrict  )"%.*s...",
            150, script);
    script = buffer;
  }
  Tcl_DStringAppend(& ds, script, -1);
  Tcl_AddErrorInfo(interp, ds.string);
  Ns_TclLogError(interp);
  Tcl_DStringFree(& ds);
  file___1 = (itPtr->servPtr)->adp.errorpage;
  if ((unsigned int )file___1 != (unsigned int )((void *)0)) {
    if (itPtr->adp.errorLevel == 0) {
      itPtr->adp.errorLevel = itPtr->adp.errorLevel + 1;
      objv[0] = Tcl_NewStringObj(file___1, -1);
      (objv[0])->refCount = (objv[0])->refCount + 1;
      objv[1] = Tcl_GetVar2Ex(interp, (char *)"errorInfo", (char *)((void *)0), 1);
      if ((unsigned int )objv[1] == (unsigned int )((void *)0)) {
        objv[1] = Tcl_GetObjResult(interp);
      }
      NsAdpInclude(itPtr, file___1, 2, objv);
      (objv[0])->refCount = (objv[0])->refCount - 1;
      if ((objv[0])->refCount <= 0) {
        TclFreeObj(objv[0]);
      }
      itPtr->adp.errorLevel = itPtr->adp.errorLevel - 1;
    }
  }
  return;
}
}
static int AdpEval(NsInterp *itPtr , AdpCode *codePtr , Tcl_Obj **objs ) 
{ Tcl_Interp *interp ;
  Tcl_Obj *objPtr ;
  int nscript ;
  int result ;
  int len ;
  int i ;
  char *ptr ;

  {
  interp = itPtr->interp;
  ptr = codePtr->base;
  nscript = 0;
  result = 0;
  i = 0;
  while (1) {
    if (itPtr->adp.exception == 0) {
      if (! (i < codePtr->nblocks)) {
        break;
      }
    } else {
      break;
    }
    len = (*(codePtr->len + i));
    if (len > 0) {
      if ((unsigned int )itPtr->adp.outputPtr != (unsigned int )((void *)0)) {
        Tcl_DStringAppend(itPtr->adp.outputPtr, ptr, len);
      }
    } else {
      len = - len;
      if (itPtr->adp.debugLevel > 0) {
        result = AdpDebug(itPtr, ptr, len, nscript);
      } else {
        if ((unsigned int )objs == (unsigned int )((void *)0)) {
          result = Tcl_EvalEx(interp, ptr, len, 0);
        } else {
          objPtr = (*(objs + nscript));
          if ((unsigned int )objPtr != (unsigned int )((void *)0)) {
            result = Tcl_EvalObjEx(interp, objPtr, 0);
          } else {
            objPtr = Tcl_NewStringObj(ptr, len);
            objPtr->refCount = objPtr->refCount + 1;
            result = Tcl_EvalObjEx(interp, objPtr, 0);
            (*(objs + nscript)) = objPtr;
          }
        }
      }
      if (result != 0) {
        if (result != 2) {
          if (itPtr->adp.exception == 0) {
            LogError(itPtr, nscript);
          }
        }
      }
      nscript ++;
    }
    ptr += len;
    NsAdpFlush(itPtr);
    i ++;
  }
  if (itPtr->adp.exception == 4) {
    itPtr->adp.exception = 0;
    result = 0;
  }
  NsAdpFlush(itPtr);
  return (result);
}
}
static int AdpDebug(NsInterp *itPtr , char *ptr , int len , int nscript ) 
{ int code ;
  int fd ;
  Tcl_Interp *interp ;
  int level ;
  char *file___1 ;
  char *tmp ;
  char buf[10] ;
  char debugfile[255] ;
  Tcl_DString ds ;
  char *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;
  char *tmp___3 ;

  {
  interp = itPtr->interp;
  level = itPtr->adp.debugLevel;
  tmp = Tcl_GetString((*(itPtr->adp.objv + 0)));
  file___1 = tmp;
  code = 1;
  Tcl_DStringInit(& ds);
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", level);
  Ns_DStringVarAppend(& ds, "#\n# level: ", buf, "\n", (void *)0);
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", nscript);
  Ns_DStringVarAppend(& ds, "# chunk: ", buf, "\n# file:  ", file___1, "\n#\n\n",
                      (void *)0);
  Tcl_DStringAppend(& ds, ptr, len);
  sprintf((char * __restrict  )(debugfile), (char const   * __restrict  )"/tmp/adp%d.%d.XXXXXX",
          level, nscript);
  tmp___3 = mktemp(debugfile);
  if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
    Tcl_SetResult(interp, (char *)"could not create adp debug file", (Tcl_FreeProc *)0);
  } else {
    fd = open((char const   *)(debugfile), 577, 420);
    if (fd < 0) {
      tmp___0 = Tcl_PosixError(interp);
      Tcl_AppendResult(interp, "could not create adp debug file \"", debugfile, "\": ",
                       tmp___0, (void *)0);
    } else {
      tmp___2 = write(fd, (void const   *)ds.string, (unsigned int )ds.length);
      if (tmp___2 < 0) {
        tmp___1 = Tcl_PosixError(interp);
        Tcl_AppendResult(interp, "write to \"", debugfile, "\" failed: ", tmp___1,
                         (void *)0);
      } else {
        Tcl_DStringSetLength(& ds, 0);
        Ns_DStringVarAppend(& ds, "source ", debugfile, (void *)0);
        code = Tcl_EvalEx(interp, ds.string, ds.length, 0);
      }
      close(fd);
      unlink((char const   *)(debugfile));
    }
  }
  Tcl_DStringFree(& ds);
  return (code);
}
}
static void FreeInterpPage(void *arg ) 
{ InterpPage *ipagePtr ;
  Page *pagePtr ;
  NsServer *servPtr ;
  int i ;

  {
  ipagePtr = (InterpPage *)arg;
  pagePtr = ipagePtr->pagePtr;
  servPtr = pagePtr->servPtr;
  i = 0;
  while (i < pagePtr->code.nscripts) {
    if ((unsigned int )ipagePtr->objs[i] != (unsigned int )((void *)0)) {
      (ipagePtr->objs[i])->refCount = (ipagePtr->objs[i])->refCount - 1;
      if ((ipagePtr->objs[i])->refCount <= 0) {
        TclFreeObj(ipagePtr->objs[i]);
      }
    }
    i ++;
  }
  Ns_MutexLock(& servPtr->adp.pagelock);
  pagePtr->refcnt --;
  if (pagePtr->refcnt == 0) {
    if ((unsigned int )pagePtr->hPtr != (unsigned int )((void *)0)) {
      Tcl_DeleteHashEntry(pagePtr->hPtr);
    }
    ns_free((void *)pagePtr);
  }
  Ns_MutexUnlock(& servPtr->adp.pagelock);
  ns_free((void *)ipagePtr);
  return;
}
}
static void ParseFree(AdpParse *parsePtr ) 
{ 

  {
  Tcl_DStringFree(& parsePtr->hdr);
  Tcl_DStringFree(& parsePtr->text);
  return;
}
}
extern char *strchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
extern char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__)) ;
extern int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
extern int Tcl_UtfToLower(char *src ) ;
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
void Ns_RWLockRdLock(Ns_RWLock *rwPtr ) ;
void Ns_RWLockWrLock(Ns_RWLock *rwPtr ) ;
void Ns_RWLockUnlock(Ns_RWLock *rwPtr ) ;
int Ns_AdpRegisterParser(char *extension , Ns_AdpParserProc *proc ) ;
static void AppendBlock(AdpParse *parsePtr , char *s , char *e___1 , int type ) ;
static void Parse(AdpParse *parsePtr , NsServer *servPtr , char *utf ) ;
static int RegisterCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ,
                       int type ) ;
int Ns_AdpRegisterParser(char *extension , Ns_AdpParserProc *proc ) 
{ 

  {
  return (-1);
}
}
int NsTclRegisterTagCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ int tmp ;

  {
  tmp = RegisterCmd(arg, interp, argc, argv, 3);
  return (tmp);
}
}
int NsTclAdpRegisterAdpCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ int tmp ;

  {
  tmp = RegisterCmd(arg, interp, argc, argv, 1);
  return (tmp);
}
}
int NsTclAdpRegisterProcCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ int tmp ;

  {
  tmp = RegisterCmd(arg, interp, argc, argv, 2);
  return (tmp);
}
}
static int RegisterCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ,
                       int type ) 
{ NsInterp *itPtr ;
  NsServer *servPtr ;
  char *string ;
  Tcl_HashEntry *hPtr ;
  int new ;
  int slen ;
  int elen ;
  Tag *tagPtr ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
  itPtr = (NsInterp *)arg;
  servPtr = itPtr->servPtr;
  if (argc != 4) {
    if (argc != 3) {
      if (type == 1) {
        tmp = "adp";
      } else {
        tmp = "proc";
      }
      Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " tag ?endtag? ",
                       tmp, "\"", (void *)0);
      return (1);
    }
  }
  string = (*(argv + (argc - 1)));
  tmp___0 = strlen((char const   *)string);
  slen = (int )(tmp___0 + 1U);
  if (argc == 3) {
    elen = 0;
  } else {
    tmp___1 = strlen((char const   *)(*(argv + 2)));
    elen = (int )(tmp___1 + 1U);
  }
  tagPtr = (Tag *)ns_malloc((sizeof(Tag ) + (unsigned int )slen) + (unsigned int )elen);
  tagPtr->type = type;
  tagPtr->string = (char *)tagPtr + sizeof(Tag );
  memcpy((void * __restrict  )tagPtr->string, (void const   * __restrict  )string,
         (unsigned int )slen);
  if (argc == 3) {
    tagPtr->endtag = (char *)((void *)0);
  } else {
    tagPtr->endtag = tagPtr->string + slen;
    memcpy((void * __restrict  )tagPtr->endtag, (void const   * __restrict  )(*(argv +
                                                                                2)),
           (unsigned int )elen);
  }
  Ns_RWLockWrLock(& servPtr->adp.taglock);
  hPtr = ((*(servPtr->adp.tags.createProc)))(& servPtr->adp.tags, (*(argv + 1)), & new);
  if (! new) {
    ns_free(hPtr->clientData);
  }
  hPtr->clientData = (void *)tagPtr;
  if (servPtr->adp.tags.keyType == 1) {
    tmp___2 = hPtr->key.oneWordValue;
  } else {
    if (servPtr->adp.tags.keyType == -1) {
      tmp___2 = hPtr->key.oneWordValue;
    } else {
      tmp___2 = hPtr->key.string;
    }
  }
  tagPtr->tag = tmp___2;
  Ns_RWLockUnlock(& servPtr->adp.taglock);
  return (0);
}
}
void NsAdpParse(AdpParse *parsePtr , NsServer *servPtr , char *utf , int safe ) 
{ char *s ;
  char *e___1 ;

  {
  Tcl_DStringInit(& parsePtr->hdr);
  Tcl_DStringInit(& parsePtr->text);
  parsePtr->code.nblocks = 0;
  parsePtr->code.nscripts = parsePtr->code.nblocks;
  while (1) {
    s = strstr((char const   *)utf, "<%");
    if (s) {
      e___1 = strstr((char const   *)s, "%>");
      if (! e___1) {
        break;
      }
    } else {
      break;
    }
    (*s) = (char )'\000';
    Parse(parsePtr, servPtr, utf);
    (*s) = (char )'<';
    if (! safe) {
      if ((int )(*(s + 2)) != 61) {
        AppendBlock(parsePtr, s + 2, e___1, 's');
      } else {
        AppendBlock(parsePtr, s + 3, e___1, 'S');
      }
    }
    utf = e___1 + 2;
  }
  Parse(parsePtr, servPtr, utf);
  parsePtr->code.len = (int *)parsePtr->hdr.string;
  parsePtr->code.base = parsePtr->text.string;
  return;
}
}
static void AppendBlock(AdpParse *parsePtr , char *s , char *e___1 , int type ) 
{ int len ;

  {
  if ((unsigned int )s < (unsigned int )e___1) {
    parsePtr->code.nblocks = parsePtr->code.nblocks + 1;
    len = e___1 - s;
    if (type == 83) {
      len = (int )((unsigned int )len + (sizeof("ns_adp_append ") - 1U));
      Tcl_DStringAppend(& parsePtr->text, (char *)"ns_adp_append ", (int )(sizeof("ns_adp_append ") -
                                                                           1U));
    }
    Tcl_DStringAppend(& parsePtr->text, s, e___1 - s);
    if (type != 116) {
      parsePtr->code.nscripts = parsePtr->code.nscripts + 1;
      len = - len;
    }
    Tcl_DStringAppend(& parsePtr->hdr, (char *)(& len), (int )sizeof(len));
  }
  return;
}
}
static void GetTag(Tcl_DString *dsPtr , char *s , char *e___1 , char **aPtr ) 
{ char *t ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  s ++;
  while (1) {
    if ((unsigned int )s < (unsigned int )e___1) {
      tmp = __ctype_b_loc();
      if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*s)))) & 8192)) {
        break;
      }
    } else {
      break;
    }
    s ++;
  }
  t = s;
  while (1) {
    if ((unsigned int )s < (unsigned int )e___1) {
      tmp___0 = __ctype_b_loc();
      if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*s)))) & 8192) {
        break;
      }
    } else {
      break;
    }
    s ++;
  }
  Tcl_DStringSetLength(dsPtr, 0);
  Tcl_DStringAppend(dsPtr, t, s - t);
  if ((unsigned int )aPtr != (unsigned int )((void *)0)) {
    while (1) {
      if ((unsigned int )s < (unsigned int )e___1) {
        tmp___1 = __ctype_b_loc();
        if (! ((int const   )(*((*tmp___1) + (int )((unsigned char )(*s)))) & 8192)) {
          break;
        }
      } else {
        break;
      }
      s ++;
    }
    (*aPtr) = s;
  }
  dsPtr->length = Tcl_UtfToLower(dsPtr->string);
  return;
}
}
static void ParseAtts(char *s , char *e___1 , int *servPtr , Tcl_DString *attsPtr ,
                      int atts ) 
{ char *vs ;
  char *ve ;
  char *as ;
  char *ae ;
  char end ;
  char vsave ;
  char asave ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  vs = (char *)((void *)0);
  ve = (char *)((void *)0);
  as = (char *)((void *)0);
  ae = (char *)((void *)0);
  end = (char)0;
  vsave = (char)0;
  asave = (char)0;
  if ((unsigned int )servPtr != (unsigned int )((void *)0)) {
    (*servPtr) = 0;
  }
  while ((unsigned int )s < (unsigned int )e___1) {
    while (1) {
      if ((unsigned int )s < (unsigned int )e___1) {
        tmp = __ctype_b_loc();
        if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*s)))) & 8192)) {
          break;
        }
      } else {
        break;
      }
      s ++;
    }
    if ((unsigned int )s == (unsigned int )e___1) {
      break;
    }
    as = s;
    if ((int )(*s) != 39) {
      if ((int )(*s) != 34) {
        while (1) {
          if ((unsigned int )s < (unsigned int )e___1) {
            tmp___0 = __ctype_b_loc();
            if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*s)))) & 8192) {
              break;
            } else {
              if (! ((int )(*s) != 61)) {
                break;
              }
            }
          } else {
            break;
          }
          s ++;
        }
      } else {
        goto _L;
      }
    } else {
      _L: 
      s ++;
      while (1) {
        if ((unsigned int )s < (unsigned int )e___1) {
          if (! ((int )(*s) != (int )(*as))) {
            break;
          }
        } else {
          break;
        }
        s ++;
      }
      s ++;
    }
    ae = s;
    while (1) {
      if ((unsigned int )s < (unsigned int )e___1) {
        tmp___1 = __ctype_b_loc();
        if (! ((int const   )(*((*tmp___1) + (int )((unsigned char )(*s)))) & 8192)) {
          break;
        }
      } else {
        break;
      }
      s ++;
    }
    if ((int )(*s) != 61) {
      vs = as;
    } else {
      while (1) {
        s ++;
        if ((unsigned int )s < (unsigned int )e___1) {
          tmp___2 = __ctype_b_loc();
          if (! ((int const   )(*((*tmp___2) + (int )((unsigned char )(*s)))) & 8192)) {
            break;
          }
        } else {
          break;
        }
      }
      vs = s;
      if ((int )(*s) != 34) {
        while (1) {
          if ((unsigned int )s < (unsigned int )e___1) {
            tmp___3 = __ctype_b_loc();
            if ((int const   )(*((*tmp___3) + (int )((unsigned char )(*s)))) & 8192) {
              break;
            }
          } else {
            break;
          }
          s ++;
        }
      } else {
        s ++;
        while (1) {
          if ((unsigned int )s < (unsigned int )e___1) {
            if (! ((int )(*s) != (int )(*vs))) {
              break;
            }
          } else {
            break;
          }
          s ++;
        }
        s ++;
      }
      ve = s;
      end = (*vs);
      if ((int )end != 61) {
        if ((int )end != 34) {
          end = (char)0;
        }
      }
      if (end) {
        if ((unsigned int )ve > (unsigned int )vs) {
          if ((int )(*(ve + -1)) == (int )end) {
            vs ++;
            ve --;
          }
        }
      }
      vsave = (*ve);
      (*ve) = (char )'\000';
    }
    asave = (*ae);
    (*ae) = (char )'\000';
    if ((unsigned int )attsPtr != (unsigned int )((void *)0)) {
      if (atts) {
        Tcl_DStringAppendElement(attsPtr, as);
      }
      Tcl_DStringAppendElement(attsPtr, vs);
    }
    if ((unsigned int )servPtr != (unsigned int )((void *)0)) {
      if ((unsigned int )vs != (unsigned int )as) {
        tmp___8 = strcasecmp((char const   *)as, "runat");
        if (tmp___8 == 0) {
          tmp___9 = strcasecmp((char const   *)vs, "server");
          if (tmp___9 == 0) {
            (*servPtr) |= 2;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          tmp___6 = strcasecmp((char const   *)as, "language");
          if (tmp___6 == 0) {
            tmp___7 = strcasecmp((char const   *)vs, "tcl");
            if (tmp___7 == 0) {
              goto _L___0;
            } else {
              (*servPtr) |= 4;
            }
          } else {
            _L___0: 
            tmp___4 = strcasecmp((char const   *)as, "stream");
            if (tmp___4 == 0) {
              tmp___5 = strcasecmp((char const   *)vs, "on");
              if (tmp___5 == 0) {
                (*servPtr) |= 1;
              }
            }
          }
        }
      }
    }
    (*ae) = asave;
    if ((unsigned int )vs != (unsigned int )as) {
      (*ve) = vsave;
    }
  }
  return;
}
}
static int IsServer(char *tag , char *as , char *ae , int *streamPtr ) 
{ int serv ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if ((unsigned int )as < (unsigned int )ae) {
    if ((int )(*tag) == (int )(*"script")) {
      if (0) {
        __s1_len = strlen((char const   *)tag);
        __s2_len = strlen("script");
        if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
               1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("script" + 1)) - (unsigned int )((void const   *)"script") ==
                   1U)) {
              tmp___6 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___6 = 1;
              } else {
                tmp___6 = 0;
              }
            }
          } else {
            tmp___6 = 0;
          }
        }
        if (tmp___6) {
          if (__s1_len < __s2_len) {
            tmp___4 = __s1_len;
          } else {
            tmp___4 = __s2_len;
          }
          tmp___3 = memcmp((void const   *)((char const   *)tag), (void const   *)"script",
                           tmp___4 + 1U);
        } else {
          tmp___5 = strcmp((char const   *)tag, "script");
          tmp___3 = tmp___5;
        }
      } else {
        tmp___5 = strcmp((char const   *)tag, "script");
        tmp___3 = tmp___5;
      }
      if (tmp___3 == 0) {
        ParseAtts(as, ae, & serv, (Tcl_DString *)((void *)0), 1);
        if (serv & 2) {
          if (! (serv & 4)) {
            (*streamPtr) = serv & 1;
            return (1);
          }
        }
      }
    }
  }
  return (0);
}
}
static void AppendTag(AdpParse *parsePtr , Tag *tagPtr , char *as , char *ae , char *se ) 
{ Tcl_DString script ;
  char save ;

  {
  Tcl_DStringInit(& script);
  Tcl_DStringAppend(& script, (char *)"ns_adp_append [", -1);
  if (tagPtr->type == 1) {
    Tcl_DStringAppend(& script, (char *)"ns_adp_eval ", -1);
  }
  Tcl_DStringAppendElement(& script, tagPtr->string);
  if (tagPtr->type == 2) {
    ParseAtts(as, ae, (int *)((void *)0), & script, 0);
  }
  if ((unsigned int )se > (unsigned int )ae) {
    save = (*se);
    (*se) = (char )'\000';
    Tcl_DStringAppendElement(& script, ae + 1);
    (*se) = save;
  }
  if (tagPtr->type != 2) {
    Tcl_DStringAppend(& script, (char *)" [ns_set create", -1);
    Tcl_DStringAppendElement(& script, tagPtr->tag);
    ParseAtts(as, ae, (int *)((void *)0), & script, 1);
    Tcl_DStringAppend(& script, (char *)"]", 1);
  }
  Tcl_DStringAppend(& script, (char *)"]", 1);
  AppendBlock(parsePtr, script.string, script.string + script.length, 's');
  Tcl_DStringFree(& script);
  return;
}
}
static void Parse(AdpParse *parsePtr , NsServer *servPtr , char *utf ) 
{ Tag *tagPtr ;
  char *ss ;
  char *se ;
  char *s ;
  char *e___1 ;
  char *a ;
  char *as ;
  char *ae ;
  char *t ;
  int level ;
  int state ;
  int stream ;
  int streamdone ;
  Tcl_DString tag ;
  Tcl_HashEntry *hPtr ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___11 ;
  char *tmp___13 ;
  size_t tmp___14 ;

  {
  tagPtr = (Tag *)((void *)0);
  ss = (char *)((void *)0);
  se = (char *)((void *)0);
  s = (char *)((void *)0);
  e___1 = (char *)((void *)0);
  a = (char *)((void *)0);
  as = (char *)((void *)0);
  ae = (char *)((void *)0);
  t = (char *)((void *)0);
  level = 0;
  hPtr = (Tcl_HashEntry *)((void *)0);
  Tcl_DStringInit(& tag);
  t = utf;
  streamdone = 0;
  state = 0;
  Ns_RWLockRdLock(& servPtr->adp.taglock);
  while (1) {
    tmp___11 = strchr((char const   *)utf, '<');
    s = tmp___11;
    if (s) {
      tmp___13 = strchr((char const   *)s, '>');
      e___1 = tmp___13;
      if (! e___1) {
        break;
      }
    } else {
      break;
    }
    switch (state) {
    case 0: 
    GetTag(& tag, s, e___1, & a);
    tmp = IsServer(tag.string, a, e___1, & stream);
    if (tmp) {
      ss = s;
      se = e___1 + 1;
      state = 1;
    } else {
      hPtr = ((*(servPtr->adp.tags.findProc)))(& servPtr->adp.tags, tag.string);
      if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
        tagPtr = (Tag *)hPtr->clientData;
        if ((unsigned int )tagPtr->endtag == (unsigned int )((void *)0)) {
          AppendBlock(parsePtr, t, s, 't');
          t = e___1 + 1;
          AppendTag(parsePtr, tagPtr, a, e___1, (char *)((void *)0));
        } else {
          ss = s;
          as = a;
          ae = e___1;
          level = 1;
          state = 2;
        }
      }
    }
    break;
    case 1: 
    GetTag(& tag, s, e___1, (char **)((void *)0));
    if ((int )(*(tag.string)) == (int )(*"/script")) {
      if (0) {
        __s1_len = strlen((char const   *)tag.string);
        __s2_len = strlen("/script");
        if (! ((unsigned int )((void const   *)(tag.string + 1)) - (unsigned int )((void const   *)tag.string) ==
               1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("/script" + 1)) - (unsigned int )((void const   *)"/script") ==
                   1U)) {
              tmp___7 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___7 = 1;
              } else {
                tmp___7 = 0;
              }
            }
          } else {
            tmp___7 = 0;
          }
        }
        if (tmp___7) {
          if (__s1_len < __s2_len) {
            tmp___5 = __s1_len;
          } else {
            tmp___5 = __s2_len;
          }
          tmp___4 = memcmp((void const   *)((char const   *)tag.string), (void const   *)"/script",
                           tmp___5 + 1U);
        } else {
          tmp___6 = strcmp((char const   *)tag.string, "/script");
          tmp___4 = tmp___6;
        }
      } else {
        tmp___6 = strcmp((char const   *)tag.string, "/script");
        tmp___4 = tmp___6;
      }
      if (tmp___4 == 0) {
        AppendBlock(parsePtr, t, ss, 't');
        t = e___1 + 1;
        if (stream) {
          if (! streamdone) {
            AppendBlock(parsePtr, (char *)"ns_adp_stream", (char *)((void *)0), 's');
            streamdone = 1;
          }
        }
        AppendBlock(parsePtr, se, s, 's');
        state = 0;
      }
    }
    break;
    case 2: 
    GetTag(& tag, s, e___1, (char **)((void *)0));
    tmp___9 = strcasecmp((char const   *)tag.string, (char const   *)tagPtr->tag);
    if (tmp___9 == 0) {
      level ++;
    } else {
      tmp___8 = strcasecmp((char const   *)tag.string, (char const   *)tagPtr->endtag);
      if (tmp___8 == 0) {
        level --;
        if (level == 0) {
          AppendBlock(parsePtr, t, ss, 't');
          t = e___1 + 1;
          AppendTag(parsePtr, tagPtr, as, ae, s);
          state = 0;
        }
      }
    }
    break;
    }
    utf = s + 1;
  }
  Ns_RWLockUnlock(& servPtr->adp.taglock);
  tmp___14 = strlen((char const   *)t);
  AppendBlock(parsePtr, t, t + tmp___14, 't');
  Tcl_DStringFree(& tag);
  return;
}
}
extern int access(char const   *__name , int __type ) ;
extern void Tcl_ResetResult(Tcl_Interp *interp ) ;
extern char *Tcl_SetVar2(Tcl_Interp *interp , char *part1 , char *part2 , char *newValue ,
                         int flags ) ;
extern char *Tcl_UtfToExternalDString(Tcl_Encoding encoding , char *src , int srcLen ,
                                      Tcl_DString *dsPtr ) ;
int Ns_AdpRequest(Ns_Conn *conn , char *file___1 ) ;
void Ns_CacheDestroy(Ns_Cache *cache ) ;
int Ns_CompressGzip(char *buf , int len , Tcl_DString *outPtr , int level ) ;
int Ns_ConnClose(Ns_Conn *conn ) ;
int Ns_WriteConn(Ns_Conn *conn , char *buf , int len ) ;
void Ns_ConnSetEncoding(Ns_Conn *conn , Tcl_Encoding encoding ) ;
Tcl_Encoding Ns_ConnGetEncoding(Ns_Conn *conn ) ;
void Ns_ConnSetUrlEncoding(Ns_Conn *conn , Tcl_Encoding encoding ) ;
Ns_Set *Ns_ConnHeaders(Ns_Conn *conn ) ;
char *Ns_ConnServer(Ns_Conn *conn ) ;
int Ns_UrlToFile(Tcl_DString *dsPtr , char *server , char *url ) ;
char *Ns_GetMimeType(char *file___1 ) ;
Tcl_Encoding Ns_GetTypeEncoding(char *type ) ;
void Ns_ConnQueueHeaders(Ns_Conn *conn , int status ) ;
void Ns_ConnCondSetHeaders(Ns_Conn *conn , char *field , char *value ) ;
void Ns_ConnSetRequiredHeaders(Ns_Conn *conn , char *type , int length ) ;
int Ns_ConnReturnNotFound(Ns_Conn *conn ) ;
Tcl_Interp *Ns_GetConnInterp(Ns_Conn *conn ) ;
NsInterp *NsGetInterp(Tcl_Interp *interp ) ;
int NsAdpProc(void *arg , Ns_Conn *conn ) ;
void NsFreeAdp(NsInterp *itPtr ) ;
static int AdpFlush(NsInterp *itPtr , int stream ) ;
int NsAdpProc(void *arg , Ns_Conn *conn ) 
{ Tcl_DString file___1 ;
  int status ;
  char *tmp ;

  {
  Tcl_DStringInit(& file___1);
  tmp = Ns_ConnServer(conn);
  Ns_UrlToFile(& file___1, tmp, (conn->request)->url);
  status = Ns_AdpRequest(conn, file___1.string);
  Tcl_DStringFree(& file___1);
  return (status);
}
}
int Ns_AdpRequest(Ns_Conn *conn , char *file___1 ) 
{ Conn *connPtr ;
  Tcl_Interp *interp ;
  Tcl_DString rds ;
  Tcl_DString tds ;
  NsInterp *itPtr ;
  int status ;
  char *type ;
  char *start ;
  Ns_Set *setPtr ;
  NsServer *servPtr ;
  Tcl_Obj *objv[2] ;
  int tmp ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  connPtr = (Conn *)conn;
  tmp___0 = access((char const   *)file___1, 4);
  if (tmp___0 != 0) {
    tmp = Ns_ConnReturnNotFound(conn);
    return (tmp);
  }
  interp = Ns_GetConnInterp(conn);
  itPtr = NsGetInterp(interp);
  servPtr = itPtr->servPtr;
  Tcl_DStringInit(& rds);
  Tcl_DStringInit(& tds);
  itPtr->adp.responsePtr = & rds;
  itPtr->adp.outputPtr = itPtr->adp.responsePtr;
  itPtr->adp.typePtr = & tds;
  type = Ns_GetMimeType(file___1);
  if ((unsigned int )type == (unsigned int )((void *)0)) {
    type = (char *)"text/html; charset=iso-8859-1";
  } else {
    if (0) {
      __s1_len = strlen((char const   *)type);
      __s2_len = strlen("*/*");
      if (! ((unsigned int )((void const   *)(type + 1)) - (unsigned int )((void const   *)type) ==
             1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: 
          if (! ((unsigned int )((void const   *)("*/*" + 1)) - (unsigned int )((void const   *)"*/*") ==
                 1U)) {
            tmp___8 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___8 = 1;
            } else {
              tmp___8 = 0;
            }
          }
        } else {
          tmp___8 = 0;
        }
      }
      if (tmp___8) {
        if (__s1_len < __s2_len) {
          tmp___6 = __s1_len;
        } else {
          tmp___6 = __s2_len;
        }
        tmp___5 = memcmp((void const   *)((char const   *)type), (void const   *)"*/*",
                         tmp___6 + 1U);
      } else {
        tmp___7 = strcmp((char const   *)type, "*/*");
        tmp___5 = tmp___7;
      }
    } else {
      tmp___7 = strcmp((char const   *)type, "*/*");
      tmp___5 = tmp___7;
    }
    if (tmp___5 == 0) {
      type = (char *)"text/html; charset=iso-8859-1";
    }
  }
  NsAdpSetMimeType(itPtr, type);
  Tcl_SetVar2(interp, (char *)"conn", (char *)((void *)0), connPtr->idstr, 1);
  Tcl_ResetResult(interp);
  if (servPtr->adp.enabledebug) {
    if ((int )(*((conn->request)->method)) == (int )(*"GET")) {
      if (0) {
        __s1_len___0 = strlen((char const   *)(conn->request)->method);
        __s2_len___0 = strlen("GET");
        if (! ((unsigned int )((void const   *)((conn->request)->method + 1)) - (unsigned int )((void const   *)(conn->request)->method) ==
               1U)) {
          goto _L___2;
        } else {
          if (__s1_len___0 >= 4U) {
            _L___2: 
            if (! ((unsigned int )((void const   *)("GET" + 1)) - (unsigned int )((void const   *)"GET") ==
                   1U)) {
              tmp___16 = 1;
            } else {
              if (__s2_len___0 >= 4U) {
                tmp___16 = 1;
              } else {
                tmp___16 = 0;
              }
            }
          } else {
            tmp___16 = 0;
          }
        }
        if (tmp___16) {
          if (__s1_len___0 < __s2_len___0) {
            tmp___14 = __s1_len___0;
          } else {
            tmp___14 = __s2_len___0;
          }
          tmp___13 = memcmp((void const   *)((char const   *)(conn->request)->method),
                            (void const   *)"GET", tmp___14 + 1U);
        } else {
          tmp___15 = strcmp((char const   *)(conn->request)->method, "GET");
          tmp___13 = tmp___15;
        }
      } else {
        tmp___15 = strcmp((char const   *)(conn->request)->method, "GET");
        tmp___13 = tmp___15;
      }
      if (tmp___13 == 0) {
        setPtr = Ns_ConnGetQuery(conn);
        if ((unsigned int )setPtr != (unsigned int )((void *)0)) {
          itPtr->adp.debugFile = Ns_SetIGet(setPtr, (char *)"debug");
        }
      }
    }
  }
  if (servPtr->adp.startpage) {
    start = servPtr->adp.startpage;
  } else {
    start = file___1;
  }
  objv[0] = Tcl_NewStringObj(start, -1);
  objv[1] = Tcl_NewStringObj(file___1, -1);
  (objv[0])->refCount = (objv[0])->refCount + 1;
  (objv[1])->refCount = (objv[1])->refCount + 1;
  tmp___17 = NsAdpInclude(itPtr, start, 2, objv);
  if (tmp___17 != 0) {
    if (itPtr->adp.exception != 4) {
      if (itPtr->adp.exception != 1) {
        if (itPtr->adp.exception != 2) {
          Ns_TclLogError(interp);
        }
      }
    }
  }
  (objv[0])->refCount = (objv[0])->refCount - 1;
  if ((objv[0])->refCount <= 0) {
    TclFreeObj(objv[0]);
  }
  (objv[1])->refCount = (objv[1])->refCount - 1;
  if ((objv[1])->refCount <= 0) {
    TclFreeObj(objv[1]);
  }
  status = 0;
  if (! (conn->flags & 16)) {
    if (itPtr->adp.exception != 2) {
      status = AdpFlush(itPtr, 0);
    }
  }
  itPtr->adp.outputPtr = (Tcl_DString *)((void *)0);
  itPtr->adp.responsePtr = (Tcl_DString *)((void *)0);
  itPtr->adp.typePtr = (Tcl_DString *)((void *)0);
  itPtr->adp.exception = 0;
  itPtr->adp.stream = 0;
  itPtr->adp.compress = 0;
  itPtr->adp.debugLevel = 0;
  itPtr->adp.debugInit = 0;
  itPtr->adp.debugFile = (char *)((void *)0);
  Tcl_DStringFree(& rds);
  Tcl_DStringFree(& tds);
  return (status);
}
}
void NsAdpFlush(NsInterp *itPtr ) 
{ int tmp ;

  {
  if (itPtr->adp.stream) {
    if ((unsigned int )itPtr->adp.responsePtr != (unsigned int )((void *)0)) {
      if ((itPtr->adp.responsePtr)->length > 0) {
        tmp = AdpFlush(itPtr, 1);
        if (tmp != 0) {
          itPtr->adp.stream = 0;
        }
      }
    }
  }
  return;
}
}
void NsAdpStream(NsInterp *itPtr ) 
{ 

  {
  if (! itPtr->adp.stream) {
    if ((unsigned int )itPtr->conn != (unsigned int )((void *)0)) {
      itPtr->adp.stream = 1;
      NsAdpFlush(itPtr);
    }
  }
  return;
}
}
void NsAdpCompress(NsInterp *itPtr , int compress ) 
{ 

  {
  itPtr->adp.compress = compress;
  return;
}
}
void NsAdpSetMimeType(NsInterp *itPtr , char *type ) 
{ Tcl_Encoding encoding ;

  {
  if ((unsigned int )itPtr->adp.typePtr != (unsigned int )((void *)0)) {
    Tcl_DStringFree(itPtr->adp.typePtr);
    Tcl_DStringAppend(itPtr->adp.typePtr, type, -1);
    encoding = Ns_GetTypeEncoding(type);
    if ((unsigned int )encoding != (unsigned int )((void *)0)) {
      Ns_ConnSetEncoding(itPtr->conn, encoding);
      Ns_ConnSetUrlEncoding(itPtr->conn, encoding);
    }
  }
  return;
}
}
void NsFreeAdp(NsInterp *itPtr ) 
{ 

  {
  if ((unsigned int )itPtr->adp.cache != (unsigned int )((void *)0)) {
    Ns_CacheDestroy(itPtr->adp.cache);
  }
  return;
}
}
static int AdpFlush(NsInterp *itPtr , int stream ) 
{ Tcl_Encoding encoding ;
  Ns_Conn *conn ;
  Tcl_DString ds ;
  Tcl_DString cds ;
  int result ;
  int len ;
  char *buf ;
  char *type ;
  char *ahdr ;
  Ns_Set *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  Tcl_DStringInit(& ds);
  Tcl_DStringInit(& cds);
  conn = itPtr->conn;
  buf = (itPtr->adp.responsePtr)->string;
  len = (itPtr->adp.responsePtr)->length;
  type = (itPtr->adp.typePtr)->string;
  encoding = Ns_ConnGetEncoding(conn);
  if ((unsigned int )encoding != (unsigned int )((void *)0)) {
    Tcl_UtfToExternalDString(encoding, buf, len, & ds);
    buf = ds.string;
    len = ds.length;
  }
  if (itPtr->adp.compress) {
    if ((itPtr->servPtr)->adp.compress.enable) {
      if (! (conn->flags & 16)) {
        if (! (conn->flags & 4)) {
          if (! stream) {
            if (len >= (itPtr->servPtr)->adp.compress.minsize) {
              tmp = Ns_ConnHeaders(conn);
              ahdr = Ns_SetIGet(tmp, (char *)"Accept-Encoding");
              if ((unsigned int )ahdr != (unsigned int )((void *)0)) {
                tmp___0 = strstr((char const   *)ahdr, "gzip");
                if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
                  tmp___1 = Ns_CompressGzip(buf, len, & cds, (itPtr->servPtr)->adp.compress.level);
                  if (tmp___1 == 0) {
                    Ns_ConnCondSetHeaders(conn, (char *)"Content-Encoding", (char *)"gzip");
                    buf = cds.string;
                    len = cds.length;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (! (conn->flags & 16)) {
    if ((itPtr->servPtr)->adp.enableexpire) {
      Ns_ConnCondSetHeaders(conn, (char *)"Expires", (char *)"now");
    }
    if (stream) {
      tmp___2 = -1;
    } else {
      tmp___2 = len;
    }
    Ns_ConnSetRequiredHeaders(conn, type, tmp___2);
    Ns_ConnQueueHeaders(conn, 200);
  }
  if (conn->flags & 4) {
    buf = (char *)((void *)0);
    len = 0;
  }
  result = Ns_WriteConn(conn, buf, len);
  if (result == 0) {
    if (! stream) {
      result = Ns_ConnClose(conn);
    }
  }
  Tcl_DStringFree(& ds);
  Tcl_DStringFree(& cds);
  Tcl_DStringSetLength(itPtr->adp.responsePtr, 0);
  return (result);
}
}
int Ns_AuthorizeRequest(char *server , char *method , char *url , char *user , char *passwd ,
                        char *peer ) ;
void Ns_SetRequestAuthorizeProc(char *server , Ns_RequestAuthorizeProc *proc ) ;
void Ns_SetUserAuthorizeProc(Ns_UserAuthorizeProc *procPtr ) ;
int Ns_AuthorizeUser(char *user , char *passwd ) ;
NsServer *NsGetServer(char *server ) ;
static Ns_UserAuthorizeProc *userProcPtr  ;
int Ns_AuthorizeRequest(char *server , char *method , char *url , char *user , char *passwd ,
                        char *peer ) 
{ NsServer *servPtr ;
  NsServer *tmp ;
  int tmp___0 ;

  {
  tmp = NsGetServer(server);
  servPtr = tmp;
  if ((unsigned int )servPtr == (unsigned int )((void *)0)) {
    return (0);
  } else {
    if ((unsigned int )servPtr->request.authProc == (unsigned int )((void *)0)) {
      return (0);
    }
  }
  tmp___0 = ((*(servPtr->request.authProc)))(server, method, url, user, passwd, peer);
  return (tmp___0);
}
}
void Ns_SetRequestAuthorizeProc(char *server , Ns_RequestAuthorizeProc *proc ) 
{ NsServer *servPtr ;
  NsServer *tmp ;

  {
  tmp = NsGetServer(server);
  servPtr = tmp;
  if ((unsigned int )servPtr != (unsigned int )((void *)0)) {
    servPtr->request.authProc = proc;
  }
  return;
}
}
int NsTclRequestAuthorizeObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  int status ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 5) {
    if (objc != 6) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"method url authuser authpasswd ?ipaddr?");
      return (1);
    }
  }
  if (objc < 6) {
    tmp___0 = (char *)((void *)0);
  } else {
    tmp___0 = Tcl_GetString((*(objv + 5)));
  }
  tmp___1 = Tcl_GetString((*(objv + 4)));
  tmp___2 = Tcl_GetString((*(objv + 3)));
  tmp___3 = Tcl_GetString((*(objv + 2)));
  tmp___4 = Tcl_GetString((*(objv + 1)));
  status = Ns_AuthorizeRequest((itPtr->servPtr)->server, tmp___4, tmp___3, tmp___2,
                               tmp___1, tmp___0);
  switch (status) {
  case 0: 
  Tcl_SetResult(interp, (char *)"OK", (Tcl_FreeProc *)0);
  break;
  case -1: 
  Tcl_SetResult(interp, (char *)"ERROR", (Tcl_FreeProc *)0);
  break;
  case -3: 
  Tcl_SetResult(interp, (char *)"FORBIDDEN", (Tcl_FreeProc *)0);
  break;
  case -2: 
  Tcl_SetResult(interp, (char *)"UNAUTHORIZED", (Tcl_FreeProc *)0);
  break;
  default: 
  tmp___5 = Tcl_GetString((*(objv + 2)));
  tmp___6 = Tcl_GetString((*(objv + 1)));
  Tcl_AppendResult(interp, "could not authorize \"", tmp___6, " ", tmp___5, "\"",
                   (void *)0);
  return (1);
  }
  return (0);
}
}
int Ns_AuthorizeUser(char *user , char *passwd ) 
{ int tmp ;

  {
  if ((unsigned int )userProcPtr == (unsigned int )((void *)0)) {
    return (-1);
  }
  tmp = ((*userProcPtr))(user, passwd);
  return (tmp);
}
}
void Ns_SetUserAuthorizeProc(Ns_UserAuthorizeProc *procPtr ) 
{ 

  {
  userProcPtr = procPtr;
  return;
}
}
extern int listen(int __fd , int __n ) ;
extern char *strerror(int __errnum ) ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern void Tcl_DeleteHashTable(Tcl_HashTable *tablePtr ) ;
extern void Tcl_InitHashTable(Tcl_HashTable *tablePtr , int keyType ) ;
extern int *__errno_location(void)  __attribute__((__const__)) ;
extern long __strtol_internal(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                              int __base , int __group ) ;
__inline static long strtol__extinline(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                       int __base ) 
{ long tmp ;

  {
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
  return (tmp);
}
}
__inline static int atoi__extinline(char const   *__nptr ) 
{ int tmp ;

  {
  tmp = (int )strtol__extinline((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                                10);
  return (tmp);
}
}
char *ns_inet_ntoa(struct in_addr addr ) ;
void Ns_Log(Ns_LogSeverity severity , char *fmt  , ...) ;
int Ns_SockBind(struct sockaddr_in *saPtr ) ;
int Ns_SockListenEx(char *address , int port , int backlog ) ;
int Ns_GetSockAddr(struct sockaddr_in *saPtr , char *host , int port ) ;
void NsInitBinder(void) ;
void NsPreBind(char *args , char *file___1 ) ;
void NsClosePreBound(void) ;
static void PreBind(char *line ) ;
static Tcl_HashTable prebound  ;
static Ns_Mutex lock  ;
int Ns_SockListenEx(char *address , int port , int backlog ) 
{ int err ;
  int sock ;
  struct sockaddr_in sa ;
  Tcl_HashEntry *hPtr ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  sock = -1;
  tmp = Ns_GetSockAddr(& sa, address, port);
  if (tmp != 0) {
    return (-1);
  }
  Ns_MutexLock(& lock);
  hPtr = ((*(prebound.findProc)))(& prebound, (char *)(& sa));
  if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    sock = (int )hPtr->clientData;
    Tcl_DeleteHashEntry(hPtr);
  }
  Ns_MutexUnlock(& lock);
  if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
    sock = Ns_SockBind(& sa);
  }
  if (sock != -1) {
    tmp___2 = listen(sock, backlog);
    if (tmp___2 != 0) {
      tmp___0 = __errno_location();
      err = (*tmp___0);
      close(sock);
      tmp___1 = __errno_location();
      (*tmp___1) = err;
      sock = -1;
    }
  }
  return (sock);
}
}
void NsInitBinder(void) 
{ 

  {
  Tcl_InitHashTable(& prebound, (int )(sizeof(struct sockaddr_in ) / sizeof(int )));
  return;
}
}
void NsPreBind(char *args , char *file___1 ) 
{ char line[1024] ;
  FILE *fp ;
  char *tmp ;

  {
  if ((unsigned int )args != (unsigned int )((void *)0)) {
    PreBind(args);
  }
  if ((unsigned int )file___1 != (unsigned int )((void *)0)) {
    fp = fopen((char const   * __restrict  )file___1, (char const   * __restrict  )"r");
    if ((unsigned int )fp != (unsigned int )((void *)0)) {
      while (1) {
        tmp = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp);
        if (! ((unsigned int )tmp != (unsigned int )((void *)0))) {
          break;
        }
        PreBind(line);
      }
      fclose(fp);
    }
  }
  return;
}
}
void NsClosePreBound(void) 
{ Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  char *addr ;
  int port ;
  int sock ;
  struct sockaddr_in *saPtr ;
  char *tmp ;
  register unsigned short __v ;
  register unsigned short __x ;

  {
  Ns_MutexLock(& lock);
  hPtr = Tcl_FirstHashEntry(& prebound, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    if (prebound.keyType == 1) {
      tmp = hPtr->key.oneWordValue;
    } else {
      if (prebound.keyType == -1) {
        tmp = hPtr->key.oneWordValue;
      } else {
        tmp = hPtr->key.string;
      }
    }
    saPtr = (struct sockaddr_in *)tmp;
    addr = ns_inet_ntoa(saPtr->sin_addr);
    __x = saPtr->sin_port;
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
    port = (int )__v;
    sock = (int )hPtr->clientData;
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"prebind: closed unused: %s:%d = %d",
           addr, port, sock);
    close(sock);
    hPtr = Tcl_NextHashEntry(& search);
  }
  Tcl_DeleteHashTable(& prebound);
  Tcl_InitHashTable(& prebound, (int )(sizeof(struct sockaddr_in ) / sizeof(int )));
  Ns_MutexUnlock(& lock);
  return;
}
}
static void PreBind(char *line ) 
{ Tcl_HashEntry *hPtr ;
  int new ;
  int sock ;
  int port ;
  struct sockaddr_in sa ;
  char *err ;
  char *ent ;
  char *p ;
  char *q ;
  char *addr ;
  char *baddr ;
  char *tmp___0 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  ent = line;
  while (1) {
    tmp___0 = strchr((char const   *)ent, ',');
    p = tmp___0;
    if ((unsigned int )p != (unsigned int )((void *)0)) {
      (*p) = (char )'\000';
    }
    baddr = (char *)((void *)0);
    addr = (char *)"0.0.0.0";
    tmp___2 = strchr((char const   *)ent, ':');
    q = tmp___2;
    if ((unsigned int )q == (unsigned int )((void *)0)) {
      port = atoi__extinline((char const   *)ent);
    } else {
      (*q) = (char )'\000';
      port = atoi__extinline((char const   *)(q + 1));
      addr = ent;
      baddr = addr;
    }
    if (port == 0) {
      err = (char *)"invalid port";
    } else {
      tmp___4 = Ns_GetSockAddr(& sa, baddr, port);
      if (tmp___4 != 0) {
        err = (char *)"invalid address";
      } else {
        hPtr = ((*(prebound.createProc)))(& prebound, (char *)(& sa), & new);
        if (! new) {
          err = (char *)"duplicate entry";
        } else {
          sock = Ns_SockBind(& sa);
          if (sock == -1) {
            Tcl_DeleteHashEntry(hPtr);
            tmp___3 = __errno_location();
            err = strerror((*tmp___3));
          } else {
            hPtr->clientData = (void *)sock;
            err = (char *)((void *)0);
          }
        }
      }
    }
    if ((unsigned int )q != (unsigned int )((void *)0)) {
      (*q) = (char )':';
    }
    if ((unsigned int )p != (unsigned int )((void *)0)) {
      tmp___5 = p;
      p ++;
      (*tmp___5) = (char )',';
    }
    if ((unsigned int )err != (unsigned int )((void *)0)) {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"prebind: invalid entry: %s: %s",
             ent, err);
    } else {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"prebind: bound: %s",
             ent);
    }
    ent = p;
    if (! ((unsigned int )ent != (unsigned int )((void *)0))) {
      break;
    }
  }
  return;
}
}
void Ns_MutexInit(Ns_Mutex *mutex ) ;
void Ns_MutexDestroy(Ns_Mutex *mutex ) ;
int Ns_MutexTryLock(Ns_Mutex *mutex ) ;
void Ns_MutexSetName(Ns_Mutex *mutex , char *name ) ;
void Ns_MutexSetName2(Ns_Mutex *mutex , char *prefix , char *name ) ;
void Ns_CondDestroy(Ns_Cond *cond___9 ) ;
void Ns_CondSignal(Ns_Cond *cond___9 ) ;
int Ns_CondTimedWait(Ns_Cond *cond___9 , Ns_Mutex *mutex , Ns_Time *timePtr ) ;
void Ns_GetTime(Ns_Time *timePtr ) ;
void Ns_IncrTime(Ns_Time *timePtr , time_t sec , long usec ) ;
Ns_Cache *Ns_CacheCreate(char *name , int keys , time_t timeout , Ns_Callback *freeProc ) ;
Ns_Cache *Ns_CacheFind(char *name ) ;
void *Ns_CacheMalloc(Ns_Cache *cache , size_t len ) ;
void Ns_CacheFree(Ns_Cache *cache , void *ptr ) ;
char *Ns_CacheName(Ns_Entry *entry ) ;
char *Ns_CacheKey(Ns_Entry *entry ) ;
void Ns_CacheSetValue(Ns_Entry *entry , void *value ) ;
void Ns_CacheDeleteEntry(Ns_Entry *entry ) ;
Ns_Entry *Ns_CacheFirstEntry(Ns_Cache *cache , Ns_CacheSearch *search ) ;
Ns_Entry *Ns_CacheNextEntry(Ns_CacheSearch *search ) ;
void Ns_CacheFlush(Ns_Cache *cache ) ;
void Ns_CacheLock(Ns_Cache *cache ) ;
int Ns_CacheTryLock(Ns_Cache *cache ) ;
void Ns_CacheUnlock(Ns_Cache *cache ) ;
int Ns_CacheTimedWait(Ns_Cache *cache , Ns_Time *timePtr ) ;
void Ns_CacheWait(Ns_Cache *cache ) ;
void Ns_CacheSignal(Ns_Cache *cache ) ;
void Ns_CacheBroadcast(Ns_Cache *cache ) ;
int Ns_Cancel(int id ) ;
int Ns_ScheduleProc(Ns_Callback *proc , void *arg , int thread , int interval ) ;
void NsInitCache(void) ;
void NsCachePurge(void *arg ) ;
void NsCacheArgProc(Tcl_DString *dsPtr , void *arg ) ;
static Ns_Cache *CacheCreate(char *name , int keys , time_t timeout , size_t maxSize ,
                             Ns_Callback *freeProc ) ;
static int GetCache(Tcl_Interp *interp , char *name , Cache **cachePtrPtr ) ;
static void Delink(Entry *ePtr ) ;
static void Push(Entry *ePtr ) ;
static Tcl_HashTable caches  ;
static Ns_Mutex lock___0  ;
void NsInitCache(void) 
{ 

  {
  Ns_MutexInit(& lock___0);
  Ns_MutexSetName(& lock___0, (char *)"ns:caches");
  Tcl_InitHashTable(& caches, 0);
  return;
}
}
Ns_Cache *Ns_CacheCreate(char *name , int keys , time_t timeout , Ns_Callback *freeProc ) 
{ Ns_Cache *tmp ;

  {
  tmp = CacheCreate(name, keys, timeout, 0U, freeProc);
  return (tmp);
}
}
Ns_Cache *Ns_CacheCreateSz(char *name , int keys , size_t maxSize , Ns_Callback *freeProc ) 
{ Ns_Cache *tmp ;

  {
  tmp = CacheCreate(name, keys, -1L, maxSize, freeProc);
  return (tmp);
}
}
void Ns_CacheDestroy(Ns_Cache *cache ) 
{ Cache *cachePtr ;
  int tmp ;

  {
  cachePtr = (Cache *)cache;
  if (cachePtr->schedId >= 0) {
    Ns_MutexLock(& cachePtr->lock);
    cachePtr->schedStop = 1;
    tmp = Ns_Cancel(cachePtr->schedId);
    if (tmp) {
      cachePtr->schedId = -1;
    }
    while (cachePtr->schedId >= 0) {
      Ns_CondWait(& cachePtr->cond, & cachePtr->lock);
    }
    Ns_MutexUnlock(& cachePtr->lock);
  }
  Ns_CacheFlush(cache);
  Ns_MutexLock(& lock___0);
  if ((unsigned int )cachePtr->hPtr != (unsigned int )((void *)0)) {
    Tcl_DeleteHashEntry(cachePtr->hPtr);
  }
  Ns_MutexUnlock(& lock___0);
  Ns_MutexDestroy(& cachePtr->lock);
  Ns_CondDestroy(& cachePtr->cond);
  Tcl_DeleteHashTable(& cachePtr->entriesTable);
  ns_free((void *)cachePtr);
  return;
}
}
Ns_Cache *Ns_CacheFind(char *name ) 
{ Tcl_HashEntry *hPtr ;
  Ns_Cache *cache ;

  {
  cache = (Ns_Cache *)((void *)0);
  Ns_MutexLock(& lock___0);
  hPtr = ((*(caches.findProc)))(& caches, name);
  if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    cache = (Ns_Cache *)hPtr->clientData;
  }
  Ns_MutexUnlock(& lock___0);
  return (cache);
}
}
void *Ns_CacheMalloc(Ns_Cache *cache , size_t len ) 
{ void *tmp ;

  {
  tmp = ns_malloc(len);
  return (tmp);
}
}
void Ns_CacheFree(Ns_Cache *cache , void *ptr ) 
{ 

  {
  ns_free(ptr);
  return;
}
}
Ns_Entry *Ns_CacheFindEntry(Ns_Cache *cache , char *key___1 ) 
{ Cache *cachePtr ;
  Tcl_HashEntry *hPtr ;
  Entry *ePtr ;

  {
  cachePtr = (Cache *)cache;
  hPtr = ((*(cachePtr->entriesTable.findProc)))(& cachePtr->entriesTable, key___1);
  if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
    cachePtr->nmiss ++;
    return ((Ns_Entry *)((void *)0));
  }
  cachePtr->nhit ++;
  ePtr = (Entry *)hPtr->clientData;
  Delink(ePtr);
  Push(ePtr);
  return ((Ns_Entry *)ePtr);
}
}
Ns_Entry *Ns_CacheCreateEntry(Ns_Cache *cache , char *key___1 , int *newPtr ) 
{ Cache *cachePtr ;
  Tcl_HashEntry *hPtr ;
  Entry *ePtr ;

  {
  cachePtr = (Cache *)cache;
  hPtr = ((*(cachePtr->entriesTable.createProc)))(& cachePtr->entriesTable, key___1,
                                                  newPtr);
  if ((*newPtr) == 0) {
    ePtr = (Entry *)hPtr->clientData;
    Delink(ePtr);
    cachePtr->nhit ++;
  } else {
    ePtr = (Entry *)ns_calloc(1U, sizeof(Entry ));
    ePtr->hPtr = hPtr;
    ePtr->cachePtr = cachePtr;
    hPtr->clientData = (void *)ePtr;
    cachePtr->nmiss ++;
  }
  Push(ePtr);
  return ((Ns_Entry *)ePtr);
}
}
char *Ns_CacheName(Ns_Entry *entry ) 
{ Entry *ePtr ;

  {
  ePtr = (Entry *)entry;
  return ((ePtr->cachePtr)->name);
}
}
char *Ns_CacheKey(Ns_Entry *entry ) 
{ Entry *ePtr ;
  char *tmp ;

  {
  ePtr = (Entry *)entry;
  if ((ePtr->cachePtr)->entriesTable.keyType == 1) {
    tmp = (ePtr->hPtr)->key.oneWordValue;
  } else {
    if ((ePtr->cachePtr)->entriesTable.keyType == -1) {
      tmp = (ePtr->hPtr)->key.oneWordValue;
    } else {
      tmp = (ePtr->hPtr)->key.string;
    }
  }
  return (tmp);
}
}
void *Ns_CacheGetValue(Ns_Entry *entry ) 
{ Entry *ePtr ;

  {
  ePtr = (Entry *)entry;
  return (ePtr->value);
}
}
void Ns_CacheSetValue(Ns_Entry *entry , void *value ) 
{ 

  {
  Ns_CacheSetValueSz(entry, value, 0U);
  return;
}
}
void Ns_CacheSetValueSz(Ns_Entry *entry , void *value , size_t size ) 
{ Entry *ePtr ;
  Cache *cachePtr ;

  {
  ePtr = (Entry *)entry;
  cachePtr = ePtr->cachePtr;
  Ns_CacheUnsetValue(entry);
  ePtr->value = value;
  ePtr->size = size;
  cachePtr->currentSize += size;
  if ((ePtr->cachePtr)->maxSize > 0U) {
    while (1) {
      if (cachePtr->currentSize > cachePtr->maxSize) {
        if (! ((unsigned int )cachePtr->lastEntryPtr != (unsigned int )ePtr)) {
          break;
        }
      } else {
        break;
      }
      Ns_CacheFlushEntry((Ns_Entry *)cachePtr->lastEntryPtr);
    }
  }
  return;
}
}
void Ns_CacheUnsetValue(Ns_Entry *entry ) 
{ Entry *ePtr ;
  Cache *cachePtr ;

  {
  ePtr = (Entry *)entry;
  if ((unsigned int )ePtr->value != (unsigned int )((void *)0)) {
    cachePtr = ePtr->cachePtr;
    cachePtr->currentSize -= ePtr->size;
    if ((unsigned int )cachePtr->freeProc == (unsigned int )((Ns_Callback *)-1)) {
      Ns_CacheFree((Ns_Cache *)cachePtr, ePtr->value);
    } else {
      if ((unsigned int )cachePtr->freeProc != (unsigned int )((void *)0)) {
        ((*(cachePtr->freeProc)))(ePtr->value);
      }
    }
    ePtr->size = 0U;
    ePtr->value = (void *)0;
  }
  return;
}
}
void Ns_CacheDeleteEntry(Ns_Entry *entry ) 
{ Entry *ePtr ;

  {
  ePtr = (Entry *)entry;
  Delink(ePtr);
  Tcl_DeleteHashEntry(ePtr->hPtr);
  ns_free((void *)ePtr);
  return;
}
}
void Ns_CacheFlushEntry(Ns_Entry *entry ) 
{ Entry *ePtr ;

  {
  ePtr = (Entry *)entry;
  (ePtr->cachePtr)->nflush ++;
  Ns_CacheUnsetValue(entry);
  Ns_CacheDeleteEntry(entry);
  return;
}
}
Ns_Entry *Ns_CacheFirstEntry(Ns_Cache *cache , Ns_CacheSearch *search ) 
{ Tcl_HashSearch *sPtr ;
  Cache *cachePtr ;
  Tcl_HashEntry *hPtr ;

  {
  sPtr = search;
  cachePtr = (Cache *)cache;
  hPtr = Tcl_FirstHashEntry(& cachePtr->entriesTable, sPtr);
  if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
    return ((Ns_Entry *)((void *)0));
  }
  return ((Ns_Entry *)hPtr->clientData);
}
}
Ns_Entry *Ns_CacheNextEntry(Ns_CacheSearch *search ) 
{ Tcl_HashSearch *sPtr ;
  Tcl_HashEntry *hPtr ;

  {
  sPtr = search;
  hPtr = Tcl_NextHashEntry(sPtr);
  if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
    return ((Ns_Entry *)((void *)0));
  }
  return ((Ns_Entry *)hPtr->clientData);
}
}
void Ns_CacheFlush(Ns_Cache *cache ) 
{ Ns_CacheSearch search ;
  Ns_Entry *entry ;

  {
  entry = Ns_CacheFirstEntry(cache, & search);
  while ((unsigned int )entry != (unsigned int )((void *)0)) {
    Ns_CacheFlushEntry(entry);
    entry = Ns_CacheNextEntry(& search);
  }
  return;
}
}
void Ns_CacheLock(Ns_Cache *cache ) 
{ Cache *cachePtr ;

  {
  cachePtr = (Cache *)cache;
  Ns_MutexLock(& cachePtr->lock);
  return;
}
}
int Ns_CacheTryLock(Ns_Cache *cache ) 
{ Cache *cachePtr ;
  int tmp ;

  {
  cachePtr = (Cache *)cache;
  tmp = Ns_MutexTryLock(& cachePtr->lock);
  return (tmp);
}
}
void Ns_CacheUnlock(Ns_Cache *cache ) 
{ Cache *cachePtr ;

  {
  cachePtr = (Cache *)cache;
  Ns_MutexUnlock(& cachePtr->lock);
  return;
}
}
int Ns_CacheTimedWait(Ns_Cache *cache , Ns_Time *timePtr ) 
{ Cache *cachePtr ;
  int tmp ;

  {
  cachePtr = (Cache *)cache;
  tmp = Ns_CondTimedWait(& cachePtr->cond, & cachePtr->lock, timePtr);
  return (tmp);
}
}
void Ns_CacheWait(Ns_Cache *cache ) 
{ 

  {
  Ns_CacheTimedWait(cache, (Ns_Time *)((void *)0));
  return;
}
}
void Ns_CacheSignal(Ns_Cache *cache ) 
{ Cache *cachePtr ;

  {
  cachePtr = (Cache *)cache;
  Ns_CondSignal(& cachePtr->cond);
  return;
}
}
void Ns_CacheBroadcast(Ns_Cache *cache ) 
{ Cache *cachePtr ;

  {
  cachePtr = (Cache *)cache;
  Ns_CondBroadcast(& cachePtr->cond);
  return;
}
}
void NsCacheArgProc(Tcl_DString *dsPtr , void *arg ) 
{ Cache *cachePtr ;

  {
  cachePtr = (Cache *)arg;
  Tcl_DStringAppendElement(dsPtr, cachePtr->name);
  return;
}
}
int NsTclCacheNamesCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) 
{ Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  char *tmp ;

  {
  if (argc != 1) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), "\"", (void *)0);
    return (1);
  }
  Ns_MutexLock(& lock___0);
  hPtr = Tcl_FirstHashEntry(& caches, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    if (caches.keyType == 1) {
      tmp = hPtr->key.oneWordValue;
    } else {
      if (caches.keyType == -1) {
        tmp = hPtr->key.oneWordValue;
      } else {
        tmp = hPtr->key.string;
      }
    }
    Tcl_AppendElement(interp, tmp);
    hPtr = Tcl_NextHashEntry(& search);
  }
  Ns_MutexUnlock(& lock___0);
  return (0);
}
}
int NsTclCacheStatsCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) 
{ Cache *cachePtr ;
  char buf[200] ;
  int entries ;
  int flushed ;
  int hits ;
  int misses ;
  int total ;
  int hitrate ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  if (argc != 2) {
    if (argc != 3) {
      Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " cache ?arrayVar?\"",
                       (void *)0);
      return (1);
    }
  }
  tmp = GetCache(interp, (*(argv + 1)), & cachePtr);
  if (tmp != 0) {
    return (1);
  }
  Ns_MutexLock(& cachePtr->lock);
  entries = cachePtr->entriesTable.numEntries;
  flushed = (int )cachePtr->nflush;
  hits = (int )cachePtr->nhit;
  misses = (int )cachePtr->nmiss;
  total = (int )(cachePtr->nhit + cachePtr->nmiss);
  if (total) {
    hitrate = (int )((cachePtr->nhit * 100U) / (unsigned int )total);
  } else {
    hitrate = 0;
  }
  Ns_MutexUnlock(& cachePtr->lock);
  if (argc == 2) {
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"entries: %d  flushed: %d  hits: %d  misses: %d  hitrate: %d",
            entries, flushed, hits, misses, hitrate);
    Tcl_SetResult(interp, buf, (Tcl_FreeProc *)1);
  } else {
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", entries);
    tmp___0 = Tcl_SetVar2(interp, (*(argv + 2)), (char *)"entries", buf, 512);
    if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
      return (1);
    }
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", flushed);
    tmp___1 = Tcl_SetVar2(interp, (*(argv + 2)), (char *)"flushed", buf, 512);
    if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
      return (1);
    }
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", hits);
    tmp___2 = Tcl_SetVar2(interp, (*(argv + 2)), (char *)"hits", buf, 512);
    if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
      return (1);
    }
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", misses);
    tmp___3 = Tcl_SetVar2(interp, (*(argv + 2)), (char *)"misses", buf, 512);
    if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
      return (1);
    }
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", hitrate);
    tmp___4 = Tcl_SetVar2(interp, (*(argv + 2)), (char *)"hitrate", buf, 512);
    if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
      return (1);
    }
  }
  return (0);
}
}
int NsTclCacheFlushCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) 
{ Cache *cachePtr ;
  Ns_Cache *cache ;
  Ns_Entry *entry ;
  int tmp ;

  {
  if (argc != 2) {
    if (argc != 3) {
      Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " cache ?key?\"",
                       (void *)0);
      return (1);
    }
  }
  tmp = GetCache(interp, (*(argv + 1)), & cachePtr);
  if (tmp != 0) {
    return (1);
  }
  if (argc > 2) {
    if (cachePtr->keys != 0) {
      Tcl_AppendResult(interp, "cache keys not strings: ", (*(argv + 1)), (void *)0);
      return (1);
    }
  }
  cache = (Ns_Cache *)cachePtr;
  Ns_CacheLock(cache);
  if (argc == 2) {
    Ns_CacheFlush(cache);
  } else {
    entry = Ns_CacheFindEntry(cache, (*(argv + 2)));
    if ((unsigned int )entry == (unsigned int )((void *)0)) {
      Tcl_SetResult(interp, (char *)"0", (Tcl_FreeProc *)0);
    } else {
      Tcl_SetResult(interp, (char *)"1", (Tcl_FreeProc *)0);
      Ns_CacheFlushEntry(entry);
    }
  }
  Ns_CacheUnlock(cache);
  return (0);
}
}
int NsTclCacheSizeCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) 
{ Cache *cachePtr ;
  size_t maxSize ;
  size_t currentSize ;
  char buf[200] ;
  int tmp ;

  {
  if (argc != 2) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " cache\"",
                     (void *)0);
    return (1);
  }
  tmp = GetCache(interp, (*(argv + 1)), & cachePtr);
  if (tmp != 0) {
    return (1);
  }
  Ns_MutexLock(& cachePtr->lock);
  maxSize = cachePtr->maxSize;
  currentSize = cachePtr->currentSize;
  Ns_MutexUnlock(& cachePtr->lock);
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%ld %ld", (long )maxSize,
          (long )currentSize);
  Tcl_SetResult(interp, buf, (Tcl_FreeProc *)1);
  return (0);
}
}
int NsTclCacheKeysCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) 
{ Ns_Cache *cache ;
  Cache *cachePtr ;
  Ns_Entry *entry ;
  Ns_CacheSearch search ;
  char *pattern ;
  char *key___1 ;
  char *fmt ;
  char onebuf[20] ;
  int i ;
  int *iPtr ;
  Tcl_DString ds ;
  int tmp ;
  int tmp___0 ;

  {
  if (argc != 2) {
    if (argc != 3) {
      Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " cache ?pattern?\"",
                       (void *)0);
      return (1);
    }
  }
  pattern = (*(argv + 2));
  tmp = GetCache(interp, (*(argv + 1)), & cachePtr);
  if (tmp != 0) {
    return (1);
  }
  Tcl_DStringInit(& ds);
  cache = (Ns_Cache *)cachePtr;
  Ns_CacheLock(cache);
  entry = Ns_CacheFirstEntry(cache, & search);
  while ((unsigned int )entry != (unsigned int )((void *)0)) {
    key___1 = Ns_CacheKey(entry);
    if (cachePtr->keys == 1) {
      sprintf((char * __restrict  )(onebuf), (char const   * __restrict  )"%p", key___1);
      key___1 = onebuf;
    } else {
      if (cachePtr->keys != 0) {
        iPtr = (int *)key___1;
        fmt = (char *)"%u";
        Tcl_DStringSetLength(& ds, 0);
        i = 0;
        while (i < cachePtr->keys) {
          Ns_DStringPrintf(& ds, fmt, (*iPtr));
          iPtr ++;
          fmt = (char *)".%u";
          i ++;
        }
        key___1 = ds.string;
      }
    }
    if ((unsigned int )pattern == (unsigned int )((void *)0)) {
      Tcl_AppendElement(interp, key___1);
    } else {
      tmp___0 = Tcl_StringMatch(key___1, pattern);
      if (tmp___0) {
        Tcl_AppendElement(interp, key___1);
      }
    }
    entry = Ns_CacheNextEntry(& search);
  }
  Ns_CacheUnlock(cache);
  Tcl_DStringFree(& ds);
  return (0);
}
}
static Ns_Cache *CacheCreate(char *name , int keys , time_t timeout , size_t maxSize ,
                             Ns_Callback *freeProc ) 
{ Cache *cachePtr ;
  int new ;
  size_t tmp ;
  Cache *prevPtr ;

  {
  tmp = strlen((char const   *)name);
  cachePtr = (Cache *)ns_calloc(1U, sizeof(Cache ) + tmp);
  cachePtr->freeProc = freeProc;
  cachePtr->timeout = timeout;
  cachePtr->maxSize = maxSize;
  cachePtr->currentSize = 0U;
  cachePtr->keys = keys;
  strcpy((char * __restrict  )(cachePtr->name), (char const   * __restrict  )name);
  cachePtr->nmiss = 0U;
  cachePtr->nhit = cachePtr->nmiss;
  cachePtr->nflush = cachePtr->nhit;
  Ns_MutexSetName2(& cachePtr->lock, (char *)"ns:cache", name);
  Tcl_InitHashTable(& cachePtr->entriesTable, keys);
  if (timeout > 0L) {
    cachePtr->schedId = Ns_ScheduleProc(& NsCachePurge, (void *)cachePtr, 0, (int )timeout);
  } else {
    cachePtr->schedId = -1;
  }
  cachePtr->schedStop = 0;
  Ns_MutexLock(& lock___0);
  cachePtr->hPtr = ((*(caches.createProc)))(& caches, name, & new);
  if (! new) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"cache: duplicate cache name: %s",
           name);
    prevPtr = (Cache *)(cachePtr->hPtr)->clientData;
    prevPtr->hPtr = (Tcl_HashEntry *)((void *)0);
  }
  (cachePtr->hPtr)->clientData = (void *)cachePtr;
  Ns_MutexUnlock(& lock___0);
  return ((Ns_Cache *)cachePtr);
}
}
static void Delink(Entry *ePtr ) 
{ 

  {
  if ((unsigned int )ePtr->prevPtr != (unsigned int )((void *)0)) {
    (ePtr->prevPtr)->nextPtr = ePtr->nextPtr;
  } else {
    (ePtr->cachePtr)->firstEntryPtr = ePtr->nextPtr;
  }
  if ((unsigned int )ePtr->nextPtr != (unsigned int )((void *)0)) {
    (ePtr->nextPtr)->prevPtr = ePtr->prevPtr;
  } else {
    (ePtr->cachePtr)->lastEntryPtr = ePtr->prevPtr;
  }
  ePtr->nextPtr = (struct Entry *)((void *)0);
  ePtr->prevPtr = ePtr->nextPtr;
  return;
}
}
static void Push(Entry *ePtr ) 
{ 

  {
  if ((ePtr->cachePtr)->timeout > 0L) {
    Ns_GetTime(& ePtr->mtime);
  }
  if ((unsigned int )(ePtr->cachePtr)->firstEntryPtr != (unsigned int )((void *)0)) {
    ((ePtr->cachePtr)->firstEntryPtr)->prevPtr = ePtr;
  }
  ePtr->prevPtr = (struct Entry *)((void *)0);
  ePtr->nextPtr = (ePtr->cachePtr)->firstEntryPtr;
  (ePtr->cachePtr)->firstEntryPtr = ePtr;
  if ((unsigned int )(ePtr->cachePtr)->lastEntryPtr == (unsigned int )((void *)0)) {
    (ePtr->cachePtr)->lastEntryPtr = ePtr;
  }
  return;
}
}
static int GetCache(Tcl_Interp *interp , char *name , Cache **cachePtrPtr ) 
{ 

  {
  (*cachePtrPtr) = (Cache *)Ns_CacheFind(name);
  if ((unsigned int )(*cachePtrPtr) == (unsigned int )((void *)0)) {
    Tcl_AppendResult(interp, "no such cache: ", name, (void *)0);
    return (1);
  }
  return (0);
}
}
void NsCachePurge(void *arg ) 
{ Entry *ePtr ;
  Cache *cachePtr ;
  Ns_Time expired ;

  {
  cachePtr = (Cache *)arg;
  Ns_MutexLock(& cachePtr->lock);
  if (cachePtr->schedStop) {
    cachePtr->schedId = -1;
    Ns_CondBroadcast(& cachePtr->cond);
  } else {
    Ns_GetTime(& expired);
    Ns_IncrTime(& expired, - cachePtr->timeout, 0L);
    while (1) {
      ePtr = cachePtr->lastEntryPtr;
      if (! ((unsigned int )ePtr != (unsigned int )((void *)0))) {
        break;
      }
      if (ePtr->mtime.sec > expired.sec) {
        break;
      }
      if (ePtr->mtime.sec == expired.sec) {
        if (ePtr->mtime.usec > expired.usec) {
          break;
        }
      }
      Ns_CacheFlushEntry((Ns_Entry *)ePtr);
    }
  }
  Ns_MutexUnlock(& cachePtr->lock);
  return;
}
}
extern void Tcl_DStringEndSublist(Tcl_DString *dsPtr ) ;
extern void Tcl_DStringStartSublist(Tcl_DString *dsPtr ) ;
void Ns_ThreadCreate(Ns_ThreadProc *proc , void *arg , long stack , Ns_Thread *resultPtr ) ;
void Ns_ThreadJoin(Ns_Thread *thread , void **argPtr ) ;
void Ns_ThreadSetName(char *name ) ;
void *Ns_RegisterAtStartup(Ns_Callback *proc , void *arg ) ;
void *Ns_RegisterAtPreStartup(Ns_Callback *proc , void *arg ) ;
void *Ns_RegisterAtSignal(Ns_Callback *proc , void *arg ) ;
void *Ns_RegisterServerShutdown(char *ignored , Ns_Callback *proc , void *arg ) ;
void *Ns_RegisterShutdown(Ns_Callback *proc , void *arg ) ;
void *Ns_RegisterAtServerShutdown(Ns_Callback *proc , void *arg ) ;
void *Ns_RegisterAtShutdown(Ns_Callback *proc , void *arg ) ;
void *Ns_RegisterAtReady(Ns_Callback *proc , void *arg ) ;
void *Ns_RegisterAtExit(Ns_Callback *proc , void *arg ) ;
void Ns_GetProcInfo(Tcl_DString *dsPtr , void *procAddr , void *arg ) ;
void NsGetCallbacks(Tcl_DString *dsPtr ) ;
void NsRunPreStartupProcs(void) ;
void NsStartShutdownProcs(void) ;
void NsWaitShutdownProcs(Ns_Time *toPtr ) ;
void NsRunSignalProcs(void) ;
void NsRunStartupProcs(void) ;
void NsRunAtReadyProcs(void) ;
void NsRunAtExitProcs(void) ;
static void RunThread(void *arg ) ;
static void RunCallbacks(Callback *cbPtr ) ;
static void RunStart(Callback **firstPtrPtr , Ns_Thread *threadPtr ) ;
static void RunWait(Callback **firstPtrPtr , Ns_Thread *threadPtr , Ns_Time *toPtr ) ;
static void *RegisterAt(Callback **firstPtrPtr , Ns_Callback *proc , void *arg ) ;
static Callback *firstPreStartup  ;
static Callback *firstStartup  ;
static Callback *firstSignal  ;
static Callback *firstServerShutdown  ;
static Callback *firstShutdown  ;
static Callback *firstExit  ;
static Callback *firstReady  ;
static Ns_Mutex lock___1  ;
static Ns_Cond cond  ;
static int shutdownPending  ;
static Ns_Thread serverShutdownThread  ;
void *Ns_RegisterAtReady(Ns_Callback *proc , void *arg ) 
{ void *tmp ;

  {
  tmp = RegisterAt(& firstReady, proc, arg);
  return (tmp);
}
}
void NsRunAtReadyProcs(void) 
{ 

  {
  RunCallbacks(firstReady);
  return;
}
}
void *Ns_RegisterAtStartup(Ns_Callback *proc , void *arg ) 
{ void *tmp ;

  {
  tmp = RegisterAt(& firstStartup, proc, arg);
  return (tmp);
}
}
void *Ns_RegisterAtPreStartup(Ns_Callback *proc , void *arg ) 
{ void *tmp ;

  {
  tmp = RegisterAt(& firstPreStartup, proc, arg);
  return (tmp);
}
}
void *Ns_RegisterAtSignal(Ns_Callback *proc , void *arg ) 
{ void *tmp ;

  {
  tmp = RegisterAt(& firstSignal, proc, arg);
  return (tmp);
}
}
void *Ns_RegisterAtServerShutdown(Ns_Callback *proc , void *arg ) 
{ void *tmp ;

  {
  tmp = RegisterAt(& firstServerShutdown, proc, arg);
  return (tmp);
}
}
void *Ns_RegisterServerShutdown(char *ignored , Ns_Callback *proc , void *arg ) 
{ void *tmp ;

  {
  tmp = Ns_RegisterAtServerShutdown(proc, arg);
  return (tmp);
}
}
void *Ns_RegisterAtShutdown(Ns_Callback *proc , void *arg ) 
{ void *tmp ;

  {
  tmp = RegisterAt(& firstShutdown, proc, arg);
  return (tmp);
}
}
void *Ns_RegisterShutdown(Ns_Callback *proc , void *arg ) 
{ void *tmp ;

  {
  tmp = Ns_RegisterAtShutdown(proc, arg);
  return (tmp);
}
}
void *Ns_RegisterAtExit(Ns_Callback *proc , void *arg ) 
{ void *tmp ;

  {
  tmp = RegisterAt(& firstExit, proc, arg);
  return (tmp);
}
}
void NsRunStartupProcs(void) 
{ 

  {
  RunCallbacks(firstStartup);
  return;
}
}
void NsRunPreStartupProcs(void) 
{ 

  {
  RunCallbacks(firstPreStartup);
  return;
}
}
void NsRunSignalProcs(void) 
{ 

  {
  RunCallbacks(firstSignal);
  return;
}
}
void NsStartShutdownProcs(void) 
{ 

  {
  Ns_MutexLock(& lock___1);
  shutdownPending = 1;
  Ns_MutexUnlock(& lock___1);
  RunStart(& firstServerShutdown, & serverShutdownThread);
  return;
}
}
void NsWaitShutdownProcs(Ns_Time *toPtr ) 
{ Ns_Thread thread ;

  {
  RunWait(& firstServerShutdown, & serverShutdownThread, toPtr);
  RunStart(& firstShutdown, & thread);
  RunWait(& firstShutdown, & thread, toPtr);
  return;
}
}
void NsRunAtExitProcs(void) 
{ 

  {
  RunCallbacks(firstExit);
  return;
}
}
static int first  =    1;
static void *RegisterAt(Callback **firstPtrPtr , Ns_Callback *proc , void *arg ) 
{ Callback *cbPtr ;

  {
  cbPtr = (Callback *)ns_malloc(sizeof(Callback ));
  cbPtr->proc = proc;
  cbPtr->arg = arg;
  Ns_MutexLock(& lock___1);
  if (first) {
    Ns_MutexSetName(& lock___1, (char *)"ns:callbacks");
    first = 0;
  }
  if (shutdownPending) {
    ns_free((void *)cbPtr);
    cbPtr = (Callback *)((void *)0);
  } else {
    cbPtr->nextPtr = (*firstPtrPtr);
    (*firstPtrPtr) = cbPtr;
  }
  Ns_MutexUnlock(& lock___1);
  return ((void *)cbPtr);
}
}
static void RunCallbacks(Callback *cbPtr ) 
{ 

  {
  while ((unsigned int )cbPtr != (unsigned int )((void *)0)) {
    ((*(cbPtr->proc)))(cbPtr->arg);
    cbPtr = cbPtr->nextPtr;
  }
  return;
}
}
static void RunStart(Callback **firstPtrPtr , Ns_Thread *threadPtr ) 
{ 

  {
  Ns_MutexLock(& lock___1);
  if ((unsigned int )(*firstPtrPtr) != (unsigned int )((void *)0)) {
    Ns_ThreadCreate(& RunThread, (void *)firstPtrPtr, 0L, threadPtr);
  } else {
    (*threadPtr) = (struct Ns_Thread_ *)((void *)0);
  }
  Ns_MutexUnlock(& lock___1);
  return;
}
}
static void RunWait(Callback **firstPtrPtr , Ns_Thread *threadPtr , Ns_Time *toPtr ) 
{ int status ;

  {
  status = 0;
  Ns_MutexLock(& lock___1);
  while (1) {
    if (status == 0) {
      if (! ((unsigned int )(*firstPtrPtr) != (unsigned int )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    status = Ns_CondTimedWait(& cond, & lock___1, toPtr);
  }
  Ns_MutexUnlock(& lock___1);
  if (status != 0) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"callbacks: timeout waiting for shutdown procs");
  } else {
    if ((unsigned int )(*threadPtr) != (unsigned int )((void *)0)) {
      Ns_ThreadJoin(threadPtr, (void **)((void *)0));
    }
  }
  return;
}
}
static void RunThread(void *arg ) 
{ Callback **firstPtrPtr ;
  Callback *firstPtr___1 ;

  {
  firstPtrPtr = (Callback **)arg;
  Ns_ThreadSetName((char *)"-shutdown-");
  Ns_MutexLock(& lock___1);
  firstPtr___1 = (*firstPtrPtr);
  Ns_MutexUnlock(& lock___1);
  RunCallbacks(firstPtr___1);
  Ns_MutexLock(& lock___1);
  while ((unsigned int )(*firstPtrPtr) != (unsigned int )((void *)0)) {
    firstPtr___1 = (*firstPtrPtr);
    (*firstPtrPtr) = firstPtr___1->nextPtr;
    ns_free((void *)firstPtr___1);
  }
  Ns_CondSignal(& cond);
  Ns_MutexUnlock(& lock___1);
  return;
}
}
static void AppendList(Tcl_DString *dsPtr , char *list , Callback *firstPtr___1 ) 
{ Callback *cbPtr ;

  {
  cbPtr = firstPtr___1;
  while ((unsigned int )cbPtr != (unsigned int )((void *)0)) {
    Tcl_DStringStartSublist(dsPtr);
    Tcl_DStringAppendElement(dsPtr, list);
    Ns_GetProcInfo(dsPtr, (void *)cbPtr->proc, cbPtr->arg);
    Tcl_DStringEndSublist(dsPtr);
    cbPtr = cbPtr->nextPtr;
  }
  return;
}
}
void NsGetCallbacks(Tcl_DString *dsPtr ) 
{ 

  {
  Ns_MutexLock(& lock___1);
  AppendList(dsPtr, (char *)"prestartup", firstPreStartup);
  AppendList(dsPtr, (char *)"startup", firstStartup);
  AppendList(dsPtr, (char *)"signal", firstSignal);
  AppendList(dsPtr, (char *)"servershutdown", firstServerShutdown);
  AppendList(dsPtr, (char *)"shutdown", firstShutdown);
  AppendList(dsPtr, (char *)"exit", firstExit);
  Ns_MutexUnlock(& lock___1);
  return;
}
}
void Ns_MasterLock(void) ;
void Ns_MasterUnlock(void) ;
void Ns_ClsAlloc(Ns_Cls *clsPtr , Ns_Callback *cleanup ) ;
void *Ns_ClsGet(Ns_Cls *clsPtr , Ns_Conn *conn ) ;
void Ns_ClsSet(Ns_Cls *clsPtr , Ns_Conn *conn , void *value ) ;
void Ns_Fatal(char *fmt  , ...) ;
void NsClsCleanup(Conn *connPtr ) ;
static Ns_Callback *cleanupProcs[16]  ;
static void **GetSlot(Ns_Cls *clsPtr , Ns_Conn *conn ) ;
static int nextId  =    1;
void Ns_ClsAlloc(Ns_Cls *clsPtr , Ns_Callback *cleanup ) 
{ int id ;
  int tmp ;

  {
  Ns_MasterLock();
  if (nextId == 16) {
    Ns_Fatal((char *)"Ns_ClsAlloc: exceded max cls: %d", 16);
  }
  tmp = nextId;
  nextId ++;
  id = tmp;
  cleanupProcs[id] = cleanup;
  Ns_MasterUnlock();
  (*clsPtr) = (struct _Ns_Cls *)((void *)id);
  return;
}
}
void Ns_ClsSet(Ns_Cls *clsPtr , Ns_Conn *conn , void *value ) 
{ void **slotPtr ;

  {
  slotPtr = GetSlot(clsPtr, conn);
  (*slotPtr) = value;
  return;
}
}
void *Ns_ClsGet(Ns_Cls *clsPtr , Ns_Conn *conn ) 
{ void **slotPtr ;

  {
  slotPtr = GetSlot(clsPtr, conn);
  return ((*slotPtr));
}
}
void NsClsCleanup(Conn *connPtr ) 
{ int i ;
  int trys ;
  int retry ;
  void *arg ;
  int tmp ;
  int tmp___0 ;

  {
  trys = 0;
  while (1) {
    retry = 0;
    i = 16;
    while (1) {
      tmp = i;
      i --;
      if (! (tmp > 0)) {
        break;
      }
      if ((unsigned int )cleanupProcs[i] != (unsigned int )((void *)0)) {
        if ((unsigned int )connPtr->cls[i] != (unsigned int )((void *)0)) {
          arg = connPtr->cls[i];
          connPtr->cls[i] = (void *)0;
          ((*(cleanupProcs[i])))(arg);
          retry = 1;
        }
      }
    }
    if (retry) {
      tmp___0 = trys;
      trys ++;
      if (! (tmp___0 < 5)) {
        break;
      }
    } else {
      break;
    }
  }
  return;
}
}
static void **GetSlot(Ns_Cls *clsPtr , Ns_Conn *conn ) 
{ Conn *connPtr ;
  int idx ;

  {
  connPtr = (Conn *)conn;
  idx = (int )(*clsPtr);
  if (idx < 1) {
    Ns_Fatal((char *)"Ns_Cls: invalid key: %d: must be between 1 and %d", idx, 16);
  } else {
    if (idx >= 16) {
      Ns_Fatal((char *)"Ns_Cls: invalid key: %d: must be between 1 and %d", idx, 16);
    }
  }
  return (& connPtr->cls[idx]);
}
}
int Ns_Compress(char *buf , int len , Tcl_DString *outPtr , int level ) ;
extern int compress2(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ,
                     int level ) ;
extern uLong crc32(uLong crc , Bytef const   *buf , uInt len ) ;
static char header[10]  = 
  {      (char)31,      (char)-117,      (char)8,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)3};
int Ns_CompressGzip(char *buf , int len , Tcl_DString *outPtr , int level ) 
{ uLongf glen ;
  char *gbuf ;
  uLong crc ;
  int skip ;
  uint32_t footer[2] ;
  int tmp ;
  register unsigned int __v ;
  register unsigned int __x ;
  register unsigned int __v___0 ;
  register unsigned int __x___0 ;

  {
  glen = (unsigned long )(((unsigned int )((len + len / 100) + 13) + sizeof(header)) +
                          sizeof(footer));
  Tcl_DStringSetLength(outPtr, (int )glen);
  gbuf = outPtr->string;
  skip = (int )(sizeof(header) - 2U);
  glen -= (unsigned long )skip;
  tmp = compress2((Bytef *)(gbuf + skip), & glen, (Bytef const   *)buf, (unsigned long )len,
                  level);
  if (tmp != 0) {
    return (-1);
  }
  memcpy((void * __restrict  )gbuf, (void const   * __restrict  )(header), sizeof(header));
  Tcl_DStringSetLength(outPtr, (int )(glen + (unsigned long )skip));
  crc = crc32(0UL, (Bytef const   *)0, 0U);
  crc = crc32(crc, (Bytef const   *)buf, (unsigned int )len);
  __x = (unsigned int )crc;
  __asm__  ("rorw $8, %w0;"
            "rorl $16, %0;"
            "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
  footer[0] = __v;
  __x___0 = (unsigned int )len;
  __asm__  ("rorw $8, %w0;"
            "rorl $16, %0;"
            "rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
  footer[1] = __v___0;
  Tcl_DStringAppend(outPtr, (char *)(footer), (int )sizeof(footer));
  return (0);
}
}
int Ns_Compress(char *buf , int len , Tcl_DString *outPtr , int level ) 
{ int tmp ;

  {
  tmp = Ns_CompressGzip(buf, len, outPtr, level);
  return (tmp);
}
}
extern int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                  , ...) ;
extern Tcl_Command Tcl_CreateCommand(Tcl_Interp *interp , char *cmdName , Tcl_CmdProc *proc ,
                                     ClientData clientData , Tcl_CmdDeleteProc *deleteProc ) ;
extern int Tcl_Eval(Tcl_Interp *interp , char *string ) ;
extern char *Tcl_SetVar(Tcl_Interp *interp , char *varName , char *newValue , int flags ) ;
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
__inline static int tolower__extinline(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp___1 = __ctype_tolower_loc();
      tmp___0 = (*((*tmp___1) + __c));
    } else {
      tmp___0 = __c;
    }
  } else {
    tmp___0 = __c;
  }
  return (tmp___0);
}
}
char *Ns_ConfigGetValue(char *section , char *key___1 ) ;
char *Ns_ConfigGetValueExact(char *section , char *key___1 ) ;
int Ns_ConfigGetInt(char *section , char *key___1 , int *valuePtr ) ;
int Ns_ConfigGetInt64(char *section , char *key___1 , ns_int64 *valuePtr ) ;
int Ns_ConfigGetBool(char *section , char *key___1 , int *valuePtr ) ;
char *Ns_ConfigGetPath(char *server , char *module  , ...) ;
Ns_Set **Ns_ConfigGetSections(void) ;
Ns_Set *Ns_ConfigGetSection(char *section ) ;
void Ns_GetVersion(int *majorV , int *minorV , int *patchLevelV , int *type ) ;
Ns_Set *Ns_SetCreate(char *name ) ;
int Ns_SetPut(Ns_Set *set , char *key___1 , char *value ) ;
int Ns_SetFind(Ns_Set *set , char *key___1 ) ;
int Ns_SetIFind(Ns_Set *set , char *key___1 ) ;
Tcl_Interp *Ns_TclCreateInterp(void) ;
void Ns_TclDestroyInterp(Tcl_Interp *interp ) ;
struct _nsconf nsconf  ;
char *NsConfigRead(char *file___1 ) ;
void NsConfigEval(char *config , int argc , char **argv , int optind___0 ) ;
static int SectionCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
static int ParamCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
static Ns_Set *GetSection(char *section , int create ) ;
static char *ConfigGet(char *section , char *key___1 , int exact ) ;
char *Ns_ConfigGetValue(char *section , char *key___1 ) 
{ char *tmp ;

  {
  tmp = ConfigGet(section, key___1, 0);
  return (tmp);
}
}
char *Ns_ConfigGetValueExact(char *section , char *key___1 ) 
{ char *tmp ;

  {
  tmp = ConfigGet(section, key___1, 1);
  return (tmp);
}
}
int Ns_ConfigGetInt(char *section , char *key___1 , int *valuePtr ) 
{ char *s ;
  int tmp ;

  {
  s = Ns_ConfigGetValue(section, key___1);
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    return (0);
  } else {
    tmp = sscanf((char const   * __restrict  )s, (char const   * __restrict  )"%d",
                 valuePtr);
    if (tmp != 1) {
      return (0);
    }
  }
  return (1);
}
}
int Ns_ConfigGetInt64(char *section , char *key___1 , ns_int64 *valuePtr ) 
{ char *s ;
  int tmp ;

  {
  s = Ns_ConfigGetValue(section, key___1);
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    return (0);
  } else {
    tmp = sscanf((char const   * __restrict  )s, (char const   * __restrict  )"%lld",
                 valuePtr);
    if (tmp != 1) {
      return (0);
    }
  }
  return (1);
}
}
int Ns_ConfigGetBool(char *section , char *key___1 , int *valuePtr ) 
{ char *s ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
  s = Ns_ConfigGetValue(section, key___1);
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    return (0);
  }
  if ((int )(*s) == (int )(*"1")) {
    if (0) {
      __s1_len___0 = strlen((char const   *)s);
      __s2_len___0 = strlen("1");
      if (! ((unsigned int )((void const   *)(s + 1)) - (unsigned int )((void const   *)s) ==
             1U)) {
        goto _L___3;
      } else {
        if (__s1_len___0 >= 4U) {
          _L___3: 
          if (! ((unsigned int )((void const   *)("1" + 1)) - (unsigned int )((void const   *)"1") ==
                 1U)) {
            tmp___20 = 1;
          } else {
            if (__s2_len___0 >= 4U) {
              tmp___20 = 1;
            } else {
              tmp___20 = 0;
            }
          }
        } else {
          tmp___20 = 0;
        }
      }
      if (tmp___20) {
        if (__s1_len___0 < __s2_len___0) {
          tmp___18 = __s1_len___0;
        } else {
          tmp___18 = __s2_len___0;
        }
        tmp___17 = memcmp((void const   *)((char const   *)s), (void const   *)"1",
                          tmp___18 + 1U);
      } else {
        tmp___19 = strcmp((char const   *)s, "1");
        tmp___17 = tmp___19;
      }
    } else {
      tmp___19 = strcmp((char const   *)s, "1");
      tmp___17 = tmp___19;
    }
    if (tmp___17 == 0) {
      (*valuePtr) = 1;
    } else {
      goto _L___4;
    }
  } else {
    _L___4: 
    tmp___21 = strcasecmp((char const   *)s, "y");
    if (tmp___21 == 0) {
      (*valuePtr) = 1;
    } else {
      tmp___22 = strcasecmp((char const   *)s, "yes");
      if (tmp___22 == 0) {
        (*valuePtr) = 1;
      } else {
        tmp___23 = strcasecmp((char const   *)s, "on");
        if (tmp___23 == 0) {
          (*valuePtr) = 1;
        } else {
          tmp___24 = strcasecmp((char const   *)s, "t");
          if (tmp___24 == 0) {
            (*valuePtr) = 1;
          } else {
            tmp___25 = strcasecmp((char const   *)s, "true");
            if (tmp___25 == 0) {
              (*valuePtr) = 1;
            } else {
              if ((int )(*s) == (int )(*"0")) {
                if (0) {
                  __s1_len = strlen((char const   *)s);
                  __s2_len = strlen("0");
                  if (! ((unsigned int )((void const   *)(s + 1)) - (unsigned int )((void const   *)s) ==
                         1U)) {
                    goto _L___0;
                  } else {
                    if (__s1_len >= 4U) {
                      _L___0: 
                      if (! ((unsigned int )((void const   *)("0" + 1)) - (unsigned int )((void const   *)"0") ==
                             1U)) {
                        tmp___7 = 1;
                      } else {
                        if (__s2_len >= 4U) {
                          tmp___7 = 1;
                        } else {
                          tmp___7 = 0;
                        }
                      }
                    } else {
                      tmp___7 = 0;
                    }
                  }
                  if (tmp___7) {
                    if (__s1_len < __s2_len) {
                      tmp___5 = __s1_len;
                    } else {
                      tmp___5 = __s2_len;
                    }
                    tmp___4 = memcmp((void const   *)((char const   *)s), (void const   *)"0",
                                     tmp___5 + 1U);
                  } else {
                    tmp___6 = strcmp((char const   *)s, "0");
                    tmp___4 = tmp___6;
                  }
                } else {
                  tmp___6 = strcmp((char const   *)s, "0");
                  tmp___4 = tmp___6;
                }
                if (tmp___4 == 0) {
                  (*valuePtr) = 0;
                } else {
                  goto _L___1;
                }
              } else {
                _L___1: 
                tmp___8 = strcasecmp((char const   *)s, "n");
                if (tmp___8 == 0) {
                  (*valuePtr) = 0;
                } else {
                  tmp___9 = strcasecmp((char const   *)s, "no");
                  if (tmp___9 == 0) {
                    (*valuePtr) = 0;
                  } else {
                    tmp___10 = strcasecmp((char const   *)s, "off");
                    if (tmp___10 == 0) {
                      (*valuePtr) = 0;
                    } else {
                      tmp___11 = strcasecmp((char const   *)s, "f");
                      if (tmp___11 == 0) {
                        (*valuePtr) = 0;
                      } else {
                        tmp___12 = strcasecmp((char const   *)s, "false");
                        if (tmp___12 == 0) {
                          (*valuePtr) = 0;
                        } else {
                          tmp = sscanf((char const   * __restrict  )s, (char const   * __restrict  )"%d",
                                       valuePtr);
                          if (tmp != 1) {
                            return (0);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return (1);
}
}
char *Ns_ConfigGetPath(char *server , char *module  , ...) 
{ va_list ap ;
  char *s ;
  Tcl_DString ds ;
  Ns_Set *set ;
  char *tmp ;

  {
  Tcl_DStringInit(& ds);
  Tcl_DStringAppend(& ds, (char *)"ns", -1);
  if ((unsigned int )server != (unsigned int )((void *)0)) {
    Ns_DStringVarAppend(& ds, "/server/", server, (void *)0);
  }
  if ((unsigned int )module != (unsigned int )((void *)0)) {
    Ns_DStringVarAppend(& ds, "/module/", module, (void *)0);
  }
  __builtin_stdarg_start(ap, module);
  while (1) {
    s = __builtin_va_arg(ap, char *);
    if (! ((unsigned int )s != (unsigned int )((void *)0))) {
      break;
    }
    Tcl_DStringAppend(& ds, (char *)"/", -1);
    while (1) {
      if ((int )(*s) != 0) {
        if (! ((int )(*s) == 47)) {
          if (! ((int )(*s) == 92)) {
            break;
          }
        }
      } else {
        break;
      }
      s ++;
    }
    Tcl_DStringAppend(& ds, s, -1);
    while (1) {
      if (! ((int )(*(ds.string + (ds.length - 1))) == 47)) {
        if (! ((int )(*(ds.string + (ds.length - 1))) == 92)) {
          break;
        }
      }
      ds.length = ds.length - 1;
      (*(ds.string + ds.length)) = (char )'\000';
    }
  }
  __builtin_va_end(ap);
  set = Ns_ConfigGetSection(ds.string);
  Tcl_DStringFree(& ds);
  if (set) {
    tmp = set->name;
  } else {
    tmp = (char *)((void *)0);
  }
  return (tmp);
}
}
Ns_Set **Ns_ConfigGetSections(void) 
{ Ns_Set **sets ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  int n ;
  int tmp ;

  {
  n = nsconf.sections.numEntries + 1;
  sets = (Ns_Set **)ns_malloc(sizeof(Ns_Set *) * (unsigned int )n);
  n = 0;
  hPtr = Tcl_FirstHashEntry(& nsconf.sections, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    tmp = n;
    n ++;
    (*(sets + tmp)) = (Ns_Set *)hPtr->clientData;
    hPtr = Tcl_NextHashEntry(& search);
  }
  (*(sets + n)) = (Ns_Set *)((void *)0);
  return (sets);
}
}
Ns_Set *Ns_ConfigGetSection(char *section ) 
{ Ns_Set *tmp___0 ;

  {
  if (section) {
    tmp___0 = GetSection(section, 0);
  } else {
    tmp___0 = (Ns_Set *)((void *)0);
  }
  return (tmp___0);
}
}
void Ns_GetVersion(int *majorV , int *minorV , int *patchLevelV , int *type ) 
{ 

  {
  if ((unsigned int )majorV != (unsigned int )((void *)0)) {
    (*majorV) = 4;
  }
  if ((unsigned int )minorV != (unsigned int )((void *)0)) {
    (*minorV) = 0;
  }
  if ((unsigned int )patchLevelV != (unsigned int )((void *)0)) {
    (*patchLevelV) = 10;
  }
  if ((unsigned int )type != (unsigned int )((void *)0)) {
    (*type) = 2;
  }
  return;
}
}
char *NsConfigRead(char *file___1 ) 
{ struct stat st ;
  int fd ;
  char *buf ;
  size_t n ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  tmp___1 = stat__extinline((char const   *)file___1, & st);
  if (tmp___1 != 0) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Ns_Fatal((char *)"config: stat(%s) failed: %s", file___1, tmp___0);
  }
  if (((st.st_mode & 61440U) == 32768U) == 0) {
    Ns_Fatal((char *)"config: not regular file: %s", file___1);
  }
  fd = open((char const   *)file___1, 0);
  if (fd < 0) {
    tmp___2 = __errno_location();
    tmp___3 = strerror((*tmp___2));
    Ns_Fatal((char *)"config: open(%s) failed: %s", file___1, tmp___3);
  }
  n = (unsigned int )st.st_size;
  buf = (char *)ns_malloc(n + 1U);
  n = (size_t )read(fd, (void *)buf, n);
  if (n < 0U) {
    tmp___4 = __errno_location();
    tmp___5 = strerror((*tmp___4));
    Ns_Fatal((char *)"config: read(%s) failed: %s", file___1, tmp___5);
  }
  (*(buf + n)) = (char )'\000';
  close(fd);
  return (buf);
}
}
void NsConfigEval(char *config , int argc , char **argv , int optind___0 ) 
{ char buf[20] ;
  Tcl_Interp *interp ;
  Ns_Set *set ;
  int i ;
  int tmp ;

  {
  set = (Ns_Set *)((void *)0);
  interp = Ns_TclCreateInterp();
  Tcl_CreateCommand(interp, (char *)"ns_section", & SectionCmd, (void *)(& set), (Tcl_CmdDeleteProc *)((void *)0));
  Tcl_CreateCommand(interp, (char *)"ns_param", & ParamCmd, (void *)(& set), (Tcl_CmdDeleteProc *)((void *)0));
  i = 0;
  while ((unsigned int )(*(argv + i)) != (unsigned int )((void *)0)) {
    Tcl_SetVar(interp, (char *)"argv", (*(argv + i)), 13);
    i ++;
  }
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", argc);
  Tcl_SetVar(interp, (char *)"argc", buf, 1);
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", optind___0);
  Tcl_SetVar(interp, (char *)"optind", buf, 1);
  tmp = Tcl_Eval(interp, config);
  if (tmp != 0) {
    Ns_TclLogError(interp);
    Ns_Fatal((char *)"config error");
  }
  Ns_TclDestroyInterp(interp);
  return;
}
}
static char *ConfigGet(char *section , char *key___1 , int exact ) 
{ Ns_Set *set ;
  int i ;
  char *s ;

  {
  s = (char *)((void *)0);
  if ((unsigned int )section != (unsigned int )((void *)0)) {
    if ((unsigned int )key___1 != (unsigned int )((void *)0)) {
      set = Ns_ConfigGetSection(section);
      if ((unsigned int )set != (unsigned int )((void *)0)) {
        if (exact) {
          i = Ns_SetFind(set, key___1);
        } else {
          i = Ns_SetIFind(set, key___1);
        }
        if (i >= 0) {
          s = (set->fields + i)->value;
        }
      }
    }
  }
  return (s);
}
}
static int ParamCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ Ns_Set *set ;

  {
  if (argc != 3) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " key value",
                     (void *)0);
    return (1);
  }
  set = (*((Ns_Set **)arg));
  if ((unsigned int )set == (unsigned int )((void *)0)) {
    Tcl_AppendResult(interp, (*(argv + 0)), " not preceded by an ns_section command.",
                     (void *)0);
    return (1);
  }
  Ns_SetPut(set, (*(argv + 1)), (*(argv + 2)));
  return (0);
}
}
static int SectionCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ Ns_Set **set ;

  {
  if (argc != 2) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " sectionname",
                     (void *)0);
    return (1);
  }
  set = (Ns_Set **)arg;
  (*set) = GetSection((*(argv + 1)), 1);
  return (0);
}
}
static Ns_Set *GetSection(char *section , int create ) 
{ Tcl_DString ds ;
  Tcl_HashEntry *hPtr ;
  int new ;
  Ns_Set *set ;
  char *s ;
  unsigned short const   **tmp ;
  int __res ;
  __int32_t const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  Tcl_DStringInit(& ds);
  s = section;
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*s)))) & 8192)) {
      break;
    }
    s ++;
  }
  Tcl_DStringAppend(& ds, s, -1);
  s = ds.string;
  while ((int )(*s) != 0) {
    if ((int )(*s) == 92) {
      (*s) = (char )'/';
    } else {
      tmp___3 = __ctype_b_loc();
      if ((int const   )(*((*tmp___3) + (int )((unsigned char )(*s)))) & 256) {
        if (sizeof((unsigned char )(*s)) > 1U) {
          __res = tolower__extinline((int )((unsigned char )(*s)));
        } else {
          tmp___2 = __ctype_tolower_loc();
          __res = (*((*tmp___2) + (int )((unsigned char )(*s))));
        }
        (*s) = (char )__res;
      }
    }
    s ++;
  }
  while (1) {
    s --;
    if ((unsigned int )s > (unsigned int )ds.string) {
      tmp___4 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___4) + (int )((unsigned char )(*s)))) & 8192)) {
        break;
      }
    } else {
      break;
    }
    (*s) = (char )'\000';
  }
  section = ds.string;
  set = (Ns_Set *)((void *)0);
  if (! create) {
    hPtr = ((*(nsconf.sections.findProc)))(& nsconf.sections, section);
  } else {
    hPtr = ((*(nsconf.sections.createProc)))(& nsconf.sections, section, & new);
    if (new) {
      set = Ns_SetCreate(section);
      hPtr->clientData = (void *)set;
    }
  }
  if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    set = (Ns_Set *)hPtr->clientData;
  }
  Tcl_DStringFree(& ds);
  return (set);
}
}
extern void Tcl_AppendStringsToObj(Tcl_Obj *objPtr  , ...) ;
extern int Tcl_GetIndexFromObj(Tcl_Interp *interp , Tcl_Obj *objPtr , char **tablePtr ,
                               char *msg , int flags , int *indexPtr ) ;
extern void Tcl_SetDoubleObj(Tcl_Obj *objPtr , double doubleValue ) ;
extern void Tcl_SetIntObj(Tcl_Obj *objPtr , int intValue ) ;
extern void Tcl_SetLongObj(Tcl_Obj *objPtr , long longValue ) ;
extern int Tcl_Flush(Tcl_Channel chan ) ;
extern Tcl_Channel Tcl_GetChannel(Tcl_Interp *interp , char *chanName , int *modePtr ) ;
extern int Tcl_Write(Tcl_Channel chan , char *s , int slen ) ;
extern char *Tcl_GetEncodingName(Tcl_Encoding encoding ) ;
void Ns_SetLocationProc(char *server , Ns_LocationProc *procPtr ) ;
void Ns_SetConnLocationProc(Ns_LocationProc *procPtr ) ;
int Ns_ConnCopyToChannel(Ns_Conn *conn , size_t ncopy , Tcl_Channel chan ) ;
Tcl_Encoding Ns_ConnGetUrlEncoding(Ns_Conn *conn ) ;
int Ns_ConnModifiedSince(Ns_Conn *conn , time_t since ) ;
void Ns_ConnClearQuery(Ns_Conn *conn ) ;
Ns_Set *Ns_ConnOutputHeaders(Ns_Conn *conn ) ;
char *Ns_ConnAuthUser(Ns_Conn *conn ) ;
char *Ns_ConnAuthPasswd(Ns_Conn *conn ) ;
int Ns_ConnContentLength(Ns_Conn *conn ) ;
char *Ns_ConnContent(Ns_Conn *conn ) ;
int Ns_ConnResponseStatus(Ns_Conn *conn ) ;
int Ns_ConnContentSent(Ns_Conn *conn ) ;
int Ns_ConnResponseLength(Ns_Conn *conn ) ;
Ns_Time *Ns_ConnStartTime(Ns_Conn *conn ) ;
char *Ns_ConnPeer(Ns_Conn *conn ) ;
int Ns_ConnPeerPort(Ns_Conn *conn ) ;
char *Ns_ConnLocation(Ns_Conn *conn ) ;
char *Ns_ConnHost(Ns_Conn *conn ) ;
int Ns_ConnPort(Ns_Conn *conn ) ;
int Ns_ConnSock(Ns_Conn *conn ) ;
char *Ns_ConnDriverName(Ns_Conn *conn ) ;
void *Ns_ConnDriverContext(Ns_Conn *conn ) ;
int Ns_ConnGetWriteEncodedFlag(Ns_Conn *conn ) ;
void Ns_ConnSetWriteEncodedFlag(Ns_Conn *conn , int flag ) ;
void Ns_TclSetTimeObj(Tcl_Obj *objPtr , Ns_Time *timePtr ) ;
Tcl_Encoding Ns_GetEncoding(char *name ) ;
Tcl_Encoding Ns_GetCharsetEncoding(char *charset ) ;
int Ns_TclEnterSet(Tcl_Interp *interp , Ns_Set *set , int flags ) ;
time_t Ns_ParseHttpTime(char *str ) ;
NsServer *NsGetInitServer(void) ;
int NsIsIdConn(char *connId ) ;
static int GetChan(Tcl_Interp *interp , char *id , Tcl_Channel *chanPtr ) ;
static int GetIndices(Tcl_Interp *interp , Conn *connPtr , Tcl_Obj **objv , int *offPtr ,
                      int *lenPtr ) ;
Ns_Set *Ns_ConnHeaders(Ns_Conn *conn ) 
{ 

  {
  return (conn->headers);
}
}
Ns_Set *Ns_ConnOutputHeaders(Ns_Conn *conn ) 
{ 

  {
  return (conn->outputheaders);
}
}
char *Ns_ConnAuthUser(Ns_Conn *conn ) 
{ 

  {
  return (conn->authUser);
}
}
char *Ns_ConnAuthPasswd(Ns_Conn *conn ) 
{ 

  {
  return (conn->authPasswd);
}
}
int Ns_ConnContentLength(Ns_Conn *conn ) 
{ 

  {
  return (conn->contentLength);
}
}
char *Ns_ConnContent(Ns_Conn *conn ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  return ((connPtr->reqPtr)->content);
}
}
char *Ns_ConnServer(Ns_Conn *conn ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  return (connPtr->server);
}
}
int Ns_ConnResponseStatus(Ns_Conn *conn ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  return (connPtr->responseStatus);
}
}
int Ns_ConnContentSent(Ns_Conn *conn ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  return (connPtr->nContentSent);
}
}
int Ns_ConnResponseLength(Ns_Conn *conn ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  return (connPtr->responseLength);
}
}
char *Ns_ConnPeer(Ns_Conn *conn ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  return ((connPtr->reqPtr)->peer);
}
}
int Ns_ConnPeerPort(Ns_Conn *conn ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  return ((connPtr->reqPtr)->port);
}
}
void Ns_SetConnLocationProc(Ns_LocationProc *procPtr ) 
{ NsServer *servPtr ;
  NsServer *tmp ;

  {
  tmp = NsGetInitServer();
  servPtr = tmp;
  if ((unsigned int )servPtr != (unsigned int )((void *)0)) {
    servPtr->locationProc = procPtr;
  }
  return;
}
}
void Ns_SetLocationProc(char *server , Ns_LocationProc *procPtr ) 
{ NsServer *servPtr ;
  NsServer *tmp ;

  {
  tmp = NsGetServer(server);
  servPtr = tmp;
  if ((unsigned int )servPtr != (unsigned int )((void *)0)) {
    servPtr->locationProc = procPtr;
  }
  return;
}
}
char *Ns_ConnLocation(Ns_Conn *conn ) 
{ Conn *connPtr ;
  NsServer *servPtr ;
  char *location ;

  {
  connPtr = (Conn *)conn;
  servPtr = connPtr->servPtr;
  if ((unsigned int )servPtr->locationProc != (unsigned int )((void *)0)) {
    location = ((*(servPtr->locationProc)))(conn);
  } else {
    location = connPtr->location;
  }
  return (location);
}
}
char *Ns_ConnHost(Ns_Conn *conn ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  return ((connPtr->drvPtr)->address);
}
}
int Ns_ConnPort(Ns_Conn *conn ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  return ((connPtr->drvPtr)->port);
}
}
int Ns_ConnSock(Ns_Conn *conn ) 
{ Conn *connPtr ;
  int tmp ;

  {
  connPtr = (Conn *)conn;
  if (connPtr->sockPtr) {
    tmp = (connPtr->sockPtr)->sock;
  } else {
    tmp = -1;
  }
  return (tmp);
}
}
char *Ns_ConnDriverName(Ns_Conn *conn ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  return ((connPtr->drvPtr)->name);
}
}
void *Ns_ConnDriverContext(Ns_Conn *conn ) 
{ Conn *connPtr ;
  void *tmp ;

  {
  connPtr = (Conn *)conn;
  if (connPtr->sockPtr) {
    tmp = (connPtr->sockPtr)->arg;
  } else {
    tmp = (void *)0;
  }
  return (tmp);
}
}
Ns_Time *Ns_ConnStartTime(Ns_Conn *conn ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  return (& connPtr->startTime);
}
}
int Ns_ConnId(Ns_Conn *conn ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  return (connPtr->id);
}
}
int Ns_ConnModifiedSince(Ns_Conn *conn , time_t since ) 
{ Conn *connPtr ;
  char *hdr ;
  time_t tmp ;

  {
  connPtr = (Conn *)conn;
  if ((connPtr->servPtr)->opts.modsince) {
    hdr = Ns_SetIGet(conn->headers, (char *)"If-Modified-Since");
    if ((unsigned int )hdr != (unsigned int )((void *)0)) {
      tmp = Ns_ParseHttpTime(hdr);
      if (tmp >= since) {
        return (0);
      }
    }
  }
  return (1);
}
}
Tcl_Encoding Ns_ConnGetEncoding(Ns_Conn *conn ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  return (connPtr->encoding);
}
}
void Ns_ConnSetEncoding(Ns_Conn *conn , Tcl_Encoding encoding ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  connPtr->encoding = encoding;
  return;
}
}
Tcl_Encoding Ns_ConnGetUrlEncoding(Ns_Conn *conn ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  return (connPtr->urlEncoding);
}
}
void Ns_ConnSetUrlEncoding(Ns_Conn *conn , Tcl_Encoding encoding ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  connPtr->urlEncoding = encoding;
  return;
}
}
int NsIsIdConn(char *connId ) 
{ 

  {
  if ((unsigned int )connId == (unsigned int )((void *)0)) {
    return (0);
  } else {
    if ((int )(*connId) != 99) {
      return (0);
    }
  }
  return (1);
}
}
int Ns_ConnGetWriteEncodedFlag(Ns_Conn *conn ) 
{ 

  {
  return (conn->flags & 64);
}
}
void Ns_ConnSetWriteEncodedFlag(Ns_Conn *conn , int flag ) 
{ 

  {
  if (flag) {
    conn->flags = conn->flags | 64;
  } else {
    conn->flags = conn->flags & -65;
  }
  return;
}
}
int NsTclConnObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
static char *opts[38]  = 
  {      (char *)"authpassword",      (char *)"authuser",      (char *)"close",      (char *)"content", 
        (char *)"contentlength",      (char *)"copy",      (char *)"driver",      (char *)"encoding", 
        (char *)"files",      (char *)"fileoffset",      (char *)"filelength",      (char *)"fileheaders", 
        (char *)"flags",      (char *)"form",      (char *)"headers",      (char *)"host", 
        (char *)"id",      (char *)"isconnected",      (char *)"location",      (char *)"method", 
        (char *)"outputheaders",      (char *)"peeraddr",      (char *)"peerport",      (char *)"port", 
        (char *)"protocol",      (char *)"query",      (char *)"request",      (char *)"server", 
        (char *)"sock",      (char *)"start",      (char *)"status",      (char *)"url", 
        (char *)"urlc",      (char *)"urlencoding",      (char *)"urlv",      (char *)"version", 
        (char *)"write_encoded",      (char *)((void *)0)};
int NsTclConnObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  Ns_Conn *conn ;
  Conn *connPtr ;
  Ns_Set *form ;
  Ns_Request *request ;
  Tcl_Encoding encoding ;
  Tcl_Channel chan ;
  Tcl_Obj *result ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  FormFile *filePtr ;
  int idx ;
  int off ;
  int len ;
  int write_encoded_flag ;
  int opt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc < 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"option");
    return (1);
  }
  tmp = Tcl_GetIndexFromObj(interp, (*(objv + 1)), opts, (char *)"option", 0, & opt);
  if (tmp != 0) {
    return (1);
  }
  result = Tcl_GetObjResult(interp);
  conn = (Ns_Conn *)((Conn *)itPtr->conn);
  connPtr = (Conn *)conn;
  if (opt == 17) {
    if (connPtr) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    Tcl_SetBooleanObj(result, tmp___0);
    return (0);
  }
  if ((unsigned int )connPtr == (unsigned int )((void *)0)) {
    Tcl_SetResult(interp, (char *)"no current connection", (Tcl_FreeProc *)0);
    return (1);
  }
  request = connPtr->request;
  switch (opt) {
  case 17: ;
  break;
  case 34: ;
  if (objc == 2) {
    goto _L;
  } else {
    if (objc == 3) {
      tmp___2 = Tcl_GetString((*(objv + 2)));
      tmp___3 = NsIsIdConn(tmp___2);
      if (tmp___3) {
        _L: 
        idx = 0;
        while (idx < request->urlc) {
          Tcl_AppendElement(interp, (*(request->urlv + idx)));
          idx ++;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      tmp___1 = Tcl_GetIntFromObj(interp, (*(objv + 2)), & idx);
      if (tmp___1 != 0) {
        return (1);
      } else {
        if (idx >= 0) {
          if (idx < request->urlc) {
            Tcl_SetResult(interp, (*(request->urlv + idx)), (Tcl_FreeProc *)0);
          }
        }
      }
    }
  }
  break;
  case 1: 
  Tcl_SetResult(interp, connPtr->authUser, (Tcl_FreeProc *)0);
  break;
  case 0: 
  Tcl_SetResult(interp, connPtr->authPasswd, (Tcl_FreeProc *)0);
  break;
  case 3: ;
  if (objc != 2) {
    if (objc != 4) {
      Tcl_WrongNumArgs(interp, 2, objv, (char *)"?off len?");
      return (1);
    }
  }
  if (objc == 2) {
    tmp___4 = Ns_ConnContent(conn);
    Tcl_SetResult(interp, tmp___4, (Tcl_FreeProc *)0);
  } else {
    tmp___5 = GetIndices(interp, connPtr, objv + 2, & off, & len);
    if (tmp___5 != 0) {
      return (1);
    }
    tmp___6 = Ns_ConnContent(conn);
    result = Tcl_NewStringObj(tmp___6 + off, len);
    Tcl_SetObjResult(interp, result);
  }
  break;
  case 4: 
  Tcl_SetIntObj(result, conn->contentLength);
  break;
  case 7: ;
  if (objc > 2) {
    tmp___7 = Tcl_GetString((*(objv + 2)));
    encoding = Ns_GetEncoding(tmp___7);
    if ((unsigned int )encoding == (unsigned int )((void *)0)) {
      tmp___8 = Tcl_GetString((*(objv + 2)));
      Tcl_AppendResult(interp, "no such encoding: ", tmp___8, (void *)0);
      return (1);
    }
    connPtr->encoding = encoding;
  }
  if ((unsigned int )connPtr->encoding != (unsigned int )((void *)0)) {
    tmp___9 = Tcl_GetEncodingName(connPtr->encoding);
    Tcl_SetResult(interp, tmp___9, (Tcl_FreeProc *)0);
  }
  break;
  case 33: ;
  if (objc > 2) {
    tmp___10 = Tcl_GetString((*(objv + 2)));
    encoding = Ns_GetEncoding(tmp___10);
    if ((unsigned int )encoding == (unsigned int )((void *)0)) {
      tmp___11 = Tcl_GetString((*(objv + 2)));
      Tcl_AppendResult(interp, "no such encoding: ", tmp___11, (void *)0);
      return (1);
    }
    if ((unsigned int )connPtr->urlEncoding != (unsigned int )encoding) {
      if (itPtr->nsconn.flags & 1) {
        Ns_ConnClearQuery(conn);
        itPtr->nsconn.flags = itPtr->nsconn.flags ^ 1;
      }
    }
    connPtr->urlEncoding = encoding;
  }
  if ((unsigned int )connPtr->urlEncoding != (unsigned int )((void *)0)) {
    tmp___12 = Tcl_GetEncodingName(connPtr->urlEncoding);
    Tcl_SetResult(interp, tmp___12, (Tcl_FreeProc *)0);
  }
  break;
  case 21: 
  tmp___13 = Ns_ConnPeer(conn);
  Tcl_SetResult(interp, tmp___13, (Tcl_FreeProc *)0);
  break;
  case 22: 
  tmp___14 = Ns_ConnPeerPort(conn);
  Tcl_SetIntObj(result, tmp___14);
  break;
  case 14: ;
  if (itPtr->nsconn.flags & 2) {
    Tcl_SetResult(interp, itPtr->nsconn.hdrs, (Tcl_FreeProc *)0);
  } else {
    Ns_TclEnterSet(interp, connPtr->headers, 0);
    tmp___15 = Tcl_GetStringResult(interp);
    strcpy((char * __restrict  )(itPtr->nsconn.hdrs), (char const   * __restrict  )tmp___15);
    itPtr->nsconn.flags = itPtr->nsconn.flags | 2;
  }
  break;
  case 20: ;
  if (itPtr->nsconn.flags & 4) {
    Tcl_SetResult(interp, itPtr->nsconn.outhdrs, (Tcl_FreeProc *)0);
  } else {
    Ns_TclEnterSet(interp, connPtr->outputheaders, 0);
    tmp___16 = Tcl_GetStringResult(interp);
    strcpy((char * __restrict  )(itPtr->nsconn.outhdrs), (char const   * __restrict  )tmp___16);
    itPtr->nsconn.flags = itPtr->nsconn.flags | 4;
  }
  break;
  case 13: ;
  if (itPtr->nsconn.flags & 1) {
    Tcl_SetResult(interp, itPtr->nsconn.form, (Tcl_FreeProc *)0);
  } else {
    form = Ns_ConnGetQuery(conn);
    if ((unsigned int )form == (unsigned int )((void *)0)) {
      itPtr->nsconn.form[0] = (char )'\000';
    } else {
      Ns_TclEnterSet(interp, form, 0);
      tmp___17 = Tcl_GetStringResult(interp);
      strcpy((char * __restrict  )(itPtr->nsconn.form), (char const   * __restrict  )tmp___17);
    }
    itPtr->nsconn.flags = itPtr->nsconn.flags | 1;
  }
  break;
  case 8: ;
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)((void *)0));
    return (1);
  }
  hPtr = Tcl_FirstHashEntry(& connPtr->files, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    if (connPtr->files.keyType == 1) {
      tmp___18 = hPtr->key.oneWordValue;
    } else {
      if (connPtr->files.keyType == -1) {
        tmp___18 = hPtr->key.oneWordValue;
      } else {
        tmp___18 = hPtr->key.string;
      }
    }
    Tcl_AppendElement(interp, tmp___18);
    hPtr = Tcl_NextHashEntry(& search);
  }
  break;
  case 9: ;
  case 10: ;
  case 11: ;
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)((void *)0));
    return (1);
  }
  tmp___19 = Tcl_GetString((*(objv + 2)));
  hPtr = ((*(connPtr->files.findProc)))(& connPtr->files, tmp___19);
  if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
    tmp___20 = Tcl_GetString((*(objv + 2)));
    Tcl_AppendResult(interp, "no such file: ", tmp___20, (void *)0);
    return (1);
  }
  filePtr = (FormFile *)hPtr->clientData;
  if (opt == 9) {
    Tcl_SetLongObj(result, filePtr->off);
  } else {
    if (opt == 10) {
      Tcl_SetLongObj(result, filePtr->len);
    } else {
      Ns_TclEnterSet(interp, filePtr->hdrs, 0);
    }
  }
  break;
  case 5: ;
  if (objc != 5) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"off len chan");
    return (1);
  }
  tmp___21 = GetIndices(interp, connPtr, objv + 2, & off, & len);
  if (tmp___21 != 0) {
    return (1);
  } else {
    tmp___22 = Tcl_GetString((*(objv + 4)));
    tmp___23 = GetChan(interp, tmp___22, & chan);
    if (tmp___23 != 0) {
      return (1);
    }
  }
  tmp___27 = Tcl_Write(chan, (connPtr->reqPtr)->content + off, len);
  if (tmp___27 != len) {
    tmp___24 = Tcl_PosixError(interp);
    tmp___25 = Tcl_GetString((*(objv + 4)));
    tmp___26 = Tcl_GetString((*(objv + 3)));
    Tcl_AppendResult(interp, "could not write ", tmp___26, " bytes to ", tmp___25,
                     ": ", tmp___24, (void *)0);
    return (1);
  }
  break;
  case 36: ;
  if (objc > 2) {
    tmp___28 = Tcl_GetIntFromObj(interp, (*(objv + 2)), & write_encoded_flag);
    if (tmp___28 != 0) {
      Tcl_AppendResult(interp, "Invalid write-encoded flag", (void *)0);
      return (1);
    }
    Ns_ConnSetWriteEncodedFlag(conn, write_encoded_flag);
  }
  tmp___29 = Ns_ConnGetWriteEncodedFlag(conn);
  if (tmp___29) {
    Tcl_AppendResult(interp, "1", (void *)0);
  } else {
    Tcl_AppendResult(interp, "0", (void *)0);
  }
  break;
  case 26: 
  Tcl_SetResult(interp, request->line, (Tcl_FreeProc *)0);
  break;
  case 19: 
  Tcl_SetResult(interp, request->method, (Tcl_FreeProc *)0);
  break;
  case 24: 
  Tcl_SetResult(interp, request->protocol, (Tcl_FreeProc *)0);
  break;
  case 15: 
  Tcl_SetResult(interp, request->host, (Tcl_FreeProc *)0);
  break;
  case 23: 
  Tcl_SetIntObj(result, (int )request->port);
  break;
  case 31: 
  Tcl_SetResult(interp, request->url, (Tcl_FreeProc *)0);
  break;
  case 25: 
  Tcl_SetResult(interp, request->query, (Tcl_FreeProc *)0);
  break;
  case 32: 
  Tcl_SetIntObj(result, request->urlc);
  break;
  case 35: 
  Tcl_SetDoubleObj(result, request->version);
  break;
  case 18: 
  tmp___30 = Ns_ConnLocation(conn);
  Tcl_SetResult(interp, tmp___30, (Tcl_FreeProc *)0);
  break;
  case 6: 
  tmp___31 = Ns_ConnDriverName(conn);
  Tcl_SetResult(interp, tmp___31, (Tcl_FreeProc *)0);
  break;
  case 27: 
  tmp___32 = Ns_ConnServer(conn);
  Tcl_SetResult(interp, tmp___32, (Tcl_FreeProc *)0);
  break;
  case 30: 
  tmp___33 = Ns_ConnResponseStatus(conn);
  Tcl_SetIntObj(result, tmp___33);
  break;
  case 28: 
  tmp___34 = Ns_ConnSock(conn);
  Tcl_SetIntObj(result, tmp___34);
  break;
  case 16: 
  tmp___35 = Ns_ConnId(conn);
  Tcl_SetIntObj(result, tmp___35);
  break;
  case 12: 
  Tcl_SetIntObj(result, connPtr->flags);
  break;
  case 29: 
  Ns_TclSetTimeObj(result, & connPtr->startTime);
  break;
  case 2: 
  tmp___36 = Ns_ConnClose(conn);
  if (tmp___36 != 0) {
    Tcl_SetResult(interp, (char *)"could not close connection", (Tcl_FreeProc *)0);
    return (1);
  }
  break;
  }
  return (0);
}
}
int NsTclWriteContentObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  Tcl_Channel chan ;
  char *tmp ;
  Tcl_Obj *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 2) {
    if (objc != 3) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?connid? channel");
      return (1);
    }
  }
  if (objc == 3) {
    tmp___1 = Tcl_GetString((*(objv + 1)));
    tmp___2 = NsIsIdConn(tmp___1);
    if (! tmp___2) {
      tmp = Tcl_GetString((*(objv + 1)));
      tmp___0 = Tcl_GetObjResult(interp);
      Tcl_AppendStringsToObj(tmp___0, "bad connid: \"", tmp, "\"", (void *)0);
      return (1);
    }
  }
  if ((unsigned int )itPtr->conn == (unsigned int )((void *)0)) {
    Tcl_SetResult(interp, (char *)"no connection", (Tcl_FreeProc *)0);
    return (1);
  }
  tmp___3 = Tcl_GetString((*(objv + (objc - 1))));
  tmp___4 = GetChan(interp, tmp___3, & chan);
  if (tmp___4 != 0) {
    return (1);
  }
  Tcl_Flush(chan);
  tmp___5 = Ns_ConnCopyToChannel(itPtr->conn, (unsigned int )(itPtr->conn)->contentLength,
                                 chan);
  if (tmp___5 != 0) {
    Tcl_SetResult(interp, (char *)"could not copy content (likely client disconnect)",
                  (Tcl_FreeProc *)0);
    return (1);
  }
  return (0);
}
}
int NsTclStartContentObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  Tcl_Encoding encoding ;
  char *opt ;
  int status ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  size_t tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
  itPtr = (NsInterp *)arg;
  status = 0;
  encoding = (struct Tcl_Encoding_ *)((void *)0);
  i = 1;
  while (1) {
    if (i < objc) {
      if (! (status == 0)) {
        break;
      }
    } else {
      break;
    }
    opt = Tcl_GetString((*(objv + i)));
    if ((int )(*opt) == (int )(*"-charset")) {
      if (0) {
        __s1_len___0 = strlen((char const   *)opt);
        __s2_len___0 = strlen("-charset");
        if (! ((unsigned int )((void const   *)(opt + 1)) - (unsigned int )((void const   *)opt) ==
               1U)) {
          goto _L___2;
        } else {
          if (__s1_len___0 >= 4U) {
            _L___2: 
            if (! ((unsigned int )((void const   *)("-charset" + 1)) - (unsigned int )((void const   *)"-charset") ==
                   1U)) {
              tmp___23 = 1;
            } else {
              if (__s2_len___0 >= 4U) {
                tmp___23 = 1;
              } else {
                tmp___23 = 0;
              }
            }
          } else {
            tmp___23 = 0;
          }
        }
        if (tmp___23) {
          if (__s1_len___0 < __s2_len___0) {
            tmp___21 = __s1_len___0;
          } else {
            tmp___21 = __s2_len___0;
          }
          tmp___20 = memcmp((void const   *)((char const   *)opt), (void const   *)"-charset",
                            tmp___21 + 1U);
        } else {
          tmp___22 = strcmp((char const   *)opt, "-charset");
          tmp___20 = tmp___22;
        }
      } else {
        tmp___22 = strcmp((char const   *)opt, "-charset");
        tmp___20 = tmp___22;
      }
      if (tmp___20 == 0) {
        if ((unsigned int )encoding != (unsigned int )((void *)0)) {
          tmp = Tcl_GetString((*(objv + 0)));
          Tcl_AppendResult(interp, tmp, ": charset may only be specified by one flag",
                           (void *)0);
          status = 1;
        }
        i ++;
        if (i >= objc) {
          tmp___0 = Tcl_GetString((*(objv + 0)));
          Tcl_AppendResult(interp, tmp___0, ": missing argument for -charset flag",
                           (void *)0);
          status = 1;
        }
        tmp___1 = Tcl_GetString((*(objv + i)));
        encoding = Ns_GetCharsetEncoding(tmp___1);
        if ((unsigned int )encoding == (unsigned int )((void *)0)) {
          tmp___2 = Tcl_GetString((*(objv + i)));
          tmp___3 = Tcl_GetString((*(objv + 0)));
          Tcl_AppendResult(interp, tmp___3, ": could not find an encoding for charset ",
                           tmp___2, (void *)0);
          status = 1;
        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: 
      if ((int )(*opt) == (int )(*"-type")) {
        if (0) {
          __s1_len = strlen((char const   *)opt);
          __s2_len = strlen("-type");
          if (! ((unsigned int )((void const   *)(opt + 1)) - (unsigned int )((void const   *)opt) ==
                 1U)) {
            goto _L___0;
          } else {
            if (__s1_len >= 4U) {
              _L___0: 
              if (! ((unsigned int )((void const   *)("-type" + 1)) - (unsigned int )((void const   *)"-type") ==
                     1U)) {
                tmp___15 = 1;
              } else {
                if (__s2_len >= 4U) {
                  tmp___15 = 1;
                } else {
                  tmp___15 = 0;
                }
              }
            } else {
              tmp___15 = 0;
            }
          }
          if (tmp___15) {
            if (__s1_len < __s2_len) {
              tmp___13 = __s1_len;
            } else {
              tmp___13 = __s2_len;
            }
            tmp___12 = memcmp((void const   *)((char const   *)opt), (void const   *)"-type",
                              tmp___13 + 1U);
          } else {
            tmp___14 = strcmp((char const   *)opt, "-type");
            tmp___12 = tmp___14;
          }
        } else {
          tmp___14 = strcmp((char const   *)opt, "-type");
          tmp___12 = tmp___14;
        }
        if (tmp___12 == 0) {
          if ((unsigned int )encoding != (unsigned int )((void *)0)) {
            tmp___4 = Tcl_GetString((*(objv + 0)));
            Tcl_AppendResult(interp, tmp___4, ": charset may only be specified by one flag",
                             (void *)0);
            status = 1;
          }
          i ++;
          if (i >= objc) {
            tmp___5 = Tcl_GetString((*(objv + 0)));
            Tcl_AppendResult(interp, tmp___5, ": missing argument for -type flag",
                             (void *)0);
            status = 1;
          }
          tmp___6 = Tcl_GetString((*(objv + i)));
          encoding = Ns_GetTypeEncoding(tmp___6);
        } else {
          tmp___7 = Tcl_GetString((*(objv + 0)));
          Tcl_AppendResult(interp, "usage: ", tmp___7, " ?-charset charsetname? ?-type content-type?",
                           (void *)0);
          status = 1;
        }
      } else {
        tmp___7 = Tcl_GetString((*(objv + 0)));
        Tcl_AppendResult(interp, "usage: ", tmp___7, " ?-charset charsetname? ?-type content-type?",
                         (void *)0);
        status = 1;
      }
    }
    i ++;
  }
  if (status != 0) {
    return (status);
  }
  Ns_ConnSetWriteEncodedFlag(itPtr->conn, 1);
  Ns_ConnSetEncoding(itPtr->conn, encoding);
  return (status);
}
}
static int GetChan(Tcl_Interp *interp , char *id , Tcl_Channel *chanPtr ) 
{ Tcl_Channel chan ;
  int mode ;

  {
  chan = Tcl_GetChannel(interp, id, & mode);
  if ((unsigned int )chan == (unsigned int )((struct Tcl_Channel_ *)((void *)0))) {
    return (1);
  }
  if ((mode & 4) == 0) {
    Tcl_AppendResult(interp, "channel \"", id, "\" wasn\'t opened for writing", (char *)((void *)0));
    return (1);
  }
  (*chanPtr) = chan;
  return (0);
}
}
static int GetIndices(Tcl_Interp *interp , Conn *connPtr , Tcl_Obj **objv , int *offPtr ,
                      int *lenPtr ) 
{ int off ;
  int len ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  tmp = Tcl_GetIntFromObj(interp, (*(objv + 0)), & off);
  if (tmp != 0) {
    return (1);
  } else {
    tmp___0 = Tcl_GetIntFromObj(interp, (*(objv + 1)), & len);
    if (tmp___0 != 0) {
      return (1);
    }
  }
  if (off < 0) {
    tmp___1 = Tcl_GetString((*(objv + 0)));
    Tcl_AppendResult(interp, "invalid offset: ", tmp___1, (void *)0);
    return (1);
  } else {
    if (off > (connPtr->reqPtr)->length) {
      tmp___1 = Tcl_GetString((*(objv + 0)));
      Tcl_AppendResult(interp, "invalid offset: ", tmp___1, (void *)0);
      return (1);
    }
  }
  if (len < 0) {
    tmp___2 = Tcl_GetString((*(objv + 1)));
    Tcl_AppendResult(interp, "invalid length: ", tmp___2, (void *)0);
    return (1);
  } else {
    if (len > (connPtr->reqPtr)->length - off) {
      tmp___2 = Tcl_GetString((*(objv + 1)));
      Tcl_AppendResult(interp, "invalid length: ", tmp___2, (void *)0);
      return (1);
    }
  }
  (*offPtr) = off;
  (*lenPtr) = len;
  return (0);
}
}
extern void *memmove(void *__dest , void const   *__src , size_t __n ) ;
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
extern int ferror(FILE *__stream ) ;
extern int Tcl_Read(Tcl_Channel chan , char *bufPtr , int toRead ) ;
extern int Tcl_UtfToExternal(Tcl_Interp *interp , Tcl_Encoding encoding , char *src ,
                             int srcLen , int flags , Tcl_EncodingState *statePtr ,
                             char *dst , int dstLen , int *srcReadPtr , int *dstWrotePtr ,
                             int *dstCharsPtr ) ;
int Ns_ConnInit(Ns_Conn *conn ) ;
int Ns_ConnRead(Ns_Conn *conn , void *vbuf , int toread ) ;
int Ns_ConnWrite(Ns_Conn *conn , void *vbuf , int towrite ) ;
int Ns_ConnReadLine(Ns_Conn *conn , Tcl_DString *dsPtr , int *nreadPtr ) ;
int Ns_WriteCharConn(Ns_Conn *conn , char *buf , int len ) ;
int Ns_ConnPuts(Ns_Conn *conn , char *string ) ;
int Ns_ConnSendDString(Ns_Conn *conn , Tcl_DString *dsPtr ) ;
int Ns_ConnSendChannel(Ns_Conn *conn , Tcl_Channel chan , int nsend ) ;
int Ns_ConnSendFp(Ns_Conn *conn , FILE *fp , int nsend ) ;
int Ns_ConnSendFd(Ns_Conn *conn , int fd , int nsend ) ;
int Ns_ConnCopyToDString(Ns_Conn *conn , size_t tocopy , Tcl_DString *dsPtr ) ;
int Ns_ConnCopyToFile(Ns_Conn *conn , size_t ncopy , FILE *fp ) ;
int Ns_ConnCopyToFd(Ns_Conn *conn , size_t ncopy , int fd ) ;
int Ns_ConnFlushContent(Ns_Conn *conn ) ;
char *Ns_ConnGets(char *buf , size_t bufsize , Ns_Conn *conn ) ;
int Ns_ConnReadHeaders(Ns_Conn *conn , Ns_Set *set , int *nreadPtr ) ;
int Ns_ParseHeader(Ns_Set *set , char *line , Ns_HeaderCaseDisposition disp ) ;
int NsSockSend(Sock *sockPtr , struct iovec *bufs , int nbufs ) ;
void NsSockClose(Sock *sockPtr , int keep ) ;
void NsRunAtClose(Tcl_Interp *interp ) ;
static int ConnSend(Ns_Conn *conn , int nsend , Tcl_Channel chan , FILE *fp , int fd ) ;
static int ConnCopy(Ns_Conn *conn , size_t tocopy , Tcl_Channel chan , FILE *fp ,
                    int fd ) ;
int Ns_ConnInit(Ns_Conn *conn ) 
{ 

  {
  return (0);
}
}
int Ns_ConnClose(Ns_Conn *conn ) 
{ Conn *connPtr ;
  int keep ;

  {
  connPtr = (Conn *)conn;
  if ((unsigned int )connPtr->sockPtr != (unsigned int )((void *)0)) {
    if (conn->flags & 32) {
      keep = 1;
    } else {
      keep = 0;
    }
    NsSockClose(connPtr->sockPtr, keep);
    connPtr->sockPtr = (struct Sock *)((void *)0);
    connPtr->flags = connPtr->flags | 1;
    if ((unsigned int )connPtr->interp != (unsigned int )((void *)0)) {
      NsRunAtClose(connPtr->interp);
    }
  }
  return (0);
}
}
int Ns_ConnSend(Ns_Conn *conn , struct iovec *bufs , int nbufs ) 
{ Conn *connPtr ;
  int nwrote ;
  int towrite ;
  int i ;
  int n ;
  struct iovec sbufs[16] ;

  {
  connPtr = (Conn *)conn;
  if ((unsigned int )connPtr->sockPtr == (unsigned int )((void *)0)) {
    return (-1);
  }
  towrite = 0;
  n = 0;
  if (connPtr->queued.length > 0) {
    sbufs[n].iov_base = (void *)connPtr->queued.string;
    sbufs[n].iov_len = (unsigned int )connPtr->queued.length;
    towrite = (int )((unsigned int )towrite + sbufs[n].iov_len);
    n ++;
  }
  i = 0;
  while (1) {
    if (i < nbufs) {
      if (! (n < 16)) {
        break;
      }
    } else {
      break;
    }
    if ((bufs + i)->iov_len > 0U) {
      if ((unsigned int )(bufs + i)->iov_base != (unsigned int )((void *)0)) {
        sbufs[n].iov_base = (bufs + i)->iov_base;
        sbufs[n].iov_len = (bufs + i)->iov_len;
        towrite = (int )((unsigned int )towrite + (bufs + i)->iov_len);
        n ++;
      }
    }
    i ++;
  }
  nbufs = n;
  bufs = sbufs;
  nwrote = 0;
  n = nwrote;
  while (towrite > 0) {
    n = NsSockSend(connPtr->sockPtr, bufs, nbufs);
    if (n < 0) {
      break;
    }
    towrite -= n;
    nwrote += n;
    if (towrite > 0) {
      i = 0;
      while (1) {
        if (i < nbufs) {
          if (! (n > 0)) {
            break;
          }
        } else {
          break;
        }
        if (n > (int )(bufs + i)->iov_len) {
          n = (int )((unsigned int )n - (bufs + i)->iov_len);
          (bufs + i)->iov_base = (void *)0;
          (bufs + i)->iov_len = 0U;
        } else {
          (bufs + i)->iov_base = (void *)((char *)(bufs + i)->iov_base + n);
          (bufs + i)->iov_len = (bufs + i)->iov_len - (unsigned int )n;
          n = 0;
        }
        i ++;
      }
    }
  }
  if (nwrote > 0) {
    connPtr->nContentSent = connPtr->nContentSent + nwrote;
    if (connPtr->queued.length > 0) {
      n = connPtr->queued.length - nwrote;
      if (n <= 0) {
        nwrote -= connPtr->queued.length;
        Tcl_DStringSetLength(& connPtr->queued, 0);
      } else {
        memmove((void *)connPtr->queued.string, (void const   *)(connPtr->queued.string +
                                                                 nwrote), (unsigned int )n);
        Tcl_DStringSetLength(& connPtr->queued, n);
        nwrote = 0;
      }
    }
  } else {
    nwrote = n;
  }
  return (nwrote);
}
}
int Ns_ConnWrite(Ns_Conn *conn , void *vbuf , int towrite ) 
{ struct iovec buf ;
  int tmp ;

  {
  buf.iov_base = vbuf;
  buf.iov_len = (unsigned int )towrite;
  tmp = Ns_ConnSend(conn, & buf, 1);
  return (tmp);
}
}
int Ns_WriteConn(Ns_Conn *conn , char *buf , int len ) 
{ int tmp ;

  {
  tmp = Ns_ConnWrite(conn, (void *)buf, len);
  if (tmp != len) {
    return (-1);
  }
  return (0);
}
}
int Ns_WriteCharConn(Ns_Conn *conn , char *buf , int len ) 
{ int status ;
  char *utfBytes ;
  int utfCount ;
  int utfConvertedCount ;
  char encodedBytes[2048] ;
  int encodedCount ;
  Tcl_Interp *interp ;
  Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  status = 0;
  if ((unsigned int )connPtr->encoding == (unsigned int )((void *)0)) {
    status = Ns_WriteConn(conn, buf, len);
  } else {
    utfBytes = buf;
    utfCount = len;
    interp = Ns_GetConnInterp(conn);
    while (1) {
      if (utfCount > 0) {
        if (! (status == 0)) {
          break;
        }
      } else {
        break;
      }
      status = Tcl_UtfToExternal(interp, connPtr->encoding, utfBytes, utfCount, 0,
                                 (Tcl_EncodingState *)((void *)0), encodedBytes, (int )sizeof(encodedBytes),
                                 & utfConvertedCount, & encodedCount, (int *)((void *)0));
      if (status != 0) {
        if (status != -4) {
          status = -1;
          break;
        }
      }
      status = 0;
      buf = encodedBytes;
      len = encodedCount;
      status = Ns_WriteConn(conn, buf, len);
      utfCount -= utfConvertedCount;
      utfBytes += utfConvertedCount;
    }
  }
  return (status);
}
}
int Ns_ConnPuts(Ns_Conn *conn , char *string ) 
{ size_t tmp ;
  int tmp___0 ;

  {
  tmp = strlen((char const   *)string);
  tmp___0 = Ns_WriteConn(conn, string, (int )tmp);
  return (tmp___0);
}
}
int Ns_ConnSendDString(Ns_Conn *conn , Tcl_DString *dsPtr ) 
{ int tmp ;

  {
  tmp = Ns_WriteConn(conn, dsPtr->string, dsPtr->length);
  return (tmp);
}
}
int Ns_ConnSendChannel(Ns_Conn *conn , Tcl_Channel chan , int nsend ) 
{ int tmp ;

  {
  tmp = ConnSend(conn, nsend, chan, (FILE *)((void *)0), -1);
  return (tmp);
}
}
int Ns_ConnSendFp(Ns_Conn *conn , FILE *fp , int nsend ) 
{ int tmp ;

  {
  tmp = ConnSend(conn, nsend, (struct Tcl_Channel_ *)((void *)0), fp, -1);
  return (tmp);
}
}
int Ns_ConnSendFd(Ns_Conn *conn , int fd , int nsend ) 
{ int tmp ;

  {
  tmp = ConnSend(conn, nsend, (struct Tcl_Channel_ *)((void *)0), (FILE *)((void *)0),
                 fd);
  return (tmp);
}
}
int Ns_ConnFlushContent(Ns_Conn *conn ) 
{ Conn *connPtr ;
  Request *reqPtr ;

  {
  connPtr = (Conn *)conn;
  reqPtr = connPtr->reqPtr;
  if ((unsigned int )connPtr->sockPtr == (unsigned int )((void *)0)) {
    return (-1);
  }
  reqPtr->next = reqPtr->next + reqPtr->avail;
  reqPtr->avail = 0;
  return (0);
}
}
char *Ns_ConnGets(char *buf , size_t bufsize , Ns_Conn *conn ) 
{ char *p ;
  int tmp ;
  char *tmp___0 ;

  {
  p = buf;
  while (bufsize > 1U) {
    tmp = Ns_ConnRead(conn, (void *)p, 1);
    if (tmp != 1) {
      return ((char *)((void *)0));
    }
    tmp___0 = p;
    p ++;
    if ((int )(*tmp___0) == 10) {
      break;
    }
    bufsize --;
  }
  (*p) = (char )'\000';
  return (buf);
}
}
int Ns_ConnRead(Ns_Conn *conn , void *vbuf , int toread ) 
{ Conn *connPtr ;
  Request *reqPtr ;

  {
  connPtr = (Conn *)conn;
  reqPtr = connPtr->reqPtr;
  if ((unsigned int )connPtr->sockPtr == (unsigned int )((void *)0)) {
    return (-1);
  }
  if (toread > reqPtr->avail) {
    toread = reqPtr->avail;
  }
  memcpy((void * __restrict  )vbuf, (void const   * __restrict  )reqPtr->next, (unsigned int )toread);
  reqPtr->next = reqPtr->next + toread;
  reqPtr->avail = reqPtr->avail - toread;
  return (toread);
}
}
int Ns_ConnReadLine(Ns_Conn *conn , Tcl_DString *dsPtr , int *nreadPtr ) 
{ Conn *connPtr ;
  Request *reqPtr ;
  NsServer *servPtr ;
  char *eol ;
  int nread ;
  int ncopy ;
  char *tmp___0 ;

  {
  connPtr = (Conn *)conn;
  reqPtr = connPtr->reqPtr;
  servPtr = connPtr->servPtr;
  if ((unsigned int )connPtr->sockPtr == (unsigned int )((void *)0)) {
    return (-1);
  } else {
    tmp___0 = strchr((char const   *)reqPtr->next, '\n');
    eol = tmp___0;
    if ((unsigned int )eol == (unsigned int )((void *)0)) {
      return (-1);
    } else {
      nread = eol - reqPtr->next;
      if (nread > servPtr->limits.maxline) {
        return (-1);
      }
    }
  }
  ncopy = nread;
  nread ++;
  if ((unsigned int )nreadPtr != (unsigned int )((void *)0)) {
    (*nreadPtr) = nread;
  }
  if (ncopy > 0) {
    if ((int )(*(eol + -1)) == 13) {
      ncopy --;
    }
  }
  Tcl_DStringAppend(dsPtr, reqPtr->next, ncopy);
  reqPtr->next = reqPtr->next + nread;
  reqPtr->avail = reqPtr->avail - nread;
  return (-1);
}
}
int Ns_ConnReadHeaders(Ns_Conn *conn , Ns_Set *set , int *nreadPtr ) 
{ Tcl_DString ds ;
  Conn *connPtr ;
  NsServer *servPtr ;
  int status ;
  int nread ;
  int nline ;
  int maxhdr ;

  {
  connPtr = (Conn *)conn;
  servPtr = connPtr->servPtr;
  Tcl_DStringInit(& ds);
  nread = 0;
  maxhdr = servPtr->limits.maxheaders;
  status = 0;
  while (1) {
    if (nread < maxhdr) {
      if (! (status == 0)) {
        break;
      }
    } else {
      break;
    }
    Tcl_DStringSetLength(& ds, 0);
    status = Ns_ConnReadLine(conn, & ds, & nline);
    if (status == 0) {
      nread += nline;
      if (nread > maxhdr) {
        status = -1;
      } else {
        if ((int )(*(ds.string + 0)) == 0) {
          break;
        }
        status = Ns_ParseHeader(set, ds.string, servPtr->opts.hdrcase);
      }
    }
  }
  if ((unsigned int )nreadPtr != (unsigned int )((void *)0)) {
    (*nreadPtr) = nread;
  }
  Tcl_DStringFree(& ds);
  return (status);
}
}
int Ns_ConnCopyToDString(Ns_Conn *conn , size_t tocopy , Tcl_DString *dsPtr ) 
{ Conn *connPtr ;
  Request *reqPtr ;
  int ncopy ;

  {
  connPtr = (Conn *)conn;
  reqPtr = connPtr->reqPtr;
  ncopy = (int )tocopy;
  if ((unsigned int )connPtr->sockPtr == (unsigned int )((void *)0)) {
    return (-1);
  } else {
    if (reqPtr->avail < ncopy) {
      return (-1);
    }
  }
  Tcl_DStringAppend(dsPtr, reqPtr->next, ncopy);
  reqPtr->next = reqPtr->next + ncopy;
  reqPtr->avail = reqPtr->avail - ncopy;
  return (0);
}
}
int Ns_ConnCopyToChannel(Ns_Conn *conn , size_t ncopy , Tcl_Channel chan ) 
{ int tmp ;

  {
  tmp = ConnCopy(conn, ncopy, chan, (FILE *)((void *)0), -1);
  return (tmp);
}
}
int Ns_ConnCopyToFile(Ns_Conn *conn , size_t ncopy , FILE *fp ) 
{ int tmp ;

  {
  tmp = ConnCopy(conn, ncopy, (struct Tcl_Channel_ *)((void *)0), fp, -1);
  return (tmp);
}
}
int Ns_ConnCopyToFd(Ns_Conn *conn , size_t ncopy , int fd ) 
{ int tmp ;

  {
  tmp = ConnCopy(conn, ncopy, (struct Tcl_Channel_ *)((void *)0), (FILE *)((void *)0),
                 fd);
  return (tmp);
}
}
static int ConnCopy(Ns_Conn *conn , size_t tocopy , Tcl_Channel chan , FILE *fp ,
                    int fd ) 
{ Conn *connPtr ;
  Request *reqPtr ;
  int nwrote ;
  int ncopy ;
  int tmp ;

  {
  connPtr = (Conn *)conn;
  reqPtr = connPtr->reqPtr;
  ncopy = (int )tocopy;
  if ((unsigned int )connPtr->sockPtr == (unsigned int )((void *)0)) {
    return (-1);
  } else {
    if (reqPtr->avail < ncopy) {
      return (-1);
    }
  }
  while (ncopy > 0) {
    if ((unsigned int )chan != (unsigned int )((void *)0)) {
      nwrote = Tcl_Write(chan, reqPtr->next, ncopy);
    } else {
      if ((unsigned int )fp != (unsigned int )((void *)0)) {
        nwrote = (int )fwrite((void const   * __restrict  )reqPtr->next, 1U, (unsigned int )ncopy,
                              (FILE * __restrict  )fp);
        tmp = ferror(fp);
        if (tmp) {
          nwrote = -1;
        }
      } else {
        nwrote = write(fd, (void const   *)reqPtr->next, (unsigned int )ncopy);
      }
    }
    if (nwrote < 0) {
      return (-1);
    }
    ncopy -= nwrote;
    reqPtr->next = reqPtr->next + nwrote;
    reqPtr->avail = reqPtr->avail - nwrote;
  }
  return (0);
}
}
static int ConnSend(Ns_Conn *conn , int nsend , Tcl_Channel chan , FILE *fp , int fd ) 
{ int toread ;
  int nread ;
  int status ;
  char buf[2048] ;
  int tmp ;

  {
  if (nsend == 0) {
    Ns_WriteConn(conn, (char *)((void *)0), 0);
  }
  status = 0;
  while (1) {
    if (status == 0) {
      if (! (nsend > 0)) {
        break;
      }
    } else {
      break;
    }
    toread = nsend;
    if ((unsigned int )toread > sizeof(buf)) {
      toread = (int )sizeof(buf);
    }
    if ((unsigned int )chan != (unsigned int )((void *)0)) {
      nread = Tcl_Read(chan, buf, toread);
    } else {
      if ((unsigned int )fp != (unsigned int )((void *)0)) {
        nread = (int )fread((void * __restrict  )(buf), 1U, (unsigned int )toread,
                            (FILE * __restrict  )fp);
        tmp = ferror(fp);
        if (tmp) {
          nread = -1;
        }
      } else {
        nread = read(fd, (void *)(buf), (unsigned int )toread);
      }
    }
    if (nread == -1) {
      status = -1;
    } else {
      if (nread == 0) {
        nsend = 0;
      } else {
        status = Ns_WriteConn(conn, buf, nread);
        if (status == 0) {
          nsend -= nread;
        }
      }
    }
  }
  return (status);
}
}
char *Ns_Encrypt(char *pw , char *salt , char *iobuf ) ;
static char const   IP[64]  = 
  {      (char const   )58,      (char const   )50,      (char const   )42,      (char const   )34, 
        (char const   )26,      (char const   )18,      (char const   )10,      (char const   )2, 
        (char const   )60,      (char const   )52,      (char const   )44,      (char const   )36, 
        (char const   )28,      (char const   )20,      (char const   )12,      (char const   )4, 
        (char const   )62,      (char const   )54,      (char const   )46,      (char const   )38, 
        (char const   )30,      (char const   )22,      (char const   )14,      (char const   )6, 
        (char const   )64,      (char const   )56,      (char const   )48,      (char const   )40, 
        (char const   )32,      (char const   )24,      (char const   )16,      (char const   )8, 
        (char const   )57,      (char const   )49,      (char const   )41,      (char const   )33, 
        (char const   )25,      (char const   )17,      (char const   )9,      (char const   )1, 
        (char const   )59,      (char const   )51,      (char const   )43,      (char const   )35, 
        (char const   )27,      (char const   )19,      (char const   )11,      (char const   )3, 
        (char const   )61,      (char const   )53,      (char const   )45,      (char const   )37, 
        (char const   )29,      (char const   )21,      (char const   )13,      (char const   )5, 
        (char const   )63,      (char const   )55,      (char const   )47,      (char const   )39, 
        (char const   )31,      (char const   )23,      (char const   )15,      (char const   )7};
static char const   FP[64]  = 
  {      (char const   )40,      (char const   )8,      (char const   )48,      (char const   )16, 
        (char const   )56,      (char const   )24,      (char const   )64,      (char const   )32, 
        (char const   )39,      (char const   )7,      (char const   )47,      (char const   )15, 
        (char const   )55,      (char const   )23,      (char const   )63,      (char const   )31, 
        (char const   )38,      (char const   )6,      (char const   )46,      (char const   )14, 
        (char const   )54,      (char const   )22,      (char const   )62,      (char const   )30, 
        (char const   )37,      (char const   )5,      (char const   )45,      (char const   )13, 
        (char const   )53,      (char const   )21,      (char const   )61,      (char const   )29, 
        (char const   )36,      (char const   )4,      (char const   )44,      (char const   )12, 
        (char const   )52,      (char const   )20,      (char const   )60,      (char const   )28, 
        (char const   )35,      (char const   )3,      (char const   )43,      (char const   )11, 
        (char const   )51,      (char const   )19,      (char const   )59,      (char const   )27, 
        (char const   )34,      (char const   )2,      (char const   )42,      (char const   )10, 
        (char const   )50,      (char const   )18,      (char const   )58,      (char const   )26, 
        (char const   )33,      (char const   )1,      (char const   )41,      (char const   )9, 
        (char const   )49,      (char const   )17,      (char const   )57,      (char const   )25};
static char const   PC1_C[28]  = 
  {      (char const   )57,      (char const   )49,      (char const   )41,      (char const   )33, 
        (char const   )25,      (char const   )17,      (char const   )9,      (char const   )1, 
        (char const   )58,      (char const   )50,      (char const   )42,      (char const   )34, 
        (char const   )26,      (char const   )18,      (char const   )10,      (char const   )2, 
        (char const   )59,      (char const   )51,      (char const   )43,      (char const   )35, 
        (char const   )27,      (char const   )19,      (char const   )11,      (char const   )3, 
        (char const   )60,      (char const   )52,      (char const   )44,      (char const   )36};
static char const   PC1_D[28]  = 
  {      (char const   )63,      (char const   )55,      (char const   )47,      (char const   )39, 
        (char const   )31,      (char const   )23,      (char const   )15,      (char const   )7, 
        (char const   )62,      (char const   )54,      (char const   )46,      (char const   )38, 
        (char const   )30,      (char const   )22,      (char const   )14,      (char const   )6, 
        (char const   )61,      (char const   )53,      (char const   )45,      (char const   )37, 
        (char const   )29,      (char const   )21,      (char const   )13,      (char const   )5, 
        (char const   )28,      (char const   )20,      (char const   )12,      (char const   )4};
static char const   shifts[16]  = 
  {      (char const   )1,      (char const   )1,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )1,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )1};
static char const   PC2_C[24]  = 
  {      (char const   )14,      (char const   )17,      (char const   )11,      (char const   )24, 
        (char const   )1,      (char const   )5,      (char const   )3,      (char const   )28, 
        (char const   )15,      (char const   )6,      (char const   )21,      (char const   )10, 
        (char const   )23,      (char const   )19,      (char const   )12,      (char const   )4, 
        (char const   )26,      (char const   )8,      (char const   )16,      (char const   )7, 
        (char const   )27,      (char const   )20,      (char const   )13,      (char const   )2};
static char const   PC2_D[24]  = 
  {      (char const   )41,      (char const   )52,      (char const   )31,      (char const   )37, 
        (char const   )47,      (char const   )55,      (char const   )30,      (char const   )40, 
        (char const   )51,      (char const   )45,      (char const   )33,      (char const   )48, 
        (char const   )44,      (char const   )49,      (char const   )39,      (char const   )56, 
        (char const   )34,      (char const   )53,      (char const   )46,      (char const   )42, 
        (char const   )50,      (char const   )36,      (char const   )29,      (char const   )32};
static char const   e[48]  = 
  {      (char const   )32,      (char const   )1,      (char const   )2,      (char const   )3, 
        (char const   )4,      (char const   )5,      (char const   )4,      (char const   )5, 
        (char const   )6,      (char const   )7,      (char const   )8,      (char const   )9, 
        (char const   )8,      (char const   )9,      (char const   )10,      (char const   )11, 
        (char const   )12,      (char const   )13,      (char const   )12,      (char const   )13, 
        (char const   )14,      (char const   )15,      (char const   )16,      (char const   )17, 
        (char const   )16,      (char const   )17,      (char const   )18,      (char const   )19, 
        (char const   )20,      (char const   )21,      (char const   )20,      (char const   )21, 
        (char const   )22,      (char const   )23,      (char const   )24,      (char const   )25, 
        (char const   )24,      (char const   )25,      (char const   )26,      (char const   )27, 
        (char const   )28,      (char const   )29,      (char const   )28,      (char const   )29, 
        (char const   )30,      (char const   )31,      (char const   )32,      (char const   )1};
static void setkey_private(struct sched *sp , char const   *key___1 ) 
{ register int i ;
  register int j ;
  register int k ;
  int t ;

  {
  i = 0;
  while (i < 28) {
    sp->C[i] = (char )(*(key___1 + ((int const   )PC1_C[i] - 1)));
    sp->D[i] = (char )(*(key___1 + ((int const   )PC1_D[i] - 1)));
    i ++;
  }
  i = 0;
  while (i < 16) {
    k = 0;
    while (k < (int )shifts[i]) {
      t = (int )sp->C[0];
      j = 0;
      while (j < 27) {
        sp->C[j] = sp->C[j + 1];
        j ++;
      }
      sp->C[27] = (char )t;
      t = (int )sp->D[0];
      j = 0;
      while (j < 27) {
        sp->D[j] = sp->D[j + 1];
        j ++;
      }
      sp->D[27] = (char )t;
      k ++;
    }
    j = 0;
    while (j < 24) {
      sp->KS[i][j] = sp->C[(int const   )PC2_C[j] - 1];
      sp->KS[i][j + 24] = sp->D[((int const   )PC2_D[j] - 28) - 1];
      j ++;
    }
    i ++;
  }
  i = 0;
  while (i < 48) {
    sp->E[i] = (char )e[i];
    i ++;
  }
  return;
}
}
static char const   S[8][64]  = 
  { {        (char const   )14,        (char const   )4,        (char const   )13,        (char const   )1, 
            (char const   )2,        (char const   )15,        (char const   )11,        (char const   )8, 
            (char const   )3,        (char const   )10,        (char const   )6,        (char const   )12, 
            (char const   )5,        (char const   )9,        (char const   )0,        (char const   )7, 
            (char const   )0,        (char const   )15,        (char const   )7,        (char const   )4, 
            (char const   )14,        (char const   )2,        (char const   )13,        (char const   )1, 
            (char const   )10,        (char const   )6,        (char const   )12,        (char const   )11, 
            (char const   )9,        (char const   )5,        (char const   )3,        (char const   )8, 
            (char const   )4,        (char const   )1,        (char const   )14,        (char const   )8, 
            (char const   )13,        (char const   )6,        (char const   )2,        (char const   )11, 
            (char const   )15,        (char const   )12,        (char const   )9,        (char const   )7, 
            (char const   )3,        (char const   )10,        (char const   )5,        (char const   )0, 
            (char const   )15,        (char const   )12,        (char const   )8,        (char const   )2, 
            (char const   )4,        (char const   )9,        (char const   )1,        (char const   )7, 
            (char const   )5,        (char const   )11,        (char const   )3,        (char const   )14, 
            (char const   )10,        (char const   )0,        (char const   )6,        (char const   )13}, 
   {        (char const   )15,        (char const   )1,        (char const   )8,        (char const   )14, 
            (char const   )6,        (char const   )11,        (char const   )3,        (char const   )4, 
            (char const   )9,        (char const   )7,        (char const   )2,        (char const   )13, 
            (char const   )12,        (char const   )0,        (char const   )5,        (char const   )10, 
            (char const   )3,        (char const   )13,        (char const   )4,        (char const   )7, 
            (char const   )15,        (char const   )2,        (char const   )8,        (char const   )14, 
            (char const   )12,        (char const   )0,        (char const   )1,        (char const   )10, 
            (char const   )6,        (char const   )9,        (char const   )11,        (char const   )5, 
            (char const   )0,        (char const   )14,        (char const   )7,        (char const   )11, 
            (char const   )10,        (char const   )4,        (char const   )13,        (char const   )1, 
            (char const   )5,        (char const   )8,        (char const   )12,        (char const   )6, 
            (char const   )9,        (char const   )3,        (char const   )2,        (char const   )15, 
            (char const   )13,        (char const   )8,        (char const   )10,        (char const   )1, 
            (char const   )3,        (char const   )15,        (char const   )4,        (char const   )2, 
            (char const   )11,        (char const   )6,        (char const   )7,        (char const   )12, 
            (char const   )0,        (char const   )5,        (char const   )14,        (char const   )9}, 
   {        (char const   )10,        (char const   )0,        (char const   )9,        (char const   )14, 
            (char const   )6,        (char const   )3,        (char const   )15,        (char const   )5, 
            (char const   )1,        (char const   )13,        (char const   )12,        (char const   )7, 
            (char const   )11,        (char const   )4,        (char const   )2,        (char const   )8, 
            (char const   )13,        (char const   )7,        (char const   )0,        (char const   )9, 
            (char const   )3,        (char const   )4,        (char const   )6,        (char const   )10, 
            (char const   )2,        (char const   )8,        (char const   )5,        (char const   )14, 
            (char const   )12,        (char const   )11,        (char const   )15,        (char const   )1, 
            (char const   )13,        (char const   )6,        (char const   )4,        (char const   )9, 
            (char const   )8,        (char const   )15,        (char const   )3,        (char const   )0, 
            (char const   )11,        (char const   )1,        (char const   )2,        (char const   )12, 
            (char const   )5,        (char const   )10,        (char const   )14,        (char const   )7, 
            (char const   )1,        (char const   )10,        (char const   )13,        (char const   )0, 
            (char const   )6,        (char const   )9,        (char const   )8,        (char const   )7, 
            (char const   )4,        (char const   )15,        (char const   )14,        (char const   )3, 
            (char const   )11,        (char const   )5,        (char const   )2,        (char const   )12}, 
   {        (char const   )7,        (char const   )13,        (char const   )14,        (char const   )3, 
            (char const   )0,        (char const   )6,        (char const   )9,        (char const   )10, 
            (char const   )1,        (char const   )2,        (char const   )8,        (char const   )5, 
            (char const   )11,        (char const   )12,        (char const   )4,        (char const   )15, 
            (char const   )13,        (char const   )8,        (char const   )11,        (char const   )5, 
            (char const   )6,        (char const   )15,        (char const   )0,        (char const   )3, 
            (char const   )4,        (char const   )7,        (char const   )2,        (char const   )12, 
            (char const   )1,        (char const   )10,        (char const   )14,        (char const   )9, 
            (char const   )10,        (char const   )6,        (char const   )9,        (char const   )0, 
            (char const   )12,        (char const   )11,        (char const   )7,        (char const   )13, 
            (char const   )15,        (char const   )1,        (char const   )3,        (char const   )14, 
            (char const   )5,        (char const   )2,        (char const   )8,        (char const   )4, 
            (char const   )3,        (char const   )15,        (char const   )0,        (char const   )6, 
            (char const   )10,        (char const   )1,        (char const   )13,        (char const   )8, 
            (char const   )9,        (char const   )4,        (char const   )5,        (char const   )11, 
            (char const   )12,        (char const   )7,        (char const   )2,        (char const   )14}, 
   {        (char const   )2,        (char const   )12,        (char const   )4,        (char const   )1, 
            (char const   )7,        (char const   )10,        (char const   )11,        (char const   )6, 
            (char const   )8,        (char const   )5,        (char const   )3,        (char const   )15, 
            (char const   )13,        (char const   )0,        (char const   )14,        (char const   )9, 
            (char const   )14,        (char const   )11,        (char const   )2,        (char const   )12, 
            (char const   )4,        (char const   )7,        (char const   )13,        (char const   )1, 
            (char const   )5,        (char const   )0,        (char const   )15,        (char const   )10, 
            (char const   )3,        (char const   )9,        (char const   )8,        (char const   )6, 
            (char const   )4,        (char const   )2,        (char const   )1,        (char const   )11, 
            (char const   )10,        (char const   )13,        (char const   )7,        (char const   )8, 
            (char const   )15,        (char const   )9,        (char const   )12,        (char const   )5, 
            (char const   )6,        (char const   )3,        (char const   )0,        (char const   )14, 
            (char const   )11,        (char const   )8,        (char const   )12,        (char const   )7, 
            (char const   )1,        (char const   )14,        (char const   )2,        (char const   )13, 
            (char const   )6,        (char const   )15,        (char const   )0,        (char const   )9, 
            (char const   )10,        (char const   )4,        (char const   )5,        (char const   )3}, 
   {        (char const   )12,        (char const   )1,        (char const   )10,        (char const   )15, 
            (char const   )9,        (char const   )2,        (char const   )6,        (char const   )8, 
            (char const   )0,        (char const   )13,        (char const   )3,        (char const   )4, 
            (char const   )14,        (char const   )7,        (char const   )5,        (char const   )11, 
            (char const   )10,        (char const   )15,        (char const   )4,        (char const   )2, 
            (char const   )7,        (char const   )12,        (char const   )9,        (char const   )5, 
            (char const   )6,        (char const   )1,        (char const   )13,        (char const   )14, 
            (char const   )0,        (char const   )11,        (char const   )3,        (char const   )8, 
            (char const   )9,        (char const   )14,        (char const   )15,        (char const   )5, 
            (char const   )2,        (char const   )8,        (char const   )12,        (char const   )3, 
            (char const   )7,        (char const   )0,        (char const   )4,        (char const   )10, 
            (char const   )1,        (char const   )13,        (char const   )11,        (char const   )6, 
            (char const   )4,        (char const   )3,        (char const   )2,        (char const   )12, 
            (char const   )9,        (char const   )5,        (char const   )15,        (char const   )10, 
            (char const   )11,        (char const   )14,        (char const   )1,        (char const   )7, 
            (char const   )6,        (char const   )0,        (char const   )8,        (char const   )13}, 
   {        (char const   )4,        (char const   )11,        (char const   )2,        (char const   )14, 
            (char const   )15,        (char const   )0,        (char const   )8,        (char const   )13, 
            (char const   )3,        (char const   )12,        (char const   )9,        (char const   )7, 
            (char const   )5,        (char const   )10,        (char const   )6,        (char const   )1, 
            (char const   )13,        (char const   )0,        (char const   )11,        (char const   )7, 
            (char const   )4,        (char const   )9,        (char const   )1,        (char const   )10, 
            (char const   )14,        (char const   )3,        (char const   )5,        (char const   )12, 
            (char const   )2,        (char const   )15,        (char const   )8,        (char const   )6, 
            (char const   )1,        (char const   )4,        (char const   )11,        (char const   )13, 
            (char const   )12,        (char const   )3,        (char const   )7,        (char const   )14, 
            (char const   )10,        (char const   )15,        (char const   )6,        (char const   )8, 
            (char const   )0,        (char const   )5,        (char const   )9,        (char const   )2, 
            (char const   )6,        (char const   )11,        (char const   )13,        (char const   )8, 
            (char const   )1,        (char const   )4,        (char const   )10,        (char const   )7, 
            (char const   )9,        (char const   )5,        (char const   )0,        (char const   )15, 
            (char const   )14,        (char const   )2,        (char const   )3,        (char const   )12}, 
   {        (char const   )13,        (char const   )2,        (char const   )8,        (char const   )4, 
            (char const   )6,        (char const   )15,        (char const   )11,        (char const   )1, 
            (char const   )10,        (char const   )9,        (char const   )3,        (char const   )14, 
            (char const   )5,        (char const   )0,        (char const   )12,        (char const   )7, 
            (char const   )1,        (char const   )15,        (char const   )13,        (char const   )8, 
            (char const   )10,        (char const   )3,        (char const   )7,        (char const   )4, 
            (char const   )12,        (char const   )5,        (char const   )6,        (char const   )11, 
            (char const   )0,        (char const   )14,        (char const   )9,        (char const   )2, 
            (char const   )7,        (char const   )11,        (char const   )4,        (char const   )1, 
            (char const   )9,        (char const   )12,        (char const   )14,        (char const   )2, 
            (char const   )0,        (char const   )6,        (char const   )10,        (char const   )13, 
            (char const   )15,        (char const   )3,        (char const   )5,        (char const   )8, 
            (char const   )2,        (char const   )1,        (char const   )14,        (char const   )7, 
            (char const   )4,        (char const   )10,        (char const   )8,        (char const   )13, 
            (char const   )15,        (char const   )12,        (char const   )9,        (char const   )0, 
            (char const   )3,        (char const   )5,        (char const   )6,        (char const   )11}};
static char const   P[32]  = 
  {      (char const   )16,      (char const   )7,      (char const   )20,      (char const   )21, 
        (char const   )29,      (char const   )12,      (char const   )28,      (char const   )17, 
        (char const   )1,      (char const   )15,      (char const   )23,      (char const   )26, 
        (char const   )5,      (char const   )18,      (char const   )31,      (char const   )10, 
        (char const   )2,      (char const   )8,      (char const   )24,      (char const   )14, 
        (char const   )32,      (char const   )27,      (char const   )3,      (char const   )9, 
        (char const   )19,      (char const   )13,      (char const   )30,      (char const   )6, 
        (char const   )22,      (char const   )11,      (char const   )4,      (char const   )25};
static void encrypt_private(struct sched *sp , char *block , int edflag ) 
{ char L[64] ;
  char *R ;
  char tempL[32] ;
  char f[32] ;
  char preS[48] ;
  int i ;
  int ii ;
  register int t ;
  register int j ;
  register int k ;

  {
  R = L + 32;
  j = 0;
  while (j < 64) {
    L[j] = (*(block + ((int const   )IP[j] - 1)));
    j ++;
  }
  ii = 0;
  while (ii < 16) {
    if (edflag) {
      i = 15 - ii;
    } else {
      i = ii;
    }
    j = 0;
    while (j < 32) {
      tempL[j] = (*(R + j));
      j ++;
    }
    j = 0;
    while (j < 48) {
      preS[j] = (char )((int )(*(R + ((int )sp->E[j] - 1))) ^ (int )sp->KS[i][j]);
      j ++;
    }
    j = 0;
    while (j < 8) {
      t = 6 * j;
      k = (int )S[j][((((((int )preS[t] << 5) + ((int )preS[t + 1] << 3)) + ((int )preS[t +
                                                                                        2] <<
                                                                             2)) +
                       ((int )preS[t + 3] << 1)) + (int )preS[t + 4]) + ((int )preS[t +
                                                                                    5] <<
                                                                         4)];
      t = 4 * j;
      f[t] = (char )((k >> 3) & 1);
      f[t + 1] = (char )((k >> 2) & 1);
      f[t + 2] = (char )((k >> 1) & 1);
      f[t + 3] = (char )(k & 1);
      j ++;
    }
    j = 0;
    while (j < 32) {
      (*(R + j)) = (char )((int )L[j] ^ (int )f[(int const   )P[j] - 1]);
      j ++;
    }
    j = 0;
    while (j < 32) {
      L[j] = tempL[j];
      j ++;
    }
    ii ++;
  }
  j = 0;
  while (j < 32) {
    t = (int )L[j];
    L[j] = (*(R + j));
    (*(R + j)) = (char )t;
    j ++;
  }
  j = 0;
  while (j < 64) {
    (*(block + j)) = L[(int const   )FP[j] - 1];
    j ++;
  }
  return;
}
}
char *Ns_Encrypt(char *pw , char *salt , char *iobuf ) 
{ register int i ;
  register int j ;
  register int c ;
  int temp ;
  char block[66] ;
  struct sched s ;
  char *tmp ;

  {
  i = 0;
  while (i < 66) {
    block[i] = (char)0;
    i ++;
  }
  i = 0;
  while (1) {
    c = (int )(*pw);
    if (c) {
      if (! (i < 64)) {
        break;
      }
    } else {
      break;
    }
    j = 0;
    while (j < 7) {
      block[i] = (char )((c >> (6 - j)) & 1);
      j ++;
      i ++;
    }
    i ++;
    pw ++;
  }
  setkey_private(& s, (char const   *)(block));
  i = 0;
  while (i < 66) {
    block[i] = (char)0;
    i ++;
  }
  i = 0;
  while (i < 2) {
    tmp = salt;
    salt ++;
    c = (int )(*tmp);
    (*(iobuf + i)) = (char )c;
    if (c > 90) {
      c -= 6;
    }
    if (c > 57) {
      c -= 7;
    }
    c -= 46;
    j = 0;
    while (j < 6) {
      if ((c >> j) & 1) {
        temp = (int )s.E[6 * i + j];
        s.E[6 * i + j] = s.E[(6 * i + j) + 24];
        s.E[(6 * i + j) + 24] = (char )temp;
      }
      j ++;
    }
    i ++;
  }
  i = 0;
  while (i < 25) {
    encrypt_private(& s, block, 0);
    i ++;
  }
  i = 0;
  while (i < 11) {
    c = 0;
    j = 0;
    while (j < 6) {
      c <<= 1;
      c |= (int )block[6 * i + j];
      j ++;
    }
    c += 46;
    if (c > 57) {
      c += 7;
    }
    if (c > 90) {
      c += 6;
    }
    (*(iobuf + (i + 2))) = (char )c;
    i ++;
  }
  (*(iobuf + (i + 2))) = (char)0;
  if ((int )(*(iobuf + 1)) == 0) {
    (*(iobuf + 1)) = (*(iobuf + 0));
  }
  return (iobuf);
}
}
extern in_addr_t inet_addr(char const   *__cp ) ;
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
extern void freeaddrinfo(struct addrinfo *__ai ) ;
extern char const   *gai_strerror(int __ecode ) ;
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
extern time_t time(time_t *__timer ) ;
int Ns_GetHostByAddr(Tcl_DString *dsPtr , char *addr ) ;
int Ns_GetAddrByHost(Tcl_DString *dsPtr , char *host ) ;
int Ns_GetAllAddrByHost(Tcl_DString *dsPtr , char *host ) ;
void NsEnableDNSCache(int timeout , int maxentries ) ;
static Ns_Cache *hostCache  ;
static Ns_Cache *addrCache  ;
static Ns_Mutex lock___2  ;
static int cachetimeout  ;
static int GetAddr(Tcl_DString *dsPtr , char *host ) ;
static int GetHost(Tcl_DString *dsPtr , char *addr ) ;
static int DnsGet(GetProc *getProc , Tcl_DString *dsPtr , Ns_Cache **cachePtr , char *key___1 ,
                  int all ) ;
int Ns_GetHostByAddr(Tcl_DString *dsPtr , char *addr ) 
{ int tmp ;

  {
  tmp = DnsGet(& GetHost, dsPtr, & hostCache, addr, 0);
  return (tmp);
}
}
int Ns_GetAddrByHost(Tcl_DString *dsPtr , char *host ) 
{ int tmp ;

  {
  tmp = DnsGet(& GetAddr, dsPtr, & addrCache, host, 0);
  return (tmp);
}
}
int Ns_GetAllAddrByHost(Tcl_DString *dsPtr , char *host ) 
{ int tmp ;

  {
  tmp = DnsGet(& GetAddr, dsPtr, & addrCache, host, 1);
  return (tmp);
}
}
static int DnsGet(GetProc *getProc , Tcl_DString *dsPtr , Ns_Cache **cachePtr , char *key___1 ,
                  int all ) 
{ int status ;
  int new ;
  int timeout ;
  Value *vPtr ;
  Ns_Entry *ePtr ;
  Ns_Cache *cache ;
  time_t now ;
  char *p ;
  unsigned short const   **tmp ;

  {
  status = 0;
  vPtr = (Value *)((void *)0);
  ePtr = (Ns_Entry *)((void *)0);
  cache = (Ns_Cache *)((void *)0);
  Ns_MutexLock(& lock___2);
  cache = (*cachePtr);
  timeout = cachetimeout;
  Ns_MutexUnlock(& lock___2);
  if ((unsigned int )cache == (unsigned int )((void *)0)) {
    status = ((*getProc))(dsPtr, key___1);
  } else {
    time(& now);
    Ns_CacheLock(cache);
    ePtr = Ns_CacheCreateEntry(cache, key___1, & new);
    if (! new) {
      while (1) {
        if ((unsigned int )ePtr != (unsigned int )((void *)0)) {
          vPtr = (Value *)Ns_CacheGetValue(ePtr);
          if (! ((unsigned int )vPtr == (unsigned int )((void *)0))) {
            break;
          }
        } else {
          break;
        }
        Ns_CacheWait(cache);
        ePtr = Ns_CacheFindEntry(cache, key___1);
      }
      if ((unsigned int )ePtr == (unsigned int )((void *)0)) {
        status = 0;
      } else {
        if (vPtr->expires < now) {
          Ns_CacheUnsetValue(ePtr);
          new = 1;
        } else {
          Tcl_DStringAppend(dsPtr, vPtr->value, -1);
          status = 1;
        }
      }
    }
    if (new) {
      Ns_CacheUnlock(cache);
      status = ((*getProc))(dsPtr, key___1);
      Ns_CacheLock(cache);
      ePtr = Ns_CacheCreateEntry(cache, key___1, & new);
      if (status != 1) {
        Ns_CacheFlushEntry(ePtr);
      } else {
        Ns_CacheUnsetValue(ePtr);
        vPtr = (Value *)ns_malloc(sizeof(Value ) + (unsigned int )dsPtr->length);
        vPtr->expires = now + (long )timeout;
        strcpy((char * __restrict  )(vPtr->value), (char const   * __restrict  )dsPtr->string);
        Ns_CacheSetValueSz(ePtr, (void *)vPtr, 1U);
      }
      Ns_CacheBroadcast(cache);
    }
    Ns_CacheUnlock(cache);
  }
  if (status == 1) {
    if ((unsigned int )getProc == (unsigned int )(& GetAddr)) {
      if (! all) {
        p = dsPtr->string;
        while (1) {
          if ((*p)) {
            tmp = __ctype_b_loc();
            if ((int const   )(*((*tmp) + (int )((unsigned char )(*p)))) & 8192) {
              break;
            }
          } else {
            break;
          }
          p ++;
        }
        Tcl_DStringSetLength(dsPtr, p - dsPtr->string);
      }
    }
  }
  return (status);
}
}
void NsEnableDNSCache(int timeout , int maxentries ) 
{ 

  {
  Ns_MutexSetName(& lock___2, (char *)"ns:dns");
  Ns_MutexLock(& lock___2);
  cachetimeout = timeout;
  hostCache = Ns_CacheCreateSz((char *)"ns:dnshost", 0, (unsigned int )maxentries,
                               & ns_free);
  addrCache = Ns_CacheCreateSz((char *)"ns:dnsaddr", 0, (unsigned int )maxentries,
                               & ns_free);
  Ns_MutexUnlock(& lock___2);
  return;
}
}
static int GetHost(Tcl_DString *dsPtr , char *addr ) 
{ struct sockaddr_in sa ;
  char buf[1025] ;
  int result ;
  int status ;
  char const   *tmp ;

  {
  status = 0;
  sa.sin_family = (unsigned short)2;
  sa.sin_addr.s_addr = inet_addr((char const   *)addr);
  result = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr  const  *)(& sa)),
                       sizeof(struct sockaddr_in ), (char * __restrict  )(buf), sizeof(buf),
                       (char * __restrict  )((void *)0), 0U, 8U);
  if (result != 0) {
    tmp = gai_strerror(result);
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"dns: getnameinfo failed: %s",
           tmp);
  } else {
    Tcl_DStringAppend(dsPtr, buf, -1);
    status = 1;
  }
  return (status);
}
}
static int GetAddr(Tcl_DString *dsPtr , char *host ) 
{ struct addrinfo hints ;
  struct addrinfo *res ;
  struct addrinfo *ptr ;
  int result ;
  int status ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_107 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  char const   *tmp ;
  char *tmp___0 ;

  {
  status = 0;
  if (sizeof(hints) <= 16U) {
    if (sizeof(hints) == 1U) {
      __s___1 = (void *)(& hints);
      (*((__uint8_t *)__s___1)) = (unsigned char)0;
    } else {
      __s___0 = (void *)(& hints);
      __u = (union __anonunion___u_107 *)__s___0;
      __c = (unsigned char)0;
      switch ((int )sizeof(hints)) {
      case 15: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107 *)((void *)__u + 4);
      case 11: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107 *)((void *)__u + 4);
      case 7: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107 *)((void *)__u + 4);
      case 3: 
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
      __u = (union __anonunion___u_107 *)((void *)__u + 2);
      __u->__uc = __c;
      break;
      case 14: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107 *)((void *)__u + 4);
      case 10: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107 *)((void *)__u + 4);
      case 6: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107 *)((void *)__u + 4);
      case 2: 
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
      break;
      case 13: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107 *)((void *)__u + 4);
      case 9: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107 *)((void *)__u + 4);
      case 5: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107 *)((void *)__u + 4);
      case 1: 
      __u->__uc = __c;
      break;
      case 16: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107 *)((void *)__u + 4);
      case 12: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107 *)((void *)__u + 4);
      case 8: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107 *)((void *)__u + 4);
      case 4: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case 0: ;
      break;
      }
    }
  } else {
    __s = (void *)(& hints);
    __builtin_memset(__s, '\000', (int )sizeof(hints));
  }
  hints.ai_family = 2;
  hints.ai_socktype = 1;
  result = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )((void *)0),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& res));
  if (result != 0) {
    tmp = gai_strerror(result);
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"dns: getaddrinfo failed for %s: %s",
           host, tmp);
  } else {
    ptr = res;
    while ((unsigned int )ptr != (unsigned int )((void *)0)) {
      tmp___0 = ns_inet_ntoa(((struct sockaddr_in *)ptr->ai_addr)->sin_addr);
      Tcl_DStringAppendElement(dsPtr, tmp___0);
      ptr = ptr->ai_next;
    }
    freeaddrinfo(res);
    status = 1;
  }
  return (status);
}
}
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
extern int setsockopt(int __fd , int __level , int __optname , void const   *__optval ,
                      socklen_t __optlen ) ;
extern int shutdown(int __fd , int __how ) ;
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
extern struct hostent *gethostbyname(char const   *__name ) ;
char *ns_strdup(char const   *old ) ;
int Ns_DiffTime(Ns_Time *t1 , Ns_Time *t0 , Ns_Time *diffPtr ) ;
int Ns_DriverInit(char *server , char *module , Ns_DriverInitData *init ) ;
char *Ns_DStringExport(Tcl_DString *dsPtr ) ;
char *Ns_InfoHostname(void) ;
void Ns_FreeRequest(Ns_Request *request ) ;
Ns_Request *Ns_ParseRequest(char *line ) ;
void Ns_SetTrunc(Ns_Set *set , int size ) ;
int Ns_SockAccept(int lsock , struct sockaddr *saPtr , int *lenPtr ) ;
int Ns_SockSetNonBlocking(int sock ) ;
int ns_sockpair(int *socks ) ;
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
void NsInitDrivers(void) ;
int NsQueueConn(Sock *sockPtr , Ns_Time *nowPtr ) ;
Request *NsGetRequest(Sock *sockPtr ) ;
void NsFreeRequest(Request *reqPtr ) ;
void NsStopDrivers(void) ;
void NsStartDrivers(void) ;
void NsWaitDriversShutdown(Ns_Time *toPtr ) ;
static void DriverThread(void *ignored ) ;
static Sock *SockAccept(Driver *drvPtr ) ;
static void SockRelease(Sock *sockPtr , ReleaseReasons reason ) ;
static void SockTrigger(void) ;
static Driver *firstDrvPtr  ;
static Sock *firstClosePtr  ;
static int SockRead(Sock *sockPtr ) ;
static void SockPoll(Sock *sockPtr , Ns_Time *timeoutPtr ) ;
static void SockTimeout(Sock *sockPtr , Ns_Time *nowPtr , int timeout ) ;
static int SetServer(Sock *sockPtr ) ;
static Request *firstReqPtr  ;
static Ns_Mutex reqLock  ;
static Sock *firstSockPtr  ;
static int shutdownPending___0  ;
static int stopped  ;
static int nactive  ;
static Ns_Thread driverThread  ;
static int trigPipe[2]  ;
static Ns_Mutex lock___3  ;
static Ns_Cond cond___0  ;
static unsigned int nfds  ;
static unsigned int maxfds  ;
static struct pollfd *pfds  ;
static Tcl_HashTable hosts  ;
static ServerMap *defMapPtr  ;
void NsInitDrivers(void) 
{ 

  {
  Tcl_InitHashTable(& hosts, 0);
  return;
}
}
int Ns_DriverInit(char *server , char *module , Ns_DriverInitData *init ) 
{ char *path ;
  char *address ;
  char *host ;
  char *bindaddr ;
  char *defproto ;
  char *defserver ;
  int i ;
  int n ;
  int sockwait ;
  int defport ;
  ServerMap *mapPtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_DString ds ;
  Ns_Set *set ;
  struct in_addr ia ;
  struct hostent *he ;
  Driver *drvPtr ;
  NsServer *servPtr ;
  int controlFlag ;
  char *tmp___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___27 ;
  size_t tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
  servPtr = (NsServer *)((void *)0);
  if ((unsigned int )server != (unsigned int )((void *)0)) {
    servPtr = NsGetServer(server);
    if ((unsigned int )servPtr == (unsigned int )((void *)0)) {
      return (-1);
    }
  }
  if (init->version != 1) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"%s: version field of init argument is invalid: %d",
           module, init->version);
    return (-1);
  }
  if (init->path) {
    path = init->path;
  } else {
    path = Ns_ConfigGetPath(server, module, (void *)0);
  }
  host = Ns_ConfigGetValue(path, (char *)"hostname");
  address = Ns_ConfigGetValue(path, (char *)"address");
  bindaddr = address;
  defserver = Ns_ConfigGetValue(path, (char *)"defaultserver");
  if ((unsigned int )address == (unsigned int )((void *)0)) {
    if (host) {
      tmp___1 = host;
    } else {
      tmp___1 = Ns_InfoHostname();
    }
    he = gethostbyname((char const   *)tmp___1);
    if ((unsigned int )he != (unsigned int )((void *)0)) {
      if ((unsigned int )he->h_name != (unsigned int )((void *)0)) {
        tmp___3 = strchr((char const   *)he->h_name, '.');
        if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
          he = gethostbyaddr((void const   *)(*(he->h_addr_list + 0)), (unsigned int )he->h_length,
                             he->h_addrtype);
        }
      }
    }
    if ((unsigned int )he == (unsigned int )((void *)0)) {
      goto _L;
    } else {
      if ((unsigned int )he->h_name == (unsigned int )((void *)0)) {
        _L: 
        tmp___4 = __errno_location();
        tmp___5 = strerror((*tmp___4));
        if (host) {
          tmp___7 = host;
        } else {
          tmp___7 = Ns_InfoHostname();
        }
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"%s: could not resolve %s: %s",
               module, tmp___7, tmp___5);
        return (-1);
      }
    }
    if ((unsigned int )(*(he->h_addr_list)) == (unsigned int )((void *)0)) {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"%s: no addresses for %s",
             module, he->h_name);
      return (-1);
    }
    memcpy((void * __restrict  )(& ia.s_addr), (void const   * __restrict  )(*(he->h_addr_list)),
           sizeof(ia.s_addr));
    address = ns_inet_ntoa(ia);
    if ((unsigned int )host == (unsigned int )((void *)0)) {
      host = he->h_name;
    }
  }
  if ((unsigned int )host == (unsigned int )((void *)0)) {
    host = address;
  }
  if (init->opts & 2) {
    defproto = (char *)"https";
    defport = 443;
  } else {
    defproto = (char *)"http";
    defport = 80;
  }
  drvPtr = (Driver *)ns_calloc(1U, sizeof(Driver ));
  drvPtr->server = server;
  drvPtr->name = init->name;
  drvPtr->proc = init->proc;
  drvPtr->arg = init->arg;
  drvPtr->opts = init->opts;
  drvPtr->servPtr = servPtr;
  tmp___8 = Ns_ConfigGetInt(path, (char *)"bufsize", & n);
  if (tmp___8) {
    if (n < 1) {
      n = 16000;
    }
  } else {
    n = 16000;
  }
  drvPtr->bufsize = n;
  tmp___9 = Ns_ConfigGetInt(path, (char *)"rcvbuf", & n);
  if (! tmp___9) {
    n = 0;
  }
  drvPtr->rcvbuf = n;
  tmp___10 = Ns_ConfigGetInt(path, (char *)"sndbuf", & n);
  if (! tmp___10) {
    n = 0;
  }
  drvPtr->sndbuf = n;
  tmp___11 = Ns_ConfigGetInt(path, (char *)"socktimeout", & n);
  if (tmp___11) {
    if (n < 1) {
      n = 30;
    }
  } else {
    n = 30;
  }
  sockwait = n;
  tmp___12 = Ns_ConfigGetInt(path, (char *)"sendwait", & n);
  if (tmp___12) {
    if (n < 1) {
      n = sockwait;
    }
  } else {
    n = sockwait;
  }
  drvPtr->sendwait = n;
  tmp___13 = Ns_ConfigGetInt(path, (char *)"recvwait", & n);
  if (tmp___13) {
    if (n < 1) {
      n = sockwait;
    }
  } else {
    n = sockwait;
  }
  drvPtr->recvwait = n;
  tmp___14 = Ns_ConfigGetInt(path, (char *)"closewait", & n);
  if (tmp___14) {
    if (n < 0) {
      n = 2;
    }
  } else {
    n = 2;
  }
  drvPtr->closewait = n;
  tmp___15 = Ns_ConfigGetInt(path, (char *)"keepwait", & n);
  if (tmp___15) {
    if (n < 0) {
      n = 30;
    }
  } else {
    n = 30;
  }
  drvPtr->keepwait = n;
  tmp___16 = Ns_ConfigGetInt(path, (char *)"backlog", & n);
  if (tmp___16) {
    if (n < 1) {
      n = 5;
    }
  } else {
    n = 5;
  }
  drvPtr->backlog = n;
  tmp___17 = Ns_ConfigGetInt(path, (char *)"maxinput", & n);
  if (tmp___17) {
    if (n < 1) {
      n = 1024000;
    }
  } else {
    n = 1024000;
  }
  if (n > 1024) {
    drvPtr->maxinput = n;
  } else {
    drvPtr->maxinput = 1024;
  }
  drvPtr->loggingFlags = 0U;
  tmp___18 = Ns_ConfigGetBool(path, (char *)"readtimeoutlogging", & controlFlag);
  if (tmp___18) {
    if (controlFlag) {
      drvPtr->loggingFlags = drvPtr->loggingFlags | 1U;
    }
  }
  tmp___19 = Ns_ConfigGetBool(path, (char *)"serverrejectlogging", & controlFlag);
  if (tmp___19) {
    if (controlFlag) {
      drvPtr->loggingFlags = drvPtr->loggingFlags | 2U;
    }
  }
  tmp___20 = Ns_ConfigGetBool(path, (char *)"sockerrorlogging", & controlFlag);
  if (tmp___20) {
    if (controlFlag) {
      drvPtr->loggingFlags = drvPtr->loggingFlags | 4U;
    }
  }
  tmp___21 = Ns_ConfigGetBool(path, (char *)"sockshuterrorlogging", & controlFlag);
  if (tmp___21) {
    if (controlFlag) {
      drvPtr->loggingFlags = drvPtr->loggingFlags | 8U;
    }
  }
  drvPtr->bindaddr = bindaddr;
  drvPtr->address = ns_strdup((char const   *)address);
  tmp___22 = Ns_ConfigGetInt(path, (char *)"port", & drvPtr->port);
  if (! tmp___22) {
    drvPtr->port = defport;
  }
  drvPtr->location = Ns_ConfigGetValue(path, (char *)"location");
  if ((unsigned int )drvPtr->location != (unsigned int )((void *)0)) {
    drvPtr->location = ns_strdup((char const   *)drvPtr->location);
  } else {
    Tcl_DStringInit(& ds);
    Ns_DStringVarAppend(& ds, defproto, "://", host, (void *)0);
    if (drvPtr->port != defport) {
      Ns_DStringPrintf(& ds, (char *)":%d", drvPtr->port);
    }
    drvPtr->location = Ns_DStringExport(& ds);
  }
  drvPtr->nextPtr = firstDrvPtr;
  firstDrvPtr = drvPtr;
  maxfds ++;
  if ((unsigned int )server == (unsigned int )((void *)0)) {
    if ((unsigned int )defserver == (unsigned int )((void *)0)) {
      Ns_Fatal((char *)"%s: virtual servers configured, but %s has no defaultserver defined",
               module, path);
    }
    defMapPtr = (ServerMap *)((void *)0);
    path = Ns_ConfigGetPath((char *)((void *)0), module, "servers", (void *)0);
    set = Ns_ConfigGetSection(path);
    i = 0;
    while (1) {
      if ((unsigned int )set != (unsigned int )((void *)0)) {
        if (! (i < set->size)) {
          break;
        }
      } else {
        break;
      }
      server = (set->fields + i)->name;
      host = (set->fields + i)->value;
      servPtr = NsGetServer(server);
      if ((unsigned int )servPtr == (unsigned int )((void *)0)) {
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"%s: no such server: %s",
               module, server);
      } else {
        hPtr = ((*(hosts.createProc)))(& hosts, host, & n);
        if (! n) {
          Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"%s: duplicate host map: %s",
                 module, host);
        } else {
          Ns_DStringVarAppend(& ds, defproto, "://", host, (void *)0);
          mapPtr = (ServerMap *)ns_malloc(sizeof(ServerMap ) + (unsigned int )ds.length);
          mapPtr->servPtr = servPtr;
          strcpy((char * __restrict  )(mapPtr->location), (char const   * __restrict  )ds.string);
          Tcl_DStringSetLength(& ds, 0);
          if ((unsigned int )defMapPtr == (unsigned int )((void *)0)) {
            if ((int )(*defserver) == (int )(*server)) {
              if (0) {
                __s1_len = strlen((char const   *)defserver);
                __s2_len = strlen((char const   *)server);
                if (! ((unsigned int )((void const   *)(defserver + 1)) - (unsigned int )((void const   *)defserver) ==
                       1U)) {
                  goto _L___1;
                } else {
                  if (__s1_len >= 4U) {
                    _L___1: 
                    if (! ((unsigned int )((void const   *)(server + 1)) - (unsigned int )((void const   *)server) ==
                           1U)) {
                      tmp___30 = 1;
                    } else {
                      if (__s2_len >= 4U) {
                        tmp___30 = 1;
                      } else {
                        tmp___30 = 0;
                      }
                    }
                  } else {
                    tmp___30 = 0;
                  }
                }
                if (tmp___30) {
                  if (__s1_len < __s2_len) {
                    tmp___28 = __s1_len;
                  } else {
                    tmp___28 = __s2_len;
                  }
                  tmp___27 = memcmp((void const   *)((char const   *)defserver), (void const   *)((char const   *)server),
                                    tmp___28 + 1U);
                } else {
                  tmp___29 = strcmp((char const   *)defserver, (char const   *)server);
                  tmp___27 = tmp___29;
                }
              } else {
                tmp___29 = strcmp((char const   *)defserver, (char const   *)server);
                tmp___27 = tmp___29;
              }
              if (tmp___27 == 0) {
                defMapPtr = mapPtr;
              }
            }
          }
          hPtr->clientData = (void *)mapPtr;
        }
      }
      i ++;
    }
    if ((unsigned int )defMapPtr == (unsigned int )((void *)0)) {
      Ns_Fatal((char *)"%s: default server %s not defined in %s", module, path);
    }
  }
  return (0);
}
}
void *Ns_RegisterDriver(char *server , char *label , void *procs___0 , void *drvData ) 
{ 

  {
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"driver: loadable drivers no longer supported");
  return ((void *)0);
}
}
void *Ns_GetDriverContext(Ns_Driver drv ) 
{ 

  {
  return ((void *)0);
}
}
void NsStartDrivers(void) 
{ Driver *drvPtr ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  drvPtr = firstDrvPtr;
  while ((unsigned int )drvPtr != (unsigned int )((void *)0)) {
    drvPtr->sock = Ns_SockListenEx(drvPtr->bindaddr, drvPtr->port, drvPtr->backlog);
    if (drvPtr->sock == -1) {
      tmp = __errno_location();
      tmp___0 = strerror((*tmp));
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"%s: failed to listen on %s:%d: %s",
             drvPtr->name, drvPtr->address, drvPtr->port, tmp___0);
    } else {
      Ns_SockSetNonBlocking(drvPtr->sock);
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"%s: listening on %s:%d",
             drvPtr->name, drvPtr->address, drvPtr->port);
    }
    drvPtr = drvPtr->nextPtr;
  }
  tmp___3 = ns_sockpair(trigPipe);
  if (tmp___3 != 0) {
    tmp___1 = __errno_location();
    tmp___2 = strerror((*tmp___1));
    Ns_Fatal((char *)"driver: ns_sockpair() failed: %s", tmp___2);
  }
  Ns_ThreadCreate(& DriverThread, (void *)0, 0L, & driverThread);
  return;
}
}
void NsStopDrivers(void) 
{ 

  {
  Ns_MutexLock(& lock___3);
  if (! stopped) {
    if (! shutdownPending___0) {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"driver: triggering shutdown");
      shutdownPending___0 = 1;
      SockTrigger();
    }
  }
  Ns_MutexUnlock(& lock___3);
  return;
}
}
void NsWaitDriversShutdown(Ns_Time *toPtr ) 
{ int status ;

  {
  status = 0;
  Ns_MutexLock(& lock___3);
  while (1) {
    if (! stopped) {
      if (! (status == 0)) {
        break;
      }
    } else {
      break;
    }
    status = Ns_CondTimedWait(& cond___0, & lock___3, toPtr);
  }
  Ns_MutexUnlock(& lock___3);
  if (status != 0) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"driver: timeout waiting for shutdown");
  } else {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"driver: shutdown complete");
    driverThread = (struct Ns_Thread_ *)((void *)0);
    close(trigPipe[0]);
    close(trigPipe[1]);
  }
  return;
}
}
Request *NsGetRequest(Sock *sockPtr ) 
{ Request *reqPtr ;
  int status ;

  {
  if ((unsigned int )sockPtr->reqPtr == (unsigned int )((void *)0)) {
    while (1) {
      status = SockRead(sockPtr);
      if (! (status == 1)) {
        break;
      }
    }
    if (status != 0) {
      if ((unsigned int )sockPtr->reqPtr != (unsigned int )((void *)0)) {
        NsFreeRequest(sockPtr->reqPtr);
      }
      sockPtr->reqPtr = (Request *)((void *)0);
    }
  }
  reqPtr = sockPtr->reqPtr;
  sockPtr->reqPtr = (Request *)((void *)0);
  return (reqPtr);
}
}
void NsFreeRequest(Request *reqPtr ) 
{ 

  {
  reqPtr->content = (char *)((void *)0);
  reqPtr->next = reqPtr->content;
  reqPtr->avail = 0;
  reqPtr->length = reqPtr->avail;
  reqPtr->roff = 0;
  reqPtr->woff = reqPtr->roff;
  reqPtr->coff = reqPtr->woff;
  reqPtr->leadblanks = 0;
  Tcl_DStringFree(& reqPtr->buffer);
  Ns_SetTrunc(reqPtr->headers, 0);
  Ns_FreeRequest(reqPtr->request);
  reqPtr->request = (Ns_Request *)((void *)0);
  Ns_MutexLock(& reqLock);
  reqPtr->nextPtr = firstReqPtr;
  firstReqPtr = reqPtr;
  Ns_MutexUnlock(& reqLock);
  return;
}
}
int NsSockSend(Sock *sockPtr , struct iovec *bufs , int nbufs ) 
{ Ns_Sock *sock ;
  int tmp ;

  {
  sock = (Ns_Sock *)sockPtr;
  tmp = ((*((sockPtr->drvPtr)->proc)))((enum __anonenum_Ns_DriverCmd_69 )1, sock,
                                       bufs, nbufs);
  return (tmp);
}
}
void NsSockClose(Sock *sockPtr , int keep ) 
{ Ns_Sock *sock ;
  int trigger ;
  int tmp ;

  {
  sock = (Ns_Sock *)sockPtr;
  trigger = 0;
  if (keep) {
    tmp = ((*((sockPtr->drvPtr)->proc)))((enum __anonenum_Ns_DriverCmd_69 )2, sock,
                                         (struct iovec *)((void *)0), 0);
    if (tmp != 0) {
      keep = 0;
    }
  }
  if (! keep) {
    ((*((sockPtr->drvPtr)->proc)))((enum __anonenum_Ns_DriverCmd_69 )3, sock, (struct iovec *)((void *)0),
                                   0);
  }
  sockPtr->keep = keep;
  Ns_MutexLock(& lock___3);
  if ((unsigned int )firstClosePtr == (unsigned int )((void *)0)) {
    trigger = 1;
  }
  sockPtr->keep = keep;
  sockPtr->nextPtr = firstClosePtr;
  firstClosePtr = sockPtr;
  Ns_MutexUnlock(& lock___3);
  if (trigger) {
    SockTrigger();
  }
  return;
}
}
static void DriverThread(void *ignored ) 
{ char c ;
  int n ;
  int stopping ;
  int pollto ;
  Sock *sockPtr ;
  Sock *closePtr ;
  Sock *nextPtr ;
  Sock *waitPtr ;
  Sock *readPtr ;
  Driver *activeDrvPtr ;
  Driver *drvPtr ;
  Driver *nextDrvPtr ;
  Driver *idleDrvPtr ;
  Driver *acceptDrvPtr ;
  char drain[1024] ;
  Ns_Time timeout ;
  Ns_Time now ;
  Ns_Time diff ;
  unsigned int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  ssize_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  Ns_ThreadSetName((char *)"-driver-");
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"starting");
  activeDrvPtr = (Driver *)((void *)0);
  drvPtr = firstDrvPtr;
  firstDrvPtr = (Driver *)((void *)0);
  while ((unsigned int )drvPtr != (unsigned int )((void *)0)) {
    nextDrvPtr = drvPtr->nextPtr;
    if (drvPtr->sock != -1) {
      drvPtr->nextPtr = activeDrvPtr;
      activeDrvPtr = drvPtr;
    } else {
      drvPtr->nextPtr = firstDrvPtr;
      firstDrvPtr = drvPtr;
    }
    drvPtr = nextDrvPtr;
  }
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"driver: accepting connections");
  readPtr = (Sock *)((void *)0);
  waitPtr = readPtr;
  closePtr = waitPtr;
  Ns_GetTime(& now);
  stopping = 0;
  maxfds += 100U;
  pfds = (struct pollfd *)ns_malloc(sizeof(struct pollfd ) * maxfds);
  (pfds + 0)->fd = trigPipe[0];
  (pfds + 0)->events = (short)1;
  while (1) {
    if (! (! stopping)) {
      if (! nactive) {
        break;
      }
    }
    nfds = 1U;
    if ((unsigned int )waitPtr == (unsigned int )((void *)0)) {
      drvPtr = activeDrvPtr;
      while ((unsigned int )drvPtr != (unsigned int )((void *)0)) {
        (pfds + nfds)->fd = drvPtr->sock;
        (pfds + nfds)->events = (short)1;
        tmp = nfds;
        nfds ++;
        drvPtr->pidx = (int )tmp;
        drvPtr = drvPtr->nextPtr;
      }
    }
    if ((unsigned int )readPtr == (unsigned int )((void *)0)) {
      if ((unsigned int )closePtr == (unsigned int )((void *)0)) {
        pollto = -1;
      } else {
        goto _L;
      }
    } else {
      _L: 
      timeout.sec = 2147483647L;
      timeout.usec = 2147483647L;
      sockPtr = readPtr;
      while ((unsigned int )sockPtr != (unsigned int )((void *)0)) {
        SockPoll(sockPtr, & timeout);
        sockPtr = sockPtr->nextPtr;
      }
      sockPtr = closePtr;
      while ((unsigned int )sockPtr != (unsigned int )((void *)0)) {
        SockPoll(sockPtr, & timeout);
        sockPtr = sockPtr->nextPtr;
      }
      tmp___0 = Ns_DiffTime(& timeout, & now, & diff);
      if (tmp___0 > 0) {
        pollto = (int )(diff.sec * 1000L + diff.usec / 1000L);
      } else {
        pollto = 0;
      }
    }
    (pfds + 0)->revents = (short)0;
    while (1) {
      n = poll(pfds, (unsigned long )nfds, pollto);
      if (n < 0) {
        tmp___1 = __errno_location();
        if (! ((*tmp___1) == 4)) {
          break;
        }
      } else {
        break;
      }
    }
    if (n < 0) {
      tmp___2 = __errno_location();
      tmp___3 = strerror((*tmp___2));
      Ns_Fatal((char *)"driver: poll() failed: %s", tmp___3);
    }
    if ((int )(pfds + 0)->revents & 1) {
      tmp___6 = recv(trigPipe[0], (void *)(& c), 1U, 0);
      if (tmp___6 != 1) {
        tmp___4 = __errno_location();
        tmp___5 = strerror((*tmp___4));
        Ns_Fatal((char *)"driver: trigger recv() failed: %s", tmp___5);
      }
    }
    Ns_GetTime(& now);
    if ((unsigned int )closePtr != (unsigned int )((void *)0)) {
      sockPtr = closePtr;
      closePtr = (Sock *)((void *)0);
      while ((unsigned int )sockPtr != (unsigned int )((void *)0)) {
        nextPtr = sockPtr->nextPtr;
        if ((int )(pfds + sockPtr->pidx)->revents & 1) {
          n = recv(sockPtr->sock, (void *)(drain), sizeof(drain), 0);
          if (n <= 0) {
            sockPtr->timeout = now;
          }
        }
        tmp___7 = Ns_DiffTime(& sockPtr->timeout, & now, & diff);
        if (tmp___7 <= 0) {
          SockRelease(sockPtr, (enum __anonenum_ReleaseReasons_107 )0);
        } else {
          sockPtr->nextPtr = closePtr;
          closePtr = sockPtr;
        }
        sockPtr = nextPtr;
      }
    }
    sockPtr = readPtr;
    readPtr = (Sock *)((void *)0);
    while ((unsigned int )sockPtr != (unsigned int )((void *)0)) {
      nextPtr = sockPtr->nextPtr;
      if (! ((int )(pfds + sockPtr->pidx)->revents & 1)) {
        tmp___8 = Ns_DiffTime(& sockPtr->timeout, & now, & diff);
        if (tmp___8 <= 0) {
          SockRelease(sockPtr, (enum __anonenum_ReleaseReasons_107 )1);
        } else {
          sockPtr->nextPtr = readPtr;
          readPtr = sockPtr;
        }
      } else {
        sockPtr->keep = 0;
        if ((sockPtr->drvPtr)->opts & 1) {
          n = SockRead(sockPtr);
        } else {
          n = 0;
        }
        switch (n) {
        case 1: 
        SockTimeout(sockPtr, & now, (sockPtr->drvPtr)->recvwait);
        sockPtr->nextPtr = readPtr;
        readPtr = sockPtr;
        break;
        case 0: 
        tmp___9 = SetServer(sockPtr);
        if (tmp___9) {
          sockPtr->nextPtr = waitPtr;
          waitPtr = sockPtr;
        } else {
          SockRelease(sockPtr, (enum __anonenum_ReleaseReasons_107 )2);
        }
        break;
        default: 
        SockRelease(sockPtr, (enum __anonenum_ReleaseReasons_107 )3);
        break;
        }
      }
      sockPtr = nextPtr;
    }
    if ((unsigned int )waitPtr != (unsigned int )((void *)0)) {
      sockPtr = (Sock *)((void *)0);
      while (1) {
        nextPtr = waitPtr;
        if (! ((unsigned int )nextPtr != (unsigned int )((void *)0))) {
          break;
        }
        waitPtr = nextPtr->nextPtr;
        nextPtr->nextPtr = sockPtr;
        sockPtr = nextPtr;
      }
      while ((unsigned int )sockPtr != (unsigned int )((void *)0)) {
        nextPtr = sockPtr->nextPtr;
        if ((unsigned int )waitPtr != (unsigned int )((void *)0)) {
          sockPtr->nextPtr = waitPtr;
          waitPtr = sockPtr;
        } else {
          tmp___10 = NsQueueConn(sockPtr, & now);
          if (! tmp___10) {
            sockPtr->nextPtr = waitPtr;
            waitPtr = sockPtr;
          }
        }
        sockPtr = nextPtr;
      }
    }
    if ((unsigned int )waitPtr == (unsigned int )((void *)0)) {
      drvPtr = activeDrvPtr;
      acceptDrvPtr = (Driver *)((void *)0);
      idleDrvPtr = acceptDrvPtr;
      activeDrvPtr = idleDrvPtr;
      while ((unsigned int )drvPtr != (unsigned int )((void *)0)) {
        nextDrvPtr = drvPtr->nextPtr;
        if ((unsigned int )waitPtr != (unsigned int )((void *)0)) {
          drvPtr->nextPtr = idleDrvPtr;
          idleDrvPtr = drvPtr;
        } else {
          if (! ((int )(pfds + drvPtr->pidx)->revents & 1)) {
            drvPtr->nextPtr = idleDrvPtr;
            idleDrvPtr = drvPtr;
          } else {
            sockPtr = SockAccept(drvPtr);
            if ((unsigned int )sockPtr == (unsigned int )((void *)0)) {
              drvPtr->nextPtr = idleDrvPtr;
              idleDrvPtr = drvPtr;
            } else {
              drvPtr->nextPtr = acceptDrvPtr;
              acceptDrvPtr = drvPtr;
              SockTimeout(sockPtr, & now, (sockPtr->drvPtr)->recvwait);
              sockPtr->nextPtr = readPtr;
              readPtr = sockPtr;
            }
          }
        }
        drvPtr = nextDrvPtr;
      }
      while (1) {
        drvPtr = acceptDrvPtr;
        if (! ((unsigned int )drvPtr != (unsigned int )((void *)0))) {
          break;
        }
        acceptDrvPtr = drvPtr->nextPtr;
        drvPtr->nextPtr = activeDrvPtr;
        activeDrvPtr = drvPtr;
      }
      while (1) {
        drvPtr = idleDrvPtr;
        if (! ((unsigned int )drvPtr != (unsigned int )((void *)0))) {
          break;
        }
        idleDrvPtr = drvPtr->nextPtr;
        drvPtr->nextPtr = activeDrvPtr;
        activeDrvPtr = drvPtr;
      }
    }
    Ns_MutexLock(& lock___3);
    sockPtr = firstClosePtr;
    firstClosePtr = (Sock *)((void *)0);
    stopping = shutdownPending___0;
    Ns_MutexUnlock(& lock___3);
    while ((unsigned int )sockPtr != (unsigned int )((void *)0)) {
      nextPtr = sockPtr->nextPtr;
      if (sockPtr->keep) {
        SockTimeout(sockPtr, & now, (sockPtr->drvPtr)->keepwait);
        sockPtr->nextPtr = readPtr;
        readPtr = sockPtr;
      } else {
        tmp___11 = shutdown(sockPtr->sock, 1);
        if (tmp___11 != 0) {
          SockRelease(sockPtr, (enum __anonenum_ReleaseReasons_107 )4);
        } else {
          SockTimeout(sockPtr, & now, (sockPtr->drvPtr)->closewait);
          sockPtr->nextPtr = closePtr;
          closePtr = sockPtr;
        }
      }
      sockPtr = nextPtr;
    }
    if (stopping) {
      while (1) {
        drvPtr = activeDrvPtr;
        if (! ((unsigned int )drvPtr != (unsigned int )((void *)0))) {
          break;
        }
        activeDrvPtr = drvPtr->nextPtr;
        close(drvPtr->sock);
        drvPtr->sock = -1;
        drvPtr->nextPtr = firstDrvPtr;
        firstDrvPtr = drvPtr;
      }
    }
  }
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"exiting");
  Ns_MutexLock(& lock___3);
  stopped = 1;
  Ns_CondBroadcast(& cond___0);
  Ns_MutexUnlock(& lock___3);
  return;
}
}
static int SetServer(Sock *sockPtr ) 
{ ServerMap *mapPtr ;
  Tcl_HashEntry *hPtr ;
  char *host ;
  int status ;

  {
  mapPtr = (ServerMap *)((void *)0);
  status = 1;
  sockPtr->servPtr = (sockPtr->drvPtr)->servPtr;
  sockPtr->location = (sockPtr->drvPtr)->location;
  if (sockPtr->reqPtr) {
    host = Ns_SetIGet((sockPtr->reqPtr)->headers, (char *)"Host");
    if (! host) {
      if (((sockPtr->reqPtr)->request)->version >= 1.1) {
        status = 0;
      }
    }
  }
  if ((unsigned int )sockPtr->servPtr == (unsigned int )((void *)0)) {
    if (host) {
      hPtr = ((*(hosts.findProc)))(& hosts, host);
      if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
        mapPtr = (ServerMap *)hPtr->clientData;
      }
    }
    if (! mapPtr) {
      mapPtr = defMapPtr;
    }
    if (mapPtr) {
      sockPtr->servPtr = mapPtr->servPtr;
      sockPtr->location = mapPtr->location;
    }
    if ((unsigned int )sockPtr->servPtr == (unsigned int )((void *)0)) {
      status = 0;
    }
  }
  if (! status) {
    if (sockPtr->reqPtr) {
      ns_free((void *)((sockPtr->reqPtr)->request)->method);
      ((sockPtr->reqPtr)->request)->method = ns_strdup("BAD");
    }
  }
  return (1);
}
}
static void SockPoll(Sock *sockPtr , Ns_Time *timeoutPtr ) 
{ unsigned int tmp ;
  int tmp___0 ;

  {
  if (nfds >= maxfds) {
    maxfds += 100U;
    pfds = (struct pollfd *)ns_realloc((void *)pfds, maxfds * sizeof(struct pollfd ));
  }
  (pfds + nfds)->fd = sockPtr->sock;
  (pfds + nfds)->events = (short)1;
  (pfds + nfds)->revents = (short)0;
  tmp = nfds;
  nfds ++;
  sockPtr->pidx = (int )tmp;
  tmp___0 = Ns_DiffTime(& sockPtr->timeout, timeoutPtr, (Ns_Time *)((void *)0));
  if (tmp___0 < 0) {
    (*timeoutPtr) = sockPtr->timeout;
  }
  return;
}
}
static void SockTimeout(Sock *sockPtr , Ns_Time *nowPtr , int timeout ) 
{ 

  {
  sockPtr->timeout = (*nowPtr);
  Ns_IncrTime(& sockPtr->timeout, (long )timeout, 0L);
  return;
}
}
static Sock *SockAccept(Driver *drvPtr ) 
{ Sock *sockPtr ;
  int slen ;

  {
  sockPtr = firstSockPtr;
  if ((unsigned int )sockPtr != (unsigned int )((void *)0)) {
    firstSockPtr = sockPtr->nextPtr;
  } else {
    sockPtr = (Sock *)ns_malloc(sizeof(Sock ));
    sockPtr->reqPtr = (Request *)((void *)0);
  }
  slen = (int )sizeof(struct sockaddr_in );
  sockPtr->drvPtr = drvPtr;
  sockPtr->keep = 0;
  sockPtr->arg = (void *)0;
  sockPtr->sock = Ns_SockAccept(drvPtr->sock, (struct sockaddr *)(& sockPtr->sa),
                                & slen);
  if (sockPtr->sock == -1) {
    sockPtr->nextPtr = firstSockPtr;
    firstSockPtr = sockPtr;
    return ((Sock *)((void *)0));
  }
  Ns_SockSetNonBlocking(sockPtr->sock);
  if (drvPtr->sndbuf > 0) {
    setsockopt(sockPtr->sock, 1, 7, (void const   *)((char *)(& drvPtr->sndbuf)),
               sizeof(drvPtr->sndbuf));
  }
  if (drvPtr->rcvbuf > 0) {
    setsockopt(sockPtr->sock, 1, 8, (void const   *)((char *)(& drvPtr->rcvbuf)),
               sizeof(drvPtr->rcvbuf));
  }
  nactive ++;
  return (sockPtr);
}
}
static void SockRelease(Sock *sockPtr , ReleaseReasons reason ) 
{ char *errMsg ;
  register unsigned short __v ;
  register unsigned short __x ;
  char *tmp ;

  {
  errMsg = (char *)((void *)0);
  switch ((int )reason) {
  case 0: ;
  break;
  case 1: ;
  if (! sockPtr->keep) {
    if ((sockPtr->drvPtr)->loggingFlags & 1U) {
      errMsg = (char *)"Timeout during read";
    }
  }
  break;
  case 2: ;
  if ((sockPtr->drvPtr)->loggingFlags & 2U) {
    errMsg = (char *)"No Server found for request";
  }
  break;
  case 3: ;
  if ((sockPtr->drvPtr)->loggingFlags & 4U) {
    errMsg = (char *)"Unable to read request";
  }
  break;
  case 4: ;
  if ((sockPtr->drvPtr)->loggingFlags & 8U) {
    errMsg = (char *)"Unable to shutdown socket";
  }
  break;
  }
  if ((unsigned int )errMsg != (unsigned int )((void *)0)) {
    __x = sockPtr->sa.sin_port;
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
    tmp = ns_inet_ntoa(sockPtr->sa.sin_addr);
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"Releasing Socket; %s, Peer =  %s:%d",
           errMsg, tmp, __v);
  }
  nactive --;
  close(sockPtr->sock);
  sockPtr->sock = -1;
  if ((unsigned int )sockPtr->reqPtr != (unsigned int )((void *)0)) {
    NsFreeRequest(sockPtr->reqPtr);
    sockPtr->reqPtr = (Request *)((void *)0);
  }
  sockPtr->nextPtr = firstSockPtr;
  firstSockPtr = sockPtr;
  return;
}
}
static void SockTrigger(void) 
{ int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
  tmp___1 = send(trigPipe[1], (void const   *)"", 1U, 0);
  if (tmp___1 != 1) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Ns_Fatal((char *)"driver: trigger send() failed: %s", tmp___0);
  }
  return;
}
}
static int SockRead(Sock *sockPtr ) 
{ Ns_Sock *sock ;
  struct iovec buf ;
  Request *reqPtr ;
  Tcl_DString *bufPtr ;
  char *s ;
  char *e___1 ;
  char save ;
  int cnt ;
  int len ;
  int nread ;
  int n ;
  register unsigned short __v ;
  register unsigned short __x ;
  char *tmp ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  sock = (Ns_Sock *)sockPtr;
  reqPtr = sockPtr->reqPtr;
  if ((unsigned int )reqPtr == (unsigned int )((void *)0)) {
    Ns_MutexLock(& reqLock);
    reqPtr = firstReqPtr;
    if ((unsigned int )reqPtr != (unsigned int )((void *)0)) {
      firstReqPtr = reqPtr->nextPtr;
    }
    Ns_MutexUnlock(& reqLock);
    if ((unsigned int )reqPtr == (unsigned int )((void *)0)) {
      reqPtr = (Request *)ns_malloc(sizeof(Request ));
      Tcl_DStringInit(& reqPtr->buffer);
      reqPtr->headers = Ns_SetCreate((char *)((void *)0));
      reqPtr->request = (Ns_Request *)((void *)0);
      reqPtr->content = (char *)((void *)0);
      reqPtr->next = reqPtr->content;
      reqPtr->avail = 0;
      reqPtr->length = reqPtr->avail;
      reqPtr->roff = 0;
      reqPtr->woff = reqPtr->roff;
      reqPtr->coff = reqPtr->woff;
      reqPtr->leadblanks = 0;
    }
    sockPtr->reqPtr = reqPtr;
    __x = sockPtr->sa.sin_port;
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
    reqPtr->port = (int )__v;
    tmp = ns_inet_ntoa(sockPtr->sa.sin_addr);
    strcpy((char * __restrict  )(reqPtr->peer), (char const   * __restrict  )tmp);
  }
  bufPtr = & reqPtr->buffer;
  if (reqPtr->length == 0) {
    nread = (sockPtr->drvPtr)->bufsize;
  } else {
    nread = reqPtr->length - reqPtr->avail;
  }
  len = bufPtr->length;
  n = len + nread;
  if (n > (sockPtr->drvPtr)->maxinput) {
    n = (sockPtr->drvPtr)->maxinput;
    nread = n - len;
    if (nread == 0) {
      return (-1);
    }
  }
  Tcl_DStringSetLength(bufPtr, len + nread);
  buf.iov_base = (void *)(bufPtr->string + reqPtr->woff);
  buf.iov_len = (unsigned int )nread;
  n = ((*((sockPtr->drvPtr)->proc)))((enum __anonenum_Ns_DriverCmd_69 )0, sock, & buf,
                                     1);
  if (n <= 0) {
    return (-1);
  }
  Tcl_DStringSetLength(bufPtr, len + n);
  reqPtr->woff = reqPtr->woff + n;
  reqPtr->avail = reqPtr->avail + n;
  while (reqPtr->coff == 0) {
    s = bufPtr->string + reqPtr->roff;
    tmp___1 = strchr((char const   *)s, '\n');
    e___1 = tmp___1;
    if ((unsigned int )e___1 == (unsigned int )((void *)0)) {
      return (1);
    }
    cnt = (e___1 - s) + 1;
    reqPtr->roff = reqPtr->roff + cnt;
    reqPtr->avail = reqPtr->avail - cnt;
    if ((unsigned int )e___1 > (unsigned int )s) {
      if ((int )(*(e___1 + -1)) == 13) {
        e___1 --;
      }
    }
    if ((unsigned int )e___1 == (unsigned int )s) {
      if (bufPtr->length == 0) {
        reqPtr->leadblanks = reqPtr->leadblanks + 1;
        if (reqPtr->leadblanks > 2) {
          return (-1);
        }
        reqPtr->roff = 0;
        reqPtr->woff = reqPtr->roff;
        Tcl_DStringSetLength(bufPtr, 0);
        return (1);
      }
      reqPtr->coff = reqPtr->roff;
      s = Ns_SetIGet(reqPtr->headers, (char *)"content-length");
      if ((unsigned int )s != (unsigned int )((void *)0)) {
        reqPtr->length = atoi__extinline((char const   *)s);
        if (reqPtr->length < 0) {
          if (reqPtr->length > ((sockPtr->drvPtr)->servPtr)->limits.maxpost) {
            return (-1);
          }
        }
      }
    } else {
      save = (*e___1);
      (*e___1) = (char )'\000';
      if ((unsigned int )reqPtr->request == (unsigned int )((void *)0)) {
        reqPtr->request = Ns_ParseRequest(s);
        if ((unsigned int )reqPtr->request == (unsigned int )((void *)0)) {
          return (-1);
        }
      } else {
        tmp___2 = Ns_ParseHeader(reqPtr->headers, s, (enum __anonenum_Ns_HeaderCaseDisposition_68 )0);
        if (tmp___2 != 0) {
          return (-1);
        }
      }
      (*e___1) = save;
      if ((reqPtr->request)->version <= 0.0) {
        reqPtr->coff = reqPtr->roff;
      }
    }
  }
  if (reqPtr->coff > 0) {
    if (reqPtr->length <= reqPtr->avail) {
      reqPtr->content = bufPtr->string + reqPtr->coff;
      reqPtr->next = reqPtr->content;
      reqPtr->avail = reqPtr->length;
      if (reqPtr->length > 0) {
        (*(reqPtr->content + reqPtr->length)) = (char )'\000';
      }
      if (reqPtr->request) {
        tmp___3 = 0;
      } else {
        tmp___3 = -1;
      }
      return (tmp___3);
    }
  }
  return (1);
}
}
extern void *memchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__)) ;
char *Ns_DStringVPrintf(Tcl_DString *dsPtr , char *fmt0 , va_list ap ) ;
char *Ns_DStringVPrintf(Tcl_DString *dsPtr , char *fmt0 , va_list ap ) 
{ char *fmt ;
  int ch ;
  int n ;
  char *cp ;
  char *bp ;
  int flags ;
  int width ;
  int prec ;
  char sign ;
  double _double ;
  ns_uint64 _uquad ;
  enum __anonenum_base_107 base ;
  int dprec ;
  int realsz ;
  int size ;
  char *xdigs ;
  char buf[348] ;
  char ox[2] ;
  int slen ;
  int len ;
  char *tfmt ;
  Tcl_DString tfmtds ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___23 ;
  int tmp___24 ;
  long double tmp___25 ;
  ns_int64 *tmp___26 ;
  long *tmp___27 ;
  short *tmp___28 ;
  int *tmp___29 ;
  int tmp___50 ;
  u_int tmp___51 ;
  void *tmp___52 ;
  char *p ;
  char *tmp___53 ;
  int tmp___74 ;
  u_int tmp___75 ;
  int tmp___96 ;
  u_int tmp___97 ;
  char *tmp___98 ;
  char *tmp___99 ;
  char *tmp___100 ;
  char *tmp___101 ;

  {
  _double = (double )0;
  xdigs = (char *)((void *)0);
  Tcl_DStringInit(& tfmtds);
  fmt = fmt0;
  slen = dsPtr->length;
  while (1) {
    cp = fmt;
    while (1) {
      ch = (int )(*fmt);
      if (ch != 0) {
        if (! (ch != 37)) {
          break;
        }
      } else {
        break;
      }
      fmt ++;
    }
    n = fmt - cp;
    if (n != 0) {
      Tcl_DStringAppend(dsPtr, cp, n);
    }
    if (ch == 0) {
      goto done;
    }
    tfmt = fmt;
    fmt ++;
    flags = 0;
    dprec = 0;
    width = 0;
    prec = -1;
    sign = (char )'\000';
    rflag: 
    tmp = fmt;
    fmt ++;
    ch = (int )(*tmp);
    reswitch: 
    switch (ch) {
    case 32: ;
    if (! sign) {
      sign = (char )' ';
    }
    goto rflag;
    case 35: 
    flags |= 1;
    goto rflag;
    case 42: 
    width = __builtin_va_arg(ap, int );
    if (width >= 0) {
      goto rflag;
    }
    width = - width;
    case 45: 
    flags |= 4;
    goto rflag;
    case 43: 
    sign = (char )'+';
    goto rflag;
    case 46: 
    tmp___0 = fmt;
    fmt ++;
    ch = (int )(*tmp___0);
    if (ch == 42) {
      n = __builtin_va_arg(ap, int );
      if (n < 0) {
        prec = -1;
      } else {
        prec = n;
      }
      goto rflag;
    }
    n = 0;
    while ((unsigned int )(ch - 48) <= 9U) {
      n = 10 * n + (ch - 48);
      tmp___1 = fmt;
      fmt ++;
      ch = (int )(*tmp___1);
    }
    if (n < 0) {
      prec = -1;
    } else {
      prec = n;
    }
    goto reswitch;
    case 48: 
    flags |= 128;
    goto rflag;
    case 49: ;
    case 50: ;
    case 51: ;
    case 52: ;
    case 53: ;
    case 54: ;
    case 55: ;
    case 56: ;
    case 57: 
    n = 0;
    while (1) {
      n = 10 * n + (ch - 48);
      tmp___2 = fmt;
      fmt ++;
      ch = (int )(*tmp___2);
      if (! ((unsigned int )(ch - 48) <= 9U)) {
        break;
      }
    }
    width = n;
    goto reswitch;
    case 76: 
    flags |= 8;
    goto rflag;
    case 104: 
    flags |= 64;
    goto rflag;
    case 108: ;
    if ((int )(*fmt) == 108) {
      fmt ++;
      flags |= 32;
    } else {
      flags |= 16;
    }
    goto rflag;
    case 113: 
    flags |= 32;
    goto rflag;
    case 99: 
    buf[0] = __builtin_va_arg(ap, int );
    cp = buf;
    size = 1;
    sign = (char )'\000';
    break;
    case 68: 
    flags |= 16;
    case 100: ;
    case 105: ;
    if (flags & 32) {
      _uquad = __builtin_va_arg(ap, ns_int64 );
    } else {
      if (flags & 16) {
        _uquad = __builtin_va_arg(ap, long );
      } else {
        if (flags & 64) {
          tmp___23 = __builtin_va_arg(ap, int );
          _uquad = (unsigned long long )((long )((short )tmp___23));
        } else {
          tmp___24 = __builtin_va_arg(ap, int );
          _uquad = (unsigned long long )((long )tmp___24);
        }
      }
    }
    if ((long long )_uquad < 0LL) {
      _uquad = - _uquad;
      sign = (char )'-';
    }
    base = (enum __anonenum_base_107 )1;
    goto number;
    case 101: ;
    case 69: ;
    case 102: ;
    case 103: ;
    case 71: ;
    if (flags & 8) {
      tmp___25 = __builtin_va_arg(ap, long double );
      _double = (double )tmp___25;
    } else {
      _double = __builtin_va_arg(ap, double );
    }
    tfmt = Tcl_DStringAppend(& tfmtds, tfmt, fmt - tfmt);
    n = width;
    if (n < 348) {
      n = sprintf((char * __restrict  )(buf), (char const   * __restrict  )tfmt, _double);
      Tcl_DStringAppend(dsPtr, buf, n);
    } else {
      len = dsPtr->length;
      Tcl_DStringSetLength(dsPtr, len + n);
      sprintf((char * __restrict  )(dsPtr->string + len), (char const   * __restrict  )tfmt,
              _double);
      Tcl_DStringSetLength(dsPtr, len + n);
    }
    Tcl_DStringSetLength(& tfmtds, 0);
    goto __Cont;
    case 110: 
    n = dsPtr->length - slen;
    if (flags & 32) {
      tmp___26 = __builtin_va_arg(ap, ns_int64 *);
      (*tmp___26) = (long long )n;
    } else {
      if (flags & 16) {
        tmp___27 = __builtin_va_arg(ap, long *);
        (*tmp___27) = (long )n;
      } else {
        if (flags & 64) {
          tmp___28 = __builtin_va_arg(ap, short *);
          (*tmp___28) = (short )n;
        } else {
          tmp___29 = __builtin_va_arg(ap, int *);
          (*tmp___29) = n;
        }
      }
    }
    goto __Cont;
    case 79: 
    flags |= 16;
    case 111: ;
    if (flags & 32) {
      _uquad = __builtin_va_arg(ap, ns_uint64 );
    } else {
      if (flags & 16) {
        _uquad = __builtin_va_arg(ap, u_long );
      } else {
        if (flags & 64) {
          tmp___50 = __builtin_va_arg(ap, int );
          _uquad = (unsigned long long )((unsigned long )((unsigned short )tmp___50));
        } else {
          tmp___51 = __builtin_va_arg(ap, u_int );
          _uquad = (unsigned long long )((unsigned long )tmp___51);
        }
      }
    }
    base = (enum __anonenum_base_107 )0;
    goto nosign;
    case 112: 
    tmp___52 = __builtin_va_arg(ap, void *);
    _uquad = (unsigned long long )((unsigned long )tmp___52);
    base = (enum __anonenum_base_107 )2;
    xdigs = (char *)"0123456789abcdef";
    flags |= 2;
    ch = 'x';
    goto nosign;
    case 115: 
    cp = __builtin_va_arg(ap, char *);
    if ((unsigned int )cp == (unsigned int )((void *)0)) {
      cp = (char *)"(null)";
    }
    if (prec >= 0) {
      tmp___53 = (char *)memchr((void const   *)cp, 0, (unsigned int )prec);
      p = tmp___53;
      if ((unsigned int )p != (unsigned int )((void *)0)) {
        size = p - cp;
        if (size > prec) {
          size = prec;
        }
      } else {
        size = prec;
      }
    } else {
      size = (int )strlen((char const   *)cp);
    }
    sign = (char )'\000';
    break;
    case 85: 
    flags |= 16;
    case 117: ;
    if (flags & 32) {
      _uquad = __builtin_va_arg(ap, ns_uint64 );
    } else {
      if (flags & 16) {
        _uquad = __builtin_va_arg(ap, u_long );
      } else {
        if (flags & 64) {
          tmp___74 = __builtin_va_arg(ap, int );
          _uquad = (unsigned long long )((unsigned long )((unsigned short )tmp___74));
        } else {
          tmp___75 = __builtin_va_arg(ap, u_int );
          _uquad = (unsigned long long )((unsigned long )tmp___75);
        }
      }
    }
    base = (enum __anonenum_base_107 )1;
    goto nosign;
    case 88: 
    xdigs = (char *)"0123456789ABCDEF";
    goto hex;
    case 120: 
    xdigs = (char *)"0123456789abcdef";
    hex: 
    if (flags & 32) {
      _uquad = __builtin_va_arg(ap, ns_uint64 );
    } else {
      if (flags & 16) {
        _uquad = __builtin_va_arg(ap, u_long );
      } else {
        if (flags & 64) {
          tmp___96 = __builtin_va_arg(ap, int );
          _uquad = (unsigned long long )((unsigned long )((unsigned short )tmp___96));
        } else {
          tmp___97 = __builtin_va_arg(ap, u_int );
          _uquad = (unsigned long long )((unsigned long )tmp___97);
        }
      }
    }
    base = (enum __anonenum_base_107 )2;
    if (flags & 1) {
      if (_uquad != 0ULL) {
        flags |= 2;
      }
    }
    nosign: 
    sign = (char )'\000';
    number: 
    dprec = prec;
    if (dprec >= 0) {
      flags &= -129;
    }
    bp = buf + 348;
    if (_uquad != 0ULL) {
      goto _L;
    } else {
      if (prec != 0) {
        _L: 
        switch ((int )base) {
        case 0: ;
        while (1) {
          bp --;
          (*bp) = (char )((_uquad & 7ULL) + 48ULL);
          _uquad >>= 3;
          if (! _uquad) {
            break;
          }
        }
        if (flags & 1) {
          if ((int )(*bp) != 48) {
            bp --;
            (*bp) = (char )'0';
          }
        }
        break;
        case 1: ;
        while (_uquad >= 10ULL) {
          bp --;
          (*bp) = (char )(_uquad % 10ULL + 48ULL);
          _uquad /= 10ULL;
        }
        bp --;
        (*bp) = (char )(_uquad + 48ULL);
        break;
        case 2: ;
        while (1) {
          bp --;
          (*bp) = (*(xdigs + (unsigned int )(_uquad & 15ULL)));
          _uquad >>= 4;
          if (! _uquad) {
            break;
          }
        }
        break;
        default: 
        cp = (char *)"bug in vfprintf: bad base";
        size = (int )strlen((char const   *)cp);
        goto skipsize;
        }
      }
    }
    cp = bp;
    size = (buf + 348) - bp;
    skipsize: 
    break;
    default: ;
    if (ch == 0) {
      goto done;
    }
    buf[0] = (char )ch;
    cp = buf;
    size = 1;
    sign = (char )'\000';
    break;
    }
    if (dprec > size) {
      realsz = dprec;
    } else {
      realsz = size;
    }
    if (sign) {
      realsz ++;
    } else {
      if (flags & 2) {
        realsz += 2;
      }
    }
    if ((flags & 132) == 0) {
      n = width - realsz;
      if (n > 0) {
        len = dsPtr->length;
        Tcl_DStringSetLength(dsPtr, len + n);
        bp = dsPtr->string + len;
        while (n > 0) {
          tmp___98 = bp;
          bp ++;
          (*tmp___98) = (char )' ';
          n --;
        }
      }
    }
    if (sign) {
      Tcl_DStringAppend(dsPtr, & sign, 1);
    } else {
      if (flags & 2) {
        ox[0] = (char )'0';
        ox[1] = (char )ch;
        Tcl_DStringAppend(dsPtr, ox, 2);
      }
    }
    if ((flags & 132) == 128) {
      n = width - realsz;
      if (n > 0) {
        len = dsPtr->length;
        Tcl_DStringSetLength(dsPtr, len + n);
        bp = dsPtr->string + len;
        while (n > 0) {
          tmp___99 = bp;
          bp ++;
          (*tmp___99) = (char )'0';
          n --;
        }
      }
    }
    n = dprec - size;
    if (n > 0) {
      len = dsPtr->length;
      Tcl_DStringSetLength(dsPtr, len + n);
      bp = dsPtr->string + len;
      while (n > 0) {
        tmp___100 = bp;
        bp ++;
        (*tmp___100) = (char )'0';
        n --;
      }
    }
    Tcl_DStringAppend(dsPtr, cp, size);
    if (flags & 4) {
      n = width - realsz;
      if (n > 0) {
        len = dsPtr->length;
        Tcl_DStringSetLength(dsPtr, len + n);
        bp = dsPtr->string + len;
        while (n > 0) {
          tmp___101 = bp;
          bp ++;
          (*tmp___101) = (char )' ';
          n --;
        }
      }
    }
    __Cont: ;
  }
  done: 
  Tcl_DStringFree(& tfmtds);
  return (dsPtr->string);
}
}
char **Ns_DStringAppendArgv(Tcl_DString *dsPtr ) ;
char *Ns_DStringAppendArg(Tcl_DString *dsPtr , char *string ) ;
Tcl_DString *Ns_DStringPop(void) ;
void Ns_DStringPush(Tcl_DString *dsPtr ) ;
char *Ns_DStringVarAppend(Tcl_DString *dsPtr  , ...) 
{ register char *s ;
  va_list ap ;

  {
  __builtin_stdarg_start(ap, dsPtr);
  while (1) {
    s = __builtin_va_arg(ap, char *);
    if (! ((unsigned int )s != (unsigned int )((void *)0))) {
      break;
    }
    Tcl_DStringAppend(dsPtr, s, -1);
  }
  __builtin_va_end(ap);
  return (dsPtr->string);
}
}
char *Ns_DStringExport(Tcl_DString *dsPtr ) 
{ char *s ;

  {
  if ((unsigned int )dsPtr->string != (unsigned int )(dsPtr->staticSpace)) {
    s = dsPtr->string;
    dsPtr->string = dsPtr->staticSpace;
  } else {
    s = (char *)ns_malloc((unsigned int )dsPtr->length + 1U);
    memcpy((void * __restrict  )s, (void const   * __restrict  )dsPtr->string, (unsigned int )(dsPtr->length +
                                                                                               1));
  }
  Tcl_DStringFree(dsPtr);
  return (s);
}
}
char *Ns_DStringAppendArg(Tcl_DString *dsPtr , char *string ) 
{ size_t tmp ;
  char *tmp___0 ;

  {
  tmp = strlen((char const   *)string);
  tmp___0 = Tcl_DStringAppend(dsPtr, string, (int )tmp + 1);
  return (tmp___0);
}
}
char *Ns_DStringPrintf(Tcl_DString *dsPtr , char *fmt  , ...) 
{ char *str ;
  va_list ap ;

  {
  __builtin_stdarg_start(ap, fmt);
  str = Ns_DStringVPrintf(dsPtr, fmt, ap);
  __builtin_va_end(ap);
  return (str);
}
}
char **Ns_DStringAppendArgv(Tcl_DString *dsPtr ) 
{ char *s ;
  char **argv ;
  int i ;
  int argc ;
  int len ;
  int size ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  argc = 0;
  s = dsPtr->string;
  while ((int )(*s) != 0) {
    argc ++;
    tmp = strlen((char const   *)s);
    s += tmp + 1U;
  }
  len = (dsPtr->length / 8 + 1) * 8;
  size = (int )((unsigned int )len + sizeof(char *) * (unsigned int )(argc + 1));
  Tcl_DStringSetLength(dsPtr, size);
  s = dsPtr->string;
  argv = (char **)(s + len);
  i = 0;
  while (i < argc) {
    (*(argv + i)) = s;
    tmp___0 = strlen((char const   *)s);
    s += tmp___0 + 1U;
    i ++;
  }
  (*(argv + i)) = (char *)((void *)0);
  return (argv);
}
}
Tcl_DString *Ns_DStringPop(void) 
{ Tcl_DString *dsPtr ;

  {
  dsPtr = (Tcl_DString *)ns_malloc(sizeof(Tcl_DString ));
  Tcl_DStringInit(dsPtr);
  return (dsPtr);
}
}
void Ns_DStringPush(Tcl_DString *dsPtr ) 
{ 

  {
  Tcl_DStringFree(dsPtr);
  ns_free((void *)dsPtr);
  return;
}
}
void Ns_DStringInit(Tcl_DString *dsPtr ) 
{ 

  {
  Tcl_DStringInit(dsPtr);
  return;
}
}
void Ns_DStringFree(Tcl_DString *dsPtr ) 
{ 

  {
  Tcl_DStringFree(dsPtr);
  return;
}
}
void Ns_DStringSetLength(Tcl_DString *dsPtr , int length ) 
{ 

  {
  Tcl_DStringSetLength(dsPtr, length);
  return;
}
}
void Ns_DStringTrunc(Tcl_DString *dsPtr , int length ) 
{ 

  {
  Tcl_DStringSetLength(dsPtr, length);
  return;
}
}
char *Ns_DStringNAppend(Tcl_DString *dsPtr , char *string , int length ) 
{ char *tmp ;

  {
  tmp = Tcl_DStringAppend(dsPtr, string, length);
  return (tmp);
}
}
char *Ns_DStringAppend(Tcl_DString *dsPtr , char *string ) 
{ char *tmp ;

  {
  tmp = Tcl_DStringAppend(dsPtr, string, -1);
  return (tmp);
}
}
char *Ns_DStringAppendElement(Tcl_DString *dsPtr , char *string ) 
{ char *tmp ;

  {
  tmp = Tcl_DStringAppendElement(dsPtr, string);
  return (tmp);
}
}
int Ns_DStringLength(Tcl_DString *dsPtr ) 
{ 

  {
  return (dsPtr->length);
}
}
char *Ns_DStringValue(Tcl_DString *dsPtr ) 
{ 

  {
  return (dsPtr->string);
}
}
extern size_t strspn(char const   *__s , char const   *__accept )  __attribute__((__pure__)) ;
extern int strncasecmp(char const   *__s1 , char const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
extern Tcl_Encoding Tcl_GetEncoding(Tcl_Interp *interp , char *name ) ;
Ns_Conn *Ns_GetConn(void) ;
char *Ns_StrTrim(char *string ) ;
char *Ns_StrToLower(char *string ) ;
char *Ns_StrCaseFind(char *string , char *substring ) ;
void NsInitEncodings(void) ;
void NsUpdateEncodings(void) ;
Tcl_Encoding NsGetTypeEncodingWithDef(char *type , int *used_default ) ;
void NsComputeEncodingFromType(char *type , Tcl_Encoding *enc___0 , int *new_type ,
                               Tcl_DString *type_ds ) ;
static void AddExtension(char *ext , char *name ) ;
static void AddCharset(char *charset , char *name ) ;
static Tcl_Encoding GetCharsetEncoding(char *charset , int len ) ;
static char *RebuildCharsetList(void) ;
static int GetDefaultHackContentTypeP(void) ;
static Tcl_Encoding GetDefaultCharset(void) ;
static Tcl_Encoding GetDefaultEncoding(void) ;
static Tcl_HashTable encodings  ;
static Tcl_HashTable charsets  ;
static Tcl_HashTable extensions  ;
static Ns_Mutex lock___4  ;
static Ns_Cond cond___1  ;
static char *charsetList  =    (char *)((void *)0);
static struct __anonstruct_builtinExt_107 builtinExt[5]  = {      {(char *)".txt", (char *)"ascii"}, 
        {(char *)".htm", (char *)"iso8859-1"}, 
        {(char *)".html", (char *)"iso8859-1"}, 
        {(char *)".adp", (char *)"iso8859-1"}, 
        {(char *)((void *)0), (char *)((void *)0)}};
static struct __anonstruct_builtinChar_108 builtinChar[65]  = 
  {      {(char *)"iso-2022-jp", (char *)"iso2022-jp"}, 
        {(char *)"iso-2022-kr", (char *)"iso2022-kr"}, 
        {(char *)"iso-8859-1", (char *)"iso8859-1"}, 
        {(char *)"iso-8859-2", (char *)"iso8859-2"}, 
        {(char *)"iso-8859-3", (char *)"iso8859-3"}, 
        {(char *)"iso-8859-4", (char *)"iso8859-4"}, 
        {(char *)"iso-8859-5", (char *)"iso8859-5"}, 
        {(char *)"iso-8859-6", (char *)"iso8859-6"}, 
        {(char *)"iso-8859-7", (char *)"iso8859-7"}, 
        {(char *)"iso-8859-8", (char *)"iso8859-8"}, 
        {(char *)"iso-8859-9", (char *)"iso8859-9"}, 
        {(char *)"korean", (char *)"ksc5601"}, 
        {(char *)"ksc_5601", (char *)"ksc5601"}, 
        {(char *)"mac", (char *)"macRoman"}, 
        {(char *)"mac-centeuro", (char *)"macCentEuro"}, 
        {(char *)"mac-centraleupore", (char *)"macCentEuro"}, 
        {(char *)"mac-croatian", (char *)"macCroatian"}, 
        {(char *)"mac-cyrillic", (char *)"macCyrillic"}, 
        {(char *)"mac-greek", (char *)"macGreek"}, 
        {(char *)"mac-iceland", (char *)"macIceland"}, 
        {(char *)"mac-japan", (char *)"macJapan"}, 
        {(char *)"mac-roman", (char *)"macRoman"}, 
        {(char *)"mac-romania", (char *)"macRomania"}, 
        {(char *)"mac-thai", (char *)"macThai"}, 
        {(char *)"mac-turkish", (char *)"macTurkish"}, 
        {(char *)"mac-ukraine", (char *)"macUkraine"}, 
        {(char *)"maccenteuro", (char *)"macCentEuro"}, 
        {(char *)"maccentraleupore", (char *)"macCentEuro"}, 
        {(char *)"maccroatian", (char *)"macCroatian"}, 
        {(char *)"maccyrillic", (char *)"macCyrillic"}, 
        {(char *)"macgreek", (char *)"macGreek"}, 
        {(char *)"maciceland", (char *)"macIceland"}, 
        {(char *)"macintosh", (char *)"macRoman"}, 
        {(char *)"macjapan", (char *)"macJapan"}, 
        {(char *)"macroman", (char *)"macRoman"}, 
        {(char *)"macromania", (char *)"macRomania"}, 
        {(char *)"macthai", (char *)"macThai"}, 
        {(char *)"macturkish", (char *)"macTurkish"}, 
        {(char *)"macukraine", (char *)"macUkraine"}, 
        {(char *)"shift_jis", (char *)"shiftjis"}, 
        {(char *)"us-ascii", (char *)"ascii"}, 
        {(char *)"windows-1250", (char *)"cp1250"}, 
        {(char *)"windows-1251", (char *)"cp1251"}, 
        {(char *)"windows-1252", (char *)"cp1252"}, 
        {(char *)"windows-1253", (char *)"cp1253"}, 
        {(char *)"windows-1254", (char *)"cp1254"}, 
        {(char *)"windows-1255", (char *)"cp1255"}, 
        {(char *)"windows-1256", (char *)"cp1256"}, 
        {(char *)"windows-1257", (char *)"cp1257"}, 
        {(char *)"windows-1258", (char *)"cp1258"}, 
        {(char *)"x-mac", (char *)"macRoman"}, 
        {(char *)"x-mac-centeuro", (char *)"macCentEuro"}, 
        {(char *)"x-mac-centraleupore", (char *)"macCentEuro"}, 
        {(char *)"x-mac-croatian", (char *)"macCroatian"}, 
        {(char *)"x-mac-cyrillic", (char *)"macCyrillic"}, 
        {(char *)"x-mac-greek", (char *)"macGreek"}, 
        {(char *)"x-mac-iceland", (char *)"macIceland"}, 
        {(char *)"x-mac-japan", (char *)"macJapan"}, 
        {(char *)"x-mac-roman", (char *)"macRoman"}, 
        {(char *)"x-mac-romania", (char *)"macRomania"}, 
        {(char *)"x-mac-thai", (char *)"macThai"}, 
        {(char *)"x-mac-turkish", (char *)"macTurkish"}, 
        {(char *)"x-mac-ukraine", (char *)"macUkraine"}, 
        {(char *)"x-macintosh", (char *)"macRoman"}, 
        {(char *)((void *)0), (char *)((void *)0)}};
Tcl_Encoding Ns_GetFileEncoding(char *file___1 ) 
{ Tcl_HashEntry *hPtr ;
  char *ext ;
  char *name ;
  Tcl_Encoding tmp ;

  {
  ext = strrchr((char const   *)file___1, '.');
  if ((unsigned int )ext != (unsigned int )((void *)0)) {
    hPtr = ((*(extensions.findProc)))(& extensions, ext);
    if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
      name = (char *)hPtr->clientData;
      tmp = Ns_GetEncoding(name);
      return (tmp);
    }
  }
  return ((struct Tcl_Encoding_ *)((void *)0));
}
}
Tcl_Encoding Ns_GetTypeEncoding(char *type ) 
{ int used_default ;
  Tcl_Encoding tmp ;

  {
  tmp = NsGetTypeEncodingWithDef(type, & used_default);
  return (tmp);
}
}
Tcl_Encoding Ns_GetCharsetEncoding(char *charset ) 
{ Tcl_Encoding tmp ;

  {
  tmp = GetCharsetEncoding(charset, -1);
  return (tmp);
}
}
Tcl_Encoding Ns_GetEncoding(char *name ) 
{ Tcl_Encoding encoding ;
  Tcl_HashEntry *hPtr ;
  int new ;

  {
  Ns_MutexLock(& lock___4);
  hPtr = ((*(encodings.createProc)))(& encodings, name, & new);
  if (! new) {
    while (1) {
      encoding = (struct Tcl_Encoding_ *)hPtr->clientData;
      if (! ((unsigned int )encoding == (unsigned int )((struct Tcl_Encoding_ *)-1))) {
        break;
      }
      Ns_CondWait(& cond___1, & lock___4);
    }
  } else {
    hPtr->clientData = (void *)((struct Tcl_Encoding_ *)-1);
    Ns_MutexUnlock(& lock___4);
    encoding = Tcl_GetEncoding((Tcl_Interp *)((void *)0), name);
    if ((unsigned int )encoding == (unsigned int )((void *)0)) {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"encoding: could not load: %s",
             name);
    } else {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"encoding: loaded: %s",
             name);
    }
    Ns_MutexLock(& lock___4);
    hPtr->clientData = (void *)encoding;
    Ns_CondBroadcast(& cond___1);
  }
  Ns_MutexUnlock(& lock___4);
  return (encoding);
}
}
void NsInitEncodings(void) 
{ int i ;

  {
  Ns_MutexSetName(& lock___4, (char *)"ns:encodings");
  Tcl_InitHashTable(& encodings, 0);
  Tcl_InitHashTable(& charsets, 0);
  Tcl_InitHashTable(& extensions, 0);
  i = 0;
  while ((unsigned int )builtinChar[i].charset != (unsigned int )((void *)0)) {
    AddCharset(builtinChar[i].charset, builtinChar[i].name);
    i ++;
  }
  i = 0;
  while ((unsigned int )builtinExt[i].extension != (unsigned int )((void *)0)) {
    AddExtension(builtinExt[i].extension, builtinExt[i].name);
    i ++;
  }
  RebuildCharsetList();
  return;
}
}
void NsUpdateEncodings(void) 
{ Ns_Set *set ;
  int i ;

  {
  set = Ns_ConfigGetSection((char *)"ns/charsets");
  i = 0;
  while (1) {
    if ((unsigned int )set != (unsigned int )((void *)0)) {
      if (! (i < set->size)) {
        break;
      }
    } else {
      break;
    }
    AddCharset((set->fields + i)->name, (set->fields + i)->value);
    i ++;
  }
  set = Ns_ConfigGetSection((char *)"ns/encodings");
  i = 0;
  while (1) {
    if ((unsigned int )set != (unsigned int )((void *)0)) {
      if (! (i < set->size)) {
        break;
      }
    } else {
      break;
    }
    AddExtension((set->fields + i)->name, (set->fields + i)->value);
    i ++;
  }
  RebuildCharsetList();
  nsconf.encoding.outputCharset = Ns_ConfigGetValue((char *)"ns/parameters", (char *)"OutputCharset");
  if ((unsigned int )nsconf.encoding.outputCharset != (unsigned int )((void *)0)) {
    nsconf.encoding.outputEncoding = Ns_GetCharsetEncoding(nsconf.encoding.outputCharset);
    if ((unsigned int )nsconf.encoding.outputEncoding == (unsigned int )((void *)0)) {
      Ns_Fatal((char *)"could not find encoding for default output charset \"%s\"",
               nsconf.encoding.outputCharset);
    }
    nsconf.encoding.hackContentTypeP = 1;
    Ns_ConfigGetBool((char *)"ns/parameters", (char *)"HackContentType", & nsconf.encoding.hackContentTypeP);
  } else {
    nsconf.encoding.outputEncoding = (struct Tcl_Encoding_ *)((void *)0);
    nsconf.encoding.hackContentTypeP = 0;
  }
  return;
}
}
Tcl_Encoding NsGetTypeEncodingWithDef(char *type , int *used_default ) 
{ char *s ;
  char *e___1 ;
  Tcl_Encoding ret_enc ;
  size_t tmp___29 ;
  size_t tmp___60 ;
  unsigned short const   **tmp___61 ;
  char *tmp___62 ;
  int tmp___63 ;

  {
  ret_enc = (struct Tcl_Encoding_ *)((void *)0);
  s = Ns_StrCaseFind(type, (char *)"charset");
  if ((unsigned int )s != (unsigned int )((void *)0)) {
    s += 7;
    tmp___29 = strspn((char const   *)s, " ");
    s += tmp___29;
    (*used_default) = 0;
    tmp___62 = s;
    s ++;
    if ((int )(*tmp___62) == 61) {
      tmp___60 = strspn((char const   *)s, " ");
      s += tmp___60;
      e___1 = s;
      while (1) {
        if ((*e___1)) {
          tmp___61 = __ctype_b_loc();
          if ((int const   )(*((*tmp___61) + (int )((unsigned char )(*e___1)))) &
              8192) {
            break;
          }
        } else {
          break;
        }
        e___1 ++;
      }
      ret_enc = GetCharsetEncoding(s, e___1 - s);
    }
  } else {
    tmp___63 = strncasecmp((char const   *)type, "text/", 5U);
    if (tmp___63 == 0) {
      (*used_default) = 1;
      ret_enc = GetDefaultEncoding();
    } else {
      (*used_default) = 0;
    }
  }
  return (ret_enc);
}
}
void NsComputeEncodingFromType(char *type , Tcl_Encoding *enc___0 , int *new_type ,
                               Tcl_DString *type_ds ) 
{ int used_default ;
  Tcl_Encoding tmp ;
  int tmp___0 ;

  {
  (*enc___0) = NsGetTypeEncodingWithDef(type, & used_default);
  if (used_default) {
    tmp___0 = GetDefaultHackContentTypeP();
    if (tmp___0) {
      Tcl_DStringInit(type_ds);
      Tcl_DStringAppend(type_ds, type, -1);
      Tcl_DStringAppend(type_ds, (char *)"; charset=", -1);
      tmp = GetDefaultCharset();
      Tcl_DStringAppend(type_ds, (char *)tmp, -1);
      (*new_type) = 1;
    } else {
      (*new_type) = 0;
    }
  } else {
    (*new_type) = 0;
  }
  return;
}
}
int NsTclCharsetsCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) 
{ 

  {
  Tcl_SetResult(interp, charsetList, (Tcl_FreeProc *)1);
  return (0);
}
}
int NsTclEncodingForCharsetCmd(ClientData dummy , Tcl_Interp *interp , int argc ,
                               char **argv ) 
{ Tcl_Encoding encoding ;
  char *tmp ;

  {
  if (argc != 2) {
    Tcl_AppendResult(interp, "usage: ", (*(argv + 0)), " charset", (void *)0);
    return (1);
  }
  encoding = Ns_GetCharsetEncoding((*(argv + 1)));
  if ((unsigned int )encoding == (unsigned int )((void *)0)) {
    return (0);
  }
  tmp = Tcl_GetEncodingName(encoding);
  Tcl_SetResult(interp, tmp, (Tcl_FreeProc *)1);
  return (0);
}
}
static void AddExtension(char *ext , char *name ) 
{ Tcl_HashEntry *hPtr ;
  int new ;

  {
  hPtr = ((*(extensions.createProc)))(& extensions, ext, & new);
  hPtr->clientData = (void *)name;
  return;
}
}
static void AddCharset(char *charset , char *name ) 
{ Tcl_HashEntry *hPtr ;
  Tcl_DString ds ;
  int new ;
  char *tmp ;

  {
  Tcl_DStringInit(& ds);
  tmp = Tcl_DStringAppend(& ds, charset, -1);
  charset = Ns_StrToLower(tmp);
  hPtr = ((*(charsets.createProc)))(& charsets, charset, & new);
  hPtr->clientData = (void *)name;
  Tcl_DStringFree(& ds);
  return;
}
}
static Tcl_Encoding GetCharsetEncoding(char *charset , int len ) 
{ Tcl_HashEntry *hPtr ;
  Tcl_Encoding encoding ;
  Tcl_DString ds ;
  char *tmp ;

  {
  Tcl_DStringInit(& ds);
  Tcl_DStringAppend(& ds, charset, len);
  tmp = Ns_StrToLower(ds.string);
  charset = Ns_StrTrim(tmp);
  hPtr = ((*(charsets.findProc)))(& charsets, charset);
  if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    charset = (char *)hPtr->clientData;
  }
  encoding = Ns_GetEncoding(charset);
  Tcl_DStringFree(& ds);
  return (encoding);
}
}
static char *RebuildCharsetList(void) 
{ Tcl_HashEntry *entry ;
  Tcl_HashSearch search ;
  Tcl_DString ds ;
  char *tmp ;

  {
  Tcl_DStringInit(& ds);
  Ns_MutexLock(& lock___4);
  entry = Tcl_FirstHashEntry(& charsets, & search);
  while ((unsigned int )entry != (unsigned int )((void *)0)) {
    if (charsets.keyType == 1) {
      tmp = entry->key.oneWordValue;
    } else {
      if (charsets.keyType == -1) {
        tmp = entry->key.oneWordValue;
      } else {
        tmp = entry->key.string;
      }
    }
    Tcl_DStringAppendElement(& ds, tmp);
    entry = Tcl_NextHashEntry(& search);
  }
  Ns_MutexUnlock(& lock___4);
  if ((unsigned int )charsetList != (unsigned int )((void *)0)) {
    ns_free((void *)charsetList);
  }
  charsetList = ns_strdup((char const   *)ds.string);
  Tcl_DStringFree(& ds);
  return (charsetList);
}
}
static Tcl_Encoding GetDefaultEncoding(void) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)Ns_GetConn();
  if ((unsigned int )connPtr != (unsigned int )((void *)0)) {
    if ((unsigned int )connPtr->servPtr != (unsigned int )((void *)0)) {
      return ((connPtr->servPtr)->encoding.outputEncoding);
    } else {
      return (nsconf.encoding.outputEncoding);
    }
  } else {
    return (nsconf.encoding.outputEncoding);
  }
}
}
static Tcl_Encoding GetDefaultCharset(void) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)Ns_GetConn();
  if ((unsigned int )connPtr != (unsigned int )((void *)0)) {
    if ((unsigned int )connPtr->servPtr != (unsigned int )((void *)0)) {
      return ((struct Tcl_Encoding_ *)(connPtr->servPtr)->encoding.outputCharset);
    } else {
      return ((struct Tcl_Encoding_ *)nsconf.encoding.outputCharset);
    }
  } else {
    return ((struct Tcl_Encoding_ *)nsconf.encoding.outputCharset);
  }
}
}
static int GetDefaultHackContentTypeP(void) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)Ns_GetConn();
  if ((unsigned int )connPtr != (unsigned int )((void *)0)) {
    if ((unsigned int )connPtr->servPtr != (unsigned int )((void *)0)) {
      return ((connPtr->servPtr)->encoding.hackContentTypeP);
    } else {
      return (nsconf.encoding.hackContentTypeP);
    }
  } else {
    return (nsconf.encoding.hackContentTypeP);
  }
}
}
extern ssize_t readv(int __fd , struct iovec  const  *__vector , int __count ) ;
extern ssize_t writev(int __fd , struct iovec  const  *__vector , int __count ) ;
extern int chdir(char const   *__path ) ;
extern int dup(int __fd ) ;
extern int dup2(int __fd , int __fd2 ) ;
extern int execve(char const   *__path , char * const  *__argv , char * const  *__envp ) ;
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
int ns_fork(void) ;
int Ns_ExecProcess(char *exec , char *dir , int fdin , int fdout , char *args , Ns_Set *env ) ;
int Ns_ExecProc(char *exec , char **argv ) ;
int Ns_ExecArgblk(char *exec , char *dir , int fdin , int fdout , char *args , Ns_Set *env ) ;
int Ns_ExecArgv(char *exec , char *dir , int fdin , int fdout , char **argv , Ns_Set *env ) ;
int Ns_WaitProcess(int pid ) ;
int Ns_WaitForProcess(int pid , int *exitcodePtr ) ;
char **Ns_CopyEnviron(Tcl_DString *dsPtr ) ;
int Ns_NoCloseOnExec(int fd ) ;
int ns_pipe(int *fds ) ;
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
void NsRestoreSignals(void) ;
static int ExecProc(char *exec , char *dir , int fdin , int fdout , char **argv ,
                    char **envp ) ;
int Ns_ExecProcess(char *exec , char *dir , int fdin , int fdout , char *args , Ns_Set *env ) 
{ int tmp ;

  {
  tmp = Ns_ExecArgblk(exec, dir, fdin, fdout, args, env);
  return (tmp);
}
}
int Ns_ExecProc(char *exec , char **argv ) 
{ int tmp ;

  {
  tmp = Ns_ExecArgv(exec, (char *)((void *)0), 0, 1, argv, (Ns_Set *)((void *)0));
  return (tmp);
}
}
int Ns_WaitProcess(int pid ) 
{ int tmp ;

  {
  tmp = Ns_WaitForProcess(pid, (int *)((void *)0));
  return (tmp);
}
}
int Ns_WaitForProcess(int pid , int *exitcodePtr ) 
{ char *coredump ;
  int exitcode ;
  int status ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  union __anonunion___u_107___0 __u ;
  union __anonunion___u_108 __u___0 ;
  union __anonunion___u_109 __u___1 ;
  union __anonunion___u_110 __u___2 ;
  int __status ;
  union __anonunion___u_111 __u___3 ;
  int tmp___2 ;

  {
  tmp___1 = waitpid(pid, & status, 0);
  if (tmp___1 != pid) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"waitpid(%d) failed: %s",
           pid, tmp___0);
    return (-1);
  }
  __u___3.__in = status;
  __status = __u___3.__i;
  if (! ((__status & 255) == 127)) {
    if (! ((__status & 127) == 0)) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  if (tmp___2) {
    coredump = (char *)"";
    __u.__in = status;
    if (__u.__i & 128) {
      coredump = (char *)" - core dumped";
    }
    __u___0.__in = status;
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"process %d killed with signal %d%s",
           pid, __u___0.__i & 127, coredump);
  } else {
    __u___2.__in = status;
    if ((__u___2.__i & 127) == 0) {
      __u___1.__in = status;
      exitcode = (__u___1.__i & 65280) >> 8;
      if (exitcode != 0) {
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"process %d exited with non-zero exit code: %d",
               pid, exitcode);
      }
      if ((unsigned int )exitcodePtr != (unsigned int )((void *)0)) {
        (*exitcodePtr) = exitcode;
      }
    } else {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"waitpid(%d): invalid status: %d",
             pid, status);
    }
  }
  return (0);
}
}
int Ns_ExecArgblk(char *exec , char *dir , int fdin , int fdout , char *args , Ns_Set *env ) 
{ int pid ;
  char **argv ;
  Tcl_DString vds ;
  size_t tmp ;

  {
  Tcl_DStringInit(& vds);
  if ((unsigned int )args == (unsigned int )((void *)0)) {
    argv = (char **)((void *)0);
  } else {
    while ((int )(*args) != 0) {
      Tcl_DStringAppend(& vds, (char *)(& args), (int )sizeof(args));
      tmp = strlen((char const   *)args);
      args += tmp + 1U;
    }
    args = (char *)((void *)0);
    Tcl_DStringAppend(& vds, (char *)(& args), (int )sizeof(args));
    argv = (char **)vds.string;
  }
  pid = Ns_ExecArgv(exec, dir, fdin, fdout, argv, env);
  Tcl_DStringFree(& vds);
  return (pid);
}
}
int Ns_ExecArgv(char *exec , char *dir , int fdin , int fdout , char **argv , Ns_Set *env ) 
{ Tcl_DString eds ;
  char *argvSh[4] ;
  char **envp ;
  int i ;
  int pid ;

  {
  if ((unsigned int )exec == (unsigned int )((void *)0)) {
    return (-1);
  }
  if ((unsigned int )argv == (unsigned int )((void *)0)) {
    argv = argvSh;
    (*(argv + 0)) = (char *)"/bin/sh";
    (*(argv + 1)) = (char *)"-c";
    (*(argv + 2)) = exec;
    (*(argv + 3)) = (char *)((void *)0);
    exec = (*(argv + 0));
  }
  Tcl_DStringInit(& eds);
  if ((unsigned int )env == (unsigned int )((void *)0)) {
    envp = Ns_CopyEnviron(& eds);
  } else {
    i = 0;
    while (i < env->size) {
      Ns_DStringVarAppend(& eds, (env->fields + i)->name, "=", (env->fields + i)->value,
                          (void *)0);
      Tcl_DStringAppend(& eds, (char *)"", 1);
      i ++;
    }
    Tcl_DStringAppend(& eds, (char *)"", 1);
    envp = Ns_DStringAppendArgv(& eds);
  }
  if (fdin < 0) {
    fdin = 0;
  }
  if (fdout < 0) {
    fdout = 1;
  }
  pid = ExecProc(exec, dir, fdin, fdout, argv, envp);
  Tcl_DStringFree(& eds);
  return (pid);
}
}
static int ExecProc(char *exec , char *dir , int fdin , int fdout , char **argv ,
                    char **envp ) 
{ struct iovec iov[2] ;
  int pid ;
  int nread ;
  int errpipe[2] ;
  int errnum ;
  int result ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  tmp___1 = ns_pipe(errpipe);
  if (tmp___1 < 0) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"exec: ns_pipe() failed: %s",
           tmp___0);
    return (-1);
  }
  pid = ns_fork();
  if (pid < 0) {
    close(errpipe[0]);
    close(errpipe[1]);
    tmp___2 = __errno_location();
    tmp___3 = strerror((*tmp___2));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"exec: ns_fork() failed: %s",
           tmp___3);
    return (-1);
  }
  iov[0].iov_base = (void *)((char *)(& result));
  iov[1].iov_base = (void *)((char *)(& errnum));
  iov[1].iov_len = sizeof(int );
  iov[0].iov_len = iov[1].iov_len;
  if (pid == 0) {
    close(errpipe[0]);
    if ((unsigned int )dir != (unsigned int )((void *)0)) {
      tmp___6 = chdir((char const   *)dir);
      if (tmp___6 != 0) {
        result = -2;
      } else {
        goto _L___3;
      }
    } else {
      _L___3: 
      if (fdin == 1) {
        fdin = dup(1);
        if (fdin < 0) {
          result = -1;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: 
        if (fdout == 0) {
          fdout = dup(0);
          if (fdout < 0) {
            result = -1;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          if (fdin != 0) {
            tmp___4 = dup2(fdin, 0);
            if (tmp___4 < 0) {
              result = -1;
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
            if (fdout != 1) {
              tmp___5 = dup2(fdout, 1);
              if (tmp___5 < 0) {
                result = -1;
              } else {
                goto _L;
              }
            } else {
              _L: 
              if (fdin > 2) {
                close(fdin);
              }
              if (fdout > 2) {
                close(fdout);
              }
              NsRestoreSignals();
              Ns_NoCloseOnExec(0);
              Ns_NoCloseOnExec(1);
              Ns_NoCloseOnExec(2);
              execve((char const   *)exec, (char * const  *)argv, (char * const  *)envp);
              result = -3;
            }
          }
        }
      }
    }
    tmp___7 = __errno_location();
    errnum = (*tmp___7);
    writev(errpipe[1], (struct iovec  const  *)(iov), 2);
    _exit(1);
  } else {
    close(errpipe[1]);
    while (1) {
      nread = readv(errpipe[0], (struct iovec  const  *)(iov), 2);
      if (nread < 0) {
        tmp___8 = __errno_location();
        if (! ((*tmp___8) == 4)) {
          break;
        }
      } else {
        break;
      }
    }
    close(errpipe[0]);
    if (nread == 0) {
      errnum = 0;
      result = pid;
    } else {
      if ((unsigned int )nread != sizeof(int ) * 2U) {
        tmp___9 = __errno_location();
        tmp___10 = strerror((*tmp___9));
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"exec: %s: error reading status from child: %s",
               exec, tmp___10);
      } else {
        switch (result) {
        case -2: 
        tmp___11 = strerror(errnum);
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"exec %s: chdir(%s) failed: %s",
               exec, dir, tmp___11);
        break;
        case -1: 
        tmp___12 = strerror(errnum);
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"exec %s: dup(%d) failed: %s",
               exec, tmp___12);
        break;
        case -3: 
        tmp___13 = strerror(errnum);
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"exec %s: execve() failed: %s",
               exec, tmp___13);
        break;
        default: 
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"exec %s: unknown result from child: %d",
               exec, result);
        break;
        }
      }
      waitpid(pid, (int *)((void *)0), 0);
    }
  }
  return (result);
}
}
char *Ns_PageRoot(char *server ) ;
void Ns_SetUrlToFileProc(char *server , Ns_UrlToFileProc *procPtr ) ;
int Ns_UrlIsFile(char *server , char *url ) ;
int Ns_UrlIsDir(char *server , char *url ) ;
int Ns_ConnRedirect(Ns_Conn *conn , char *url ) ;
int Ns_ConnFlushHeaders(Ns_Conn *conn , int status ) ;
void Ns_ConnSetLastModifiedHeader(Ns_Conn *conn , time_t *mtime ) ;
int Ns_ConnReturnData(Ns_Conn *conn , int status , char *data , int len , char *type ) ;
int Ns_ConnReturnRedirect(Ns_Conn *conn , char *url ) ;
int Ns_ConnReturnNotModified(Ns_Conn *conn ) ;
int Ns_ConnReturnOpenFd(Ns_Conn *conn , int status , char *type , int fd , int len ) ;
int Ns_ConnReturnFile(Ns_Conn *conn , int status , char *type , char *file___1 ) ;
int Ns_TclRequest(Ns_Conn *conn , char *name ) ;
int NsFastGet(void *arg , Ns_Conn *conn ) ;
Ns_Cache *NsFastpathCache(char *server , int size ) ;
int NsUrlToFile(Tcl_DString *dsPtr , NsServer *servPtr , char *url ) ;
extern void *mmap(void *__addr , size_t __len , int __prot , int __flags , int __fd ,
                  __off_t __offset ) ;
extern int munmap(void *__addr , size_t __len ) ;
static void FreeEntry(void *arg ) ;
static void DecrEntry(File *filePtr ) ;
static int UrlIs(char *server , char *url , int dir ) ;
static int FastStat(char *file___1 , struct stat *stPtr ) ;
static int FastReturn(NsServer *servPtr , Ns_Conn *conn , int status , char *type ,
                      char *file___1 , struct stat *stPtr ) ;
Ns_Cache *NsFastpathCache(char *server , int size ) 
{ Tcl_DString ds ;
  Ns_Cache *fpCache ;
  int keys ;

  {
  keys = (int )(sizeof(FileKey ) / sizeof(int ));
  Tcl_DStringInit(& ds);
  Ns_DStringVarAppend(& ds, "nsfp:", server, (void *)0);
  fpCache = Ns_CacheCreateSz(ds.string, keys, (unsigned int )size, & FreeEntry);
  Tcl_DStringFree(& ds);
  return (fpCache);
}
}
int Ns_ConnReturnFile(Ns_Conn *conn , int status , char *type , char *file___1 ) 
{ struct stat st ;
  char *server ;
  NsServer *servPtr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = FastStat(file___1, & st);
  if (! tmp___0) {
    tmp = Ns_ConnReturnNotFound(conn);
    return (tmp);
  }
  server = Ns_ConnServer(conn);
  servPtr = NsGetServer(server);
  tmp___1 = FastReturn(servPtr, conn, status, type, file___1, & st);
  return (tmp___1);
}
}
char *Ns_PageRoot(char *server ) 
{ NsServer *servPtr ;
  NsServer *tmp ;

  {
  tmp = NsGetServer(server);
  servPtr = tmp;
  return (servPtr->fastpath.pageroot);
}
}
void Ns_SetUrlToFileProc(char *server , Ns_UrlToFileProc *procPtr ) 
{ NsServer *servPtr ;
  NsServer *tmp ;

  {
  tmp = NsGetServer(server);
  servPtr = tmp;
  servPtr->fastpath.url2file = procPtr;
  return;
}
}
int Ns_UrlToFile(Tcl_DString *dsPtr , char *server , char *url ) 
{ NsServer *servPtr ;
  NsServer *tmp ;
  int tmp___0 ;

  {
  tmp = NsGetServer(server);
  servPtr = tmp;
  tmp___0 = NsUrlToFile(dsPtr, servPtr, url);
  return (tmp___0);
}
}
int Ns_UrlIsFile(char *server , char *url ) 
{ int tmp ;

  {
  tmp = UrlIs(server, url, 0);
  return (tmp);
}
}
int Ns_UrlIsDir(char *server , char *url ) 
{ int tmp ;

  {
  tmp = UrlIs(server, url, 1);
  return (tmp);
}
}
static int UrlIs(char *server , char *url , int dir ) 
{ Tcl_DString ds ;
  int is ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  is = 0;
  Tcl_DStringInit(& ds);
  tmp = Ns_UrlToFile(& ds, server, url);
  if (tmp == 0) {
    tmp___0 = stat__extinline((char const   *)ds.string, & st);
    if (tmp___0 == 0) {
      if (dir) {
        if ((st.st_mode & 61440U) == 16384U) {
          is = 1;
        } else {
          goto _L;
        }
      } else {
        _L: 
        if (dir == 0) {
          if ((st.st_mode & 61440U) == 32768U) {
            is = 1;
          }
        }
      }
    }
  }
  Tcl_DStringFree(& ds);
  return (is);
}
}
static int FastGetRestart(Ns_Conn *conn , char *page ) 
{ int status ;
  Tcl_DString ds ;

  {
  Tcl_DStringInit(& ds);
  Ns_MakePath(& ds, (conn->request)->url, page, (void *)0);
  status = Ns_ConnRedirect(conn, ds.string);
  Tcl_DStringFree(& ds);
  return (status);
}
}
int NsFastGet(void *arg , Ns_Conn *conn ) 
{ Tcl_DString ds ;
  NsServer *servPtr ;
  char *url ;
  int result ;
  int i ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  servPtr = (NsServer *)arg;
  url = (conn->request)->url;
  Tcl_DStringInit(& ds);
  tmp = NsUrlToFile(& ds, servPtr, url);
  if (tmp != 0) {
    goto notfound;
  } else {
    tmp___0 = FastStat(ds.string, & st);
    if (! tmp___0) {
      goto notfound;
    }
  }
  if ((st.st_mode & 61440U) == 32768U) {
    result = FastReturn(servPtr, conn, 200, (char *)((void *)0), ds.string, & st);
  } else {
    if ((st.st_mode & 61440U) == 16384U) {
      i = 0;
      while (i < servPtr->fastpath.dirc) {
        Tcl_DStringSetLength(& ds, 0);
        tmp___1 = NsUrlToFile(& ds, servPtr, url);
        if (tmp___1 != 0) {
          goto notfound;
        }
        Ns_DStringVarAppend(& ds, "/", (*(servPtr->fastpath.dirv + i)), (void *)0);
        tmp___3 = stat__extinline((char const   *)ds.string, & st);
        if (tmp___3 == 0) {
          if ((st.st_mode & 61440U) == 32768U) {
            tmp___2 = strlen((char const   *)url);
            if ((int )(*(url + (tmp___2 - 1U))) != 47) {
              Tcl_DStringSetLength(& ds, 0);
              Ns_DStringVarAppend(& ds, url, "/", (void *)0);
              result = Ns_ConnReturnRedirect(conn, ds.string);
            } else {
              result = FastGetRestart(conn, (*(servPtr->fastpath.dirv + i)));
            }
            goto done;
          }
        }
        i ++;
      }
      if ((unsigned int )servPtr->fastpath.diradp != (unsigned int )((void *)0)) {
        result = Ns_AdpRequest(conn, servPtr->fastpath.diradp);
      } else {
        if ((unsigned int )servPtr->fastpath.dirproc != (unsigned int )((void *)0)) {
          result = Ns_TclRequest(conn, servPtr->fastpath.dirproc);
        } else {
          goto notfound;
        }
      }
    } else {
      notfound: 
      result = Ns_ConnReturnNotFound(conn);
    }
  }
  done: 
  Tcl_DStringFree(& ds);
  return (result);
}
}
static void FreeEntry(void *arg ) 
{ File *filePtr ;

  {
  filePtr = (File *)arg;
  DecrEntry(filePtr);
  return;
}
}
static void DecrEntry(File *filePtr ) 
{ 

  {
  filePtr->refcnt --;
  if (filePtr->refcnt == 0) {
    ns_free((void *)filePtr);
  }
  return;
}
}
static int FastStat(char *file___1 , struct stat *stPtr ) 
{ int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  tmp___3 = stat__extinline((char const   *)file___1, stPtr);
  if (tmp___3 != 0) {
    tmp___1 = __errno_location();
    if ((*tmp___1) != 2) {
      tmp___2 = __errno_location();
      if ((*tmp___2) != 13) {
        tmp = __errno_location();
        tmp___0 = strerror((*tmp));
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"fastpath: stat(%s) failed: %s",
               file___1, tmp___0);
      }
    }
    return (0);
  }
  return (1);
}
}
static int FastReturn(NsServer *servPtr , Ns_Conn *conn , int status , char *type ,
                      char *file___1 , struct stat *stPtr ) 
{ int result ;
  int fd ;
  int new ;
  int nread ;
  File *filePtr ;
  char *key___1 ;
  Ns_Entry *entPtr ;
  char *map ;
  FileKey ukey ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  result = -1;
  if ((unsigned int )type == (unsigned int )((void *)0)) {
    type = Ns_GetMimeType(file___1);
  }
  Ns_ConnSetLastModifiedHeader(conn, & stPtr->st_mtim.tv_sec);
  tmp___0 = Ns_ConnModifiedSince(conn, stPtr->st_mtim.tv_sec);
  if (tmp___0 == 0) {
    tmp = Ns_ConnReturnNotModified(conn);
    return (tmp);
  }
  if (conn->flags & 4) {
    Ns_ConnSetRequiredHeaders(conn, type, (int )stPtr->st_size);
    tmp___1 = Ns_ConnFlushHeaders(conn, status);
    return (tmp___1);
  }
  if ((unsigned int )servPtr->fastpath.cache == (unsigned int )((void *)0)) {
    goto _L;
  } else {
    if (stPtr->st_size > (long )servPtr->fastpath.cachemaxentry) {
      _L: 
      fd = open((char const   *)file___1, 0);
      if (fd < 0) {
        tmp___2 = __errno_location();
        tmp___3 = strerror((*tmp___2));
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"fastpath: open(%s) failed: %s",
               file___1, tmp___3);
        goto notfound;
      }
      if (servPtr->fastpath.mmap) {
        map = (char *)mmap((void *)0, (unsigned int )stPtr->st_size, 1, 1, fd, 0L);
        if ((unsigned int )map != (unsigned int )((void *)-1)) {
          close(fd);
          fd = -1;
          result = Ns_ConnReturnData(conn, status, map, (int )stPtr->st_size, type);
          munmap((void *)map, (unsigned int )stPtr->st_size);
        }
      }
      if (fd != -1) {
        result = Ns_ConnReturnOpenFd(conn, status, type, fd, (int )stPtr->st_size);
        close(fd);
      }
    } else {
      ukey.dev = stPtr->st_dev;
      ukey.ino = stPtr->st_ino;
      key___1 = (char *)(& ukey);
      filePtr = (File *)((void *)0);
      Ns_CacheLock(servPtr->fastpath.cache);
      entPtr = Ns_CacheCreateEntry(servPtr->fastpath.cache, key___1, & new);
      if (! new) {
        while (1) {
          if ((unsigned int )entPtr != (unsigned int )((void *)0)) {
            filePtr = (File *)Ns_CacheGetValue(entPtr);
            if (! ((unsigned int )filePtr == (unsigned int )((void *)0))) {
              break;
            }
          } else {
            break;
          }
          Ns_CacheWait(servPtr->fastpath.cache);
          entPtr = Ns_CacheFindEntry(servPtr->fastpath.cache, key___1);
        }
        if ((unsigned int )filePtr != (unsigned int )((void *)0)) {
          if (filePtr->mtime != stPtr->st_mtim.tv_sec) {
            Ns_CacheUnsetValue(entPtr);
            new = 1;
          } else {
            if ((long )filePtr->size != stPtr->st_size) {
              Ns_CacheUnsetValue(entPtr);
              new = 1;
            }
          }
        }
      }
      if (new) {
        Ns_CacheUnlock(servPtr->fastpath.cache);
        fd = open((char const   *)file___1, 0);
        if (fd < 0) {
          filePtr = (File *)((void *)0);
          tmp___4 = __errno_location();
          tmp___5 = strerror((*tmp___4));
          Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"fastpath: failed to open \'%s\': \'%s\'",
                 file___1, tmp___5);
        } else {
          filePtr = (File *)ns_malloc((unsigned int )((unsigned long )sizeof(File ) +
                                                      (unsigned long )stPtr->st_size));
          filePtr->refcnt = 1;
          filePtr->size = (int )stPtr->st_size;
          filePtr->mtime = stPtr->st_mtim.tv_sec;
          nread = read(fd, (void *)(filePtr->bytes), (unsigned int )filePtr->size);
          close(fd);
          if (nread != filePtr->size) {
            tmp___6 = __errno_location();
            tmp___7 = strerror((*tmp___6));
            Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"fastpath: failed to read \'%s\': \'%s\'",
                   file___1, tmp___7);
            ns_free((void *)filePtr);
            filePtr = (File *)((void *)0);
          }
        }
        Ns_CacheLock(servPtr->fastpath.cache);
        entPtr = Ns_CacheCreateEntry(servPtr->fastpath.cache, key___1, & new);
        if ((unsigned int )filePtr != (unsigned int )((void *)0)) {
          Ns_CacheSetValueSz(entPtr, (void *)filePtr, (unsigned int )filePtr->size);
        } else {
          Ns_CacheFlushEntry(entPtr);
        }
        Ns_CacheBroadcast(servPtr->fastpath.cache);
      }
      if ((unsigned int )filePtr != (unsigned int )((void *)0)) {
        filePtr->refcnt ++;
        Ns_CacheUnlock(servPtr->fastpath.cache);
        result = Ns_ConnReturnData(conn, status, filePtr->bytes, filePtr->size, type);
        Ns_CacheLock(servPtr->fastpath.cache);
        DecrEntry(filePtr);
      }
      Ns_CacheUnlock(servPtr->fastpath.cache);
      if ((unsigned int )filePtr == (unsigned int )((void *)0)) {
        goto notfound;
      }
    }
  }
  return (result);
  notfound: 
  tmp___8 = Ns_ConnReturnNotFound(conn);
  return (tmp___8);
}
}
int NsUrlToFile(Tcl_DString *dsPtr , NsServer *servPtr , char *url ) 
{ int status ;

  {
  if ((unsigned int )servPtr->fastpath.url2file != (unsigned int )((void *)0)) {
    status = ((*(servPtr->fastpath.url2file)))(dsPtr, servPtr->server, url);
  } else {
    Ns_MakePath(dsPtr, servPtr->fastpath.pageroot, url, (void *)0);
    status = 0;
  }
  if (status == 0) {
    while (1) {
      if (dsPtr->length > 0) {
        if (! ((int )(*(dsPtr->string + (dsPtr->length - 1))) == 47)) {
          break;
        }
      } else {
        break;
      }
      Tcl_DStringSetLength(dsPtr, dsPtr->length - 1);
    }
  }
  return (status);
}
}
extern int ftruncate(int __fd , __off_t __length ) ;
extern int fcntl(int __fd , int __cmd  , ...) ;
int Ns_CloseOnExec(int fd ) ;
int Ns_DupHigh(int *fdPtr ) ;
int Ns_GetTemp(void) ;
void Ns_ReleaseTemp(int fd ) ;
static Tmp *firstTmpPtr  ;
static Ns_Mutex lock___5  ;
int Ns_CloseOnExec(int fd ) 
{ int i ;
  int status ;

  {
  status = -1;
  i = fcntl(fd, 1);
  if (i != -1) {
    i |= 1;
    i = fcntl(fd, 2, i);
    status = 0;
  }
  return (status);
}
}
int ns_closeonexec(int fd ) 
{ int tmp ;

  {
  tmp = Ns_CloseOnExec(fd);
  return (tmp);
}
}
int Ns_NoCloseOnExec(int fd ) 
{ int i ;
  int status ;

  {
  status = -1;
  i = fcntl(fd, 1);
  if (i != -1) {
    i &= -2;
    i = fcntl(fd, 2, i);
    status = 0;
  }
  return (status);
}
}
int ns_duphigh(int *fdPtr ) 
{ int tmp ;

  {
  tmp = Ns_DupHigh(fdPtr);
  return (tmp);
}
}
int Ns_DupHigh(int *fdPtr ) 
{ 

  {
  return ((*fdPtr));
}
}
int Ns_GetTemp(void) 
{ Tmp *tmpPtr ;
  Ns_Time now ;
  Tcl_DString ds ;
  char *path ;
  char buf[64] ;
  int fd ;
  int flags ;
  int trys ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  Ns_MutexLock(& lock___5);
  tmpPtr = firstTmpPtr;
  if ((unsigned int )tmpPtr != (unsigned int )((void *)0)) {
    firstTmpPtr = tmpPtr->nextPtr;
  }
  Ns_MutexUnlock(& lock___5);
  if ((unsigned int )tmpPtr != (unsigned int )((void *)0)) {
    fd = tmpPtr->fd;
    ns_free((void *)tmpPtr);
    return (fd);
  }
  Tcl_DStringInit(& ds);
  flags = 706;
  trys = 0;
  while (1) {
    Ns_GetTime(& now);
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"nstmp.%d.%d",
            (int )now.sec, (int )now.usec);
    path = Ns_MakePath(& ds, "/tmp", buf, (void *)0);
    fd = open((char const   *)path, flags, 384);
    if (fd < 0) {
      tmp = trys;
      trys ++;
      if (tmp < 10) {
        tmp___0 = __errno_location();
        if (! ((*tmp___0) == 17)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
  }
  if (fd < 0) {
    tmp___1 = __errno_location();
    tmp___2 = strerror((*tmp___1));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"tmp: could not open temp file %s: %s",
           path, tmp___2);
  } else {
    Ns_DupHigh(& fd);
    Ns_CloseOnExec(fd);
    tmp___5 = unlink((char const   *)path);
    if (tmp___5 != 0) {
      tmp___3 = __errno_location();
      tmp___4 = strerror((*tmp___3));
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"tmp: unlink(%s) failed: %s",
             path, tmp___4);
    }
  }
  Tcl_DStringFree(& ds);
  return (fd);
}
}
void Ns_ReleaseTemp(int fd ) 
{ Tmp *tmpPtr ;
  __off_t tmp ;
  int tmp___0 ;

  {
  tmp = lseek(fd, 0L, 0);
  if (tmp != 0L) {
    close(fd);
  } else {
    tmp___0 = ftruncate(fd, 0L);
    if (tmp___0 != 0) {
      close(fd);
    } else {
      tmpPtr = (Tmp *)ns_malloc(sizeof(Tmp ));
      tmpPtr->fd = fd;
      Ns_MutexLock(& lock___5);
      tmpPtr->nextPtr = firstTmpPtr;
      firstTmpPtr = tmpPtr;
      Ns_MutexUnlock(& lock___5);
    }
  }
  return;
}
}
void *Ns_RegisterFilter(char *server , char *method , char *url , Ns_FilterProc *proc ,
                        int when , void *arg ) ;
void *Ns_RegisterServerTrace(char *server , Ns_TraceProc *proc , void *arg ) ;
void *Ns_RegisterConnCleanup(char *server , Ns_TraceProc *proc , void *arg ) ;
void *Ns_RegisterCleanup(Ns_TraceProc *proc , void *arg ) ;
int NsRunFilters(Ns_Conn *conn , int why ) ;
void NsRunCleanups(Ns_Conn *conn ) ;
void NsRunTraces(Ns_Conn *conn ) ;
static Trace *NewTrace(Ns_TraceProc *proc , void *arg ) ;
static void RunTraces(Ns_Conn *conn , Trace *tracePtr ) ;
static void *RegisterCleanup(NsServer *servPtr , Ns_TraceProc *proc , void *arg ) ;
void *Ns_RegisterFilter(char *server , char *method , char *url , Ns_FilterProc *proc ,
                        int when , void *arg ) 
{ NsServer *servPtr ;
  NsServer *tmp ;
  Filter *fPtr ;
  Filter **fPtrPtr ;

  {
  tmp = NsGetServer(server);
  servPtr = tmp;
  if ((unsigned int )servPtr == (unsigned int )((void *)0)) {
    return ((void *)0);
  }
  fPtr = (Filter *)ns_malloc(sizeof(Filter ));
  fPtr->proc = proc;
  fPtr->method = ns_strdup((char const   *)method);
  fPtr->url = ns_strdup((char const   *)url);
  fPtr->when = when;
  fPtr->arg = arg;
  fPtr->nextPtr = (struct Filter *)((void *)0);
  fPtrPtr = & servPtr->filter.firstFilterPtr;
  while ((unsigned int )(*fPtrPtr) != (unsigned int )((void *)0)) {
    fPtrPtr = & ((*fPtrPtr))->nextPtr;
  }
  (*fPtrPtr) = fPtr;
  return ((void *)fPtr);
}
}
int NsRunFilters(Ns_Conn *conn , int why ) 
{ Conn *connPtr ;
  Filter *fPtr ;
  char *method ;
  char *url ;
  int status ;
  int tmp ;
  int tmp___0 ;

  {
  connPtr = (Conn *)conn;
  status = 0;
  if ((unsigned int )conn->request != (unsigned int )((void *)0)) {
    method = (conn->request)->method;
    url = (conn->request)->url;
    fPtr = (connPtr->servPtr)->filter.firstFilterPtr;
    while (1) {
      if ((unsigned int )fPtr != (unsigned int )((void *)0)) {
        if (! (status == 0)) {
          break;
        }
      } else {
        break;
      }
      if (fPtr->when & why) {
        tmp = Tcl_StringMatch(method, fPtr->method);
        if (tmp) {
          tmp___0 = Tcl_StringMatch(url, fPtr->url);
          if (tmp___0) {
            status = ((*(fPtr->proc)))(fPtr->arg, conn, why);
          }
        }
      }
      fPtr = fPtr->nextPtr;
    }
    if (status == -4) {
      status = 0;
    } else {
      if (why == 4) {
        if (status == -5) {
          status = 0;
        }
      }
    }
  }
  return (status);
}
}
void *Ns_RegisterServerTrace(char *server , Ns_TraceProc *proc , void *arg ) 
{ NsServer *servPtr ;
  NsServer *tmp ;
  Trace *tracePtr ;
  Trace **tPtrPtr ;

  {
  tmp = NsGetServer(server);
  servPtr = tmp;
  if ((unsigned int )servPtr == (unsigned int )((void *)0)) {
    return ((void *)0);
  }
  tracePtr = NewTrace(proc, arg);
  tPtrPtr = & servPtr->filter.firstTracePtr;
  while ((unsigned int )(*tPtrPtr) != (unsigned int )((void *)0)) {
    tPtrPtr = & ((*tPtrPtr))->nextPtr;
  }
  (*tPtrPtr) = tracePtr;
  tracePtr->nextPtr = (struct Trace *)((void *)0);
  return ((void *)tracePtr);
}
}
void *Ns_RegisterConnCleanup(char *server , Ns_TraceProc *proc , void *arg ) 
{ NsServer *servPtr ;
  NsServer *tmp ;
  void *tmp___0 ;

  {
  tmp = NsGetServer(server);
  servPtr = tmp;
  tmp___0 = RegisterCleanup(servPtr, proc, arg);
  return (tmp___0);
}
}
void *Ns_RegisterCleanup(Ns_TraceProc *proc , void *arg ) 
{ NsServer *servPtr ;
  NsServer *tmp ;
  void *tmp___0 ;

  {
  tmp = NsGetInitServer();
  servPtr = tmp;
  tmp___0 = RegisterCleanup(servPtr, proc, arg);
  return (tmp___0);
}
}
static void *RegisterCleanup(NsServer *servPtr , Ns_TraceProc *proc , void *arg ) 
{ Trace *tracePtr ;

  {
  if ((unsigned int )servPtr == (unsigned int )((void *)0)) {
    return ((void *)0);
  }
  tracePtr = NewTrace(proc, arg);
  tracePtr->nextPtr = servPtr->filter.firstCleanupPtr;
  servPtr->filter.firstCleanupPtr = tracePtr;
  return ((void *)tracePtr);
}
}
void NsRunTraces(Ns_Conn *conn ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  RunTraces(conn, (connPtr->servPtr)->filter.firstTracePtr);
  return;
}
}
void NsRunCleanups(Ns_Conn *conn ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  RunTraces(conn, (connPtr->servPtr)->filter.firstCleanupPtr);
  return;
}
}
static void RunTraces(Ns_Conn *conn , Trace *tracePtr ) 
{ 

  {
  while ((unsigned int )tracePtr != (unsigned int )((void *)0)) {
    ((*(tracePtr->proc)))(tracePtr->arg, conn);
    tracePtr = tracePtr->nextPtr;
  }
  return;
}
}
static Trace *NewTrace(Ns_TraceProc *proc , void *arg ) 
{ Trace *tracePtr ;

  {
  tracePtr = (Trace *)ns_malloc(sizeof(Trace ));
  tracePtr->proc = proc;
  tracePtr->arg = arg;
  return (tracePtr);
}
}
extern int strncmp(char const   *__s1 , char const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
int Ns_QueryToSet(char *query , Ns_Set *set ) ;
void Ns_SetFree(Ns_Set *set ) ;
char *Ns_SetGet(Ns_Set *set , char *key___1 ) ;
char *Ns_DecodeUrlWithEncoding(Tcl_DString *dsPtr , char *string , Tcl_Encoding encoding ) ;
static void ParseQuery(char *form , Ns_Set *set , Tcl_Encoding encoding ) ;
static void ParseMultiInput(Conn *connPtr , char *start , char *end ) ;
static char *Ext2Utf(Tcl_DString *dsPtr , char *start , int len , Tcl_Encoding encoding ) ;
static int GetBoundary(Tcl_DString *dsPtr , Ns_Conn *conn ) ;
static char *NextBoundry(Tcl_DString *dsPtr , char *s , char *e___1 ) ;
static int GetValue(char *hdr , char *att , char **vsPtr , char **vePtr ) ;
Ns_Set *Ns_ConnGetQuery(Ns_Conn *conn ) 
{ Conn *connPtr ;
  Tcl_DString bound ;
  char *s ;
  char *e___1 ;
  char *form ;
  char *formend ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  connPtr = (Conn *)conn;
  if ((unsigned int )connPtr->query == (unsigned int )((void *)0)) {
    connPtr->query = Ns_SetCreate((char *)((void *)0));
    if ((int )(*((connPtr->request)->method)) == (int )(*"POST")) {
      if (0) {
        __s1_len = strlen((char const   *)(connPtr->request)->method);
        __s2_len = strlen("POST");
        if (! ((unsigned int )((void const   *)((connPtr->request)->method + 1)) -
               (unsigned int )((void const   *)(connPtr->request)->method) == 1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("POST" + 1)) - (unsigned int )((void const   *)"POST") ==
                   1U)) {
              tmp___7 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___7 = 1;
              } else {
                tmp___7 = 0;
              }
            }
          } else {
            tmp___7 = 0;
          }
        }
        if (tmp___7) {
          if (__s1_len < __s2_len) {
            tmp___5 = __s1_len;
          } else {
            tmp___5 = __s2_len;
          }
          tmp___4 = memcmp((void const   *)((char const   *)(connPtr->request)->method),
                           (void const   *)"POST", tmp___5 + 1U);
        } else {
          tmp___6 = strcmp((char const   *)(connPtr->request)->method, "POST");
          tmp___4 = tmp___6;
        }
      } else {
        tmp___6 = strcmp((char const   *)(connPtr->request)->method, "POST");
        tmp___4 = tmp___6;
      }
      if (tmp___4 == 0) {
        form = (connPtr->reqPtr)->content;
        if ((unsigned int )form != (unsigned int )((void *)0)) {
          Tcl_DStringInit(& bound);
          tmp = GetBoundary(& bound, conn);
          if (tmp) {
            formend = form + (connPtr->reqPtr)->length;
            s = NextBoundry(& bound, form, formend);
            while ((unsigned int )s != (unsigned int )((void *)0)) {
              s += bound.length;
              if ((int )(*s) == 13) {
                s ++;
              }
              if ((int )(*s) == 10) {
                s ++;
              }
              e___1 = NextBoundry(& bound, s, formend);
              if ((unsigned int )e___1 != (unsigned int )((void *)0)) {
                ParseMultiInput(connPtr, s, e___1);
              }
              s = e___1;
            }
          } else {
            ParseQuery(form, connPtr->query, connPtr->urlEncoding);
          }
          Tcl_DStringFree(& bound);
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      form = (connPtr->request)->query;
      if ((unsigned int )form != (unsigned int )((void *)0)) {
        ParseQuery(form, connPtr->query, connPtr->urlEncoding);
      }
    }
  }
  return (connPtr->query);
}
}
void Ns_ConnClearQuery(Ns_Conn *conn ) 
{ Conn *connPtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  FormFile *filePtr ;

  {
  connPtr = (Conn *)conn;
  if ((unsigned int )conn == (unsigned int )((void *)0)) {
    return;
  } else {
    if ((unsigned int )connPtr->query == (unsigned int )((void *)0)) {
      return;
    }
  }
  Ns_SetFree(connPtr->query);
  connPtr->query = (Ns_Set *)((void *)0);
  hPtr = Tcl_FirstHashEntry(& connPtr->files, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    filePtr = (FormFile *)hPtr->clientData;
    Ns_SetFree(filePtr->hdrs);
    ns_free((void *)filePtr);
    hPtr = Tcl_NextHashEntry(& search);
  }
  Tcl_DeleteHashTable(& connPtr->files);
  Tcl_InitHashTable(& connPtr->files, 0);
  return;
}
}
int Ns_QueryToSet(char *query , Ns_Set *set ) 
{ 

  {
  ParseQuery(query, set, (struct Tcl_Encoding_ *)((void *)0));
  return (0);
}
}
int NsTclParseQueryObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Ns_Set *set ;
  char *tmp ;
  Tcl_Obj *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"querystring");
    return (1);
  }
  set = Ns_SetCreate((char *)((void *)0));
  tmp___1 = Tcl_GetString((*(objv + 1)));
  tmp___2 = Ns_QueryToSet(tmp___1, set);
  if (tmp___2 != 0) {
    tmp = Tcl_GetString((*(objv + 1)));
    tmp___0 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___0, "could not parse: \"", tmp, "\"", (void *)0);
    Ns_SetFree(set);
    return (1);
  }
  tmp___3 = Ns_TclEnterSet(interp, set, 1);
  return (tmp___3);
}
}
static void ParseQuery(char *form , Ns_Set *set , Tcl_Encoding encoding ) 
{ char *p ;
  char *k ;
  char *v ;
  Tcl_DString kds ;
  Tcl_DString vds ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  Tcl_DStringInit(& kds);
  Tcl_DStringInit(& vds);
  p = form;
  while ((unsigned int )p != (unsigned int )((void *)0)) {
    k = p;
    tmp___0 = strchr((char const   *)p, '&');
    p = tmp___0;
    if ((unsigned int )p != (unsigned int )((void *)0)) {
      (*p) = (char )'\000';
    }
    tmp___2 = strchr((char const   *)k, '=');
    v = tmp___2;
    if ((unsigned int )v != (unsigned int )((void *)0)) {
      (*v) = (char )'\000';
    }
    Tcl_DStringSetLength(& kds, 0);
    k = Ns_DecodeUrlWithEncoding(& kds, k, encoding);
    if ((unsigned int )v != (unsigned int )((void *)0)) {
      Tcl_DStringSetLength(& vds, 0);
      Ns_DecodeUrlWithEncoding(& vds, v + 1, encoding);
      (*v) = (char )'=';
      v = vds.string;
    }
    Ns_SetPut(set, k, v);
    if ((unsigned int )p != (unsigned int )((void *)0)) {
      tmp___3 = p;
      p ++;
      (*tmp___3) = (char )'&';
    }
  }
  Tcl_DStringFree(& kds);
  Tcl_DStringFree(& vds);
  return;
}
}
static void ParseMultiInput(Conn *connPtr , char *start , char *end ) 
{ Tcl_Encoding encoding ;
  Tcl_DString kds ;
  Tcl_DString vds ;
  Tcl_HashEntry *hPtr ;
  FormFile *filePtr ;
  char *s ;
  char *e___1 ;
  char *ks ;
  char *ke ;
  char *fs ;
  char *fe ;
  char save ;
  char saveend ;
  char *key___1 ;
  char *value ;
  char *disp ;
  Ns_Set *set ;
  int new ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  encoding = connPtr->urlEncoding;
  Tcl_DStringInit(& kds);
  Tcl_DStringInit(& vds);
  set = Ns_SetCreate((char *)((void *)0));
  if ((unsigned int )end > (unsigned int )start) {
    if ((int )(*(end + -1)) == 10) {
      end --;
    }
  }
  if ((unsigned int )end > (unsigned int )start) {
    if ((int )(*(end + -1)) == 13) {
      end --;
    }
  }
  saveend = (*end);
  (*end) = (char )'\000';
  fs = (char *)((void *)0);
  ks = fs;
  while (1) {
    tmp___0 = strchr((char const   *)start, '\n');
    e___1 = tmp___0;
    if (! ((unsigned int )e___1 != (unsigned int )((void *)0))) {
      break;
    }
    s = start;
    start = e___1 + 1;
    if ((unsigned int )e___1 > (unsigned int )s) {
      if ((int )(*(e___1 + -1)) == 13) {
        e___1 --;
      }
    }
    if ((unsigned int )s == (unsigned int )e___1) {
      break;
    }
    save = (*e___1);
    (*e___1) = (char )'\000';
    Ns_ParseHeader(set, s, (enum __anonenum_Ns_HeaderCaseDisposition_68 )1);
    (*e___1) = save;
  }
  disp = Ns_SetGet(set, (char *)"content-disposition");
  if ((unsigned int )disp != (unsigned int )((void *)0)) {
    tmp___2 = GetValue(disp, (char *)"name=", & ks, & ke);
    if (tmp___2) {
      key___1 = Ext2Utf(& kds, ks, ke - ks, encoding);
      tmp___1 = GetValue(disp, (char *)"filename=", & fs, & fe);
      if (tmp___1) {
        value = Ext2Utf(& vds, fs, fe - fs, encoding);
        hPtr = ((*(connPtr->files.createProc)))(& connPtr->files, key___1, & new);
        if (new) {
          filePtr = (FormFile *)ns_malloc(sizeof(FormFile ));
          filePtr->hdrs = set;
          filePtr->off = (long )(start - (connPtr->reqPtr)->content);
          filePtr->len = (long )(end - start);
          hPtr->clientData = (void *)filePtr;
          set = (Ns_Set *)((void *)0);
        }
      } else {
        value = Ext2Utf(& vds, start, end - start, encoding);
      }
      Ns_SetPut(connPtr->query, key___1, value);
    }
  }
  (*end) = saveend;
  Tcl_DStringFree(& kds);
  Tcl_DStringFree(& vds);
  if ((unsigned int )set != (unsigned int )((void *)0)) {
    Ns_SetFree(set);
  }
  return;
}
}
static int GetBoundary(Tcl_DString *dsPtr , Ns_Conn *conn ) 
{ char *type ;
  char *bs ;
  char *be ;
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
  type = Ns_SetIGet(conn->headers, (char *)"content-type");
  if ((unsigned int )type != (unsigned int )((void *)0)) {
    tmp___0 = Ns_StrCaseFind(type, (char *)"multipart/form-data");
    if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
      bs = Ns_StrCaseFind(type, (char *)"boundary=");
      if ((unsigned int )bs != (unsigned int )((void *)0)) {
        bs += 9;
        be = bs;
        while (1) {
          if ((*be)) {
            tmp = __ctype_b_loc();
            if ((int const   )(*((*tmp) + (int )((unsigned char )(*be)))) & 8192) {
              break;
            }
          } else {
            break;
          }
          be ++;
        }
        Tcl_DStringAppend(dsPtr, (char *)"--", 2);
        Tcl_DStringAppend(dsPtr, bs, be - bs);
        return (1);
      }
    }
  }
  return (0);
}
}
static char *NextBoundry(Tcl_DString *dsPtr , char *s , char *e___1 ) 
{ char c ;
  char sc ;
  char *find ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  find = dsPtr->string;
  tmp = find;
  find ++;
  c = (*tmp);
  len = (unsigned int )(dsPtr->length - 1);
  e___1 -= len;
  while (1) {
    while (1) {
      tmp___0 = s;
      s ++;
      sc = (*tmp___0);
      if ((unsigned int )s > (unsigned int )e___1) {
        return ((char *)((void *)0));
      }
      if (! ((int )sc != (int )c)) {
        break;
      }
    }
    if (0) {
      if (0) {
        __s1_len___0 = strlen((char const   *)s);
        __s2_len___0 = strlen((char const   *)find);
        if (! ((unsigned int )((void const   *)(s + 1)) - (unsigned int )((void const   *)s) ==
               1U)) {
          goto _L___2;
        } else {
          if (__s1_len___0 >= 4U) {
            _L___2: 
            if (! ((unsigned int )((void const   *)(find + 1)) - (unsigned int )((void const   *)find) ==
                   1U)) {
              tmp___20 = 1;
            } else {
              if (__s2_len___0 >= 4U) {
                tmp___20 = 1;
              } else {
                tmp___20 = 0;
              }
            }
          } else {
            tmp___20 = 0;
          }
        }
        if (tmp___20) {
          if (__s1_len___0 < __s2_len___0) {
            tmp___18 = __s1_len___0;
          } else {
            tmp___18 = __s2_len___0;
          }
          tmp___17 = memcmp((void const   *)((char const   *)s), (void const   *)((char const   *)find),
                            tmp___18 + 1U);
        } else {
          tmp___19 = strcmp((char const   *)s, (char const   *)find);
          tmp___17 = tmp___19;
        }
      } else {
        tmp___19 = strcmp((char const   *)s, (char const   *)find);
        tmp___17 = tmp___19;
      }
      tmp___12 = tmp___17;
    } else {
      tmp___12 = strncmp((char const   *)s, (char const   *)find, len);
    }
    if (! (tmp___12 != 0)) {
      break;
    }
  }
  s --;
  return (s);
}
}
static int GetValue(char *hdr , char *att , char **vsPtr , char **vePtr ) 
{ char *s ;
  char *e___1 ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  s = Ns_StrCaseFind(hdr, att);
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    return (0);
  }
  tmp = strlen((char const   *)att);
  s += tmp;
  e___1 = s;
  if ((int )(*s) != 34) {
    if ((int )(*s) != 39) {
      while (1) {
        if ((*e___1)) {
          tmp___0 = __ctype_b_loc();
          if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*e___1)))) & 8192) {
            break;
          }
        } else {
          break;
        }
        e___1 ++;
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    e___1 ++;
    while (1) {
      if ((*e___1)) {
        if (! ((int )(*e___1) != (int )(*s))) {
          break;
        }
      } else {
        break;
      }
      e___1 ++;
    }
    s ++;
  }
  (*vsPtr) = s;
  (*vePtr) = e___1;
  return (1);
}
}
static char *Ext2Utf(Tcl_DString *dsPtr , char *start , int len , Tcl_Encoding encoding ) 
{ 

  {
  if ((unsigned int )encoding == (unsigned int )((void *)0)) {
    Tcl_DStringSetLength(dsPtr, 0);
    Tcl_DStringAppend(dsPtr, start, len);
  } else {
    Tcl_DStringFree(dsPtr);
    Tcl_ExternalToUtfDString(encoding, start, len, dsPtr);
  }
  return (dsPtr->string);
}
}
extern size_t strftime(char * __restrict  __s , size_t __maxsize , char const   * __restrict  __format ,
                       struct tm  const  * __restrict  __tp ) ;
extern time_t timegm(struct tm *__tp ) ;
extern __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline static int toupper__extinline(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp___1 = __ctype_toupper_loc();
      tmp___0 = (*((*tmp___1) + __c));
    } else {
      tmp___0 = __c;
    }
  } else {
    tmp___0 = __c;
  }
  return (tmp___0);
}
}
struct tm *ns_gmtime(time_t const   *clock___0 ) ;
char *Ns_HttpTime(Tcl_DString *pds , time_t *when ) ;
static int MakeNum(char *s ) ;
static int MakeMonth(char *s ) ;
static char *month_names[12]  = 
  {      (char *)"Jan",      (char *)"Feb",      (char *)"Mar",      (char *)"Apr", 
        (char *)"May",      (char *)"Jun",      (char *)"Jul",      (char *)"Aug", 
        (char *)"Sep",      (char *)"Oct",      (char *)"Nov",      (char *)"Dec"};
char *Ns_HttpTime(Tcl_DString *pds , time_t *when ) 
{ time_t now ;
  char buf[40] ;
  struct tm *tmPtr ;

  {
  if ((unsigned int )when == (unsigned int )((void *)0)) {
    now = time((time_t *)0);
    when = & now;
  }
  tmPtr = ns_gmtime((time_t const   *)when);
  if ((unsigned int )tmPtr == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  }
  strftime((char * __restrict  )(buf), 40U, (char const   * __restrict  )"%a, %d %b %Y %H:%M:%S GMT",
           (struct tm  const  * __restrict  )tmPtr);
  Tcl_DStringAppend(pds, buf, -1);
  return (pds->string);
}
}
time_t Ns_ParseHttpTime(char *str ) 
{ char *s ;
  struct tm tm ;
  time_t t ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___6 ;
  size_t tmp___7 ;

  {
  if ((unsigned int )str == (unsigned int )((void *)0)) {
    return (0L);
  }
  tmp___0 = strchr((char const   *)str, ',');
  s = tmp___0;
  if ((unsigned int )s != (unsigned int )((void *)0)) {
    s ++;
    while (1) {
      if ((*s)) {
        if (! ((int )(*s) == 32)) {
          break;
        }
      } else {
        break;
      }
      s ++;
    }
    tmp___6 = strchr((char const   *)s, '-');
    if ((unsigned int )tmp___6 != (unsigned int )((void *)0)) {
      tmp___1 = strlen((char const   *)s);
      if (tmp___1 < 18U) {
        return (0L);
      }
      tm.tm_mday = MakeNum(s);
      tm.tm_mon = MakeMonth(s + 3);
      tm.tm_year = MakeNum(s + 7);
      tm.tm_hour = MakeNum(s + 10);
      tm.tm_min = MakeNum(s + 13);
      tm.tm_sec = MakeNum(s + 16);
    } else {
      tmp___2 = strlen((char const   *)s);
      if ((int )tmp___2 < 20) {
        return (0L);
      }
      tm.tm_mday = MakeNum(s);
      tm.tm_mon = MakeMonth(s + 3);
      tmp___3 = MakeNum(s + 7);
      tmp___4 = MakeNum(s + 9);
      tm.tm_year = (100 * tmp___3 - 1900) + tmp___4;
      tm.tm_hour = MakeNum(s + 12);
      tm.tm_min = MakeNum(s + 15);
      tm.tm_sec = MakeNum(s + 18);
    }
  } else {
    s = str;
    while (1) {
      if ((*s)) {
        if (! ((int )(*s) == 32)) {
          break;
        }
      } else {
        break;
      }
      s ++;
    }
    tmp___7 = strlen((char const   *)s);
    if ((int )tmp___7 < 24) {
      return (0L);
    }
    tm.tm_mday = MakeNum(s + 8);
    tm.tm_mon = MakeMonth(s + 4);
    tm.tm_year = MakeNum(s + 22);
    tm.tm_hour = MakeNum(s + 11);
    tm.tm_min = MakeNum(s + 14);
    tm.tm_sec = MakeNum(s + 17);
  }
  if (tm.tm_sec < 0) {
    return (0L);
  } else {
    if (tm.tm_sec > 59) {
      return (0L);
    } else {
      if (tm.tm_min < 0) {
        return (0L);
      } else {
        if (tm.tm_min > 59) {
          return (0L);
        } else {
          if (tm.tm_hour < 0) {
            return (0L);
          } else {
            if (tm.tm_hour > 23) {
              return (0L);
            } else {
              if (tm.tm_mday < 1) {
                return (0L);
              } else {
                if (tm.tm_mday > 31) {
                  return (0L);
                } else {
                  if (tm.tm_mon < 0) {
                    return (0L);
                  } else {
                    if (tm.tm_mon > 11) {
                      return (0L);
                    } else {
                      if (tm.tm_year < 70) {
                        return (0L);
                      } else {
                        if (tm.tm_year > 120) {
                          return (0L);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  tm.tm_isdst = 0;
  t = timegm(& tm);
  return (t);
}
}
int NsTclParseHttpTimeObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ time_t time___0 ;
  char *tmp ;
  char *tmp___0 ;
  Tcl_Obj *tmp___1 ;

  {
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"httptime");
    return (1);
  }
  tmp = Tcl_GetString((*(objv + 1)));
  time___0 = Ns_ParseHttpTime(tmp);
  if (time___0 == 0L) {
    tmp___0 = Tcl_GetString((*(objv + 1)));
    Tcl_AppendResult(interp, "invalid time: ", tmp___0, (void *)0);
    return (1);
  }
  tmp___1 = Tcl_GetObjResult(interp);
  Tcl_SetLongObj(tmp___1, time___0);
  return (0);
}
}
int NsTclHttpTimeObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Tcl_DString ds ;
  int itime ;
  time_t time___0 ;
  int tmp ;
  char *tmp___0 ;

  {
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"time");
    return (1);
  }
  tmp = Tcl_GetIntFromObj(interp, (*(objv + 1)), & itime);
  if (tmp != 0) {
    return (1);
  }
  time___0 = (long )itime;
  Tcl_DStringInit(& ds);
  Ns_HttpTime(& ds, & time___0);
  tmp___0 = Ns_DStringExport(& ds);
  Tcl_SetResult(interp, tmp___0, (Tcl_FreeProc *)(& ns_free));
  Tcl_DStringFree(& ds);
  return (0);
}
}
static int MakeNum(char *s ) 
{ 

  {
  if ((int )(*s) >= 48) {
    if ((int )(*s) <= 57) {
      return (10 * ((int )(*s) - 48) + ((int )(*(s + 1)) - 48));
    } else {
      return ((int )(*(s + 1)) - 48);
    }
  } else {
    return ((int )(*(s + 1)) - 48);
  }
}
}
static int MakeMonth(char *s ) 
{ int i ;
  int __res ;
  __int32_t const   **tmp___1 ;
  int __res___0 ;
  __int32_t const   **tmp___4 ;
  int __res___1 ;
  __int32_t const   **tmp___7 ;
  int tmp___19 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;

  {
  if (sizeof((*s)) > 1U) {
    __res = toupper__extinline((int )(*s));
  } else {
    tmp___1 = __ctype_toupper_loc();
    __res = (*((*tmp___1) + (int )(*s)));
  }
  (*s) = (char )__res;
  if (sizeof((*(s + 1))) > 1U) {
    __res___0 = tolower__extinline((int )(*(s + 1)));
  } else {
    tmp___4 = __ctype_tolower_loc();
    __res___0 = (*((*tmp___4) + (int )(*(s + 1))));
  }
  (*(s + 1)) = (char )__res___0;
  if (sizeof((*(s + 2))) > 1U) {
    __res___1 = tolower__extinline((int )(*(s + 2)));
  } else {
    tmp___7 = __ctype_tolower_loc();
    __res___1 = (*((*tmp___7) + (int )(*(s + 2))));
  }
  (*(s + 2)) = (char )__res___1;
  i = 0;
  while (i < 12) {
    if (0) {
      if (0) {
        __s1_len___0 = strlen((char const   *)month_names[i]);
        __s2_len___0 = strlen((char const   *)s);
        if (! ((unsigned int )((void const   *)(month_names[i] + 1)) - (unsigned int )((void const   *)month_names[i]) ==
               1U)) {
          goto _L___2;
        } else {
          if (__s1_len___0 >= 4U) {
            _L___2: 
            if (! ((unsigned int )((void const   *)(s + 1)) - (unsigned int )((void const   *)s) ==
                   1U)) {
              tmp___27 = 1;
            } else {
              if (__s2_len___0 >= 4U) {
                tmp___27 = 1;
              } else {
                tmp___27 = 0;
              }
            }
          } else {
            tmp___27 = 0;
          }
        }
        if (tmp___27) {
          if (__s1_len___0 < __s2_len___0) {
            tmp___25 = __s1_len___0;
          } else {
            tmp___25 = __s2_len___0;
          }
          tmp___24 = memcmp((void const   *)((char const   *)month_names[i]), (void const   *)((char const   *)s),
                            tmp___25 + 1U);
        } else {
          tmp___26 = strcmp((char const   *)month_names[i], (char const   *)s);
          tmp___24 = tmp___26;
        }
      } else {
        tmp___26 = strcmp((char const   *)month_names[i], (char const   *)s);
        tmp___24 = tmp___26;
      }
      tmp___19 = tmp___24;
    } else {
      tmp___19 = strncmp((char const   *)month_names[i], (char const   *)s, 3U);
    }
    if (! tmp___19) {
      return (i);
    }
    i ++;
  }
  return (0);
}
}
extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                     size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
void Ns_IndexInit(Ns_Index *indexPtr , int inc , int (*CmpEls)(void const   * , void const   * ) ,
                  int (*CmpKeyWithEl)(void const   * , void const   * ) ) ;
void Ns_IndexTrunc(Ns_Index *indexPtr ) ;
void Ns_IndexDestroy(Ns_Index *indexPtr ) ;
Ns_Index *Ns_IndexDup(Ns_Index *indexPtr ) ;
void *Ns_IndexFind(Ns_Index *indexPtr , void *key___1 ) ;
void *Ns_IndexFindInf(Ns_Index *indexPtr , void *key___1 ) ;
void **Ns_IndexFindMultiple(Ns_Index *indexPtr , void *key___1 ) ;
void Ns_IndexAdd(Ns_Index *indexPtr , void *el ) ;
void Ns_IndexDel(Ns_Index *indexPtr , void *el ) ;
void *Ns_IndexEl(Ns_Index *indexPtr , int i ) ;
void Ns_IndexStringInit(Ns_Index *indexPtr , int inc ) ;
Ns_Index *Ns_IndexStringDup(Ns_Index *indexPtr ) ;
void Ns_IndexStringAppend(Ns_Index *addtoPtr , Ns_Index *addfromPtr ) ;
void Ns_IndexStringDestroy(Ns_Index *indexPtr ) ;
void Ns_IndexStringTrunc(Ns_Index *indexPtr ) ;
void Ns_IndexIntInit(Ns_Index *indexPtr , int inc ) ;
static int BinSearch(void **elPtrPtr , void **listPtrPtr , int n , Ns_IndexCmpProc *cmpProc ) ;
static int BinSearchKey(void *key___1 , void **listPtrPtr , int n , Ns_IndexCmpProc *cmpProc ) ;
void Ns_IndexInit(Ns_Index *indexPtr , int inc , int (*CmpEls)(void const   * , void const   * ) ,
                  int (*CmpKeyWithEl)(void const   * , void const   * ) ) 
{ 

  {
  indexPtr->n = 0;
  indexPtr->max = inc;
  indexPtr->inc = inc;
  indexPtr->CmpEls = CmpEls;
  indexPtr->CmpKeyWithEl = CmpKeyWithEl;
  indexPtr->el = (void **)ns_malloc((unsigned int )inc * sizeof(void *));
  return;
}
}
void Ns_IndexTrunc(Ns_Index *indexPtr ) 
{ 

  {
  indexPtr->n = 0;
  ns_free((void *)indexPtr->el);
  indexPtr->max = indexPtr->inc;
  indexPtr->el = (void **)ns_malloc((unsigned int )indexPtr->inc * sizeof(void *));
  return;
}
}
void Ns_IndexDestroy(Ns_Index *indexPtr ) 
{ 

  {
  indexPtr->CmpEls = (Ns_IndexCmpProc *)((void *)0);
  indexPtr->CmpKeyWithEl = (Ns_IndexCmpProc *)((void *)0);
  ns_free((void *)indexPtr->el);
  return;
}
}
Ns_Index *Ns_IndexDup(Ns_Index *indexPtr ) 
{ Ns_Index *newPtr ;

  {
  newPtr = (Ns_Index *)ns_malloc(sizeof(Ns_Index ));
  memcpy((void * __restrict  )newPtr, (void const   * __restrict  )indexPtr, sizeof(Ns_Index ));
  newPtr->el = (void **)ns_malloc((unsigned int )indexPtr->max * sizeof(void *));
  memcpy((void * __restrict  )newPtr->el, (void const   * __restrict  )indexPtr->el,
         (unsigned int )indexPtr->n * sizeof(void *));
  return (newPtr);
}
}
void *Ns_IndexFind(Ns_Index *indexPtr , void *key___1 ) 
{ void **pPtrPtr ;
  void *tmp___0 ;

  {
  pPtrPtr = (void **)bsearch((void const   *)key___1, (void const   *)indexPtr->el,
                             (unsigned int )indexPtr->n, sizeof(void *), indexPtr->CmpKeyWithEl);
  if (pPtrPtr) {
    tmp___0 = (*pPtrPtr);
  } else {
    tmp___0 = (void *)0;
  }
  return (tmp___0);
}
}
void *Ns_IndexFindInf(Ns_Index *indexPtr , void *key___1 ) 
{ int i ;
  int tmp ;

  {
  if (indexPtr->n > 0) {
    i = BinSearchKey(key___1, indexPtr->el, indexPtr->n, indexPtr->CmpKeyWithEl);
    if (i >= indexPtr->n) {
      return ((void *)0);
    }
    if (i > 0) {
      tmp = ((*(indexPtr->CmpKeyWithEl)))((void const   *)key___1, (void const   *)(indexPtr->el +
                                                                                    i));
      if (tmp != 0) {
        return ((*(indexPtr->el + (i - 1))));
      } else {
        return ((*(indexPtr->el + i)));
      }
    } else {
      return ((*(indexPtr->el + i)));
    }
  } else {
    return ((void *)0);
  }
}
}
void **Ns_IndexFindMultiple(Ns_Index *indexPtr , void *key___1 ) 
{ void **firstPtrPtr ;
  void **retPtrPtr ;
  int i ;
  int n ;
  int tmp___0 ;
  int tmp___1 ;

  {
  firstPtrPtr = (void **)bsearch((void const   *)key___1, (void const   *)indexPtr->el,
                                 (unsigned int )indexPtr->n, sizeof(void *), indexPtr->CmpKeyWithEl);
  if ((unsigned int )firstPtrPtr == (unsigned int )((void *)0)) {
    return ((void **)((void *)0));
  } else {
    while (1) {
      if ((unsigned int )firstPtrPtr != (unsigned int )indexPtr->el) {
        tmp___0 = ((*(indexPtr->CmpKeyWithEl)))((void const   *)key___1, (void const   *)(firstPtrPtr -
                                                                                          1));
        if (! (tmp___0 == 0)) {
          break;
        }
      } else {
        break;
      }
      firstPtrPtr --;
    }
    n = indexPtr->n - (firstPtrPtr - indexPtr->el);
    i = 1;
    while (1) {
      if (i < n) {
        tmp___1 = ((*(indexPtr->CmpKeyWithEl)))((void const   *)key___1, (void const   *)(firstPtrPtr +
                                                                                          i));
        if (! (tmp___1 == 0)) {
          break;
        }
      } else {
        break;
      }
      i ++;
    }
    retPtrPtr = (void **)ns_malloc((unsigned int )(i + 1) * sizeof(void *));
    memcpy((void * __restrict  )retPtrPtr, (void const   * __restrict  )firstPtrPtr,
           (unsigned int )i * sizeof(void *));
    (*(retPtrPtr + i)) = (void *)0;
    return (retPtrPtr);
  }
}
}
static int BinSearch(void **elPtrPtr , void **listPtrPtr , int n , Ns_IndexCmpProc *cmpProc ) 
{ int cond___9 ;
  int low ;
  int high ;
  int mid ;
  int tmp ;

  {
  cond___9 = 0;
  low = 0;
  high = 0;
  mid = 0;
  low = 0;
  high = n - 1;
  while (low <= high) {
    mid = (low + high) / 2;
    cond___9 = ((*cmpProc))((void const   *)elPtrPtr, (void const   *)(listPtrPtr +
                                                                       mid));
    if (cond___9 < 0) {
      high = mid - 1;
    } else {
      if (cond___9 > 0) {
        low = mid + 1;
      } else {
        return (mid);
      }
    }
  }
  if (high < mid) {
    tmp = mid;
  } else {
    tmp = low;
  }
  return (tmp);
}
}
static int BinSearchKey(void *key___1 , void **listPtrPtr , int n , Ns_IndexCmpProc *cmpProc ) 
{ int cond___9 ;
  int low ;
  int high ;
  int mid ;
  int tmp ;

  {
  cond___9 = 0;
  low = 0;
  high = 0;
  mid = 0;
  low = 0;
  high = n - 1;
  while (low <= high) {
    mid = (low + high) / 2;
    cond___9 = ((*cmpProc))((void const   *)key___1, (void const   *)(listPtrPtr +
                                                                      mid));
    if (cond___9 < 0) {
      high = mid - 1;
    } else {
      if (cond___9 > 0) {
        low = mid + 1;
      } else {
        return (mid);
      }
    }
  }
  if (high < mid) {
    tmp = mid;
  } else {
    tmp = low;
  }
  return (tmp);
}
}
void Ns_IndexAdd(Ns_Index *indexPtr , void *el ) 
{ int i ;
  int j ;

  {
  if (indexPtr->n == indexPtr->max) {
    indexPtr->max += indexPtr->inc;
    indexPtr->el = (void **)ns_realloc((void *)indexPtr->el, (unsigned int )indexPtr->max *
                                                             sizeof(void *));
  } else {
    if (indexPtr->max == 0) {
      indexPtr->max += indexPtr->inc;
      indexPtr->el = (void **)ns_malloc((unsigned int )indexPtr->max * sizeof(void *));
    }
  }
  if (indexPtr->n > 0) {
    i = BinSearch(& el, indexPtr->el, indexPtr->n, indexPtr->CmpEls);
  } else {
    i = 0;
  }
  if (i < indexPtr->n) {
    j = indexPtr->n;
    while (j > i) {
      (*(indexPtr->el + j)) = (*(indexPtr->el + (j - 1)));
      j --;
    }
  }
  (*(indexPtr->el + i)) = el;
  indexPtr->n ++;
  return;
}
}
void Ns_IndexDel(Ns_Index *indexPtr , void *el ) 
{ int i ;
  int done ;
  int j ;

  {
  done = 0;
  i = 0;
  while (1) {
    if (i < indexPtr->n) {
      if (! (! done)) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned int )(*(indexPtr->el + i)) == (unsigned int )el) {
      indexPtr->n --;
      if (i < indexPtr->n) {
        j = i;
        while (j < indexPtr->n) {
          (*(indexPtr->el + j)) = (*(indexPtr->el + (j + 1)));
          j ++;
        }
      }
      done = 1;
    }
    i ++;
  }
  return;
}
}
void *Ns_IndexEl(Ns_Index *indexPtr , int i ) 
{ 

  {
  return ((*(indexPtr->el + i)));
}
}
static int CmpStr(char **leftPtr , char **rightPtr ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if (0) {
    __s1_len = strlen((char const   *)(*leftPtr));
    __s2_len = strlen((char const   *)(*rightPtr));
    if (! ((unsigned int )((void const   *)((*leftPtr) + 1)) - (unsigned int )((void const   *)(*leftPtr)) ==
           1U)) {
      goto _L___0;
    } else {
      if (__s1_len >= 4U) {
        _L___0: 
        if (! ((unsigned int )((void const   *)((*rightPtr) + 1)) - (unsigned int )((void const   *)(*rightPtr)) ==
               1U)) {
          tmp___6 = 1;
        } else {
          if (__s2_len >= 4U) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        }
      } else {
        tmp___6 = 0;
      }
    }
    if (tmp___6) {
      if (__s1_len < __s2_len) {
        tmp___4 = __s1_len;
      } else {
        tmp___4 = __s2_len;
      }
      tmp___3 = memcmp((void const   *)((char const   *)(*leftPtr)), (void const   *)((char const   *)(*rightPtr)),
                       tmp___4 + 1U);
    } else {
      tmp___5 = strcmp((char const   *)(*leftPtr), (char const   *)(*rightPtr));
      tmp___3 = tmp___5;
    }
  } else {
    tmp___5 = strcmp((char const   *)(*leftPtr), (char const   *)(*rightPtr));
    tmp___3 = tmp___5;
  }
  return (tmp___3);
}
}
static int CmpKeyWithStr(char *key___1 , char **elPtr ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if (0) {
    __s1_len = strlen((char const   *)key___1);
    __s2_len = strlen((char const   *)(*elPtr));
    if (! ((unsigned int )((void const   *)(key___1 + 1)) - (unsigned int )((void const   *)key___1) ==
           1U)) {
      goto _L___0;
    } else {
      if (__s1_len >= 4U) {
        _L___0: 
        if (! ((unsigned int )((void const   *)((*elPtr) + 1)) - (unsigned int )((void const   *)(*elPtr)) ==
               1U)) {
          tmp___6 = 1;
        } else {
          if (__s2_len >= 4U) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        }
      } else {
        tmp___6 = 0;
      }
    }
    if (tmp___6) {
      if (__s1_len < __s2_len) {
        tmp___4 = __s1_len;
      } else {
        tmp___4 = __s2_len;
      }
      tmp___3 = memcmp((void const   *)((char const   *)key___1), (void const   *)((char const   *)(*elPtr)),
                       tmp___4 + 1U);
    } else {
      tmp___5 = strcmp((char const   *)key___1, (char const   *)(*elPtr));
      tmp___3 = tmp___5;
    }
  } else {
    tmp___5 = strcmp((char const   *)key___1, (char const   *)(*elPtr));
    tmp___3 = tmp___5;
  }
  return (tmp___3);
}
}
void Ns_IndexStringInit(Ns_Index *indexPtr , int inc ) 
{ 

  {
  Ns_IndexInit(indexPtr, inc, (int (*)(void const   * , void const   * ))(& CmpStr),
               (int (*)(void const   * , void const   * ))(& CmpKeyWithStr));
  return;
}
}
Ns_Index *Ns_IndexStringDup(Ns_Index *indexPtr ) 
{ Ns_Index *newPtr ;
  int i ;

  {
  newPtr = (Ns_Index *)ns_malloc(sizeof(Ns_Index ));
  memcpy((void * __restrict  )newPtr, (void const   * __restrict  )indexPtr, sizeof(Ns_Index ));
  newPtr->el = (void **)ns_malloc((unsigned int )indexPtr->max * sizeof(void *));
  i = 0;
  while (i < newPtr->n) {
    (*(newPtr->el + i)) = (void *)ns_strdup((char const   *)(*(indexPtr->el + i)));
    i ++;
  }
  return (newPtr);
}
}
void Ns_IndexStringAppend(Ns_Index *addtoPtr , Ns_Index *addfromPtr ) 
{ int i ;
  char *tmp ;

  {
  i = 0;
  while (i < addfromPtr->n) {
    tmp = ns_strdup((char const   *)(*(addfromPtr->el + i)));
    Ns_IndexAdd(addtoPtr, (void *)tmp);
    i ++;
  }
  return;
}
}
void Ns_IndexStringDestroy(Ns_Index *indexPtr ) 
{ int i ;

  {
  i = 0;
  while (i < indexPtr->n) {
    ns_free((*(indexPtr->el + i)));
    i ++;
  }
  Ns_IndexDestroy(indexPtr);
  return;
}
}
void Ns_IndexStringTrunc(Ns_Index *indexPtr ) 
{ int i ;

  {
  i = 0;
  while (i < indexPtr->n) {
    ns_free((*(indexPtr->el + i)));
    i ++;
  }
  Ns_IndexTrunc(indexPtr);
  return;
}
}
static int CmpInts(int *leftPtr , int *rightPtr ) 
{ int tmp ;

  {
  if ((*leftPtr) == (*rightPtr)) {
    return (0);
  } else {
    if ((*leftPtr) < (*rightPtr)) {
      tmp = -1;
    } else {
      tmp = 1;
    }
    return (tmp);
  }
}
}
static int CmpKeyWithInt(int *keyPtr , int *elPtr ) 
{ int tmp ;

  {
  if ((*keyPtr) == (*elPtr)) {
    return (0);
  } else {
    if ((*keyPtr) < (*elPtr)) {
      tmp = -1;
    } else {
      tmp = 1;
    }
    return (tmp);
  }
}
}
void Ns_IndexIntInit(Ns_Index *indexPtr , int inc ) 
{ 

  {
  Ns_IndexInit(indexPtr, inc, (int (*)(void const   * , void const   * ))(& CmpInts),
               (int (*)(void const   * , void const   * ))(& CmpKeyWithInt));
  return;
}
}
extern double difftime(time_t __time1 , time_t __time0 )  __attribute__((__const__)) ;
void Ns_MutexList(Tcl_DString *dsPtr ) ;
void Ns_ThreadList(Tcl_DString *dsPtr , Ns_ThreadArgProc *proc ) ;
char *Ns_InfoErrorLog(void) ;
char *Ns_InfoHomePath(void) ;
char *Ns_InfoServerName(void) ;
char *Ns_InfoServerVersion(void) ;
char *Ns_InfoConfigFile(void) ;
int Ns_InfoPid(void) ;
char *Ns_InfoNameOfExecutable(void) ;
char *Ns_InfoPlatform(void) ;
int Ns_InfoUptime(void) ;
int Ns_InfoBootTime(void) ;
char *Ns_InfoAddress(void) ;
char *Ns_InfoBuildDate(void) ;
int Ns_InfoShutdownPending(void) ;
int Ns_InfoStarted(void) ;
int Ns_InfoServersStarted(void) ;
char *Ns_InfoLabel(void) ;
char *Ns_InfoTag(void) ;
void NsGetSockCallbacks(Tcl_DString *dsPtr ) ;
void NsGetScheduled(Tcl_DString *dsPtr ) ;
static void ThreadArgProc(Tcl_DString *dsPtr , void *proc , void *arg ) ;
char *Ns_InfoHomePath(void) 
{ 

  {
  return (nsconf.home);
}
}
char *Ns_InfoServerName(void) 
{ 

  {
  return (nsconf.name);
}
}
char *Ns_InfoServerVersion(void) 
{ 

  {
  return (nsconf.version);
}
}
char *Ns_InfoConfigFile(void) 
{ 

  {
  return (nsconf.config);
}
}
int Ns_InfoPid(void) 
{ 

  {
  return (nsconf.pid);
}
}
char *Ns_InfoNameOfExecutable(void) 
{ 

  {
  return (nsconf.nsd);
}
}
char *Ns_InfoPlatform(void) 
{ 

  {
  return ((char *)"linux");
}
}
int Ns_InfoUptime(void) 
{ time_t tmp ;
  int tmp___0 ;

  {
  tmp = time((time_t *)((void *)0));
  tmp___0 = (int )difftime(tmp, nsconf.boot_t);
  return (tmp___0);
}
}
int Ns_InfoBootTime(void) 
{ 

  {
  return ((int )nsconf.boot_t);
}
}
char *Ns_InfoHostname(void) 
{ 

  {
  return (nsconf.hostname);
}
}
char *Ns_InfoAddress(void) 
{ 

  {
  return (nsconf.address);
}
}
char *Ns_InfoBuildDate(void) 
{ 

  {
  return (nsconf.build);
}
}
int Ns_InfoShutdownPending(void) 
{ int stopping ;

  {
  Ns_MutexLock(& nsconf.state.lock);
  stopping = nsconf.state.stopping;
  Ns_MutexUnlock(& nsconf.state.lock);
  return (stopping);
}
}
int Ns_InfoStarted(void) 
{ int started ;

  {
  Ns_MutexLock(& nsconf.state.lock);
  started = nsconf.state.started;
  Ns_MutexUnlock(& nsconf.state.lock);
  return (started);
}
}
int Ns_InfoServersStarted(void) 
{ int tmp ;

  {
  tmp = Ns_InfoStarted();
  return (tmp);
}
}
char *Ns_InfoLabel(void) 
{ 

  {
  return ((char *)"aolserver4_0");
}
}
char *Ns_InfoTag(void) 
{ 

  {
  return ((char *)"$Name: aolserver_v40_r10 $");
}
}
int NsTclInfoObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
static char *opts___0[31]  = 
  {      (char *)"address",      (char *)"argv0",      (char *)"boottime",      (char *)"builddate", 
        (char *)"callbacks",      (char *)"config",      (char *)"home",      (char *)"hostname", 
        (char *)"label",      (char *)"locks",      (char *)"log",      (char *)"major", 
        (char *)"minor",      (char *)"name",      (char *)"nsd",      (char *)"pageroot", 
        (char *)"patchlevel",      (char *)"pid",      (char *)"platform",      (char *)"pools", 
        (char *)"scheduled",      (char *)"server",      (char *)"servers",      (char *)"sockcallbacks", 
        (char *)"tag",      (char *)"tcllib",      (char *)"threads",      (char *)"uptime", 
        (char *)"version",      (char *)"winnt",      (char *)((void *)0)};
extern int Tcl_GetMemoryInfo() ;
int NsTclInfoObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  char *elog ;
  Tcl_DString ds ;
  enum __anonenum_opt_107 opt ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  Tcl_Obj *tmp___7 ;
  int tmp___8 ;
  Tcl_Obj *tmp___9 ;
  int tmp___10 ;
  Tcl_Obj *tmp___11 ;
  Tcl_Obj *tmp___12 ;
  Tcl_Obj *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"option");
    return (1);
  }
  tmp = Tcl_GetIndexFromObj(interp, (*(objv + 1)), opts___0, (char *)"option", 0,
                            (int *)(& opt));
  if (tmp != 0) {
    return (1);
  }
  Tcl_DStringInit(& ds);
  switch ((int )opt) {
  case 1: 
  Tcl_SetResult(interp, nsconf.argv0, (Tcl_FreeProc *)0);
  break;
  case 14: 
  Tcl_SetResult(interp, nsconf.nsd, (Tcl_FreeProc *)0);
  break;
  case 13: 
  tmp___0 = Ns_InfoServerName();
  Tcl_SetResult(interp, tmp___0, (Tcl_FreeProc *)0);
  break;
  case 5: 
  tmp___1 = Ns_InfoConfigFile();
  Tcl_SetResult(interp, tmp___1, (Tcl_FreeProc *)0);
  break;
  case 4: 
  NsGetCallbacks(& ds);
  Tcl_DStringResult(interp, & ds);
  break;
  case 23: 
  NsGetSockCallbacks(& ds);
  Tcl_DStringResult(interp, & ds);
  break;
  case 20: 
  NsGetScheduled(& ds);
  Tcl_DStringResult(interp, & ds);
  break;
  case 9: 
  Ns_MutexList(& ds);
  Tcl_DStringResult(interp, & ds);
  break;
  case 26: 
  Ns_ThreadList(& ds, & ThreadArgProc);
  Tcl_DStringResult(interp, & ds);
  break;
  case 19: 
  Tcl_GetMemoryInfo(& ds);
  Tcl_DStringResult(interp, & ds);
  break;
  case 10: 
  elog = Ns_InfoErrorLog();
  if ((unsigned int )elog == (unsigned int )((void *)0)) {
    tmp___2 = "STDOUT";
  } else {
    tmp___2 = (char const   *)elog;
  }
  Tcl_SetResult(interp, (char *)tmp___2, (Tcl_FreeProc *)0);
  break;
  case 18: 
  tmp___3 = Ns_InfoPlatform();
  Tcl_SetResult(interp, tmp___3, (Tcl_FreeProc *)0);
  break;
  case 7: 
  tmp___4 = Ns_InfoHostname();
  Tcl_SetResult(interp, tmp___4, (Tcl_FreeProc *)0);
  break;
  case 0: 
  tmp___5 = Ns_InfoAddress();
  Tcl_SetResult(interp, tmp___5, (Tcl_FreeProc *)0);
  break;
  case 27: 
  tmp___6 = Ns_InfoUptime();
  tmp___7 = Tcl_NewIntObj(tmp___6);
  Tcl_SetObjResult(interp, tmp___7);
  break;
  case 2: 
  tmp___8 = Ns_InfoBootTime();
  tmp___9 = Tcl_NewIntObj(tmp___8);
  Tcl_SetObjResult(interp, tmp___9);
  break;
  case 17: 
  tmp___10 = Ns_InfoPid();
  tmp___11 = Tcl_NewIntObj(tmp___10);
  Tcl_SetObjResult(interp, tmp___11);
  break;
  case 11: 
  tmp___12 = Tcl_NewIntObj(4);
  Tcl_SetObjResult(interp, tmp___12);
  break;
  case 12: 
  tmp___13 = Tcl_NewIntObj(0);
  Tcl_SetObjResult(interp, tmp___13);
  break;
  case 28: 
  Tcl_SetResult(interp, (char *)"4.0", (Tcl_FreeProc *)0);
  break;
  case 16: 
  Tcl_SetResult(interp, (char *)"4.0.10", (Tcl_FreeProc *)0);
  break;
  case 6: 
  tmp___14 = Ns_InfoHomePath();
  Tcl_SetResult(interp, tmp___14, (Tcl_FreeProc *)0);
  break;
  case 29: 
  Tcl_SetResult(interp, (char *)"0", (Tcl_FreeProc *)0);
  break;
  case 8: 
  tmp___15 = Ns_InfoLabel();
  Tcl_SetResult(interp, tmp___15, (Tcl_FreeProc *)0);
  break;
  case 3: 
  tmp___16 = Ns_InfoBuildDate();
  Tcl_SetResult(interp, tmp___16, (Tcl_FreeProc *)0);
  break;
  case 24: 
  tmp___17 = Ns_InfoTag();
  Tcl_SetResult(interp, tmp___17, (Tcl_FreeProc *)0);
  break;
  case 22: 
  Tcl_SetResult(interp, nsconf.servers.string, (Tcl_FreeProc *)0);
  break;
  case 25: ;
  case 15: ;
  case 21: ;
  if ((unsigned int )itPtr->servPtr == (unsigned int )((void *)0)) {
    Tcl_SetResult(interp, (char *)"no server", (Tcl_FreeProc *)0);
    return (1);
  }
  if ((int )opt == 21) {
    Tcl_SetResult(interp, (itPtr->servPtr)->server, (Tcl_FreeProc *)0);
  } else {
    if ((int )opt == 25) {
      Tcl_SetResult(interp, (itPtr->servPtr)->tcl.library, (Tcl_FreeProc *)0);
    } else {
      Tcl_SetResult(interp, (itPtr->servPtr)->fastpath.pageroot, (Tcl_FreeProc *)0);
    }
  }
  }
  return (0);
}
}
int NsTclLibraryCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ NsInterp *itPtr ;
  char *lib ;
  Tcl_DString ds ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  itPtr = (NsInterp *)arg;
  if (argc != 2) {
    if (argc != 3) {
      Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " library ?module?\"",
                       (void *)0);
      return (1);
    }
  }
  if ((int )(*((*(argv + 1)))) == (int )(*"private")) {
    if (0) {
      __s1_len___0 = strlen((char const   *)(*(argv + 1)));
      __s2_len___0 = strlen("private");
      if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                       1))) ==
             1U)) {
        goto _L___2;
      } else {
        if (__s1_len___0 >= 4U) {
          _L___2: 
          if (! ((unsigned int )((void const   *)("private" + 1)) - (unsigned int )((void const   *)"private") ==
                 1U)) {
            tmp___14 = 1;
          } else {
            if (__s2_len___0 >= 4U) {
              tmp___14 = 1;
            } else {
              tmp___14 = 0;
            }
          }
        } else {
          tmp___14 = 0;
        }
      }
      if (tmp___14) {
        if (__s1_len___0 < __s2_len___0) {
          tmp___12 = __s1_len___0;
        } else {
          tmp___12 = __s2_len___0;
        }
        tmp___11 = memcmp((void const   *)((char const   *)(*(argv + 1))), (void const   *)"private",
                          tmp___12 + 1U);
      } else {
        tmp___13 = strcmp((char const   *)(*(argv + 1)), "private");
        tmp___11 = tmp___13;
      }
    } else {
      tmp___13 = strcmp((char const   *)(*(argv + 1)), "private");
      tmp___11 = tmp___13;
    }
    if (tmp___11 == 0) {
      lib = (itPtr->servPtr)->tcl.library;
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    if ((int )(*((*(argv + 1)))) == (int )(*"shared")) {
      if (0) {
        __s1_len = strlen((char const   *)(*(argv + 1)));
        __s2_len = strlen("shared");
        if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                         1))) ==
               1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("shared" + 1)) - (unsigned int )((void const   *)"shared") ==
                   1U)) {
              tmp___6 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___6 = 1;
              } else {
                tmp___6 = 0;
              }
            }
          } else {
            tmp___6 = 0;
          }
        }
        if (tmp___6) {
          if (__s1_len < __s2_len) {
            tmp___4 = __s1_len;
          } else {
            tmp___4 = __s2_len;
          }
          tmp___3 = memcmp((void const   *)((char const   *)(*(argv + 1))), (void const   *)"shared",
                           tmp___4 + 1U);
        } else {
          tmp___5 = strcmp((char const   *)(*(argv + 1)), "shared");
          tmp___3 = tmp___5;
        }
      } else {
        tmp___5 = strcmp((char const   *)(*(argv + 1)), "shared");
        tmp___3 = tmp___5;
      }
      if (tmp___3 == 0) {
        lib = nsconf.tcl.sharedlibrary;
      } else {
        Tcl_AppendResult(interp, "unknown library \"", (*(argv + 1)), "\": should be private or shared",
                         (void *)0);
        return (1);
      }
    } else {
      Tcl_AppendResult(interp, "unknown library \"", (*(argv + 1)), "\": should be private or shared",
                       (void *)0);
      return (1);
    }
  }
  Tcl_DStringInit(& ds);
  Ns_MakePath(& ds, lib, (*(argv + 2)), (void *)0);
  Tcl_SetResult(interp, ds.string, (Tcl_FreeProc *)1);
  Tcl_DStringFree(& ds);
  return (0);
}
}
static void ThreadArgProc(Tcl_DString *dsPtr , void *proc , void *arg ) 
{ 

  {
  Ns_GetProcInfo(dsPtr, proc, arg);
  return;
}
}
void NsInitConf(void) ;
void NsInitListen(void) ;
void NsInitLog(void) ;
void NsInitInfo(void) ;
void NsInitMimeTypes(void) ;
void NsInitModLoad(void) ;
void NsInitProcInfo(void) ;
void NsInitQueue(void) ;
void NsInitSched(void) ;
void NsInitTcl(void) ;
void NsInitUrlSpace(void) ;
void NsInitRequests(void) ;
void NsdInit(void) ;
static int once  =    0;
void NsdInit(void) 
{ 

  {
  if (! once) {
    once = 1;
    NsInitBinder();
    NsInitCache();
    NsInitConf();
    NsInitEncodings();
    NsInitListen();
    NsInitLog();
    NsInitInfo();
    NsInitMimeTypes();
    NsInitModLoad();
    NsInitProcInfo();
    NsInitDrivers();
    NsInitQueue();
    NsInitSched();
    NsInitTcl();
    NsInitUrlSpace();
    NsInitRequests();
  }
  return;
}
}
extern struct _IO_FILE *stdout ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
Ns_List *Ns_ListNconc(Ns_List *l1Ptr , Ns_List *l2Ptr ) ;
Ns_List *Ns_ListCons(void *elem , Ns_List *lPtr ) ;
Ns_List *Ns_ListNreverse(Ns_List *lPtr ) ;
Ns_List *Ns_ListLast(Ns_List *lPtr ) ;
void Ns_ListFree(Ns_List *lPtr , Ns_ElemVoidProc *freeProc ) ;
void Ns_IntPrint(int d ) ;
void Ns_StringPrint(char *s ) ;
void Ns_ListPrint(Ns_List *lPtr , Ns_ElemVoidProc *printProc ) ;
Ns_List *Ns_ListCopy(Ns_List *lPtr ) ;
int Ns_ListLength(Ns_List *lPtr ) ;
Ns_List *Ns_ListWeightSort(Ns_List *wPtr ) ;
Ns_List *Ns_ListSort(Ns_List *wPtr , Ns_SortProc *sortProc ) ;
Ns_List *Ns_ListDeleteLowElements(Ns_List *mPtr , float minweight ) ;
Ns_List *Ns_ListDeleteWithTest(void *elem , Ns_List *lPtr , Ns_EqualProc *equalProc ) ;
Ns_List *Ns_ListDeleteIf(Ns_List *lPtr , Ns_ElemTestProc *testProc ) ;
Ns_List *Ns_ListDeleteDuplicates(Ns_List *lPtr , Ns_EqualProc *equalProc ) ;
Ns_List *Ns_ListNmapcar(Ns_List *lPtr , Ns_ElemValProc *valProc ) ;
Ns_List *Ns_ListMapcar(Ns_List *lPtr , Ns_ElemValProc *valProc ) ;
Ns_List *Ns_ListNconc(Ns_List *l1Ptr , Ns_List *l2Ptr ) 
{ Ns_List *lPtr ;

  {
  if ((unsigned int )l1Ptr != (unsigned int )((void *)0)) {
    lPtr = l1Ptr;
    while ((unsigned int )lPtr->rest != (unsigned int )((void *)0)) {
      lPtr = lPtr->rest;
    }
    lPtr->rest = l2Ptr;
    return (l1Ptr);
  } else {
    return (l2Ptr);
  }
}
}
Ns_List *Ns_ListCons(void *elem , Ns_List *lPtr ) 
{ Ns_List *newlPtr ;

  {
  newlPtr = (Ns_List *)ns_malloc(sizeof(Ns_List ));
  newlPtr->first = elem;
  newlPtr->rest = lPtr;
  return (newlPtr);
}
}
Ns_List *Ns_ListNreverse(Ns_List *lPtr ) 
{ Ns_List *nextPtr ;
  Ns_List *nextRestPtr ;

  {
  if ((unsigned int )lPtr != (unsigned int )((void *)0)) {
    nextPtr = lPtr->rest;
    lPtr->rest = (struct Ns_List *)((void *)0);
    while ((unsigned int )nextPtr != (unsigned int )((void *)0)) {
      nextRestPtr = nextPtr->rest;
      nextPtr->rest = lPtr;
      lPtr = nextPtr;
      nextPtr = nextRestPtr;
    }
  }
  return (lPtr);
}
}
Ns_List *Ns_ListLast(Ns_List *lPtr ) 
{ 

  {
  if ((unsigned int )lPtr == (unsigned int )((void *)0)) {
    return ((Ns_List *)((void *)0));
  } else {
    while ((unsigned int )lPtr->rest != (unsigned int )((void *)0)) {
      lPtr = lPtr->rest;
    }
    return (lPtr);
  }
}
}
void Ns_ListFree(Ns_List *lPtr , Ns_ElemVoidProc *freeProc ) 
{ Ns_List *nextPtr ;

  {
  while ((unsigned int )lPtr != (unsigned int )((void *)0)) {
    nextPtr = lPtr->rest;
    if ((unsigned int )freeProc != (unsigned int )((void *)0)) {
      ((*freeProc))(lPtr->first);
    }
    ns_free((void *)lPtr);
    lPtr = nextPtr;
  }
  return;
}
}
void Ns_IntPrint(int d ) 
{ 

  {
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%d", d);
  return;
}
}
void Ns_StringPrint(char *s ) 
{ 

  {
  fputs((char const   * __restrict  )s, (FILE * __restrict  )stdout);
  return;
}
}
void Ns_ListPrint(Ns_List *lPtr , Ns_ElemVoidProc *printProc ) 
{ 

  {
  Ns_StringPrint((char *)"(");
  while ((unsigned int )lPtr != (unsigned int )((void *)0)) {
    ((*printProc))(lPtr->first);
    if ((unsigned int )lPtr->rest != (unsigned int )((void *)0)) {
      Ns_StringPrint((char *)" ");
    }
    lPtr = lPtr->rest;
  }
  Ns_StringPrint((char *)")\n");
  return;
}
}
Ns_List *Ns_ListCopy(Ns_List *lPtr ) 
{ Ns_List *curPtr ;
  Ns_List *newPtr ;
  Ns_List *headPtr ;

  {
  curPtr = (Ns_List *)((void *)0);
  newPtr = (Ns_List *)((void *)0);
  headPtr = (Ns_List *)((void *)0);
  if ((unsigned int )lPtr == (unsigned int )((void *)0)) {
    return ((Ns_List *)((void *)0));
  }
  curPtr = Ns_ListCons(lPtr->first, (Ns_List *)((void *)0));
  headPtr = curPtr;
  lPtr = lPtr->rest;
  while ((unsigned int )lPtr != (unsigned int )((void *)0)) {
    newPtr = Ns_ListCons(lPtr->first, (Ns_List *)((void *)0));
    curPtr->rest = newPtr;
    curPtr = newPtr;
    lPtr = lPtr->rest;
  }
  newPtr->rest = (struct Ns_List *)((void *)0);
  return (headPtr);
}
}
int Ns_ListLength(Ns_List *lPtr ) 
{ int i ;

  {
  i = 0;
  while ((unsigned int )lPtr != (unsigned int )((void *)0)) {
    i ++;
    lPtr = lPtr->rest;
  }
  return (i);
}
}
Ns_List *Ns_ListWeightSort(Ns_List *wPtr ) 
{ Ns_List *curPtr ;
  Ns_List *mPtr ;
  Ns_List *nPtr ;
  Ns_List *axisnodePtr ;
  Ns_List **lastmPtrPtr ;
  Ns_List **lastnPtrPtr ;
  float axis ;
  Ns_List *tmp ;
  Ns_List *tmp___0 ;
  Ns_List *tmp___1 ;

  {
  if ((unsigned int )wPtr == (unsigned int )((void *)0)) {
    return (wPtr);
  } else {
    if ((unsigned int )wPtr->rest == (unsigned int )((void *)0)) {
      return (wPtr);
    }
  }
  curPtr = wPtr->rest;
  axisnodePtr = wPtr;
  axisnodePtr->rest = (struct Ns_List *)((void *)0);
  axis = wPtr->weight;
  mPtr = (Ns_List *)((void *)0);
  nPtr = (Ns_List *)((void *)0);
  lastmPtrPtr = & mPtr;
  lastnPtrPtr = & nPtr;
  while ((unsigned int )curPtr != (unsigned int )((void *)0)) {
    if (curPtr->weight >= axis) {
      (*lastmPtrPtr) = curPtr;
      lastmPtrPtr = & curPtr->rest;
    } else {
      (*lastnPtrPtr) = curPtr;
      lastnPtrPtr = & curPtr->rest;
    }
    curPtr = curPtr->rest;
  }
  (*lastmPtrPtr) = (Ns_List *)((void *)0);
  (*lastnPtrPtr) = (Ns_List *)((void *)0);
  tmp = Ns_ListWeightSort(nPtr);
  Ns_ListNconc(axisnodePtr, tmp);
  tmp___0 = Ns_ListWeightSort(mPtr);
  tmp___1 = Ns_ListNconc(tmp___0, axisnodePtr);
  return (tmp___1);
}
}
Ns_List *Ns_ListSort(Ns_List *wPtr , Ns_SortProc *sortProc ) 
{ Ns_List *curPtr ;
  Ns_List *mPtr ;
  Ns_List *nPtr ;
  Ns_List *axisnodePtr ;
  void *axisPtr ;
  Ns_List **lastmPtrPtr ;
  Ns_List **lastnPtrPtr ;
  int tmp ;
  Ns_List *tmp___0 ;
  Ns_List *tmp___1 ;
  Ns_List *tmp___2 ;

  {
  if ((unsigned int )wPtr == (unsigned int )((void *)0)) {
    return (wPtr);
  } else {
    if ((unsigned int )wPtr->rest == (unsigned int )((void *)0)) {
      return (wPtr);
    }
  }
  curPtr = wPtr->rest;
  axisnodePtr = wPtr;
  axisnodePtr->rest = (struct Ns_List *)((void *)0);
  axisPtr = wPtr->first;
  mPtr = (Ns_List *)((void *)0);
  nPtr = (Ns_List *)((void *)0);
  lastmPtrPtr = & mPtr;
  lastnPtrPtr = & nPtr;
  while ((unsigned int )curPtr != (unsigned int )((void *)0)) {
    tmp = ((*sortProc))(curPtr->first, axisPtr);
    if (tmp <= 0) {
      (*lastmPtrPtr) = curPtr;
      lastmPtrPtr = & curPtr->rest;
    } else {
      (*lastnPtrPtr) = curPtr;
      lastnPtrPtr = & curPtr->rest;
    }
    curPtr = curPtr->rest;
  }
  (*lastmPtrPtr) = (Ns_List *)((void *)0);
  (*lastnPtrPtr) = (Ns_List *)((void *)0);
  tmp___0 = Ns_ListSort(nPtr, sortProc);
  Ns_ListNconc(axisnodePtr, tmp___0);
  tmp___1 = Ns_ListSort(mPtr, sortProc);
  tmp___2 = Ns_ListNconc(tmp___1, axisnodePtr);
  return (tmp___2);
}
}
Ns_List *Ns_ListDeleteLowElements(Ns_List *mPtr , float minweight ) 
{ Ns_List **lastPtrPtr ;
  Ns_List *curPtr ;
  Ns_List *nextPtr ;

  {
  lastPtrPtr = & mPtr;
  curPtr = mPtr;
  while ((unsigned int )curPtr != (unsigned int )((void *)0)) {
    nextPtr = curPtr->rest;
    if (curPtr->weight < minweight) {
      (*lastPtrPtr) = curPtr->rest;
      ns_free((void *)curPtr);
    } else {
      lastPtrPtr = & curPtr->rest;
    }
    curPtr = nextPtr;
  }
  return (mPtr);
}
}
Ns_List *Ns_ListDeleteWithTest(void *elem , Ns_List *lPtr , Ns_EqualProc *equalProc ) 
{ Ns_List *mPtr ;
  Ns_List **lastPtrPtr ;
  int tmp ;

  {
  mPtr = lPtr;
  lastPtrPtr = & lPtr;
  while ((unsigned int )mPtr != (unsigned int )((void *)0)) {
    tmp = ((*equalProc))(elem, mPtr->first);
    if (tmp) {
      (*lastPtrPtr) = mPtr->rest;
      ns_free((void *)mPtr);
      mPtr = (*lastPtrPtr);
    } else {
      lastPtrPtr = & mPtr->rest;
      mPtr = mPtr->rest;
    }
  }
  return (lPtr);
}
}
Ns_List *Ns_ListDeleteIf(Ns_List *lPtr , Ns_ElemTestProc *testProc ) 
{ Ns_List *mPtr ;
  Ns_List **lastPtrPtr ;
  int tmp ;

  {
  mPtr = lPtr;
  lastPtrPtr = & lPtr;
  while ((unsigned int )mPtr != (unsigned int )((void *)0)) {
    tmp = ((*testProc))(mPtr->first);
    if (tmp) {
      (*lastPtrPtr) = mPtr->rest;
      ns_free((void *)mPtr);
      mPtr = (*lastPtrPtr);
    } else {
      lastPtrPtr = & mPtr->rest;
      mPtr = mPtr->rest;
    }
  }
  return (lPtr);
}
}
Ns_List *Ns_ListDeleteDuplicates(Ns_List *lPtr , Ns_EqualProc *equalProc ) 
{ Ns_List *mPtr ;

  {
  mPtr = lPtr;
  while ((unsigned int )lPtr != (unsigned int )((void *)0)) {
    lPtr->rest = Ns_ListDeleteWithTest(lPtr->first, lPtr->rest, equalProc);
    lPtr = lPtr->rest;
  }
  return (mPtr);
}
}
Ns_List *Ns_ListNmapcar(Ns_List *lPtr , Ns_ElemValProc *valProc ) 
{ Ns_List *mPtr ;

  {
  mPtr = lPtr;
  while ((unsigned int )lPtr != (unsigned int )((void *)0)) {
    lPtr->first = ((*valProc))(lPtr->first);
    lPtr = lPtr->rest;
  }
  return (mPtr);
}
}
Ns_List *Ns_ListMapcar(Ns_List *lPtr , Ns_ElemValProc *valProc ) 
{ Ns_List *mPtr ;
  void *tmp ;
  Ns_List *tmp___0 ;

  {
  mPtr = (Ns_List *)((void *)0);
  while ((unsigned int )lPtr != (unsigned int )((void *)0)) {
    tmp = ((*valProc))(lPtr->first);
    mPtr = Ns_ListCons(tmp, mPtr);
    lPtr = lPtr->rest;
  }
  tmp___0 = Ns_ListNreverse(mPtr);
  return (tmp___0);
}
}
extern int getsockname(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __len ) ;
int Ns_SockListenCallback(char *addr , int port , Ns_SockProc *proc , void *arg ) ;
int Ns_SockPortBound(int port ) ;
int Ns_SockListen(char *address , int port ) ;
int Ns_SockSetBlocking(int sock ) ;
int Ns_SockCallback(int sock , Ns_SockProc *proc , void *arg , int when ) ;
static int ListenCallback(int sock , void *arg , int why ) ;
static Tcl_HashTable portsTable  ;
static Ns_Mutex lock___6  ;
void NsInitListen(void) 
{ 

  {
  Ns_MutexInit(& lock___6);
  Ns_MutexSetName(& lock___6, (char *)"ns:listencallbacks");
  Tcl_InitHashTable(& portsTable, 1);
  return;
}
}
int Ns_SockListenCallback(char *addr , int port , Ns_SockProc *proc , void *arg ) 
{ Tcl_HashTable *tablePtr ;
  Tcl_HashEntry *hPtr ;
  ListenData *ldPtr ;
  int new ;
  int sock ;
  int status ;
  struct sockaddr_in sa ;
  int tmp ;

  {
  tablePtr = (Tcl_HashTable *)((void *)0);
  tmp = Ns_GetSockAddr(& sa, addr, port);
  if (tmp != 0) {
    return (-1);
  }
  if ((unsigned int )addr != (unsigned int )((void *)0)) {
    sa.sin_port = (unsigned short)0;
    sock = Ns_SockBind(& sa);
    if (sock == -1) {
      return (-1);
    }
    close(sock);
  }
  status = 0;
  Ns_MutexLock(& lock___6);
  hPtr = ((*(portsTable.createProc)))(& portsTable, (char *)port, & new);
  if (new == 0) {
    tablePtr = (Tcl_HashTable *)hPtr->clientData;
  } else {
    sock = Ns_SockListen((char *)((void *)0), port);
    if (sock == -1) {
      Tcl_DeleteHashEntry(hPtr);
      status = -1;
    } else {
      Ns_SockSetNonBlocking(sock);
      tablePtr = (Tcl_HashTable *)ns_malloc(sizeof(Tcl_HashTable ));
      Tcl_InitHashTable(tablePtr, 1);
      hPtr->clientData = (void *)tablePtr;
      Ns_SockCallback(sock, & ListenCallback, (void *)tablePtr, 9);
    }
  }
  if (status == 0) {
    hPtr = ((*(tablePtr->createProc)))(tablePtr, (char *)sa.sin_addr.s_addr, & new);
    if (! new) {
      status = -1;
    } else {
      ldPtr = (ListenData *)ns_malloc(sizeof(ListenData ));
      ldPtr->proc = proc;
      ldPtr->arg = arg;
      hPtr->clientData = (void *)ldPtr;
    }
  }
  Ns_MutexUnlock(& lock___6);
  return (status);
}
}
int Ns_SockPortBound(int port ) 
{ Tcl_HashEntry *hPtr ;
  int tmp ;

  {
  Ns_MutexLock(& lock___6);
  hPtr = ((*(portsTable.findProc)))(& portsTable, (char *)port);
  Ns_MutexUnlock(& lock___6);
  if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static int ListenCallback(int sock , void *arg , int why ) 
{ struct sockaddr_in sa ;
  int len ;
  Tcl_HashTable *tablePtr ;
  Tcl_HashEntry *hPtr ;
  int new ;
  ListenData *ldPtr ;

  {
  tablePtr = (Tcl_HashTable *)arg;
  if (why == 8) {
    close(sock);
    return (0);
  }
  new = Ns_SockAccept(sock, (struct sockaddr *)((void *)0), (int *)((void *)0));
  if (new != -1) {
    Ns_SockSetBlocking(new);
    len = (int )sizeof(sa);
    getsockname(new, (struct sockaddr * __restrict  )((struct sockaddr *)(& sa)),
                (socklen_t * __restrict  )(& len));
    ldPtr = (ListenData *)((void *)0);
    Ns_MutexLock(& lock___6);
    hPtr = ((*(tablePtr->findProc)))(tablePtr, (char *)sa.sin_addr.s_addr);
    if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
      hPtr = ((*(tablePtr->findProc)))(tablePtr, (char *)0U);
    }
    if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
      ldPtr = (ListenData *)hPtr->clientData;
    }
    Ns_MutexUnlock(& lock___6);
    if ((unsigned int )ldPtr == (unsigned int )((void *)0)) {
      close(new);
    } else {
      ((*(ldPtr->proc)))(new, ldPtr->arg, why);
    }
  }
  return (1);
}
}
struct tm *ns_localtime(time_t const   *clock___0 ) ;
int Ns_ThreadId(void) ;
char *Ns_ThreadGetName(void) ;
void Ns_TlsAlloc(Ns_Tls *keyPtr , Ns_TlsCleanup *cleanup ) ;
void Ns_TlsSet(Ns_Tls *keyPtr , void *value ) ;
void *Ns_TlsGet(Ns_Tls *keyPtr ) ;
int Ns_LogRoll(void) ;
char *Ns_LogTime(char *timeBuf ) ;
char *Ns_LogTime2(char *timeBuf , int gmt ) ;
int Ns_RollFile(char *file___1 , int max ) ;
void Ns_SetLogFlushProc(Ns_LogFlushProc *procPtr ) ;
void Ns_SetNsLogProc(Ns_LogProc *procPtr ) ;
void NsLogOpen(void) ;
static int LogReOpen(void) ;
static void Log(Ns_LogSeverity severity , char *fmt , va_list ap ) ;
static Cache___0 *LogGetCache(void) ;
static void LogFreeCache(void *arg ) ;
static void LogFlush(Cache___0 *cachePtr ) ;
static char *LogTime(Cache___0 *cachePtr , int gmtoff , long *usecPtr ) ;
static int LogStart(Cache___0 *cachePtr , Ns_LogSeverity severity ) ;
static void LogEnd(Cache___0 *cachePtr ) ;
static Ns_Tls tls  ;
static Ns_Mutex lock___7  ;
static Ns_LogFlushProc *flushProcPtr  ;
static Ns_LogProc *nslogProcPtr  ;
void NsInitLog(void) 
{ 

  {
  Ns_MutexSetName(& lock___7, (char *)"ns:log");
  Ns_TlsAlloc(& tls, & LogFreeCache);
  flushProcPtr = (Ns_LogFlushProc *)((void *)0);
  nslogProcPtr = (Ns_LogProc *)((void *)0);
  return;
}
}
char *Ns_InfoErrorLog(void) 
{ 

  {
  return (nsconf.log.file);
}
}
int Ns_LogRoll(void) 
{ int tmp ;
  int tmp___0 ;

  {
  if ((unsigned int )nsconf.log.file != (unsigned int )((void *)0)) {
    tmp = access((char const   *)nsconf.log.file, 0);
    if (tmp == 0) {
      Ns_RollFile(nsconf.log.file, nsconf.log.maxback);
    }
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"log: re-opening log file \'%s\'",
           nsconf.log.file);
    tmp___0 = LogReOpen();
    if (tmp___0 != 0) {
      return (-1);
    }
  }
  return (0);
}
}
void Ns_Log(Ns_LogSeverity severity , char *fmt  , ...) 
{ va_list ap ;

  {
  __builtin_stdarg_start(ap, fmt);
  Log(severity, fmt, ap);
  __builtin_va_end(ap);
  return;
}
}
void ns_serverLog(Ns_LogSeverity severity , char *fmt , va_list *vaPtr ) 
{ 

  {
  Log(severity, fmt, (*vaPtr));
  return;
}
}
void Ns_Fatal(char *fmt  , ...) 
{ va_list ap ;

  {
  __builtin_stdarg_start(ap, fmt);
  Log((enum __anonenum_Ns_LogSeverity_67 )3, fmt, ap);
  __builtin_va_end(ap);
  _exit(1);
}
}
char *Ns_LogTime2(char *timeBuf , int gmt ) 
{ Cache___0 *tmp ;
  char *tmp___0 ;

  {
  tmp = LogGetCache();
  tmp___0 = LogTime(tmp, gmt, (long *)((void *)0));
  strcpy((char * __restrict  )timeBuf, (char const   * __restrict  )tmp___0);
  return (timeBuf);
}
}
char *Ns_LogTime(char *timeBuf ) 
{ char *tmp ;

  {
  tmp = Ns_LogTime2(timeBuf, 1);
  return (tmp);
}
}
void NsLogOpen(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  tmp___1 = LogReOpen();
  if (tmp___1 != 0) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Ns_Fatal((char *)"log: failed to open server log \'%s\': \'%s\'", nsconf.log.file,
             tmp___0);
  }
  if (nsconf.log.flags & 1) {
    Ns_RegisterAtSignal((Ns_Callback *)(& Ns_LogRoll), (void *)0);
  }
  return;
}
}
int NsTclLogRollObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = Ns_LogRoll();
  if (tmp != 0) {
    Tcl_SetResult(interp, (char *)"could not roll server log", (Tcl_FreeProc *)0);
  }
  return (0);
}
}
int NsTclLogCtlObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
static char *opts___1[8]  = 
  {      (char *)"hold",      (char *)"count",      (char *)"get",      (char *)"peek", 
        (char *)"flush",      (char *)"release",      (char *)"truncate",      (char *)((void *)0)};
int NsTclLogCtlObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int len ;
  Cache___0 *cachePtr ;
  enum __anonenum_opt_107___0 opt ;
  int tmp ;
  Tcl_Obj *tmp___0 ;
  int tmp___1 ;

  {
  if (objc < 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"option ?arg?");
    return (1);
  }
  tmp = Tcl_GetIndexFromObj(interp, (*(objv + 1)), opts___1, (char *)"option", 0,
                            (int *)(& opt));
  if (tmp != 0) {
    return (1);
  }
  cachePtr = LogGetCache();
  switch ((int )opt) {
  case 0: 
  cachePtr->hold = 1;
  break;
  case 3: 
  Tcl_SetResult(interp, cachePtr->buffer.string, (Tcl_FreeProc *)1);
  break;
  case 2: 
  Tcl_SetResult(interp, cachePtr->buffer.string, (Tcl_FreeProc *)1);
  Tcl_DStringFree(& cachePtr->buffer);
  cachePtr->count = 0;
  break;
  case 5: 
  cachePtr->hold = 0;
  case 4: 
  LogFlush(cachePtr);
  cachePtr->count = 0;
  break;
  case 1: 
  tmp___0 = Tcl_GetObjResult(interp);
  Tcl_SetIntObj(tmp___0, cachePtr->count);
  break;
  case 6: 
  len = 0;
  if (objc > 2) {
    tmp___1 = Tcl_GetIntFromObj(interp, (*(objv + 2)), & len);
    if (tmp___1 != 0) {
      return (1);
    }
  }
  Tcl_DStringSetLength(& cachePtr->buffer, len);
  break;
  }
  return (0);
}
}
int NsTclLogObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Ns_LogSeverity severity ;
  Cache___0 *cachePtr ;
  char *severitystr ;
  int i ;
  Tcl_DString ds ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;

  {
  if (objc < 3) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"severity string ?string ...?");
    return (1);
  }
  severitystr = Tcl_GetString((*(objv + 1)));
  cachePtr = LogGetCache();
  tmp___5 = strcasecmp((char const   *)severitystr, "notice");
  if (tmp___5 == 0) {
    severity = (enum __anonenum_Ns_LogSeverity_67 )0;
  } else {
    tmp___4 = strcasecmp((char const   *)severitystr, "warning");
    if (tmp___4 == 0) {
      severity = (enum __anonenum_Ns_LogSeverity_67 )1;
    } else {
      tmp___3 = strcasecmp((char const   *)severitystr, "error");
      if (tmp___3 == 0) {
        severity = (enum __anonenum_Ns_LogSeverity_67 )2;
      } else {
        tmp___2 = strcasecmp((char const   *)severitystr, "fatal");
        if (tmp___2 == 0) {
          severity = (enum __anonenum_Ns_LogSeverity_67 )3;
        } else {
          tmp___1 = strcasecmp((char const   *)severitystr, "bug");
          if (tmp___1 == 0) {
            severity = (enum __anonenum_Ns_LogSeverity_67 )4;
          } else {
            tmp___0 = strcasecmp((char const   *)severitystr, "debug");
            if (tmp___0 == 0) {
              severity = (enum __anonenum_Ns_LogSeverity_67 )5;
            } else {
              tmp = Tcl_GetIntFromObj((Tcl_Interp *)((void *)0), (*(objv + 1)), & i);
              if (tmp == 0) {
                severity = (enum __anonenum_Ns_LogSeverity_67 )i;
              } else {
                Tcl_AppendResult(interp, "unknown severity: \"", severitystr, "\": should be notice, warning, error, fatal, bug, debug or integer value",
                                 (void *)0);
                return (1);
              }
            }
          }
        }
      }
    }
  }
  Tcl_DStringInit(& ds);
  i = 2;
  while (i < objc) {
    if (i < objc - 1) {
      tmp___6 = " ";
    } else {
      tmp___6 = (char const   *)((void *)0);
    }
    tmp___7 = Tcl_GetString((*(objv + i)));
    Ns_DStringVarAppend(& ds, tmp___7, tmp___6, (void *)0);
    i ++;
  }
  Ns_Log(severity, (char *)"%s", ds.string);
  Tcl_DStringFree(& ds);
  return (0);
}
}
static void Log(Ns_LogSeverity severity , char *fmt , va_list ap ) 
{ Cache___0 *cachePtr ;
  int tmp ;

  {
  cachePtr = LogGetCache();
  if ((unsigned int )nslogProcPtr == (unsigned int )((void *)0)) {
    tmp = LogStart(cachePtr, severity);
    if (tmp) {
      Ns_DStringVPrintf(& cachePtr->buffer, fmt, ap);
      LogEnd(cachePtr);
    }
  } else {
    ((*nslogProcPtr))(& cachePtr->buffer, severity, fmt, ap);
    cachePtr->count ++;
    if (! cachePtr->hold) {
      LogFlush(cachePtr);
    }
  }
  return;
}
}
static int LogStart(Cache___0 *cachePtr , Ns_LogSeverity severity ) 
{ char *severityStr ;
  char buf[10] ;
  long usec ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  switch ((int )severity) {
  case 0: ;
  if (nsconf.log.flags & 16) {
    return (0);
  }
  severityStr = (char *)"Notice";
  break;
  case 1: 
  severityStr = (char *)"Warning";
  break;
  case 2: 
  severityStr = (char *)"Error";
  break;
  case 3: 
  severityStr = (char *)"Fatal";
  break;
  case 4: 
  severityStr = (char *)"Bug";
  break;
  case 5: ;
  if (! (nsconf.log.flags & 4)) {
    return (0);
  }
  severityStr = (char *)"Debug";
  break;
  case 6: ;
  if (! (nsconf.log.flags & 8)) {
    return (0);
  }
  severityStr = (char *)"Dev";
  break;
  default: ;
  if ((int )severity > nsconf.log.maxlevel) {
    return (0);
  }
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"Level%d", severity);
  severityStr = buf;
  break;
  }
  tmp = LogTime(cachePtr, 0, & usec);
  Tcl_DStringAppend(& cachePtr->buffer, tmp, -1);
  if (nsconf.log.flags & 32) {
    Tcl_DStringSetLength(& cachePtr->buffer, cachePtr->buffer.length - 1);
    Ns_DStringPrintf(& cachePtr->buffer, (char *)".%ld]", usec);
  }
  tmp___0 = Ns_ThreadGetName();
  tmp___1 = Ns_ThreadId();
  tmp___2 = Ns_InfoPid();
  Ns_DStringPrintf(& cachePtr->buffer, (char *)"[%d.%lu][%s] %s: ", tmp___2, (unsigned long )tmp___1,
                   tmp___0, severityStr);
  if (nsconf.log.flags & 2) {
    Tcl_DStringAppend(& cachePtr->buffer, (char *)"\n    ", -1);
  }
  return (1);
}
}
static void LogEnd(Cache___0 *cachePtr ) 
{ 

  {
  Tcl_DStringAppend(& cachePtr->buffer, (char *)"\n", 1);
  if (nsconf.log.flags & 2) {
    Tcl_DStringAppend(& cachePtr->buffer, (char *)"\n", 1);
  }
  cachePtr->count ++;
  if (! cachePtr->hold) {
    LogFlush(cachePtr);
  }
  return;
}
}
static void LogFlush(Cache___0 *cachePtr ) 
{ Tcl_DString *dsPtr ;

  {
  dsPtr = & cachePtr->buffer;
  Ns_MutexLock(& lock___7);
  if ((unsigned int )flushProcPtr == (unsigned int )((void *)0)) {
    write(2, (void const   *)dsPtr->string, (unsigned int )dsPtr->length);
  } else {
    ((*flushProcPtr))(dsPtr->string, (unsigned int )dsPtr->length);
  }
  Ns_MutexUnlock(& lock___7);
  Tcl_DStringFree(dsPtr);
  cachePtr->count = 0;
  return;
}
}
static int LogReOpen(void) 
{ int fd ;
  int status ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  status = 0;
  fd = open((char const   *)nsconf.log.file, 1089, 420);
  if (fd < 0) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"log: failed to re-open log file \'%s\': \'%s\'",
           nsconf.log.file, tmp___0);
    status = -1;
  } else {
    if (fd != 2) {
      tmp___3 = dup2(fd, 2);
      if (tmp___3 == -1) {
        tmp___1 = __errno_location();
        tmp___2 = strerror((*tmp___1));
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"dup2(%s, STDERR_FILENO) failed: %s\n",
                nsconf.log.file, tmp___2);
        status = -1;
      }
    }
    tmp___6 = dup2(2, 1);
    if (tmp___6 == -1) {
      tmp___4 = __errno_location();
      tmp___5 = strerror((*tmp___4));
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"log: failed to route stdout to file: \'%s\'",
             tmp___5);
      status = -1;
    }
    if (fd != 2) {
      if (fd != 1) {
        close(fd);
      }
    }
  }
  return (status);
}
}
static char *LogTime(Cache___0 *cachePtr , int gmtoff , long *usecPtr ) 
{ time_t *tp___1 ;
  struct tm *ptm ;
  int gmtoffset ;
  int n ;
  int sign ;
  char *bp ;
  Ns_Time now ;
  int tmp ;

  {
  if (gmtoff) {
    tp___1 = & cachePtr->gtime;
    bp = cachePtr->gbuf;
  } else {
    tp___1 = & cachePtr->ltime;
    bp = cachePtr->lbuf;
  }
  Ns_GetTime(& now);
  if ((*tp___1) != now.sec) {
    (*tp___1) = now.sec;
    ptm = ns_localtime((time_t const   *)(& now.sec));
    n = (int )strftime((char * __restrict  )bp, 32U, (char const   * __restrict  )"[%d/%b/%Y:%H:%M:%S",
                       (struct tm  const  * __restrict  )ptm);
    if (! gmtoff) {
      tmp = n;
      n ++;
      (*(bp + tmp)) = (char )']';
      (*(bp + n)) = (char )'\000';
    } else {
      gmtoffset = (int )(ptm->tm_gmtoff / 60L);
      if (gmtoffset < 0) {
        sign = '-';
        gmtoffset *= -1;
      } else {
        sign = '+';
      }
      sprintf((char * __restrict  )(bp + n), (char const   * __restrict  )" %c%02d%02d]",
              sign, gmtoffset / 60, gmtoffset % 60);
    }
  }
  if ((unsigned int )usecPtr != (unsigned int )((void *)0)) {
    (*usecPtr) = now.usec;
  }
  return (bp);
}
}
static Cache___0 *LogGetCache(void) 
{ Cache___0 *cachePtr ;

  {
  cachePtr = (Cache___0 *)Ns_TlsGet(& tls);
  if ((unsigned int )cachePtr == (unsigned int )((void *)0)) {
    cachePtr = (Cache___0 *)ns_calloc(1U, sizeof(Cache___0 ));
    Tcl_DStringInit(& cachePtr->buffer);
    Ns_TlsSet(& tls, (void *)cachePtr);
  }
  return (cachePtr);
}
}
static void LogFreeCache(void *arg ) 
{ Cache___0 *cachePtr ;

  {
  cachePtr = (Cache___0 *)arg;
  LogFlush(cachePtr);
  Tcl_DStringFree(& cachePtr->buffer);
  ns_free((void *)cachePtr);
  return;
}
}
void Ns_SetLogFlushProc(Ns_LogFlushProc *procPtr ) 
{ 

  {
  flushProcPtr = procPtr;
  return;
}
}
void Ns_SetNsLogProc(Ns_LogProc *procPtr ) 
{ 

  {
  nslogProcPtr = procPtr;
  return;
}
}
void NsUpdateMimeTypes(void) ;
static void AddType(char *ext , char *type ) ;
static char *LowerDString(Tcl_DString *dsPtr , char *ext ) ;
static Tcl_HashTable types  ;
static char *defaultType  =    (char *)"*/*";
static char *noextType  =    (char *)"*/*";
static struct exttype typetab[82]  = 
  {      {(char *)".adp", (char *)"text/html; charset=iso-8859-1"}, 
        {(char *)".dci", (char *)"text/html; charset=iso-8859-1"}, 
        {(char *)".htm", (char *)"text/html; charset=iso-8859-1"}, 
        {(char *)".html", (char *)"text/html; charset=iso-8859-1"}, 
        {(char *)".sht", (char *)"text/html; charset=iso-8859-1"}, 
        {(char *)".shtml", (char *)"text/html; charset=iso-8859-1"}, 
        {(char *)".ai", (char *)"application/postscript"}, 
        {(char *)".aif", (char *)"audio/aiff"}, 
        {(char *)".aifc", (char *)"audio/aiff"}, 
        {(char *)".aiff", (char *)"audio/aiff"}, 
        {(char *)".ani", (char *)"application/x-navi-animation"}, 
        {(char *)".art", (char *)"image/x-art"}, 
        {(char *)".au", (char *)"audio/basic"}, 
        {(char *)".avi", (char *)"video/x-msvideo"}, 
        {(char *)".bin", (char *)"application/x-macbinary"}, 
        {(char *)".bmp", (char *)"image/bmp"}, 
        {(char *)".css", (char *)"text/css"}, 
        {(char *)".csv", (char *)"application/csv"}, 
        {(char *)".dcr", (char *)"application/x-director"}, 
        {(char *)".dir", (char *)"application/x-director"}, 
        {(char *)".dp", (char *)"application/commonground"}, 
        {(char *)".dxr", (char *)"application/x-director"}, 
        {(char *)".elm", (char *)"text/plain"}, 
        {(char *)".eml", (char *)"text/plain"}, 
        {(char *)".exe", (char *)"application/octet-stream"}, 
        {(char *)".gbt", (char *)"text/plain"}, 
        {(char *)".gif", (char *)"image/gif"}, 
        {(char *)".gz", (char *)"application/x-compressed"}, 
        {(char *)".hqx", (char *)"application/mac-binhex40"}, 
        {(char *)".jfif", (char *)"image/jpeg"}, 
        {(char *)".jpe", (char *)"image/jpeg"}, 
        {(char *)".jpg", (char *)"image/jpeg"}, 
        {(char *)".jpeg", (char *)"image/jpeg"}, 
        {(char *)".js", (char *)"application/x-javascript"}, 
        {(char *)".ls", (char *)"application/x-javascript"}, 
        {(char *)".map", (char *)"application/x-navimap"}, 
        {(char *)".mid", (char *)"audio/x-midi"}, 
        {(char *)".midi", (char *)"audio/x-midi"}, 
        {(char *)".mocha", (char *)"application/x-javascript"}, 
        {(char *)".mov", (char *)"video/quicktime"}, 
        {(char *)".mpe", (char *)"video/mpeg"}, 
        {(char *)".mpeg", (char *)"video/mpeg"}, 
        {(char *)".mpg", (char *)"video/mpeg"}, 
        {(char *)".nvd", (char *)"application/x-navidoc"}, 
        {(char *)".nvm", (char *)"application/x-navimap"}, 
        {(char *)".pbm", (char *)"image/x-portable-bitmap"}, 
        {(char *)".pdf", (char *)"application/pdf"}, 
        {(char *)".pgm", (char *)"image/x-portable-graymap"}, 
        {(char *)".pic", (char *)"image/pict"}, 
        {(char *)".pict", (char *)"image/pict"}, 
        {(char *)".pnm", (char *)"image/x-portable-anymap"}, 
        {(char *)".png", (char *)"image/png"}, 
        {(char *)".ps", (char *)"application/postscript"}, 
        {(char *)".qt", (char *)"video/quicktime"}, 
        {(char *)".ra", (char *)"audio/x-pn-realaudio"}, 
        {(char *)".ram", (char *)"audio/x-pn-realaudio"}, 
        {(char *)".ras", (char *)"image/x-cmu-raster"}, 
        {(char *)".rgb", (char *)"image/x-rgb"}, 
        {(char *)".rtf", (char *)"application/rtf"}, 
        {(char *)".sit", (char *)"application/x-stuffit"}, 
        {(char *)".snd", (char *)"audio/basic"}, 
        {(char *)".sql", (char *)"application/x-sql"}, 
        {(char *)".stl", (char *)"application/x-navistyle"}, 
        {(char *)".tar", (char *)"application/x-tar"}, 
        {(char *)".tcl", (char *)"text/plain"}, 
        {(char *)".text", (char *)"text/plain"}, 
        {(char *)".tgz", (char *)"application/x-compressed"}, 
        {(char *)".tif", (char *)"image/tiff"}, 
        {(char *)".tiff", (char *)"image/tiff"}, 
        {(char *)".txt", (char *)"text/plain"}, 
        {(char *)".xbm", (char *)"image/x-xbitmap"}, 
        {(char *)".xpm", (char *)"image/x-xpixmap"}, 
        {(char *)".xht", (char *)"application/xhtml+xml"}, 
        {(char *)".xhtml", (char *)"application/xhtml+xml"}, 
        {(char *)".xml", (char *)"text/xml"}, 
        {(char *)".xsl", (char *)"text/xml"}, 
        {(char *)".vrml", (char *)"x-world/x-vrml"}, 
        {(char *)".wav", (char *)"audio/x-wav"}, 
        {(char *)".wrl", (char *)"x-world/x-vrml"}, 
        {(char *)".z", (char *)"application/x-compressed"}, 
        {(char *)".zip", (char *)"application/x-zip-compressed"}, 
        {(char *)((void *)0), (char *)((void *)0)}};
char *Ns_GetMimeType(char *file___1 ) 
{ char *start ;
  char *ext ;
  Tcl_DString ds ;
  Tcl_HashEntry *hePtr ;

  {
  start = strrchr((char const   *)file___1, '/');
  if ((unsigned int )start == (unsigned int )((void *)0)) {
    start = file___1;
  }
  ext = strrchr((char const   *)start, '.');
  if ((unsigned int )ext == (unsigned int )((void *)0)) {
    return (noextType);
  }
  Tcl_DStringInit(& ds);
  ext = LowerDString(& ds, ext);
  hePtr = ((*(types.findProc)))(& types, ext);
  if ((unsigned int )hePtr == (unsigned int )((void *)0)) {
    return (defaultType);
  }
  return ((char *)hePtr->clientData);
}
}
void NsInitMimeTypes(void) 
{ int i ;

  {
  Tcl_InitHashTable(& types, 0);
  i = 0;
  while ((unsigned int )typetab[i].ext != (unsigned int )((void *)0)) {
    AddType(typetab[i].ext, typetab[i].type);
    i ++;
  }
  return;
}
}
void NsUpdateMimeTypes(void) 
{ Ns_Set *set ;
  int i ;

  {
  set = Ns_ConfigGetSection((char *)"ns/mimetypes");
  if ((unsigned int )set == (unsigned int )((void *)0)) {
    return;
  }
  defaultType = Ns_SetIGet(set, (char *)"default");
  if ((unsigned int )defaultType == (unsigned int )((void *)0)) {
    defaultType = (char *)"*/*";
  }
  noextType = Ns_SetIGet(set, (char *)"noextension");
  if ((unsigned int )noextType == (unsigned int )((void *)0)) {
    noextType = defaultType;
  }
  i = 0;
  while (i < set->size) {
    AddType((set->fields + i)->name, (set->fields + i)->value);
    i ++;
  }
  return;
}
}
int NsTclGuessTypeObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ char *type ;
  char *tmp ;

  {
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"filename");
    return (1);
  }
  tmp = Tcl_GetString((*(objv + 1)));
  type = Ns_GetMimeType(tmp);
  Tcl_SetResult(interp, type, (Tcl_FreeProc *)1);
  return (0);
}
}
static void AddType(char *ext , char *type ) 
{ Tcl_DString ds ;
  Tcl_HashEntry *he ;
  int new ;

  {
  Tcl_DStringInit(& ds);
  ext = LowerDString(& ds, ext);
  he = ((*(types.createProc)))(& types, ext, & new);
  if (new == 0) {
    ns_free(he->clientData);
  }
  he->clientData = (ClientData )ns_strdup((char const   *)type);
  Tcl_DStringFree(& ds);
  return;
}
}
static char *LowerDString(Tcl_DString *dsPtr , char *ext ) 
{ int __res ;
  __int32_t const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  Tcl_DStringAppend(dsPtr, ext, -1);
  ext = dsPtr->string;
  while ((int )(*ext) != 0) {
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + (int )((unsigned char )(*ext)))) & 256) {
      if (sizeof((unsigned char )(*ext)) > 1U) {
        __res = tolower__extinline((int )((unsigned char )(*ext)));
      } else {
        tmp___1 = __ctype_tolower_loc();
        __res = (*((*tmp___1) + (int )((unsigned char )(*ext))));
      }
      (*ext) = (char )__res;
    }
    ext ++;
  }
  return (dsPtr->string);
}
}
char *ns_strcopy(char const   *old ) ;
int Ns_ModuleLoad(char *server , char *module , char *file___1 , char *init ) ;
void *Ns_ModuleSymbol(char *file___1 , char *name ) ;
void *Ns_ModuleGetSymbol(char *name ) ;
void Ns_RegisterModule(char *name , Ns_ModuleInitProc *proc ) ;
char *Ns_HomePath(Tcl_DString *dest  , ...) ;
int Ns_TclInitModule(char *server , char *module ) ;
void NsLoadModules(char *server ) ;
extern void *dlopen(char const   *__file , int __mode ) ;
extern void *dlsym(void * __restrict  __handle , char const   * __restrict  __name ) ;
extern char *dlerror(void) ;
static Tcl_HashTable modulesTable  ;
static void *DlOpen(char *file___1 ) ;
static void *DlSym(void *handle , char *name ) ;
static void *DlSym2(void *handle , char *name ) ;
static char *DlError(void) ;
static Module *firstPtr  ;
void NsInitModLoad(void) 
{ 

  {
  Tcl_InitHashTable(& modulesTable, (int )(sizeof(FileKey ) / sizeof(int )));
  return;
}
}
void Ns_RegisterModule(char *name , Ns_ModuleInitProc *proc ) 
{ Module *modPtr ;
  Module **nextPtrPtr ;

  {
  modPtr = (Module *)ns_malloc(sizeof(Module ));
  modPtr->name = ns_strcopy((char const   *)name);
  modPtr->proc = proc;
  modPtr->nextPtr = (struct Module *)((void *)0);
  nextPtrPtr = & firstPtr;
  while ((unsigned int )(*nextPtrPtr) != (unsigned int )((void *)0)) {
    nextPtrPtr = & ((*nextPtrPtr))->nextPtr;
  }
  (*nextPtrPtr) = modPtr;
  return;
}
}
int Ns_ModuleLoad(char *server , char *module , char *file___1 , char *init ) 
{ Ns_ModuleInitProc *initProc ;
  int status ;
  int *verPtr ;

  {
  status = 0;
  initProc = (Ns_ModuleInitProc *)Ns_ModuleSymbol(file___1, init);
  if ((unsigned int )initProc == (unsigned int )((void *)0)) {
    return (-1);
  }
  verPtr = (int *)Ns_ModuleSymbol(file___1, (char *)"Ns_ModuleVersion");
  status = ((*initProc))(server, module);
  if ((unsigned int )verPtr == (unsigned int )((void *)0)) {
    status = 0;
  } else {
    if ((*verPtr) < 1) {
      status = 0;
    } else {
      if (status != 0) {
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"modload: init %s of %s returned: %d",
               file___1, init, status);
      }
    }
  }
  return (status);
}
}
void *Ns_ModuleSymbol(char *file___1 , char *name ) 
{ Tcl_HashEntry *hPtr ;
  Tcl_DString ds ;
  int new ;
  void *module ;
  void *symbol ;
  struct stat st ;
  FileKey key___1 ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  symbol = (void *)0;
  Tcl_DStringInit(& ds);
  tmp = Ns_PathIsAbsolute(file___1);
  if (! tmp) {
    file___1 = Ns_HomePath(& ds, "bin", file___1, (void *)0);
  }
  tmp___2 = stat__extinline((char const   *)file___1, & st);
  if (tmp___2 != 0) {
    tmp___0 = __errno_location();
    tmp___1 = strerror((*tmp___0));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"modload: stat(%s) failed: %s",
           file___1, tmp___1);
    goto done;
  }
  key___1.dev = st.st_dev;
  key___1.ino = st.st_ino;
  hPtr = ((*(modulesTable.createProc)))(& modulesTable, (char *)(& key___1), & new);
  if (! new) {
    module = hPtr->clientData;
  } else {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"modload: loading \'%s\'",
           file___1);
    module = DlOpen(file___1);
    if ((unsigned int )module == (unsigned int )((void *)0)) {
      tmp___3 = DlError();
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"modload: could not load %s: %s",
             file___1, tmp___3);
      Tcl_DeleteHashEntry(hPtr);
      goto done;
    }
    hPtr->clientData = module;
  }
  symbol = DlSym(module, name);
  if ((unsigned int )symbol == (unsigned int )((void *)0)) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"modload: could not find %s in %s",
           name, file___1);
  }
  done: 
  Tcl_DStringFree(& ds);
  return (symbol);
}
}
void *Ns_ModuleGetSymbol(char *name ) 
{ void *tmp ;

  {
  tmp = DlSym((void *)0, name);
  return (tmp);
}
}
void NsLoadModules(char *server ) 
{ Ns_Set *modules ;
  int i ;
  char *file___1 ;
  char *module ;
  char *init ;
  char *s ;
  char *e___1 ;
  Module *modPtr ;
  Module *nextPtr ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  init = (char *)((void *)0);
  e___1 = (char *)((void *)0);
  tmp = Ns_ConfigGetPath(server, (char *)((void *)0), "modules", (void *)0);
  modules = Ns_ConfigGetSection(tmp);
  i = 0;
  while (1) {
    if ((unsigned int )modules != (unsigned int )((void *)0)) {
      if (! (i < modules->size)) {
        break;
      }
    } else {
      break;
    }
    module = (modules->fields + i)->name;
    file___1 = (modules->fields + i)->value;
    tmp___1 = strchr((char const   *)file___1, '(');
    s = tmp___1;
    if ((unsigned int )s == (unsigned int )((void *)0)) {
      init = (char *)"Ns_ModuleInit";
    } else {
      (*s) = (char )'\000';
      init = s + 1;
      tmp___3 = strchr((char const   *)init, ')');
      e___1 = tmp___3;
      if ((unsigned int )e___1 != (unsigned int )((void *)0)) {
        (*e___1) = (char )'\000';
      }
    }
    tmp___4 = strcasecmp((char const   *)file___1, "tcl");
    if (! (tmp___4 == 0)) {
      tmp___5 = Ns_ModuleLoad(server, module, file___1, init);
      if (tmp___5 != 0) {
        Ns_Fatal((char *)"modload: failed to load module \'%s\'", file___1);
      }
    }
    Ns_TclInitModule(server, module);
    if ((unsigned int )s != (unsigned int )((void *)0)) {
      (*s) = (char )'(';
      if ((unsigned int )e___1 != (unsigned int )((void *)0)) {
        (*e___1) = (char )')';
      }
    }
    i ++;
  }
  while ((unsigned int )firstPtr != (unsigned int )((void *)0)) {
    modPtr = firstPtr;
    firstPtr = (Module *)((void *)0);
    while ((unsigned int )modPtr != (unsigned int )((void *)0)) {
      nextPtr = modPtr->nextPtr;
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"modload: initializing module \'%s\'",
             modPtr->name);
      tmp___6 = ((*(modPtr->proc)))(server, modPtr->name);
      if (tmp___6 != 0) {
        Ns_Fatal((char *)"modload: failed to initialize %s", modPtr->name);
      }
      ns_free((void *)modPtr->name);
      ns_free((void *)modPtr);
      modPtr = nextPtr;
    }
  }
  return;
}
}
static void *DlOpen(char *file___1 ) 
{ void *tmp ;

  {
  tmp = dlopen((char const   *)file___1, 258);
  return (tmp);
}
}
static void *DlSym(void *handle , char *name ) 
{ Tcl_DString ds ;
  void *symbol ;

  {
  symbol = DlSym2(handle, name);
  if ((unsigned int )symbol == (unsigned int )((void *)0)) {
    Tcl_DStringInit(& ds);
    Ns_DStringVarAppend(& ds, "_", name, (void *)0);
    symbol = DlSym2(handle, ds.string);
    Tcl_DStringFree(& ds);
  }
  return (symbol);
}
}
static void *DlSym2(void *handle , char *name ) 
{ void *symbol ;

  {
  symbol = (void *)0;
  symbol = dlsym((void * __restrict  )handle, (char const   * __restrict  )name);
  return (symbol);
}
}
static char *DlError(void) 
{ char *tmp ;

  {
  tmp = dlerror();
  return (tmp);
}
}
extern char *getcwd(char *__buf , size_t __size ) ;
extern __pid_t getpid(void) ;
extern int gethostname(char *__name , size_t __len ) ;
long Ns_ThreadStackSize(long size ) ;
void NsUpdateUrlEncode(void) ;
void NsConfUpdate(void) ;
static int GetInt(char *key___1 , int def ) ;
static int GetBool(char *key___1 , int def ) ;
static char cwd[4096]  ;
char *nsBuildDate ;
void NsInitConf(void) 
{ 

  {
  Ns_ThreadSetName((char *)"-main-");
  nsconf.state.started = 1;
  Ns_MutexInit(& nsconf.state.lock);
  Ns_MutexSetName(& nsconf.state.lock, (char *)"nsd:conf");
  nsconf.build = nsBuildDate;
  nsconf.name = (char *)"AOLserver";
  nsconf.version = (char *)"4.0.10";
  nsconf.tcl.version = (char *)"8.4";
  time(& nsconf.boot_t);
  nsconf.pid = getpid();
  nsconf.home = getcwd(cwd, sizeof(cwd));
  Tcl_InitHashTable(& nsconf.sections, 0);
  Tcl_DStringInit(& nsconf.servers);
  Tcl_InitHashTable(& nsconf.servertable, 0);
  return;
}
}
void NsInitInfo(void) 
{ Tcl_DString addr ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = gethostname(nsconf.hostname, sizeof(nsconf.hostname));
  if (tmp != 0) {
    strcpy((char * __restrict  )(nsconf.hostname), (char const   * __restrict  )"localhost");
  }
  Tcl_DStringInit(& addr);
  tmp___0 = Ns_GetAddrByHost(& addr, nsconf.hostname);
  if (tmp___0) {
    strcpy((char * __restrict  )(nsconf.address), (char const   * __restrict  )addr.string);
  } else {
    strcpy((char * __restrict  )(nsconf.address), (char const   * __restrict  )"0.0.0.0");
  }
  Tcl_DStringFree(& addr);
  return;
}
}
void NsConfUpdate(void) 
{ int i ;
  Tcl_DString ds ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int max ;
  int tmp___7 ;
  int tmp___8 ;

  {
  NsUpdateEncodings();
  NsUpdateMimeTypes();
  NsUpdateUrlEncode();
  Tcl_DStringInit(& ds);
  tmp = Ns_ConfigGetInt((char *)"ns/threads", (char *)"stacksize", & i);
  if (! tmp) {
    i = GetInt((char *)"stacksize", 65536);
  }
  Ns_ThreadStackSize((long )i);
  tmp___0 = GetBool((char *)"logusec", 0);
  if (tmp___0) {
    nsconf.log.flags = nsconf.log.flags | 32;
  }
  tmp___1 = GetBool((char *)"logroll", 1);
  if (tmp___1) {
    nsconf.log.flags = nsconf.log.flags | 1;
  }
  tmp___2 = GetBool((char *)"logexpanded", 0);
  if (tmp___2) {
    nsconf.log.flags = nsconf.log.flags | 2;
  }
  tmp___3 = GetBool((char *)"debug", 0);
  if (tmp___3) {
    nsconf.log.flags = nsconf.log.flags | 4;
  }
  tmp___4 = GetBool((char *)"logdev", 0);
  if (tmp___4) {
    nsconf.log.flags = nsconf.log.flags | 8;
  }
  tmp___5 = GetBool((char *)"lognotice", 1);
  if (! tmp___5) {
    nsconf.log.flags = nsconf.log.flags | 16;
  }
  nsconf.log.maxback = GetInt((char *)"logmaxbackup", 10);
  nsconf.log.maxlevel = GetInt((char *)"logmaxlevel", 2147483647);
  nsconf.log.maxbuffer = GetInt((char *)"logmaxbuffer", 10);
  nsconf.log.flushint = GetInt((char *)"logflushinterval", 10);
  nsconf.log.file = Ns_ConfigGetValue((char *)"ns/parameters", (char *)"serverlog");
  if ((unsigned int )nsconf.log.file == (unsigned int )((void *)0)) {
    nsconf.log.file = (char *)"server.log";
  }
  tmp___6 = Ns_PathIsAbsolute(nsconf.log.file);
  if (tmp___6 == 0) {
    Ns_HomePath(& ds, "log", nsconf.log.file, (void *)0);
    nsconf.log.file = Ns_DStringExport(& ds);
  }
  nsconf.shutdowntimeout = GetInt((char *)"shutdowntimeout", 20);
  nsconf.sched.maxelapsed = GetInt((char *)"schedmaxelapsed", 2);
  nsconf.backlog = GetInt((char *)"listenbacklog", 32);
  tmp___8 = GetBool((char *)"dnscache", 1);
  if (tmp___8) {
    tmp___7 = GetInt((char *)"dnscachemaxentries", 100);
    max = tmp___7;
    i = GetInt((char *)"dnscachetimeout", 60);
    if (max > 0) {
      if (i > 0) {
        i *= 60;
        NsEnableDNSCache(i, max);
      }
    }
  }
  nsconf.keepalive.timeout = GetInt((char *)"keepalivetimeout", 30);
  if (nsconf.keepalive.timeout > 0) {
    nsconf.keepalive.enabled = 1;
  }
  nsconf.keepalive.maxkeep = GetInt((char *)"maxkeepalive", 100);
  nsconf.keepalive.allmethods = GetBool((char *)"keepaliveallmethods", 0);
  Ns_HomePath(& ds, "modules", "tcl", (void *)0);
  nsconf.tcl.sharedlibrary = Ns_DStringExport(& ds);
  nsconf.tcl.lockoninit = GetBool((char *)"tclinitlock", 0);
  Tcl_DStringFree(& ds);
  return;
}
}
static int GetInt(char *key___1 , int def ) 
{ int i ;
  int tmp ;

  {
  tmp = Ns_ConfigGetInt((char *)"ns/parameters", key___1, & i);
  if (tmp) {
    if (i < 0) {
      i = def;
    }
  } else {
    i = def;
  }
  return (i);
}
}
static int GetBool(char *key___1 , int def ) 
{ int i ;
  int tmp ;

  {
  tmp = Ns_ConfigGetBool((char *)"ns/parameters", key___1, & i);
  if (! tmp) {
    i = def;
  }
  return (i);
}
}
extern __pid_t setsid(void) ;
extern __uid_t getuid(void) ;
extern __uid_t geteuid(void) ;
extern __gid_t getgid(void) ;
extern __gid_t getegid(void) ;
extern int setuid(__uid_t __uid ) ;
extern int setgid(__gid_t __gid ) ;
extern char *optarg ;
extern int optind ;
extern int opterr ;
extern int optopt ;
extern int getopt(int ___argc , char * const  *___argv , char const   *__shortopts ) ;
extern int chroot(char const   *__path ) ;
extern struct _IO_FILE *stderr ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern void Tcl_FindExecutable(char *argv0 ) ;
extern char *Tcl_GetNameOfExecutable(void) ;
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
int Ns_WaitForStartup(void) ;
int Ns_GetGid(char *group ) ;
int Ns_GetUserGid(char *user ) ;
int Ns_GetUid(char *user ) ;
extern int getrlimit(__rlimit_resource_t __resource , struct rlimit *__rlimits ) ;
extern int setrlimit(__rlimit_resource_t __resource , struct rlimit  const  *__rlimits ) ;
extern int setgroups(size_t __n , __gid_t const   *__groups ) ;
extern int initgroups(char const   *__user , __gid_t __group ) ;
extern int prctl(int __option  , ...) ;
void NsCreatePidFile(char *procname ) ;
void NsRemovePidFile(char *procname ) ;
void NsStartServers(void) ;
void NsBlockSignals(int debug ) ;
void NsHandleSignals(void) ;
void NsInitServer(char *server , Ns_ServerInitProc *initProc ) ;
void NsStopServers(Ns_Time *toPtr ) ;
void NsStartSchedShutdown(void) ;
void NsWaitSchedShutdown(Ns_Time *toPtr ) ;
void NsStartSockShutdown(void) ;
void NsWaitSockShutdown(Ns_Time *toPtr ) ;
void NsStartJobsShutdown(void) ;
void NsWaitJobsShutdown(Ns_Time *toPtr ) ;
void NsSendSignal(int sig ) ;
static void UsageError(char *msg ) ;
static void StatusMsg(int state ) ;
static char *FindConfig(char *config ) ;
int Ns_Main(int argc , char **argv , Ns_ServerInitProc *initProc ) 
{ int i ;
  int fd ;
  char *config ;
  Ns_Time timeout ;
  char buf[4096] ;
  uid_t uid___1 ;
  gid_t gid ;
  int debug ;
  int mode ;
  char *root ;
  char *garg ;
  char *uarg ;
  char *bindargs ;
  char *bindfile ;
  char *procname ;
  char *server ;
  Ns_Set *servers ;
  struct rlimit rl ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  __gid_t tmp___23 ;
  int tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  __uid_t tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;

  {
  uid___1 = 0U;
  gid = 0U;
  debug = 0;
  mode = 0;
  root = (char *)((void *)0);
  garg = (char *)((void *)0);
  uarg = (char *)((void *)0);
  bindargs = (char *)((void *)0);
  bindfile = (char *)((void *)0);
  procname = (char *)((void *)0);
  server = (char *)((void *)0);
  Ns_MutexLock(& nsconf.state.lock);
  nsconf.state.started = 0;
  Ns_MutexUnlock(& nsconf.state.lock);
  nsconf.argv0 = (*(argv + 0));
  fd = open("/dev/null", 0);
  if (fd > 0) {
    dup2(fd, 0);
    close(fd);
  }
  fd = open("/dev/null", 1);
  if (fd > 0) {
    if (fd != 1) {
      close(fd);
    }
  }
  fd = open("/dev/null", 1);
  if (fd > 0) {
    if (fd != 2) {
      close(fd);
    }
  }
  opterr = 0;
  while (1) {
    i = getopt(argc, (char * const  *)argv, "hpzifVs:t:IRSkKdr:u:g:b:B:");
    if (! (i != -1)) {
      break;
    }
    switch (i) {
    case 104: 
    UsageError((char *)((void *)0));
    break;
    case 102: ;
    case 105: ;
    case 86: ;
    if (mode != 0) {
      UsageError((char *)"only one of -i, -f, or -V may be specified");
    }
    mode = i;
    break;
    case 115: ;
    if ((unsigned int )server != (unsigned int )((void *)0)) {
      UsageError((char *)"multiple -s <server> options");
    }
    server = optarg;
    break;
    case 116: ;
    if ((unsigned int )nsconf.config != (unsigned int )((void *)0)) {
      UsageError((char *)"multiple -t <file> options");
    }
    nsconf.config = optarg;
    break;
    case 112: ;
    case 122: ;
    break;
    case 98: 
    bindargs = optarg;
    break;
    case 66: 
    bindfile = optarg;
    break;
    case 114: 
    root = optarg;
    break;
    break;
    case 100: 
    debug = 1;
    break;
    case 103: 
    garg = optarg;
    break;
    case 117: 
    uarg = optarg;
    break;
    case 58: 
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"option -%c requires a parameter",
            optopt);
    UsageError(buf);
    break;
    default: 
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"invalid option: -%c",
            optopt);
    UsageError(buf);
    break;
    }
  }
  if (mode == 86) {
    tmp = Ns_InfoLabel();
    printf((char const   * __restrict  )"AOLserver/%s (%s)\n", "4.0.10", tmp);
    tmp___0 = Ns_InfoTag();
    printf((char const   * __restrict  )"   CVS Tag:         %s\n", tmp___0);
    tmp___1 = Ns_InfoBuildDate();
    printf((char const   * __restrict  )"   Built:           %s\n", tmp___1);
    printf((char const   * __restrict  )"   Tcl version:     %s\n", nsconf.tcl.version);
    tmp___2 = Ns_InfoPlatform();
    printf((char const   * __restrict  )"   Platform:        %s\n", tmp___2);
    return (0);
  } else {
    if ((unsigned int )nsconf.config == (unsigned int )((void *)0)) {
      UsageError((char *)"required -t <config> option not specified");
    }
  }
  nsconf.config = FindConfig(nsconf.config);
  config = NsConfigRead(nsconf.config);
  if ((unsigned int )uarg != (unsigned int )((void *)0)) {
    uid___1 = (uid_t )Ns_GetUid(uarg);
    gid = (gid_t )Ns_GetUserGid(uarg);
    if (uid___1 < 0U) {
      uid___1 = (uid_t )atoi__extinline((char const   *)uarg);
      uarg = (char *)((void *)0);
    }
    if (uid___1 == 0U) {
      Ns_Fatal((char *)"nsmain: invalid user \'%s\'", uarg);
    }
  }
  if ((unsigned int )garg != (unsigned int )((void *)0)) {
    gid = (gid_t )Ns_GetGid(garg);
    if (gid < 0U) {
      gid = (gid_t )atoi__extinline((char const   *)garg);
      if (gid == 0U) {
        Ns_Fatal((char *)"nsmain: invalid group \'%s\'", garg);
      }
    }
  }
  tmp___8 = getrlimit((enum __rlimit_resource )7, & rl);
  if (tmp___8 != 0) {
    tmp___3 = __errno_location();
    tmp___4 = strerror((*tmp___3));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"nsmain: getrlimit(RLIMIT_NOFILE) failed: \'%s\'",
           tmp___4);
  } else {
    if (rl.rlim_cur != rl.rlim_max) {
      rl.rlim_cur = rl.rlim_max;
      tmp___7 = setrlimit((enum __rlimit_resource )7, (struct rlimit  const  *)(& rl));
      if (tmp___7 != 0) {
        tmp___5 = __errno_location();
        tmp___6 = strerror((*tmp___5));
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"nsmain: setrlimit(RLIMIT_NOFILE, %d) failed: \'%s\'",
               rl.rlim_max, tmp___6);
      }
    }
  }
  NsPreBind(bindargs, bindfile);
  if ((unsigned int )root != (unsigned int )((void *)0)) {
    tmp___11 = chroot((char const   *)root);
    if (tmp___11 != 0) {
      tmp___9 = __errno_location();
      tmp___10 = strerror((*tmp___9));
      Ns_Fatal((char *)"nsmain: chroot(%s) failed: \'%s\'", root, tmp___10);
    }
    tmp___14 = chdir("/");
    if (tmp___14 != 0) {
      tmp___12 = __errno_location();
      tmp___13 = strerror((*tmp___12));
      Ns_Fatal((char *)"nsmain: chdir(/) failed: \'%s\'", tmp___13);
    }
    nsconf.home = (char *)"/";
  }
  tmp___28 = getuid();
  if (tmp___28 == 0U) {
    if (uid___1 == 0U) {
      Ns_Fatal((char *)"nsmain: server will not run as root; must specify \'-u username\' parameter");
    }
    if (gid == 0U) {
      Ns_Fatal((char *)"nsmain: server will not run as gid 0; must specify \'-g group\' parameter");
    }
    if ((unsigned int )uarg != (unsigned int )((void *)0)) {
      tmp___17 = initgroups((char const   *)uarg, gid);
      if (tmp___17 != 0) {
        tmp___15 = __errno_location();
        tmp___16 = strerror((*tmp___15));
        Ns_Fatal((char *)"nsmain: initgroups(%s, %d) failed: \'%s\'", uarg, gid, tmp___16);
      }
    } else {
      tmp___20 = setgroups(0U, (__gid_t const   *)((void *)0));
      if (tmp___20 != 0) {
        tmp___18 = __errno_location();
        tmp___19 = strerror((*tmp___18));
        Ns_Fatal((char *)"nsmain: setgroups(0, NULL) failed: \'%s\'", tmp___19);
      }
    }
    tmp___23 = getgid();
    if (gid != tmp___23) {
      tmp___24 = setgid(gid);
      if (tmp___24 != 0) {
        tmp___21 = __errno_location();
        tmp___22 = strerror((*tmp___21));
        Ns_Fatal((char *)"nsmain: setgid(%d) failed: \'%s\'", gid, tmp___22);
      }
    }
    tmp___27 = setuid(uid___1);
    if (tmp___27 != 0) {
      tmp___25 = __errno_location();
      tmp___26 = strerror((*tmp___25));
      Ns_Fatal((char *)"nsmain: setuid(%d) failed: \'%s\'", uid___1, tmp___26);
    }
  }
  tmp___31 = prctl(4, 1, 0, 0, 0);
  if (tmp___31 < 0) {
    tmp___29 = __errno_location();
    tmp___30 = strerror((*tmp___29));
    Ns_Fatal((char *)"nsmain: prctl(PR_SET_DUMPABLE) failed: \'%s\'", tmp___30);
  }
  if (mode == 0) {
    i = ns_fork();
    if (i < 0) {
      tmp___32 = __errno_location();
      tmp___33 = strerror((*tmp___32));
      Ns_Fatal((char *)"nsmain: fork() failed: \'%s\'", tmp___33);
    }
    if (i > 0) {
      return (0);
    }
    nsconf.pid = getpid();
    setsid();
  }
  NsBlockSignals(debug);
  Tcl_FindExecutable((*(argv + 0)));
  tmp___34 = Tcl_GetNameOfExecutable();
  nsconf.nsd = tmp___34;
  NsConfigEval(config, argc, argv, optind);
  ns_free((void *)config);
  servers = Ns_ConfigGetSection((char *)"ns/servers");
  if ((unsigned int )servers == (unsigned int )((void *)0)) {
    Ns_Fatal((char *)"nsmain: no servers defined");
  } else {
    if (servers->size == 0) {
      Ns_Fatal((char *)"nsmain: no servers defined");
    }
  }
  if ((unsigned int )server != (unsigned int )((void *)0)) {
    i = Ns_SetFind(servers, server);
    if (i < 0) {
      Ns_Fatal((char *)"nsmain: no such server \'%s\'", server);
    }
    server = (servers->fields + i)->name;
  }
  if (server) {
    procname = server;
  } else {
    procname = (servers->fields + 0)->name;
  }
  nsconf.home = Ns_ConfigGetValue((char *)"ns/parameters", (char *)"home");
  if ((unsigned int )nsconf.home == (unsigned int )((void *)0)) {
    Ns_Fatal((char *)"nsmain: missing: [%s]home", "ns/parameters");
  }
  tmp___37 = chdir((char const   *)nsconf.home);
  if (tmp___37 != 0) {
    tmp___35 = __errno_location();
    tmp___36 = strerror((*tmp___35));
    Ns_Fatal((char *)"nsmain: chdir(%s) failed: \'%s\'", nsconf.home, tmp___36);
  }
  NsConfUpdate();
  if (mode != 102) {
    NsLogOpen();
  }
  StatusMsg(0);
  tmp___40 = getrlimit((enum __rlimit_resource )7, & rl);
  if (tmp___40 != 0) {
    tmp___38 = __errno_location();
    tmp___39 = strerror((*tmp___38));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"nsmain: getrlimit(RLIMIT_NOFILE) failed: \'%s\'",
           tmp___39);
  } else {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"nsmain: max files: FD_SETSIZE = %d, rl_cur = %d, rl_max = %d",
           1024, rl.rlim_cur, rl.rlim_max);
    if (rl.rlim_max > 1024UL) {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"nsmain: rl_max > FD_SETSIZE");
    }
  }
  NsCreatePidFile(procname);
  if ((unsigned int )server != (unsigned int )((void *)0)) {
    NsInitServer(server, initProc);
  } else {
    i = 0;
    while (i < servers->size) {
      server = (servers->fields + i)->name;
      NsInitServer(server, initProc);
      i ++;
    }
  }
  NsLoadModules((char *)((void *)0));
  NsRunPreStartupProcs();
  NsStartServers();
  StatusMsg(1);
  Ns_MutexLock(& nsconf.state.lock);
  nsconf.state.started = 1;
  Ns_CondBroadcast(& nsconf.state.cond);
  Ns_MutexUnlock(& nsconf.state.lock);
  NsRunStartupProcs();
  NsStartDrivers();
  NsClosePreBound();
  NsHandleSignals();
  StatusMsg(2);
  Ns_MutexLock(& nsconf.state.lock);
  nsconf.state.stopping = 1;
  if (nsconf.shutdowntimeout < 0) {
    nsconf.shutdowntimeout = 0;
  }
  Ns_GetTime(& timeout);
  Ns_IncrTime(& timeout, (long )nsconf.shutdowntimeout, 0L);
  Ns_MutexUnlock(& nsconf.state.lock);
  NsStopDrivers();
  NsStopServers(& timeout);
  NsWaitDriversShutdown(& timeout);
  NsStartSchedShutdown();
  NsStartSockShutdown();
  NsStartJobsShutdown();
  NsStartShutdownProcs();
  NsWaitSchedShutdown(& timeout);
  NsWaitSockShutdown(& timeout);
  NsWaitJobsShutdown(& timeout);
  NsWaitShutdownProcs(& timeout);
  NsRunAtExitProcs();
  NsRemovePidFile(procname);
  StatusMsg(3);
  return (0);
}
}
int Ns_WaitForStartup(void) 
{ 

  {
  if (nsconf.state.started) {
    return (0);
  }
  Ns_MutexLock(& nsconf.state.lock);
  while (! nsconf.state.started) {
    Ns_CondWait(& nsconf.state.cond, & nsconf.state.lock);
  }
  Ns_MutexUnlock(& nsconf.state.lock);
  return (0);
}
}
void Ns_StopServer(char *server ) 
{ 

  {
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"nsmain: immediate server shutdown requested");
  NsSendSignal(15);
  return;
}
}
int NsTclShutdownObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int timeout ;
  int tmp ;
  Tcl_Obj *tmp___0 ;

  {
  if (objc != 1) {
    if (objc != 2) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?timeout?");
      return (1);
    }
  }
  if (objc == 1) {
    timeout = nsconf.shutdowntimeout;
  } else {
    tmp = Tcl_GetIntFromObj(interp, (*(objv + 1)), & timeout);
    if (tmp != 0) {
      return (1);
    }
  }
  tmp___0 = Tcl_GetObjResult(interp);
  Tcl_SetIntObj(tmp___0, timeout);
  Ns_MutexLock(& nsconf.state.lock);
  nsconf.shutdowntimeout = timeout;
  Ns_MutexUnlock(& nsconf.state.lock);
  NsSendSignal(15);
  return (0);
}
}
static void StatusMsg(int state ) 
{ char *what ;
  char *tmp ;
  char *tmp___0 ;
  __gid_t tmp___1 ;
  __gid_t tmp___2 ;
  __uid_t tmp___3 ;
  __uid_t tmp___4 ;

  {
  switch (state) {
  case 0: 
  what = (char *)"starting";
  break;
  case 1: 
  what = (char *)"running";
  break;
  case 2: 
  what = (char *)"stopping";
  break;
  case 3: 
  what = (char *)"exiting";
  break;
  default: 
  what = (char *)"unknown";
  break;
  }
  tmp = Ns_InfoServerVersion();
  tmp___0 = Ns_InfoServerName();
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"nsmain: %s/%s %s", tmp___0,
         tmp, what);
  if (state < 2) {
    tmp___1 = getegid();
    tmp___2 = getgid();
    tmp___3 = geteuid();
    tmp___4 = getuid();
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"nsmain: security info: uid=%d, euid=%d, gid=%d, egid=%d",
           tmp___4, tmp___3, tmp___2, tmp___1);
  }
  return;
}
}
static void UsageError(char *msg ) 
{ int tmp ;

  {
  if ((unsigned int )msg != (unsigned int )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nError: %s\n",
            msg);
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nUsage: %s [-h|V] [-i|f] [-u <user>] [-g <group>] [-r <path>] [-b <address:port>|-B <file>] [-s <server>] -t <file>\n\n  -h  help (this message)\n  -V  version and release information\n  -i  inittab mode\n  -f  foreground mode\n  -d  debugger-friendly mode (ignore SIGINT)\n  -u  run as <user>\n  -g  run as <group>\n  -r  chroot to <path>\n  -b  bind <address:port>\n  -B  bind address:port list from <file>\n  -s  use server named <server> in config file\n  -t  read config from <file> (REQUIRED)\n\n",
          nsconf.argv0);
  if (msg) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  exit(tmp);
}
}
static char *FindConfig(char *config ) 
{ Tcl_DString ds1 ;
  Tcl_DString ds2 ;
  char cwd___1[4096] ;
  int tmp ;
  char *tmp___0 ;

  {
  Tcl_DStringInit(& ds1);
  Tcl_DStringInit(& ds2);
  tmp = Ns_PathIsAbsolute(config);
  if (! tmp) {
    tmp___0 = getcwd(cwd___1, sizeof(cwd___1));
    if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
      Ns_MakePath(& ds2, cwd___1, config, (void *)0);
      config = ds2.string;
    }
  }
  Ns_NormalizePath(& ds1, config);
  config = Ns_DStringExport(& ds1);
  Tcl_DStringFree(& ds2);
  return (config);
}
}
void Ns_SetThreadServer(char *server ) ;
char *Ns_GetThreadServer(void) ;
void Ns_SetThreadServer(char *server ) 
{ 

  {
  Ns_ThreadSetName(server);
  return;
}
}
char *Ns_GetThreadServer(void) 
{ char *tmp ;

  {
  tmp = Ns_ThreadGetName();
  return (tmp);
}
}
void Ns_RegisterRequest(char *server , char *method , char *url , Ns_OpProc *proc ,
                        Ns_Callback *delete , void *arg , int flags ) ;
void Ns_GetRequest(char *server , char *method , char *url , Ns_OpProc **procPtr ,
                   Ns_Callback **deletePtr , void **argPtr , int *flagsPtr ) ;
void Ns_UnRegisterRequest(char *server , char *method , char *url , int inherit ) ;
int Ns_ConnRunRequest(Ns_Conn *conn ) ;
void Ns_SetRequestUrl(Ns_Request *request , char *url ) ;
int Ns_ConnReturnBadRequest(Ns_Conn *conn , char *reason ) ;
int Ns_ConnReturnUnauthorized(Ns_Conn *conn ) ;
int Ns_ConnReturnForbidden(Ns_Conn *conn ) ;
int Ns_ConnReturnInternalError(Ns_Conn *conn ) ;
int Ns_UrlSpecificAlloc(void) ;
void Ns_UrlSpecificSet(char *server , char *method , char *url , int id , void *data ,
                       int flags , void (*deletefunc)(void * ) ) ;
void *Ns_UrlSpecificGet(char *server , char *method , char *url , int id ) ;
void *Ns_UrlSpecificDestroy(char *server , char *method , char *url , int id , int flags ) ;
int NsConnRunProxyRequest(Ns_Conn *conn ) ;
static void FreeReq(void *arg ) ;
static Ns_Mutex ulock  ;
static int uid  ;
void NsInitRequests(void) 
{ 

  {
  uid = Ns_UrlSpecificAlloc();
  Ns_MutexInit(& ulock);
  Ns_MutexSetName(& ulock, (char *)"nsd:requests");
  return;
}
}
void Ns_RegisterRequest(char *server , char *method , char *url , Ns_OpProc *proc ,
                        Ns_Callback *delete , void *arg , int flags ) 
{ Req *reqPtr ;

  {
  reqPtr = (Req *)ns_malloc(sizeof(Req ));
  reqPtr->proc = proc;
  reqPtr->delete = delete;
  reqPtr->arg = arg;
  reqPtr->flags = (unsigned int )flags;
  reqPtr->refcnt = 1;
  Ns_MutexLock(& ulock);
  Ns_UrlSpecificSet(server, method, url, uid, (void *)reqPtr, flags, & FreeReq);
  Ns_MutexUnlock(& ulock);
  return;
}
}
void Ns_GetRequest(char *server , char *method , char *url , Ns_OpProc **procPtr ,
                   Ns_Callback **deletePtr , void **argPtr , int *flagsPtr ) 
{ Req *reqPtr ;

  {
  Ns_MutexLock(& ulock);
  reqPtr = (Req *)Ns_UrlSpecificGet(server, method, url, uid);
  if ((unsigned int )reqPtr != (unsigned int )((void *)0)) {
    (*procPtr) = reqPtr->proc;
    (*deletePtr) = reqPtr->delete;
    (*argPtr) = reqPtr->arg;
    (*flagsPtr) = (int )reqPtr->flags;
  } else {
    (*procPtr) = (Ns_OpProc *)((void *)0);
    (*deletePtr) = (Ns_Callback *)((void *)0);
    (*argPtr) = (void *)0;
    (*flagsPtr) = 0;
  }
  Ns_MutexUnlock(& ulock);
  return;
}
}
void Ns_UnRegisterRequest(char *server , char *method , char *url , int inherit ) 
{ int tmp ;

  {
  Ns_MutexLock(& ulock);
  if (inherit) {
    tmp = 0;
  } else {
    tmp = 2;
  }
  Ns_UrlSpecificDestroy(server, method, url, uid, tmp);
  Ns_MutexUnlock(& ulock);
  return;
}
}
int Ns_ConnRunRequest(Ns_Conn *conn ) 
{ Req *reqPtr ;
  int status ;
  char *server ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  tmp = Ns_ConnServer(conn);
  server = tmp;
  Ns_MutexLock(& ulock);
  reqPtr = (Req *)Ns_UrlSpecificGet(server, (conn->request)->method, (conn->request)->url,
                                    uid);
  if ((unsigned int )reqPtr == (unsigned int )((void *)0)) {
    Ns_MutexUnlock(& ulock);
    if ((int )(*((conn->request)->method)) == (int )(*"BAD")) {
      if (0) {
        __s1_len = strlen((char const   *)(conn->request)->method);
        __s2_len = strlen("BAD");
        if (! ((unsigned int )((void const   *)((conn->request)->method + 1)) - (unsigned int )((void const   *)(conn->request)->method) ==
               1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("BAD" + 1)) - (unsigned int )((void const   *)"BAD") ==
                   1U)) {
              tmp___9 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___9 = 1;
              } else {
                tmp___9 = 0;
              }
            }
          } else {
            tmp___9 = 0;
          }
        }
        if (tmp___9) {
          if (__s1_len < __s2_len) {
            tmp___7 = __s1_len;
          } else {
            tmp___7 = __s2_len;
          }
          tmp___6 = memcmp((void const   *)((char const   *)(conn->request)->method),
                           (void const   *)"BAD", tmp___7 + 1U);
        } else {
          tmp___8 = strcmp((char const   *)(conn->request)->method, "BAD");
          tmp___6 = tmp___8;
        }
      } else {
        tmp___8 = strcmp((char const   *)(conn->request)->method, "BAD");
        tmp___6 = tmp___8;
      }
      if (tmp___6 == 0) {
        tmp___0 = Ns_ConnReturnBadRequest(conn, (char *)((void *)0));
        return (tmp___0);
      } else {
        tmp___1 = Ns_ConnReturnNotFound(conn);
        return (tmp___1);
      }
    } else {
      tmp___1 = Ns_ConnReturnNotFound(conn);
      return (tmp___1);
    }
  }
  reqPtr->refcnt ++;
  Ns_MutexUnlock(& ulock);
  status = ((*(reqPtr->proc)))(reqPtr->arg, conn);
  Ns_MutexLock(& ulock);
  FreeReq((void *)reqPtr);
  Ns_MutexUnlock(& ulock);
  return (status);
}
}
int Ns_ConnRedirect(Ns_Conn *conn , char *url ) 
{ int status ;
  char *tmp ;
  char *tmp___0 ;

  {
  Ns_SetRequestUrl(conn->request, url);
  tmp = Ns_ConnPeer(conn);
  tmp___0 = Ns_ConnServer(conn);
  status = Ns_AuthorizeRequest(tmp___0, (conn->request)->method, (conn->request)->url,
                               conn->authUser, conn->authPasswd, tmp);
  switch (status) {
  case 0: 
  status = Ns_ConnRunRequest(conn);
  break;
  case -3: 
  status = Ns_ConnReturnForbidden(conn);
  break;
  case -2: 
  status = Ns_ConnReturnUnauthorized(conn);
  break;
  case -1: ;
  default: 
  status = Ns_ConnReturnInternalError(conn);
  break;
  }
  return (status);
}
}
void Ns_RegisterProxyRequest(char *server , char *method , char *protocol , Ns_OpProc *proc ,
                             Ns_Callback *delete , void *arg ) 
{ NsServer *servPtr ;
  Req *reqPtr ;
  Tcl_DString ds ;
  int new ;
  Tcl_HashEntry *hPtr ;

  {
  servPtr = NsGetServer(server);
  if ((unsigned int )servPtr == (unsigned int )((void *)0)) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"Ns_RegisterProxyRequest: no such server: %s",
           server);
    return;
  }
  Tcl_DStringInit(& ds);
  Ns_DStringVarAppend(& ds, method, protocol, (void *)0);
  reqPtr = (Req *)ns_malloc(sizeof(Req ));
  reqPtr->refcnt = 1;
  reqPtr->proc = proc;
  reqPtr->delete = delete;
  reqPtr->arg = arg;
  reqPtr->flags = 0U;
  Ns_MutexLock(& servPtr->request.plock);
  hPtr = ((*(servPtr->request.proxy.createProc)))(& servPtr->request.proxy, ds.string,
                                                  & new);
  if (! new) {
    FreeReq(hPtr->clientData);
  }
  hPtr->clientData = (void *)reqPtr;
  Ns_MutexUnlock(& servPtr->request.plock);
  Tcl_DStringFree(& ds);
  return;
}
}
void Ns_UnRegisterProxyRequest(char *server , char *method , char *protocol ) 
{ NsServer *servPtr ;
  Tcl_DString ds ;
  Tcl_HashEntry *hPtr ;

  {
  servPtr = NsGetServer(server);
  if ((unsigned int )servPtr != (unsigned int )((void *)0)) {
    Tcl_DStringInit(& ds);
    Ns_DStringVarAppend(& ds, method, protocol, (void *)0);
    Ns_MutexLock(& servPtr->request.plock);
    hPtr = ((*(servPtr->request.proxy.findProc)))(& servPtr->request.proxy, ds.string);
    if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
      FreeReq(hPtr->clientData);
      Tcl_DeleteHashEntry(hPtr);
    }
    Ns_MutexUnlock(& servPtr->request.plock);
    Tcl_DStringFree(& ds);
  }
  return;
}
}
int NsConnRunProxyRequest(Ns_Conn *conn ) 
{ Conn *connPtr ;
  NsServer *servPtr ;
  Ns_Request *request ;
  Req *reqPtr ;
  int status ;
  Tcl_DString ds ;
  Tcl_HashEntry *hPtr ;

  {
  connPtr = (Conn *)conn;
  servPtr = connPtr->servPtr;
  request = conn->request;
  reqPtr = (Req *)((void *)0);
  Tcl_DStringInit(& ds);
  Ns_DStringVarAppend(& ds, request->method, request->protocol, (void *)0);
  Ns_MutexLock(& servPtr->request.plock);
  hPtr = ((*(servPtr->request.proxy.findProc)))(& servPtr->request.proxy, ds.string);
  if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    reqPtr = (Req *)hPtr->clientData;
    reqPtr->refcnt ++;
  }
  Ns_MutexUnlock(& servPtr->request.plock);
  if ((unsigned int )reqPtr == (unsigned int )((void *)0)) {
    status = Ns_ConnReturnNotFound(conn);
  } else {
    status = ((*(reqPtr->proc)))(reqPtr->arg, conn);
    Ns_MutexLock(& servPtr->request.plock);
    FreeReq((void *)reqPtr);
    Ns_MutexUnlock(& servPtr->request.plock);
  }
  Tcl_DStringFree(& ds);
  return (status);
}
}
static void FreeReq(void *arg ) 
{ Req *reqPtr ;

  {
  reqPtr = (Req *)arg;
  reqPtr->refcnt --;
  if (reqPtr->refcnt == 0) {
    if ((unsigned int )reqPtr->delete != (unsigned int )((void *)0)) {
      ((*(reqPtr->delete)))(reqPtr->arg);
    }
    ns_free((void *)reqPtr);
  }
  return;
}
}
char *Ns_LibPath(Tcl_DString *dest  , ...) ;
char *Ns_ModulePath(Tcl_DString *dest , char *server , char *module  , ...) ;
static char *MakePath(Tcl_DString *dest , va_list *pap ) ;
int Ns_PathIsAbsolute(char *path ) 
{ 

  {
  if ((int )(*path) == 47) {
    return (1);
  } else {
    if ((int )(*path) == 92) {
      return (1);
    }
  }
  return (0);
}
}
char *Ns_NormalizePath(Tcl_DString *dsPtr , char *path ) 
{ char end ;
  register char *src ;
  register char *part ;
  register char *slash ;
  Tcl_DString tmp ;
  char *tmp___0 ;

  {
  Tcl_DStringInit(& tmp);
  src = Tcl_DStringAppend(& tmp, path, -1);
  while (1) {
    if (! ((int )(*src) == 47)) {
      if (! ((int )(*src) == 92)) {
        break;
      }
    }
    src ++;
  }
  while (1) {
    part = src;
    while (1) {
      if ((*src)) {
        if ((int )(*src) == 47) {
          break;
        } else {
          if ((int )(*src) == 92) {
            break;
          }
        }
      } else {
        break;
      }
      src ++;
    }
    end = (*src);
    tmp___0 = src;
    src ++;
    (*tmp___0) = (char )'\000';
    if ((int )(*(part + 0)) == 46) {
      if ((int )(*(part + 1)) == 46) {
        if ((int )(*(part + 2)) == 0) {
          slash = strrchr((char const   *)dsPtr->string, '/');
          if ((unsigned int )slash != (unsigned int )((void *)0)) {
            Tcl_DStringSetLength(dsPtr, slash - dsPtr->string);
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if ((int )(*(part + 0)) != 0) {
        if ((int )(*(part + 0)) != 46) {
          Tcl_DStringAppend(dsPtr, (char *)"/", 1);
          Tcl_DStringAppend(dsPtr, part, -1);
        } else {
          if ((int )(*(part + 1)) != 0) {
            Tcl_DStringAppend(dsPtr, (char *)"/", 1);
            Tcl_DStringAppend(dsPtr, part, -1);
          }
        }
      }
    }
    if (! ((int )end != 0)) {
      break;
    }
  }
  if ((int )(*(dsPtr->string + 0)) == 0) {
    Tcl_DStringAppend(dsPtr, (char *)"/", 1);
  }
  Tcl_DStringFree(& tmp);
  return (dsPtr->string);
}
}
char *Ns_MakePath(Tcl_DString *dest  , ...) 
{ va_list ap ;
  char *path ;

  {
  __builtin_stdarg_start(ap, dest);
  path = MakePath(dest, & ap);
  __builtin_va_end(ap);
  return (path);
}
}
char *Ns_LibPath(Tcl_DString *dest  , ...) 
{ va_list ap ;
  char *path ;
  char *tmp ;

  {
  tmp = Ns_InfoHomePath();
  Ns_MakePath(dest, tmp, "lib", (void *)0);
  __builtin_stdarg_start(ap, dest);
  path = MakePath(dest, & ap);
  __builtin_va_end(ap);
  return (path);
}
}
char *Ns_HomePath(Tcl_DString *dest  , ...) 
{ va_list ap ;
  char *path ;
  char *tmp ;

  {
  tmp = Ns_InfoHomePath();
  Ns_MakePath(dest, tmp, (void *)0);
  __builtin_stdarg_start(ap, dest);
  path = MakePath(dest, & ap);
  __builtin_va_end(ap);
  return (path);
}
}
char *Ns_ModulePath(Tcl_DString *dest , char *server , char *module  , ...) 
{ va_list ap ;
  char *path ;
  char *tmp ;

  {
  tmp = Ns_InfoHomePath();
  Ns_MakePath(dest, tmp, (void *)0);
  if ((unsigned int )server != (unsigned int )((void *)0)) {
    Ns_MakePath(dest, "servers", server, (void *)0);
  }
  if ((unsigned int )module != (unsigned int )((void *)0)) {
    Ns_MakePath(dest, "modules", module, (void *)0);
  }
  __builtin_stdarg_start(ap, module);
  path = MakePath(dest, & ap);
  __builtin_va_end(ap);
  return (path);
}
}
int NsTclModulePathObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Tcl_DString ds ;
  int i ;
  char *module ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  Tcl_DStringInit(& ds);
  if (objc < 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"server ?module ...?");
    return (1);
  }
  if (objc > 2) {
    module = Tcl_GetString((*(objv + 2)));
  } else {
    module = (char *)((void *)0);
  }
  tmp___0 = Tcl_GetString((*(objv + 1)));
  Ns_ModulePath(& ds, tmp___0, module, (void *)0);
  i = 3;
  while (i < objc) {
    tmp___1 = Tcl_GetString((*(objv + i)));
    Ns_MakePath(& ds, tmp___1, (void *)0);
    i ++;
  }
  Tcl_DStringResult(interp, & ds);
  Tcl_DStringFree(& ds);
  return (0);
}
}
static char *MakePath(Tcl_DString *dest , va_list *pap ) 
{ char *s ;
  int len ;
  char temp ;
  unsigned short const   **tmp ;

  {
  while (1) {
    s = __builtin_va_arg((*pap), char *);
    if (! ((unsigned int )s != (unsigned int )((void *)0))) {
      break;
    }
    tmp = __ctype_b_loc();
    if ((int const   )(*((*tmp) + (int )(*s))) & 1024) {
      if ((int )(*(s + 1)) == 58) {
        temp = (*(s + 2));
        (*(s + 2)) = (char)0;
        Tcl_DStringAppend(dest, s, 2);
        (*(s + 2)) = temp;
        s += 2;
      }
    }
    while ((*s)) {
      while (1) {
        if (! ((int )(*s) == 47)) {
          if (! ((int )(*s) == 92)) {
            break;
          }
        }
        s ++;
      }
      if ((*s)) {
        Tcl_DStringAppend(dest, (char *)"/", 1);
        len = 0;
        while (1) {
          if ((int )(*(s + len)) != 0) {
            if ((int )(*(s + len)) == 47) {
              break;
            } else {
              if ((int )(*(s + len)) == 92) {
                break;
              }
            }
          } else {
            break;
          }
          len ++;
        }
        Tcl_DStringAppend(dest, s, len);
        s += len;
      }
    }
  }
  return (dest->string);
}
}
static char *GetFile(char *procname ) ;
void NsCreatePidFile(char *procname ) 
{ int fd ;
  int n ;
  char buf[10] ;
  char *file___1 ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;

  {
  tmp = GetFile(procname);
  file___1 = tmp;
  fd = open((char const   *)file___1, 577, 420);
  if (fd < 0) {
    tmp___0 = __errno_location();
    tmp___1 = strerror((*tmp___0));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"pidfile: failed to open pid file \'%s\': \'%s\'",
           file___1, tmp___1);
  } else {
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d\n", nsconf.pid);
    n = (int )strlen((char const   *)(buf));
    tmp___4 = write(fd, (void const   *)(buf), (unsigned int )n);
    if (tmp___4 != n) {
      tmp___2 = __errno_location();
      tmp___3 = strerror((*tmp___2));
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"pidfile: write() failed: \'%s\'",
             tmp___3);
    }
    close(fd);
  }
  return;
}
}
void NsRemovePidFile(char *procname ) 
{ char *file___1 ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  tmp = GetFile(procname);
  file___1 = tmp;
  tmp___2 = unlink((char const   *)file___1);
  if (tmp___2 != 0) {
    tmp___0 = __errno_location();
    tmp___1 = strerror((*tmp___0));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"pidfile: failed to remove \'%s\': \'%s\'",
           file___1, tmp___1);
  }
  return;
}
}
static char *file  ;
static char *GetFile(char *procname ) 
{ Tcl_DString ds ;

  {
  if ((unsigned int )file == (unsigned int )((void *)0)) {
    file = Ns_ConfigGetValue((char *)"ns/parameters", (char *)"pidfile");
    if ((unsigned int )file == (unsigned int )((void *)0)) {
      Tcl_DStringInit(& ds);
      Ns_HomePath(& ds, "log/nspid.", (void *)0);
      Tcl_DStringAppend(& ds, procname, -1);
      file = Ns_DStringExport(& ds);
    }
  }
  return (file);
}
}
void Ns_RegisterProcInfo(void *procAddr , char *desc , Ns_ArgProc *argProc ) ;
void NsTclCallback(void *arg ) ;
void NsTclSignalProc(void *arg ) ;
void NsTclSchedProc(void *arg , int id ) ;
void NsTclArgProc(Tcl_DString *dsPtr , void *arg ) ;
void NsTclThread(void *arg ) ;
void NsTclThreadArgProc(Tcl_DString *dsPtr , void *arg ) ;
int NsTclSockProc(int sock , void *arg , int why ) ;
void NsTclSockArgProc(Tcl_DString *dsPtr , void *arg ) ;
void NsConnThread(void *arg ) ;
void NsConnArgProc(Tcl_DString *dsPtr , void *arg ) ;
struct proc procs[8]  = 
  {      {(void *)(& NsTclThread), (char *)"ns:tclthread", & NsTclThreadArgProc}, 
        {(void *)(& NsTclCallback), (char *)"ns:tclcallback", & NsTclArgProc}, 
        {(void *)(& NsTclSchedProc), (char *)"ns:tclschedproc", & NsTclArgProc}, 
        {(void *)(& NsTclSignalProc), (char *)"ns:tclsigproc", & NsTclArgProc}, 
        {(void *)(& NsTclSockProc), (char *)"ns:tclsockcallback", & NsTclSockArgProc}, 
        {(void *)(& NsCachePurge),
      (char *)"ns:cachepurge", & NsCacheArgProc}, 
        {(void *)(& NsConnThread), (char *)"ns:connthread", & NsConnArgProc}, 
        {(void *)0, (char *)((void *)0), (Ns_ArgProc *)((void *)0)}};
static void AppendAddr(Tcl_DString *dsPtr , char *prefix , void *addr ) ;
static Tcl_HashTable info  ;
void NsInitProcInfo(void) 
{ struct proc *procPtr ;

  {
  Tcl_InitHashTable(& info, 1);
  procPtr = procs;
  while ((unsigned int )procPtr->procAddr != (unsigned int )((void *)0)) {
    Ns_RegisterProcInfo(procPtr->procAddr, procPtr->desc, procPtr->argProc);
    procPtr ++;
  }
  return;
}
}
void Ns_RegisterProcInfo(void *procAddr , char *desc , Ns_ArgProc *argProc ) 
{ Tcl_HashEntry *hPtr ;
  Info *iPtr ;
  int new ;

  {
  hPtr = ((*(info.createProc)))(& info, (char *)procAddr, & new);
  if (! new) {
    iPtr = (Info *)hPtr->clientData;
  } else {
    iPtr = (Info *)ns_malloc(sizeof(Info ));
    hPtr->clientData = (void *)iPtr;
  }
  iPtr->desc = desc;
  iPtr->proc = argProc;
  return;
}
}
static struct Info nullInfo  =    {(Ns_ArgProc *)((void *)0), (char *)((void *)0)};
void Ns_GetProcInfo(Tcl_DString *dsPtr , void *procAddr , void *arg ) 
{ Tcl_HashEntry *hPtr ;
  Info *iPtr ;

  {
  hPtr = ((*(info.findProc)))(& info, (char *)procAddr);
  if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    iPtr = (Info *)hPtr->clientData;
  } else {
    iPtr = & nullInfo;
  }
  if ((unsigned int )iPtr->desc != (unsigned int )((void *)0)) {
    Tcl_DStringAppendElement(dsPtr, iPtr->desc);
  } else {
    AppendAddr(dsPtr, (char *)"p", procAddr);
  }
  if ((unsigned int )iPtr->proc != (unsigned int )((void *)0)) {
    ((*(iPtr->proc)))(dsPtr, arg);
  } else {
    AppendAddr(dsPtr, (char *)"a", arg);
  }
  return;
}
}
static void AppendAddr(Tcl_DString *dsPtr , char *prefix , void *addr ) 
{ char buf[30] ;

  {
  if ((unsigned int )addr == (unsigned int )((void *)0)) {
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%s:0x0", prefix);
  } else {
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%s:%p", prefix,
            addr);
  }
  Tcl_DStringAppendElement(dsPtr, buf);
  return;
}
}
extern char *strncpy(char * __restrict  __dest , char const   * __restrict  __src ,
                     size_t __n ) ;
extern void Tcl_Free(char *ptr ) ;
extern int Tcl_SplitList(Tcl_Interp *interp , char *listStr , int *argcPtr , char ***argvPtr ) ;
void Ns_ThreadExit(void *arg ) ;
void Ns_ThreadSelf(Ns_Thread *threadPtr ) ;
int Ns_HtuuDecode(char *input , unsigned char *output , int outputlen ) ;
char *Ns_StrToUpper(char *string ) ;
void Ns_FreeConnInterp(Ns_Conn *conn ) ;
void NsMapPool(ConnPool *poolPtr , char *map ) ;
void NsStartServer(NsServer *servPtr ) ;
void NsStopServer(NsServer *servPtr ) ;
void NsWaitServer(NsServer *servPtr , Ns_Time *toPtr ) ;
static void ConnRun(Conn *connPtr ) ;
static void ParseAuth(Conn *connPtr , char *auth ) ;
static void CreateConnThread(ConnPool *poolPtr ) ;
static void JoinConnThread(Ns_Thread *threadPtr ) ;
static void AppendConn(Tcl_DString *dsPtr , Conn *connPtr , char *state ) ;
static void AppendConnList(Tcl_DString *dsPtr , Conn *firstPtr___1 , char *state ) ;
static Ns_Tls argtls  ;
static int poolid  ;
void NsInitQueue(void) 
{ 

  {
  Ns_TlsAlloc(& argtls, (Ns_TlsCleanup *)((void *)0));
  poolid = Ns_UrlSpecificAlloc();
  return;
}
}
int Ns_QueueConn(void *drv , void *arg ) 
{ 

  {
  return (-1);
}
}
Ns_Conn *Ns_GetConn(void) 
{ Arg *argPtr ;
  Ns_Conn *tmp ;

  {
  argPtr = (Arg *)Ns_TlsGet(& argtls);
  if (argPtr) {
    tmp = (Ns_Conn *)argPtr->connPtr;
  } else {
    tmp = (Ns_Conn *)((void *)0);
  }
  return (tmp);
}
}
void NsMapPool(ConnPool *poolPtr , char *map ) 
{ char *server ;
  char **mv ;
  int mc ;
  int tmp ;

  {
  server = (poolPtr->servPtr)->server;
  tmp = Tcl_SplitList((Tcl_Interp *)((void *)0), map, & mc, & mv);
  if (tmp == 0) {
    if (mc == 2) {
      Ns_UrlSpecificSet(server, (*(mv + 0)), (*(mv + 1)), poolid, (void *)poolPtr,
                        0, (void (*)(void * ))((void *)0));
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"pool[%s]: mapped %s %s -> %s",
             server, (*(mv + 0)), (*(mv + 1)), poolPtr->pool);
    }
    Tcl_Free((char *)mv);
  }
  return;
}
}
int NsQueueConn(Sock *sockPtr , Ns_Time *nowPtr ) 
{ NsServer *servPtr ;
  ConnPool *poolPtr ;
  Conn *connPtr ;
  int create ;
  int tmp ;

  {
  servPtr = sockPtr->servPtr;
  poolPtr = (ConnPool *)((void *)0);
  connPtr = (Conn *)((void *)0);
  create = 0;
  if ((unsigned int )sockPtr->reqPtr != (unsigned int )((void *)0)) {
    poolPtr = (ConnPool *)Ns_UrlSpecificGet(servPtr->server, ((sockPtr->reqPtr)->request)->method,
                                            ((sockPtr->reqPtr)->request)->url, poolid);
  }
  if ((unsigned int )poolPtr == (unsigned int )((void *)0)) {
    poolPtr = servPtr->pools.defaultPtr;
  }
  Ns_MutexLock(& servPtr->pools.lock);
  if (! servPtr->pools.shutdown) {
    connPtr = poolPtr->queue.freePtr;
    if ((unsigned int )connPtr != (unsigned int )((void *)0)) {
      poolPtr->queue.freePtr = connPtr->nextPtr;
      connPtr->startTime = (*nowPtr);
      tmp = servPtr->pools.nextconnid;
      servPtr->pools.nextconnid = servPtr->pools.nextconnid + 1;
      connPtr->id = tmp;
      connPtr->sockPtr = sockPtr;
      connPtr->drvPtr = sockPtr->drvPtr;
      connPtr->servPtr = servPtr;
      connPtr->server = servPtr->server;
      connPtr->location = sockPtr->location;
      if ((unsigned int )poolPtr->queue.wait.firstPtr == (unsigned int )((void *)0)) {
        poolPtr->queue.wait.firstPtr = connPtr;
      } else {
        (poolPtr->queue.wait.lastPtr)->nextPtr = connPtr;
      }
      poolPtr->queue.wait.lastPtr = connPtr;
      connPtr->nextPtr = (struct Conn *)((void *)0);
      if (poolPtr->threads.idle == 0) {
        if (poolPtr->threads.current < poolPtr->threads.max) {
          poolPtr->threads.idle = poolPtr->threads.idle + 1;
          poolPtr->threads.current = poolPtr->threads.current + 1;
          create = 1;
        }
      }
      poolPtr->queue.wait.num = poolPtr->queue.wait.num + 1;
    }
  }
  Ns_MutexUnlock(& servPtr->pools.lock);
  if ((unsigned int )connPtr == (unsigned int )((void *)0)) {
    return (0);
  }
  if (create) {
    CreateConnThread(poolPtr);
  } else {
    Ns_CondSignal(& poolPtr->queue.cond);
  }
  return (1);
}
}
int NsTclServerObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
static char *opts___2[9]  = 
  {      (char *)"active",      (char *)"all",      (char *)"connections",      (char *)"keepalive", 
        (char *)"pools",      (char *)"queued",      (char *)"threads",      (char *)"waiting", 
        (char *)((void *)0)};
int NsTclServerObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  NsServer *servPtr ;
  ConnPool *poolPtr ;
  char buf[100] ;
  char *pool ;
  Tcl_DString ds ;
  enum __anonenum_opt_108 opt ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  Tcl_Obj *tmp___8 ;
  Tcl_Obj *tmp___9 ;
  Tcl_Obj *tmp___10 ;

  {
  itPtr = (NsInterp *)arg;
  servPtr = itPtr->servPtr;
  poolPtr = servPtr->pools.defaultPtr;
  if (objc != 2) {
    if (objc != 3) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"option ?pool?");
      return (1);
    }
  }
  tmp = Tcl_GetIndexFromObj(interp, (*(objv + 1)), opts___2, (char *)"option", 0,
                            (int *)(& opt));
  if (tmp != 0) {
    return (1);
  }
  if (objc == 2) {
    poolPtr = servPtr->pools.defaultPtr;
  } else {
    pool = Tcl_GetString((*(objv + 2)));
    poolPtr = servPtr->pools.firstPtr;
    while (1) {
      if ((unsigned int )poolPtr != (unsigned int )((void *)0)) {
        if ((int )(*(poolPtr->pool)) == (int )(*pool)) {
          if (0) {
            __s1_len = strlen((char const   *)poolPtr->pool);
            __s2_len = strlen((char const   *)pool);
            if (! ((unsigned int )((void const   *)(poolPtr->pool + 1)) - (unsigned int )((void const   *)poolPtr->pool) ==
                   1U)) {
              goto _L___0;
            } else {
              if (__s1_len >= 4U) {
                _L___0: 
                if (! ((unsigned int )((void const   *)(pool + 1)) - (unsigned int )((void const   *)pool) ==
                       1U)) {
                  tmp___7 = 1;
                } else {
                  if (__s2_len >= 4U) {
                    tmp___7 = 1;
                  } else {
                    tmp___7 = 0;
                  }
                }
              } else {
                tmp___7 = 0;
              }
            }
            if (tmp___7) {
              if (__s1_len < __s2_len) {
                tmp___5 = __s1_len;
              } else {
                tmp___5 = __s2_len;
              }
              tmp___4 = memcmp((void const   *)((char const   *)poolPtr->pool), (void const   *)((char const   *)pool),
                               tmp___5 + 1U);
            } else {
              tmp___6 = strcmp((char const   *)poolPtr->pool, (char const   *)pool);
              tmp___4 = tmp___6;
            }
          } else {
            tmp___6 = strcmp((char const   *)poolPtr->pool, (char const   *)pool);
            tmp___4 = tmp___6;
          }
          if (tmp___4 == 0) {
            break;
          }
        }
      } else {
        break;
      }
      poolPtr = poolPtr->nextPtr;
    }
    if ((unsigned int )poolPtr == (unsigned int )((void *)0)) {
      Tcl_AppendResult(interp, "no such pool: ", pool, (void *)0);
      return (1);
    }
  }
  Ns_MutexLock(& servPtr->pools.lock);
  switch ((int )opt) {
  case 4: 
  poolPtr = servPtr->pools.firstPtr;
  while ((unsigned int )poolPtr != (unsigned int )((void *)0)) {
    Tcl_AppendElement(interp, poolPtr->pool);
    poolPtr = poolPtr->nextPtr;
  }
  break;
  case 7: 
  tmp___8 = Tcl_NewIntObj(poolPtr->queue.wait.num);
  Tcl_SetObjResult(interp, tmp___8);
  break;
  case 3: 
  tmp___9 = Tcl_NewIntObj(nsconf.keepalive.npending);
  Tcl_SetObjResult(interp, tmp___9);
  break;
  case 2: 
  tmp___10 = Tcl_NewIntObj(servPtr->pools.nextconnid);
  Tcl_SetObjResult(interp, tmp___10);
  break;
  case 6: 
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"min %d", poolPtr->threads.min);
  Tcl_AppendElement(interp, buf);
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"max %d", poolPtr->threads.max);
  Tcl_AppendElement(interp, buf);
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"current %d", poolPtr->threads.current);
  Tcl_AppendElement(interp, buf);
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"idle %d", poolPtr->threads.idle);
  Tcl_AppendElement(interp, buf);
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"stopping 0");
  Tcl_AppendElement(interp, buf);
  break;
  case 0: ;
  case 5: ;
  case 1: 
  Tcl_DStringInit(& ds);
  if ((int )opt != 5) {
    AppendConnList(& ds, poolPtr->queue.active.firstPtr, (char *)"running");
  }
  if ((int )opt != 0) {
    AppendConnList(& ds, poolPtr->queue.wait.firstPtr, (char *)"queued");
  }
  Tcl_DStringResult(interp, & ds);
  }
  Ns_MutexUnlock(& servPtr->pools.lock);
  return (0);
}
}
void NsStartServer(NsServer *servPtr ) 
{ ConnPool *poolPtr ;
  int n ;

  {
  poolPtr = servPtr->pools.firstPtr;
  while ((unsigned int )poolPtr != (unsigned int )((void *)0)) {
    poolPtr->threads.idle = poolPtr->threads.min;
    poolPtr->threads.current = poolPtr->threads.idle;
    n = 0;
    while (n < poolPtr->threads.min) {
      CreateConnThread(poolPtr);
      n ++;
    }
    poolPtr = poolPtr->nextPtr;
  }
  return;
}
}
void NsStopServer(NsServer *servPtr ) 
{ ConnPool *poolPtr ;

  {
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"serv: stopping server: %s",
         servPtr->server);
  Ns_MutexLock(& servPtr->pools.lock);
  servPtr->pools.shutdown = 1;
  Ns_MutexUnlock(& servPtr->pools.lock);
  poolPtr = servPtr->pools.firstPtr;
  while ((unsigned int )poolPtr != (unsigned int )((void *)0)) {
    Ns_CondBroadcast(& poolPtr->queue.cond);
    poolPtr = poolPtr->nextPtr;
  }
  return;
}
}
void NsWaitServer(NsServer *servPtr , Ns_Time *toPtr ) 
{ ConnPool *poolPtr ;
  Ns_Thread joinThread ;
  int status ;

  {
  status = 0;
  poolPtr = servPtr->pools.firstPtr;
  Ns_MutexLock(& servPtr->pools.lock);
  while (1) {
    if ((unsigned int )poolPtr != (unsigned int )((void *)0)) {
      if (! (status == 0)) {
        break;
      }
    } else {
      break;
    }
    while (1) {
      if (status == 0) {
        if (! ((unsigned int )poolPtr->queue.wait.firstPtr != (unsigned int )((void *)0))) {
          if (! (poolPtr->threads.current > 0)) {
            break;
          }
        }
      } else {
        break;
      }
      status = Ns_CondTimedWait(& poolPtr->queue.cond, & servPtr->pools.lock, toPtr);
    }
    poolPtr = poolPtr->nextPtr;
  }
  joinThread = servPtr->pools.joinThread;
  servPtr->pools.joinThread = (struct Ns_Thread_ *)((void *)0);
  Ns_MutexUnlock(& servPtr->pools.lock);
  if (status != 0) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"serv: timeout waiting for connection thread exit");
  } else {
    if ((unsigned int )joinThread != (unsigned int )((void *)0)) {
      JoinConnThread(& joinThread);
    }
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"serv: connection threads stopped");
  }
  return;
}
}
void NsConnArgProc(Tcl_DString *dsPtr , void *arg ) 
{ Arg *argPtr ;

  {
  argPtr = (Arg *)arg;
  if ((unsigned int )arg != (unsigned int )((void *)0)) {
    AppendConn(dsPtr, argPtr->connPtr, (char *)"running");
  } else {
    Tcl_DStringAppendElement(dsPtr, (char *)"");
  }
  return;
}
}
void NsConnThread(void *arg ) 
{ Arg *argPtr ;
  ConnPool *poolPtr ;
  NsServer *servPtr ;
  Conn *connPtr ;
  Ns_Time wait___0 ;
  Ns_Time *timePtr ;
  unsigned int id ;
  Tcl_DString ds ;
  int status ;
  int cpt ;
  int ncons ;
  char *p ;
  char *path ;
  Ns_Thread joinThread ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  argPtr = (Arg *)arg;
  poolPtr = argPtr->poolPtr;
  servPtr = poolPtr->servPtr;
  Ns_TlsSet(& argtls, (void *)argPtr);
  Ns_MutexLock(& servPtr->pools.lock);
  tmp = poolPtr->threads.nextid;
  poolPtr->threads.nextid = poolPtr->threads.nextid + 1U;
  id = tmp;
  Ns_MutexUnlock(& servPtr->pools.lock);
  Tcl_DStringInit(& ds);
  Ns_DStringVarAppend(& ds, "-conn:", servPtr->server, (void *)0);
  if ((unsigned int )poolPtr->pool != (unsigned int )((void *)0)) {
    Ns_DStringVarAppend(& ds, ":", poolPtr->pool, (void *)0);
  }
  Ns_DStringPrintf(& ds, (char *)":%d", id);
  Ns_ThreadSetName(ds.string);
  Tcl_DStringFree(& ds);
  path = Ns_ConfigGetPath(servPtr->server, (char *)((void *)0), (void *)0);
  tmp___0 = Ns_ConfigGetInt(path, (char *)"connsperthread", & cpt);
  if (! tmp___0) {
    cpt = 0;
  }
  ncons = cpt;
  Ns_MutexLock(& servPtr->pools.lock);
  while (1) {
    if (! (cpt == 0)) {
      if (! (ncons > 0)) {
        break;
      }
    }
    if (poolPtr->threads.current <= poolPtr->threads.min) {
      timePtr = (Ns_Time *)((void *)0);
    } else {
      Ns_GetTime(& wait___0);
      Ns_IncrTime(& wait___0, (long )poolPtr->threads.timeout, 0L);
      timePtr = & wait___0;
    }
    status = 0;
    while (1) {
      if (! servPtr->pools.shutdown) {
        if (status == 0) {
          if (! ((unsigned int )poolPtr->queue.wait.firstPtr == (unsigned int )((void *)0))) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      status = Ns_CondTimedWait(& poolPtr->queue.cond, & servPtr->pools.lock, timePtr);
    }
    if ((unsigned int )poolPtr->queue.wait.firstPtr == (unsigned int )((void *)0)) {
      break;
    }
    connPtr = poolPtr->queue.wait.firstPtr;
    poolPtr->queue.wait.firstPtr = connPtr->nextPtr;
    if ((unsigned int )poolPtr->queue.wait.lastPtr == (unsigned int )connPtr) {
      poolPtr->queue.wait.lastPtr = (Conn *)((void *)0);
    }
    connPtr->nextPtr = (struct Conn *)((void *)0);
    connPtr->prevPtr = poolPtr->queue.active.lastPtr;
    if ((unsigned int )poolPtr->queue.active.lastPtr != (unsigned int )((void *)0)) {
      (poolPtr->queue.active.lastPtr)->nextPtr = connPtr;
    }
    poolPtr->queue.active.lastPtr = connPtr;
    if ((unsigned int )poolPtr->queue.active.firstPtr == (unsigned int )((void *)0)) {
      poolPtr->queue.active.firstPtr = connPtr;
    }
    poolPtr->threads.idle = poolPtr->threads.idle - 1;
    poolPtr->queue.wait.num = poolPtr->queue.wait.num - 1;
    argPtr->connPtr = connPtr;
    Ns_MutexUnlock(& servPtr->pools.lock);
    ConnRun(connPtr);
    Ns_MutexLock(& servPtr->pools.lock);
    argPtr->connPtr = (Conn *)((void *)0);
    if ((unsigned int )connPtr->prevPtr != (unsigned int )((void *)0)) {
      (connPtr->prevPtr)->nextPtr = connPtr->nextPtr;
    } else {
      poolPtr->queue.active.firstPtr = connPtr->nextPtr;
    }
    if ((unsigned int )connPtr->nextPtr != (unsigned int )((void *)0)) {
      (connPtr->nextPtr)->prevPtr = connPtr->prevPtr;
    } else {
      poolPtr->queue.active.lastPtr = connPtr->prevPtr;
    }
    poolPtr->threads.idle = poolPtr->threads.idle + 1;
    connPtr->prevPtr = (struct Conn *)((void *)0);
    connPtr->nextPtr = poolPtr->queue.freePtr;
    poolPtr->queue.freePtr = connPtr;
    if ((unsigned int )connPtr->nextPtr == (unsigned int )((void *)0)) {
      Ns_MutexUnlock(& servPtr->pools.lock);
      NsRunAtReadyProcs();
      Ns_MutexLock(& servPtr->pools.lock);
    }
    if (cpt) {
      ncons --;
      if (ncons <= 0) {
        break;
      }
    }
  }
  poolPtr->threads.idle = poolPtr->threads.idle - 1;
  poolPtr->threads.current = poolPtr->threads.current - 1;
  if (poolPtr->threads.current == 0) {
    Ns_CondBroadcast(& poolPtr->queue.cond);
  }
  if (servPtr->pools.shutdown) {
    p = (char *)"shutdown pending";
  } else {
    p = (char *)"no waiting connections";
  }
  joinThread = servPtr->pools.joinThread;
  Ns_ThreadSelf(& servPtr->pools.joinThread);
  Ns_MutexUnlock(& servPtr->pools.lock);
  if ((unsigned int )joinThread != (unsigned int )((void *)0)) {
    JoinConnThread(& joinThread);
  }
  Ns_ThreadExit((void *)argPtr);
  return;
}
}
static void ConnRun(Conn *connPtr ) 
{ Ns_Conn *conn ;
  NsServer *servPtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  FormFile *filePtr ;
  int i ;
  int status ;
  char *auth ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  conn = (Ns_Conn *)connPtr;
  servPtr = connPtr->servPtr;
  connPtr->reqPtr = NsGetRequest(connPtr->sockPtr);
  if ((unsigned int )connPtr->reqPtr == (unsigned int )((void *)0)) {
    Ns_ConnClose(conn);
    return;
  }
  connPtr->contentLength = (connPtr->reqPtr)->length;
  connPtr->headers = (connPtr->reqPtr)->headers;
  connPtr->request = (connPtr->reqPtr)->request;
  connPtr->flags = 0;
  connPtr->nContentSent = 0;
  connPtr->responseStatus = 0;
  connPtr->responseLength = 0;
  connPtr->recursionCount = 0;
  connPtr->encoding = servPtr->encoding.outputEncoding;
  connPtr->urlEncoding = servPtr->encoding.urlEncoding;
  Tcl_DStringInit(& connPtr->queued);
  Tcl_InitHashTable(& connPtr->files, 0);
  sprintf((char * __restrict  )(connPtr->idstr), (char const   * __restrict  )"cns%d",
          connPtr->id);
  connPtr->outputheaders = Ns_SetCreate((char *)((void *)0));
  if ((connPtr->request)->version < 1.0) {
    conn->flags = conn->flags | 2;
  }
  if ((int )servPtr->opts.hdrcase != 0) {
    i = 0;
    while (i < (connPtr->headers)->size) {
      if ((int )servPtr->opts.hdrcase == 1) {
        Ns_StrToLower(((connPtr->headers)->fields + i)->name);
      } else {
        Ns_StrToUpper(((connPtr->headers)->fields + i)->name);
      }
      i ++;
    }
  }
  auth = Ns_SetIGet(connPtr->headers, (char *)"authorization");
  if ((unsigned int )auth != (unsigned int )((void *)0)) {
    ParseAuth(connPtr, auth);
  }
  if ((conn->request)->method) {
    if ((int )(*((conn->request)->method)) == (int )(*"HEAD")) {
      if (0) {
        __s1_len = strlen((char const   *)(conn->request)->method);
        __s2_len = strlen("HEAD");
        if (! ((unsigned int )((void const   *)((conn->request)->method + 1)) - (unsigned int )((void const   *)(conn->request)->method) ==
               1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("HEAD" + 1)) - (unsigned int )((void const   *)"HEAD") ==
                   1U)) {
              tmp___6 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___6 = 1;
              } else {
                tmp___6 = 0;
              }
            }
          } else {
            tmp___6 = 0;
          }
        }
        if (tmp___6) {
          if (__s1_len < __s2_len) {
            tmp___4 = __s1_len;
          } else {
            tmp___4 = __s2_len;
          }
          tmp___3 = memcmp((void const   *)((char const   *)(conn->request)->method),
                           (void const   *)"HEAD", tmp___4 + 1U);
        } else {
          tmp___5 = strcmp((char const   *)(conn->request)->method, "HEAD");
          tmp___3 = tmp___5;
        }
      } else {
        tmp___5 = strcmp((char const   *)(conn->request)->method, "HEAD");
        tmp___3 = tmp___5;
      }
      if (tmp___3 == 0) {
        conn->flags = conn->flags | 4;
      }
    }
  }
  if ((unsigned int )(connPtr->request)->protocol != (unsigned int )((void *)0)) {
    if ((unsigned int )(connPtr->request)->host != (unsigned int )((void *)0)) {
      status = NsConnRunProxyRequest((Ns_Conn *)connPtr);
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    status = NsRunFilters(conn, 1);
    if (status == 0) {
      status = Ns_AuthorizeRequest(servPtr->server, (connPtr->request)->method, (connPtr->request)->url,
                                   connPtr->authUser, connPtr->authPasswd, (connPtr->reqPtr)->peer);
      switch (status) {
      case 0: 
      status = NsRunFilters(conn, 2);
      if (status == 0) {
        status = Ns_ConnRunRequest(conn);
      }
      break;
      case -3: 
      Ns_ConnReturnForbidden(conn);
      break;
      case -2: 
      Ns_ConnReturnUnauthorized(conn);
      break;
      case -1: ;
      default: 
      Ns_ConnReturnInternalError(conn);
      break;
      }
    } else {
      if (status != -5) {
        Ns_ConnReturnInternalError(conn);
        status = -5;
      }
    }
  }
  Ns_ConnClose(conn);
  if (status == 0) {
    goto _L___2;
  } else {
    if (status == -5) {
      _L___2: 
      status = NsRunFilters(conn, 4);
      if (status == 0) {
        NsRunFilters(conn, 8);
        NsRunTraces(conn);
      }
    }
  }
  NsRunCleanups(conn);
  NsClsCleanup(connPtr);
  Ns_FreeConnInterp(conn);
  if ((unsigned int )connPtr->authUser != (unsigned int )((void *)0)) {
    ns_free((void *)connPtr->authUser);
    connPtr->authPasswd = (char *)((void *)0);
    connPtr->authUser = connPtr->authPasswd;
  }
  if ((unsigned int )connPtr->query != (unsigned int )((void *)0)) {
    Ns_SetFree(connPtr->query);
    connPtr->query = (Ns_Set *)((void *)0);
  }
  hPtr = Tcl_FirstHashEntry(& connPtr->files, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    filePtr = (FormFile *)hPtr->clientData;
    Ns_SetFree(filePtr->hdrs);
    ns_free((void *)filePtr);
    hPtr = Tcl_NextHashEntry(& search);
  }
  Tcl_DeleteHashTable(& connPtr->files);
  Tcl_DStringFree(& connPtr->queued);
  Ns_SetFree(connPtr->outputheaders);
  connPtr->outputheaders = (Ns_Set *)((void *)0);
  NsFreeRequest(connPtr->reqPtr);
  connPtr->reqPtr = (struct Request *)((void *)0);
  return;
}
}
static void ParseAuth(Conn *connPtr , char *auth ) 
{ register char *p ;
  register char *q ;
  int n ;
  char save ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  p = auth;
  while (1) {
    if ((int )(*p) != 0) {
      tmp = __ctype_b_loc();
      if ((int const   )(*((*tmp) + (int )((unsigned char )(*p)))) & 8192) {
        break;
      }
    } else {
      break;
    }
    p ++;
  }
  if ((int )(*p) != 0) {
    save = (*p);
    (*p) = (char )'\000';
    tmp___5 = strcasecmp((char const   *)auth, "Basic");
    if (tmp___5 == 0) {
      q = p + 1;
      while (1) {
        if ((int )(*q) != 0) {
          tmp___0 = __ctype_b_loc();
          if (! ((int const   )(*((*tmp___0) + (int )((unsigned char )(*q)))) & 8192)) {
            break;
          }
        } else {
          break;
        }
        q ++;
      }
      tmp___1 = strlen((char const   *)q);
      n = (int )(tmp___1 + 3U);
      connPtr->authUser = (char *)ns_malloc((unsigned int )n);
      n = Ns_HtuuDecode(q, (unsigned char *)connPtr->authUser, n);
      (*(connPtr->authUser + n)) = (char )'\000';
      tmp___3 = strchr((char const   *)connPtr->authUser, ':');
      q = tmp___3;
      if ((unsigned int )q != (unsigned int )((void *)0)) {
        tmp___4 = q;
        q ++;
        (*tmp___4) = (char )'\000';
        connPtr->authPasswd = q;
      }
    }
    (*p) = save;
  }
  return;
}
}
static void CreateConnThread(ConnPool *poolPtr ) 
{ Ns_Thread thread ;
  Arg *argPtr ;

  {
  argPtr = (Arg *)ns_malloc(sizeof(Arg ));
  argPtr->poolPtr = poolPtr;
  argPtr->connPtr = (Conn *)((void *)0);
  Ns_ThreadCreate(& NsConnThread, (void *)argPtr, 0L, & thread);
  return;
}
}
static void JoinConnThread(Ns_Thread *threadPtr ) 
{ Arg *argPtr ;

  {
  Ns_ThreadJoin(threadPtr, (void **)(& argPtr));
  ns_free((void *)argPtr);
  return;
}
}
static void AppendConn(Tcl_DString *dsPtr , Conn *connPtr , char *state ) 
{ char buf[100] ;
  char *p ;
  Ns_Time now ;
  Ns_Time diff ;
  char *tmp ;
  char *tmp___6 ;
  char *tmp___13 ;

  {
  Tcl_DStringStartSublist(dsPtr);
  if ((unsigned int )connPtr != (unsigned int )((void *)0)) {
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", connPtr->id);
    Tcl_DStringAppendElement(dsPtr, buf);
    tmp = Ns_ConnPeer((Ns_Conn *)connPtr);
    Tcl_DStringAppendElement(dsPtr, tmp);
    Tcl_DStringAppendElement(dsPtr, state);
    if (connPtr->request) {
      if ((connPtr->request)->method) {
        p = (connPtr->request)->method;
      } else {
        p = (char *)"?";
      }
    } else {
      p = (char *)"?";
    }
    tmp___6 = strncpy((char * __restrict  )(buf), (char const   * __restrict  )p,
                      sizeof(buf));
    Tcl_DStringAppendElement(dsPtr, tmp___6);
    if (connPtr->request) {
      if ((connPtr->request)->url) {
        p = (connPtr->request)->url;
      } else {
        p = (char *)"?";
      }
    } else {
      p = (char *)"?";
    }
    tmp___13 = strncpy((char * __restrict  )(buf), (char const   * __restrict  )p,
                       sizeof(buf));
    Tcl_DStringAppendElement(dsPtr, tmp___13);
    Ns_GetTime(& now);
    Ns_DiffTime(& now, & connPtr->startTime, & diff);
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%ld.%ld", diff.sec,
            diff.usec);
    Tcl_DStringAppendElement(dsPtr, buf);
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", connPtr->nContentSent);
    Tcl_DStringAppendElement(dsPtr, buf);
  }
  Tcl_DStringEndSublist(dsPtr);
  return;
}
}
static void AppendConnList(Tcl_DString *dsPtr , Conn *firstPtr___1 , char *state ) 
{ 

  {
  while ((unsigned int )firstPtr___1 != (unsigned int )((void *)0)) {
    AppendConn(dsPtr, firstPtr___1, state);
    firstPtr___1 = firstPtr___1->nextPtr;
  }
  return;
}
}
void Ns_QuoteHtml(Tcl_DString *pds , char *string ) ;
void Ns_QuoteHtml(Tcl_DString *pds , char *string ) 
{ 

  {
  while ((int )(*string) != 0) {
    switch ((int )(*string)) {
    case 60: 
    Tcl_DStringAppend(pds, (char *)"&lt;", -1);
    break;
    case 62: 
    Tcl_DStringAppend(pds, (char *)"&gt;", -1);
    break;
    case 38: 
    Tcl_DStringAppend(pds, (char *)"&amp;", -1);
    break;
    case 39: 
    Tcl_DStringAppend(pds, (char *)"&#39;", -1);
    break;
    case 34: 
    Tcl_DStringAppend(pds, (char *)"&#34;", -1);
    break;
    default: 
    Tcl_DStringAppend(pds, string, 1);
    break;
    }
    string ++;
  }
  return;
}
}
int NsTclQuoteHtmlCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) 
{ Tcl_DString ds ;
  char *tmp ;

  {
  if (argc != 2) {
    Tcl_AppendResult(interp, "wrong # args:  should be \"", (*(argv + 0)), " html\"",
                     (void *)0);
    return (1);
  }
  Tcl_DStringInit(& ds);
  Ns_QuoteHtml(& ds, (*(argv + 1)));
  tmp = Ns_DStringExport(& ds);
  Tcl_SetResult(interp, tmp, (Tcl_FreeProc *)(& ns_free));
  return (0);
}
}
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
extern double drand48(void) ;
extern void srand48(long __seedval ) ;
void Ns_CsEnter(Ns_Cs *csPtr ) ;
void Ns_CsLeave(Ns_Cs *csPtr ) ;
void Ns_SemaInit(Ns_Sema *semaPtr , int count ) ;
void Ns_SemaDestroy(Ns_Sema *semaPtr ) ;
void Ns_SemaWait(Ns_Sema *semaPtr ) ;
void Ns_SemaPost(Ns_Sema *semaPtr , int count ) ;
void Ns_GenSeeds(unsigned long *seedsPtr , int nseeds ) ;
double Ns_DRand(void) ;
static void CounterThread(void *ignored ) ;
static unsigned long TrueRand(void) ;
static unsigned long Roulette(void) ;
static unsigned long volatile   counter  ;
static char volatile   fRun  ;
static char volatile   fCount  ;
static Ns_Sema sema  ;
static Ns_Cs lock___8  ;
static int volatile   initialized  ;
int NsTclRandObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ double d ;
  int max ;
  Tcl_Obj *result ;
  char *tmp ;
  Tcl_Obj *tmp___0 ;
  int tmp___1 ;

  {
  if (objc > 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"?maximum?");
    return (1);
  }
  if (objc == 2) {
    tmp___1 = Tcl_GetIntFromObj(interp, (*(objv + 1)), & max);
    if (tmp___1 != 0) {
      return (1);
    } else {
      if (max <= 0) {
        tmp = Tcl_GetString((*(objv + 1)));
        tmp___0 = Tcl_GetObjResult(interp);
        Tcl_AppendStringsToObj(tmp___0, "invalid max \"", tmp, "\": must be > 0",
                               (void *)0);
        return (1);
      }
    }
  }
  result = Tcl_GetObjResult(interp);
  d = Ns_DRand();
  if (objc == 1) {
    Tcl_SetDoubleObj(result, d);
  } else {
    Tcl_SetIntObj(result, (int )(d * (double )max));
  }
  return (0);
}
}
double Ns_DRand(void) 
{ unsigned long seed ;
  double tmp ;

  {
  if (! initialized) {
    Ns_CsEnter(& lock___8);
    if (! initialized) {
      Ns_GenSeeds(& seed, 1);
      srand48((long )seed);
      initialized = (int volatile   )1;
    }
    Ns_CsLeave(& lock___8);
  }
  tmp = drand48();
  return (tmp);
}
}
void Ns_GenSeeds(unsigned long *seedsPtr , int nseeds ) 
{ Ns_Thread thr ;
  char const   *tmp ;
  unsigned long *tmp___0 ;
  int tmp___1 ;

  {
  if (nseeds == 1) {
    tmp = "";
  } else {
    tmp = "s";
  }
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"random: generating %d seed%s",
         nseeds, tmp);
  Ns_CsEnter(& lock___8);
  Ns_SemaInit(& sema, 0);
  fRun = (char volatile   )1;
  Ns_ThreadCreate(& CounterThread, (void *)0, 0L, & thr);
  while (1) {
    tmp___1 = nseeds;
    nseeds --;
    if (! (tmp___1 > 0)) {
      break;
    }
    tmp___0 = seedsPtr;
    seedsPtr ++;
    (*tmp___0) = TrueRand();
  }
  fRun = (char volatile   )0;
  Ns_SemaPost(& sema, 1);
  Ns_ThreadJoin(& thr, (void **)((void *)0));
  Ns_SemaDestroy(& sema);
  Ns_CsLeave(& lock___8);
  return;
}
}
static void CounterThread(void *ignored ) 
{ 

  {
  while (fRun) {
    Ns_SemaWait(& sema);
    if (fRun) {
      while (fCount) {
        counter ++;
      }
    }
  }
  return;
}
}
static unsigned long TrueRand(void) 
{ int i ;
  unsigned long tmp ;

  {
  i = 0;
  while (i < 10) {
    Roulette();
    i ++;
  }
  tmp = Roulette();
  return (tmp);
}
}
static unsigned long ocount  ;
static unsigned long randbuf  ;
static unsigned long Roulette(void) 
{ struct timeval tv ;

  {
  counter = (unsigned long volatile   )0;
  fCount = (char volatile   )1;
  Ns_SemaPost(& sema, 1);
  tv.tv_sec = 0L;
  tv.tv_usec = 31000L;
  select(0, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )((void *)0),
         (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& tv));
  fCount = (char volatile   )0;
  counter ^= ((counter >> 3) ^ (counter >> 6)) ^ (unsigned long volatile   )ocount;
  counter &= 7UL;
  ocount = (unsigned long )counter;
  randbuf = (randbuf << 3) ^ (unsigned long )counter;
  return (randbuf);
}
}
extern double __strtod_internal(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                int __group ) ;
__inline static double strtod__extinline(char const   * __restrict  __nptr , char ** __restrict  __endptr ) 
{ double tmp ;

  {
  tmp = __strtod_internal(__nptr, __endptr, 0);
  return (tmp);
}
}
__inline static double atof__extinline(char const   *__nptr ) 
{ double tmp ;

  {
  tmp = strtod__extinline((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
char *Ns_SkipUrl(Ns_Request *request , int n ) ;
void Ns_SetPutValue(Ns_Set *set , int index___0 , char *value ) ;
char *Ns_DecodeUrlCharset(Tcl_DString *dsPtr , char *string , char *charset ) ;
static void SetUrl(Ns_Request *request , char *url ) ;
static void FreeUrl(Ns_Request *request ) ;
void Ns_FreeRequest(Ns_Request *request ) 
{ 

  {
  if ((unsigned int )request != (unsigned int )((void *)0)) {
    ns_free((void *)request->line);
    ns_free((void *)request->method);
    ns_free((void *)request->protocol);
    ns_free((void *)request->host);
    ns_free((void *)request->query);
    FreeUrl(request);
    ns_free((void *)request);
  }
  return;
}
}
Ns_Request *Ns_ParseRequest(char *line ) 
{ char *url ;
  char *p ;
  Tcl_DString ds ;
  Ns_Request *request ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  int tmp___16 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___27 ;
  char *h ;
  char *tmp___28 ;
  char *tmp___30 ;
  char *tmp___31 ;
  size_t tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;

  {
  request = (Ns_Request *)ns_calloc(1U, sizeof(Ns_Request ));
  Tcl_DStringInit(& ds);
  if ((unsigned int )line == (unsigned int )((void *)0)) {
    goto done;
  }
  Tcl_DStringAppend(& ds, line, -1);
  line = Ns_StrTrim(ds.string);
  if ((int )(*line) == 0) {
    goto done;
  }
  request->line = ns_strdup((char const   *)line);
  url = line;
  while (1) {
    if ((int )(*url) != 0) {
      tmp = __ctype_b_loc();
      if ((int const   )(*((*tmp) + (int )((unsigned char )(*url)))) & 8192) {
        break;
      }
    } else {
      break;
    }
    url ++;
  }
  if ((int )(*url) == 0) {
    goto done;
  }
  tmp___0 = url;
  url ++;
  (*tmp___0) = (char )'\000';
  while (1) {
    if ((int )(*url) != 0) {
      tmp___1 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___1) + (int )((unsigned char )(*url)))) & 8192)) {
        break;
      }
    } else {
      break;
    }
    url ++;
  }
  if ((int )(*url) == 0) {
    goto done;
  }
  request->method = ns_strdup((char const   *)line);
  request->version = 0.0;
  tmp___2 = strlen((char const   *)url);
  p = url + tmp___2;
  while (1) {
    tmp___4 = p;
    p --;
    if (! ((unsigned int )tmp___4 > (unsigned int )url)) {
      break;
    }
    tmp___3 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___3) + (int )((unsigned char )(*p)))) & 2048)) {
      if ((int )(*p) != 46) {
        break;
      }
    }
  }
  p -= sizeof("HTTP/") - 2U;
  if ((unsigned int )p >= (unsigned int )url) {
    if (0) {
      if (0) {
        __s1_len___0 = strlen((char const   *)p);
        __s2_len___0 = strlen("HTTP/");
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) ==
               1U)) {
          goto _L___2;
        } else {
          if (__s1_len___0 >= 4U) {
            _L___2: 
            if (! ((unsigned int )((void const   *)("HTTP/" + 1)) - (unsigned int )((void const   *)"HTTP/") ==
                   1U)) {
              tmp___24 = 1;
            } else {
              if (__s2_len___0 >= 4U) {
                tmp___24 = 1;
              } else {
                tmp___24 = 0;
              }
            }
          } else {
            tmp___24 = 0;
          }
        }
        if (tmp___24) {
          if (__s1_len___0 < __s2_len___0) {
            tmp___22 = __s1_len___0;
          } else {
            tmp___22 = __s2_len___0;
          }
          tmp___21 = memcmp((void const   *)((char const   *)p), (void const   *)"HTTP/",
                            tmp___22 + 1U);
        } else {
          tmp___23 = strcmp((char const   *)p, "HTTP/");
          tmp___21 = tmp___23;
        }
      } else {
        tmp___23 = strcmp((char const   *)p, "HTTP/");
        tmp___21 = tmp___23;
      }
      tmp___16 = tmp___21;
    } else {
      tmp___16 = strncmp((char const   *)p, "HTTP/", sizeof("HTTP/") - 1U);
    }
    if (tmp___16 == 0) {
      (*p) = (char )'\000';
      p += sizeof("HTTP/") - 1U;
      request->version = atof__extinline((char const   *)p);
    }
  }
  url = Ns_StrTrim(url);
  if ((int )(*url) == 0) {
    goto done;
  }
  request->protocol = (char *)((void *)0);
  request->host = (char *)((void *)0);
  request->port = (unsigned short)0;
  if ((int )(*url) != 47) {
    p = url;
    while (1) {
      if ((int )(*p) != 0) {
        if ((int )(*p) != 47) {
          if (! ((int )(*p) != 58)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      p ++;
    }
    if ((int )(*p) == 58) {
      tmp___27 = p;
      p ++;
      (*tmp___27) = (char )'\000';
      request->protocol = ns_strdup((char const   *)url);
      url = p;
      tmp___32 = strlen((char const   *)url);
      if (tmp___32 > 3U) {
        tmp___33 = p;
        p ++;
        if ((int )(*tmp___33) == 47) {
          tmp___34 = p;
          p ++;
          if ((int )(*tmp___34) == 47) {
            if ((int )(*p) != 0) {
              if ((int )(*p) != 47) {
                h = p;
                while (1) {
                  if ((int )(*p) != 0) {
                    if (! ((int )(*p) != 47)) {
                      break;
                    }
                  } else {
                    break;
                  }
                  p ++;
                }
                if ((int )(*p) == 47) {
                  tmp___28 = p;
                  p ++;
                  (*tmp___28) = (char )'\000';
                }
                url = p;
                tmp___30 = strchr((char const   *)h, ':');
                p = tmp___30;
                if ((unsigned int )p != (unsigned int )((void *)0)) {
                  tmp___31 = p;
                  p ++;
                  (*tmp___31) = (char )'\000';
                  request->port = (unsigned short )atoi__extinline((char const   *)p);
                }
                request->host = ns_strdup((char const   *)h);
              }
            }
          }
        }
      }
    }
  }
  SetUrl(request, url);
  done: 
  if ((unsigned int )request->url == (unsigned int )((void *)0)) {
    Ns_FreeRequest(request);
    request = (Ns_Request *)((void *)0);
  }
  Tcl_DStringFree(& ds);
  return (request);
}
}
char *Ns_SkipUrl(Ns_Request *request , int n ) 
{ int skip ;
  size_t tmp ;

  {
  if (n > request->urlc) {
    return ((char *)((void *)0));
  }
  skip = 0;
  while (1) {
    n --;
    if (! (n >= 0)) {
      break;
    }
    tmp = strlen((char const   *)(*(request->urlv + n)));
    skip = (int )((unsigned int )skip + (tmp + 1U));
  }
  return (request->url + skip);
}
}
void Ns_SetRequestUrl(Ns_Request *request , char *url ) 
{ Tcl_DString ds ;

  {
  FreeUrl(request);
  Tcl_DStringInit(& ds);
  Tcl_DStringAppend(& ds, url, -1);
  SetUrl(request, ds.string);
  Tcl_DStringFree(& ds);
  return;
}
}
static void FreeUrl(Ns_Request *request ) 
{ 

  {
  if ((unsigned int )request->url != (unsigned int )((void *)0)) {
    ns_free((void *)request->url);
    request->url = (char *)((void *)0);
  }
  if ((unsigned int )request->urlv != (unsigned int )((void *)0)) {
    ns_free((void *)(*(request->urlv + 0)));
    ns_free((void *)request->urlv);
    request->urlv = (char **)((void *)0);
  }
  return;
}
}
static void SetUrl(Ns_Request *request , char *url ) 
{ Tcl_DString ds1 ;
  Tcl_DString ds2 ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
  Tcl_DStringInit(& ds1);
  Tcl_DStringInit(& ds2);
  tmp___0 = strchr((char const   *)url, '?');
  p = tmp___0;
  if ((unsigned int )p != (unsigned int )((void *)0)) {
    tmp___1 = p;
    p ++;
    (*tmp___1) = (char )'\000';
    if ((unsigned int )request->query != (unsigned int )((void *)0)) {
      ns_free((void *)request->query);
    }
    request->query = ns_strdup((char const   *)p);
  }
  p = Ns_DecodeUrlCharset(& ds1, url, (char *)((void *)0));
  if ((unsigned int )p == (unsigned int )((void *)0)) {
    p = url;
  }
  Ns_NormalizePath(& ds2, p);
  Tcl_DStringSetLength(& ds1, 0);
  while ((int )(*url) == 47) {
    url ++;
  }
  if ((int )(*url) != 0) {
    tmp___2 = strlen((char const   *)url);
    if ((int )(*(url + (tmp___2 - 1U))) == 47) {
      Tcl_DStringAppend(& ds2, (char *)"/", -1);
    }
  }
  request->url = ns_strdup((char const   *)ds2.string);
  Tcl_DStringFree(& ds2);
  p = ns_strdup((char const   *)(request->url + 1));
  Tcl_DStringAppend(& ds1, (char *)(& p), (int )sizeof(char *));
  while ((int )(*p) != 0) {
    if ((int )(*p) == 47) {
      tmp___3 = p;
      p ++;
      (*tmp___3) = (char )'\000';
      if ((int )(*p) == 0) {
        break;
      }
      Tcl_DStringAppend(& ds1, (char *)(& p), (int )sizeof(char *));
    }
    p ++;
  }
  request->urlc = (int )((unsigned int )ds1.length / sizeof(char *));
  p = (char *)((void *)0);
  Tcl_DStringAppend(& ds1, (char *)(& p), (int )sizeof(char *));
  request->urlv = (char **)ns_malloc((unsigned int )ds1.length);
  memcpy((void * __restrict  )request->urlv, (void const   * __restrict  )ds1.string,
         (unsigned int )ds1.length);
  Tcl_DStringFree(& ds1);
  return;
}
}
int Ns_ParseHeader(Ns_Set *set , char *line , Ns_HeaderCaseDisposition disp ) 
{ char *key___1 ;
  char *sep ;
  char *value ;
  int index___0 ;
  Tcl_DString ds ;
  unsigned short const   **tmp ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  int __res ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int __res___0 ;
  __int32_t const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;

  {
  tmp___11 = __ctype_b_loc();
  if ((int const   )(*((*tmp___11) + (int )((unsigned char )(*line)))) & 8192) {
    index___0 = set->size - 1;
    if (index___0 < 0) {
      return (-1);
    }
    while (1) {
      tmp = __ctype_b_loc();
      if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*line)))) & 8192)) {
        break;
      }
      line ++;
    }
    if ((int )(*line) != 0) {
      value = (set->fields + index___0)->value;
      Tcl_DStringInit(& ds);
      Ns_DStringVarAppend(& ds, value, " ", line, (void *)0);
      Ns_SetPutValue(set, index___0, ds.string);
      Tcl_DStringFree(& ds);
    }
  } else {
    tmp___1 = strchr((char const   *)line, ':');
    sep = tmp___1;
    if ((unsigned int )sep == (unsigned int )((void *)0)) {
      return (-1);
    }
    (*sep) = (char )'\000';
    value = sep + 1;
    while (1) {
      if ((int )(*value) != 0) {
        tmp___2 = __ctype_b_loc();
        if (! ((int const   )(*((*tmp___2) + (int )((unsigned char )(*value)))) &
               8192)) {
          break;
        }
      } else {
        break;
      }
      value ++;
    }
    index___0 = Ns_SetPut(set, line, value);
    key___1 = (set->fields + index___0)->name;
    if ((int )disp == 1) {
      while ((int )(*key___1) != 0) {
        tmp___6 = __ctype_b_loc();
        if ((int const   )(*((*tmp___6) + (int )((unsigned char )(*key___1)))) & 256) {
          if (sizeof((unsigned char )(*key___1)) > 1U) {
            __res = tolower__extinline((int )((unsigned char )(*key___1)));
          } else {
            tmp___5 = __ctype_tolower_loc();
            __res = (*((*tmp___5) + (int )((unsigned char )(*key___1))));
          }
          (*key___1) = (char )__res;
        }
        key___1 ++;
      }
    } else {
      if ((int )disp == 2) {
        while ((int )(*key___1) != 0) {
          tmp___10 = __ctype_b_loc();
          if ((int const   )(*((*tmp___10) + (int )((unsigned char )(*key___1)))) &
              512) {
            if (sizeof((unsigned char )(*key___1)) > 1U) {
              __res___0 = toupper__extinline((int )((unsigned char )(*key___1)));
            } else {
              tmp___9 = __ctype_toupper_loc();
              __res___0 = (*((*tmp___9) + (int )((unsigned char )(*key___1))));
            }
            (*key___1) = (char )__res___0;
          }
          key___1 ++;
        }
      }
    }
    (*sep) = (char )':';
  }
  return (0);
}
}
void Ns_RegisterReturn(int status , char *url ) ;
void Ns_ConnConstructHeaders(Ns_Conn *conn , Tcl_DString *dsPtr ) ;
void Ns_ConnSetHeaders(Ns_Conn *conn , char *field , char *value ) ;
void Ns_ConnReplaceHeaders(Ns_Conn *conn , Ns_Set *newheaders ) ;
void Ns_ConnSetTypeHeader(Ns_Conn *conn , char *type ) ;
void Ns_ConnSetLengthHeader(Ns_Conn *conn , int length ) ;
void Ns_ConnSetExpiresHeader(Ns_Conn *conn , char *expires ) ;
int Ns_ConnPrintfHeader(Ns_Conn *conn , char *fmt  , ...) ;
int Ns_ConnResetReturn(Ns_Conn *conn ) ;
int Ns_ConnReturnAdminNotice(Ns_Conn *conn , int status , char *title , char *notice ) ;
int Ns_ConnReturnCharData(Ns_Conn *conn , int status , char *data , int len , char *type ) ;
int Ns_ConnReturnHtml(Ns_Conn *conn , int status , char *html , int len ) ;
int Ns_ConnReturnOk(Ns_Conn *conn ) ;
int Ns_ConnReturnNoResponse(Ns_Conn *conn ) ;
int Ns_ConnReturnNotImplemented(Ns_Conn *conn ) ;
int Ns_ConnReturnStatus(Ns_Conn *conn , int status ) ;
int Ns_ConnReturnOpenChannel(Ns_Conn *conn , int status , char *type , Tcl_Channel chan ,
                             int len ) ;
int Ns_ConnReturnOpenFile(Ns_Conn *conn , int status , char *type , FILE *fp , int len ) ;
Ns_Set *Ns_SetCopy(Ns_Set *old ) ;
static int ReturnRedirect(Ns_Conn *conn , int status , int *resultPtr ) ;
static int ReturnOpen(Ns_Conn *conn , int status , char *type , Tcl_Channel chan ,
                      FILE *fp , int fd , int len ) ;
static int ReturnCharData(Ns_Conn *conn , int status , char *data , int len , char *type ,
                          int sendRaw ) ;
static struct __anonstruct_reasons_107 reasons[47]  = 
  {      {100, (char *)"Continue"}, 
        {101, (char *)"Switching Protocols"}, 
        {102, (char *)"Processing"}, 
        {200, (char *)"OK"}, 
        {201, (char *)"Created"}, 
        {202, (char *)"Accepted"}, 
        {203, (char *)"Non-Authoritative Information"}, 
        {204, (char *)"No Content"}, 
        {205, (char *)"Reset Content"}, 
        {206, (char *)"Partial Content"}, 
        {207, (char *)"Multi-Status"}, 
        {300, (char *)"Multiple Choices"}, 
        {301, (char *)"Moved"}, 
        {302, (char *)"Found"}, 
        {303, (char *)"See Other"}, 
        {304, (char *)"Not Modified"}, 
        {305, (char *)"Use Proxy"}, 
        {307, (char *)"Temporary Redirect"}, 
        {400, (char *)"Bad Request"}, 
        {401, (char *)"Unauthorized"}, 
        {402, (char *)"Payment Required"}, 
        {403, (char *)"Forbidden"}, 
        {404, (char *)"Not Found"}, 
        {405, (char *)"Method Not Allowed"}, 
        {406, (char *)"Not Acceptable"}, 
        {407, (char *)"Proxy Authentication Required"}, 
        {408, (char *)"Request Timeout"}, 
        {409, (char *)"Conflict"}, 
        {410, (char *)"Gone"}, 
        {411, (char *)"Length Required"}, 
        {412, (char *)"Precondition Failed"}, 
        {413, (char *)"Request Entity Too Large"}, 
        {414, (char *)"Request-URI Too Long"}, 
        {415, (char *)"Unsupported Media Type"}, 
        {416, (char *)"Requested Range Not Satisfiable"}, 
        {417, (char *)"Expectation Failed"}, 
        {422, (char *)"Unprocessable Entity"}, 
        {423, (char *)"Locked"}, 
        {424, (char *)"Method Failure"}, 
        {425, (char *)"Insufficient Space On Resource"}, 
        {500, (char *)"Internal Server Error"}, 
        {501, (char *)"Not Implemented"}, 
        {502, (char *)"Bad Gateway"}, 
        {503, (char *)"Service Unavailable"}, 
        {504, (char *)"Gateway Timeout"}, 
        {505, (char *)"HTTP Version Not Supported"}, 
        {507, (char *)"Insufficient Storage"}};
static int nreasons  =    (int )(sizeof(reasons) / sizeof(reasons[0]));
void Ns_RegisterReturn(int status , char *url ) 
{ NsServer *servPtr ;
  Tcl_HashEntry *hPtr ;
  int new ;

  {
  servPtr = NsGetInitServer();
  if ((unsigned int )servPtr != (unsigned int )((void *)0)) {
    hPtr = ((*(servPtr->request.redirect.createProc)))(& servPtr->request.redirect,
                                                       (char *)status, & new);
    if (! new) {
      ns_free(hPtr->clientData);
    }
    if ((unsigned int )url == (unsigned int )((void *)0)) {
      Tcl_DeleteHashEntry(hPtr);
    } else {
      hPtr->clientData = (ClientData )ns_strdup((char const   *)url);
    }
  }
  return;
}
}
static int IsSetupForChunkedEncoding(Ns_Conn *conn ) 
{ int headerCount ;
  int i ;
  Ns_Set *outHeaders ;
  int tmp ;
  int tmp___0 ;

  {
  headerCount = 0;
  if ((unsigned int )conn == (unsigned int )((void *)0)) {
    return (0);
  }
  outHeaders = Ns_ConnOutputHeaders(conn);
  headerCount = outHeaders->size;
  if (outHeaders) {
    if (headerCount) {
      i = 0;
      while (i < headerCount) {
        tmp = strcasecmp((char const   *)(outHeaders->fields + i)->name, "Transfer-Encoding");
        if (! tmp) {
          tmp___0 = strcasecmp((char const   *)(outHeaders->fields + i)->value, "chunked");
          if (! tmp___0) {
            return (1);
          }
        }
        i ++;
      }
    }
  }
  return (0);
}
}
void Ns_ConnConstructHeaders(Ns_Conn *conn , Tcl_DString *dsPtr ) 
{ int i ;
  int length ;
  char *reason ;
  char buf[100] ;
  char *value ;
  char *keep ;
  char *key___1 ;
  char *lengthHdr ;
  Conn *connPtr ;
  int doChunkEncoding ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  doChunkEncoding = 0;
  connPtr = (Conn *)conn;
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", connPtr->responseStatus);
  reason = (char *)"Unknown Reason";
  i = 0;
  while (i < nreasons) {
    if (reasons[i].status == connPtr->responseStatus) {
      reason = reasons[i].reason;
      break;
    }
    i ++;
  }
  doChunkEncoding = IsSetupForChunkedEncoding(conn);
  if (! doChunkEncoding) {
    Ns_DStringVarAppend(dsPtr, "HTTP/1.0 ", buf, " ", reason, "\r\n", (void *)0);
  } else {
    Ns_DStringVarAppend(dsPtr, "HTTP/1.1 ", buf, " ", reason, "\r\n", (void *)0);
  }
  if ((unsigned int )conn->outputheaders != (unsigned int )((void *)0)) {
    length = connPtr->responseLength;
    lengthHdr = Ns_SetIGet(conn->outputheaders, (char *)"content-length");
    if ((unsigned int )lengthHdr != (unsigned int )((void *)0)) {
      connPtr->responseLength = atoi__extinline((char const   *)lengthHdr);
    }
    if (nsconf.keepalive.enabled) {
      if ((unsigned int )connPtr->headers != (unsigned int )((void *)0)) {
        if ((unsigned int )connPtr->request != (unsigned int )((void *)0)) {
          if (connPtr->responseStatus >= 200) {
            if (connPtr->responseStatus < 300) {
              if ((unsigned int )lengthHdr != (unsigned int )((void *)0)) {
                if (connPtr->responseLength == length) {
                  goto _L___3;
                } else {
                  goto _L___5;
                }
              } else {
                goto _L___5;
              }
            } else {
              goto _L___5;
            }
          } else {
            _L___5: 
            if (doChunkEncoding) {
              goto _L___3;
            } else {
              if (connPtr->responseStatus == 304) {
                goto _L___3;
              } else {
                if (connPtr->responseStatus == 201) {
                  goto _L___3;
                } else {
                  if (connPtr->responseStatus == 207) {
                    _L___3: 
                    if (nsconf.keepalive.allmethods == 1) {
                      goto _L___1;
                    } else {
                      if ((int )(*((connPtr->request)->method)) == (int )(*"GET")) {
                        if (0) {
                          __s1_len = strlen((char const   *)(connPtr->request)->method);
                          __s2_len = strlen("GET");
                          if (! ((unsigned int )((void const   *)((connPtr->request)->method +
                                                                  1)) - (unsigned int )((void const   *)(connPtr->request)->method) ==
                                 1U)) {
                            goto _L___0;
                          } else {
                            if (__s1_len >= 4U) {
                              _L___0: 
                              if (! ((unsigned int )((void const   *)("GET" + 1)) -
                                     (unsigned int )((void const   *)"GET") == 1U)) {
                                tmp___6 = 1;
                              } else {
                                if (__s2_len >= 4U) {
                                  tmp___6 = 1;
                                } else {
                                  tmp___6 = 0;
                                }
                              }
                            } else {
                              tmp___6 = 0;
                            }
                          }
                          if (tmp___6) {
                            if (__s1_len < __s2_len) {
                              tmp___4 = __s1_len;
                            } else {
                              tmp___4 = __s2_len;
                            }
                            tmp___3 = memcmp((void const   *)((char const   *)(connPtr->request)->method),
                                             (void const   *)"GET", tmp___4 + 1U);
                          } else {
                            tmp___5 = strcmp((char const   *)(connPtr->request)->method,
                                             "GET");
                            tmp___3 = tmp___5;
                          }
                        } else {
                          tmp___5 = strcmp((char const   *)(connPtr->request)->method,
                                           "GET");
                          tmp___3 = tmp___5;
                        }
                        if (tmp___3 == 0) {
                          _L___1: 
                          key___1 = Ns_SetIGet(conn->headers, (char *)"connection");
                          if ((unsigned int )key___1 != (unsigned int )((void *)0)) {
                            tmp___7 = strcasecmp((char const   *)key___1, "keep-alive");
                            if (tmp___7 == 0) {
                              conn->flags = conn->flags | 32;
                              keep = (char *)"keep-alive";
                            } else {
                              keep = (char *)"close";
                            }
                          } else {
                            keep = (char *)"close";
                          }
                        } else {
                          keep = (char *)"close";
                        }
                      } else {
                        keep = (char *)"close";
                      }
                    }
                  } else {
                    keep = (char *)"close";
                  }
                }
              }
            }
          }
        } else {
          keep = (char *)"close";
        }
      } else {
        keep = (char *)"close";
      }
    } else {
      keep = (char *)"close";
    }
    Ns_ConnCondSetHeaders(conn, (char *)"Connection", keep);
    i = 0;
    while (i < (conn->outputheaders)->size) {
      key___1 = ((conn->outputheaders)->fields + i)->name;
      value = ((conn->outputheaders)->fields + i)->value;
      if ((unsigned int )key___1 != (unsigned int )((void *)0)) {
        if ((unsigned int )value != (unsigned int )((void *)0)) {
          Tcl_DStringAppend(dsPtr, key___1, -1);
          Tcl_DStringAppend(dsPtr, (char *)": ", 2);
          Tcl_DStringAppend(dsPtr, value, -1);
          Tcl_DStringAppend(dsPtr, (char *)"\r\n", 2);
        }
      }
      i ++;
    }
  }
  Tcl_DStringAppend(dsPtr, (char *)"\r\n", 2);
  return;
}
}
void Ns_ConnQueueHeaders(Ns_Conn *conn , int status ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  if (! (conn->flags & 16)) {
    connPtr->responseStatus = status;
    if (! (conn->flags & 2)) {
      Ns_ConnConstructHeaders(conn, & connPtr->queued);
      connPtr->nContentSent = connPtr->nContentSent - connPtr->queued.length;
    }
    conn->flags = conn->flags | 16;
  }
  return;
}
}
int Ns_ConnFlushHeaders(Ns_Conn *conn , int status ) 
{ int tmp ;

  {
  Ns_ConnQueueHeaders(conn, status);
  tmp = Ns_WriteConn(conn, (char *)((void *)0), 0);
  return (tmp);
}
}
void Ns_ConnSetHeaders(Ns_Conn *conn , char *field , char *value ) 
{ 

  {
  Ns_SetPut(conn->outputheaders, field, value);
  return;
}
}
void Ns_ConnCondSetHeaders(Ns_Conn *conn , char *field , char *value ) 
{ char *tmp ;

  {
  tmp = Ns_SetIGet(conn->outputheaders, field);
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
    Ns_SetPut(conn->outputheaders, field, value);
  }
  return;
}
}
void Ns_ConnReplaceHeaders(Ns_Conn *conn , Ns_Set *newheaders ) 
{ 

  {
  Ns_SetFree(conn->outputheaders);
  conn->outputheaders = Ns_SetCopy(newheaders);
  return;
}
}
void Ns_ConnSetRequiredHeaders(Ns_Conn *conn , char *type , int length ) 
{ Conn *connPtr ;
  Tcl_DString ds ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  connPtr = (Conn *)conn;
  Tcl_DStringInit(& ds);
  Ns_ConnCondSetHeaders(conn, (char *)"MIME-Version", (char *)"1.0");
  tmp = Ns_HttpTime(& ds, (time_t *)((void *)0));
  Ns_ConnCondSetHeaders(conn, (char *)"Date", tmp);
  Tcl_DStringSetLength(& ds, 0);
  if ((connPtr->servPtr)->opts.aolpress) {
    Tcl_DStringAppend(& ds, (char *)"NaviServer/2.0 ", -1);
  }
  tmp___0 = Ns_InfoServerVersion();
  tmp___1 = Ns_InfoServerName();
  Ns_DStringVarAppend(& ds, tmp___1, "/", tmp___0, (void *)0);
  Ns_ConnCondSetHeaders(conn, (char *)"Server", ds.string);
  if ((unsigned int )type != (unsigned int )((void *)0)) {
    Ns_ConnSetTypeHeader(conn, type);
  }
  if (length >= 0) {
    Ns_ConnSetLengthHeader(conn, length);
  }
  Tcl_DStringFree(& ds);
  return;
}
}
void Ns_ConnSetTypeHeader(Ns_Conn *conn , char *type ) 
{ 

  {
  Ns_ConnSetHeaders(conn, (char *)"Content-Type", type);
  return;
}
}
void Ns_ConnSetLengthHeader(Ns_Conn *conn , int length ) 
{ char buf[100] ;
  Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  connPtr->responseLength = length;
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", length);
  Ns_ConnSetHeaders(conn, (char *)"Content-Length", buf);
  return;
}
}
void Ns_ConnSetLastModifiedHeader(Ns_Conn *conn , time_t *mtime ) 
{ Tcl_DString ds ;
  char *tmp ;

  {
  Tcl_DStringInit(& ds);
  tmp = Ns_HttpTime(& ds, mtime);
  Ns_ConnCondSetHeaders(conn, (char *)"Last-Modified", tmp);
  Tcl_DStringFree(& ds);
  return;
}
}
void Ns_ConnSetExpiresHeader(Ns_Conn *conn , char *expires ) 
{ 

  {
  Ns_ConnSetHeaders(conn, (char *)"Expires", expires);
  return;
}
}
int Ns_ConnPrintfHeader(Ns_Conn *conn , char *fmt  , ...) 
{ int result ;
  Tcl_DString ds ;
  va_list ap ;

  {
  if ((unsigned int )conn->request == (unsigned int )((void *)0)) {
    return (0);
  } else {
    if ((conn->request)->version < 1.0) {
      return (0);
    }
  }
  Tcl_DStringInit(& ds);
  __builtin_stdarg_start(ap, fmt);
  Ns_DStringVPrintf(& ds, fmt, ap);
  __builtin_va_end(ap);
  result = Ns_ConnSendDString(conn, & ds);
  Tcl_DStringFree(& ds);
  return (result);
}
}
int Ns_ConnResetReturn(Ns_Conn *conn ) 
{ 

  {
  return (0);
}
}
int Ns_ConnReturnAdminNotice(Ns_Conn *conn , int status , char *title , char *notice ) 
{ int tmp ;

  {
  tmp = Ns_ConnReturnNotice(conn, status, title, notice);
  return (tmp);
}
}
int Ns_ConnReturnNotice(Ns_Conn *conn , int status , char *title , char *notice ) 
{ Conn *connPtr ;
  NsServer *servPtr ;
  Tcl_DString ds ;
  int result ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  connPtr = (Conn *)conn;
  servPtr = connPtr->servPtr;
  Tcl_DStringInit(& ds);
  if ((unsigned int )title == (unsigned int )((void *)0)) {
    title = (char *)"Server Message";
  }
  Ns_DStringVarAppend(& ds, "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<HTML>\n<HEAD>\n<TITLE>",
                      title, "</TITLE>\n</HEAD>\n<BODY>\n<H2>", title, "</H2>\n",
                      (void *)0);
  if ((unsigned int )notice != (unsigned int )((void *)0)) {
    Ns_DStringVarAppend(& ds, notice, "\n", (void *)0);
  }
  if (servPtr->opts.noticedetail) {
    tmp = Ns_ConnLocation(conn);
    tmp___0 = Ns_InfoServerVersion();
    tmp___1 = Ns_InfoServerName();
    Ns_DStringVarAppend(& ds, "<P ALIGN=RIGHT><SMALL><I>", tmp___1, "/", tmp___0,
                        " on ", tmp, "</I></SMALL></P>\n", (void *)0);
  }
  if (status >= 400) {
    while (ds.length < servPtr->limits.errorminsize) {
      Tcl_DStringAppend(& ds, (char *)"                    ", -1);
    }
  }
  Ns_DStringVarAppend(& ds, "\n</BODY></HTML>\n", (void *)0);
  result = Ns_ConnReturnHtml(conn, status, ds.string, ds.length);
  Tcl_DStringFree(& ds);
  return (result);
}
}
int Ns_ConnReturnData(Ns_Conn *conn , int status , char *data , int len , char *type ) 
{ int tmp ;

  {
  tmp = ReturnCharData(conn, status, data, len, type, 1);
  return (tmp);
}
}
int Ns_ConnReturnCharData(Ns_Conn *conn , int status , char *data , int len , char *type ) 
{ int tmp ;

  {
  tmp = ReturnCharData(conn, status, data, len, type, 0);
  return (tmp);
}
}
static int ReturnCharData(Ns_Conn *conn , int status , char *data , int len , char *type ,
                          int sendRaw ) 
{ int result ;
  Conn *connPtr ;
  Tcl_DString ds ;
  Tcl_Encoding enc___0 ;
  Tcl_DString type_ds ;
  int new_type ;

  {
  new_type = 0;
  connPtr = (Conn *)conn;
  if (! sendRaw) {
    NsComputeEncodingFromType(type, & enc___0, & new_type, & type_ds);
    if (new_type) {
      type = type_ds.string;
    }
    if ((unsigned int )enc___0 != (unsigned int )((void *)0)) {
      connPtr->encoding = enc___0;
    } else {
      if ((unsigned int )connPtr->encoding == (unsigned int )((void *)0)) {
        sendRaw = 1;
      }
    }
  }
  if (! sendRaw) {
    Tcl_UtfToExternalDString(connPtr->encoding, data, len, & ds);
    data = ds.string;
    len = ds.length;
  } else {
    if (len == -1) {
      if (data) {
        len = (int )strlen((char const   *)data);
      } else {
        len = 0;
      }
    }
  }
  Ns_ConnSetRequiredHeaders(conn, type, len);
  Ns_ConnQueueHeaders(conn, status);
  if (conn->flags & 4) {
    data = (char *)((void *)0);
    len = 0;
  }
  result = Ns_WriteConn(conn, data, len);
  if (result == 0) {
    result = Ns_ConnClose(conn);
  }
  if (! sendRaw) {
    if ((unsigned int )connPtr->encoding != (unsigned int )((void *)0)) {
      Tcl_DStringFree(& ds);
    }
  }
  if (new_type) {
    Tcl_DStringFree(& type_ds);
  }
  return (result);
}
}
int Ns_ConnReturnHtml(Ns_Conn *conn , int status , char *html , int len ) 
{ int tmp ;

  {
  tmp = Ns_ConnReturnData(conn, status, html, len, (char *)"text/html");
  return (tmp);
}
}
int Ns_ConnReturnOk(Ns_Conn *conn ) 
{ int tmp ;

  {
  tmp = Ns_ConnReturnStatus(conn, 200);
  return (tmp);
}
}
int Ns_ConnReturnNoResponse(Ns_Conn *conn ) 
{ int tmp ;

  {
  tmp = Ns_ConnReturnStatus(conn, 204);
  return (tmp);
}
}
int Ns_ConnReturnRedirect(Ns_Conn *conn , char *url ) 
{ Tcl_DString ds ;
  Tcl_DString msg ;
  int result ;
  char *tmp ;

  {
  Tcl_DStringInit(& ds);
  Tcl_DStringInit(& msg);
  if ((unsigned int )url != (unsigned int )((void *)0)) {
    if ((int )(*url) == 47) {
      tmp = Ns_ConnLocation(conn);
      Tcl_DStringAppend(& ds, tmp, -1);
    }
    Tcl_DStringAppend(& ds, url, -1);
    Ns_ConnSetHeaders(conn, (char *)"Location", ds.string);
    Ns_DStringVarAppend(& msg, "<A HREF=\"", ds.string, "\">The requested URL has moved here.</A>",
                        (void *)0);
    result = Ns_ConnReturnNotice(conn, 302, (char *)"Redirection", msg.string);
  } else {
    result = Ns_ConnReturnNotice(conn, 204, (char *)"No Content", msg.string);
  }
  Tcl_DStringFree(& msg);
  Tcl_DStringFree(& ds);
  return (result);
}
}
int Ns_ConnReturnBadRequest(Ns_Conn *conn , char *reason ) 
{ Tcl_DString ds ;
  int result ;
  int tmp ;

  {
  tmp = ReturnRedirect(conn, 400, & result);
  if (tmp) {
    return (result);
  }
  Tcl_DStringInit(& ds);
  Tcl_DStringAppend(& ds, (char *)"The HTTP request presented by your browser is invalid.",
                    -1);
  if ((unsigned int )reason != (unsigned int )((void *)0)) {
    Ns_DStringVarAppend(& ds, "<P>\n", reason, (void *)0);
  }
  result = Ns_ConnReturnNotice(conn, 400, (char *)"Invalid Request", ds.string);
  Tcl_DStringFree(& ds);
  return (result);
}
}
int Ns_ConnReturnUnauthorized(Ns_Conn *conn ) 
{ Conn *connPtr ;
  Tcl_DString ds ;
  int result ;
  int tmp ;
  int tmp___0 ;

  {
  connPtr = (Conn *)conn;
  Tcl_DStringInit(& ds);
  Ns_DStringVarAppend(& ds, "Basic realm=\"", (connPtr->servPtr)->opts.realm, "\"",
                      (void *)0);
  Ns_ConnSetHeaders(conn, (char *)"WWW-Authenticate", ds.string);
  Tcl_DStringFree(& ds);
  tmp = ReturnRedirect(conn, 401, & result);
  if (tmp) {
    return (result);
  }
  tmp___0 = Ns_ConnReturnNotice(conn, 401, (char *)"Access Denied", (char *)"The requested URL cannot be accessed because a valid username and password are required.");
  return (tmp___0);
}
}
int Ns_ConnReturnForbidden(Ns_Conn *conn ) 
{ int result ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = ReturnRedirect(conn, 403, & result);
  if (tmp) {
    return (result);
  }
  tmp___0 = Ns_ConnReturnNotice(conn, 403, (char *)"Forbidden", (char *)"The requested URL cannot be accessed by this server.");
  return (tmp___0);
}
}
int Ns_ConnReturnNotFound(Ns_Conn *conn ) 
{ int result ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = ReturnRedirect(conn, 404, & result);
  if (tmp) {
    return (result);
  }
  tmp___0 = Ns_ConnReturnNotice(conn, 404, (char *)"Not Found", (char *)"The requested URL was not found on this server.");
  return (tmp___0);
}
}
int Ns_ConnReturnNotModified(Ns_Conn *conn ) 
{ int tmp ;

  {
  tmp = Ns_ConnReturnStatus(conn, 304);
  return (tmp);
}
}
int Ns_ConnReturnNotImplemented(Ns_Conn *conn ) 
{ int result ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = ReturnRedirect(conn, 501, & result);
  if (tmp) {
    return (result);
  }
  tmp___0 = Ns_ConnReturnNotice(conn, 501, (char *)"Not Implemented", (char *)"The requested URL or method is not implemented by this server.");
  return (tmp___0);
}
}
int Ns_ConnReturnInternalError(Ns_Conn *conn ) 
{ int result ;
  int tmp ;
  int tmp___0 ;

  {
  Ns_SetTrunc(conn->outputheaders, 0);
  tmp = ReturnRedirect(conn, 500, & result);
  if (tmp) {
    return (result);
  }
  tmp___0 = Ns_ConnReturnNotice(conn, 500, (char *)"Server Error", (char *)"The requested URL cannot be accessed due to a system error on this server.");
  return (tmp___0);
}
}
int Ns_ConnReturnStatus(Ns_Conn *conn , int status ) 
{ int result ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = ReturnRedirect(conn, status, & result);
  if (tmp) {
    return (result);
  }
  Ns_ConnSetRequiredHeaders(conn, (char *)((void *)0), 0);
  Ns_ConnFlushHeaders(conn, status);
  tmp___0 = Ns_ConnClose(conn);
  return (tmp___0);
}
}
int Ns_ConnReturnOpenChannel(Ns_Conn *conn , int status , char *type , Tcl_Channel chan ,
                             int len ) 
{ int tmp ;

  {
  tmp = ReturnOpen(conn, status, type, chan, (FILE *)((void *)0), -1, len);
  return (tmp);
}
}
int Ns_ConnReturnOpenFile(Ns_Conn *conn , int status , char *type , FILE *fp , int len ) 
{ int tmp ;

  {
  tmp = ReturnOpen(conn, status, type, (struct Tcl_Channel_ *)((void *)0), fp, -1,
                   len);
  return (tmp);
}
}
int Ns_ConnReturnOpenFd(Ns_Conn *conn , int status , char *type , int fd , int len ) 
{ int tmp ;

  {
  tmp = ReturnOpen(conn, status, type, (struct Tcl_Channel_ *)((void *)0), (FILE *)((void *)0),
                   fd, len);
  return (tmp);
}
}
static int ReturnRedirect(Ns_Conn *conn , int status , int *resultPtr ) 
{ Tcl_HashEntry *hPtr ;
  Conn *connPtr ;
  NsServer *servPtr ;

  {
  connPtr = (Conn *)conn;
  servPtr = connPtr->servPtr;
  hPtr = ((*(servPtr->request.redirect.findProc)))(& servPtr->request.redirect, (char *)status);
  if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    connPtr->recursionCount = connPtr->recursionCount + 1;
    if (connPtr->recursionCount > 3) {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"return: failed to redirect \'%d\': exceeded recursion limit of %d",
             status, 3);
    } else {
      (*resultPtr) = Ns_ConnRedirect(conn, (char *)hPtr->clientData);
      return (1);
    }
  }
  return (0);
}
}
static int ReturnOpen(Ns_Conn *conn , int status , char *type , Tcl_Channel chan ,
                      FILE *fp , int fd , int len ) 
{ int result ;

  {
  Ns_ConnSetRequiredHeaders(conn, type, len);
  Ns_ConnQueueHeaders(conn, status);
  if ((unsigned int )chan != (unsigned int )((void *)0)) {
    result = Ns_ConnSendChannel(conn, chan, len);
  } else {
    if ((unsigned int )fp != (unsigned int )((void *)0)) {
      result = Ns_ConnSendFp(conn, fp, len);
    } else {
      result = Ns_ConnSendFd(conn, fd, len);
    }
  }
  if (result == 0) {
    result = Ns_ConnClose(conn);
  }
  return (result);
}
}
extern DIR *opendir(char const   *__name ) ;
extern int closedir(DIR *__dirp ) ;
extern int rename(char const   *__old , char const   *__new ) ;
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) ) ;
struct dirent *ns_readdir(DIR *dir ) ;
int Ns_PurgeFiles(char *file___1 , int max ) ;
int Ns_RollFileByDate(char *file___1 , int max ) ;
static int AppendFile(Tcl_DString *dsPtr , char *dir , char *tail ) ;
static int CmpFile(void const   *arg1 , void const   *arg2 ) ;
static int Rename(char *from , char *to ) ;
static int Exists(char *file___1 ) ;
static int Unlink(char *file___1 ) ;
int Ns_RollFile(char *file___1 , int max ) 
{ char *first___1 ;
  char *next ;
  char *dot ;
  int num ;
  int err ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  if (max < 0) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"rollfile: invalid max parameter \'%d\'; must be > 0 and < 999",
           max);
    return (-1);
  } else {
    if (max > 999) {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"rollfile: invalid max parameter \'%d\'; must be > 0 and < 999",
             max);
      return (-1);
    }
  }
  tmp = strlen((char const   *)file___1);
  first___1 = (char *)ns_malloc(tmp + 5U);
  sprintf((char * __restrict  )first___1, (char const   * __restrict  )"%s.000", file___1);
  err = Exists(first___1);
  if (err > 0) {
    next = ns_strdup((char const   *)first___1);
    num = 0;
    while (1) {
      tmp___0 = strrchr((char const   *)next, '.');
      dot = tmp___0 + 1;
      tmp___1 = num;
      num ++;
      sprintf((char * __restrict  )dot, (char const   * __restrict  )"%03d", tmp___1);
      err = Exists(next);
      if (err == 1) {
        if (! (num < max)) {
          break;
        }
      } else {
        break;
      }
    }
    num --;
    if (err == 1) {
      err = Unlink(next);
    }
    while (1) {
      if (err == 0) {
        tmp___4 = num;
        num --;
        if (! (tmp___4 > 0)) {
          break;
        }
      } else {
        break;
      }
      tmp___2 = strrchr((char const   *)first___1, '.');
      dot = tmp___2 + 1;
      sprintf((char * __restrict  )dot, (char const   * __restrict  )"%03d", num);
      tmp___3 = strrchr((char const   *)next, '.');
      dot = tmp___3 + 1;
      sprintf((char * __restrict  )dot, (char const   * __restrict  )"%03d", num +
                                                                             1);
      err = Rename(first___1, next);
    }
    ns_free((void *)next);
  }
  if (err == 0) {
    err = Exists(file___1);
    if (err > 0) {
      err = Rename(file___1, first___1);
    }
  }
  ns_free((void *)first___1);
  if (err != 0) {
    return (-1);
  }
  return (0);
}
}
int Ns_RollFileByDate(char *file___1 , int max ) 
{ int tmp ;

  {
  tmp = Ns_PurgeFiles(file___1, max);
  return (tmp);
}
}
int Ns_PurgeFiles(char *file___1 , int max ) 
{ char *slash ;
  char *tail ;
  DIR *dp ;
  struct dirent *ent ;
  File___0 **files ;
  int tlen ;
  int i ;
  int nfiles ;
  int status ;
  Tcl_DString dir ;
  Tcl_DString list ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;

  {
  status = -1;
  Tcl_DStringInit(& dir);
  Tcl_DStringInit(& list);
  Ns_NormalizePath(& dir, file___1);
  slash = strrchr((char const   *)dir.string, '/');
  if ((unsigned int )slash == (unsigned int )((void *)0)) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"rollfile: failed to purge files: invalid path \'%s\'",
           file___1);
    goto err;
  } else {
    if ((int )(*(slash + 1)) == 0) {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"rollfile: failed to purge files: invalid path \'%s\'",
             file___1);
      goto err;
    }
  }
  (*slash) = (char )'\000';
  tail = slash + 1;
  tlen = (int )strlen((char const   *)tail);
  dp = opendir((char const   *)dir.string);
  if ((unsigned int )dp == (unsigned int )((void *)0)) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"rollfile: failed to purge files:opendir(%s) failed: \'%s\'",
           dir.string, tmp___0);
    goto err;
  }
  while (1) {
    ent = ns_readdir(dp);
    if (! ((unsigned int )ent != (unsigned int )((void *)0))) {
      break;
    }
    if (0) {
      if (0) {
        __s1_len___0 = strlen((char const   *)tail);
        __s2_len___0 = strlen((char const   *)(ent->d_name));
        if (! ((unsigned int )((void const   *)(tail + 1)) - (unsigned int )((void const   *)tail) ==
               1U)) {
          goto _L___2;
        } else {
          if (__s1_len___0 >= 4U) {
            _L___2: 
            if (! ((unsigned int )((void const   *)(ent->d_name + 1)) - (unsigned int )((void const   *)(ent->d_name)) ==
                   1U)) {
              tmp___20 = 1;
            } else {
              if (__s2_len___0 >= 4U) {
                tmp___20 = 1;
              } else {
                tmp___20 = 0;
              }
            }
          } else {
            tmp___20 = 0;
          }
        }
        if (tmp___20) {
          if (__s1_len___0 < __s2_len___0) {
            tmp___18 = __s1_len___0;
          } else {
            tmp___18 = __s2_len___0;
          }
          tmp___17 = memcmp((void const   *)((char const   *)tail), (void const   *)((char const   *)(ent->d_name)),
                            tmp___18 + 1U);
        } else {
          tmp___19 = strcmp((char const   *)tail, (char const   *)(ent->d_name));
          tmp___17 = tmp___19;
        }
      } else {
        tmp___19 = strcmp((char const   *)tail, (char const   *)(ent->d_name));
        tmp___17 = tmp___19;
      }
      tmp___12 = tmp___17;
    } else {
      tmp___12 = strncmp((char const   *)tail, (char const   *)(ent->d_name), (unsigned int )tlen);
    }
    if (tmp___12 != 0) {
      continue;
    }
    tmp___23 = AppendFile(& list, dir.string, ent->d_name);
    if (! tmp___23) {
      closedir(dp);
      goto err;
    }
  }
  closedir(dp);
  nfiles = (int )((unsigned int )list.length / sizeof(File___0 *));
  if (nfiles >= max) {
    files = (File___0 **)list.string;
    qsort((void *)files, (unsigned int )nfiles, sizeof(File___0 *), & CmpFile);
    i = max;
    while (i < nfiles) {
      tmp___24 = Unlink(((*(files + i)))->name);
      if (tmp___24 != 0) {
        goto err;
      }
      i ++;
    }
  }
  status = 0;
  err: 
  nfiles = (int )((unsigned int )list.length / sizeof(File___0 *));
  if (nfiles > 0) {
    files = (File___0 **)list.string;
    i = 0;
    while (i < nfiles) {
      ns_free((void *)(*(files + i)));
      i ++;
    }
  }
  Tcl_DStringFree(& list);
  Tcl_DStringFree(& dir);
  return (status);
}
}
static int AppendFile(Tcl_DString *dsPtr , char *dir , char *tail ) 
{ File___0 *fPtr ;
  struct stat st ;
  size_t tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  tmp = strlen((char const   *)dir);
  tmp___0 = strlen((char const   *)tail);
  fPtr = (File___0 *)ns_malloc((sizeof(File___0 ) + tmp) + tmp___0);
  sprintf((char * __restrict  )(fPtr->name), (char const   * __restrict  )"%s/%s",
          dir, tail);
  tmp___3 = stat__extinline((char const   *)(fPtr->name), & st);
  if (tmp___3 != 0) {
    tmp___1 = __errno_location();
    tmp___2 = strerror((*tmp___1));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"rollfile: failed to append to file \'%s\': \'%s\'",
           fPtr->name, tmp___2);
    ns_free((void *)fPtr);
    return (0);
  }
  fPtr->mtime = st.st_mtim.tv_sec;
  Tcl_DStringAppend(dsPtr, (char *)(& fPtr), (int )sizeof(File___0 *));
  return (1);
}
}
static int CmpFile(void const   *arg1 , void const   *arg2 ) 
{ File___0 *f1Ptr ;
  File___0 *f2Ptr ;

  {
  f1Ptr = (*((File___0 **)arg1));
  f2Ptr = (*((File___0 **)arg2));
  if (f1Ptr->mtime < f2Ptr->mtime) {
    return (1);
  } else {
    if (f1Ptr->mtime > f2Ptr->mtime) {
      return (-1);
    }
  }
  return (0);
}
}
static int Unlink(char *file___1 ) 
{ int err ;
  int *tmp ;
  char *tmp___0 ;

  {
  err = unlink((char const   *)file___1);
  if (err != 0) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"rollfile: failed to delete file \'%s\': \'%s\'",
           file___1, tmp___0);
  }
  return (err);
}
}
static int Rename(char *from , char *to ) 
{ int err ;
  int *tmp ;
  char *tmp___0 ;

  {
  err = rename((char const   *)from, (char const   *)to);
  if (err != 0) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"rollfile: failed to rename file \'%s\' to \'%s\': \'%s\'",
           from, to, tmp___0);
  }
  return (err);
}
}
static int Exists(char *file___1 ) 
{ int exists ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  tmp___2 = access((char const   *)file___1, 0);
  if (tmp___2 == 0) {
    exists = 1;
  } else {
    tmp___1 = __errno_location();
    if ((*tmp___1) == 2) {
      exists = 0;
    } else {
      tmp = __errno_location();
      tmp___0 = strerror((*tmp));
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"rollfile: failed to determine if file \'%s\' exists: \'%s\'",
             file___1, tmp___0);
      exists = -1;
    }
  }
  return (exists);
}
}
extern time_t mktime(struct tm *__tp ) ;
int Ns_After(int delay , Ns_Callback *proc , void *arg , Ns_Callback *deleteProc ) ;
int Ns_Pause(int id ) ;
int Ns_Resume(int id ) ;
int Ns_ScheduleDaily(Ns_SchedProc *proc , void *clientData , int flags , int hour ,
                     int minute , Ns_SchedProc *cleanupProc ) ;
int Ns_ScheduleWeekly(Ns_SchedProc *proc , void *clientData , int flags , int day ,
                      int hour , int minute , Ns_SchedProc *cleanupProc ) ;
int Ns_ScheduleProcEx(Ns_SchedProc *proc , void *arg , int flags , int interval ,
                      Ns_SchedProc *deleteProc ) ;
void Ns_UnscheduleProc(int id ) ;
static void SchedThread(void *ignored ) ;
static void EventThread(void *arg ) ;
static void QueueEvent(Event *ePtr , time_t *nowPtr ) ;
static Event *DeQueueEvent(int k ) ;
static void FreeEvent(Event *ePtr ) ;
static Tcl_HashTable eventsTable  ;
static Ns_Mutex lock___9  ;
static Ns_Cond schedcond  ;
static Ns_Cond eventcond  ;
static Event **queue  ;
static int nqueue  ;
static int maxqueue  ;
static int running  ;
static int shutdownPending___1  ;
static Ns_Thread schedThread  ;
static int nThreads  ;
static int nIdleThreads  ;
static Event *threadEventPtr  ;
static Ns_Thread *eventThreads  ;
void NsInitSched(void) 
{ 

  {
  Ns_MutexInit(& lock___9);
  Ns_MutexSetName(& lock___9, (char *)"ns:sched");
  Tcl_InitHashTable(& eventsTable, 1);
  return;
}
}
int Ns_After(int delay , Ns_Callback *proc , void *arg , Ns_Callback *deleteProc ) 
{ int tmp ;

  {
  if (delay < 0) {
    return (-1);
  }
  tmp = Ns_ScheduleProcEx((Ns_SchedProc *)proc, arg, 2, delay, (Ns_SchedProc *)deleteProc);
  return (tmp);
}
}
int Ns_ScheduleProc(Ns_Callback *proc , void *arg , int thread , int interval ) 
{ int tmp ;
  int tmp___0 ;

  {
  if (interval < 0) {
    return (-1);
  }
  if (thread) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  tmp___0 = Ns_ScheduleProcEx((Ns_SchedProc *)proc, arg, tmp, interval, (Ns_SchedProc *)((void *)0));
  return (tmp___0);
}
}
int Ns_ScheduleDaily(Ns_SchedProc *proc , void *clientData , int flags , int hour ,
                     int minute , Ns_SchedProc *cleanupProc ) 
{ int seconds ;
  int tmp ;

  {
  if (hour > 23) {
    return (-1);
  } else {
    if (hour < 0) {
      return (-1);
    } else {
      if (minute > 59) {
        return (-1);
      } else {
        if (minute < 0) {
          return (-1);
        }
      }
    }
  }
  seconds = hour * 3600 + minute * 60;
  tmp = Ns_ScheduleProcEx(proc, clientData, flags | 4, seconds, cleanupProc);
  return (tmp);
}
}
int Ns_ScheduleWeekly(Ns_SchedProc *proc , void *clientData , int flags , int day ,
                      int hour , int minute , Ns_SchedProc *cleanupProc ) 
{ int seconds ;
  int tmp ;

  {
  if (day < 0) {
    return (-1);
  } else {
    if (day > 6) {
      return (-1);
    } else {
      if (hour > 23) {
        return (-1);
      } else {
        if (hour < 0) {
          return (-1);
        } else {
          if (minute > 59) {
            return (-1);
          } else {
            if (minute < 0) {
              return (-1);
            }
          }
        }
      }
    }
  }
  seconds = (day * 24 + hour) * 3600 + minute * 60;
  tmp = Ns_ScheduleProcEx(proc, clientData, flags | 8, seconds, cleanupProc);
  return (tmp);
}
}
static int nextId___0  ;
int Ns_ScheduleProcEx(Ns_SchedProc *proc , void *arg , int flags , int interval ,
                      Ns_SchedProc *deleteProc ) 
{ Event *ePtr ;
  int id ;
  int new ;
  time_t now ;
  int tmp ;

  {
  if (interval < 0) {
    return (-1);
  }
  time(& now);
  ePtr = (Event *)ns_malloc(sizeof(Event ));
  ePtr->flags = flags;
  ePtr->nextqueue = 0L;
  ePtr->lastend = -1L;
  ePtr->laststart = ePtr->lastend;
  ePtr->lastqueue = ePtr->laststart;
  ePtr->interval = interval;
  ePtr->proc = proc;
  ePtr->deleteProc = deleteProc;
  ePtr->arg = arg;
  Ns_MutexLock(& lock___9);
  if (shutdownPending___1) {
    id = -1;
    ns_free((void *)ePtr);
  } else {
    while (1) {
      tmp = nextId___0;
      nextId___0 ++;
      id = tmp;
      if (nextId___0 < 0) {
        nextId___0 = 0;
      }
      ePtr->hPtr = ((*(eventsTable.createProc)))(& eventsTable, (char *)id, & new);
      if (! (! new)) {
        break;
      }
    }
    (ePtr->hPtr)->clientData = (void *)ePtr;
    ePtr->id = (unsigned int )id;
    QueueEvent(ePtr, & now);
  }
  Ns_MutexUnlock(& lock___9);
  return (id);
}
}
void Ns_UnscheduleProc(int id ) 
{ 

  {
  Ns_Cancel(id);
  return;
}
}
int Ns_Cancel(int id ) 
{ Tcl_HashEntry *hPtr ;
  Event *ePtr ;
  int cancelled ;

  {
  hPtr = (Tcl_HashEntry *)((void *)0);
  ePtr = (Event *)((void *)0);
  cancelled = 0;
  Ns_MutexLock(& lock___9);
  if (! shutdownPending___1) {
    hPtr = ((*(eventsTable.findProc)))(& eventsTable, (char *)id);
    if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
      ePtr = (Event *)hPtr->clientData;
      Tcl_DeleteHashEntry(hPtr);
      ePtr->hPtr = (Tcl_HashEntry *)((void *)0);
      if (ePtr->qid > 0) {
        DeQueueEvent(ePtr->qid);
        cancelled = 1;
      }
    }
  }
  Ns_MutexUnlock(& lock___9);
  if (cancelled) {
    FreeEvent(ePtr);
  }
  return (cancelled);
}
}
int Ns_Pause(int id ) 
{ Tcl_HashEntry *hPtr ;
  Event *ePtr ;
  int paused ;

  {
  paused = 0;
  Ns_MutexLock(& lock___9);
  if (! shutdownPending___1) {
    hPtr = ((*(eventsTable.findProc)))(& eventsTable, (char *)id);
    if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
      ePtr = (Event *)hPtr->clientData;
      if (! (ePtr->flags & 16)) {
        ePtr->flags |= 16;
        if (ePtr->qid > 0) {
          DeQueueEvent(ePtr->qid);
        }
        paused = 1;
      }
    }
  }
  Ns_MutexUnlock(& lock___9);
  return (paused);
}
}
int Ns_Resume(int id ) 
{ Tcl_HashEntry *hPtr ;
  Event *ePtr ;
  int resumed ;
  time_t now ;

  {
  resumed = 0;
  Ns_MutexLock(& lock___9);
  if (! shutdownPending___1) {
    hPtr = ((*(eventsTable.findProc)))(& eventsTable, (char *)id);
    if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
      ePtr = (Event *)hPtr->clientData;
      if (ePtr->flags & 16) {
        ePtr->flags &= -17;
        time(& now);
        QueueEvent(ePtr, & now);
        resumed = 1;
      }
    }
  }
  Ns_MutexUnlock(& lock___9);
  return (resumed);
}
}
void NsStartSchedShutdown(void) 
{ 

  {
  Ns_MutexLock(& lock___9);
  if (running) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"sched: shutdown pending");
    shutdownPending___1 = 1;
    Ns_CondSignal(& schedcond);
  }
  Ns_MutexUnlock(& lock___9);
  return;
}
}
void NsWaitSchedShutdown(Ns_Time *toPtr ) 
{ int status ;

  {
  Ns_MutexLock(& lock___9);
  status = 0;
  while (1) {
    if (status == 0) {
      if (! running) {
        break;
      }
    } else {
      break;
    }
    status = Ns_CondTimedWait(& schedcond, & lock___9, toPtr);
  }
  Ns_MutexUnlock(& lock___9);
  if (status != 0) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"sched: timeout waiting for sched exit");
  } else {
    if ((unsigned int )schedThread != (unsigned int )((void *)0)) {
      Ns_ThreadJoin(& schedThread, (void **)((void *)0));
    }
  }
  return;
}
}
static void QueueEvent(Event *ePtr , time_t *nowPtr ) 
{ struct tm *tp___1 ;
  int tmp ;
  int j ;
  int k ;
  Event *tmp___0 ;

  {
  if (ePtr->flags & 16) {
    return;
  }
  if (ePtr->flags & 12) {
    tp___1 = ns_localtime((time_t const   *)nowPtr);
    tp___1->tm_sec = ePtr->interval;
    tp___1->tm_hour = 0;
    tp___1->tm_min = 0;
    if (ePtr->flags & 8) {
      tp___1->tm_mday = tp___1->tm_mday - tp___1->tm_wday;
    }
    ePtr->nextqueue = mktime(tp___1);
    if (ePtr->nextqueue <= (*nowPtr)) {
      if (ePtr->flags & 8) {
        tmp = 7;
      } else {
        tmp = 1;
      }
      tp___1->tm_mday = tp___1->tm_mday + tmp;
      ePtr->nextqueue = mktime(tp___1);
    }
  } else {
    ePtr->nextqueue = (*nowPtr) + (long )ePtr->interval;
  }
  nqueue ++;
  ePtr->qid = nqueue;
  if (maxqueue <= nqueue) {
    maxqueue += 1000;
    queue = (Event **)ns_realloc((void *)queue, sizeof(Event *) * (unsigned int )(maxqueue +
                                                                                  1));
  }
  (*(queue + nqueue)) = ePtr;
  if (nqueue > 1) {
    k = nqueue;
    j = k / 2;
    while (1) {
      if (k > 1) {
        if (! (((*(queue + j)))->nextqueue > ((*(queue + k)))->nextqueue)) {
          break;
        }
      } else {
        break;
      }
      tmp___0 = (*(queue + j));
      (*(queue + j)) = (*(queue + k));
      (*(queue + k)) = tmp___0;
      ((*(queue + j)))->qid = j;
      ((*(queue + k)))->qid = k;
      k = j;
      j = k / 2;
    }
  }
  if (running) {
    Ns_CondSignal(& schedcond);
  } else {
    running = 1;
    Ns_ThreadCreate(& SchedThread, (void *)0, 0L, & schedThread);
  }
  return;
}
}
static Event *DeQueueEvent(int k ) 
{ Event *ePtr ;
  int j ;
  Event *tmp ;
  int tmp___0 ;
  Event *tmp___1 ;

  {
  tmp = (*(queue + k));
  (*(queue + k)) = (*(queue + nqueue));
  (*(queue + nqueue)) = tmp;
  ((*(queue + k)))->qid = k;
  ((*(queue + nqueue)))->qid = nqueue;
  tmp___0 = nqueue;
  nqueue --;
  ePtr = (*(queue + tmp___0));
  ePtr->qid = 0;
  while (1) {
    j = 2 * k;
    if (! (j <= nqueue)) {
      break;
    }
    if (j < nqueue) {
      if (((*(queue + j)))->nextqueue > ((*(queue + (j + 1))))->nextqueue) {
        j ++;
      }
    }
    if (((*(queue + j)))->nextqueue > ((*(queue + k)))->nextqueue) {
      break;
    }
    tmp___1 = (*(queue + k));
    (*(queue + k)) = (*(queue + j));
    (*(queue + j)) = tmp___1;
    ((*(queue + k)))->qid = k;
    ((*(queue + j)))->qid = j;
    k = j;
  }
  return (ePtr);
}
}
static void EventThread(void *arg ) 
{ Event *ePtr ;
  char name[20] ;
  char idle[20] ;
  time_t now ;

  {
  sprintf((char * __restrict  )(idle), (char const   * __restrict  )"-sched:idle%d-",
          (int )arg);
  Ns_ThreadSetName(idle);
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"starting");
  Ns_MutexLock(& lock___9);
  while (1) {
    while (1) {
      if ((unsigned int )threadEventPtr == (unsigned int )((void *)0)) {
        if (! (! shutdownPending___1)) {
          break;
        }
      } else {
        break;
      }
      Ns_CondWait(& eventcond, & lock___9);
    }
    if ((unsigned int )threadEventPtr == (unsigned int )((void *)0)) {
      break;
    }
    ePtr = threadEventPtr;
    threadEventPtr = ePtr->nextPtr;
    if ((unsigned int )threadEventPtr != (unsigned int )((void *)0)) {
      Ns_CondSignal(& eventcond);
    }
    nIdleThreads --;
    Ns_MutexUnlock(& lock___9);
    sprintf((char * __restrict  )(name), (char const   * __restrict  )"-sched:%u-",
            ePtr->id);
    Ns_ThreadSetName(name);
    ((*(ePtr->proc)))(ePtr->arg, (int )ePtr->id);
    Ns_ThreadSetName(idle);
    time(& now);
    Ns_MutexLock(& lock___9);
    nIdleThreads ++;
    if ((unsigned int )ePtr->hPtr == (unsigned int )((void *)0)) {
      Ns_MutexUnlock(& lock___9);
      FreeEvent(ePtr);
      Ns_MutexLock(& lock___9);
    } else {
      ePtr->flags &= -33;
      ePtr->lastend = now;
      QueueEvent(ePtr, & now);
    }
  }
  Ns_MutexUnlock(& lock___9);
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"exiting");
  return;
}
}
static void FreeEvent(Event *ePtr ) 
{ 

  {
  if ((unsigned int )ePtr->deleteProc != (unsigned int )((void *)0)) {
    ((*(ePtr->deleteProc)))(ePtr->arg, (int )ePtr->id);
  }
  ns_free((void *)ePtr);
  return;
}
}
static void SchedThread(void *ignored ) 
{ Event *ePtr ;
  Event *readyPtr ;
  time_t now ;
  Ns_Time timeout ;
  int elapsed ;
  Ns_Thread *joinThreads ;
  int nJoinThreads ;
  int tmp___0 ;

  {
  Ns_WaitForStartup();
  Ns_ThreadSetName((char *)"-sched-");
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"sched: starting");
  readyPtr = (Event *)((void *)0);
  Ns_MutexLock(& lock___9);
  while (! shutdownPending___1) {
    time(& now);
    while (1) {
      if (nqueue > 0) {
        if (! (((*(queue + 1)))->nextqueue <= now)) {
          break;
        }
      } else {
        break;
      }
      ePtr = DeQueueEvent(1);
      if (ePtr->flags & 2) {
        Tcl_DeleteHashEntry(ePtr->hPtr);
        ePtr->hPtr = (Tcl_HashEntry *)((void *)0);
      }
      ePtr->lastqueue = now;
      if (ePtr->flags & 1) {
        ePtr->flags |= 32;
        ePtr->laststart = now;
        ePtr->nextPtr = threadEventPtr;
        threadEventPtr = ePtr;
      } else {
        ePtr->nextPtr = readyPtr;
        readyPtr = ePtr;
      }
    }
    if ((unsigned int )threadEventPtr != (unsigned int )((void *)0)) {
      if (nIdleThreads == 0) {
        eventThreads = (Ns_Thread *)ns_realloc((void *)eventThreads, sizeof(Ns_Thread ) *
                                                                     (unsigned int )(nThreads +
                                                                                     1));
        Ns_ThreadCreate(& EventThread, (void *)nThreads, 0L, eventThreads + nThreads);
        nIdleThreads ++;
        nThreads ++;
      }
      Ns_CondSignal(& eventcond);
    }
    while (1) {
      ePtr = readyPtr;
      if (! ((unsigned int )ePtr != (unsigned int )((void *)0))) {
        break;
      }
      readyPtr = ePtr->nextPtr;
      ePtr->laststart = now;
      ePtr->flags |= 32;
      Ns_MutexUnlock(& lock___9);
      ((*(ePtr->proc)))(ePtr->arg, (int )ePtr->id);
      time(& now);
      elapsed = (int )difftime(now, ePtr->laststart);
      if (elapsed > nsconf.sched.maxelapsed) {
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"sched: excessive time taken by proc %d (%d seconds)",
               ePtr->id, elapsed);
      }
      if ((unsigned int )ePtr->hPtr == (unsigned int )((void *)0)) {
        FreeEvent(ePtr);
        ePtr = (Event *)((void *)0);
      }
      Ns_MutexLock(& lock___9);
      if ((unsigned int )ePtr != (unsigned int )((void *)0)) {
        ePtr->flags &= -33;
        ePtr->lastend = now;
        QueueEvent(ePtr, & now);
      }
    }
    if (nqueue == 0) {
      Ns_CondWait(& schedcond, & lock___9);
    } else {
      if (! shutdownPending___1) {
        timeout.sec = ((*(queue + 1)))->nextqueue;
        timeout.usec = 0L;
        Ns_CondTimedWait(& schedcond, & lock___9, & timeout);
      }
    }
  }
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"sched: shutdown started");
  if (nThreads > 0) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"sched: waiting for event threads...");
    Ns_CondBroadcast(& eventcond);
    while (nThreads > 0) {
      joinThreads = eventThreads;
      nJoinThreads = nThreads;
      eventThreads = (Ns_Thread *)((void *)0);
      nThreads = 0;
      Ns_MutexUnlock(& lock___9);
      while (1) {
        nJoinThreads --;
        if (! (nJoinThreads >= 0)) {
          break;
        }
        Ns_ThreadJoin(joinThreads + nJoinThreads, (void **)((void *)0));
      }
      ns_free((void *)joinThreads);
      Ns_MutexLock(& lock___9);
    }
  }
  Ns_MutexUnlock(& lock___9);
  while (nqueue > 0) {
    tmp___0 = nqueue;
    nqueue --;
    FreeEvent((*(queue + tmp___0)));
  }
  ns_free((void *)queue);
  Tcl_DeleteHashTable(& eventsTable);
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"sched: shutdown complete");
  Ns_MutexLock(& lock___9);
  running = 0;
  Ns_CondBroadcast(& schedcond);
  Ns_MutexUnlock(& lock___9);
  return;
}
}
void NsGetScheduled(Tcl_DString *dsPtr ) 
{ Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  Event *ePtr ;
  time_t now ;
  char buf[100] ;

  {
  time(& now);
  Ns_MutexLock(& lock___9);
  hPtr = Tcl_FirstHashEntry(& eventsTable, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    ePtr = (Event *)hPtr->clientData;
    Tcl_DStringStartSublist(dsPtr);
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%u %d %d %ld %ld %ld %ld",
            ePtr->id, ePtr->flags, ePtr->interval, ePtr->nextqueue, ePtr->lastqueue,
            ePtr->laststart, ePtr->lastend);
    Tcl_DStringAppend(dsPtr, buf, -1);
    Ns_GetProcInfo(dsPtr, (void *)ePtr->proc, ePtr->arg);
    Tcl_DStringEndSublist(dsPtr);
    hPtr = Tcl_NextHashEntry(& search);
  }
  Ns_MutexUnlock(& lock___9);
  return;
}
}
extern Tcl_Obj *Tcl_NewObj(void) ;
void Ns_RWLockInit(Ns_RWLock *rwPtr ) ;
void Ns_CondInit(Ns_Cond *cond___9 ) ;
void NsTclInitServer(char *server ) ;
struct Bucket *NsTclCreateBuckets(char *server , int n ) ;
static void CreatePool(NsServer *servPtr , char *pool ) ;
static NsServer *initServPtr  ;
NsServer *NsGetServer(char *server ) 
{ Tcl_HashEntry *hPtr ;

  {
  if ((unsigned int )server != (unsigned int )((void *)0)) {
    hPtr = ((*(nsconf.servertable.findProc)))(& nsconf.servertable, server);
    if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
      return ((NsServer *)hPtr->clientData);
    }
  }
  return ((NsServer *)((void *)0));
}
}
NsServer *NsGetInitServer(void) 
{ 

  {
  return (initServPtr);
}
}
void NsStartServers(void) 
{ NsServer *servPtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;

  {
  hPtr = Tcl_FirstHashEntry(& nsconf.servertable, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    servPtr = (NsServer *)hPtr->clientData;
    NsStartServer(servPtr);
    hPtr = Tcl_NextHashEntry(& search);
  }
  return;
}
}
void NsStopServers(Ns_Time *toPtr ) 
{ NsServer *servPtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;

  {
  hPtr = Tcl_FirstHashEntry(& nsconf.servertable, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    servPtr = (NsServer *)hPtr->clientData;
    NsStopServer(servPtr);
    hPtr = Tcl_NextHashEntry(& search);
  }
  hPtr = Tcl_FirstHashEntry(& nsconf.servertable, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    servPtr = (NsServer *)hPtr->clientData;
    NsWaitServer(servPtr, toPtr);
    hPtr = Tcl_NextHashEntry(& search);
  }
  return;
}
}
void NsInitServer(char *server , Ns_ServerInitProc *initProc ) 
{ Tcl_HashEntry *hPtr ;
  Tcl_DString ds ;
  NsServer *servPtr ;
  char *path ;
  char *spath ;
  char *map ;
  char *key___1 ;
  char *dirf ;
  char *p ;
  Ns_Set *set ;
  int i ;
  int n ;
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___16 ;
  char *tmp___18 ;
  char *tmp___19 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;

  {
  hPtr = ((*(nsconf.servertable.createProc)))(& nsconf.servertable, server, & n);
  if (! n) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"duplicate server: %s",
           server);
    return;
  }
  Tcl_DStringAppendElement(& nsconf.servers, server);
  servPtr = (NsServer *)ns_calloc(1U, sizeof(NsServer ));
  hPtr->clientData = (void *)servPtr;
  initServPtr = servPtr;
  Tcl_DStringInit(& ds);
  path = Ns_ConfigGetPath(server, (char *)((void *)0), (void *)0);
  spath = path;
  servPtr->server = server;
  servPtr->opts.realm = Ns_ConfigGetValue(path, (char *)"realm");
  if ((unsigned int )servPtr->opts.realm == (unsigned int )((void *)0)) {
    servPtr->opts.realm = server;
  }
  tmp = Ns_ConfigGetBool(path, (char *)"enableaolpress", & servPtr->opts.aolpress);
  if (! tmp) {
    servPtr->opts.aolpress = 0;
  }
  tmp___0 = Ns_ConfigGetBool(path, (char *)"checkmodifiedsince", & servPtr->opts.modsince);
  if (! tmp___0) {
    servPtr->opts.modsince = 1;
  }
  tmp___1 = Ns_ConfigGetBool(path, (char *)"flushcontent", & servPtr->opts.flushcontent);
  if (! tmp___1) {
    servPtr->opts.flushcontent = 0;
  }
  tmp___2 = Ns_ConfigGetBool(path, (char *)"noticedetail", & servPtr->opts.noticedetail);
  if (! tmp___2) {
    servPtr->opts.noticedetail = 1;
  }
  p = Ns_ConfigGetValue(path, (char *)"headercase");
  if ((unsigned int )p != (unsigned int )((void *)0)) {
    tmp___4 = strcasecmp((char const   *)p, "tolower");
    if (tmp___4 == 0) {
      servPtr->opts.hdrcase = (enum __anonenum_Ns_HeaderCaseDisposition_68 )1;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )p != (unsigned int )((void *)0)) {
      tmp___3 = strcasecmp((char const   *)p, "toupper");
      if (tmp___3 == 0) {
        servPtr->opts.hdrcase = (enum __anonenum_Ns_HeaderCaseDisposition_68 )2;
      } else {
        servPtr->opts.hdrcase = (enum __anonenum_Ns_HeaderCaseDisposition_68 )0;
      }
    } else {
      servPtr->opts.hdrcase = (enum __anonenum_Ns_HeaderCaseDisposition_68 )0;
    }
  }
  servPtr->encoding.outputCharset = Ns_ConfigGetValue(path, (char *)"outputCharset");
  if ((unsigned int )servPtr->encoding.outputCharset != (unsigned int )((void *)0)) {
    servPtr->encoding.outputEncoding = Ns_GetCharsetEncoding(servPtr->encoding.outputCharset);
    if ((unsigned int )servPtr->encoding.outputEncoding == (unsigned int )((void *)0)) {
      Ns_Fatal((char *)"could not find encoding for default output charset \"%s\"",
               servPtr->encoding.outputCharset);
    }
  } else {
    servPtr->encoding.outputCharset = nsconf.encoding.outputCharset;
    servPtr->encoding.outputEncoding = nsconf.encoding.outputEncoding;
    nsconf.encoding.hackContentTypeP = nsconf.encoding.hackContentTypeP;
  }
  if ((unsigned int )servPtr->encoding.outputEncoding != (unsigned int )((void *)0)) {
    servPtr->encoding.hackContentTypeP = 1;
    Ns_ConfigGetBool(path, (char *)"HackContentType", & servPtr->encoding.hackContentTypeP);
  } else {
    nsconf.encoding.hackContentTypeP = 0;
  }
  servPtr->encoding.urlCharset = Ns_ConfigGetValue(path, (char *)"urlCharset");
  if ((unsigned int )servPtr->encoding.urlCharset != (unsigned int )((void *)0)) {
    servPtr->encoding.urlEncoding = Ns_GetCharsetEncoding(servPtr->encoding.urlCharset);
    if ((unsigned int )servPtr->encoding.urlEncoding == (unsigned int )((void *)0)) {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"no encoding found for charset \"%s\" from config",
             servPtr->encoding.urlCharset);
    }
  } else {
    servPtr->encoding.urlCharset = nsconf.encoding.urlCharset;
    servPtr->encoding.urlEncoding = nsconf.encoding.urlEncoding;
  }
  tmp___5 = Ns_ConfigGetInt(path, (char *)"sendfdthreshold", & servPtr->limits.sendfdmin);
  if (! tmp___5) {
    servPtr->limits.sendfdmin = 2048;
  }
  tmp___6 = Ns_ConfigGetInt(path, (char *)"errorminsize", & servPtr->limits.errorminsize);
  if (! tmp___6) {
    servPtr->limits.errorminsize = 514;
  }
  tmp___7 = Ns_ConfigGetInt(path, (char *)"maxline", & servPtr->limits.maxline);
  if (! tmp___7) {
    servPtr->limits.maxline = 16384;
  }
  tmp___8 = Ns_ConfigGetInt(path, (char *)"maxheaders", & servPtr->limits.maxheaders);
  if (! tmp___8) {
    servPtr->limits.maxheaders = 65536;
  }
  tmp___9 = Ns_ConfigGetInt(path, (char *)"maxpost", & servPtr->limits.maxpost);
  if (! tmp___9) {
    servPtr->limits.maxpost = 262144;
  }
  path = Ns_ConfigGetPath(server, (char *)((void *)0), "tcl", (void *)0);
  servPtr->tcl.library = Ns_ConfigGetValue(path, (char *)"library");
  if ((unsigned int )servPtr->tcl.library == (unsigned int )((void *)0)) {
    Ns_ModulePath(& ds, server, (char *)"tcl", (void *)0);
    servPtr->tcl.library = Ns_DStringExport(& ds);
  }
  servPtr->tcl.initfile = Ns_ConfigGetValue(path, (char *)"initfile");
  if ((unsigned int )servPtr->tcl.initfile == (unsigned int )((void *)0)) {
    Ns_HomePath(& ds, "bin", "init.tcl", (void *)0);
    servPtr->tcl.initfile = Ns_DStringExport(& ds);
  }
  servPtr->tcl.modules = Tcl_NewObj();
  (servPtr->tcl.modules)->refCount = (servPtr->tcl.modules)->refCount + 1;
  Ns_RWLockInit(& servPtr->tcl.lock);
  tmp___10 = Ns_ConfigGetInt(path, (char *)"nsvbuckets", & n);
  if (tmp___10) {
    if (n < 1) {
      n = 8;
    }
  } else {
    n = 8;
  }
  servPtr->nsv.nbuckets = n;
  servPtr->nsv.buckets = NsTclCreateBuckets(server, n);
  Tcl_InitHashTable(& servPtr->share.inits, 0);
  Tcl_InitHashTable(& servPtr->share.vars, 0);
  Ns_MutexSetName2(& servPtr->share.lock, (char *)"nstcl:share", server);
  Tcl_InitHashTable(& servPtr->var.table, 0);
  Tcl_InitHashTable(& servPtr->sets.table, 0);
  Ns_MutexSetName2(& servPtr->sets.lock, (char *)"nstcl:sets", server);
  Tcl_InitHashTable(& servPtr->chans.table, 0);
  Ns_MutexSetName2(& servPtr->chans.lock, (char *)"nstcl:chans", server);
  path = Ns_ConfigGetPath(server, (char *)((void *)0), "fastpath", (void *)0);
  tmp___13 = Ns_ConfigGetBool(path, (char *)"cache", & i);
  if (tmp___13) {
    if (i) {
      _L___0: 
      tmp___11 = Ns_ConfigGetInt(path, (char *)"cachemaxsize", & n);
      if (! tmp___11) {
        n = 5120000;
      }
      tmp___12 = Ns_ConfigGetInt(path, (char *)"cachemaxentry", & i);
      if (tmp___12) {
        if (i < 0) {
          i = n / 10;
        }
      } else {
        i = n / 10;
      }
      servPtr->fastpath.cachemaxentry = i;
      servPtr->fastpath.cache = NsFastpathCache(server, n);
    }
  } else {
    goto _L___0;
  }
  tmp___14 = Ns_ConfigGetBool(path, (char *)"mmap", & servPtr->fastpath.mmap);
  if (! tmp___14) {
    servPtr->fastpath.mmap = 0;
  }
  dirf = Ns_ConfigGetValue(path, (char *)"directoryfile");
  if ((unsigned int )dirf == (unsigned int )((void *)0)) {
    dirf = Ns_ConfigGetValue(spath, (char *)"directoryfile");
  }
  if ((unsigned int )dirf != (unsigned int )((void *)0)) {
    dirf = ns_strdup((char const   *)dirf);
    p = dirf;
    n = 1;
    while (1) {
      tmp___16 = strchr((char const   *)p, ',');
      p = tmp___16;
      if (! ((unsigned int )p != (unsigned int )((void *)0))) {
        break;
      }
      n ++;
      p ++;
    }
    servPtr->fastpath.dirc = n;
    servPtr->fastpath.dirv = (char **)ns_malloc(sizeof(char *) * (unsigned int )n);
    i = 0;
    while (i < n) {
      tmp___18 = strchr((char const   *)dirf, ',');
      p = tmp___18;
      if ((unsigned int )p != (unsigned int )((void *)0)) {
        tmp___19 = p;
        p ++;
        (*tmp___19) = (char )'\000';
      }
      (*(servPtr->fastpath.dirv + i)) = dirf;
      dirf = p;
      i ++;
    }
  }
  servPtr->fastpath.pageroot = Ns_ConfigGetValue(path, (char *)"pageroot");
  if ((unsigned int )servPtr->fastpath.pageroot == (unsigned int )((void *)0)) {
    servPtr->fastpath.pageroot = Ns_ConfigGetValue(spath, (char *)"pageroot");
    if ((unsigned int )servPtr->fastpath.pageroot == (unsigned int )((void *)0)) {
      Ns_ModulePath(& ds, server, (char *)((void *)0), "pages", (void *)0);
      servPtr->fastpath.pageroot = Ns_DStringExport(& ds);
    }
  }
  p = Ns_ConfigGetValue(path, (char *)"directorylisting");
  if ((unsigned int )p != (unsigned int )((void *)0)) {
    if ((int )(*p) == (int )(*"simple")) {
      if (0) {
        __s1_len = strlen((char const   *)p);
        __s2_len = strlen("simple");
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) ==
               1U)) {
          goto _L___2;
        } else {
          if (__s1_len >= 4U) {
            _L___2: 
            if (! ((unsigned int )((void const   *)("simple" + 1)) - (unsigned int )((void const   *)"simple") ==
                   1U)) {
              tmp___27 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___27 = 1;
              } else {
                tmp___27 = 0;
              }
            }
          } else {
            tmp___27 = 0;
          }
        }
        if (tmp___27) {
          if (__s1_len < __s2_len) {
            tmp___25 = __s1_len;
          } else {
            tmp___25 = __s2_len;
          }
          tmp___24 = memcmp((void const   *)((char const   *)p), (void const   *)"simple",
                            tmp___25 + 1U);
        } else {
          tmp___26 = strcmp((char const   *)p, "simple");
          tmp___24 = tmp___26;
        }
      } else {
        tmp___26 = strcmp((char const   *)p, "simple");
        tmp___24 = tmp___26;
      }
      if (tmp___24 == 0) {
        p = (char *)"_ns_dirlist";
      } else {
        goto _L___5;
      }
    } else {
      _L___5: 
      if ((int )(*p) == (int )(*"fancy")) {
        if (0) {
          __s1_len___0 = strlen((char const   *)p);
          __s2_len___0 = strlen("fancy");
          if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) ==
                 1U)) {
            goto _L___4;
          } else {
            if (__s1_len___0 >= 4U) {
              _L___4: 
              if (! ((unsigned int )((void const   *)("fancy" + 1)) - (unsigned int )((void const   *)"fancy") ==
                     1U)) {
                tmp___35 = 1;
              } else {
                if (__s2_len___0 >= 4U) {
                  tmp___35 = 1;
                } else {
                  tmp___35 = 0;
                }
              }
            } else {
              tmp___35 = 0;
            }
          }
          if (tmp___35) {
            if (__s1_len___0 < __s2_len___0) {
              tmp___33 = __s1_len___0;
            } else {
              tmp___33 = __s2_len___0;
            }
            tmp___32 = memcmp((void const   *)((char const   *)p), (void const   *)"fancy",
                              tmp___33 + 1U);
          } else {
            tmp___34 = strcmp((char const   *)p, "fancy");
            tmp___32 = tmp___34;
          }
        } else {
          tmp___34 = strcmp((char const   *)p, "fancy");
          tmp___32 = tmp___34;
        }
        if (tmp___32 == 0) {
          p = (char *)"_ns_dirlist";
        }
      }
    }
  }
  servPtr->fastpath.dirproc = Ns_ConfigGetValue(path, (char *)"directoryproc");
  if ((unsigned int )servPtr->fastpath.dirproc == (unsigned int )((void *)0)) {
    servPtr->fastpath.dirproc = p;
  }
  servPtr->fastpath.diradp = Ns_ConfigGetValue(path, (char *)"directoryadp");
  Tcl_InitHashTable(& servPtr->request.proxy, 0);
  Ns_MutexInit(& servPtr->request.plock);
  Ns_MutexSetName2(& servPtr->request.plock, (char *)"nsd:proxy", server);
  path = Ns_ConfigGetPath(server, (char *)((void *)0), "redirects", (void *)0);
  set = Ns_ConfigGetSection(path);
  Tcl_InitHashTable(& servPtr->request.redirect, 1);
  i = 0;
  while (1) {
    if ((unsigned int )set != (unsigned int )((void *)0)) {
      if (! (i < set->size)) {
        break;
      }
    } else {
      break;
    }
    key___1 = (set->fields + i)->name;
    map = (set->fields + i)->value;
    status = atoi__extinline((char const   *)key___1);
    if (status <= 0) {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"return: invalid redirect \'%s=%s\'",
             key___1, map);
    } else {
      if ((int )(*map) == 0) {
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"return: invalid redirect \'%s=%s\'",
               key___1, map);
      } else {
        Ns_RegisterReturn(status, map);
      }
    }
    i ++;
  }
  Ns_RegisterRequest(server, (char *)"GET", (char *)"/", & NsFastGet, (Ns_Callback *)((void *)0),
                     (void *)servPtr, 0);
  Ns_RegisterRequest(server, (char *)"HEAD", (char *)"/", & NsFastGet, (Ns_Callback *)((void *)0),
                     (void *)servPtr, 0);
  Ns_RegisterRequest(server, (char *)"POST", (char *)"/", & NsFastGet, (Ns_Callback *)((void *)0),
                     (void *)servPtr, 0);
  path = Ns_ConfigGetPath(server, (char *)((void *)0), "adp", (void *)0);
  servPtr->adp.errorpage = Ns_ConfigGetValue(path, (char *)"errorpage");
  servPtr->adp.startpage = Ns_ConfigGetValue(path, (char *)"startpage");
  tmp___36 = Ns_ConfigGetBool(path, (char *)"enableexpire", & servPtr->adp.enableexpire);
  if (! tmp___36) {
    servPtr->adp.enableexpire = 0;
  }
  tmp___37 = Ns_ConfigGetBool(path, (char *)"enabledebug", & servPtr->adp.enabledebug);
  if (! tmp___37) {
    servPtr->adp.enabledebug = 0;
  }
  servPtr->adp.debuginit = Ns_ConfigGetValue(path, (char *)"debuginit");
  if ((unsigned int )servPtr->adp.debuginit == (unsigned int )((void *)0)) {
    servPtr->adp.debuginit = (char *)"ns_adp_debuginit";
  }
  servPtr->adp.defaultparser = Ns_ConfigGetValue(path, (char *)"defaultparser");
  if ((unsigned int )servPtr->adp.defaultparser == (unsigned int )((void *)0)) {
    servPtr->adp.defaultparser = (char *)"adp";
  }
  tmp___38 = Ns_ConfigGetInt(path, (char *)"cachesize", & n);
  if (! tmp___38) {
    n = 5120000;
  }
  servPtr->adp.cachesize = (unsigned int )n;
  path = Ns_ConfigGetPath(server, (char *)((void *)0), "adp", "compress", (void *)0);
  tmp___39 = Ns_ConfigGetBool(path, (char *)"enable", & servPtr->adp.compress.enable);
  if (! tmp___39) {
    servPtr->adp.compress.enable = 0;
  }
  tmp___40 = Ns_ConfigGetInt(path, (char *)"level", & n);
  if (tmp___40) {
    if (n < 1) {
      n = 4;
    } else {
      if (n > 9) {
        n = 4;
      }
    }
  } else {
    n = 4;
  }
  servPtr->adp.compress.level = n;
  tmp___41 = Ns_ConfigGetInt(path, (char *)"minsize", & n);
  if (tmp___41) {
    if (n < 0) {
      n = 0;
    }
  } else {
    n = 0;
  }
  servPtr->adp.compress.minsize = n;
  Tcl_InitHashTable(& servPtr->adp.pages, (int )(sizeof(FileKey ) / sizeof(int )));
  Ns_MutexInit(& servPtr->adp.pagelock);
  Ns_CondInit(& servPtr->adp.pagecond);
  Ns_MutexSetName2(& servPtr->adp.pagelock, (char *)"nsadp:pages", server);
  Tcl_InitHashTable(& servPtr->adp.tags, 0);
  Ns_RWLockInit(& servPtr->adp.taglock);
  path = Ns_ConfigGetPath(server, (char *)((void *)0), "adp", (void *)0);
  set = Ns_ConfigGetSection(path);
  i = 0;
  while (1) {
    if ((unsigned int )set != (unsigned int )((void *)0)) {
      if (! (i < set->size)) {
        break;
      }
    } else {
      break;
    }
    key___1 = (set->fields + i)->name;
    tmp___42 = strcasecmp((char const   *)key___1, "map");
    if (! tmp___42) {
      map = (set->fields + i)->value;
      Ns_RegisterRequest(server, (char *)"GET", map, & NsAdpProc, (Ns_Callback *)((void *)0),
                         (void *)servPtr, 0);
      Ns_RegisterRequest(server, (char *)"HEAD", map, & NsAdpProc, (Ns_Callback *)((void *)0),
                         (void *)servPtr, 0);
      Ns_RegisterRequest(server, (char *)"POST", map, & NsAdpProc, (Ns_Callback *)((void *)0),
                         (void *)servPtr, 0);
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"adp[%s]: mapped %s",
             server, map);
    }
    i ++;
  }
  if ((unsigned int )initProc != (unsigned int )((void *)0)) {
    ((*initProc))(server);
  }
  Ns_MutexSetName2(& servPtr->pools.lock, (char *)"nsd:queue:", server);
  CreatePool(servPtr, (char *)"");
  path = Ns_ConfigGetPath(server, (char *)((void *)0), "pools", (void *)0);
  set = Ns_ConfigGetSection(path);
  i = 0;
  while (1) {
    if ((unsigned int )set != (unsigned int )((void *)0)) {
      if (! (i < set->size)) {
        break;
      }
    } else {
      break;
    }
    CreatePool(servPtr, (set->fields + i)->name);
    i ++;
  }
  NsLoadModules(server);
  NsTclInitServer(server);
  initServPtr = (NsServer *)((void *)0);
  return;
}
}
static void CreatePool(NsServer *servPtr , char *pool ) 
{ ConnPool *poolPtr ;
  Conn *connBufPtr ;
  Conn *connPtr ;
  int i ;
  int n ;
  int maxconns ;
  char *path ;
  Ns_Set *set ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  poolPtr = (ConnPool *)ns_calloc(1U, sizeof(ConnPool ));
  poolPtr->pool = pool;
  poolPtr->servPtr = servPtr;
  if ((int )(*pool) == 0) {
    path = Ns_ConfigGetPath(servPtr->server, (char *)((void *)0), (void *)0);
    servPtr->pools.defaultPtr = poolPtr;
  } else {
    path = Ns_ConfigGetPath(servPtr->server, (char *)((void *)0), "pool", pool, (void *)0);
    set = Ns_ConfigGetSection(path);
    i = 0;
    while (1) {
      if ((unsigned int )set != (unsigned int )((void *)0)) {
        if (! (i < set->size)) {
          break;
        }
      } else {
        break;
      }
      tmp = strcasecmp((char const   *)(set->fields + i)->name, "map");
      if (! tmp) {
        NsMapPool(poolPtr, (set->fields + i)->value);
      }
      i ++;
    }
  }
  poolPtr->nextPtr = servPtr->pools.firstPtr;
  servPtr->pools.firstPtr = poolPtr;
  tmp___0 = Ns_ConfigGetInt(path, (char *)"maxconnections", & maxconns);
  if (! tmp___0) {
    maxconns = 100;
  }
  connBufPtr = (Conn *)ns_calloc((unsigned int )maxconns, sizeof(Conn ));
  n = 0;
  while (n < maxconns - 1) {
    connPtr = connBufPtr + n;
    connPtr->nextPtr = connBufPtr + (n + 1);
    n ++;
  }
  (connBufPtr + n)->nextPtr = (struct Conn *)((void *)0);
  poolPtr->queue.freePtr = connBufPtr + 0;
  tmp___1 = Ns_ConfigGetInt(path, (char *)"minthreads", & poolPtr->threads.min);
  if (! tmp___1) {
    poolPtr->threads.min = 0;
  }
  tmp___2 = Ns_ConfigGetInt(path, (char *)"maxthreads", & poolPtr->threads.max);
  if (! tmp___2) {
    poolPtr->threads.max = 10;
  }
  tmp___3 = Ns_ConfigGetInt(path, (char *)"threadtimeout", & poolPtr->threads.timeout);
  if (! tmp___3) {
    poolPtr->threads.timeout = 120;
  }
  if (poolPtr->threads.max > maxconns) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"serv: cannot have more maxthreads than maxconns: %d max threads adjusted down to %d max connections",
           poolPtr->threads.max, maxconns);
    poolPtr->threads.max = maxconns;
  }
  if (poolPtr->threads.min > poolPtr->threads.max) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"serv: cannot have more minthreads than maxthreads: %d min threads adjusted down to %d max threads",
           poolPtr->threads.min, poolPtr->threads.max);
    poolPtr->threads.min = poolPtr->threads.max;
  }
  tmp___4 = Ns_ConfigGetInt(path, (char *)"minthreads", & poolPtr->threads.min);
  if (! tmp___4) {
    poolPtr->threads.min = 0;
  }
  tmp___5 = Ns_ConfigGetInt(path, (char *)"maxthreads", & poolPtr->threads.max);
  if (! tmp___5) {
    poolPtr->threads.max = 10;
  }
  tmp___6 = Ns_ConfigGetInt(path, (char *)"threadtimeout", & poolPtr->threads.timeout);
  if (! tmp___6) {
    poolPtr->threads.timeout = 120;
  }
  if (poolPtr->threads.max > maxconns) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"serv: cannot have more maxthreads than maxconns: %d max threads adjusted down to %d max connections",
           poolPtr->threads.max, maxconns);
    poolPtr->threads.max = maxconns;
  }
  if (poolPtr->threads.min > poolPtr->threads.max) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"serv: cannot have more minthreads than maxthreads: %d min threads adjusted down to %d max threads",
           poolPtr->threads.min, poolPtr->threads.max);
    poolPtr->threads.min = poolPtr->threads.max;
  }
  return;
}
}
void Ns_SetUpdate(Ns_Set *set , char *key___1 , char *value ) ;
int Ns_SetUniqueCmp(Ns_Set *set , char *key___1 , int (*cmp)(char *s1 , char *s2 ) ) ;
int Ns_SetFindCmp(Ns_Set *set , char *key___1 , int (*cmp)(char *s1 , char *s2 ) ) ;
char *Ns_SetGetCmp(Ns_Set *set , char *key___1 , int (*cmp)(char *s1 , char *s2 ) ) ;
int Ns_SetUnique(Ns_Set *set , char *key___1 ) ;
int Ns_SetIUnique(Ns_Set *set , char *key___1 ) ;
void Ns_SetDelete(Ns_Set *set , int index___0 ) ;
void Ns_SetDeleteKey(Ns_Set *set , char *key___1 ) ;
void Ns_SetIDeleteKey(Ns_Set *set , char *key___1 ) ;
Ns_Set *Ns_SetListFind(Ns_Set **sets , char *name ) ;
Ns_Set **Ns_SetSplit(Ns_Set *set , char sep ) ;
void Ns_SetListFree(Ns_Set **sets ) ;
void Ns_SetMerge(Ns_Set *high , Ns_Set *low ) ;
void Ns_SetMove(Ns_Set *to , Ns_Set *from ) ;
void Ns_SetPrint(Ns_Set *set ) ;
void Ns_SetUpdate(Ns_Set *set , char *key___1 , char *value ) 
{ 

  {
  Ns_SetDeleteKey(set, key___1);
  Ns_SetPut(set, key___1, value);
  return;
}
}
Ns_Set *Ns_SetCreate(char *name ) 
{ Ns_Set *setPtr ;

  {
  setPtr = (Ns_Set *)ns_malloc(sizeof(Ns_Set ));
  setPtr->size = 0;
  setPtr->maxSize = 10;
  setPtr->name = ns_strcopy((char const   *)name);
  setPtr->fields = (Ns_SetField *)ns_malloc(sizeof(Ns_SetField ) * (unsigned int )setPtr->maxSize);
  return (setPtr);
}
}
void Ns_SetFree(Ns_Set *set ) 
{ int i ;

  {
  if ((unsigned int )set != (unsigned int )((void *)0)) {
    i = 0;
    while (i < set->size) {
      ns_free((void *)(set->fields + i)->name);
      ns_free((void *)(set->fields + i)->value);
      i ++;
    }
    ns_free((void *)set->fields);
    ns_free((void *)set->name);
    ns_free((void *)set);
  }
  return;
}
}
int Ns_SetPut(Ns_Set *set , char *key___1 , char *value ) 
{ int index___0 ;

  {
  index___0 = set->size;
  set->size = set->size + 1;
  if (set->size > set->maxSize) {
    set->maxSize = set->size * 2;
    set->fields = (Ns_SetField *)ns_realloc((void *)set->fields, sizeof(Ns_SetField ) *
                                                                 (unsigned int )set->maxSize);
  }
  (set->fields + index___0)->name = ns_strcopy((char const   *)key___1);
  (set->fields + index___0)->value = ns_strcopy((char const   *)value);
  return (index___0);
}
}
int Ns_SetUniqueCmp(Ns_Set *set , char *key___1 , int (*cmp)(char *s1 , char *s2 ) ) 
{ int i ;
  char *name ;
  int found ;
  int tmp ;

  {
  found = 0;
  i = 0;
  while (i < set->size) {
    name = (set->fields + i)->name;
    if ((unsigned int )key___1 == (unsigned int )((void *)0)) {
      if ((unsigned int )name == (unsigned int )((void *)0)) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if ((unsigned int )key___1 != (unsigned int )((void *)0)) {
        if ((unsigned int )name != (unsigned int )((void *)0)) {
          tmp = ((*cmp))(key___1, name);
          if (tmp == 0) {
            _L: 
            if (found) {
              return (0);
            }
            found = 1;
          }
        }
      }
    }
    i ++;
  }
  return (1);
}
}
int Ns_SetFindCmp(Ns_Set *set , char *key___1 , int (*cmp)(char *s1 , char *s2 ) ) 
{ int i ;
  char *name ;
  int tmp ;

  {
  i = 0;
  while (i < set->size) {
    name = (set->fields + i)->name;
    if ((unsigned int )key___1 == (unsigned int )((void *)0)) {
      if ((unsigned int )name == (unsigned int )((void *)0)) {
        return (i);
      } else {
        goto _L;
      }
    } else {
      _L: 
      if ((unsigned int )key___1 != (unsigned int )((void *)0)) {
        if ((unsigned int )name != (unsigned int )((void *)0)) {
          tmp = ((*cmp))(key___1, name);
          if (tmp == 0) {
            return (i);
          }
        }
      }
    }
    i ++;
  }
  return (-1);
}
}
char *Ns_SetGetCmp(Ns_Set *set , char *key___1 , int (*cmp)(char *s1 , char *s2 ) ) 
{ int i ;

  {
  i = Ns_SetFindCmp(set, key___1, cmp);
  if (i == -1) {
    return ((char *)((void *)0));
  }
  return ((set->fields + i)->value);
}
}
int Ns_SetUnique(Ns_Set *set , char *key___1 ) 
{ int tmp ;

  {
  tmp = Ns_SetUniqueCmp(set, key___1, (int (*)(char * , char * ))(& strcmp));
  return (tmp);
}
}
int Ns_SetIUnique(Ns_Set *set , char *key___1 ) 
{ int tmp ;

  {
  tmp = Ns_SetUniqueCmp(set, key___1, (int (*)(char * , char * ))(& strcasecmp));
  return (tmp);
}
}
int Ns_SetFind(Ns_Set *set , char *key___1 ) 
{ int tmp ;

  {
  tmp = Ns_SetFindCmp(set, key___1, (int (*)(char * , char * ))(& strcmp));
  return (tmp);
}
}
int Ns_SetIFind(Ns_Set *set , char *key___1 ) 
{ int tmp ;

  {
  tmp = Ns_SetFindCmp(set, key___1, (int (*)(char * , char * ))(& strcasecmp));
  return (tmp);
}
}
char *Ns_SetGet(Ns_Set *set , char *key___1 ) 
{ char *tmp ;

  {
  tmp = Ns_SetGetCmp(set, key___1, (int (*)(char * , char * ))(& strcmp));
  return (tmp);
}
}
char *Ns_SetIGet(Ns_Set *set , char *key___1 ) 
{ char *tmp ;

  {
  tmp = Ns_SetGetCmp(set, key___1, (int (*)(char * , char * ))(& strcasecmp));
  return (tmp);
}
}
void Ns_SetTrunc(Ns_Set *set , int size ) 
{ int index___0 ;

  {
  if (size < set->size) {
    index___0 = size;
    while (index___0 < set->size) {
      ns_free((void *)(set->fields + index___0)->name);
      ns_free((void *)(set->fields + index___0)->value);
      index___0 ++;
    }
    set->size = size;
  }
  return;
}
}
void Ns_SetDelete(Ns_Set *set , int index___0 ) 
{ int i ;

  {
  if (index___0 != -1) {
    if (index___0 < set->size) {
      ns_free((void *)(set->fields + index___0)->name);
      ns_free((void *)(set->fields + index___0)->value);
      i = index___0;
      while (i < set->size) {
        (set->fields + i)->name = (set->fields + (i + 1))->name;
        (set->fields + i)->value = (set->fields + (i + 1))->value;
        i ++;
      }
      set->size = set->size - 1;
    }
  }
  return;
}
}
void Ns_SetPutValue(Ns_Set *set , int index___0 , char *value ) 
{ 

  {
  if (index___0 != -1) {
    if (index___0 < set->size) {
      ns_free((void *)(set->fields + index___0)->value);
      (set->fields + index___0)->value = ns_strcopy((char const   *)value);
    }
  }
  return;
}
}
void Ns_SetDeleteKey(Ns_Set *set , char *key___1 ) 
{ int tmp ;

  {
  tmp = Ns_SetFind(set, key___1);
  Ns_SetDelete(set, tmp);
  return;
}
}
void Ns_SetIDeleteKey(Ns_Set *set , char *key___1 ) 
{ int tmp ;

  {
  tmp = Ns_SetIFind(set, key___1);
  Ns_SetDelete(set, tmp);
  return;
}
}
Ns_Set *Ns_SetListFind(Ns_Set **sets , char *name ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  while ((unsigned int )(*sets) != (unsigned int )((void *)0)) {
    if ((unsigned int )name == (unsigned int )((void *)0)) {
      if ((unsigned int )((*sets))->name == (unsigned int )((void *)0)) {
        return ((*sets));
      }
    } else {
      if ((unsigned int )((*sets))->name != (unsigned int )((void *)0)) {
        if ((int )(*(((*sets))->name)) == (int )(*name)) {
          if (0) {
            __s1_len = strlen((char const   *)((*sets))->name);
            __s2_len = strlen((char const   *)name);
            if (! ((unsigned int )((void const   *)(((*sets))->name + 1)) - (unsigned int )((void const   *)((*sets))->name) ==
                   1U)) {
              goto _L___0;
            } else {
              if (__s1_len >= 4U) {
                _L___0: 
                if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                       1U)) {
                  tmp___6 = 1;
                } else {
                  if (__s2_len >= 4U) {
                    tmp___6 = 1;
                  } else {
                    tmp___6 = 0;
                  }
                }
              } else {
                tmp___6 = 0;
              }
            }
            if (tmp___6) {
              if (__s1_len < __s2_len) {
                tmp___4 = __s1_len;
              } else {
                tmp___4 = __s2_len;
              }
              tmp___3 = memcmp((void const   *)((char const   *)((*sets))->name),
                               (void const   *)((char const   *)name), tmp___4 + 1U);
            } else {
              tmp___5 = strcmp((char const   *)((*sets))->name, (char const   *)name);
              tmp___3 = tmp___5;
            }
          } else {
            tmp___5 = strcmp((char const   *)((*sets))->name, (char const   *)name);
            tmp___3 = tmp___5;
          }
          if (tmp___3 == 0) {
            return ((*sets));
          }
        }
      }
    }
    sets ++;
  }
  return ((Ns_Set *)((void *)0));
}
}
Ns_Set **Ns_SetSplit(Ns_Set *set , char sep ) 
{ int i ;
  Tcl_DString ds ;
  Ns_Set *end ;
  Ns_Set *next ;
  char *name ;
  char *key___1 ;
  char *tmp___0 ;
  char *tmp___1 ;
  Ns_Set **sp ;
  Ns_Set **tmp___2 ;

  {
  end = (Ns_Set *)((void *)0);
  Tcl_DStringInit(& ds);
  Tcl_DStringAppend(& ds, (char *)(& end), (int )sizeof(Ns_Set *));
  i = 0;
  while (i < set->size) {
    tmp___0 = strchr((char const   *)(set->fields + i)->name, (int )sep);
    key___1 = tmp___0;
    if ((unsigned int )key___1 != (unsigned int )((void *)0)) {
      tmp___1 = key___1;
      key___1 ++;
      (*tmp___1) = (char )'\000';
      name = (set->fields + i)->name;
    } else {
      key___1 = (set->fields + i)->name;
      name = (char *)((void *)0);
    }
    next = Ns_SetListFind((Ns_Set **)ds.string, name);
    if ((unsigned int )next == (unsigned int )((void *)0)) {
      next = Ns_SetCreate(name);
      sp = (Ns_Set **)((ds.string + ds.length) - sizeof(Ns_Set *));
      (*sp) = next;
      Tcl_DStringAppend(& ds, (char *)(& end), (int )sizeof(Ns_Set *));
    }
    Ns_SetPut(next, key___1, (set->fields + i)->value);
    if ((unsigned int )name != (unsigned int )((void *)0)) {
      key___1 --;
      (*key___1) = sep;
    }
    i ++;
  }
  tmp___2 = (Ns_Set **)Ns_DStringExport(& ds);
  return (tmp___2);
}
}
void Ns_SetListFree(Ns_Set **sets ) 
{ Ns_Set **s ;

  {
  s = sets;
  while ((unsigned int )(*s) != (unsigned int )((void *)0)) {
    Ns_SetFree((*s));
    s ++;
  }
  ns_free((void *)sets);
  return;
}
}
void Ns_SetMerge(Ns_Set *high , Ns_Set *low ) 
{ int i ;
  int j ;

  {
  i = 0;
  while (i < low->size) {
    j = Ns_SetFind(high, (low->fields + i)->name);
    if (j == -1) {
      Ns_SetPut(high, (low->fields + i)->name, (low->fields + i)->value);
    }
    i ++;
  }
  return;
}
}
Ns_Set *Ns_SetCopy(Ns_Set *old ) 
{ int i ;
  Ns_Set *new ;

  {
  if ((unsigned int )old == (unsigned int )((void *)0)) {
    return ((Ns_Set *)((void *)0));
  }
  new = Ns_SetCreate(old->name);
  i = 0;
  while (i < old->size) {
    Ns_SetPut(new, (old->fields + i)->name, (old->fields + i)->value);
    i ++;
  }
  return (new);
}
}
void Ns_SetMove(Ns_Set *to , Ns_Set *from ) 
{ int i ;

  {
  i = 0;
  while (i < from->size) {
    Ns_SetPut(to, (from->fields + i)->name, (from->fields + i)->value);
    i ++;
  }
  Ns_SetTrunc(from, 0);
  return;
}
}
void Ns_SetPrint(Ns_Set *set ) 
{ int i ;
  char const   *tmp ;

  {
  if (set->name) {
    tmp = (char const   *)set->name;
  } else {
    tmp = "<Unamed set>";
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:\n", tmp);
  i = 0;
  while (i < set->size) {
    if ((unsigned int )(set->fields + i)->name == (unsigned int )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\t(null) = ");
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\t%s = ",
              (set->fields + i)->name);
    }
    if ((unsigned int )(set->fields + i)->value == (unsigned int )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"(null)\n");
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", (set->fields +
                                                                                 i)->value);
    }
    i ++;
  }
  return;
}
}
extern int socket(int __domain , int __type , int __protocol ) ;
extern int bind(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
extern int getsockopt(int __fd , int __level , int __optname , void * __restrict  __optval ,
                      socklen_t * __restrict  __optlen ) ;
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
int Ns_SockRecv(int sock , void *buf , int toread , int timeout ) ;
int Ns_SockSend(int sock , void *buf , int towrite , int timeout ) ;
int Ns_SockWait(int sock , int what , int timeout ) ;
int Ns_BindSock(struct sockaddr_in *saPtr ) ;
int Ns_SockConnect(char *host , int port ) ;
int Ns_SockConnect2(char *host , int port , char *lhost , int lport ) ;
int Ns_SockAsyncConnect(char *host , int port ) ;
int Ns_SockAsyncConnect2(char *host , int port , char *lhost , int lport ) ;
int Ns_SockTimedConnect(char *host , int port , int timeout ) ;
int Ns_SockTimedConnect2(char *host , int port , char *lhost , int lport , int timeout ) ;
int Ns_SockCloseLater(int sock ) ;
void Ns_ClearSockErrno(void) ;
int Ns_GetSockErrno(void) ;
void Ns_SetSockErrno(int err ) ;
char *Ns_SockStrError(int err ) ;
extern int ioctl(int __fd , unsigned long __request  , ...) ;
static int SockConnect(char *host , int port , char *lhost , int lport , int async ) ;
static int SockSetup(int sock ) ;
int Ns_SockRecv(int sock , void *buf , int toread , int timeout ) 
{ int nread ;
  int *tmp ;
  int tmp___0 ;

  {
  nread = recv(sock, buf, (unsigned int )toread, 0);
  if (nread == -1) {
    tmp = __errno_location();
    if ((*tmp) == 11) {
      tmp___0 = Ns_SockWait(sock, 1, timeout);
      if (tmp___0 == 0) {
        nread = recv(sock, buf, (unsigned int )toread, 0);
      }
    }
  }
  return (nread);
}
}
int Ns_SockSend(int sock , void *buf , int towrite , int timeout ) 
{ int nwrote ;
  int *tmp ;
  int tmp___0 ;

  {
  nwrote = send(sock, (void const   *)buf, (unsigned int )towrite, 0);
  if (nwrote == -1) {
    tmp = __errno_location();
    if ((*tmp) == 11) {
      tmp___0 = Ns_SockWait(sock, 2, timeout);
      if (tmp___0 == 0) {
        nwrote = send(sock, (void const   *)buf, (unsigned int )towrite, 0);
      }
    }
  }
  return (nwrote);
}
}
int Ns_SockWait(int sock , int what , int timeout ) 
{ struct pollfd pfd ;
  int n ;
  int *tmp ;

  {
  if (timeout < 0) {
    return (-2);
  }
  timeout *= 1000;
  pfd.fd = sock;
  switch (what) {
  case 1: 
  pfd.events = (short)1;
  break;
  case 2: 
  pfd.events = (short)4;
  break;
  case 4: 
  pfd.events = (short)2;
  break;
  default: ;
  return (-1);
  break;
  }
  pfd.revents = (short)0;
  while (1) {
    n = poll(& pfd, 1UL, timeout);
    if (n < 0) {
      tmp = __errno_location();
      if (! ((*tmp) == 4)) {
        break;
      }
    } else {
      break;
    }
  }
  if (n > 0) {
    return (0);
  }
  return (-2);
}
}
int Ns_SockListen(char *address , int port ) 
{ int tmp ;

  {
  tmp = Ns_SockListenEx(address, port, nsconf.backlog);
  return (tmp);
}
}
int Ns_SockAccept(int lsock , struct sockaddr *saPtr , int *lenPtr ) 
{ int sock ;

  {
  sock = accept(lsock, (struct sockaddr * __restrict  )saPtr, (socklen_t * __restrict  )lenPtr);
  if (sock != -1) {
    sock = SockSetup(sock);
  }
  return (sock);
}
}
int Ns_BindSock(struct sockaddr_in *saPtr ) 
{ int tmp ;

  {
  tmp = Ns_SockBind(saPtr);
  return (tmp);
}
}
int Ns_SockBind(struct sockaddr_in *saPtr ) 
{ int sock ;
  int n ;
  int tmp ;

  {
  sock = socket(2, 1, 0);
  if (sock != -1) {
    sock = SockSetup(sock);
  }
  if (sock != -1) {
    n = 1;
    if ((int )saPtr->sin_port != 0) {
      setsockopt(sock, 1, 2, (void const   *)((char *)(& n)), sizeof(n));
    }
    tmp = bind(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)saPtr),
               sizeof(struct sockaddr_in ));
    if (tmp != 0) {
      close(sock);
      sock = -1;
    }
  }
  return (sock);
}
}
int Ns_SockConnect(char *host , int port ) 
{ int tmp ;

  {
  tmp = SockConnect(host, port, (char *)((void *)0), 0, 0);
  return (tmp);
}
}
int Ns_SockConnect2(char *host , int port , char *lhost , int lport ) 
{ int tmp ;

  {
  tmp = SockConnect(host, port, lhost, lport, 0);
  return (tmp);
}
}
int Ns_SockAsyncConnect(char *host , int port ) 
{ int tmp ;

  {
  tmp = SockConnect(host, port, (char *)((void *)0), 0, 1);
  return (tmp);
}
}
int Ns_SockAsyncConnect2(char *host , int port , char *lhost , int lport ) 
{ int tmp ;

  {
  tmp = SockConnect(host, port, lhost, lport, 1);
  return (tmp);
}
}
int Ns_SockTimedConnect(char *host , int port , int timeout ) 
{ int tmp ;

  {
  tmp = Ns_SockTimedConnect2(host, port, (char *)((void *)0), 0, timeout);
  return (tmp);
}
}
int Ns_SockTimedConnect2(char *host , int port , char *lhost , int lport , int timeout ) 
{ int sock ;
  int len ;
  int err ;
  int tmp ;
  int tmp___0 ;

  {
  sock = SockConnect(host, port, lhost, lport, 1);
  if (sock != -1) {
    len = (int )sizeof(err);
    tmp = Ns_SockWait(sock, 2, timeout);
    if (tmp == 0) {
      tmp___0 = getsockopt(sock, 1, 4, (void * __restrict  )((char *)(& err)), (socklen_t * __restrict  )(& len));
      if (tmp___0 == 0) {
        if (err == 0) {
          return (sock);
        }
      }
    }
    close(sock);
    sock = -1;
  }
  return (sock);
}
}
int Ns_SockSetNonBlocking(int sock ) 
{ unsigned long i ;
  int tmp ;

  {
  i = 1UL;
  tmp = ioctl(sock, 21537UL, & i);
  if (tmp == -1) {
    return (-1);
  }
  return (0);
}
}
int Ns_SockSetBlocking(int sock ) 
{ unsigned long i ;
  int tmp ;

  {
  i = 0UL;
  tmp = ioctl(sock, 21537UL, & i);
  if (tmp == -1) {
    return (-1);
  }
  return (0);
}
}
int Ns_GetSockAddr(struct sockaddr_in *saPtr , char *host , int port ) 
{ struct in_addr ia ;
  Tcl_DString ds ;
  register unsigned int __v ;
  register unsigned int __x ;
  int tmp ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_107___1 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;

  {
  if ((unsigned int )host == (unsigned int )((void *)0)) {
    __x = 0U;
    __asm__  ("rorw $8, %w0;"
              "rorl $16, %0;"
              "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
    ia.s_addr = __v;
  } else {
    ia.s_addr = inet_addr((char const   *)host);
    if (ia.s_addr == 4294967295U) {
      Tcl_DStringInit(& ds);
      tmp = Ns_GetAddrByHost(& ds, host);
      if (tmp == 1) {
        ia.s_addr = inet_addr((char const   *)ds.string);
      }
      Tcl_DStringFree(& ds);
      if (ia.s_addr == 4294967295U) {
        return (-1);
      }
    }
  }
  if (sizeof(struct sockaddr_in ) <= 16U) {
    if (sizeof(struct sockaddr_in ) == 1U) {
      __s___1 = (void *)saPtr;
      (*((__uint8_t *)__s___1)) = (unsigned char)0;
    } else {
      __s___0 = (void *)saPtr;
      __u = (union __anonunion___u_107___1 *)__s___0;
      __c = (unsigned char)0;
      switch ((int )sizeof(struct sockaddr_in )) {
      case 15: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___1 *)((void *)__u + 4);
      case 11: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___1 *)((void *)__u + 4);
      case 7: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___1 *)((void *)__u + 4);
      case 3: 
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
      __u = (union __anonunion___u_107___1 *)((void *)__u + 2);
      __u->__uc = __c;
      break;
      case 14: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___1 *)((void *)__u + 4);
      case 10: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___1 *)((void *)__u + 4);
      case 6: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___1 *)((void *)__u + 4);
      case 2: 
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
      break;
      case 13: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___1 *)((void *)__u + 4);
      case 9: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___1 *)((void *)__u + 4);
      case 5: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___1 *)((void *)__u + 4);
      case 1: 
      __u->__uc = __c;
      break;
      case 16: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___1 *)((void *)__u + 4);
      case 12: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___1 *)((void *)__u + 4);
      case 8: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___1 *)((void *)__u + 4);
      case 4: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case 0: ;
      break;
      }
    }
  } else {
    __s = (void *)saPtr;
    __builtin_memset(__s, '\000', (int )sizeof(struct sockaddr_in ));
  }
  saPtr->sin_family = (unsigned short)2;
  saPtr->sin_addr = ia;
  __x___0 = (unsigned short )port;
  __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
  saPtr->sin_port = __v___0;
  return (0);
}
}
int Ns_SockPipe(int *socks ) 
{ int tmp ;

  {
  tmp = ns_sockpair(socks);
  if (tmp != 0) {
    return (-1);
  }
  return (0);
}
}
static int SockConnect(char *host , int port , char *lhost , int lport , int async ) 
{ int sock ;
  struct sockaddr_in lsa ;
  struct sockaddr_in sa ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  tmp = Ns_GetSockAddr(& sa, host, port);
  if (tmp != 0) {
    return (-1);
  } else {
    tmp___0 = Ns_GetSockAddr(& lsa, lhost, lport);
    if (tmp___0 != 0) {
      return (-1);
    }
  }
  sock = Ns_SockBind(& lsa);
  if (sock != -1) {
    if (async) {
      Ns_SockSetNonBlocking(sock);
    }
    tmp___2 = connect(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& sa)),
                      sizeof(sa));
    if (tmp___2 != 0) {
      tmp___1 = __errno_location();
      err = (*tmp___1);
      if (! async) {
        close(sock);
        sock = -1;
      } else {
        if (err != 115) {
          if (err != 11) {
            close(sock);
            sock = -1;
          }
        }
      }
    }
    if (async) {
      if (sock != -1) {
        Ns_SockSetBlocking(sock);
      }
    }
  }
  return (sock);
}
}
static int CloseLater(int sock , void *arg , int why ) 
{ 

  {
  close(sock);
  return (0);
}
}
int Ns_SockCloseLater(int sock ) 
{ int tmp ;

  {
  tmp = Ns_SockCallback(sock, & CloseLater, (void *)0, 2);
  return (tmp);
}
}
void Ns_ClearSockErrno(void) 
{ int *tmp ;

  {
  tmp = __errno_location();
  (*tmp) = 0;
  return;
}
}
int Ns_GetSockErrno(void) 
{ int *tmp ;

  {
  tmp = __errno_location();
  return ((*tmp));
}
}
void Ns_SetSockErrno(int err ) 
{ int *tmp ;

  {
  tmp = __errno_location();
  (*tmp) = err;
  return;
}
}
char *Ns_SockStrError(int err ) 
{ char *tmp ;

  {
  tmp = strerror(err);
  return (tmp);
}
}
static int SockSetup(int sock ) 
{ 

  {
  fcntl(sock, 2, 1);
  return (sock);
}
}
void Ns_SockCancelCallback(int sock ) ;
int Ns_SockCancelCallbackEx(int sock , Ns_SockProc *proc , void *arg ) ;
static void SockCallbackThread(void *ignored ) ;
static int Queue(int sock , Ns_SockProc *proc , void *arg , int when ) ;
static void CallbackTrigger(void) ;
static Callback___0 *firstQueuePtr  ;
static Callback___0 *lastQueuePtr  ;
static int shutdownPending___2  ;
static int running___0  ;
static Ns_Thread sockThread  ;
static Ns_Mutex lock___10  ;
static Ns_Cond cond___2  ;
static int trigPipe___0[2]  ;
static Tcl_HashTable table  ;
int Ns_SockCallback(int sock , Ns_SockProc *proc , void *arg , int when ) 
{ int tmp ;

  {
  tmp = Queue(sock, proc, arg, when);
  return (tmp);
}
}
void Ns_SockCancelCallback(int sock ) 
{ 

  {
  Ns_SockCancelCallbackEx(sock, (Ns_SockProc *)((void *)0), (void *)0);
  return;
}
}
int Ns_SockCancelCallbackEx(int sock , Ns_SockProc *proc , void *arg ) 
{ int tmp ;

  {
  tmp = Queue(sock, proc, arg, 32);
  return (tmp);
}
}
void NsStartSockShutdown(void) 
{ 

  {
  Ns_MutexLock(& lock___10);
  if (running___0) {
    shutdownPending___2 = 1;
    CallbackTrigger();
  }
  Ns_MutexUnlock(& lock___10);
  return;
}
}
void NsWaitSockShutdown(Ns_Time *toPtr ) 
{ int status ;

  {
  status = 0;
  Ns_MutexLock(& lock___10);
  while (1) {
    if (status == 0) {
      if (! running___0) {
        break;
      }
    } else {
      break;
    }
    status = Ns_CondTimedWait(& cond___2, & lock___10, toPtr);
  }
  Ns_MutexUnlock(& lock___10);
  if (status != 0) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"socks: timeout waiting for callback shutdown");
  } else {
    if ((unsigned int )sockThread != (unsigned int )((void *)0)) {
      Ns_ThreadJoin(& sockThread, (void **)((void *)0));
      sockThread = (struct Ns_Thread_ *)((void *)0);
      close(trigPipe___0[0]);
      close(trigPipe___0[1]);
    }
  }
  return;
}
}
static void CallbackTrigger(void) 
{ int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
  tmp___1 = send(trigPipe___0[1], (void const   *)"", 1U, 0);
  if (tmp___1 != 1) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Ns_Fatal((char *)"trigger send() failed: %s", tmp___0);
  }
  return;
}
}
static int Queue(int sock , Ns_SockProc *proc , void *arg , int when ) 
{ Callback___0 *cbPtr ;
  int status ;
  int trigger ;
  int create ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  cbPtr = (Callback___0 *)ns_malloc(sizeof(Callback___0 ));
  cbPtr->sock = sock;
  cbPtr->proc = proc;
  cbPtr->arg = arg;
  cbPtr->when = when;
  create = 0;
  trigger = create;
  Ns_MutexLock(& lock___10);
  if (shutdownPending___2) {
    ns_free((void *)cbPtr);
    status = -1;
  } else {
    if (! running___0) {
      Tcl_InitHashTable(& table, 1);
      Ns_MutexSetName(& lock___10, (char *)"ns:sockcallbacks");
      create = 1;
      running___0 = 1;
    } else {
      if ((unsigned int )firstQueuePtr == (unsigned int )((void *)0)) {
        trigger = 1;
      }
    }
    if ((unsigned int )firstQueuePtr == (unsigned int )((void *)0)) {
      firstQueuePtr = cbPtr;
    } else {
      lastQueuePtr->nextPtr = cbPtr;
    }
    cbPtr->nextPtr = (struct Callback___0 *)((void *)0);
    lastQueuePtr = cbPtr;
    status = 0;
  }
  Ns_MutexUnlock(& lock___10);
  if (trigger) {
    CallbackTrigger();
  } else {
    if (create) {
      tmp___1 = ns_sockpair(trigPipe___0);
      if (tmp___1 != 0) {
        tmp = __errno_location();
        tmp___0 = strerror((*tmp));
        Ns_Fatal((char *)"ns_sockpair() failed: %s", tmp___0);
      }
      Ns_ThreadCreate(& SockCallbackThread, (void *)0, 0L, & sockThread);
    }
  }
  return (status);
}
}
static void SockCallbackThread(void *ignored ) 
{ char c ;
  int when[3] ;
  int events[3] ;
  int n ;
  int i ;
  int new ;
  int stop ;
  int max ;
  int nfds___1 ;
  Callback___0 *cbPtr ;
  Callback___0 *nextPtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  struct pollfd *pfds___1 ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;

  {
  Ns_ThreadSetName((char *)"-socks-");
  Ns_WaitForStartup();
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"socks: starting");
  events[0] = 1;
  events[1] = 4;
  events[2] = 2;
  when[0] = 1;
  when[1] = 2;
  when[2] = 20;
  max = 100;
  pfds___1 = (struct pollfd *)ns_malloc(sizeof(struct pollfd ) * (unsigned int )max);
  (pfds___1 + 0)->fd = trigPipe___0[0];
  (pfds___1 + 0)->events = (short)1;
  while (1) {
    Ns_MutexLock(& lock___10);
    cbPtr = firstQueuePtr;
    firstQueuePtr = (Callback___0 *)((void *)0);
    lastQueuePtr = (Callback___0 *)((void *)0);
    stop = shutdownPending___2;
    Ns_MutexUnlock(& lock___10);
    while ((unsigned int )cbPtr != (unsigned int )((void *)0)) {
      nextPtr = cbPtr->nextPtr;
      if (cbPtr->when & 32) {
        hPtr = ((*(table.findProc)))(& table, (char *)cbPtr->sock);
        if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
          ns_free(hPtr->clientData);
          Tcl_DeleteHashEntry(hPtr);
        }
        if ((unsigned int )cbPtr->proc != (unsigned int )((void *)0)) {
          ((*(cbPtr->proc)))(cbPtr->sock, cbPtr->arg, 32);
        }
        ns_free((void *)cbPtr);
      } else {
        hPtr = ((*(table.createProc)))(& table, (char *)cbPtr->sock, & new);
        if (! new) {
          ns_free(hPtr->clientData);
        }
        hPtr->clientData = (void *)cbPtr;
      }
      cbPtr = nextPtr;
    }
    if (max <= table.numEntries) {
      max = table.numEntries + 100;
      pfds___1 = (struct pollfd *)ns_realloc((void *)pfds___1, (unsigned int )max);
    }
    nfds___1 = 1;
    hPtr = Tcl_FirstHashEntry(& table, & search);
    while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
      cbPtr = (Callback___0 *)hPtr->clientData;
      if (! (cbPtr->when & 255)) {
        Tcl_DeleteHashEntry(hPtr);
        ns_free((void *)cbPtr);
      } else {
        cbPtr->idx = nfds___1;
        (pfds___1 + nfds___1)->fd = cbPtr->sock;
        (pfds___1 + nfds___1)->revents = (short)0;
        (pfds___1 + nfds___1)->events = (pfds___1 + nfds___1)->revents;
        i = 0;
        while (i < 3) {
          if (cbPtr->when & when[i]) {
            (pfds___1 + nfds___1)->events = (short )((int )(pfds___1 + nfds___1)->events |
                                                     events[i]);
          }
          i ++;
        }
        nfds___1 ++;
      }
      hPtr = Tcl_NextHashEntry(& search);
    }
    if (stop) {
      break;
    }
    (pfds___1 + 0)->revents = (short)0;
    while (1) {
      n = poll(pfds___1, (unsigned long )((unsigned int )nfds___1), -1);
      if (n < 0) {
        tmp = __errno_location();
        if (! ((*tmp) == 4)) {
          break;
        }
      } else {
        break;
      }
    }
    if (n < 0) {
      tmp___0 = __errno_location();
      tmp___1 = strerror((*tmp___0));
      Ns_Fatal((char *)"poll() failed: %s", tmp___1);
    }
    if ((int )(pfds___1 + 0)->revents & 1) {
      tmp___4 = recv(trigPipe___0[0], (void *)(& c), 1U, 0);
      if (tmp___4 != 1) {
        tmp___2 = __errno_location();
        tmp___3 = strerror((*tmp___2));
        Ns_Fatal((char *)"trigger read() failed: %s", tmp___3);
      }
    }
    hPtr = Tcl_FirstHashEntry(& table, & search);
    while (1) {
      if (n > 0) {
        if (! ((unsigned int )hPtr != (unsigned int )((void *)0))) {
          break;
        }
      } else {
        break;
      }
      cbPtr = (Callback___0 *)hPtr->clientData;
      i = 0;
      while (i < 3) {
        if (cbPtr->when & when[i]) {
          if ((int )(pfds___1 + cbPtr->idx)->revents & events[i]) {
            tmp___5 = ((*(cbPtr->proc)))(cbPtr->sock, cbPtr->arg, when[i]);
            if (! tmp___5) {
              cbPtr->when = 0;
            }
          }
        }
        i ++;
      }
      hPtr = Tcl_NextHashEntry(& search);
    }
  }
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"socks: shutdown pending");
  hPtr = Tcl_FirstHashEntry(& table, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    cbPtr = (Callback___0 *)hPtr->clientData;
    if (cbPtr->when & 8) {
      ((*(cbPtr->proc)))(cbPtr->sock, cbPtr->arg, 8);
    }
    hPtr = Tcl_NextHashEntry(& search);
  }
  hPtr = Tcl_FirstHashEntry(& table, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    ns_free(hPtr->clientData);
    hPtr = Tcl_NextHashEntry(& search);
  }
  Tcl_DeleteHashTable(& table);
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"socks: shutdown complete");
  Ns_MutexLock(& lock___10);
  running___0 = 0;
  Ns_CondBroadcast(& cond___2);
  Ns_MutexUnlock(& lock___10);
  return;
}
}
void NsGetSockCallbacks(Tcl_DString *dsPtr ) 
{ Callback___0 *cbPtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  char buf[100] ;

  {
  Ns_MutexLock(& lock___10);
  if (running___0) {
    hPtr = Tcl_FirstHashEntry(& table, & search);
    while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
      cbPtr = (Callback___0 *)hPtr->clientData;
      Tcl_DStringStartSublist(dsPtr);
      sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", cbPtr->sock);
      Tcl_DStringAppendElement(dsPtr, buf);
      Tcl_DStringStartSublist(dsPtr);
      if (cbPtr->when & 1) {
        Tcl_DStringAppendElement(dsPtr, (char *)"read");
      }
      if (cbPtr->when & 2) {
        Tcl_DStringAppendElement(dsPtr, (char *)"write");
      }
      if (cbPtr->when & 4) {
        Tcl_DStringAppendElement(dsPtr, (char *)"exception");
      }
      if (cbPtr->when & 8) {
        Tcl_DStringAppendElement(dsPtr, (char *)"exit");
      }
      Tcl_DStringEndSublist(dsPtr);
      Ns_GetProcInfo(dsPtr, (void *)cbPtr->proc, cbPtr->arg);
      Tcl_DStringEndSublist(dsPtr);
      hPtr = Tcl_NextHashEntry(& search);
    }
  }
  Ns_MutexUnlock(& lock___10);
  return;
}
}
char *Ns_StrTrimLeft(char *string ) ;
char *Ns_StrTrimRight(char *string ) ;
char *Ns_Match(char *a , char *b ) ;
char *Ns_NextWord(char *line ) ;
char *Ns_StrNStr(char *string , char *substring ) ;
char *Ns_StrTrim(char *string ) 
{ char *tmp ;
  char *tmp___0 ;

  {
  tmp = Ns_StrTrimRight(string);
  tmp___0 = Ns_StrTrimLeft(tmp);
  return (tmp___0);
}
}
char *Ns_StrTrimLeft(char *string ) 
{ unsigned short const   **tmp ;

  {
  if ((unsigned int )string == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  }
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*string)))) & 8192)) {
      break;
    }
    string ++;
  }
  return (string);
}
}
char *Ns_StrTrimRight(char *string ) 
{ int len ;
  unsigned short const   **tmp ;

  {
  if ((unsigned int )string == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  }
  len = (int )strlen((char const   *)string);
  while (1) {
    len --;
    if (len >= 0) {
      tmp = __ctype_b_loc();
      if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*(string + len))))) &
             8192)) {
        if (! ((int )(*(string + len)) == 10)) {
          break;
        }
      }
    } else {
      break;
    }
    (*(string + len)) = (char )'\000';
  }
  return (string);
}
}
char *Ns_StrToLower(char *string ) 
{ char *s ;
  int __res ;
  __int32_t const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  s = string;
  while ((int )(*s) != 0) {
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + (int )((unsigned char )(*s)))) & 256) {
      if (sizeof((unsigned char )(*s)) > 1U) {
        __res = tolower__extinline((int )((unsigned char )(*s)));
      } else {
        tmp___1 = __ctype_tolower_loc();
        __res = (*((*tmp___1) + (int )((unsigned char )(*s))));
      }
      (*s) = (char )__res;
    }
    s ++;
  }
  return (string);
}
}
char *Ns_StrToUpper(char *string ) 
{ char *s ;
  int __res ;
  __int32_t const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  s = string;
  while ((int )(*s) != 0) {
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + (int )((unsigned char )(*s)))) & 512) {
      if (sizeof((unsigned char )(*s)) > 1U) {
        __res = toupper__extinline((int )((unsigned char )(*s)));
      } else {
        tmp___1 = __ctype_toupper_loc();
        __res = (*((*tmp___1) + (int )((unsigned char )(*s))));
      }
      (*s) = (char )__res;
    }
    s ++;
  }
  return (string);
}
}
char *Ns_Match(char *a , char *b ) 
{ char c1 ;
  char c2 ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int __res___2 ;
  __int32_t const   **tmp___13 ;
  unsigned short const   **tmp___14 ;

  {
  if ((unsigned int )a != (unsigned int )((void *)0)) {
    if ((unsigned int )b != (unsigned int )((void *)0)) {
      while (1) {
        if ((int )(*a) != 0) {
          if (! ((int )(*b) != 0)) {
            break;
          }
        } else {
          break;
        }
        tmp___6 = __ctype_b_loc();
        if ((int const   )(*((*tmp___6) + (int )((unsigned char )(*a)))) & 512) {
          c1 = (*a);
        } else {
          if (sizeof((unsigned char )(*a)) > 1U) {
            __res___0 = tolower__extinline((int )((unsigned char )(*a)));
          } else {
            tmp___5 = __ctype_tolower_loc();
            __res___0 = (*((*tmp___5) + (int )((unsigned char )(*a))));
          }
          c1 = (char )__res___0;
        }
        tmp___14 = __ctype_b_loc();
        if ((int const   )(*((*tmp___14) + (int )((unsigned char )(*b)))) & 512) {
          c2 = (*b);
        } else {
          if (sizeof((unsigned char )(*b)) > 1U) {
            __res___2 = tolower__extinline((int )((unsigned char )(*b)));
          } else {
            tmp___13 = __ctype_tolower_loc();
            __res___2 = (*((*tmp___13) + (int )((unsigned char )(*b))));
          }
          c2 = (char )__res___2;
        }
        if ((int )c1 != (int )c2) {
          return ((char *)((void *)0));
        }
        a ++;
        b ++;
      }
    }
  }
  return (b);
}
}
char *Ns_NextWord(char *line ) 
{ unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  while (1) {
    if ((int )(*line) != 0) {
      tmp = __ctype_b_loc();
      if ((int const   )(*((*tmp) + (int )((unsigned char )(*line)))) & 8192) {
        break;
      }
    } else {
      break;
    }
    line ++;
  }
  while (1) {
    if ((int )(*line) != 0) {
      tmp___0 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___0) + (int )((unsigned char )(*line)))) & 8192)) {
        break;
      }
    } else {
      break;
    }
    line ++;
  }
  return (line);
}
}
char *Ns_StrNStr(char *string , char *substring ) 
{ char *tmp ;

  {
  tmp = Ns_StrCaseFind(string, substring);
  return (tmp);
}
}
char *Ns_StrCaseFind(char *string , char *substring ) 
{ char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  tmp___0 = strlen((char const   *)string);
  tmp___1 = strlen((char const   *)substring);
  if (tmp___0 > tmp___1) {
    while ((int )(*string) != 0) {
      tmp = Ns_Match(string, substring);
      if (tmp) {
        return (string);
      }
      string ++;
    }
  }
  return ((char *)((void *)0));
}
}
extern char *Tcl_Concat(int argc , char **argv ) ;
extern int Tcl_GlobalEval(Tcl_Interp *interp , char *command ) ;
void NsFreeAtClose(NsInterp *itPtr ) ;
static void RunAtClose(NsInterp *itPtr , int run ) ;
int NsTclAtCloseCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ NsInterp *itPtr ;
  char *script ;
  AtClose *atPtr ;
  char *tmp ;
  size_t tmp___0 ;

  {
  itPtr = (NsInterp *)arg;
  if (argc < 2) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " script ?arg?\"",
                     (void *)0);
    return (1);
  } else {
    if (argc > 3) {
      Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " script ?arg?\"",
                       (void *)0);
      return (1);
    }
  }
  if (argc == 2) {
    script = (*(argv + 1));
  } else {
    tmp = Tcl_Concat(2, argv + 1);
    script = tmp;
  }
  tmp___0 = strlen((char const   *)script);
  atPtr = (AtClose *)ns_malloc(sizeof(AtClose ) + tmp___0);
  strcpy((char * __restrict  )(atPtr->script), (char const   * __restrict  )script);
  atPtr->nextPtr = itPtr->firstAtClosePtr;
  itPtr->firstAtClosePtr = atPtr;
  if ((unsigned int )script != (unsigned int )(*(argv + 1))) {
    Tcl_Free(script);
  }
  return (0);
}
}
void NsFreeAtClose(NsInterp *itPtr ) 
{ 

  {
  RunAtClose(itPtr, 0);
  return;
}
}
void NsRunAtClose(Tcl_Interp *interp ) 
{ NsInterp *itPtr ;
  NsInterp *tmp ;

  {
  tmp = NsGetInterp(interp);
  itPtr = tmp;
  RunAtClose(itPtr, 1);
  return;
}
}
static void RunAtClose(NsInterp *itPtr , int run ) 
{ Tcl_Interp *interp ;
  AtClose *atPtr ;
  int tmp ;

  {
  interp = itPtr->interp;
  while (1) {
    atPtr = itPtr->firstAtClosePtr;
    if (! ((unsigned int )atPtr != (unsigned int )((void *)0))) {
      break;
    }
    itPtr->firstAtClosePtr = atPtr->nextPtr;
    if (run) {
      tmp = Tcl_GlobalEval(interp, atPtr->script);
      if (tmp != 0) {
        Ns_TclLogError(interp);
      }
    }
    ns_free((void *)atPtr);
  }
  return;
}
}
extern Tcl_Command Tcl_CreateObjCommand(Tcl_Interp *interp , char *cmdName , Tcl_ObjCmdProc *proc ,
                                        ClientData clientData , Tcl_CmdDeleteProc *deleteProc ) ;
void NsTclAddCmds(Tcl_Interp *interp , NsInterp *itPtr ) ;
void NsTclAddServerCmds(Tcl_Interp *interp , NsInterp *itPtr ) ;
int NsTclChanObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclChmodObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclCondObjCmd(ClientData data , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclConnSendFpObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclCpFpObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclCpObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclCryptObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclCritSecObjCmd(ClientData data , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclDummyObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclICtlObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclFTruncateObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclGetAddrObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclGetHostObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclGetUrlObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclGifSizeObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclGmTimeObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclHTUUDecodeObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclHTUUEncodeObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclHeadersObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclHttpObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclJobObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclJpegSizeObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclKillObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclLinkObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclLocalTimeObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclMarkForDeleteObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclMkdirObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclMutexObjCmd(ClientData data , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclNormalizePathObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclNsvAppendObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclNsvArrayObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclNsvExistsObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclNsvGetObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclNsvIncrObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclNsvLappendObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclNsvNamesObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclNsvSetObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclNsvUnsetObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclPurgeFilesObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclRegisterAdpObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclRegisterFilterObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclRegisterProcObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclRegisterTraceObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclRenameObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclRespondObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclReturnBadRequestObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclReturnErrorObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclReturnFileObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclReturnForbiddenObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclReturnFpObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclReturnNotFoundObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclReturnObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclReturnRedirectObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclReturnUnauthorizedObjCmd(ClientData arg , Tcl_Interp *interp , int objc ,
                                  Tcl_Obj **objv ) ;
int NsTclRmdirObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclRollFileObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclRWLockObjCmd(ClientData data , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclSelectObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclSemaObjCmd(ClientData data , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclSetObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclSleepObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclSockAcceptObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclSockCallbackObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclSockCheckObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclSockListenCallbackObjCmd(ClientData arg , Tcl_Interp *interp , int objc ,
                                  Tcl_Obj **objv ) ;
int NsTclSockListenObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclSockNReadObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclSockOpenObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclSockSetBlockingObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclSockSetNonBlockingObjCmd(ClientData arg , Tcl_Interp *interp , int objc ,
                                  Tcl_Obj **objv ) ;
int NsTclSocketPairObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclStrftimeObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclSymlinkObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclTimeObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclTmpNamObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclTruncateObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclUnRegisterObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclUnlinkObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclUrl2FileObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclUrlDecodeObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclUrlEncodeObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclVarObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclWriteFpObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclWriteObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
int NsTclAfterCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclAtExitCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclAtShutdownCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclAtSignalCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclCancelCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclConfigCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclConfigSectionCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclConfigSectionsCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclEnvCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclHrefsCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclMkTempCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclParseHeaderCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclPauseCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclResumeCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclReturnAdminNoticeCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclReturnNoticeCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclSchedCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclSchedDailyCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclSchedWeeklyCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclShareCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclStripHtmlCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclThreadCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
int NsTclUnscheduleCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
int Tcl_KeyldelCmd(ClientData clientData , Tcl_Interp *interp , int argc , char **argv ) ;
int Tcl_KeylgetCmd(ClientData clientData , Tcl_Interp *interp , int argc , char **argv ) ;
int Tcl_KeylkeysCmd(ClientData clientData , Tcl_Interp *interp , int argc , char **argv ) ;
int Tcl_KeylsetCmd(ClientData clientData , Tcl_Interp *interp , int argc , char **argv ) ;
static Cmd cmds[98]  = 
  {      {(char *)"ns_crypt", (Tcl_CmdProc *)((void *)0), & NsTclCryptObjCmd}, 
        {(char *)"ns_sleep", (Tcl_CmdProc *)((void *)0), & NsTclSleepObjCmd}, 
        {(char *)"ns_localtime", (Tcl_CmdProc *)((void *)0), & NsTclLocalTimeObjCmd}, 
        {(char *)"ns_gmtime",
      (Tcl_CmdProc *)((void *)0), & NsTclGmTimeObjCmd}, 
        {(char *)"ns_time", (Tcl_CmdProc *)((void *)0), & NsTclTimeObjCmd}, 
        {(char *)"ns_fmttime", (Tcl_CmdProc *)((void *)0), & NsTclStrftimeObjCmd}, 
        {(char *)"ns_httptime", (Tcl_CmdProc *)((void *)0), & NsTclHttpTimeObjCmd}, 
        {(char *)"ns_parsehttptime", (Tcl_CmdProc *)((void *)0), & NsTclParseHttpTimeObjCmd}, 
        {(char *)"ns_parsequery",
      (Tcl_CmdProc *)((void *)0), & NsTclParseQueryObjCmd}, 
        {(char *)"ns_rand", (Tcl_CmdProc *)((void *)0), & NsTclRandObjCmd}, 
        {(char *)"ns_info", (Tcl_CmdProc *)((void *)0), & NsTclInfoObjCmd}, 
        {(char *)"ns_modulepath", (Tcl_CmdProc *)((void *)0), & NsTclModulePathObjCmd}, 
        {(char *)"ns_log",
      (Tcl_CmdProc *)((void *)0), & NsTclLogObjCmd}, 
        {(char *)"ns_logctl", (Tcl_CmdProc *)((void *)0), & NsTclLogCtlObjCmd}, 
        {(char *)"ns_logroll", (Tcl_CmdProc *)((void *)0), & NsTclLogRollObjCmd}, 
        {(char *)"ns_urlencode", (Tcl_CmdProc *)((void *)0), & NsTclUrlEncodeObjCmd}, 
        {(char *)"ns_urldecode",
      (Tcl_CmdProc *)((void *)0), & NsTclUrlDecodeObjCmd}, 
        {(char *)"ns_uuencode", (Tcl_CmdProc *)((void *)0), & NsTclHTUUEncodeObjCmd}, 
        {(char *)"ns_uudecode",
      (Tcl_CmdProc *)((void *)0), & NsTclHTUUDecodeObjCmd}, 
        {(char *)"ns_gifsize", (Tcl_CmdProc *)((void *)0), & NsTclGifSizeObjCmd}, 
        {(char *)"ns_jpegsize", (Tcl_CmdProc *)((void *)0), & NsTclJpegSizeObjCmd}, 
        {(char *)"ns_guesstype", (Tcl_CmdProc *)((void *)0), & NsTclGuessTypeObjCmd}, 
        {(char *)"ns_striphtml",
      & NsTclStripHtmlCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_quotehtml", & NsTclQuoteHtmlCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_hrefs",
      & NsTclHrefsCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_config", & NsTclConfigCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_configsection", & NsTclConfigSectionCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_configsections",
      & NsTclConfigSectionsCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_unlink", (Tcl_CmdProc *)((void *)0), & NsTclUnlinkObjCmd}, 
        {(char *)"ns_mkdir", (Tcl_CmdProc *)((void *)0), & NsTclMkdirObjCmd}, 
        {(char *)"ns_rmdir", (Tcl_CmdProc *)((void *)0), & NsTclRmdirObjCmd}, 
        {(char *)"ns_cp", (Tcl_CmdProc *)((void *)0), & NsTclCpObjCmd}, 
        {(char *)"ns_cpfp", (Tcl_CmdProc *)((void *)0), & NsTclCpFpObjCmd}, 
        {(char *)"ns_rollfile", (Tcl_CmdProc *)((void *)0), & NsTclRollFileObjCmd}, 
        {(char *)"ns_purgefiles", (Tcl_CmdProc *)((void *)0), & NsTclPurgeFilesObjCmd}, 
        {(char *)"ns_mktemp",
      & NsTclMkTempCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_tmpnam", (Tcl_CmdProc *)((void *)0), & NsTclTmpNamObjCmd}, 
        {(char *)"ns_normalizepath", (Tcl_CmdProc *)((void *)0), & NsTclNormalizePathObjCmd}, 
        {(char *)"ns_link",
      (Tcl_CmdProc *)((void *)0), & NsTclLinkObjCmd}, 
        {(char *)"ns_symlink", (Tcl_CmdProc *)((void *)0), & NsTclSymlinkObjCmd}, 
        {(char *)"ns_rename", (Tcl_CmdProc *)((void *)0), & NsTclRenameObjCmd}, 
        {(char *)"ns_kill", (Tcl_CmdProc *)((void *)0), & NsTclKillObjCmd}, 
        {(char *)"ns_writefp", (Tcl_CmdProc *)((void *)0), & NsTclWriteFpObjCmd}, 
        {(char *)"ns_truncate", (Tcl_CmdProc *)((void *)0), & NsTclTruncateObjCmd}, 
        {(char *)"ns_ftruncate", (Tcl_CmdProc *)((void *)0), & NsTclFTruncateObjCmd}, 
        {(char *)"ns_chmod",
      (Tcl_CmdProc *)((void *)0), & NsTclChmodObjCmd}, 
        {(char *)"ns_env", & NsTclEnvCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"env", & NsTclEnvCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_job", (Tcl_CmdProc *)((void *)0), & NsTclJobObjCmd}, 
        {(char *)"ns_http", (Tcl_CmdProc *)((void *)0), & NsTclHttpObjCmd}, 
        {(char *)"ns_schedule_proc", & NsTclSchedCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_schedule_daily",
      & NsTclSchedDailyCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_schedule_weekly", & NsTclSchedWeeklyCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_atsignal",
      & NsTclAtSignalCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_atshutdown", & NsTclAtShutdownCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_atexit",
      & NsTclAtExitCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_after", & NsTclAfterCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_cancel", & NsTclCancelCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_pause", & NsTclPauseCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_resume", & NsTclResumeCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_unschedule_proc", & NsTclUnscheduleCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_set",
      (Tcl_CmdProc *)((void *)0), & NsTclSetObjCmd}, 
        {(char *)"ns_parseheader", & NsTclParseHeaderCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_sockcallback",
      (Tcl_CmdProc *)((void *)0), & NsTclSockCallbackObjCmd}, 
        {(char *)"ns_socklistencallback", (Tcl_CmdProc *)((void *)0), & NsTclSockListenCallbackObjCmd}, 
        {(char *)"ns_sockblocking",
      (Tcl_CmdProc *)((void *)0), & NsTclSockSetBlockingObjCmd}, 
        {(char *)"ns_socknonblocking", (Tcl_CmdProc *)((void *)0), & NsTclSockSetNonBlockingObjCmd}, 
        {(char *)"ns_socknread",
      (Tcl_CmdProc *)((void *)0), & NsTclSockNReadObjCmd}, 
        {(char *)"ns_sockopen", (Tcl_CmdProc *)((void *)0), & NsTclSockOpenObjCmd}, 
        {(char *)"ns_socklisten", (Tcl_CmdProc *)((void *)0), & NsTclSockListenObjCmd}, 
        {(char *)"ns_sockaccept",
      (Tcl_CmdProc *)((void *)0), & NsTclSockAcceptObjCmd}, 
        {(char *)"ns_sockcheck", (Tcl_CmdProc *)((void *)0), & NsTclSockCheckObjCmd}, 
        {(char *)"ns_sockselect",
      (Tcl_CmdProc *)((void *)0), & NsTclSelectObjCmd}, 
        {(char *)"ns_socketpair", (Tcl_CmdProc *)((void *)0), & NsTclSocketPairObjCmd}, 
        {(char *)"ns_hostbyaddr",
      (Tcl_CmdProc *)((void *)0), & NsTclGetHostObjCmd}, 
        {(char *)"ns_addrbyhost", (Tcl_CmdProc *)((void *)0), & NsTclGetAddrObjCmd}, 
        {(char *)"keyldel", & Tcl_KeyldelCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"keylget", & Tcl_KeylgetCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"keylkeys", & Tcl_KeylkeysCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"keylset", & Tcl_KeylsetCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_cache_flush", & NsTclCacheFlushCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_cache_stats",
      & NsTclCacheStatsCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_cache_names", & NsTclCacheNamesCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_cache_size",
      & NsTclCacheSizeCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_cache_keys", & NsTclCacheKeysCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_thread",
      & NsTclThreadCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_mutex", (Tcl_CmdProc *)((void *)0), & NsTclMutexObjCmd}, 
        {(char *)"ns_cond", (Tcl_CmdProc *)((void *)0), & NsTclCondObjCmd}, 
        {(char *)"ns_event", (Tcl_CmdProc *)((void *)0), & NsTclCondObjCmd}, 
        {(char *)"ns_rwlock", (Tcl_CmdProc *)((void *)0), & NsTclRWLockObjCmd}, 
        {(char *)"ns_sema", (Tcl_CmdProc *)((void *)0), & NsTclSemaObjCmd}, 
        {(char *)"ns_critsec", (Tcl_CmdProc *)((void *)0), & NsTclCritSecObjCmd}, 
        {(char *)"ns_init", (Tcl_CmdProc *)((void *)0), & NsTclDummyObjCmd}, 
        {(char *)"ns_cleanup", (Tcl_CmdProc *)((void *)0), & NsTclDummyObjCmd}, 
        {(char *)"ns_markfordelete", (Tcl_CmdProc *)((void *)0), & NsTclMarkForDeleteObjCmd}, 
        {(char *)"ns_charsets",
      & NsTclCharsetsCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_encodingforcharset", & NsTclEncodingForCharsetCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)((void *)0),
      (Tcl_CmdProc *)((void *)0), (Tcl_ObjCmdProc *)0}};
static Cmd servCmds[75]  = 
  {      {(char *)"ns_register_filter", (Tcl_CmdProc *)((void *)0), & NsTclRegisterFilterObjCmd}, 
        {(char *)"ns_register_trace",
      (Tcl_CmdProc *)((void *)0), & NsTclRegisterTraceObjCmd}, 
        {(char *)"ns_register_adp", (Tcl_CmdProc *)((void *)0), & NsTclRegisterAdpObjCmd}, 
        {(char *)"ns_register_proc",
      (Tcl_CmdProc *)((void *)0), & NsTclRegisterProcObjCmd}, 
        {(char *)"ns_unregister_adp", (Tcl_CmdProc *)((void *)0), & NsTclUnRegisterObjCmd}, 
        {(char *)"ns_unregister_proc",
      (Tcl_CmdProc *)((void *)0), & NsTclUnRegisterObjCmd}, 
        {(char *)"ns_atclose", & NsTclAtCloseCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_return", (Tcl_CmdProc *)((void *)0), & NsTclReturnObjCmd}, 
        {(char *)"ns_respond", (Tcl_CmdProc *)((void *)0), & NsTclRespondObjCmd}, 
        {(char *)"ns_returnfile", (Tcl_CmdProc *)((void *)0), & NsTclReturnFileObjCmd}, 
        {(char *)"ns_returnfp",
      (Tcl_CmdProc *)((void *)0), & NsTclReturnFpObjCmd}, 
        {(char *)"ns_returnbadrequest", (Tcl_CmdProc *)((void *)0), & NsTclReturnBadRequestObjCmd}, 
        {(char *)"ns_returnerror",
      (Tcl_CmdProc *)((void *)0), & NsTclReturnErrorObjCmd}, 
        {(char *)"ns_returnnotice", & NsTclReturnNoticeCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_returnadminnotice",
      & NsTclReturnAdminNoticeCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_returnredirect", (Tcl_CmdProc *)((void *)0), & NsTclReturnRedirectObjCmd}, 
        {(char *)"ns_headers",
      (Tcl_CmdProc *)((void *)0), & NsTclHeadersObjCmd}, 
        {(char *)"ns_write", (Tcl_CmdProc *)((void *)0), & NsTclWriteObjCmd}, 
        {(char *)"ns_connsendfp", (Tcl_CmdProc *)((void *)0), & NsTclConnSendFpObjCmd}, 
        {(char *)"ns_returnforbidden",
      (Tcl_CmdProc *)((void *)0), & NsTclReturnForbiddenObjCmd}, 
        {(char *)"ns_returnunauthorized", (Tcl_CmdProc *)((void *)0), & NsTclReturnUnauthorizedObjCmd}, 
        {(char *)"ns_returnnotfound",
      (Tcl_CmdProc *)((void *)0), & NsTclReturnNotFoundObjCmd}, 
        {(char *)"ns_chan", (Tcl_CmdProc *)((void *)0), & NsTclChanObjCmd}, 
        {(char *)"ns_url2file", (Tcl_CmdProc *)((void *)0), & NsTclUrl2FileObjCmd}, 
        {(char *)"ns_library", & NsTclLibraryCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_geturl", (Tcl_CmdProc *)((void *)0), & NsTclGetUrlObjCmd}, 
        {(char *)"ns_checkurl", (Tcl_CmdProc *)((void *)0), & NsTclRequestAuthorizeObjCmd}, 
        {(char *)"ns_requestauthorize",
      (Tcl_CmdProc *)((void *)0), & NsTclRequestAuthorizeObjCmd}, 
        {(char *)"ns_shutdown", (Tcl_CmdProc *)((void *)0), & NsTclShutdownObjCmd}, 
        {(char *)"ns_conncptofp", (Tcl_CmdProc *)((void *)0), & NsTclWriteContentObjCmd}, 
        {(char *)"ns_writecontent",
      (Tcl_CmdProc *)((void *)0), & NsTclWriteContentObjCmd}, 
        {(char *)"ns_conn", (Tcl_CmdProc *)((void *)0), & NsTclConnObjCmd}, 
        {(char *)"ns_startcontent", (Tcl_CmdProc *)((void *)0), & NsTclStartContentObjCmd}, 
        {(char *)"ns_register_adptag",
      & NsTclRegisterTagCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_adp_registeradp", & NsTclAdpRegisterAdpCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_adp_registertag",
      & NsTclAdpRegisterAdpCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_adp_registerproc", & NsTclAdpRegisterProcCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_adp_stats",
      & NsTclAdpStatsCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_adp_debug", & NsTclAdpDebugCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"_ns_adp_include", (Tcl_CmdProc *)((void *)0), & NsTclAdpIncludeObjCmd}, 
        {(char *)"ns_adp_eval",
      (Tcl_CmdProc *)((void *)0), & NsTclAdpEvalObjCmd}, 
        {(char *)"ns_adp_safeeval", (Tcl_CmdProc *)((void *)0), & NsTclAdpSafeEvalObjCmd}, 
        {(char *)"ns_adp_parse",
      (Tcl_CmdProc *)((void *)0), & NsTclAdpParseObjCmd}, 
        {(char *)"ns_puts", (Tcl_CmdProc *)((void *)0), & NsTclAdpPutsObjCmd}, 
        {(char *)"ns_adp_puts", (Tcl_CmdProc *)((void *)0), & NsTclAdpPutsObjCmd}, 
        {(char *)"ns_adp_append", (Tcl_CmdProc *)((void *)0), & NsTclAdpAppendObjCmd}, 
        {(char *)"ns_adp_dir",
      (Tcl_CmdProc *)((void *)0), & NsTclAdpDirObjCmd}, 
        {(char *)"ns_adp_return", (Tcl_CmdProc *)((void *)0), & NsTclAdpReturnObjCmd}, 
        {(char *)"ns_adp_break",
      (Tcl_CmdProc *)((void *)0), & NsTclAdpBreakObjCmd}, 
        {(char *)"ns_adp_abort", (Tcl_CmdProc *)((void *)0), & NsTclAdpAbortObjCmd}, 
        {(char *)"ns_adp_tell", (Tcl_CmdProc *)((void *)0), & NsTclAdpTellObjCmd}, 
        {(char *)"ns_adp_trunc", (Tcl_CmdProc *)((void *)0), & NsTclAdpTruncObjCmd}, 
        {(char *)"ns_adp_dump", (Tcl_CmdProc *)((void *)0), & NsTclAdpDumpObjCmd}, 
        {(char *)"ns_adp_argc", (Tcl_CmdProc *)((void *)0), & NsTclAdpArgcObjCmd}, 
        {(char *)"ns_adp_argv", (Tcl_CmdProc *)((void *)0), & NsTclAdpArgvObjCmd}, 
        {(char *)"ns_adp_bind_args", (Tcl_CmdProc *)((void *)0), & NsTclAdpBindArgsObjCmd}, 
        {(char *)"ns_adp_exception",
      (Tcl_CmdProc *)((void *)0), & NsTclAdpExceptionObjCmd}, 
        {(char *)"ns_adp_stream", (Tcl_CmdProc *)((void *)0), & NsTclAdpStreamObjCmd}, 
        {(char *)"ns_adp_mime",
      (Tcl_CmdProc *)((void *)0), & NsTclAdpMimeTypeObjCmd}, 
        {(char *)"ns_adp_mimetype", (Tcl_CmdProc *)((void *)0), & NsTclAdpMimeTypeObjCmd}, 
        {(char *)"ns_adp_compress",
      (Tcl_CmdProc *)((void *)0), & NsTclAdpCompressObjCmd}, 
        {(char *)"ns_share", & NsTclShareCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_var", (Tcl_CmdProc *)((void *)0), & NsTclVarObjCmd}, 
        {(char *)"nsv_get", (Tcl_CmdProc *)((void *)0), & NsTclNsvGetObjCmd}, 
        {(char *)"nsv_exists", (Tcl_CmdProc *)((void *)0), & NsTclNsvExistsObjCmd}, 
        {(char *)"nsv_set", (Tcl_CmdProc *)((void *)0), & NsTclNsvSetObjCmd}, 
        {(char *)"nsv_incr", (Tcl_CmdProc *)((void *)0), & NsTclNsvIncrObjCmd}, 
        {(char *)"nsv_append", (Tcl_CmdProc *)((void *)0), & NsTclNsvAppendObjCmd}, 
        {(char *)"nsv_lappend", (Tcl_CmdProc *)((void *)0), & NsTclNsvLappendObjCmd}, 
        {(char *)"nsv_array",
      (Tcl_CmdProc *)((void *)0), & NsTclNsvArrayObjCmd}, 
        {(char *)"nsv_unset", (Tcl_CmdProc *)((void *)0), & NsTclNsvUnsetObjCmd}, 
        {(char *)"nsv_names", (Tcl_CmdProc *)((void *)0), & NsTclNsvNamesObjCmd}, 
        {(char *)"ns_server", (Tcl_CmdProc *)((void *)0), & NsTclServerObjCmd}, 
        {(char *)"ns_ictl", (Tcl_CmdProc *)((void *)0), & NsTclICtlObjCmd}, 
        {(char *)((void *)0), (Tcl_CmdProc *)((void *)0), (Tcl_ObjCmdProc *)0}};
static void AddCmds(Cmd *cmdPtr , ClientData arg , Tcl_Interp *interp ) 
{ 

  {
  while ((unsigned int )cmdPtr->name != (unsigned int )((void *)0)) {
    if ((unsigned int )cmdPtr->objProc != (unsigned int )((void *)0)) {
      Tcl_CreateObjCommand(interp, cmdPtr->name, cmdPtr->objProc, arg, (Tcl_CmdDeleteProc *)((void *)0));
    } else {
      Tcl_CreateCommand(interp, cmdPtr->name, cmdPtr->proc, arg, (Tcl_CmdDeleteProc *)((void *)0));
    }
    cmdPtr ++;
  }
  return;
}
}
void NsTclAddCmds(Tcl_Interp *interp , NsInterp *itPtr ) 
{ 

  {
  AddCmds(cmds, (void *)itPtr, interp);
  return;
}
}
void NsTclAddServerCmds(Tcl_Interp *interp , NsInterp *itPtr ) 
{ 

  {
  AddCmds(servCmds, (void *)itPtr, interp);
  return;
}
}
extern int Tcl_GetBoolean(Tcl_Interp *interp , char *str , int *boolPtr ) ;
extern int Tcl_GetInt(Tcl_Interp *interp , char *str , int *intPtr ) ;
int NsTclConfigCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) 
{ char *value ;
  int i ;
  int fHasDefault ;
  int defaultIndex ;
  Tcl_Obj *tmp ;
  int tmp___0 ;
  Tcl_Obj *tmp___1 ;
  int tmp___2 ;
  int iValue ;
  int tmp___3 ;
  int tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;

  {
  fHasDefault = 0;
  defaultIndex = 0;
  if (argc < 3) {
    Tcl_AppendResult(interp, "wrong # args:  should be \"", (*(argv + 0)), " ?-exact | -bool | -int? section key ?default?\"",
                     (void *)0);
    return (1);
  } else {
    if (argc > 5) {
      Tcl_AppendResult(interp, "wrong # args:  should be \"", (*(argv + 0)), " ?-exact | -bool | -int? section key ?default?\"",
                       (void *)0);
      return (1);
    }
  }
  if ((int )(*((*(argv + 1)) + 0)) == 45) {
    if (argc == 5) {
      fHasDefault = 1;
      defaultIndex = 4;
    }
  } else {
    if (argc == 4) {
      fHasDefault = 1;
      defaultIndex = 3;
    }
  }
  if ((int )(*((*(argv + 1)))) == (int )(*"-exact")) {
    if (0) {
      __s1_len___1 = strlen((char const   *)(*(argv + 1)));
      __s2_len___1 = strlen("-exact");
      if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                       1))) ==
             1U)) {
        goto _L___7;
      } else {
        if (__s1_len___1 >= 4U) {
          _L___7: 
          if (! ((unsigned int )((void const   *)("-exact" + 1)) - (unsigned int )((void const   *)"-exact") ==
                 1U)) {
            tmp___28 = 1;
          } else {
            if (__s2_len___1 >= 4U) {
              tmp___28 = 1;
            } else {
              tmp___28 = 0;
            }
          }
        } else {
          tmp___28 = 0;
        }
      }
      if (tmp___28) {
        if (__s1_len___1 < __s2_len___1) {
          tmp___26 = __s1_len___1;
        } else {
          tmp___26 = __s2_len___1;
        }
        tmp___25 = memcmp((void const   *)((char const   *)(*(argv + 1))), (void const   *)"-exact",
                          tmp___26 + 1U);
      } else {
        tmp___27 = strcmp((char const   *)(*(argv + 1)), "-exact");
        tmp___25 = tmp___27;
      }
    } else {
      tmp___27 = strcmp((char const   *)(*(argv + 1)), "-exact");
      tmp___25 = tmp___27;
    }
    if (tmp___25 == 0) {
      value = Ns_ConfigGetValueExact((*(argv + 2)), (*(argv + 3)));
      if ((unsigned int )value == (unsigned int )((void *)0)) {
        if (fHasDefault) {
          value = (*(argv + defaultIndex));
        }
      }
    } else {
      goto _L___8;
    }
  } else {
    _L___8: 
    if ((int )(*((*(argv + 1)))) == (int )(*"-int")) {
      if (0) {
        __s1_len___0 = strlen((char const   *)(*(argv + 1)));
        __s2_len___0 = strlen("-int");
        if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                         1))) ==
               1U)) {
          goto _L___4;
        } else {
          if (__s1_len___0 >= 4U) {
            _L___4: 
            if (! ((unsigned int )((void const   *)("-int" + 1)) - (unsigned int )((void const   *)"-int") ==
                   1U)) {
              tmp___20 = 1;
            } else {
              if (__s2_len___0 >= 4U) {
                tmp___20 = 1;
              } else {
                tmp___20 = 0;
              }
            }
          } else {
            tmp___20 = 0;
          }
        }
        if (tmp___20) {
          if (__s1_len___0 < __s2_len___0) {
            tmp___18 = __s1_len___0;
          } else {
            tmp___18 = __s2_len___0;
          }
          tmp___17 = memcmp((void const   *)((char const   *)(*(argv + 1))), (void const   *)"-int",
                            tmp___18 + 1U);
        } else {
          tmp___19 = strcmp((char const   *)(*(argv + 1)), "-int");
          tmp___17 = tmp___19;
        }
      } else {
        tmp___19 = strcmp((char const   *)(*(argv + 1)), "-int");
        tmp___17 = tmp___19;
      }
      if (tmp___17 == 0) {
        tmp___2 = Ns_ConfigGetInt((*(argv + 2)), (*(argv + 3)), & i);
        if (tmp___2) {
          tmp = Tcl_NewIntObj(i);
          Tcl_SetObjResult(interp, tmp);
          return (0);
        } else {
          if (fHasDefault) {
            tmp___0 = Tcl_GetInt(interp, (*(argv + defaultIndex)), & i);
            if (tmp___0 != 0) {
              return (1);
            }
            tmp___1 = Tcl_NewIntObj(i);
            Tcl_SetObjResult(interp, tmp___1);
            return (0);
          }
        }
        value = (char *)((void *)0);
      } else {
        goto _L___5;
      }
    } else {
      _L___5: 
      if ((int )(*((*(argv + 1)))) == (int )(*"-bool")) {
        if (0) {
          __s1_len = strlen((char const   *)(*(argv + 1)));
          __s2_len = strlen("-bool");
          if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                           1))) ==
                 1U)) {
            goto _L___1;
          } else {
            if (__s1_len >= 4U) {
              _L___1: 
              if (! ((unsigned int )((void const   *)("-bool" + 1)) - (unsigned int )((void const   *)"-bool") ==
                     1U)) {
                tmp___12 = 1;
              } else {
                if (__s2_len >= 4U) {
                  tmp___12 = 1;
                } else {
                  tmp___12 = 0;
                }
              }
            } else {
              tmp___12 = 0;
            }
          }
          if (tmp___12) {
            if (__s1_len < __s2_len) {
              tmp___10 = __s1_len;
            } else {
              tmp___10 = __s2_len;
            }
            tmp___9 = memcmp((void const   *)((char const   *)(*(argv + 1))), (void const   *)"-bool",
                             tmp___10 + 1U);
          } else {
            tmp___11 = strcmp((char const   *)(*(argv + 1)), "-bool");
            tmp___9 = tmp___11;
          }
        } else {
          tmp___11 = strcmp((char const   *)(*(argv + 1)), "-bool");
          tmp___9 = tmp___11;
        }
        if (tmp___9 == 0) {
          tmp___4 = Ns_ConfigGetBool((*(argv + 2)), (*(argv + 3)), & iValue);
          if (tmp___4 == 0) {
            if (fHasDefault) {
              tmp___3 = Tcl_GetBoolean(interp, (*(argv + defaultIndex)), & iValue);
              if (tmp___3 != 0) {
                return (1);
              }
              if (iValue) {
                value = (char *)"1";
              } else {
                value = (char *)"0";
              }
            } else {
              value = (char *)((void *)0);
            }
          } else {
            if (iValue) {
              value = (char *)"1";
            } else {
              value = (char *)"0";
            }
          }
        } else {
          goto _L___2;
        }
      } else {
        _L___2: 
        if (argc == 3) {
          goto _L;
        } else {
          if (argc == 4) {
            _L: 
            value = Ns_ConfigGetValue((*(argv + 1)), (*(argv + 2)));
            if ((unsigned int )value == (unsigned int )((void *)0)) {
              if (fHasDefault) {
                value = (*(argv + defaultIndex));
              }
            }
          } else {
            Tcl_AppendResult(interp, "wrong # args:  should be \"", (*(argv + 0)),
                             " ?-exact | -bool | -int? section key ?default?\"", (void *)0);
            return (1);
          }
        }
      }
    }
  }
  if ((unsigned int )value != (unsigned int )((void *)0)) {
    Tcl_SetResult(interp, value, (Tcl_FreeProc *)0);
  }
  return (0);
}
}
int NsTclConfigSectionCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) 
{ Ns_Set *set ;

  {
  if (argc != 2) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " key\"",
                     (void *)0);
    return (1);
  }
  set = Ns_ConfigGetSection((*(argv + 1)));
  if ((unsigned int )set == (unsigned int )((void *)0)) {
    Tcl_SetResult(interp, (char *)"", (Tcl_FreeProc *)0);
  } else {
    Ns_TclEnterSet(interp, set, 0);
  }
  return (0);
}
}
int NsTclConfigSectionsCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) 
{ Ns_Set **sets ;
  int i ;

  {
  if (argc != 1) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " key\"",
                     (void *)0);
    return (1);
  }
  sets = Ns_ConfigGetSections();
  i = 0;
  while ((unsigned int )(*(sets + i)) != (unsigned int )((void *)0)) {
    Ns_TclEnterSet(interp, (*(sets + i)), 0);
    i ++;
  }
  ns_free((void *)sets);
  return (0);
}
}
extern char *strcat(char * __restrict  __dest , char const   * __restrict  __src ) ;
extern void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern char **environ ;
extern void free(void *__ptr ) ;
extern char *getenv(char const   *__name ) ;
extern int putenv(char *__string ) ;
char **Ns_GetEnviron(void) ;
static int PutEnv(Tcl_Interp *interp , char *name , char *value ) ;
static Ns_Mutex lock___11  ;
char **Ns_CopyEnviron(Tcl_DString *dsPtr ) 
{ char *s ;
  char **envp ;
  int i ;
  char **tmp ;

  {
  Ns_MutexLock(& lock___11);
  envp = Ns_GetEnviron();
  i = 0;
  while (1) {
    s = (*(envp + i));
    if (! ((unsigned int )s != (unsigned int )((void *)0))) {
      break;
    }
    Ns_DStringAppendArg(dsPtr, s);
    i ++;
  }
  Ns_MutexUnlock(& lock___11);
  tmp = Ns_DStringAppendArgv(dsPtr);
  return (tmp);
}
}
int NsTclEnvCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) 
{ char *name ;
  char *value ;
  char **envp ;
  int status ;
  int i ;
  Tcl_DString ds ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  size_t tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___42 ;
  size_t tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___50 ;
  size_t tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___58 ;
  size_t tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;

  {
  if (argc < 2) {
    Tcl_AppendResult(interp, "wrong # args:  should be \"", (*(argv + 0)), " command ?args ...?\"",
                     (void *)0);
    return (1);
  }
  status = 0;
  Ns_MutexLock(& lock___11);
  if ((int )(*((*(argv + 1)))) == (int )(*"names")) {
    if (0) {
      __s1_len___5 = strlen((char const   *)(*(argv + 1)));
      __s2_len___5 = strlen("names");
      if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                       1))) ==
             1U)) {
        goto _L___19;
      } else {
        if (__s1_len___5 >= 4U) {
          _L___19: 
          if (! ((unsigned int )((void const   *)("names" + 1)) - (unsigned int )((void const   *)"names") ==
                 1U)) {
            tmp___61 = 1;
          } else {
            if (__s2_len___5 >= 4U) {
              tmp___61 = 1;
            } else {
              tmp___61 = 0;
            }
          }
        } else {
          tmp___61 = 0;
        }
      }
      if (tmp___61) {
        if (__s1_len___5 < __s2_len___5) {
          tmp___59 = __s1_len___5;
        } else {
          tmp___59 = __s2_len___5;
        }
        tmp___58 = memcmp((void const   *)((char const   *)(*(argv + 1))), (void const   *)"names",
                          tmp___59 + 1U);
      } else {
        tmp___60 = strcmp((char const   *)(*(argv + 1)), "names");
        tmp___58 = tmp___60;
      }
    } else {
      tmp___60 = strcmp((char const   *)(*(argv + 1)), "names");
      tmp___58 = tmp___60;
    }
    if (tmp___58 == 0) {
      if (argc != 2) {
        Tcl_AppendResult(interp, "wrong # args:  should be \"", (*(argv + 0)), " names\"",
                         (void *)0);
        status = 1;
      } else {
        Tcl_DStringInit(& ds);
        envp = Ns_GetEnviron();
        i = 0;
        while ((unsigned int )(*(envp + i)) != (unsigned int )((void *)0)) {
          name = (*(envp + i));
          tmp___0 = strchr((char const   *)name, '=');
          value = tmp___0;
          if (value) {
            tmp___1 = value - name;
          } else {
            tmp___1 = -1;
          }
          Tcl_DStringAppend(& ds, name, tmp___1);
          Tcl_AppendElement(interp, ds.string);
          Tcl_DStringSetLength(& ds, 0);
          i ++;
        }
        Tcl_DStringFree(& ds);
      }
    } else {
      goto _L___20;
    }
  } else {
    _L___20: 
    if ((int )(*((*(argv + 1)))) == (int )(*"exists")) {
      if (0) {
        __s1_len___4 = strlen((char const   *)(*(argv + 1)));
        __s2_len___4 = strlen("exists");
        if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                         1))) ==
               1U)) {
          goto _L___16;
        } else {
          if (__s1_len___4 >= 4U) {
            _L___16: 
            if (! ((unsigned int )((void const   *)("exists" + 1)) - (unsigned int )((void const   *)"exists") ==
                   1U)) {
              tmp___53 = 1;
            } else {
              if (__s2_len___4 >= 4U) {
                tmp___53 = 1;
              } else {
                tmp___53 = 0;
              }
            }
          } else {
            tmp___53 = 0;
          }
        }
        if (tmp___53) {
          if (__s1_len___4 < __s2_len___4) {
            tmp___51 = __s1_len___4;
          } else {
            tmp___51 = __s2_len___4;
          }
          tmp___50 = memcmp((void const   *)((char const   *)(*(argv + 1))), (void const   *)"exists",
                            tmp___51 + 1U);
        } else {
          tmp___52 = strcmp((char const   *)(*(argv + 1)), "exists");
          tmp___50 = tmp___52;
        }
      } else {
        tmp___52 = strcmp((char const   *)(*(argv + 1)), "exists");
        tmp___50 = tmp___52;
      }
      if (tmp___50 == 0) {
        if (argc != 3) {
          Tcl_AppendResult(interp, "wrong # args:  should be \"", (*(argv + 0)), " exists name\"",
                           (void *)0);
          status = 1;
        } else {
          tmp___4 = getenv((char const   *)(*(argv + 2)));
          if (tmp___4) {
            tmp___3 = "1";
          } else {
            tmp___3 = "0";
          }
          Tcl_SetResult(interp, (char *)tmp___3, (Tcl_FreeProc *)0);
        }
      } else {
        goto _L___17;
      }
    } else {
      _L___17: 
      if ((int )(*((*(argv + 1)))) == (int )(*"get")) {
        if (0) {
          __s1_len___3 = strlen((char const   *)(*(argv + 1)));
          __s2_len___3 = strlen("get");
          if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                           1))) ==
                 1U)) {
            goto _L___13;
          } else {
            if (__s1_len___3 >= 4U) {
              _L___13: 
              if (! ((unsigned int )((void const   *)("get" + 1)) - (unsigned int )((void const   *)"get") ==
                     1U)) {
                tmp___45 = 1;
              } else {
                if (__s2_len___3 >= 4U) {
                  tmp___45 = 1;
                } else {
                  tmp___45 = 0;
                }
              }
            } else {
              tmp___45 = 0;
            }
          }
          if (tmp___45) {
            if (__s1_len___3 < __s2_len___3) {
              tmp___43 = __s1_len___3;
            } else {
              tmp___43 = __s2_len___3;
            }
            tmp___42 = memcmp((void const   *)((char const   *)(*(argv + 1))), (void const   *)"get",
                              tmp___43 + 1U);
          } else {
            tmp___44 = strcmp((char const   *)(*(argv + 1)), "get");
            tmp___42 = tmp___44;
          }
        } else {
          tmp___44 = strcmp((char const   *)(*(argv + 1)), "get");
          tmp___42 = tmp___44;
        }
        if (tmp___42 == 0) {
          if (argc != 3) {
            if (argc != 4) {
              goto badargs;
            } else {
              goto _L___3;
            }
          } else {
            _L___3: 
            if (argc == 4) {
              if ((int )(*((*(argv + 2)))) == (int )(*"-nocomplain")) {
                if (0) {
                  __s1_len = strlen((char const   *)(*(argv + 2)));
                  __s2_len = strlen("-nocomplain");
                  if (! ((unsigned int )((void const   *)((*(argv + 2)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                                   2))) ==
                         1U)) {
                    goto _L___0;
                  } else {
                    if (__s1_len >= 4U) {
                      _L___0: 
                      if (! ((unsigned int )((void const   *)("-nocomplain" + 1)) -
                             (unsigned int )((void const   *)"-nocomplain") == 1U)) {
                        tmp___12 = 1;
                      } else {
                        if (__s2_len >= 4U) {
                          tmp___12 = 1;
                        } else {
                          tmp___12 = 0;
                        }
                      }
                    } else {
                      tmp___12 = 0;
                    }
                  }
                  if (tmp___12) {
                    if (__s1_len < __s2_len) {
                      tmp___10 = __s1_len;
                    } else {
                      tmp___10 = __s2_len;
                    }
                    tmp___9 = memcmp((void const   *)((char const   *)(*(argv + 2))),
                                     (void const   *)"-nocomplain", tmp___10 + 1U);
                  } else {
                    tmp___11 = strcmp((char const   *)(*(argv + 2)), "-nocomplain");
                    tmp___9 = tmp___11;
                  }
                } else {
                  tmp___11 = strcmp((char const   *)(*(argv + 2)), "-nocomplain");
                  tmp___9 = tmp___11;
                }
                if (! (tmp___9 == 0)) {
                  goto badargs;
                }
              } else {
                badargs: 
                Tcl_AppendResult(interp, "wrong # args:  should be \"", (*(argv +
                                                                           0)), " ",
                                 (*(argv + 1)), " ?-nocomplain? name\"", (void *)0);
                status = 1;
              }
            }
          }
          name = (*(argv + (argc - 1)));
          value = getenv((char const   *)name);
          if ((unsigned int )value != (unsigned int )((void *)0)) {
            Tcl_SetResult(interp, value, (Tcl_FreeProc *)1);
          } else {
            if (argc == 4) {
              Tcl_AppendResult(interp, "no such environment variable: ", (*(argv +
                                                                            (argc -
                                                                             1))),
                               (void *)0);
              status = 1;
            }
          }
        } else {
          goto _L___14;
        }
      } else {
        _L___14: 
        if ((int )(*((*(argv + 1)))) == (int )(*"set")) {
          if (0) {
            __s1_len___2 = strlen((char const   *)(*(argv + 1)));
            __s2_len___2 = strlen("set");
            if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                             1))) ==
                   1U)) {
              goto _L___10;
            } else {
              if (__s1_len___2 >= 4U) {
                _L___10: 
                if (! ((unsigned int )((void const   *)("set" + 1)) - (unsigned int )((void const   *)"set") ==
                       1U)) {
                  tmp___37 = 1;
                } else {
                  if (__s2_len___2 >= 4U) {
                    tmp___37 = 1;
                  } else {
                    tmp___37 = 0;
                  }
                }
              } else {
                tmp___37 = 0;
              }
            }
            if (tmp___37) {
              if (__s1_len___2 < __s2_len___2) {
                tmp___35 = __s1_len___2;
              } else {
                tmp___35 = __s2_len___2;
              }
              tmp___34 = memcmp((void const   *)((char const   *)(*(argv + 1))), (void const   *)"set",
                                tmp___35 + 1U);
            } else {
              tmp___36 = strcmp((char const   *)(*(argv + 1)), "set");
              tmp___34 = tmp___36;
            }
          } else {
            tmp___36 = strcmp((char const   *)(*(argv + 1)), "set");
            tmp___34 = tmp___36;
          }
          if (tmp___34 == 0) {
            if (argc != 4) {
              Tcl_AppendResult(interp, "wrong # args:  should be \"", (*(argv + 0)),
                               " set name value\"", (void *)0);
              status = 1;
            } else {
              status = PutEnv(interp, (*(argv + 2)), (*(argv + 3)));
            }
          } else {
            goto _L___11;
          }
        } else {
          _L___11: 
          if ((int )(*((*(argv + 1)))) == (int )(*"unset")) {
            if (0) {
              __s1_len___1 = strlen((char const   *)(*(argv + 1)));
              __s2_len___1 = strlen("unset");
              if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                               1))) ==
                     1U)) {
                goto _L___8;
              } else {
                if (__s1_len___1 >= 4U) {
                  _L___8: 
                  if (! ((unsigned int )((void const   *)("unset" + 1)) - (unsigned int )((void const   *)"unset") ==
                         1U)) {
                    tmp___29 = 1;
                  } else {
                    if (__s2_len___1 >= 4U) {
                      tmp___29 = 1;
                    } else {
                      tmp___29 = 0;
                    }
                  }
                } else {
                  tmp___29 = 0;
                }
              }
              if (tmp___29) {
                if (__s1_len___1 < __s2_len___1) {
                  tmp___27 = __s1_len___1;
                } else {
                  tmp___27 = __s2_len___1;
                }
                tmp___26 = memcmp((void const   *)((char const   *)(*(argv + 1))),
                                  (void const   *)"unset", tmp___27 + 1U);
              } else {
                tmp___28 = strcmp((char const   *)(*(argv + 1)), "unset");
                tmp___26 = tmp___28;
              }
            } else {
              tmp___28 = strcmp((char const   *)(*(argv + 1)), "unset");
              tmp___26 = tmp___28;
            }
            if (tmp___26 == 0) {
              if (argc != 3) {
                if (argc != 4) {
                  goto badargs;
                } else {
                  goto _L___6;
                }
              } else {
                _L___6: 
                if (argc == 4) {
                  if ((int )(*((*(argv + 2)))) == (int )(*"-nocomplain")) {
                    if (0) {
                      __s1_len___0 = strlen((char const   *)(*(argv + 2)));
                      __s2_len___0 = strlen("-nocomplain");
                      if (! ((unsigned int )((void const   *)((*(argv + 2)) + 1)) -
                             (unsigned int )((void const   *)(*(argv + 2))) == 1U)) {
                        goto _L___5;
                      } else {
                        if (__s1_len___0 >= 4U) {
                          _L___5: 
                          if (! ((unsigned int )((void const   *)("-nocomplain" +
                                                                  1)) - (unsigned int )((void const   *)"-nocomplain") ==
                                 1U)) {
                            tmp___20 = 1;
                          } else {
                            if (__s2_len___0 >= 4U) {
                              tmp___20 = 1;
                            } else {
                              tmp___20 = 0;
                            }
                          }
                        } else {
                          tmp___20 = 0;
                        }
                      }
                      if (tmp___20) {
                        if (__s1_len___0 < __s2_len___0) {
                          tmp___18 = __s1_len___0;
                        } else {
                          tmp___18 = __s2_len___0;
                        }
                        tmp___17 = memcmp((void const   *)((char const   *)(*(argv +
                                                                              2))),
                                          (void const   *)"-nocomplain", tmp___18 +
                                                                         1U);
                      } else {
                        tmp___19 = strcmp((char const   *)(*(argv + 2)), "-nocomplain");
                        tmp___17 = tmp___19;
                      }
                    } else {
                      tmp___19 = strcmp((char const   *)(*(argv + 2)), "-nocomplain");
                      tmp___17 = tmp___19;
                    }
                    if (! (tmp___17 == 0)) {
                      goto badargs;
                    }
                  } else {
                    goto badargs;
                  }
                }
              }
              name = (*(argv + (argc - 1)));
              if (argc == 3) {
                tmp___21 = getenv((char const   *)name);
                if ((unsigned int )tmp___21 == (unsigned int )((void *)0)) {
                  Tcl_AppendResult(interp, "no such environment variable: ", name,
                                   (void *)0);
                  status = 1;
                } else {
                  status = PutEnv(interp, name, (char *)"");
                }
              } else {
                status = PutEnv(interp, name, (char *)"");
              }
            } else {
              Tcl_AppendResult(interp, "unknown command \"", (*(argv + 1)), "\": should be exists, names, get, set, or unset",
                               (void *)0);
              status = 1;
            }
          } else {
            Tcl_AppendResult(interp, "unknown command \"", (*(argv + 1)), "\": should be exists, names, get, set, or unset",
                             (void *)0);
            status = 1;
          }
        }
      }
    }
  }
  Ns_MutexUnlock(& lock___11);
  return (status);
}
}
static int PutEnv(Tcl_Interp *interp , char *name , char *value ) 
{ char *s ;
  size_t len ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  len = strlen((char const   *)name);
  if ((unsigned int )value != (unsigned int )((void *)0)) {
    tmp = strlen((char const   *)value);
    len += tmp + 1U;
  }
  s = (char *)malloc(len + 1U);
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    Tcl_SetResult(interp, (char *)"could not allocate memory for new env entry", (Tcl_FreeProc *)0);
    return (1);
  }
  strcpy((char * __restrict  )s, (char const   * __restrict  )name);
  if ((unsigned int )value != (unsigned int )((void *)0)) {
    strcat((char * __restrict  )s, (char const   * __restrict  )"=");
    strcat((char * __restrict  )s, (char const   * __restrict  )value);
  }
  tmp___1 = putenv(s);
  if (tmp___1 != 0) {
    tmp___0 = Tcl_PosixError(interp);
    Tcl_AppendResult(interp, "could not put environment entry \"", s, "\": ", tmp___0,
                     (void *)0);
    free((void *)s);
    return (1);
  }
  return (0);
}
}
char **Ns_GetEnviron(void) 
{ char **envp ;

  {
  envp = environ;
  return (envp);
}
}
extern int link(char const   *__from , char const   *__to ) ;
extern int symlink(char const   *__from , char const   *__to ) ;
extern int rmdir(char const   *__path ) ;
extern int truncate(char const   *__file , __off_t __length ) ;
extern char *tmpnam(char *__s ) ;
extern int Tcl_Close(Tcl_Interp *interp , Tcl_Channel chan ) ;
extern int Tcl_GetChannelHandle(Tcl_Channel chan , int direction , ClientData *handlePtr ) ;
extern char *Tcl_GetChannelName(Tcl_Channel chan ) ;
extern void Tcl_RegisterChannel(Tcl_Interp *interp , Tcl_Channel chan ) ;
extern int Tcl_UnregisterChannel(Tcl_Interp *interp , Tcl_Channel chan ) ;
extern int Tcl_IsChannelShared(Tcl_Channel channel ) ;
extern int Tcl_IsChannelRegistered(Tcl_Interp *interp , Tcl_Channel channel ) ;
extern void Tcl_CutChannel(Tcl_Channel channel ) ;
extern void Tcl_SpliceChannel(Tcl_Channel channel ) ;
extern void Tcl_ClearChannelHandlers(Tcl_Channel channel ) ;
extern int chmod(char const   *__file , __mode_t __mode ) ;
extern int mkdir(char const   *__path , __mode_t __mode ) ;
extern int kill(__pid_t __pid , int __sig ) ;
int Ns_TclGetOpenChannel(Tcl_Interp *interp , char *chanId , int write___0 , int check ,
                         Tcl_Channel *chanPtr ) ;
int Ns_TclGetOpenFd(Tcl_Interp *interp , char *chanId , int write___0 , int *fdPtr ) ;
extern int utime(char const   *__file , struct utimbuf  const  *__file_times ) ;
static void SpliceChannel(Tcl_Interp *interp , Tcl_Channel chan ) ;
static void UnspliceChannel(Tcl_Interp *interp , Tcl_Channel chan ) ;
static int GetOpenChannel(Tcl_Interp *interp , Tcl_Obj *obj , int write___0 , int check ,
                          Tcl_Channel *chanPtr ) 
{ char *tmp ;
  int tmp___0 ;

  {
  tmp = Tcl_GetString(obj);
  tmp___0 = Ns_TclGetOpenChannel(interp, tmp, write___0, check, chanPtr);
  return (tmp___0);
}
}
int Ns_TclGetOpenChannel(Tcl_Interp *interp , char *chanId , int write___0 , int check ,
                         Tcl_Channel *chanPtr ) 
{ int mode ;
  char const   *tmp ;

  {
  (*chanPtr) = Tcl_GetChannel(interp, chanId, & mode);
  if ((unsigned int )(*chanPtr) == (unsigned int )((void *)0)) {
    return (1);
  }
  if (check) {
    if (write___0) {
      if (! (mode & 4)) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if (! write___0) {
        if (! (mode & 2)) {
          _L: 
          if (write___0) {
            tmp = "write";
          } else {
            tmp = "read";
          }
          Tcl_AppendResult(interp, "channel \"", chanId, "\" not open for ", tmp,
                           (void *)0);
          return (1);
        }
      }
    }
  }
  return (0);
}
}
int Ns_TclGetOpenFd(Tcl_Interp *interp , char *chanId , int write___0 , int *fdPtr ) 
{ Tcl_Channel chan ;
  ClientData data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = Ns_TclGetOpenChannel(interp, chanId, write___0, 1, & chan);
  if (tmp != 0) {
    return (1);
  }
  if (write___0) {
    tmp___0 = 4;
  } else {
    tmp___0 = 2;
  }
  tmp___1 = Tcl_GetChannelHandle(chan, tmp___0, & data);
  if (tmp___1 != 0) {
    Tcl_AppendResult(interp, "could not get handle for channel: ", chanId, (void *)0);
    return (1);
  }
  (*fdPtr) = (int )data;
  return (0);
}
}
int NsTclCpFpObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Tcl_Channel in ;
  Tcl_Channel out ;
  char buf[2048] ;
  char *p ;
  int tocopy ;
  int nread ;
  int nwrote ;
  int toread ;
  int ntotal ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  Tcl_Obj *tmp___4 ;
  char *tmp___5 ;
  Tcl_Obj *tmp___6 ;
  char *tmp___7 ;
  Tcl_Obj *tmp___8 ;
  Tcl_Obj *tmp___9 ;

  {
  if (objc != 3) {
    if (objc != 4) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"inChan outChan ?ncopy?");
      return (1);
    }
  }
  tmp = GetOpenChannel(interp, (*(objv + 1)), 0, 1, & in);
  if (tmp != 0) {
    return (1);
  } else {
    tmp___0 = GetOpenChannel(interp, (*(objv + 2)), 1, 1, & out);
    if (tmp___0 != 0) {
      return (1);
    }
  }
  if (objc == 3) {
    tocopy = -1;
  } else {
    tmp___1 = Tcl_GetString((*(objv + 3)));
    tmp___2 = Tcl_GetInt(interp, tmp___1, & tocopy);
    if (tmp___2 != 0) {
      return (1);
    }
    if (tocopy < 0) {
      tmp___3 = Tcl_GetString((*(objv + 3)));
      tmp___4 = Tcl_GetObjResult(interp);
      Tcl_AppendStringsToObj(tmp___4, "invalid length \"", tmp___3, "\": must be >= 0",
                             (void *)0);
      return (1);
    }
  }
  ntotal = 0;
  while (tocopy != 0) {
    toread = (int )sizeof(buf);
    if (tocopy > 0) {
      if (toread > tocopy) {
        toread = tocopy;
      }
    }
    nread = Tcl_Read(in, buf, toread);
    if (nread == 0) {
      break;
    } else {
      if (nread < 0) {
        tmp___5 = Tcl_PosixError(interp);
        tmp___6 = Tcl_GetObjResult(interp);
        Tcl_AppendStringsToObj(tmp___6, "read failed: ", tmp___5, (void *)0);
        return (1);
      }
    }
    if (tocopy > 0) {
      tocopy -= nread;
    }
    p = buf;
    while (nread > 0) {
      nwrote = Tcl_Write(out, p, nread);
      if (nwrote < 0) {
        tmp___7 = Tcl_PosixError(interp);
        tmp___8 = Tcl_GetObjResult(interp);
        Tcl_AppendStringsToObj(tmp___8, "write failed: ", tmp___7, (void *)0);
        return (1);
      }
      nread -= nwrote;
      ntotal += nwrote;
      p += nwrote;
    }
  }
  tmp___9 = Tcl_NewIntObj(ntotal);
  Tcl_SetObjResult(interp, tmp___9);
  return (0);
}
}
int NsTclCpObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int nread ;
  int towrite ;
  int nwrote ;
  char buf[4096] ;
  char *src ;
  char *dst ;
  char *p ;
  char *emsg ;
  char *efile ;
  int preserve ;
  int result ;
  int rfd ;
  int wfd ;
  struct stat st ;
  struct utimbuf ut ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___30 ;
  size_t tmp___31 ;
  char *tmp___32 ;
  char *tmp___53 ;
  int tmp___54 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  char *tmp___63 ;
  Tcl_Obj *tmp___64 ;

  {
  if (objc != 3) {
    if (objc != 4) {
      badargs: 
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-preserve? srcfile dstfile");
      return (1);
    }
  }
  emsg = (char *)"<unknown>";
  efile = (char *)"";
  rfd = -1;
  wfd = rfd;
  result = 1;
  if (objc == 3) {
    preserve = 0;
    src = Tcl_GetString((*(objv + 1)));
    dst = Tcl_GetString((*(objv + 2)));
  } else {
    tmp = Tcl_GetString((*(objv + 1)));
    if ((int )(*tmp) == (int )(*"-preserve")) {
      if (0) {
        tmp___56 = Tcl_GetString((*(objv + 1)));
        __s1_len = strlen((char const   *)tmp___56);
        __s2_len = strlen("-preserve");
        tmp___57 = Tcl_GetString((*(objv + 1)));
        tmp___58 = Tcl_GetString((*(objv + 1)));
        if ((unsigned int )((void const   *)(tmp___57 + 1)) - (unsigned int )((void const   *)tmp___58) ==
            1U) {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("-preserve" + 1)) - (unsigned int )((void const   *)"-preserve") ==
                   1U)) {
              tmp___59 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___59 = 1;
              } else {
                tmp___59 = 0;
              }
            }
          } else {
            tmp___59 = 0;
          }
        } else {
          goto _L___0;
        }
        if (tmp___59) {
          if (__s1_len < __s2_len) {
            tmp___31 = __s1_len;
          } else {
            tmp___31 = __s2_len;
          }
          tmp___32 = Tcl_GetString((*(objv + 1)));
          tmp___30 = memcmp((void const   *)((char const   *)tmp___32), (void const   *)"-preserve",
                            tmp___31 + 1U);
        } else {
          tmp___53 = Tcl_GetString((*(objv + 1)));
          tmp___54 = strcmp((char const   *)tmp___53, "-preserve");
          tmp___30 = tmp___54;
        }
      } else {
        tmp___53 = Tcl_GetString((*(objv + 1)));
        tmp___54 = strcmp((char const   *)tmp___53, "-preserve");
        tmp___30 = tmp___54;
      }
      if (! (tmp___30 == 0)) {
        goto badargs;
      }
    } else {
      goto badargs;
    }
    preserve = 1;
    src = Tcl_GetString((*(objv + 2)));
    dst = Tcl_GetString((*(objv + 3)));
    tmp___60 = stat__extinline((char const   *)src, & st);
    if (tmp___60 != 0) {
      emsg = (char *)"stat";
      efile = src;
      goto done;
    }
  }
  emsg = (char *)"open";
  rfd = open((char const   *)src, 0);
  if (rfd < 0) {
    efile = src;
    goto done;
  }
  wfd = open((char const   *)dst, 577, 420);
  if (wfd < 0) {
    efile = dst;
    goto done;
  }
  while (1) {
    nread = read(rfd, (void *)(buf), sizeof(buf));
    if (! (nread > 0)) {
      break;
    }
    p = buf;
    towrite = nread;
    while (towrite > 0) {
      nwrote = write(wfd, (void const   *)p, (unsigned int )towrite);
      if (nwrote <= 0) {
        emsg = (char *)"write";
        efile = dst;
        goto done;
      }
      towrite -= nwrote;
      p += nwrote;
    }
  }
  if (nread < 0) {
    emsg = (char *)"read";
    efile = src;
    goto done;
  }
  if (! preserve) {
    result = 0;
  } else {
    efile = dst;
    tmp___61 = chmod((char const   *)dst, st.st_mode);
    if (tmp___61 != 0) {
      emsg = (char *)"chmod";
      goto done;
    }
    ut.actime = st.st_atim.tv_sec;
    ut.modtime = st.st_mtim.tv_sec;
    tmp___62 = utime((char const   *)dst, (struct utimbuf  const  *)(& ut));
    if (tmp___62 != 0) {
      emsg = (char *)"utime";
      goto done;
    }
    result = 0;
  }
  done: 
  if (result != 0) {
    tmp___63 = Tcl_PosixError(interp);
    tmp___64 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___64, "could not ", emsg, " \"", efile, "\": ", tmp___63,
                           (void *)0);
  }
  if (rfd >= 0) {
    close(rfd);
  }
  if (wfd >= 0) {
    close(wfd);
  }
  return (result);
}
}
int NsTclMkdirObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ char *tmp ;
  char *tmp___0 ;
  Tcl_Obj *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"dir");
    return (1);
  }
  tmp___2 = Tcl_GetString((*(objv + 1)));
  tmp___3 = mkdir((char const   *)tmp___2, 493U);
  if (tmp___3 != 0) {
    tmp = Tcl_PosixError(interp);
    tmp___0 = Tcl_GetString((*(objv + 1)));
    tmp___1 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___1, "mkdir (\"", tmp___0, "\") failed:  ", tmp, (void *)0);
    return (1);
  }
  return (0);
}
}
int NsTclRmdirObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ char *tmp ;
  char *tmp___0 ;
  Tcl_Obj *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"dir");
    return (1);
  }
  tmp___2 = Tcl_GetString((*(objv + 1)));
  tmp___3 = rmdir((char const   *)tmp___2);
  if (tmp___3 != 0) {
    tmp = Tcl_PosixError(interp);
    tmp___0 = Tcl_GetString((*(objv + 1)));
    tmp___1 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___1, "rmdir (\"", tmp___0, "\") failed:  ", tmp, (void *)0);
    return (1);
  }
  return (0);
}
}
static int FileObjCmd(Tcl_Interp *interp , int objc , Tcl_Obj **objv , char *cmd ) 
{ int max ;
  int status ;
  int tmp ;
  char *tmp___0 ;
  Tcl_Obj *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  Tcl_Obj *tmp___6 ;

  {
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"file backupMax");
    return (1);
  }
  tmp = Tcl_GetIntFromObj(interp, (*(objv + 2)), & max);
  if (tmp != 0) {
    return (1);
  }
  if (max <= 0) {
    tmp___0 = Tcl_GetString((*(objv + 2)));
    tmp___1 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___1, "invalid max \"", tmp___0, "\": should be > 0 and <= 1000.",
                           (void *)0);
    return (1);
  } else {
    if (max > 1000) {
      tmp___0 = Tcl_GetString((*(objv + 2)));
      tmp___1 = Tcl_GetObjResult(interp);
      Tcl_AppendStringsToObj(tmp___1, "invalid max \"", tmp___0, "\": should be > 0 and <= 1000.",
                             (void *)0);
      return (1);
    }
  }
  if ((int )(*cmd) == 112) {
    tmp___2 = Tcl_GetString((*(objv + 1)));
    status = Ns_PurgeFiles(tmp___2, max);
  } else {
    tmp___3 = Tcl_GetString((*(objv + 1)));
    status = Ns_RollFile(tmp___3, max);
  }
  if (status != 0) {
    tmp___4 = Tcl_PosixError(interp);
    tmp___5 = Tcl_GetString((*(objv + 1)));
    tmp___6 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___6, "could not ", cmd, " \"", tmp___5, "\": ", tmp___4,
                           (void *)0);
    return (1);
  }
  return (0);
}
}
int NsTclRollFileObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = FileObjCmd(interp, objc, objv, (char *)"roll");
  return (tmp);
}
}
int NsTclPurgeFilesObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = FileObjCmd(interp, objc, objv, (char *)"purge");
  return (tmp);
}
}
int NsTclUnlinkObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int fComplain ;
  char *tmp ;
  Tcl_Obj *tmp___0 ;
  char *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___32 ;
  size_t tmp___33 ;
  char *tmp___34 ;
  char *tmp___55 ;
  int tmp___56 ;
  char *tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  int tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  Tcl_Obj *tmp___64 ;
  int *tmp___65 ;
  char *tmp___66 ;
  int tmp___67 ;

  {
  fComplain = 1;
  if (objc != 2) {
    if (objc != 3) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-nocomplain? filename");
      return (1);
    }
  }
  if (objc == 3) {
    tmp___1 = Tcl_GetString((*(objv + 1)));
    if ((int )(*tmp___1) == (int )(*"-nocomplain")) {
      if (0) {
        tmp___58 = Tcl_GetString((*(objv + 1)));
        __s1_len = strlen((char const   *)tmp___58);
        __s2_len = strlen("-nocomplain");
        tmp___59 = Tcl_GetString((*(objv + 1)));
        tmp___60 = Tcl_GetString((*(objv + 1)));
        if ((unsigned int )((void const   *)(tmp___59 + 1)) - (unsigned int )((void const   *)tmp___60) ==
            1U) {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("-nocomplain" + 1)) - (unsigned int )((void const   *)"-nocomplain") ==
                   1U)) {
              tmp___61 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___61 = 1;
              } else {
                tmp___61 = 0;
              }
            }
          } else {
            tmp___61 = 0;
          }
        } else {
          goto _L___0;
        }
        if (tmp___61) {
          if (__s1_len < __s2_len) {
            tmp___33 = __s1_len;
          } else {
            tmp___33 = __s2_len;
          }
          tmp___34 = Tcl_GetString((*(objv + 1)));
          tmp___32 = memcmp((void const   *)((char const   *)tmp___34), (void const   *)"-nocomplain",
                            tmp___33 + 1U);
        } else {
          tmp___55 = Tcl_GetString((*(objv + 1)));
          tmp___56 = strcmp((char const   *)tmp___55, "-nocomplain");
          tmp___32 = tmp___56;
        }
      } else {
        tmp___55 = Tcl_GetString((*(objv + 1)));
        tmp___56 = strcmp((char const   *)tmp___55, "-nocomplain");
        tmp___32 = tmp___56;
      }
      if (tmp___32 == 0) {
        fComplain = 0;
      } else {
        tmp = Tcl_GetString((*(objv + 1)));
        tmp___0 = Tcl_GetObjResult(interp);
        Tcl_AppendStringsToObj(tmp___0, "unknown flag \"", tmp, "\": should be -nocomplain",
                               (void *)0);
        return (1);
      }
    } else {
      tmp = Tcl_GetString((*(objv + 1)));
      tmp___0 = Tcl_GetObjResult(interp);
      Tcl_AppendStringsToObj(tmp___0, "unknown flag \"", tmp, "\": should be -nocomplain",
                             (void *)0);
      return (1);
    }
  }
  tmp___66 = Tcl_GetString((*(objv + (objc - 1))));
  tmp___67 = unlink((char const   *)tmp___66);
  if (tmp___67 != 0) {
    if (fComplain) {
      tmp___62 = Tcl_PosixError(interp);
      tmp___63 = Tcl_GetString((*(objv + (objc - 1))));
      tmp___64 = Tcl_GetObjResult(interp);
      Tcl_AppendStringsToObj(tmp___64, "unlink (\"", tmp___63, "\") failed:  ", tmp___62,
                             (void *)0);
      return (1);
    } else {
      tmp___65 = __errno_location();
      if ((*tmp___65) != 2) {
        tmp___62 = Tcl_PosixError(interp);
        tmp___63 = Tcl_GetString((*(objv + (objc - 1))));
        tmp___64 = Tcl_GetObjResult(interp);
        Tcl_AppendStringsToObj(tmp___64, "unlink (\"", tmp___63, "\") failed:  ",
                               tmp___62, (void *)0);
        return (1);
      }
    }
  }
  return (0);
}
}
int NsTclMkTempCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) 
{ char *buffer ;
  char *tmp ;

  {
  if (argc != 2) {
    Tcl_AppendResult(interp, "wrong # of args: should be \"", (*(argv + 0)), " template\"",
                     (void *)0);
    return (1);
  }
  buffer = ns_strdup((char const   *)(*(argv + 1)));
  tmp = mktemp(buffer);
  Tcl_SetResult(interp, tmp, (Tcl_FreeProc *)(& ns_free));
  return (0);
}
}
int NsTclTmpNamObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ char buf[20] ;
  char *tmp ;

  {
  tmp = tmpnam(buf);
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
    Tcl_SetResult(interp, (char *)"could not generate temporary filename.", (Tcl_FreeProc *)0);
    return (1);
  }
  Tcl_SetResult(interp, buf, (Tcl_FreeProc *)1);
  return (0);
}
}
int NsTclNormalizePathObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Tcl_DString ds ;
  char *tmp ;

  {
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"path");
    return (1);
  }
  Tcl_DStringInit(& ds);
  tmp = Tcl_GetString((*(objv + 1)));
  Ns_NormalizePath(& ds, tmp);
  Tcl_SetResult(interp, ds.string, (Tcl_FreeProc *)1);
  Tcl_DStringFree(& ds);
  return (0);
}
}
int NsTclUrl2FileObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  Tcl_DString ds ;
  char *tmp ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"url");
    return (1);
  }
  Tcl_DStringInit(& ds);
  tmp = Tcl_GetString((*(objv + 1)));
  NsUrlToFile(& ds, itPtr->servPtr, tmp);
  Tcl_SetResult(interp, ds.string, (Tcl_FreeProc *)1);
  Tcl_DStringFree(& ds);
  return (0);
}
}
int NsTclKillObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int pid ;
  int signal___0 ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  Tcl_Obj *tmp___4 ;
  int tmp___5 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___36 ;
  size_t tmp___37 ;
  char *tmp___38 ;
  char *tmp___59 ;
  int tmp___60 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;

  {
  if (objc != 3) {
    if (objc != 4) {
      badargs: 
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-nocomplain? pid signal");
      return (1);
    }
  }
  if (objc == 3) {
    tmp = Tcl_GetIntFromObj(interp, (*(objv + 1)), & pid);
    if (tmp != 0) {
      return (1);
    }
    tmp___0 = Tcl_GetIntFromObj(interp, (*(objv + 2)), & signal___0);
    if (tmp___0 != 0) {
      return (1);
    }
    tmp___5 = kill(pid, signal___0);
    if (tmp___5 != 0) {
      tmp___1 = Tcl_PosixError(interp);
      tmp___2 = Tcl_GetString((*(objv + 2)));
      tmp___3 = Tcl_GetString((*(objv + 1)));
      tmp___4 = Tcl_GetObjResult(interp);
      Tcl_AppendStringsToObj(tmp___4, "kill (\"", tmp___3, ",", tmp___2, "\") failed:  ",
                             tmp___1, (void *)0);
      return (1);
    }
  } else {
    if (0) {
      tmp___62 = Tcl_GetString((*(objv + 1)));
      __s1_len = strlen((char const   *)tmp___62);
      __s2_len = strlen("-nocomplain");
      tmp___63 = Tcl_GetString((*(objv + 1)));
      tmp___64 = Tcl_GetString((*(objv + 1)));
      if ((unsigned int )((void const   *)(tmp___63 + 1)) - (unsigned int )((void const   *)tmp___64) ==
          1U) {
        if (__s1_len >= 4U) {
          _L___0: 
          if (! ((unsigned int )((void const   *)("-nocomplain" + 1)) - (unsigned int )((void const   *)"-nocomplain") ==
                 1U)) {
            tmp___65 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___65 = 1;
            } else {
              tmp___65 = 0;
            }
          }
        } else {
          tmp___65 = 0;
        }
      } else {
        goto _L___0;
      }
      if (tmp___65) {
        if (__s1_len < __s2_len) {
          tmp___37 = __s1_len;
        } else {
          tmp___37 = __s2_len;
        }
        tmp___38 = Tcl_GetString((*(objv + 1)));
        tmp___36 = memcmp((void const   *)((char const   *)tmp___38), (void const   *)"-nocomplain",
                          tmp___37 + 1U);
      } else {
        tmp___59 = Tcl_GetString((*(objv + 1)));
        tmp___60 = strcmp((char const   *)tmp___59, "-nocomplain");
        tmp___36 = tmp___60;
      }
    } else {
      tmp___59 = Tcl_GetString((*(objv + 1)));
      tmp___60 = strcmp((char const   *)tmp___59, "-nocomplain");
      tmp___36 = tmp___60;
    }
    if (tmp___36 != 0) {
      goto badargs;
    }
    tmp___66 = Tcl_GetIntFromObj(interp, (*(objv + 2)), & pid);
    if (tmp___66 != 0) {
      return (1);
    }
    tmp___67 = Tcl_GetIntFromObj(interp, (*(objv + 3)), & signal___0);
    if (tmp___67 != 0) {
      return (1);
    }
    kill(pid, signal___0);
  }
  return (0);
}
}
int NsTclLinkObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  Tcl_Obj *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___36 ;
  size_t tmp___37 ;
  char *tmp___38 ;
  char *tmp___59 ;
  int tmp___60 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;

  {
  if (objc != 3) {
    if (objc != 4) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-nocomplain? filename1 filename2");
      return (1);
    }
  }
  if (objc == 3) {
    tmp___3 = Tcl_GetString((*(objv + 2)));
    tmp___4 = Tcl_GetString((*(objv + 1)));
    tmp___5 = link((char const   *)tmp___4, (char const   *)tmp___3);
    if (tmp___5 != 0) {
      tmp = Tcl_PosixError(interp);
      tmp___0 = Tcl_GetString((*(objv + 2)));
      tmp___1 = Tcl_GetString((*(objv + 1)));
      tmp___2 = Tcl_GetObjResult(interp);
      Tcl_AppendStringsToObj(tmp___2, "link (\"", tmp___1, "\", \"", tmp___0, "\") failed:  ",
                             tmp, (void *)0);
      return (1);
    }
  } else {
    if (0) {
      tmp___62 = Tcl_GetString((*(objv + 1)));
      __s1_len = strlen((char const   *)tmp___62);
      __s2_len = strlen("-nocomplain");
      tmp___63 = Tcl_GetString((*(objv + 1)));
      tmp___64 = Tcl_GetString((*(objv + 1)));
      if ((unsigned int )((void const   *)(tmp___63 + 1)) - (unsigned int )((void const   *)tmp___64) ==
          1U) {
        if (__s1_len >= 4U) {
          _L___0: 
          if (! ((unsigned int )((void const   *)("-nocomplain" + 1)) - (unsigned int )((void const   *)"-nocomplain") ==
                 1U)) {
            tmp___65 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___65 = 1;
            } else {
              tmp___65 = 0;
            }
          }
        } else {
          tmp___65 = 0;
        }
      } else {
        goto _L___0;
      }
      if (tmp___65) {
        if (__s1_len < __s2_len) {
          tmp___37 = __s1_len;
        } else {
          tmp___37 = __s2_len;
        }
        tmp___38 = Tcl_GetString((*(objv + 1)));
        tmp___36 = memcmp((void const   *)((char const   *)tmp___38), (void const   *)"-nocomplain",
                          tmp___37 + 1U);
      } else {
        tmp___59 = Tcl_GetString((*(objv + 1)));
        tmp___60 = strcmp((char const   *)tmp___59, "-nocomplain");
        tmp___36 = tmp___60;
      }
    } else {
      tmp___59 = Tcl_GetString((*(objv + 1)));
      tmp___60 = strcmp((char const   *)tmp___59, "-nocomplain");
      tmp___36 = tmp___60;
    }
    if (tmp___36 != 0) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-nocomplain? filename1 filename2");
      return (1);
    }
    tmp___66 = Tcl_GetString((*(objv + 3)));
    tmp___67 = Tcl_GetString((*(objv + 2)));
    link((char const   *)tmp___67, (char const   *)tmp___66);
  }
  return (0);
}
}
int NsTclSymlinkObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  Tcl_Obj *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___36 ;
  size_t tmp___37 ;
  char *tmp___38 ;
  char *tmp___59 ;
  int tmp___60 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;

  {
  if (objc != 3) {
    if (objc != 4) {
      badargs: 
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-nocomplain? filename1 filename2");
      return (1);
    }
  }
  if (objc == 3) {
    tmp___3 = Tcl_GetString((*(objv + 2)));
    tmp___4 = Tcl_GetString((*(objv + 1)));
    tmp___5 = symlink((char const   *)tmp___4, (char const   *)tmp___3);
    if (tmp___5 != 0) {
      tmp = Tcl_PosixError(interp);
      tmp___0 = Tcl_GetString((*(objv + 2)));
      tmp___1 = Tcl_GetString((*(objv + 1)));
      tmp___2 = Tcl_GetObjResult(interp);
      Tcl_AppendStringsToObj(tmp___2, "symlink (\"", tmp___1, "\", \"", tmp___0, "\") failed:  ",
                             tmp, (void *)0);
      return (1);
    }
  } else {
    if (0) {
      tmp___62 = Tcl_GetString((*(objv + 1)));
      __s1_len = strlen((char const   *)tmp___62);
      __s2_len = strlen("-nocomplain");
      tmp___63 = Tcl_GetString((*(objv + 1)));
      tmp___64 = Tcl_GetString((*(objv + 1)));
      if ((unsigned int )((void const   *)(tmp___63 + 1)) - (unsigned int )((void const   *)tmp___64) ==
          1U) {
        if (__s1_len >= 4U) {
          _L___0: 
          if (! ((unsigned int )((void const   *)("-nocomplain" + 1)) - (unsigned int )((void const   *)"-nocomplain") ==
                 1U)) {
            tmp___65 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___65 = 1;
            } else {
              tmp___65 = 0;
            }
          }
        } else {
          tmp___65 = 0;
        }
      } else {
        goto _L___0;
      }
      if (tmp___65) {
        if (__s1_len < __s2_len) {
          tmp___37 = __s1_len;
        } else {
          tmp___37 = __s2_len;
        }
        tmp___38 = Tcl_GetString((*(objv + 1)));
        tmp___36 = memcmp((void const   *)((char const   *)tmp___38), (void const   *)"-nocomplain",
                          tmp___37 + 1U);
      } else {
        tmp___59 = Tcl_GetString((*(objv + 1)));
        tmp___60 = strcmp((char const   *)tmp___59, "-nocomplain");
        tmp___36 = tmp___60;
      }
    } else {
      tmp___59 = Tcl_GetString((*(objv + 1)));
      tmp___60 = strcmp((char const   *)tmp___59, "-nocomplain");
      tmp___36 = tmp___60;
    }
    if (tmp___36 != 0) {
      goto badargs;
    }
    tmp___66 = Tcl_GetString((*(objv + 3)));
    tmp___67 = Tcl_GetString((*(objv + 2)));
    symlink((char const   *)tmp___67, (char const   *)tmp___66);
  }
  return (0);
}
}
int NsTclRenameObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  Tcl_Obj *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"filename1 filename2");
    return (1);
  }
  tmp___3 = Tcl_GetString((*(objv + 2)));
  tmp___4 = Tcl_GetString((*(objv + 1)));
  tmp___5 = rename((char const   *)tmp___4, (char const   *)tmp___3);
  if (tmp___5 != 0) {
    tmp = Tcl_PosixError(interp);
    tmp___0 = Tcl_GetString((*(objv + 2)));
    tmp___1 = Tcl_GetString((*(objv + 1)));
    tmp___2 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___2, "rename (\"", tmp___1, "\", \"", tmp___0, "\") failed:  ",
                           tmp, (void *)0);
    return (1);
  }
  return (0);
}
}
int NsTclWriteFpObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  Tcl_Channel chan ;
  int nbytes ;
  int result ;
  int tmp ;
  int tmp___0 ;

  {
  itPtr = (NsInterp *)arg;
  nbytes = 2147483647;
  if (objc != 2) {
    if (objc != 3) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"fileid ?nbytes?");
      return (1);
    }
  }
  tmp = GetOpenChannel(interp, (*(objv + 1)), 0, 1, & chan);
  if (tmp != 0) {
    return (1);
  }
  if (objc == 3) {
    tmp___0 = Tcl_GetIntFromObj(interp, (*(objv + 2)), & nbytes);
    if (tmp___0 != 0) {
      return (1);
    }
  }
  if ((unsigned int )itPtr->conn == (unsigned int )((void *)0)) {
    Tcl_SetResult(interp, (char *)"no connection", (Tcl_FreeProc *)0);
    return (1);
  }
  result = Ns_ConnSendChannel(itPtr->conn, chan, nbytes);
  if (result != 0) {
    Tcl_SetResult(interp, (char *)"i/o failed", (Tcl_FreeProc *)0);
    return (1);
  }
  return (0);
}
}
int NsTclTruncateObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int length ;
  int tmp ;
  char *tmp___0 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  Tcl_Obj *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  if (objc != 2) {
    if (objc != 3) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"file ?length?");
      return (1);
    }
  }
  if (objc == 2) {
    length = 0;
  } else {
    tmp = Tcl_GetIntFromObj(interp, (*(objv + 2)), & length);
    if (tmp != 0) {
      return (1);
    }
  }
  tmp___7 = Tcl_GetString((*(objv + 1)));
  tmp___8 = truncate((char const   *)tmp___7, (long )length);
  if (tmp___8 != 0) {
    tmp___0 = Tcl_PosixError(interp);
    tmp___4 = Tcl_GetString((*(objv + 2)));
    if (tmp___4) {
      tmp___3 = (char const   *)Tcl_GetString((*(objv + 2)));
    } else {
      tmp___3 = "0";
    }
    tmp___5 = Tcl_GetString((*(objv + 1)));
    tmp___6 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___6, "truncate (\"", tmp___5, "\", ", tmp___3, ") failed:  ",
                           tmp___0, (void *)0);
    return (1);
  }
  return (0);
}
}
int NsTclFTruncateObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int length ;
  int fd ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  Tcl_Obj *tmp___9 ;
  int tmp___10 ;

  {
  if (objc != 2) {
    if (objc != 3) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"fileId ?length?");
      return (1);
    }
  }
  tmp = Tcl_GetString((*(objv + 1)));
  tmp___0 = Ns_TclGetOpenFd(interp, tmp, 1, & fd);
  if (tmp___0 != 0) {
    return (1);
  }
  if (objc == 2) {
    length = 0;
  } else {
    tmp___1 = Tcl_GetString((*(objv + 2)));
    tmp___2 = Tcl_GetInt(interp, tmp___1, & length);
    if (tmp___2 != 0) {
      return (1);
    }
  }
  tmp___10 = ftruncate(fd, (long )length);
  if (tmp___10 != 0) {
    tmp___3 = Tcl_PosixError(interp);
    tmp___7 = Tcl_GetString((*(objv + 2)));
    if (tmp___7) {
      tmp___6 = (char const   *)Tcl_GetString((*(objv + 2)));
    } else {
      tmp___6 = "0";
    }
    tmp___8 = Tcl_GetString((*(objv + 1)));
    tmp___9 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___9, "ftruncate (\"", tmp___8, "\", ", tmp___6, ") failed:  ",
                           tmp___3, (void *)0);
    return (1);
  }
  return (0);
}
}
int NsTclChmodObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int mode ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  Tcl_Obj *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"filename mode");
    return (1);
  }
  tmp = Tcl_GetIntFromObj(interp, (*(objv + 2)), & mode);
  if (tmp != 0) {
    return (1);
  }
  tmp___4 = Tcl_GetString((*(objv + 1)));
  tmp___5 = chmod((char const   *)tmp___4, (unsigned int )mode);
  if (tmp___5 != 0) {
    tmp___0 = Tcl_PosixError(interp);
    tmp___1 = Tcl_GetString((*(objv + 2)));
    tmp___2 = Tcl_GetString((*(objv + 1)));
    tmp___3 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___3, "chmod (\"", tmp___2, "\", ", tmp___1, ") failed:  ",
                           tmp___0, (void *)0);
    return (1);
  }
  return (0);
}
}
static char *opts___3[6]  = {      (char *)"cleanup",      (char *)"list",      (char *)"create",      (char *)"put", 
        (char *)"get",      (char *)((void *)0)};
int NsTclChanObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  NsServer *servPtr ;
  Tcl_Channel chan ;
  char *name ;
  int new ;
  int shared ;
  Tcl_HashTable *tabPtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  enum __anonenum_opt_107___1 opt ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  Tcl_Obj *tmp___4 ;
  Tcl_Obj *tmp___5 ;
  char *tmp___6 ;
  Tcl_Obj *tmp___7 ;
  char *tmp___8 ;

  {
  itPtr = (NsInterp *)arg;
  servPtr = itPtr->servPtr;
  chan = (struct Tcl_Channel_ *)((void *)0);
  if (objc < 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"command ?args?");
    return (1);
  }
  tmp = Tcl_GetIndexFromObj(interp, (*(objv + 1)), opts___3, (char *)"option", 0,
                            (int *)(& opt));
  if (tmp != 0) {
    return (1);
  }
  switch ((int )opt) {
  case 2: ;
  if (objc != 4) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"create channel name");
    return (1);
  }
  tmp___0 = Tcl_GetString((*(objv + 2)));
  chan = Tcl_GetChannel(interp, tmp___0, (int *)((void *)0));
  if ((unsigned int )chan == (unsigned int )((struct Tcl_Channel_ *)((void *)0))) {
    return (1);
  }
  tmp___1 = Tcl_IsChannelRegistered(interp, chan);
  if (! tmp___1) {
    Tcl_SetResult(interp, (char *)"channel is not registered", (Tcl_FreeProc *)0);
    return (1);
  }
  tmp___2 = Tcl_IsChannelShared(chan);
  if (tmp___2) {
    Tcl_SetResult(interp, (char *)"channel is shared", (Tcl_FreeProc *)0);
    return (1);
  }
  name = Tcl_GetString((*(objv + 3)));
  Ns_MutexLock(& servPtr->chans.lock);
  hPtr = ((*(servPtr->chans.table.createProc)))(& servPtr->chans.table, name, & new);
  if (new) {
    hPtr->clientData = (void *)chan;
  }
  Ns_MutexUnlock(& servPtr->chans.lock);
  if (! new) {
    tmp___3 = Tcl_GetString((*(objv + 3)));
    tmp___4 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___4, "channel with name \"", tmp___3, "\" already exists",
                           (void *)0);
    return (1);
  }
  UnspliceChannel(interp, chan);
  break;
  case 4: ;
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"get name");
    return (1);
  }
  name = Tcl_GetString((*(objv + 2)));
  Ns_MutexLock(& servPtr->chans.lock);
  hPtr = ((*(servPtr->chans.table.findProc)))(& servPtr->chans.table, name);
  if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    chan = (struct Tcl_Channel_ *)hPtr->clientData;
    Tcl_DeleteHashEntry(hPtr);
  }
  Ns_MutexUnlock(& servPtr->chans.lock);
  if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
    tmp___5 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___5, "no such shared channel: ", name, (void *)0);
    return (1);
  }
  SpliceChannel(interp, chan);
  tmp___6 = Tcl_GetChannelName(chan);
  Tcl_SetResult(interp, tmp___6, (Tcl_FreeProc *)1);
  hPtr = ((*(itPtr->chans.createProc)))(& itPtr->chans, name, & new);
  hPtr->clientData = (void *)chan;
  break;
  case 3: ;
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"put name");
    return (1);
  }
  name = Tcl_GetString((*(objv + 2)));
  hPtr = ((*(itPtr->chans.findProc)))(& itPtr->chans, name);
  if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
    tmp___7 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___7, "no such shared channel: ", name, (void *)0);
    return (1);
  }
  chan = (struct Tcl_Channel_ *)hPtr->clientData;
  UnspliceChannel(interp, chan);
  Tcl_DeleteHashEntry(hPtr);
  Ns_MutexLock(& servPtr->chans.lock);
  hPtr = ((*(servPtr->chans.table.createProc)))(& servPtr->chans.table, name, & new);
  hPtr->clientData = (void *)chan;
  Ns_MutexUnlock(& servPtr->chans.lock);
  break;
  case 1: ;
  if (objc != 2) {
    if (objc != 3) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"list ?-shared?");
      return (1);
    }
  }
  shared = objc == 3;
  if (shared) {
    Ns_MutexLock(& servPtr->chans.lock);
    tabPtr = & servPtr->chans.table;
  } else {
    tabPtr = & itPtr->chans;
  }
  hPtr = Tcl_FirstHashEntry(tabPtr, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    if (tabPtr->keyType == 1) {
      tmp___8 = hPtr->key.oneWordValue;
    } else {
      if (tabPtr->keyType == -1) {
        tmp___8 = hPtr->key.oneWordValue;
      } else {
        tmp___8 = hPtr->key.string;
      }
    }
    Tcl_AppendElement(interp, tmp___8);
    hPtr = Tcl_NextHashEntry(& search);
  }
  if (shared) {
    Ns_MutexUnlock(& servPtr->chans.lock);
  }
  break;
  case 0: ;
  if (objc != 2) {
    if (objc != 3) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"cleanup ?-shared?");
      return (1);
    }
  }
  shared = objc == 3;
  if (shared) {
    Ns_MutexLock(& servPtr->chans.lock);
    tabPtr = & servPtr->chans.table;
  } else {
    tabPtr = & itPtr->chans;
  }
  hPtr = Tcl_FirstHashEntry(tabPtr, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    chan = (struct Tcl_Channel_ *)hPtr->clientData;
    if (shared) {
      Tcl_Close((Tcl_Interp *)((void *)0), chan);
    }
    Tcl_DeleteHashEntry(hPtr);
    hPtr = Tcl_NextHashEntry(& search);
  }
  if (objc == 3) {
    Ns_MutexUnlock(& servPtr->chans.lock);
  }
  break;
  }
  return (0);
}
}
static void SpliceChannel(Tcl_Interp *interp , Tcl_Channel chan ) 
{ 

  {
  Tcl_SpliceChannel(chan);
  Tcl_RegisterChannel(interp, chan);
  Tcl_UnregisterChannel((Tcl_Interp *)((void *)0), chan);
  return;
}
}
static void UnspliceChannel(Tcl_Interp *interp , Tcl_Channel chan ) 
{ 

  {
  Tcl_ClearChannelHandlers(chan);
  Tcl_RegisterChannel((Tcl_Interp *)((void *)0), chan);
  Tcl_UnregisterChannel(interp, chan);
  Tcl_CutChannel(chan);
  return;
}
}
extern int snprintf(char * __restrict  __s , size_t __maxlen , char const   * __restrict  __format 
                    , ...) ;
int Ns_TclGetTimeFromObj(Tcl_Interp *interp , Tcl_Obj *objPtr , Ns_Time *timePtr ) ;
int Ns_TclGetSet2(Tcl_Interp *interp , char *id , Ns_Set **setPtr ) ;
static int HttpSend(int sock , void *arg , int why ) ;
static int HttpRecv(int sock , void *arg , int why ) ;
static int HttpCancel(int sock , void *arg , int why ) ;
static int HttpDone(int sock , Http *httpPtr , int state ) ;
static Http *HttpOpen(char *method , char *url , Ns_Set *hdrs , char *body ) ;
static void HttpClose(Http *httpPtr , int nb ) ;
static int HttpAbort(Http *httpPtr ) ;
static char *HttpResult(char *response , Ns_Set *hdrs ) ;
static Ns_Mutex lock___12  ;
static Ns_Cond cond___3  ;
static char *opts___4[5]  = {      (char *)"cancel",      (char *)"cleanup",      (char *)"queue",      (char *)"wait", 
        (char *)((void *)0)};
int NsTclHttpObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  Http *httpPtr ;
  char buf[50] ;
  char *result ;
  char *carg ;
  int new ;
  int status ;
  int n ;
  int timeidx ;
  Ns_Time timeout ;
  Ns_Time incr ;
  Ns_Set *hdrs ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  enum __anonenum_opt_108___0 opt ;
  char *method ;
  char *url ;
  char *body ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  Tcl_Obj *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  Tcl_Obj *tmp___6 ;
  int tmp___7 ;
  Tcl_Obj *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  Tcl_Obj *tmp___15 ;
  Ns_Time dtime ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  Tcl_Obj *tmp___20 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc < 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"option ?args ...?");
    return (1);
  }
  tmp = Tcl_GetIndexFromObj(interp, (*(objv + 1)), opts___4, (char *)"option", 0,
                            (int *)(& opt));
  if (tmp != 0) {
    return (1);
  }
  switch ((int )opt) {
  case 2: ;
  if (objc < 4) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"method url ?body? ?headers?");
    return (1);
  } else {
    if (objc > 6) {
      Tcl_WrongNumArgs(interp, 2, objv, (char *)"method url ?body? ?headers?");
      return (1);
    }
  }
  method = Tcl_GetString((*(objv + 2)));
  url = Tcl_GetString((*(objv + 3)));
  if (objc > 4) {
    body = Tcl_GetString((*(objv + 4)));
    if (objc > 5) {
      tmp___0 = Tcl_GetString((*(objv + 5)));
      tmp___1 = Ns_TclGetSet2(interp, tmp___0, & hdrs);
      if (tmp___1 != 0) {
        return (1);
      }
    } else {
      hdrs = (Ns_Set *)((void *)0);
    }
  } else {
    body = (char *)((void *)0);
    hdrs = (Ns_Set *)((void *)0);
  }
  httpPtr = HttpOpen(method, url, hdrs, body);
  if ((unsigned int )httpPtr == (unsigned int )((void *)0)) {
    tmp___2 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___2, "could not connect to : ", url, (void *)0);
    return (1);
  }
  Ns_GetTime(& httpPtr->stime);
  Ns_SockCallback(httpPtr->sock, & HttpSend, (void *)httpPtr, 2);
  n = itPtr->https.numEntries;
  while (1) {
    tmp___3 = n;
    n ++;
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"http%d", tmp___3);
    hPtr = ((*(itPtr->https.createProc)))(& itPtr->https, buf, & new);
    if (! (! new)) {
      break;
    }
  }
  hPtr->clientData = (void *)httpPtr;
  Tcl_SetResult(interp, buf, (Tcl_FreeProc *)1);
  break;
  case 0: ;
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"id");
    return (1);
  }
  tmp___4 = Tcl_GetString((*(objv + 2)));
  hPtr = ((*(itPtr->https.findProc)))(& itPtr->https, tmp___4);
  if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
    tmp___5 = Tcl_GetString((*(objv + 2)));
    tmp___6 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___6, "no such request: ", tmp___5, (void *)0);
    return (1);
  }
  httpPtr = (Http *)hPtr->clientData;
  Tcl_DeleteHashEntry(hPtr);
  tmp___7 = HttpAbort(httpPtr);
  tmp___8 = Tcl_GetObjResult(interp);
  Tcl_SetIntObj(tmp___8, tmp___7);
  break;
  case 3: ;
  if (objc < 4) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"id resultsVar ?timeout? ?headers? ?-servicetime svcTime?");
    return (1);
  } else {
    if (objc > 8) {
      Tcl_WrongNumArgs(interp, 2, objv, (char *)"id resultsVar ?timeout? ?headers? ?-servicetime svcTime?");
      return (1);
    }
  }
  carg = Tcl_GetString((*(objv + (objc - 2))));
  tmp___9 = strcasecmp((char const   *)carg, "-servicetime");
  if (tmp___9 == 0) {
    timeidx = objc - 1;
    objc -= 2;
  } else {
    timeidx = 0;
  }
  if (objc < 5) {
    incr.sec = 2L;
    incr.usec = 0L;
  } else {
    tmp___10 = Ns_TclGetTimeFromObj(interp, (*(objv + 4)), & incr);
    if (tmp___10 != 0) {
      return (1);
    }
  }
  Ns_GetTime(& timeout);
  Ns_IncrTime(& timeout, incr.sec, incr.usec);
  if (objc < 6) {
    hdrs = (Ns_Set *)((void *)0);
  } else {
    tmp___11 = Tcl_GetString((*(objv + 5)));
    tmp___12 = Ns_TclGetSet2(interp, tmp___11, & hdrs);
    if (tmp___12 != 0) {
      return (1);
    }
  }
  tmp___13 = Tcl_GetString((*(objv + 2)));
  hPtr = ((*(itPtr->https.findProc)))(& itPtr->https, tmp___13);
  if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
    tmp___14 = Tcl_GetString((*(objv + 2)));
    tmp___15 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___15, "no such request: ", tmp___14, (void *)0);
    return (1);
  }
  httpPtr = (Http *)hPtr->clientData;
  status = 0;
  Ns_MutexLock(& lock___12);
  while (1) {
    if (status == 0) {
      if (! (! (httpPtr->state & 4))) {
        break;
      }
    } else {
      break;
    }
    status = Ns_CondTimedWait(& cond___3, & lock___12, & timeout);
  }
  Ns_MutexUnlock(& lock___12);
  if (timeidx > 0) {
    if (status != 0) {
      Ns_GetTime(& httpPtr->etime);
    }
    Ns_DiffTime(& httpPtr->etime, & httpPtr->stime, & dtime);
    snprintf((char * __restrict  )(buf), 50U, (char const   * __restrict  )"%ld:%ld",
             dtime.sec, dtime.usec);
    tmp___16 = Tcl_GetString((*(objv + timeidx)));
    Tcl_SetVar(interp, tmp___16, buf, 512);
  }
  if (status != 0) {
    httpPtr = (Http *)((void *)0);
    result = (char *)"timeout";
  } else {
    if (httpPtr->state & 16) {
      result = HttpResult(httpPtr->ds.string, hdrs);
    } else {
      status = -1;
      result = (char *)"error";
    }
  }
  tmp___17 = Tcl_GetString((*(objv + 3)));
  tmp___18 = Tcl_SetVar(interp, tmp___17, result, 512);
  result = tmp___18;
  if ((unsigned int )httpPtr != (unsigned int )((void *)0)) {
    Tcl_DeleteHashEntry(hPtr);
    HttpClose(httpPtr, 0);
  }
  if ((unsigned int )result == (unsigned int )((void *)0)) {
    return (1);
  }
  if (status == 0) {
    tmp___19 = 1;
  } else {
    tmp___19 = 0;
  }
  tmp___20 = Tcl_GetObjResult(interp);
  Tcl_SetBooleanObj(tmp___20, tmp___19);
  break;
  case 1: 
  hPtr = Tcl_FirstHashEntry(& itPtr->https, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    httpPtr = (Http *)hPtr->clientData;
    HttpAbort(httpPtr);
    hPtr = Tcl_NextHashEntry(& search);
  }
  Tcl_DeleteHashTable(& itPtr->https);
  Tcl_InitHashTable(& itPtr->https, 0);
  break;
  }
  return (0);
}
}
static Http *HttpOpen(char *method , char *url , Ns_Set *hdrs , char *body ) 
{ Http *httpPtr ;
  int sock ;
  char *host ;
  char *file___1 ;
  char *port ;
  int i ;
  int body_len ;
  char lenbuf[20] ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___22 ;
  char *tmp___24 ;
  char const   *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;

  {
  httpPtr = (Http *)((void *)0);
  body_len = 0;
  if (0) {
    if (0) {
      __s1_len___0 = strlen((char const   *)url);
      __s2_len___0 = strlen("http://");
      if (! ((unsigned int )((void const   *)(url + 1)) - (unsigned int )((void const   *)url) ==
             1U)) {
        goto _L___2;
      } else {
        if (__s1_len___0 >= 4U) {
          _L___2: 
          if (! ((unsigned int )((void const   *)("http://" + 1)) - (unsigned int )((void const   *)"http://") ==
                 1U)) {
            tmp___18 = 1;
          } else {
            if (__s2_len___0 >= 4U) {
              tmp___18 = 1;
            } else {
              tmp___18 = 0;
            }
          }
        } else {
          tmp___18 = 0;
        }
      }
      if (tmp___18) {
        if (__s1_len___0 < __s2_len___0) {
          tmp___16 = __s1_len___0;
        } else {
          tmp___16 = __s2_len___0;
        }
        tmp___15 = memcmp((void const   *)((char const   *)url), (void const   *)"http://",
                          tmp___16 + 1U);
      } else {
        tmp___17 = strcmp((char const   *)url, "http://");
        tmp___15 = tmp___17;
      }
    } else {
      tmp___17 = strcmp((char const   *)url, "http://");
      tmp___15 = tmp___17;
    }
    tmp___10 = tmp___15;
  } else {
    tmp___10 = strncmp((char const   *)url, "http://", 7U);
  }
  if (tmp___10 != 0) {
    return ((Http *)((void *)0));
  } else {
    if ((int )(*(url + 7)) == 0) {
      return ((Http *)((void *)0));
    }
  }
  host = url + 7;
  tmp___22 = strchr((char const   *)host, '/');
  file___1 = tmp___22;
  if ((unsigned int )file___1 != (unsigned int )((void *)0)) {
    (*file___1) = (char )'\000';
  }
  tmp___24 = strchr((char const   *)host, ':');
  port = tmp___24;
  if ((unsigned int )port == (unsigned int )((void *)0)) {
    i = 80;
  } else {
    (*port) = (char )'\000';
    i = atoi__extinline((char const   *)(port + 1));
  }
  sock = Ns_SockAsyncConnect(host, i);
  if ((unsigned int )port != (unsigned int )((void *)0)) {
    (*port) = (char )':';
  }
  if (sock != -1) {
    httpPtr = (Http *)ns_malloc(sizeof(Http ));
    httpPtr->state = 1;
    httpPtr->sock = sock;
    Tcl_DStringInit(& httpPtr->ds);
    if ((unsigned int )file___1 != (unsigned int )((void *)0)) {
      (*file___1) = (char )'/';
    }
    Tcl_DStringAppend(& httpPtr->ds, method, -1);
    Ns_StrToUpper(httpPtr->ds.string);
    if (file___1) {
      tmp___25 = (char const   *)file___1;
    } else {
      tmp___25 = "/";
    }
    Ns_DStringVarAppend(& httpPtr->ds, " ", tmp___25, " HTTP/1.0\r\n", (void *)0);
    if ((unsigned int )file___1 != (unsigned int )((void *)0)) {
      (*file___1) = (char )'\000';
    }
    tmp___26 = Ns_InfoServerVersion();
    tmp___27 = Ns_InfoServerName();
    Ns_DStringVarAppend(& httpPtr->ds, "User-Agent: ", tmp___27, "/", tmp___26, "\r\nConnection: close\r\nHost: ",
                        host, "\r\n", (void *)0);
    if ((unsigned int )file___1 != (unsigned int )((void *)0)) {
      (*file___1) = (char )'/';
    }
    if ((unsigned int )hdrs != (unsigned int )((void *)0)) {
      i = 0;
      while (i < hdrs->size) {
        Ns_DStringVarAppend(& httpPtr->ds, (hdrs->fields + i)->name, ": ", (hdrs->fields +
                                                                            i)->value,
                            "\r\n", (void *)0);
        i ++;
      }
    }
    if ((unsigned int )body != (unsigned int )((void *)0)) {
      body_len = (int )strlen((char const   *)body);
      if (body_len > 0) {
        sprintf((char * __restrict  )(lenbuf), (char const   * __restrict  )"%d",
                body_len);
        Ns_DStringVarAppend(& httpPtr->ds, "Content-Length: ", lenbuf, "\r\n", (void *)0);
      }
    }
    Tcl_DStringAppend(& httpPtr->ds, (char *)"\r\n", 2);
    if (body_len > 0) {
      Tcl_DStringAppend(& httpPtr->ds, body, body_len);
    }
    httpPtr->next = httpPtr->ds.string;
    httpPtr->len = (unsigned int )httpPtr->ds.length;
  }
  if ((unsigned int )file___1 != (unsigned int )((void *)0)) {
    (*file___1) = (char )'/';
  }
  return (httpPtr);
}
}
static char *HttpResult(char *response , Ns_Set *hdrs ) 
{ int firsthdr ;
  int len ;
  char *eoh ;
  char *body ;
  char *p ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___2 ;

  {
  body = response;
  eoh = strstr((char const   *)response, "\r\n\r\n");
  if ((unsigned int )eoh != (unsigned int )((void *)0)) {
    body = eoh + 4;
  } else {
    eoh = strstr((char const   *)response, "\n\n");
    if ((unsigned int )eoh != (unsigned int )((void *)0)) {
      body = eoh + 2;
    }
  }
  if ((unsigned int )eoh != (unsigned int )((void *)0)) {
    (*eoh) = (char )'\000';
  }
  if ((unsigned int )hdrs != (unsigned int )((void *)0)) {
    firsthdr = 1;
    p = response;
    while (1) {
      tmp___2 = strchr((char const   *)p, '\n');
      eoh = tmp___2;
      if (! ((unsigned int )eoh != (unsigned int )((void *)0))) {
        break;
      }
      tmp = eoh;
      eoh ++;
      (*tmp) = (char )'\000';
      len = (int )strlen((char const   *)p);
      if (len > 0) {
        if ((int )(*(p + (len - 1))) == 13) {
          (*(p + (len - 1))) = (char )'\000';
        }
      }
      if (firsthdr) {
        if ((unsigned int )hdrs->name != (unsigned int )((void *)0)) {
          ns_free((void *)hdrs->name);
        }
        hdrs->name = ns_strdup((char const   *)p);
        firsthdr = 0;
      } else {
        tmp___0 = Ns_ParseHeader(hdrs, p, (enum __anonenum_Ns_HeaderCaseDisposition_68 )1);
        if (tmp___0 != 0) {
          break;
        }
      }
      p = eoh;
    }
  }
  return (body);
}
}
static void HttpClose(Http *httpPtr , int nb ) 
{ 

  {
  Tcl_DStringFree(& httpPtr->ds);
  if (nb) {
    close(httpPtr->sock);
  } else {
    close(httpPtr->sock);
  }
  ns_free((void *)httpPtr);
  return;
}
}
static int HttpSend(int sock , void *arg , int why ) 
{ Http *httpPtr ;
  int n ;
  int tmp ;

  {
  httpPtr = (Http *)arg;
  n = send(sock, (void const   *)httpPtr->next, httpPtr->len, 0);
  if (n < 0) {
    Tcl_DStringFree(& httpPtr->ds);
    tmp = HttpDone(sock, httpPtr, 36);
    return (tmp);
  }
  httpPtr->next += n;
  httpPtr->len -= (unsigned int )n;
  if (httpPtr->len == 0U) {
    shutdown(sock, 1);
    Tcl_DStringSetLength(& httpPtr->ds, 0);
    Ns_MutexLock(& lock___12);
    httpPtr->state = 2;
    Ns_MutexUnlock(& lock___12);
    Ns_SockCallback(sock, & HttpRecv, arg, 1);
  }
  return (1);
}
}
static int HttpRecv(int sock , void *arg , int why ) 
{ Http *httpPtr ;
  char buf[1024] ;
  int n ;
  int state ;
  int tmp ;

  {
  httpPtr = (Http *)arg;
  n = recv(sock, (void *)(buf), sizeof(buf), 0);
  if (n > 0) {
    Tcl_DStringAppend(& httpPtr->ds, buf, n);
    return (1);
  }
  state = 4;
  if (n < 0) {
    state |= 32;
  } else {
    state |= 16;
  }
  Ns_GetTime(& httpPtr->etime);
  tmp = HttpDone(sock, httpPtr, state);
  return (tmp);
}
}
static int HttpCancel(int sock , void *arg , int why ) 
{ Http *httpPtr ;
  int tmp ;

  {
  httpPtr = (Http *)arg;
  tmp = HttpDone(sock, httpPtr, 12);
  return (tmp);
}
}
static int HttpDone(int sock , Http *httpPtr , int state ) 
{ 

  {
  Ns_MutexLock(& lock___12);
  httpPtr->state = state;
  Ns_MutexUnlock(& lock___12);
  Ns_CondBroadcast(& cond___3);
  return (0);
}
}
static int HttpAbort(Http *httpPtr ) 
{ int state ;

  {
  Ns_MutexLock(& lock___12);
  state = httpPtr->state;
  if (! (state & 4)) {
    Ns_SockCancelCallbackEx(httpPtr->sock, & HttpCancel, (void *)httpPtr);
    while (! (httpPtr->state & 4)) {
      Ns_CondWait(& cond___3, & lock___12);
    }
  }
  Ns_MutexUnlock(& lock___12);
  HttpClose(httpPtr, 1);
  return (state);
}
}
extern int Tcl_ListObjAppendElement(Tcl_Interp *interp , Tcl_Obj *listPtr , Tcl_Obj *objPtr ) ;
extern Tcl_Channel Tcl_OpenFileChannel(Tcl_Interp *interp , char *fileName , char *modeString ,
                                       int permissions ) ;
extern int Tcl_SetChannelOption(Tcl_Interp *interp , Tcl_Channel chan , char *optionName ,
                                char *newValue ) ;
extern Tcl_WideInt Tcl_Seek(Tcl_Channel chan , Tcl_WideInt offset , int mode ) ;
static int ChanGetc(Tcl_Channel chan ) ;
static int JpegNextMarker(Tcl_Channel chan ) ;
static int JpegSize(Tcl_Channel chan , int *wPtr , int *hPtr ) ;
static int JpegRead2Bytes(Tcl_Channel chan ) ;
static int AppendObjDims(Tcl_Interp *interp , int w , int h ) ;
int NsTclGifSizeObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int fd ;
  unsigned char buf[768] ;
  int depth ;
  int colormap ;
  int dx ;
  int dy ;
  int status ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  Tcl_Obj *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  Tcl_Obj *tmp___5 ;
  ssize_t tmp___6 ;
  char *tmp___7 ;
  Tcl_Obj *tmp___8 ;
  int tmp___20 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___42 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___47 ;
  size_t tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  ssize_t tmp___53 ;
  ssize_t tmp___54 ;
  ssize_t tmp___55 ;
  unsigned char count ;
  ssize_t tmp___56 ;
  ssize_t tmp___57 ;
  ssize_t tmp___58 ;
  ssize_t tmp___59 ;
  int tmp___60 ;

  {
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"gif");
    return (1);
  }
  tmp = Tcl_GetString((*(objv + 1)));
  fd = open((char const   *)tmp, 0);
  if (fd == -1) {
    tmp___0 = Tcl_PosixError(interp);
    tmp___1 = Tcl_GetString((*(objv + 1)));
    tmp___2 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___2, "could not open \"", tmp___1, "\": ", tmp___0,
                           (void *)0);
    return (1);
  }
  status = 1;
  tmp___6 = read(fd, (void *)(buf), 6U);
  if (tmp___6 != 6) {
    readfail: 
    tmp___3 = Tcl_PosixError(interp);
    tmp___4 = Tcl_GetString((*(objv + 1)));
    tmp___5 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___5, "could not read \"", tmp___4, "\": ", tmp___3,
                           (void *)0);
    goto done;
  }
  if (0) {
    if (0) {
      __s1_len___0 = strlen((char const   *)((char *)(buf)));
      __s2_len___0 = strlen("GIF87a");
      if (! ((unsigned int )((void const   *)((char *)(buf) + 1)) - (unsigned int )((void const   *)((char *)(buf))) ==
             1U)) {
        goto _L___2;
      } else {
        if (__s1_len___0 >= 4U) {
          _L___2: 
          if (! ((unsigned int )((void const   *)("GIF87a" + 1)) - (unsigned int )((void const   *)"GIF87a") ==
                 1U)) {
            tmp___28 = 1;
          } else {
            if (__s2_len___0 >= 4U) {
              tmp___28 = 1;
            } else {
              tmp___28 = 0;
            }
          }
        } else {
          tmp___28 = 0;
        }
      }
      if (tmp___28) {
        if (__s1_len___0 < __s2_len___0) {
          tmp___26 = __s1_len___0;
        } else {
          tmp___26 = __s2_len___0;
        }
        tmp___25 = memcmp((void const   *)((char const   *)((char *)(buf))), (void const   *)"GIF87a",
                          tmp___26 + 1U);
      } else {
        tmp___27 = strcmp((char const   *)((char *)(buf)), "GIF87a");
        tmp___25 = tmp___27;
      }
    } else {
      tmp___27 = strcmp((char const   *)((char *)(buf)), "GIF87a");
      tmp___25 = tmp___27;
    }
    tmp___20 = tmp___25;
  } else {
    tmp___20 = strncmp((char const   *)((char *)(buf)), "GIF87a", 6U);
  }
  if (tmp___20) {
    if (0) {
      if (0) {
        __s1_len___2 = strlen((char const   *)((char *)(buf)));
        __s2_len___2 = strlen("GIF89a");
        if (! ((unsigned int )((void const   *)((char *)(buf) + 1)) - (unsigned int )((void const   *)((char *)(buf))) ==
               1U)) {
          goto _L___6;
        } else {
          if (__s1_len___2 >= 4U) {
            _L___6: 
            if (! ((unsigned int )((void const   *)("GIF89a" + 1)) - (unsigned int )((void const   *)"GIF89a") ==
                   1U)) {
              tmp___50 = 1;
            } else {
              if (__s2_len___2 >= 4U) {
                tmp___50 = 1;
              } else {
                tmp___50 = 0;
              }
            }
          } else {
            tmp___50 = 0;
          }
        }
        if (tmp___50) {
          if (__s1_len___2 < __s2_len___2) {
            tmp___48 = __s1_len___2;
          } else {
            tmp___48 = __s2_len___2;
          }
          tmp___47 = memcmp((void const   *)((char const   *)((char *)(buf))), (void const   *)"GIF89a",
                            tmp___48 + 1U);
        } else {
          tmp___49 = strcmp((char const   *)((char *)(buf)), "GIF89a");
          tmp___47 = tmp___49;
        }
      } else {
        tmp___49 = strcmp((char const   *)((char *)(buf)), "GIF89a");
        tmp___47 = tmp___49;
      }
      tmp___42 = tmp___47;
    } else {
      tmp___42 = strncmp((char const   *)((char *)(buf)), "GIF89a", 6U);
    }
    if (tmp___42) {
      badfile: 
      tmp___7 = Tcl_GetString((*(objv + 1)));
      tmp___8 = Tcl_GetObjResult(interp);
      Tcl_AppendStringsToObj(tmp___8, "invalid gif file: ", tmp___7, (void *)0);
      goto done;
    }
  }
  tmp___53 = read(fd, (void *)(buf), 7U);
  if (tmp___53 != 7) {
    goto readfail;
  }
  depth = 1 << (((int )buf[4] & 7) + 1);
  if ((int )buf[4] & 128) {
    colormap = 1;
  } else {
    colormap = 0;
  }
  if (colormap) {
    tmp___54 = read(fd, (void *)(buf), (unsigned int )(3 * depth));
    if (tmp___54 != 3 * depth) {
      goto readfail;
    }
  }
  outerloop: 
  tmp___55 = read(fd, (void *)(buf), 1U);
  if (tmp___55 != 1) {
    goto readfail;
  }
  if ((int )buf[0] == 33) {
    tmp___56 = read(fd, (void *)(buf), 1U);
    if (tmp___56 != 1) {
      goto readfail;
    }
    innerloop: 
    tmp___57 = read(fd, (void *)((char *)(& count)), 1U);
    if (tmp___57 != 1) {
      goto readfail;
    }
    if ((int )count == 0) {
      goto outerloop;
    }
    tmp___58 = read(fd, (void *)(buf), (unsigned int )count);
    if (tmp___58 != (int )count) {
      goto readfail;
    }
    goto innerloop;
  } else {
    if ((int )buf[0] != 44) {
      goto badfile;
    }
  }
  tmp___59 = read(fd, (void *)(buf), 9U);
  if (tmp___59 != 9) {
    goto readfail;
  }
  dx = 256 * (int )buf[5] + (int )buf[4];
  dy = 256 * (int )buf[7] + (int )buf[6];
  tmp___60 = AppendObjDims(interp, dx, dy);
  if (tmp___60 != 0) {
    return (1);
  }
  status = 0;
  done: 
  close(fd);
  return (status);
}
}
int NsTclJpegSizeObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int code ;
  int w ;
  int h ;
  Tcl_Channel chan ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  Tcl_Obj *tmp___2 ;
  int tmp___3 ;

  {
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"file");
    return (1);
  }
  tmp = Tcl_GetString((*(objv + 1)));
  chan = Tcl_OpenFileChannel(interp, tmp, (char *)"r", 0);
  if ((unsigned int )chan == (unsigned int )((void *)0)) {
    return (1);
  }
  tmp___0 = Tcl_SetChannelOption(interp, chan, (char *)"-translation", (char *)"binary");
  if (tmp___0 != 0) {
    return (1);
  }
  code = JpegSize(chan, & w, & h);
  Tcl_Close(interp, chan);
  if (code != 0) {
    tmp___1 = Tcl_GetString((*(objv + 1)));
    tmp___2 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___2, "invalid jpeg file: ", tmp___1, (void *)0);
    return (1);
  }
  tmp___3 = AppendObjDims(interp, w, h);
  if (tmp___3 != 0) {
    return (1);
  }
  return (0);
}
}
static int JpegSize(Tcl_Channel chan , int *wPtr , int *hPtr ) 
{ unsigned int i ;
  unsigned int w ;
  unsigned int h ;
  Tcl_WideInt numbytes ;
  int tmp ;
  int tmp___0 ;
  Tcl_WideInt tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___2 = ChanGetc(chan);
  if (tmp___2 == 255) {
    tmp___3 = ChanGetc(chan);
    if (tmp___3 == 216) {
      while (1) {
        i = (unsigned int )JpegNextMarker(chan);
        if (i == 4294967295U) {
          break;
        } else {
          if (i == 218U) {
            break;
          } else {
            if (i == 217U) {
              break;
            }
          }
        }
        if (192U <= i) {
          if (i <= 195U) {
            tmp = JpegRead2Bytes(chan);
            if (tmp != -1) {
              tmp___0 = ChanGetc(chan);
              if (tmp___0 != -1) {
                h = (unsigned int )JpegRead2Bytes(chan);
                if (h != 4294967295U) {
                  w = (unsigned int )JpegRead2Bytes(chan);
                  if (w != 4294967295U) {
                    (*wPtr) = (int )w;
                    (*hPtr) = (int )h;
                    return (0);
                  }
                }
              }
            }
            break;
          }
        }
        numbytes = (Tcl_WideInt )JpegRead2Bytes(chan);
        if (numbytes < 2LL) {
          break;
        } else {
          tmp___1 = Tcl_Seek(chan, numbytes - 2LL, 1);
          if (tmp___1 == -1LL) {
            break;
          }
        }
      }
    }
  }
  return (1);
}
}
static int JpegRead2Bytes(Tcl_Channel chan ) 
{ int c1 ;
  int c2 ;

  {
  c1 = ChanGetc(chan);
  c2 = ChanGetc(chan);
  if (c1 == -1) {
    return (-1);
  } else {
    if (c2 == -1) {
      return (-1);
    }
  }
  return ((int )((unsigned int )((int )((unsigned int )c1 << 8)) + (unsigned int )c2));
}
}
static int JpegNextMarker(Tcl_Channel chan ) 
{ int c ;

  {
  c = ChanGetc(chan);
  while (1) {
    if (c != -1) {
      if (! (c != 255)) {
        break;
      }
    } else {
      break;
    }
    c = ChanGetc(chan);
  }
  if (c != -1) {
    while (1) {
      c = ChanGetc(chan);
      if (! (c == 255)) {
        break;
      }
    }
  }
  return (c);
}
}
static int ChanGetc(Tcl_Channel chan ) 
{ unsigned char buf[1] ;
  int tmp ;

  {
  tmp = Tcl_Read(chan, (char *)(buf), 1);
  if (tmp != 1) {
    return (-1);
  }
  return ((int )buf[0]);
}
}
static int AppendObjDims(Tcl_Interp *interp , int w , int h ) 
{ char buf[20] ;
  Tcl_Obj *result ;
  Tcl_Obj *tmp ;
  Tcl_Obj *tmp___0 ;
  int tmp___1 ;
  Tcl_Obj *tmp___2 ;
  int tmp___3 ;

  {
  tmp = Tcl_NewObj();
  result = tmp;
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", w);
  tmp___0 = Tcl_NewStringObj(buf, -1);
  tmp___1 = Tcl_ListObjAppendElement(interp, result, tmp___0);
  if (tmp___1) {
    return (1);
  }
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", h);
  tmp___2 = Tcl_NewStringObj(buf, -1);
  tmp___3 = Tcl_ListObjAppendElement(interp, result, tmp___2);
  if (tmp___3) {
    return (1);
  }
  Tcl_SetObjResult(interp, result);
  return (0);
}
}
extern Tcl_Interp *Tcl_CreateInterp(void) ;
extern void Tcl_DeleteInterp(Tcl_Interp *interp ) ;
extern int Tcl_EvalFile(Tcl_Interp *interp , char *fileName ) ;
extern ClientData Tcl_GetAssocData(Tcl_Interp *interp , char *name , Tcl_InterpDeleteProc **procPtr ) ;
extern char *Tcl_GetVar(Tcl_Interp *interp , char *varName , int flags ) ;
extern int Tcl_Init(Tcl_Interp *interp ) ;
extern void Tcl_SetAssocData(Tcl_Interp *interp , char *name , Tcl_InterpDeleteProc *proc ,
                             ClientData clientData ) ;
extern void Tcl_FinalizeThread(void) ;
int Ns_TclInit(Tcl_Interp *interp ) ;
int Nsd_Init(Tcl_Interp *interp ) ;
int Ns_TclInitInterps(char *server , Ns_TclInterpInitProc *proc , void *arg ) ;
void Ns_TclRegisterDeferred(Tcl_Interp *interp , Ns_TclDeferProc *proc , void *arg ) ;
void Ns_TclMarkForDelete(Tcl_Interp *interp ) ;
Tcl_Interp *Ns_TclAllocateInterp(char *server ) ;
void Ns_TclDeAllocateInterp(Tcl_Interp *interp ) ;
char *Ns_TclLibrary(char *server ) ;
char *Ns_TclInterpServer(Tcl_Interp *interp ) ;
Ns_Conn *Ns_TclGetConn(Tcl_Interp *interp ) ;
int Ns_TclRegisterAtCreate(Ns_TclTraceProc *proc , void *arg ) ;
int Ns_TclRegisterAtCleanup(Ns_TclTraceProc *proc , void *arg ) ;
int Ns_TclRegisterAtDelete(Ns_TclTraceProc *proc , void *arg ) ;
int Ns_TclEval(Tcl_DString *dsPtr , char *server , char *script ) ;
char *Ns_TclLogErrorRequest(Tcl_Interp *interp , Ns_Conn *conn ) ;
void NsTclInitQueueType(void) ;
void NsTclInitAddrType(void) ;
void NsTclInitTimeType(void) ;
static void FreeData(ClientData arg , Tcl_Interp *interp ) ;
static void DeleteInterps(void *arg ) ;
static int InitInterp(Tcl_Interp *interp , NsServer *servPtr , NsInterp **itPtrPtr ) ;
static int UpdateInterp(NsInterp *itPtr ) ;
static Tcl_HashEntry *GetHashEntry(NsServer *servPtr ) ;
static int RegisterTrace(NsServer *servPtr , int idx , Ns_TclTraceProc *proc , void *arg ) ;
static void RunTraces___0(NsInterp *itPtr , int idx ) ;
static int TclScriptTraceCB(Tcl_Interp *interp , void *arg ) ;
static int TclInitScriptCB(Tcl_Interp *interp , void *arg ) ;
static Ns_Tls tls___0  ;
static Ns_Mutex initLock  ;
void NsInitTcl(void) 
{ 

  {
  Ns_TlsAlloc(& tls___0, & DeleteInterps);
  Ns_MutexInit(& initLock);
  Ns_MutexSetName(& initLock, (char *)"ns:interp");
  return;
}
}
int Ns_TclEval(Tcl_DString *dsPtr , char *server , char *script ) 
{ int retcode ;
  Tcl_Interp *interp ;
  char *result ;
  int tmp ;

  {
  retcode = -1;
  interp = Ns_TclAllocateInterp(server);
  if ((unsigned int )interp != (unsigned int )((void *)0)) {
    tmp = Tcl_EvalEx(interp, script, -1, 0);
    if (tmp != 0) {
      result = Ns_TclLogError(interp);
    } else {
      result = Tcl_GetStringResult(interp);
      retcode = 0;
    }
    if ((unsigned int )dsPtr != (unsigned int )((void *)0)) {
      Tcl_DStringAppend(dsPtr, result, -1);
    }
    Ns_TclDeAllocateInterp(interp);
  }
  return (retcode);
}
}
int Ns_TclInitInterps(char *server , Ns_TclInterpInitProc *proc , void *arg ) 
{ NsServer *tmp ;
  int tmp___0 ;

  {
  tmp = NsGetServer(server);
  tmp___0 = RegisterTrace(tmp, 0, proc, arg);
  return (tmp___0);
}
}
int Ns_TclRegisterAtCreate(Ns_TclTraceProc *proc , void *arg ) 
{ NsServer *tmp ;
  int tmp___0 ;

  {
  tmp = NsGetInitServer();
  tmp___0 = RegisterTrace(tmp, 1, proc, arg);
  return (tmp___0);
}
}
int Ns_TclRegisterAtCleanup(Ns_TclTraceProc *proc , void *arg ) 
{ NsServer *tmp ;
  int tmp___0 ;

  {
  tmp = NsGetInitServer();
  tmp___0 = RegisterTrace(tmp, 2, proc, arg);
  return (tmp___0);
}
}
int Ns_TclRegisterAtDelete(Ns_TclTraceProc *proc , void *arg ) 
{ NsServer *tmp ;
  int tmp___0 ;

  {
  tmp = NsGetInitServer();
  tmp___0 = RegisterTrace(tmp, 3, proc, arg);
  return (tmp___0);
}
}
void Ns_TclMarkForDelete(Tcl_Interp *interp ) 
{ NsInterp *itPtr ;
  NsInterp *tmp ;

  {
  tmp = NsGetInterp(interp);
  itPtr = tmp;
  if ((unsigned int )itPtr != (unsigned int )((void *)0)) {
    itPtr->delete = 1;
  }
  return;
}
}
int Ns_TclInit(Tcl_Interp *interp ) 
{ int tmp ;

  {
  tmp = InitInterp(interp, (NsServer *)((void *)0), (NsInterp **)((void *)0));
  return (tmp);
}
}
int Nsd_Init(Tcl_Interp *interp ) 
{ int tmp ;

  {
  tmp = Ns_TclInit(interp);
  return (tmp);
}
}
Tcl_Interp *Ns_TclCreateInterp(void) 
{ Tcl_Interp *interp ;
  int tmp ;

  {
  interp = Tcl_CreateInterp();
  tmp = Ns_TclInit(interp);
  if (tmp != 0) {
    Ns_TclLogError(interp);
  }
  return (interp);
}
}
void Ns_TclDestroyInterp(Tcl_Interp *interp ) 
{ 

  {
  Tcl_DeleteInterp(interp);
  return;
}
}
Tcl_Interp *Ns_TclAllocateInterp(char *server ) 
{ Tcl_HashEntry *hPtr ;
  Tcl_Interp *interp ;
  NsInterp *itPtr ;
  NsServer *servPtr ;
  Tcl_Interp *tmp ;
  int tmp___0 ;

  {
  if ((unsigned int )server == (unsigned int )((void *)0)) {
    servPtr = (NsServer *)((void *)0);
  } else {
    servPtr = NsGetServer(server);
    if ((unsigned int )servPtr == (unsigned int )((void *)0)) {
      return ((Tcl_Interp *)((void *)0));
    }
  }
  hPtr = GetHashEntry(servPtr);
  itPtr = (NsInterp *)hPtr->clientData;
  if ((unsigned int )itPtr != (unsigned int )((void *)0)) {
    hPtr->clientData = (void *)itPtr->nextPtr;
  } else {
    tmp = Tcl_CreateInterp();
    InitInterp(tmp, servPtr, & itPtr);
  }
  interp = itPtr->interp;
  itPtr->nextPtr = (struct NsInterp *)((void *)0);
  tmp___0 = Tcl_EvalEx(interp, (char *)"ns_init", -1, 0);
  if (tmp___0 != 0) {
    Ns_TclLogError(interp);
  }
  return (interp);
}
}
void Ns_TclDeAllocateInterp(Tcl_Interp *interp ) 
{ NsInterp *itPtr ;
  NsInterp *tmp ;
  Tcl_HashEntry *hPtr ;
  int tmp___0 ;

  {
  tmp = NsGetInterp(interp);
  itPtr = tmp;
  if ((unsigned int )itPtr == (unsigned int )((void *)0)) {
    Tcl_DeleteInterp(interp);
    return;
  }
  if ((unsigned int )itPtr->conn != (unsigned int )((void *)0)) {
    return;
  }
  tmp___0 = Tcl_EvalEx(interp, (char *)"ns_cleanup", -1, 0);
  if (tmp___0 != 0) {
    Ns_TclLogError(interp);
  }
  if (itPtr->delete) {
    Tcl_DeleteInterp(interp);
  } else {
    Tcl_ResetResult(interp);
    hPtr = GetHashEntry(itPtr->servPtr);
    itPtr->nextPtr = (struct NsInterp *)hPtr->clientData;
    hPtr->clientData = (void *)itPtr;
  }
  return;
}
}
void Ns_TclRegisterDeferred(Tcl_Interp *interp , Ns_TclDeferProc *proc , void *arg ) 
{ NsInterp *itPtr ;
  NsInterp *tmp ;
  Defer *deferPtr ;
  Defer **nextPtrPtr ;

  {
  tmp = NsGetInterp(interp);
  itPtr = tmp;
  if ((unsigned int )itPtr == (unsigned int )((void *)0)) {
    return;
  }
  deferPtr = (Defer *)ns_malloc(sizeof(Defer ));
  deferPtr->proc = proc;
  deferPtr->arg = arg;
  deferPtr->nextPtr = (struct Defer *)((void *)0);
  nextPtrPtr = & itPtr->firstDeferPtr;
  while ((unsigned int )(*nextPtrPtr) != (unsigned int )((void *)0)) {
    nextPtrPtr = & ((*nextPtrPtr))->nextPtr;
  }
  (*nextPtrPtr) = deferPtr;
  return;
}
}
NsInterp *NsGetInterp(Tcl_Interp *interp ) 
{ NsInterp *tmp ;

  {
  if ((unsigned int )interp == (unsigned int )((void *)0)) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"NsGetInterp: Invalid Tcl_Interp == NULL");
    return ((NsInterp *)((void *)0));
  } else {
    tmp = (NsInterp *)Tcl_GetAssocData(interp, (char *)"ns:data", (Tcl_InterpDeleteProc **)((void *)0));
    return (tmp);
  }
}
}
int NsTclMarkForDeleteObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 1) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"");
    return (1);
  }
  itPtr->delete = 1;
  return (0);
}
}
Tcl_Interp *Ns_GetConnInterp(Ns_Conn *conn ) 
{ Conn *connPtr ;
  NsInterp *itPtr ;

  {
  connPtr = (Conn *)conn;
  if ((unsigned int )connPtr->interp == (unsigned int )((void *)0)) {
    connPtr->interp = Ns_TclAllocateInterp(connPtr->server);
    itPtr = NsGetInterp(connPtr->interp);
    itPtr->conn = conn;
    itPtr->nsconn.flags = 0;
  }
  return (connPtr->interp);
}
}
void Ns_FreeConnInterp(Ns_Conn *conn ) 
{ NsInterp *itPtr ;
  Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  if ((unsigned int )connPtr->interp != (unsigned int )((void *)0)) {
    itPtr = NsGetInterp(connPtr->interp);
    itPtr->conn = (Ns_Conn *)((void *)0);
    itPtr->nsconn.flags = 0;
    Ns_TclDeAllocateInterp(connPtr->interp);
    connPtr->interp = (Tcl_Interp *)((void *)0);
  }
  return;
}
}
Ns_Conn *Ns_TclGetConn(Tcl_Interp *interp ) 
{ NsInterp *itPtr ;
  Ns_Conn *tmp ;

  {
  if ((unsigned int )interp == (unsigned int )((void *)0)) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"Ns_TclGetConn: interp == NULL; Valid interp value required.");
    return ((Ns_Conn *)((void *)0));
  }
  itPtr = NsGetInterp(interp);
  if (itPtr) {
    tmp = itPtr->conn;
  } else {
    tmp = (Ns_Conn *)((void *)0);
  }
  return (tmp);
}
}
char *Ns_TclLibrary(char *server ) 
{ NsServer *servPtr ;
  NsServer *tmp ;
  char *tmp___0 ;

  {
  tmp = NsGetServer(server);
  servPtr = tmp;
  if (servPtr) {
    tmp___0 = servPtr->tcl.library;
  } else {
    tmp___0 = nsconf.tcl.sharedlibrary;
  }
  return (tmp___0);
}
}
char *Ns_TclInterpServer(Tcl_Interp *interp ) 
{ NsInterp *itPtr ;

  {
  if ((unsigned int )interp == (unsigned int )((void *)0)) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"Ns_TclInterpServer: interp == NULL; Valid interp value required.");
    return ((char *)((void *)0));
  }
  itPtr = NsGetInterp(interp);
  if ((unsigned int )itPtr == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  } else {
    if ((unsigned int )itPtr->servPtr == (unsigned int )((void *)0)) {
      return ((char *)((void *)0));
    }
  }
  return ((itPtr->servPtr)->server);
}
}
void NsTclInitServer(char *server ) 
{ NsServer *servPtr ;
  NsServer *tmp ;
  Tcl_Interp *interp ;
  int tmp___0 ;

  {
  tmp = NsGetServer(server);
  servPtr = tmp;
  if ((unsigned int )servPtr != (unsigned int )((void *)0)) {
    interp = Ns_TclAllocateInterp(server);
    tmp___0 = Tcl_EvalFile(interp, servPtr->tcl.initfile);
    if (tmp___0 != 0) {
      Ns_TclLogError(interp);
    }
    Ns_TclDeAllocateInterp(interp);
  }
  return;
}
}
char *Ns_TclLogError(Tcl_Interp *interp ) 
{ char *errorInfo ;
  char *tmp ;

  {
  errorInfo = Tcl_GetVar(interp, (char *)"errorInfo", 1);
  if ((unsigned int )errorInfo == (unsigned int )((void *)0)) {
    errorInfo = (char *)"";
  }
  tmp = Tcl_GetStringResult(interp);
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"%s\n%s", tmp, errorInfo);
  return (errorInfo);
}
}
char *Ns_TclLogErrorRequest(Tcl_Interp *interp , Ns_Conn *conn ) 
{ char *agent ;
  char *errorInfo ;
  char *tmp ;

  {
  errorInfo = Tcl_GetVar(interp, (char *)"errorInfo", 1);
  if ((unsigned int )errorInfo == (unsigned int )((void *)0)) {
    errorInfo = Tcl_GetStringResult(interp);
  }
  agent = Ns_SetIGet(conn->headers, (char *)"user-agent");
  if ((unsigned int )agent == (unsigned int )((void *)0)) {
    agent = (char *)"?";
  }
  tmp = Ns_ConnPeer(conn);
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"error for %s %s, User-Agent: %s, PeerAddress: %s\n%s",
         (conn->request)->method, (conn->request)->url, agent, tmp, errorInfo);
  return (errorInfo);
}
}
int Ns_TclInitModule(char *server , char *module ) 
{ NsServer *servPtr ;
  Tcl_Obj *tmp ;

  {
  servPtr = NsGetServer(server);
  if ((unsigned int )servPtr == (unsigned int )((void *)0)) {
    return (-1);
  }
  tmp = Tcl_NewStringObj(module, -1);
  Tcl_ListObjAppendElement((Tcl_Interp *)((void *)0), servPtr->tcl.modules, tmp);
  return (0);
}
}
int NsTclDummyObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ 

  {
  return (0);
}
}
static char *opts___5[12]  = 
  {      (char *)"addmodule",      (char *)"cleanup",      (char *)"epoch",      (char *)"get", 
        (char *)"getmodules",      (char *)"save",      (char *)"update",      (char *)"oncreate", 
        (char *)"oncleanup",      (char *)"oninit",      (char *)"ondelete",      (char *)((void *)0)};
int NsTclICtlObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Defer *deferPtr ;
  NsInterp *itPtr ;
  enum __anonenum_opt_107___2 opt ;
  char *script ;
  int length ;
  int result ;
  int status ;
  Tcl_Obj *objPtr ;
  int tmp ;
  int tmp___0 ;
  Tcl_Obj *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  NsServer *tmp___4 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc < 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"option ?arg?");
    return (1);
  }
  tmp = Tcl_GetIndexFromObj(interp, (*(objv + 1)), opts___5, (char *)"option", 0,
                            (int *)(& opt));
  if (tmp != 0) {
    return (1);
  }
  result = 0;
  switch ((int )opt) {
  case 0: ;
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"module");
    return (1);
  }
  tmp___0 = Tcl_ListObjAppendElement(interp, (itPtr->servPtr)->tcl.modules, (*(objv +
                                                                               2)));
  if (tmp___0 != 0) {
    return (1);
  }
  Tcl_SetObjResult(interp, (itPtr->servPtr)->tcl.modules);
  break;
  case 4: ;
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)((void *)0));
    return (1);
  }
  Tcl_SetObjResult(interp, (itPtr->servPtr)->tcl.modules);
  break;
  case 3: ;
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)((void *)0));
    return (1);
  }
  Ns_RWLockRdLock(& (itPtr->servPtr)->tcl.lock);
  Tcl_SetResult(interp, (itPtr->servPtr)->tcl.script, (Tcl_FreeProc *)1);
  Ns_RWLockUnlock(& (itPtr->servPtr)->tcl.lock);
  break;
  case 2: ;
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)((void *)0));
    return (1);
  }
  Ns_RWLockRdLock(& (itPtr->servPtr)->tcl.lock);
  tmp___1 = Tcl_GetObjResult(interp);
  Tcl_SetIntObj(tmp___1, (itPtr->servPtr)->tcl.epoch);
  Ns_RWLockUnlock(& (itPtr->servPtr)->tcl.lock);
  break;
  case 5: ;
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"script");
    return (1);
  }
  tmp___2 = Tcl_GetStringFromObj((*(objv + 2)), & length);
  script = ns_strdup((char const   *)tmp___2);
  Ns_RWLockWrLock(& (itPtr->servPtr)->tcl.lock);
  ns_free((void *)(itPtr->servPtr)->tcl.script);
  (itPtr->servPtr)->tcl.script = script;
  (itPtr->servPtr)->tcl.length = length;
  (itPtr->servPtr)->tcl.epoch = (itPtr->servPtr)->tcl.epoch + 1;
  if ((itPtr->servPtr)->tcl.epoch == 0) {
    (itPtr->servPtr)->tcl.epoch = (itPtr->servPtr)->tcl.epoch + 1;
  }
  Ns_RWLockUnlock(& (itPtr->servPtr)->tcl.lock);
  break;
  case 6: ;
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)((void *)0));
    return (1);
  }
  result = UpdateInterp(itPtr);
  break;
  case 1: ;
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)((void *)0));
    return (1);
  }
  RunTraces___0(itPtr, 2);
  while (1) {
    deferPtr = itPtr->firstDeferPtr;
    if (! ((unsigned int )deferPtr != (unsigned int )((void *)0))) {
      break;
    }
    itPtr->firstDeferPtr = deferPtr->nextPtr;
    ((*(deferPtr->proc)))(interp, deferPtr->arg);
    ns_free((void *)deferPtr);
  }
  NsFreeAtClose(itPtr);
  break;
  case 7: ;
  case 8: ;
  case 9: ;
  case 10: ;
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"when script");
    return (1);
  }
  tmp___3 = Tcl_GetString((*(objv + 2)));
  script = ns_strdup((char const   *)tmp___3);
  switch ((int )opt) {
  case 7: 
  status = Ns_TclRegisterAtCreate(& TclScriptTraceCB, (void *)script);
  break;
  case 8: 
  status = Ns_TclRegisterAtCleanup(& TclScriptTraceCB, (void *)script);
  break;
  case 10: 
  status = Ns_TclRegisterAtDelete(& TclScriptTraceCB, (void *)script);
  break;
  case 9: 
  status = Ns_TclInitInterps((itPtr->servPtr)->server, & TclInitScriptCB, (void *)script);
  break;
  default: 
  status = -1;
  break;
  }
  if (status != 0) {
    Tcl_AppendResult(interp, "Failed ", opts___5[opt], "-time registration", (void *)0);
    if ((int )opt != 9) {
      tmp___4 = NsGetInitServer();
      if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
        Tcl_AppendResult(interp, ", this can only be used during server init.", (void *)0);
      }
    }
    objPtr->refCount = objPtr->refCount - 1;
    if (objPtr->refCount <= 0) {
      TclFreeObj(objPtr);
    }
    result = 1;
  } else {
    result = 0;
  }
  break;
  }
  return (result);
}
}
static int TclScriptTraceCB(Tcl_Interp *interp , void *arg ) 
{ char *script ;
  int status ;

  {
  script = (char *)arg;
  status = 0;
  if ((unsigned int )script != (unsigned int )((void *)0)) {
    status = Tcl_EvalEx(interp, script, -1, 131072);
  }
  return (status);
}
}
static int TclInitScriptCB(Tcl_Interp *interp , void *arg ) 
{ char *script ;
  int status ;
  int tmp ;

  {
  script = (char *)arg;
  status = 0;
  if ((unsigned int )script != (unsigned int )((void *)0)) {
    tmp = Tcl_EvalEx(interp, script, -1, 131072);
    if (tmp != 0) {
      status = -1;
    }
  }
  return (status);
}
}
static int volatile   initialized___0  =    (int volatile   )0;
static int InitInterp(Tcl_Interp *interp , NsServer *servPtr , NsInterp **itPtrPtr ) 
{ NsInterp *itPtr ;
  int result ;
  int updateResult ;
  int tmp ;

  {
  result = 0;
  updateResult = 0;
  tmp = Tcl_Init(interp);
  if (tmp != 0) {
    Ns_TclLogError(interp);
    result = 1;
  }
  if (! initialized___0) {
    Ns_MasterLock();
    if (! initialized___0) {
      NsTclInitQueueType();
      NsTclInitAddrType();
      NsTclInitTimeType();
      initialized___0 = (int volatile   )1;
    }
    Ns_MasterUnlock();
  }
  itPtr = (NsInterp *)ns_calloc(1U, sizeof(NsInterp ));
  itPtr->interp = interp;
  itPtr->servPtr = servPtr;
  Tcl_InitHashTable(& itPtr->sets, 0);
  Tcl_InitHashTable(& itPtr->chans, 0);
  Tcl_InitHashTable(& itPtr->https, 0);
  Tcl_SetAssocData(interp, (char *)"ns:data", & FreeData, (void *)itPtr);
  NsTclAddCmds(interp, itPtr);
  if ((unsigned int )servPtr != (unsigned int )((void *)0)) {
    NsTclAddServerCmds(interp, itPtr);
    RunTraces___0(itPtr, 0);
    RunTraces___0(itPtr, 1);
    if (nsconf.tcl.lockoninit) {
      Ns_MutexLock(& initLock);
    }
    updateResult = UpdateInterp(itPtr);
    if (nsconf.tcl.lockoninit) {
      Ns_MutexUnlock(& initLock);
    }
    if (updateResult != 0) {
      Ns_TclLogError(interp);
      result = 1;
    }
  }
  if ((unsigned int )itPtrPtr != (unsigned int )((void *)0)) {
    (*itPtrPtr) = itPtr;
  }
  return (result);
}
}
static int UpdateInterp(NsInterp *itPtr ) 
{ int result ;

  {
  result = 0;
  Ns_RWLockRdLock(& (itPtr->servPtr)->tcl.lock);
  if (itPtr->epoch != (itPtr->servPtr)->tcl.epoch) {
    result = Tcl_EvalEx(itPtr->interp, (itPtr->servPtr)->tcl.script, (itPtr->servPtr)->tcl.length,
                        131072);
    itPtr->epoch = (itPtr->servPtr)->tcl.epoch;
  }
  Ns_RWLockUnlock(& (itPtr->servPtr)->tcl.lock);
  return (result);
}
}
static void FreeData(ClientData arg , Tcl_Interp *interp ) 
{ NsInterp *itPtr ;

  {
  itPtr = (NsInterp *)arg;
  NsFreeAdp(itPtr);
  Tcl_DeleteHashTable(& itPtr->sets);
  Tcl_DeleteHashTable(& itPtr->chans);
  Tcl_DeleteHashTable(& itPtr->https);
  ns_free((void *)itPtr);
  return;
}
}
static void DeleteInterps(void *arg ) 
{ Tcl_HashTable *tablePtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  NsInterp *itPtr ;

  {
  tablePtr = (Tcl_HashTable *)arg;
  hPtr = Tcl_FirstHashEntry(tablePtr, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    while (1) {
      itPtr = (NsInterp *)hPtr->clientData;
      if (! ((unsigned int )itPtr != (unsigned int )((void *)0))) {
        break;
      }
      hPtr->clientData = (void *)itPtr->nextPtr;
      RunTraces___0(itPtr, 3);
      Tcl_DeleteInterp(itPtr->interp);
    }
    hPtr = Tcl_NextHashEntry(& search);
  }
  Tcl_DeleteHashTable(tablePtr);
  ns_free((void *)tablePtr);
  Tcl_FinalizeThread();
  return;
}
}
static Tcl_HashEntry *GetHashEntry(NsServer *servPtr ) 
{ Tcl_HashTable *tablePtr ;
  int ignored ;
  Tcl_HashEntry *tmp ;

  {
  tablePtr = (Tcl_HashTable *)Ns_TlsGet(& tls___0);
  if ((unsigned int )tablePtr == (unsigned int )((void *)0)) {
    tablePtr = (Tcl_HashTable *)ns_malloc(sizeof(Tcl_HashTable ));
    Tcl_InitHashTable(tablePtr, 1);
    Ns_TlsSet(& tls___0, (void *)tablePtr);
  }
  tmp = ((*(tablePtr->createProc)))(tablePtr, (char *)servPtr, & ignored);
  return (tmp);
}
}
static int RegisterTrace(NsServer *servPtr , int idx , Ns_TclTraceProc *proc , void *arg ) 
{ Trace___0 *tracePtr ;
  Trace___0 **firstPtrPtr ;

  {
  if ((unsigned int )servPtr == (unsigned int )((void *)0)) {
    return (-1);
  }
  tracePtr = (Trace___0 *)ns_malloc(sizeof(Trace___0 ));
  tracePtr->proc = proc;
  tracePtr->arg = arg;
  tracePtr->nextPtr = (struct Trace1 *)((void *)0);
  firstPtrPtr = (Trace___0 **)(& servPtr->tcl.traces[idx]);
  while ((unsigned int )(*firstPtrPtr) != (unsigned int )((void *)0)) {
    firstPtrPtr = & ((*firstPtrPtr))->nextPtr;
  }
  (*firstPtrPtr) = tracePtr;
  return (0);
}
}
static void RunTraces___0(NsInterp *itPtr , int idx ) 
{ Trace___0 *tracePtr ;
  int tmp ;

  {
  if ((unsigned int )itPtr->servPtr != (unsigned int )((void *)0)) {
    tracePtr = (Trace___0 *)(itPtr->servPtr)->tcl.traces[idx];
    while ((unsigned int )tracePtr != (unsigned int )((void *)0)) {
      tmp = ((*(tracePtr->proc)))(itPtr->interp, tracePtr->arg);
      if (tmp != 0) {
        Ns_TclLogError(itPtr->interp);
      }
      tracePtr = tracePtr->nextPtr;
    }
  }
  return;
}
}
extern Tcl_Obj *Tcl_NewDoubleObj(double doubleValue ) ;
extern Tcl_Obj *Tcl_NewListObj(int objc , Tcl_Obj **objv ) ;
extern Tcl_Obj *Tcl_NewLongObj(long longValue ) ;
static void JobThread(void *arg ) ;
static Job *getNextJob(void) ;
Queue___0 *NewQueue(char *queueName , char *queueDesc , int maxThreads ) ;
void FreeQueue(Queue___0 *queuePtr ) ;
Job *NewJob(char *server , char *queueId , int type , Tcl_Obj *script ) ;
void FreeJob(Job *jobPtr ) ;
static int LookupQueue(Tcl_Interp *interp , char *queueId , Queue___0 **queuePtr ,
                       int locked ) ;
static int ReleaseQueue(Queue___0 *queuePtr , int locked ) ;
static int AnyDone(Queue___0 *queue___1 ) ;
static char *GetJobCodeStr(int code ) ;
static char *GetJobStateStr(JobStates state ) ;
static char *GetJobTypeStr(JobTypes type ) ;
static char *GetJobReqStr(JobRequests req ) ;
static char *GetQueueReqStr(QueueRequests req ) ;
static char *GetTpReqStr(ThreadPoolRequests req ) ;
static int AppendField(Tcl_Interp *interp , Tcl_Obj *list , char *name , char *value ) ;
static int AppendFieldInt(Tcl_Interp *interp , Tcl_Obj *list , char *name , int value ) ;
static int AppendFieldLong(Tcl_Interp *interp , Tcl_Obj *list , char *name , long value ) ;
static int AppendFieldDouble(Tcl_Interp *interp , Tcl_Obj *list , char *name , double value ) ;
static double ComputeDelta(Ns_Time *start , Ns_Time *end ) ;
static ThreadPool tp  ;
void NsTclInitQueueType(void) 
{ 

  {
  Tcl_InitHashTable(& tp.queues, 0);
  Ns_MutexSetName(& tp.queuelock, (char *)"threadPool");
  tp.nextThreadId = 0;
  tp.nextQueueId = 0UL;
  tp.maxThreads = 0;
  tp.nthreads = 0;
  tp.nidle = 0;
  tp.firstPtr = (Job *)((void *)0);
  tp.req = (enum ThreadPoolRequests )0;
  return;
}
}
void NsStartJobsShutdown(void) 
{ Tcl_HashSearch search ;
  Tcl_HashEntry *hPtr ;

  {
  hPtr = Tcl_FirstHashEntry(& tp.queues, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    Ns_MutexLock(& tp.queuelock);
    tp.req = (enum ThreadPoolRequests )1;
    Ns_CondBroadcast(& tp.cond);
    Ns_MutexUnlock(& tp.queuelock);
    hPtr = Tcl_NextHashEntry(& search);
  }
  return;
}
}
void NsWaitJobsShutdown(Ns_Time *toPtr ) 
{ Tcl_HashSearch search ;
  Tcl_HashEntry *hPtr ;
  int status ;

  {
  status = 0;
  hPtr = Tcl_FirstHashEntry(& tp.queues, & search);
  while (1) {
    if (status == 0) {
      if (! ((unsigned int )hPtr != (unsigned int )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    Ns_MutexLock(& tp.queuelock);
    while (1) {
      if (status == 0) {
        if (! (tp.nthreads > 0)) {
          break;
        }
      } else {
        break;
      }
      status = Ns_CondTimedWait(& tp.cond, & tp.queuelock, toPtr);
    }
    Ns_MutexUnlock(& tp.queuelock);
    hPtr = Tcl_NextHashEntry(& search);
  }
  if (status != 0) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"tcljobs: timeout waiting for exit");
  }
  return;
}
}
static char *opts___6[13]  = 
  {      (char *)"cancel",      (char *)"create",      (char *)"delete",      (char *)"genid", 
        (char *)"jobs",      (char *)"joblist",      (char *)"threadlist",      (char *)"queue", 
        (char *)"queues",      (char *)"queuelist",      (char *)"wait",      (char *)"waitany", 
        (char *)((void *)0)};
int NsTclJobObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  Queue___0 *queuePtr ;
  Job *jobPtr ;
  Job **nextPtrPtr ;
  int code ;
  int new ;
  int create ;
  int max ;
  char *jobId ;
  char buf[100] ;
  char *queueId ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashEntry *jPtr ;
  Tcl_HashSearch search ;
  int argIndex ;
  enum __anonenum_opt_107___3 opt ;
  int tmp ;
  Tcl_Obj *queueIdObj ;
  char *queueDesc ;
  int tmp___0 ;
  int tmp___71 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___102 ;
  size_t tmp___103 ;
  char *tmp___104 ;
  char *tmp___125 ;
  int tmp___126 ;
  char *tmp___128 ;
  char *tmp___129 ;
  char *tmp___130 ;
  int tmp___131 ;
  size_t tmp___132 ;
  char *tmp___133 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  char *tmp___144 ;
  char *tmp___145 ;
  char *tmp___146 ;
  int tmp___147 ;
  int job_type ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___204 ;
  size_t tmp___205 ;
  int tmp___206 ;
  char *tmp___207 ;
  int tmp___248 ;
  char *tmp___249 ;
  int tmp___250 ;
  int tmp___253 ;
  char *tmp___254 ;
  int tmp___255 ;
  char *tmp___256 ;
  int tmp___257 ;
  char *tmp___258 ;
  int tmp___259 ;
  int tmp___260 ;
  char *tmp___261 ;
  int tmp___262 ;
  int tmp___263 ;
  char *tmp___264 ;
  unsigned int tmp___265 ;
  int timeoutFlag ;
  Ns_Time timeout ;
  int timedOut ;
  Ns_Time delta_timeout ;
  int tmp___266 ;
  int tmp___267 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___324 ;
  size_t tmp___325 ;
  int tmp___326 ;
  char *tmp___327 ;
  int tmp___368 ;
  char *tmp___369 ;
  int tmp___370 ;
  int tmp___373 ;
  char *tmp___374 ;
  int tmp___375 ;
  char *tmp___376 ;
  int tmp___377 ;
  char *tmp___378 ;
  int tmp___379 ;
  int tmp___380 ;
  char *tmp___381 ;
  int tmp___382 ;
  int tmp___383 ;
  char *tmp___384 ;
  char *tmp___385 ;
  int tmp___386 ;
  Tcl_Obj *tmp___387 ;
  int timeoutFlag___0 ;
  Ns_Time timeout___0 ;
  int timedOut___0 ;
  Ns_Time delta_timeout___0 ;
  int tmp___388 ;
  int tmp___389 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___446 ;
  size_t tmp___447 ;
  int tmp___448 ;
  char *tmp___449 ;
  int tmp___490 ;
  char *tmp___491 ;
  int tmp___492 ;
  int tmp___495 ;
  char *tmp___496 ;
  int tmp___497 ;
  char *tmp___498 ;
  int tmp___499 ;
  char *tmp___500 ;
  int tmp___501 ;
  int tmp___502 ;
  char *tmp___503 ;
  int tmp___504 ;
  Tcl_HashEntry *tmp___505 ;
  int tmp___506 ;
  Tcl_HashEntry *tmp___507 ;
  int tmp___508 ;
  char *tmp___509 ;
  int tmp___510 ;
  char *tmp___511 ;
  Tcl_Obj *jobList ;
  Tcl_Obj *jobFieldList ;
  char *jobId___0 ;
  char *jobState ;
  char *jobCode ;
  char *jobType ;
  char *jobResults ;
  char *jobScript ;
  char *jobReq ;
  double delta ;
  char *tmp___512 ;
  int tmp___513 ;
  char *tmp___514 ;
  int tmp___515 ;
  int tmp___516 ;
  int tmp___517 ;
  int tmp___518 ;
  int tmp___519 ;
  int tmp___520 ;
  int tmp___521 ;
  int tmp___522 ;
  int tmp___523 ;
  int tmp___524 ;
  int tmp___525 ;
  Tcl_Obj *queueList ;
  Tcl_Obj *queueFieldList ;
  char *queueReq ;
  int tmp___526 ;
  int tmp___527 ;
  int tmp___528 ;
  int tmp___529 ;
  int tmp___530 ;
  int tmp___531 ;
  Ns_Time currentTime ;
  unsigned long tmp___532 ;
  Tcl_Obj *tpFieldList ;
  char *tpReq ;
  int tmp___533 ;
  int tmp___534 ;
  int tmp___535 ;
  int tmp___536 ;

  {
  itPtr = (NsInterp *)arg;
  queuePtr = (Queue___0 *)((void *)0);
  jobPtr = (Job *)((void *)0);
  create = 0;
  jobId = (char *)((void *)0);
  if (objc < 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"option ?arg?");
    return (1);
  }
  tmp = Tcl_GetIndexFromObj(interp, (*(objv + 1)), opts___6, (char *)"option", 1,
                            (int *)(& opt));
  if (tmp != 0) {
    return (1);
  }
  code = 0;
  switch ((int )opt) {
  case 1: 
  queueIdObj = (Tcl_Obj *)((void *)0);
  queueDesc = (char *)"";
  argIndex = 2;
  if (objc < 3) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"?-desc description? queueId ?maxThreads?");
    return (1);
  } else {
    if (objc > 6) {
      Tcl_WrongNumArgs(interp, 2, objv, (char *)"?-desc description? queueId ?maxThreads?");
      return (1);
    }
  }
  if (objc > 3) {
    if (0) {
      if (0) {
        tmp___128 = Tcl_GetString((*(objv + argIndex)));
        __s1_len___0 = strlen((char const   *)tmp___128);
        __s2_len___0 = strlen("-desc");
        tmp___129 = Tcl_GetString((*(objv + argIndex)));
        tmp___130 = Tcl_GetString((*(objv + argIndex)));
        if ((unsigned int )((void const   *)(tmp___129 + 1)) - (unsigned int )((void const   *)tmp___130) ==
            1U) {
          if (__s1_len___0 >= 4U) {
            _L___2: 
            if (! ((unsigned int )((void const   *)("-desc" + 1)) - (unsigned int )((void const   *)"-desc") ==
                   1U)) {
              tmp___131 = 1;
            } else {
              if (__s2_len___0 >= 4U) {
                tmp___131 = 1;
              } else {
                tmp___131 = 0;
              }
            }
          } else {
            tmp___131 = 0;
          }
        } else {
          goto _L___2;
        }
        if (tmp___131) {
          if (__s1_len___0 < __s2_len___0) {
            tmp___103 = __s1_len___0;
          } else {
            tmp___103 = __s2_len___0;
          }
          tmp___104 = Tcl_GetString((*(objv + argIndex)));
          tmp___102 = memcmp((void const   *)((char const   *)tmp___104), (void const   *)"-desc",
                             tmp___103 + 1U);
        } else {
          tmp___125 = Tcl_GetString((*(objv + argIndex)));
          tmp___126 = strcmp((char const   *)tmp___125, "-desc");
          tmp___102 = tmp___126;
        }
      } else {
        tmp___125 = Tcl_GetString((*(objv + argIndex)));
        tmp___126 = strcmp((char const   *)tmp___125, "-desc");
        tmp___102 = tmp___126;
      }
      tmp___71 = tmp___102;
    } else {
      tmp___132 = strlen("-desc");
      tmp___133 = Tcl_GetString((*(objv + argIndex)));
      tmp___71 = strncmp((char const   *)tmp___133, "-desc", tmp___132);
    }
    if (tmp___71 == 0) {
      argIndex ++;
      tmp___0 = argIndex;
      argIndex ++;
      queueDesc = Tcl_GetString((*(objv + tmp___0)));
    }
  }
  tmp___141 = argIndex;
  argIndex ++;
  queueIdObj = (*(objv + tmp___141));
  queueId = Tcl_GetString(queueIdObj);
  max = 4;
  if (objc > argIndex) {
    tmp___142 = argIndex;
    argIndex ++;
    tmp___143 = Tcl_GetIntFromObj(interp, (*(objv + tmp___142)), & max);
    if (tmp___143 != 0) {
      return (1);
    }
  }
  Ns_MutexLock(& tp.queuelock);
  tmp___144 = Tcl_GetString(queueIdObj);
  hPtr = ((*(tp.queues.createProc)))(& tp.queues, tmp___144, & new);
  if (new) {
    if (tp.queues.keyType == 1) {
      tmp___145 = hPtr->key.oneWordValue;
    } else {
      if (tp.queues.keyType == -1) {
        tmp___145 = hPtr->key.oneWordValue;
      } else {
        tmp___145 = hPtr->key.string;
      }
    }
    queuePtr = NewQueue(tmp___145, queueDesc, max);
    hPtr->clientData = (void *)queuePtr;
  }
  Ns_MutexUnlock(& tp.queuelock);
  if (! new) {
    Tcl_AppendResult(interp, "queue already exists: ", queueId, (void *)0);
    return (1);
  }
  Tcl_SetObjResult(interp, queueIdObj);
  break;
  case 2: ;
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"queueId");
    return (1);
  }
  tmp___146 = Tcl_GetString((*(objv + 2)));
  tmp___147 = LookupQueue(interp, tmp___146, & queuePtr, 0);
  if (tmp___147 != 0) {
    return (1);
  }
  queuePtr->req = (enum QueueRequests )1;
  ReleaseQueue(queuePtr, 0);
  Ns_CondBroadcast(& tp.cond);
  Tcl_SetResult(interp, (char *)"", (Tcl_FreeProc *)0);
  break;
  case 7: 
  job_type = 0;
  argIndex = 2;
  if (objc != 4) {
    if (objc != 5) {
      Tcl_WrongNumArgs(interp, 2, objv, (char *)"?-detached? queueId script");
      return (1);
    }
  }
  if (objc > 4) {
    if (0) {
      tmp___253 = argIndex;
      argIndex ++;
      tmp___254 = Tcl_GetString((*(objv + tmp___253)));
      __s1_len___1 = strlen((char const   *)tmp___254);
      __s2_len___1 = strlen("-detached");
      tmp___255 = argIndex;
      argIndex ++;
      tmp___256 = Tcl_GetString((*(objv + tmp___255)));
      tmp___257 = argIndex;
      argIndex ++;
      tmp___258 = Tcl_GetString((*(objv + tmp___257)));
      if ((unsigned int )((void const   *)(tmp___256 + 1)) - (unsigned int )((void const   *)tmp___258) ==
          1U) {
        if (__s1_len___1 >= 4U) {
          _L___4: 
          if (! ((unsigned int )((void const   *)("-detached" + 1)) - (unsigned int )((void const   *)"-detached") ==
                 1U)) {
            tmp___259 = 1;
          } else {
            if (__s2_len___1 >= 4U) {
              tmp___259 = 1;
            } else {
              tmp___259 = 0;
            }
          }
        } else {
          tmp___259 = 0;
        }
      } else {
        goto _L___4;
      }
      if (tmp___259) {
        if (__s1_len___1 < __s2_len___1) {
          tmp___205 = __s1_len___1;
        } else {
          tmp___205 = __s2_len___1;
        }
        tmp___206 = argIndex;
        argIndex ++;
        tmp___207 = Tcl_GetString((*(objv + tmp___206)));
        tmp___204 = memcmp((void const   *)((char const   *)tmp___207), (void const   *)"-detached",
                           tmp___205 + 1U);
      } else {
        tmp___248 = argIndex;
        argIndex ++;
        tmp___249 = Tcl_GetString((*(objv + tmp___248)));
        tmp___250 = strcmp((char const   *)tmp___249, "-detached");
        tmp___204 = tmp___250;
      }
    } else {
      tmp___248 = argIndex;
      argIndex ++;
      tmp___249 = Tcl_GetString((*(objv + tmp___248)));
      tmp___250 = strcmp((char const   *)tmp___249, "-detached");
      tmp___204 = tmp___250;
    }
    if (tmp___204 == 0) {
      job_type = 1;
    } else {
      Tcl_WrongNumArgs(interp, 2, objv, (char *)"?-detached? queueId script");
      return (1);
    }
  }
  Ns_MutexLock(& tp.queuelock);
  tmp___260 = argIndex;
  argIndex ++;
  tmp___261 = Tcl_GetString((*(objv + tmp___260)));
  tmp___262 = LookupQueue(interp, tmp___261, & queuePtr, 1);
  if (tmp___262 != 0) {
    Ns_MutexUnlock(& tp.queuelock);
    return (1);
  }
  tmp___263 = argIndex;
  argIndex ++;
  if (itPtr->servPtr) {
    tmp___264 = (itPtr->servPtr)->server;
  } else {
    tmp___264 = (char *)((void *)0);
  }
  jobPtr = NewJob(tmp___264, queuePtr->name, job_type, (*(objv + tmp___263)));
  Ns_GetTime(& jobPtr->startTime);
  if ((int )tp.req == 1) {
    Tcl_AppendResult(interp, "The specified queue is being deleted or the system is stopping.",
                     (void *)0);
    FreeJob(jobPtr);
    ReleaseQueue(queuePtr, 1);
    Ns_MutexUnlock(& tp.queuelock);
    return (1);
  } else {
    if ((int )queuePtr->req == 1) {
      Tcl_AppendResult(interp, "The specified queue is being deleted or the system is stopping.",
                       (void *)0);
      FreeJob(jobPtr);
      ReleaseQueue(queuePtr, 1);
      Ns_MutexUnlock(& tp.queuelock);
      return (1);
    }
  }
  nextPtrPtr = & tp.firstPtr;
  while ((unsigned int )(*nextPtrPtr) != (unsigned int )((void *)0)) {
    nextPtrPtr = & ((*nextPtrPtr))->nextPtr;
  }
  (*nextPtrPtr) = jobPtr;
  if (tp.nidle == 0) {
    if (tp.nthreads < tp.maxThreads) {
      create = 1;
      tp.nthreads ++;
    } else {
      create = 0;
    }
  } else {
    create = 0;
  }
  jobId = buf;
  while (1) {
    tmp___265 = queuePtr->nextid;
    queuePtr->nextid ++;
    sprintf((char * __restrict  )jobId, (char const   * __restrict  )"job%d", tmp___265);
    hPtr = ((*(queuePtr->jobs.createProc)))(& queuePtr->jobs, jobId, & new);
    if (! (! new)) {
      break;
    }
  }
  Tcl_DStringAppend(& jobPtr->id, jobId, -1);
  hPtr->clientData = (void *)jobPtr;
  Ns_CondBroadcast(& tp.cond);
  ReleaseQueue(queuePtr, 1);
  Ns_MutexUnlock(& tp.queuelock);
  if (create) {
    Ns_ThreadCreate(& JobThread, (void *)0, 0L, (Ns_Thread *)((void *)0));
  }
  Tcl_SetResult(interp, jobId, (Tcl_FreeProc *)1);
  break;
  case 10: 
  timeoutFlag = 0;
  timedOut = 0;
  argIndex = 2;
  if (objc != 4) {
    if (objc != 6) {
      Tcl_WrongNumArgs(interp, 2, objv, (char *)"?-timeout seconds:microseconds? queueId jobId");
      return (1);
    }
  }
  if (objc > 4) {
    if (0) {
      tmp___373 = argIndex;
      argIndex ++;
      tmp___374 = Tcl_GetString((*(objv + tmp___373)));
      __s1_len___2 = strlen((char const   *)tmp___374);
      __s2_len___2 = strlen("-timeout");
      tmp___375 = argIndex;
      argIndex ++;
      tmp___376 = Tcl_GetString((*(objv + tmp___375)));
      tmp___377 = argIndex;
      argIndex ++;
      tmp___378 = Tcl_GetString((*(objv + tmp___377)));
      if ((unsigned int )((void const   *)(tmp___376 + 1)) - (unsigned int )((void const   *)tmp___378) ==
          1U) {
        if (__s1_len___2 >= 4U) {
          _L___6: 
          if (! ((unsigned int )((void const   *)("-timeout" + 1)) - (unsigned int )((void const   *)"-timeout") ==
                 1U)) {
            tmp___379 = 1;
          } else {
            if (__s2_len___2 >= 4U) {
              tmp___379 = 1;
            } else {
              tmp___379 = 0;
            }
          }
        } else {
          tmp___379 = 0;
        }
      } else {
        goto _L___6;
      }
      if (tmp___379) {
        if (__s1_len___2 < __s2_len___2) {
          tmp___325 = __s1_len___2;
        } else {
          tmp___325 = __s2_len___2;
        }
        tmp___326 = argIndex;
        argIndex ++;
        tmp___327 = Tcl_GetString((*(objv + tmp___326)));
        tmp___324 = memcmp((void const   *)((char const   *)tmp___327), (void const   *)"-timeout",
                           tmp___325 + 1U);
      } else {
        tmp___368 = argIndex;
        argIndex ++;
        tmp___369 = Tcl_GetString((*(objv + tmp___368)));
        tmp___370 = strcmp((char const   *)tmp___369, "-timeout");
        tmp___324 = tmp___370;
      }
    } else {
      tmp___368 = argIndex;
      argIndex ++;
      tmp___369 = Tcl_GetString((*(objv + tmp___368)));
      tmp___370 = strcmp((char const   *)tmp___369, "-timeout");
      tmp___324 = tmp___370;
    }
    if (tmp___324 == 0) {
      timeoutFlag = 1;
      tmp___266 = argIndex;
      argIndex ++;
      tmp___267 = Ns_TclGetTimeFromObj(interp, (*(objv + tmp___266)), & delta_timeout);
      if (tmp___267 != 0) {
        return (1);
      }
      Ns_GetTime(& timeout);
      Ns_IncrTime(& timeout, delta_timeout.sec, delta_timeout.usec);
    }
  }
  tmp___380 = argIndex;
  argIndex ++;
  tmp___381 = Tcl_GetString((*(objv + tmp___380)));
  tmp___382 = LookupQueue(interp, tmp___381, & queuePtr, 0);
  if (tmp___382 != 0) {
    return (1);
  }
  tmp___383 = argIndex;
  argIndex ++;
  jobId = Tcl_GetString((*(objv + tmp___383)));
  hPtr = ((*(queuePtr->jobs.findProc)))(& queuePtr->jobs, jobId);
  if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
    ReleaseQueue(queuePtr, 0);
    Tcl_AppendResult(interp, "no such job: ", jobId, (void *)0);
    return (1);
  }
  jobPtr = (Job *)hPtr->clientData;
  if ((int )jobPtr->type == 1) {
    tmp___384 = GetJobReqStr(jobPtr->req);
    Tcl_AppendResult(interp, "Cannot wait on job. Job ID : Job Req: %s", jobPtr->id.string,
                     tmp___384, (void *)0);
    ReleaseQueue(queuePtr, 0);
    return (1);
  } else {
    if ((int )jobPtr->req == 2) {
      tmp___384 = GetJobReqStr(jobPtr->req);
      Tcl_AppendResult(interp, "Cannot wait on job. Job ID : Job Req: %s", jobPtr->id.string,
                       tmp___384, (void *)0);
      ReleaseQueue(queuePtr, 0);
      return (1);
    } else {
      if ((int )jobPtr->req == 1) {
        tmp___384 = GetJobReqStr(jobPtr->req);
        Tcl_AppendResult(interp, "Cannot wait on job. Job ID : Job Req: %s", jobPtr->id.string,
                         tmp___384, (void *)0);
        ReleaseQueue(queuePtr, 0);
        return (1);
      }
    }
  }
  jobPtr->req = (enum JobRequests )1;
  if (timeoutFlag) {
    while ((int )jobPtr->state != 2) {
      timedOut = Ns_CondTimedWait(& queuePtr->cond, & queuePtr->lock, & timeout);
      if (timedOut == -2) {
        Tcl_SetResult(interp, (char *)"Wait timed out.", (Tcl_FreeProc *)0);
        jobPtr->req = (enum JobRequests )0;
        ReleaseQueue(queuePtr, 0);
        return (1);
      }
    }
  } else {
    while ((int )jobPtr->state != 2) {
      Ns_CondWait(& queuePtr->cond, & queuePtr->lock);
    }
  }
  hPtr = ((*(queuePtr->jobs.findProc)))(& queuePtr->jobs, jobId);
  if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
    Tcl_SetResult(interp, (char *)"Internal ns_job error.", (Tcl_FreeProc *)0);
  } else {
    if ((unsigned int )jobPtr == (unsigned int )hPtr->clientData) {
      Tcl_SetResult(interp, (char *)"Internal ns_job error.", (Tcl_FreeProc *)0);
    }
  }
  Tcl_DeleteHashEntry(hPtr);
  ReleaseQueue(queuePtr, 0);
  Tcl_DStringResult(interp, & jobPtr->results);
  if ((unsigned int )jobPtr->errorCode != (unsigned int )((void *)0)) {
    Tcl_SetVar(interp, (char *)"errorCode", jobPtr->errorCode, 1);
  }
  if ((unsigned int )jobPtr->errorInfo != (unsigned int )((void *)0)) {
    Tcl_SetVar(interp, (char *)"errorInfo", jobPtr->errorInfo, 1);
  }
  code = jobPtr->code;
  FreeJob(jobPtr);
  break;
  case 0: ;
  if (objc != 4) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"queueId jobId");
    return (1);
  }
  tmp___385 = Tcl_GetString((*(objv + 2)));
  tmp___386 = LookupQueue(interp, tmp___385, & queuePtr, 0);
  if (tmp___386 != 0) {
    return (1);
  }
  jobId = Tcl_GetString((*(objv + 3)));
  jPtr = ((*(queuePtr->jobs.findProc)))(& queuePtr->jobs, jobId);
  if ((unsigned int )jPtr == (unsigned int )((void *)0)) {
    ReleaseQueue(queuePtr, 0);
    Tcl_AppendResult(interp, "no such job: ", jobId, (void *)0);
    return (1);
  }
  jobPtr = (Job *)jPtr->clientData;
  if ((int )jobPtr->req == 1) {
    Tcl_AppendResult(interp, "Can not cancel this job because someone is waiting on it. Job ID: ",
                     jobPtr->id.string, (void *)0);
    ReleaseQueue(queuePtr, 0);
    return (1);
  }
  jobPtr->req = (enum JobRequests )2;
  if ((int )jobPtr->state == 2) {
    Tcl_DeleteHashEntry(jPtr);
    FreeJob(jobPtr);
  }
  Ns_CondBroadcast(& queuePtr->cond);
  Ns_CondBroadcast(& tp.cond);
  tmp___387 = Tcl_GetObjResult(interp);
  Tcl_SetBooleanObj(tmp___387, (int )jobPtr->state == 1);
  ReleaseQueue(queuePtr, 0);
  break;
  case 11: 
  timeoutFlag___0 = 0;
  timedOut___0 = 0;
  argIndex = 2;
  if (objc != 3) {
    if (objc != 5) {
      Tcl_WrongNumArgs(interp, 2, objv, (char *)"?-timeout seconds:microseconds? queueId");
      return (1);
    }
  }
  if (objc > 3) {
    if (0) {
      tmp___495 = argIndex;
      argIndex ++;
      tmp___496 = Tcl_GetString((*(objv + tmp___495)));
      __s1_len___3 = strlen((char const   *)tmp___496);
      __s2_len___3 = strlen("-timeout");
      tmp___497 = argIndex;
      argIndex ++;
      tmp___498 = Tcl_GetString((*(objv + tmp___497)));
      tmp___499 = argIndex;
      argIndex ++;
      tmp___500 = Tcl_GetString((*(objv + tmp___499)));
      if ((unsigned int )((void const   *)(tmp___498 + 1)) - (unsigned int )((void const   *)tmp___500) ==
          1U) {
        if (__s1_len___3 >= 4U) {
          _L___8: 
          if (! ((unsigned int )((void const   *)("-timeout" + 1)) - (unsigned int )((void const   *)"-timeout") ==
                 1U)) {
            tmp___501 = 1;
          } else {
            if (__s2_len___3 >= 4U) {
              tmp___501 = 1;
            } else {
              tmp___501 = 0;
            }
          }
        } else {
          tmp___501 = 0;
        }
      } else {
        goto _L___8;
      }
      if (tmp___501) {
        if (__s1_len___3 < __s2_len___3) {
          tmp___447 = __s1_len___3;
        } else {
          tmp___447 = __s2_len___3;
        }
        tmp___448 = argIndex;
        argIndex ++;
        tmp___449 = Tcl_GetString((*(objv + tmp___448)));
        tmp___446 = memcmp((void const   *)((char const   *)tmp___449), (void const   *)"-timeout",
                           tmp___447 + 1U);
      } else {
        tmp___490 = argIndex;
        argIndex ++;
        tmp___491 = Tcl_GetString((*(objv + tmp___490)));
        tmp___492 = strcmp((char const   *)tmp___491, "-timeout");
        tmp___446 = tmp___492;
      }
    } else {
      tmp___490 = argIndex;
      argIndex ++;
      tmp___491 = Tcl_GetString((*(objv + tmp___490)));
      tmp___492 = strcmp((char const   *)tmp___491, "-timeout");
      tmp___446 = tmp___492;
    }
    if (tmp___446 == 0) {
      timeoutFlag___0 = 1;
      tmp___388 = argIndex;
      argIndex ++;
      tmp___389 = Ns_TclGetTimeFromObj(interp, (*(objv + tmp___388)), & delta_timeout___0);
      if (tmp___389 != 0) {
        return (1);
      }
      Ns_GetTime(& timeout___0);
      Ns_IncrTime(& timeout___0, delta_timeout___0.sec, delta_timeout___0.usec);
    }
  }
  tmp___502 = argIndex;
  argIndex ++;
  tmp___503 = Tcl_GetString((*(objv + tmp___502)));
  tmp___504 = LookupQueue(interp, tmp___503, & queuePtr, 0);
  if (tmp___504 != 0) {
    return (1);
  }
  if (timeoutFlag___0) {
    while (1) {
      tmp___505 = Tcl_FirstHashEntry(& queuePtr->jobs, & search);
      if ((unsigned int )tmp___505 != (unsigned int )((void *)0)) {
        tmp___506 = AnyDone(queuePtr);
        if (tmp___506) {
          break;
        }
      } else {
        break;
      }
      timedOut___0 = Ns_CondTimedWait(& queuePtr->cond, & queuePtr->lock, & timeout___0);
      if (timedOut___0 == -2) {
        Tcl_SetResult(interp, (char *)"Wait timed out.", (Tcl_FreeProc *)0);
        ReleaseQueue(queuePtr, 0);
        return (1);
      }
    }
  } else {
    while (1) {
      tmp___507 = Tcl_FirstHashEntry(& queuePtr->jobs, & search);
      if ((unsigned int )tmp___507 != (unsigned int )((void *)0)) {
        tmp___508 = AnyDone(queuePtr);
        if (tmp___508) {
          break;
        }
      } else {
        break;
      }
      Ns_CondWait(& queuePtr->cond, & queuePtr->lock);
    }
  }
  ReleaseQueue(queuePtr, 0);
  Tcl_SetResult(interp, (char *)"", (Tcl_FreeProc *)0);
  break;
  case 4: ;
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"queueId");
    return (1);
  }
  tmp___509 = Tcl_GetString((*(objv + 2)));
  tmp___510 = LookupQueue(interp, tmp___509, & queuePtr, 0);
  if (tmp___510 != 0) {
    return (1);
  }
  hPtr = Tcl_FirstHashEntry(& queuePtr->jobs, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    if (queuePtr->jobs.keyType == 1) {
      tmp___511 = hPtr->key.oneWordValue;
    } else {
      if (queuePtr->jobs.keyType == -1) {
        tmp___511 = hPtr->key.oneWordValue;
      } else {
        tmp___511 = hPtr->key.string;
      }
    }
    jobId = tmp___511;
    Tcl_AppendElement(interp, jobId);
    hPtr = Tcl_NextHashEntry(& search);
  }
  ReleaseQueue(queuePtr, 0);
  break;
  case 8: 
  Ns_MutexLock(& tp.queuelock);
  hPtr = Tcl_FirstHashEntry(& tp.queues, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    queuePtr = (Queue___0 *)hPtr->clientData;
    Tcl_AppendElement(interp, queuePtr->name);
    hPtr = Tcl_NextHashEntry(& search);
  }
  Ns_MutexUnlock(& tp.queuelock);
  break;
  case 5: ;
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"queueId");
    return (1);
  }
  tmp___512 = Tcl_GetString((*(objv + 2)));
  tmp___513 = LookupQueue(interp, tmp___512, & queuePtr, 0);
  if (tmp___513 != 0) {
    return (1);
  }
  jobList = Tcl_NewListObj(0, (Tcl_Obj **)((void *)0));
  hPtr = Tcl_FirstHashEntry(& queuePtr->jobs, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    jobPtr = (Job *)hPtr->clientData;
    if (queuePtr->jobs.keyType == 1) {
      tmp___514 = hPtr->key.oneWordValue;
    } else {
      if (queuePtr->jobs.keyType == -1) {
        tmp___514 = hPtr->key.oneWordValue;
      } else {
        tmp___514 = hPtr->key.string;
      }
    }
    jobId___0 = tmp___514;
    jobCode = GetJobCodeStr(jobPtr->code);
    jobState = GetJobStateStr(jobPtr->state);
    jobType = GetJobTypeStr(jobPtr->type);
    jobReq = GetJobReqStr(jobPtr->req);
    jobResults = jobPtr->results.string;
    jobScript = jobPtr->script.string;
    if ((int )jobPtr->state == 0) {
      Ns_GetTime(& jobPtr->endTime);
    } else {
      if ((int )jobPtr->state == 1) {
        Ns_GetTime(& jobPtr->endTime);
      }
    }
    delta = ComputeDelta(& jobPtr->startTime, & jobPtr->endTime);
    jobFieldList = Tcl_NewListObj(0, (Tcl_Obj **)((void *)0));
    tmp___515 = AppendField(interp, jobFieldList, (char *)"id", jobId___0);
    if (tmp___515 != 0) {
      goto _L___9;
    } else {
      tmp___516 = AppendField(interp, jobFieldList, (char *)"state", jobState);
      if (tmp___516 != 0) {
        goto _L___9;
      } else {
        tmp___517 = AppendField(interp, jobFieldList, (char *)"results", jobResults);
        if (tmp___517 != 0) {
          goto _L___9;
        } else {
          tmp___518 = AppendField(interp, jobFieldList, (char *)"script", jobScript);
          if (tmp___518 != 0) {
            goto _L___9;
          } else {
            tmp___519 = AppendField(interp, jobFieldList, (char *)"code", jobCode);
            if (tmp___519 != 0) {
              goto _L___9;
            } else {
              tmp___520 = AppendField(interp, jobFieldList, (char *)"type", jobType);
              if (tmp___520 != 0) {
                goto _L___9;
              } else {
                tmp___521 = AppendField(interp, jobFieldList, (char *)"req", jobReq);
                if (tmp___521 != 0) {
                  goto _L___9;
                } else {
                  tmp___522 = AppendFieldDouble(interp, jobFieldList, (char *)"time",
                                                delta);
                  if (tmp___522 != 0) {
                    goto _L___9;
                  } else {
                    tmp___523 = AppendFieldLong(interp, jobFieldList, (char *)"starttime",
                                                jobPtr->startTime.sec);
                    if (tmp___523 != 0) {
                      goto _L___9;
                    } else {
                      tmp___524 = AppendFieldLong(interp, jobFieldList, (char *)"endtime",
                                                  jobPtr->endTime.sec);
                      if (tmp___524 != 0) {
                        _L___9: 
                        jobList->refCount = jobList->refCount - 1;
                        if (jobList->refCount <= 0) {
                          TclFreeObj(jobList);
                        }
                        jobFieldList->refCount = jobFieldList->refCount - 1;
                        if (jobFieldList->refCount <= 0) {
                          TclFreeObj(jobFieldList);
                        }
                        Ns_MutexUnlock(& queuePtr->lock);
                        return (1);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    tmp___525 = Tcl_ListObjAppendElement(interp, jobList, jobFieldList);
    if (tmp___525 != 0) {
      jobList->refCount = jobList->refCount - 1;
      if (jobList->refCount <= 0) {
        TclFreeObj(jobList);
      }
      jobFieldList->refCount = jobFieldList->refCount - 1;
      if (jobFieldList->refCount <= 0) {
        TclFreeObj(jobFieldList);
      }
      ReleaseQueue(queuePtr, 0);
      return (1);
    }
    hPtr = Tcl_NextHashEntry(& search);
  }
  Tcl_SetObjResult(interp, jobList);
  ReleaseQueue(queuePtr, 0);
  break;
  case 9: 
  queueList = Tcl_NewListObj(0, (Tcl_Obj **)((void *)0));
  Ns_MutexLock(& tp.queuelock);
  hPtr = Tcl_FirstHashEntry(& tp.queues, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    queuePtr = (Queue___0 *)hPtr->clientData;
    queueFieldList = Tcl_NewListObj(0, (Tcl_Obj **)((void *)0));
    queueReq = GetQueueReqStr(queuePtr->req);
    tmp___526 = AppendField(interp, queueFieldList, (char *)"name", queuePtr->name);
    if (tmp___526 != 0) {
      goto _L___10;
    } else {
      tmp___527 = AppendField(interp, queueFieldList, (char *)"desc", queuePtr->desc);
      if (tmp___527 != 0) {
        goto _L___10;
      } else {
        tmp___528 = AppendFieldInt(interp, queueFieldList, (char *)"maxthreads", queuePtr->maxThreads);
        if (tmp___528 != 0) {
          goto _L___10;
        } else {
          tmp___529 = AppendFieldInt(interp, queueFieldList, (char *)"numrunning",
                                     queuePtr->nRunning);
          if (tmp___529 != 0) {
            goto _L___10;
          } else {
            tmp___530 = AppendField(interp, queueFieldList, (char *)"req", queueReq);
            if (tmp___530 != 0) {
              _L___10: 
              queueList->refCount = queueList->refCount - 1;
              if (queueList->refCount <= 0) {
                TclFreeObj(queueList);
              }
              queueFieldList->refCount = queueFieldList->refCount - 1;
              if (queueFieldList->refCount <= 0) {
                TclFreeObj(queueFieldList);
              }
              Ns_MutexUnlock(& tp.queuelock);
              return (1);
            }
          }
        }
      }
    }
    tmp___531 = Tcl_ListObjAppendElement(interp, queueList, queueFieldList);
    if (tmp___531 != 0) {
      queueList->refCount = queueList->refCount - 1;
      if (queueList->refCount <= 0) {
        TclFreeObj(queueList);
      }
      queueFieldList->refCount = queueFieldList->refCount - 1;
      if (queueFieldList->refCount <= 0) {
        TclFreeObj(queueFieldList);
      }
      Ns_MutexUnlock(& tp.queuelock);
      return (1);
    }
    hPtr = Tcl_NextHashEntry(& search);
  }
  Tcl_SetObjResult(interp, queueList);
  Ns_MutexUnlock(& tp.queuelock);
  break;
  case 3: 
  Ns_GetTime(& currentTime);
  tmp___532 = tp.nextQueueId;
  tp.nextQueueId ++;
  snprintf((char * __restrict  )(buf), 100U, (char const   * __restrict  )"queue_id_%x_%x",
           tmp___532, currentTime.sec);
  Tcl_SetResult(interp, buf, (Tcl_FreeProc *)1);
  break;
  case 6: 
  tpFieldList = Tcl_NewListObj(0, (Tcl_Obj **)((void *)0));
  tpReq = GetTpReqStr(tp.req);
  Ns_MutexLock(& tp.queuelock);
  tmp___533 = AppendFieldInt(interp, tpFieldList, (char *)"maxthreads", tp.maxThreads);
  if (tmp___533 != 0) {
    goto _L___11;
  } else {
    tmp___534 = AppendFieldInt(interp, tpFieldList, (char *)"numthreads", tp.nthreads);
    if (tmp___534 != 0) {
      goto _L___11;
    } else {
      tmp___535 = AppendFieldInt(interp, tpFieldList, (char *)"numidle", tp.nidle);
      if (tmp___535 != 0) {
        goto _L___11;
      } else {
        tmp___536 = AppendField(interp, tpFieldList, (char *)"req", tpReq);
        if (tmp___536 != 0) {
          _L___11: 
          tpFieldList->refCount = tpFieldList->refCount - 1;
          if (tpFieldList->refCount <= 0) {
            TclFreeObj(tpFieldList);
          }
          Ns_MutexUnlock(& tp.queuelock);
          return (1);
        }
      }
    }
  }
  Ns_MutexUnlock(& tp.queuelock);
  Tcl_SetObjResult(interp, tpFieldList);
  break;
  }
  return (code);
}
}
static void JobThread(void *arg ) 
{ Tcl_Interp *interp ;
  Job *jobPtr ;
  char buf[100] ;
  char *err ;
  Queue___0 *queuePtr ;
  Tcl_HashEntry *jPtr ;
  int tmp ;
  char *tmp___0 ;

  {
  Ns_WaitForStartup();
  Ns_MutexLock(& tp.queuelock);
  tmp = tp.nextThreadId;
  tp.nextThreadId ++;
  snprintf((char * __restrict  )(buf), 100U, (char const   * __restrict  )"-ns_job_%x-",
           tmp);
  Ns_ThreadSetName(buf);
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"Starting thread: %s", buf);
  while (1) {
    tp.nidle ++;
    while (1) {
      jobPtr = getNextJob();
      if ((unsigned int )jobPtr == (unsigned int )((void *)0)) {
        if (! (! ((int )tp.req == 1))) {
          break;
        }
      } else {
        break;
      }
      Ns_CondWait(& tp.cond, & tp.queuelock);
    }
    tp.nidle --;
    if ((int )tp.req == 1) {
      break;
    }
    Ns_MutexUnlock(& tp.queuelock);
    interp = Ns_TclAllocateInterp(jobPtr->server);
    Ns_GetTime(& jobPtr->endTime);
    Ns_GetTime(& jobPtr->startTime);
    jobPtr->code = Tcl_EvalEx(interp, jobPtr->script.string, -1, 0);
    tmp___0 = Tcl_GetStringResult(interp);
    Tcl_DStringAppend(& jobPtr->results, tmp___0, -1);
    err = Tcl_GetVar(interp, (char *)"errorCode", 1);
    if ((unsigned int )err != (unsigned int )((void *)0)) {
      jobPtr->errorCode = ns_strdup((char const   *)err);
    }
    err = Tcl_GetVar(interp, (char *)"errorInfo", 1);
    if ((unsigned int )err != (unsigned int )((void *)0)) {
      jobPtr->errorInfo = ns_strdup((char const   *)err);
    }
    Ns_GetTime(& jobPtr->endTime);
    Ns_TclDeAllocateInterp(interp);
    Ns_MutexLock(& tp.queuelock);
    LookupQueue((Tcl_Interp *)((void *)0), jobPtr->queueId, & queuePtr, 1);
    queuePtr->nRunning --;
    jobPtr->state = (enum JobStates )2;
    if ((int )jobPtr->req == 2) {
      jPtr = ((*(queuePtr->jobs.findProc)))(& queuePtr->jobs, jobPtr->id.string);
      Tcl_DeleteHashEntry(jPtr);
      FreeJob(jobPtr);
    } else {
      if ((int )jobPtr->type == 1) {
        jPtr = ((*(queuePtr->jobs.findProc)))(& queuePtr->jobs, jobPtr->id.string);
        Tcl_DeleteHashEntry(jPtr);
        FreeJob(jobPtr);
      }
    }
    Ns_CondBroadcast(& queuePtr->cond);
    ReleaseQueue(queuePtr, 1);
  }
  tp.nthreads --;
  Ns_CondBroadcast(& tp.cond);
  Ns_MutexUnlock(& tp.queuelock);
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"exiting");
  return;
}
}
static Job *getNextJob(void) 
{ Queue___0 *queuePtr ;
  Tcl_HashEntry *jPtr ;
  Job *prev ;
  Job *tmp ;
  Job *jobPtr ;
  int done ;

  {
  prev = (Job *)((void *)0);
  tmp = (Job *)((void *)0);
  jobPtr = (Job *)((void *)0);
  done = 0;
  jobPtr = tp.firstPtr;
  prev = tp.firstPtr;
  while (1) {
    if (! done) {
      if (! ((unsigned int )jobPtr != (unsigned int )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    LookupQueue((Tcl_Interp *)((void *)0), jobPtr->queueId, & queuePtr, 1);
    if ((int )jobPtr->req == 2) {
      tmp = jobPtr;
      if ((unsigned int )jobPtr == (unsigned int )tp.firstPtr) {
        tp.firstPtr = jobPtr->nextPtr;
      } else {
        prev->nextPtr = jobPtr->nextPtr;
      }
      jobPtr = jobPtr->nextPtr;
      jPtr = ((*(queuePtr->jobs.findProc)))(& queuePtr->jobs, tmp->id.string);
      Tcl_DeleteHashEntry(jPtr);
      FreeJob(tmp);
    } else {
      if (queuePtr->nRunning < queuePtr->maxThreads) {
        if ((unsigned int )jobPtr == (unsigned int )tp.firstPtr) {
          tp.firstPtr = jobPtr->nextPtr;
        } else {
          prev->nextPtr = jobPtr->nextPtr;
        }
        done = 1;
        jobPtr->state = (enum JobStates )1;
        queuePtr->nRunning ++;
      } else {
        prev = jobPtr;
        jobPtr = jobPtr->nextPtr;
      }
    }
    ReleaseQueue(queuePtr, 1);
  }
  return (jobPtr);
}
}
Queue___0 *NewQueue(char *queueName , char *queueDesc , int maxThreads ) 
{ Queue___0 *queuePtr ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  queuePtr = (Queue___0 *)((void *)0);
  queuePtr = (Queue___0 *)ns_calloc(1U, sizeof(Queue___0 ));
  queuePtr->req = (enum QueueRequests )0;
  tmp = strlen((char const   *)queueName);
  queuePtr->name = (char *)ns_calloc(1U, tmp + 1U);
  strcpy((char * __restrict  )queuePtr->name, (char const   * __restrict  )queueName);
  tmp___0 = strlen((char const   *)queueDesc);
  queuePtr->desc = (char *)ns_calloc(1U, tmp___0 + 1U);
  strcpy((char * __restrict  )queuePtr->desc, (char const   * __restrict  )queueDesc);
  queuePtr->maxThreads = maxThreads;
  queuePtr->refCount = 0;
  Ns_MutexSetName2(& queuePtr->lock, (char *)"tcljob", queueName);
  Tcl_InitHashTable(& queuePtr->jobs, 0);
  tp.maxThreads += maxThreads;
  return (queuePtr);
}
}
void FreeQueue(Queue___0 *queuePtr ) 
{ 

  {
  Ns_MutexDestroy(& queuePtr->lock);
  Tcl_DeleteHashTable(& queuePtr->jobs);
  ns_free((void *)queuePtr->desc);
  ns_free((void *)queuePtr->name);
  ns_free((void *)queuePtr);
  return;
}
}
Job *NewJob(char *server , char *queueId , int type , Tcl_Obj *script ) 
{ Job *jobPtr ;
  size_t tmp ;
  char *tmp___0 ;

  {
  jobPtr = (Job *)((void *)0);
  jobPtr = (Job *)ns_malloc(sizeof(Job ));
  jobPtr->nextPtr = (struct Job *)((void *)0);
  jobPtr->server = server;
  jobPtr->state = (enum JobStates )0;
  jobPtr->code = 0;
  jobPtr->type = (enum JobTypes )type;
  jobPtr->req = (enum JobRequests )0;
  jobPtr->errorInfo = (char *)((void *)0);
  jobPtr->errorCode = jobPtr->errorInfo;
  tmp = strlen((char const   *)queueId);
  jobPtr->queueId = (char *)ns_calloc(1U, tmp + 1U);
  strcpy((char * __restrict  )jobPtr->queueId, (char const   * __restrict  )queueId);
  Tcl_DStringInit(& jobPtr->id);
  Tcl_DStringInit(& jobPtr->script);
  tmp___0 = Tcl_GetString(script);
  Tcl_DStringAppend(& jobPtr->script, tmp___0, -1);
  Tcl_DStringInit(& jobPtr->results);
  return (jobPtr);
}
}
void FreeJob(Job *jobPtr ) 
{ 

  {
  Tcl_DStringFree(& jobPtr->results);
  Tcl_DStringFree(& jobPtr->script);
  Tcl_DStringFree(& jobPtr->id);
  ns_free((void *)jobPtr->queueId);
  if (jobPtr->errorCode) {
    ns_free((void *)jobPtr->errorCode);
  }
  if (jobPtr->errorInfo) {
    ns_free((void *)jobPtr->errorInfo);
  }
  ns_free((void *)jobPtr);
  return;
}
}
static int LookupQueue(Tcl_Interp *interp , char *queueId , Queue___0 **queuePtr ,
                       int locked ) 
{ Tcl_HashEntry *hPtr ;

  {
  if (! locked) {
    Ns_MutexLock(& tp.queuelock);
  }
  (*queuePtr) = (Queue___0 *)((void *)0);
  hPtr = ((*(tp.queues.findProc)))(& tp.queues, queueId);
  if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    (*queuePtr) = (Queue___0 *)hPtr->clientData;
    Ns_MutexLock(& ((*queuePtr))->lock);
    ((*queuePtr))->refCount ++;
  }
  if (! locked) {
    Ns_MutexUnlock(& tp.queuelock);
  }
  if ((unsigned int )(*queuePtr) == (unsigned int )((void *)0)) {
    if ((unsigned int )interp != (unsigned int )((void *)0)) {
      Tcl_AppendResult(interp, "no such queue: ", queueId, (void *)0);
    }
    return (1);
  }
  return (0);
}
}
static int ReleaseQueue(Queue___0 *queuePtr , int locked ) 
{ Tcl_HashEntry *qPtr ;
  Tcl_HashSearch search ;
  int deleted ;
  Tcl_HashEntry *tmp ;

  {
  deleted = 0;
  queuePtr->refCount --;
  if ((int )queuePtr->req == 1) {
    if (queuePtr->refCount <= 0) {
      tmp = Tcl_FirstHashEntry(& queuePtr->jobs, & search);
      if ((unsigned int )tmp == (unsigned int )((void *)0)) {
        if (! locked) {
          Ns_MutexLock(& tp.queuelock);
        }
        qPtr = ((*(tp.queues.findProc)))(& tp.queues, queuePtr->name);
        if ((unsigned int )qPtr != (unsigned int )((void *)0)) {
          Tcl_DeleteHashEntry(qPtr);
          tp.maxThreads -= queuePtr->maxThreads;
          deleted = 1;
        }
        Ns_MutexUnlock(& queuePtr->lock);
        FreeQueue(queuePtr);
        if (! locked) {
          Ns_MutexUnlock(& tp.queuelock);
        }
      } else {
        Ns_MutexUnlock(& queuePtr->lock);
      }
    } else {
      Ns_MutexUnlock(& queuePtr->lock);
    }
  } else {
    Ns_MutexUnlock(& queuePtr->lock);
  }
  return (deleted);
}
}
static int AnyDone(Queue___0 *queue___1 ) 
{ Tcl_HashEntry *hPtr ;
  Job *jobPtr ;
  Tcl_HashSearch search ;

  {
  hPtr = Tcl_FirstHashEntry(& queue___1->jobs, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    jobPtr = (Job *)hPtr->clientData;
    if ((int )jobPtr->state == 2) {
      return (1);
    }
    hPtr = Tcl_NextHashEntry(& search);
  }
  return (0);
}
}
static char *codeArr[6]  = {      (char *)"TCL_OK",      (char *)"TCL_ERROR",      (char *)"TCL_RETURN",      (char *)"TCL_BREAK", 
        (char *)"TCL_CONTINUE",      (char *)"UNKNOWN_CODE"};
static int max_code_index  =    5;
static char *GetJobCodeStr(int code ) 
{ 

  {
  if (code > max_code_index) {
    code = max_code_index;
  }
  return (codeArr[code]);
}
}
static char *stateArr[4]  = {      (char *)"scheduled",      (char *)"running",      (char *)"done",      (char *)"unknown"};
static int max_state_index  =    3;
static char *GetJobStateStr(JobStates state ) 
{ 

  {
  if ((int )state > max_state_index) {
    state = (enum JobStates )max_state_index;
  }
  return (stateArr[state]);
}
}
static char *typeArr[3]  = {      (char *)"nondetached",      (char *)"detached",      (char *)"unknown"};
static int max_type_index  =    2;
static char *GetJobTypeStr(JobTypes type ) 
{ 

  {
  if ((int )type > max_type_index) {
    type = (enum JobTypes )max_type_index;
  }
  return (typeArr[type]);
}
}
static char *reqArr[4]  = {      (char *)"none",      (char *)"wait",      (char *)"cancel",      (char *)"unknown"};
static int req_max_index  =    3;
static char *GetJobReqStr(JobRequests req ) 
{ 

  {
  if ((int )req > req_max_index) {
    req = (enum JobRequests )req_max_index;
  }
  return (reqArr[req]);
}
}
static char *reqArr___0[2]  = {      (char *)"none",      (char *)"delete"};
static int req_max_index___0  =    1;
static char *GetQueueReqStr(QueueRequests req ) 
{ 

  {
  if ((int )req > req_max_index___0) {
    req = (enum QueueRequests )req_max_index___0;
  }
  return (reqArr___0[req]);
}
}
static char *reqArr___1[2]  = {      (char *)"none",      (char *)"stop"};
static int req_max_index___1  =    1;
static char *GetTpReqStr(ThreadPoolRequests req ) 
{ 

  {
  if ((int )req > req_max_index___1) {
    req = (enum ThreadPoolRequests )req_max_index___1;
  }
  return (reqArr___1[req]);
}
}
static int AppendField(Tcl_Interp *interp , Tcl_Obj *list , char *name , char *value ) 
{ size_t tmp ;
  Tcl_Obj *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  Tcl_Obj *tmp___3 ;
  int tmp___4 ;

  {
  tmp = strlen((char const   *)name);
  tmp___0 = Tcl_NewStringObj(name, (int )tmp);
  tmp___1 = Tcl_ListObjAppendElement(interp, list, tmp___0);
  if (tmp___1 == 1) {
    return (1);
  }
  tmp___2 = strlen((char const   *)value);
  tmp___3 = Tcl_NewStringObj(value, (int )tmp___2);
  tmp___4 = Tcl_ListObjAppendElement(interp, list, tmp___3);
  if (tmp___4 == 1) {
    return (1);
  }
  return (0);
}
}
static int AppendFieldInt(Tcl_Interp *interp , Tcl_Obj *list , char *name , int value ) 
{ size_t tmp ;
  Tcl_Obj *tmp___0 ;
  int tmp___1 ;
  Tcl_Obj *tmp___2 ;
  int tmp___3 ;

  {
  tmp = strlen((char const   *)name);
  tmp___0 = Tcl_NewStringObj(name, (int )tmp);
  tmp___1 = Tcl_ListObjAppendElement(interp, list, tmp___0);
  if (tmp___1 == 1) {
    return (1);
  }
  tmp___2 = Tcl_NewIntObj(value);
  tmp___3 = Tcl_ListObjAppendElement(interp, list, tmp___2);
  if (tmp___3 == 1) {
    return (1);
  }
  return (0);
}
}
static int AppendFieldLong(Tcl_Interp *interp , Tcl_Obj *list , char *name , long value ) 
{ size_t tmp ;
  Tcl_Obj *tmp___0 ;
  int tmp___1 ;
  Tcl_Obj *tmp___2 ;
  int tmp___3 ;

  {
  tmp = strlen((char const   *)name);
  tmp___0 = Tcl_NewStringObj(name, (int )tmp);
  tmp___1 = Tcl_ListObjAppendElement(interp, list, tmp___0);
  if (tmp___1 == 1) {
    return (1);
  }
  tmp___2 = Tcl_NewLongObj(value);
  tmp___3 = Tcl_ListObjAppendElement(interp, list, tmp___2);
  if (tmp___3 == 1) {
    return (1);
  }
  return (0);
}
}
static int AppendFieldDouble(Tcl_Interp *interp , Tcl_Obj *list , char *name , double value ) 
{ size_t tmp ;
  Tcl_Obj *tmp___0 ;
  int tmp___1 ;
  Tcl_Obj *tmp___2 ;
  int tmp___3 ;

  {
  tmp = strlen((char const   *)name);
  tmp___0 = Tcl_NewStringObj(name, (int )tmp);
  tmp___1 = Tcl_ListObjAppendElement(interp, list, tmp___0);
  if (tmp___1 == 1) {
    return (1);
  }
  tmp___2 = Tcl_NewDoubleObj(value);
  tmp___3 = Tcl_ListObjAppendElement(interp, list, tmp___2);
  if (tmp___3 == 1) {
    return (1);
  }
  return (0);
}
}
static double ComputeDelta(Ns_Time *start , Ns_Time *end ) 
{ Ns_Time diff ;

  {
  Ns_DiffTime(end, start, & diff);
  return ((double )diff.sec * 1000.0 + (double )diff.usec / 1000.0);
}
}
extern void Tcl_Sleep(int ms ) ;
extern int Tcl_GetLongFromObj(Tcl_Interp *interp , Tcl_Obj *objPtr , long *longPtr ) ;
void Ns_AdjTime(Ns_Time *timePtr ) ;
int Ns_HtuuEncode(unsigned char *input , unsigned int len , char *output ) ;
static int WordEndsInSemi(char *ip ) ;
int NsTclStripHtmlCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) 
{ int intag ;
  int intspec ;
  char *inString ;
  char *inPtr ;
  char *outPtr ;
  char *tmp ;

  {
  if (argc != 2) {
    Tcl_AppendResult(interp, "wrong # of args:  should be \"", (*(argv + 0)), " page\"",
                     (void *)0);
    return (1);
  }
  inString = ns_strdup((char const   *)(*(argv + 1)));
  inPtr = inString;
  outPtr = inString;
  intag = 0;
  intspec = 0;
  while ((int )(*inPtr) != 0) {
    if ((int )(*inPtr) == 60) {
      intag = 1;
    } else {
      if (intag) {
        if ((int )(*inPtr) == 62) {
          intag = 0;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
        if (intspec) {
          if ((int )(*inPtr) == 59) {
            intspec = 0;
          } else {
            goto _L;
          }
        } else {
          _L: 
          if (! intag) {
            if (! intspec) {
              if ((int )(*inPtr) == 38) {
                intspec = WordEndsInSemi(inPtr);
              }
              if (! intspec) {
                tmp = outPtr;
                outPtr ++;
                (*tmp) = (*inPtr);
              }
            }
          }
        }
      }
    }
    inPtr ++;
  }
  (*outPtr) = (char )'\000';
  Tcl_SetResult(interp, inString, (Tcl_FreeProc *)1);
  ns_free((void *)inString);
  return (0);
}
}
int NsTclCryptObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ char buf[16] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"key salt");
    return (1);
  }
  tmp = Tcl_GetString((*(objv + 2)));
  tmp___0 = Tcl_GetString((*(objv + 1)));
  tmp___1 = Ns_Encrypt(tmp___0, tmp, buf);
  Tcl_SetResult(interp, tmp___1, (Tcl_FreeProc *)1);
  return (0);
}
}
int NsTclHrefsCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) 
{ char *p ;
  char *s ;
  char *e___1 ;
  char *he ;
  char save ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *tmp___7 ;
  char *tmp___9 ;
  char *tmp___11 ;

  {
  if (argc != 2) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " html\"",
                     (char *)((void *)0));
    return (1);
  }
  p = (*(argv + 1));
  while (1) {
    tmp___9 = strchr((char const   *)p, '<');
    s = tmp___9;
    if (s) {
      tmp___11 = strchr((char const   *)s, '>');
      e___1 = tmp___11;
      if (! e___1) {
        break;
      }
    } else {
      break;
    }
    s ++;
    (*e___1) = (char )'\000';
    while (1) {
      if ((*s)) {
        tmp = __ctype_b_loc();
        if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*s)))) & 8192)) {
          break;
        }
      } else {
        break;
      }
      s ++;
    }
    if ((int )(*s) == 97) {
      goto _L___0;
    } else {
      if ((int )(*s) == 65) {
        _L___0: 
        tmp___6 = __ctype_b_loc();
        if ((int const   )(*((*tmp___6) + (int )((unsigned char )(*(s + 1))))) & 8192) {
          s ++;
          while ((*s)) {
            tmp___5 = strncasecmp((char const   *)s, "href", 4U);
            if (! tmp___5) {
              s += 4;
              while (1) {
                if ((*s)) {
                  tmp___0 = __ctype_b_loc();
                  if (! ((int const   )(*((*tmp___0) + (int )((unsigned char )(*s)))) &
                         8192)) {
                    break;
                  }
                } else {
                  break;
                }
                s ++;
              }
              if ((int )(*s) == 61) {
                s ++;
                while (1) {
                  if ((*s)) {
                    tmp___1 = __ctype_b_loc();
                    if (! ((int const   )(*((*tmp___1) + (int )((unsigned char )(*s)))) &
                           8192)) {
                      break;
                    }
                  } else {
                    break;
                  }
                  s ++;
                }
                he = (char *)((void *)0);
                if ((int )(*s) == 39) {
                  tmp___3 = strchr((char const   *)(s + 1), (int )(*s));
                  he = tmp___3;
                  s ++;
                } else {
                  if ((int )(*s) == 34) {
                    tmp___3 = strchr((char const   *)(s + 1), (int )(*s));
                    he = tmp___3;
                    s ++;
                  }
                }
                if ((unsigned int )he == (unsigned int )((void *)0)) {
                  he = s;
                  while (1) {
                    tmp___4 = __ctype_b_loc();
                    if ((int const   )(*((*tmp___4) + (int )((unsigned char )(*he)))) &
                        8192) {
                      break;
                    }
                    he ++;
                  }
                }
                save = (*he);
                (*he) = (char )'\000';
                Tcl_AppendElement(interp, s);
                (*he) = save;
                break;
              }
            }
            if ((int )(*s) == 39) {
              goto _L;
            } else {
              if ((int )(*s) == 34) {
                _L: 
                while (1) {
                  if ((*s)) {
                    if (! ((int )(*s) != 39)) {
                      if (! ((int )(*s) != 34)) {
                        break;
                      }
                    }
                  } else {
                    break;
                  }
                  s ++;
                }
                continue;
              }
            }
            s ++;
          }
        }
      }
    }
    tmp___7 = e___1;
    e___1 ++;
    (*tmp___7) = (char )'>';
    p = e___1;
  }
  return (0);
}
}
static int TmObjCmd(ClientData isgmt , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ time_t now ;
  struct tm *ptm ;
  Tcl_Obj *objPtr[9] ;
  Tcl_Obj *tmp ;

  {
  if (objc != 1) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"");
    return (1);
  }
  now = time((time_t *)((void *)0));
  if (isgmt) {
    ptm = ns_gmtime((time_t const   *)(& now));
  } else {
    ptm = ns_localtime((time_t const   *)(& now));
  }
  objPtr[0] = Tcl_NewIntObj(ptm->tm_sec);
  objPtr[1] = Tcl_NewIntObj(ptm->tm_min);
  objPtr[2] = Tcl_NewIntObj(ptm->tm_hour);
  objPtr[3] = Tcl_NewIntObj(ptm->tm_mday);
  objPtr[4] = Tcl_NewIntObj(ptm->tm_mon);
  objPtr[5] = Tcl_NewIntObj(ptm->tm_year);
  objPtr[6] = Tcl_NewIntObj(ptm->tm_wday);
  objPtr[7] = Tcl_NewIntObj(ptm->tm_yday);
  objPtr[8] = Tcl_NewIntObj(ptm->tm_isdst);
  tmp = Tcl_GetObjResult(interp);
  Tcl_SetListObj(tmp, 9, objPtr);
  return (0);
}
}
int NsTclGmTimeObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = TmObjCmd((void *)1, interp, objc, objv);
  return (tmp);
}
}
int NsTclLocalTimeObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = TmObjCmd((void *)0, interp, objc, objv);
  return (tmp);
}
}
int NsTclSleepObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Ns_Time time___0 ;
  int ms ;
  int tmp ;
  char *tmp___0 ;

  {
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"timespec");
    return (1);
  }
  tmp = Ns_TclGetTimeFromObj(interp, (*(objv + 1)), & time___0);
  if (tmp != 0) {
    return (1);
  }
  Ns_AdjTime(& time___0);
  if (time___0.sec < 0L) {
    tmp___0 = Tcl_GetString((*(objv + 1)));
    Tcl_AppendResult(interp, "invalid timespec: ", tmp___0, (void *)0);
    return (1);
  } else {
    if (time___0.sec == 0L) {
      if (time___0.usec < 0L) {
        tmp___0 = Tcl_GetString((*(objv + 1)));
        Tcl_AppendResult(interp, "invalid timespec: ", tmp___0, (void *)0);
        return (1);
      }
    }
  }
  ms = (int )(time___0.sec * 1000L + time___0.usec / 1000L);
  Tcl_Sleep(ms);
  return (0);
}
}
int NsTclHTUUEncodeObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ char bufcoded[97] ;
  char *string ;
  int nbytes ;
  Tcl_Obj *tmp ;

  {
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"string");
    return (1);
  }
  string = Tcl_GetStringFromObj((*(objv + 1)), & nbytes);
  if (nbytes > 48) {
    tmp = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp, "invalid string \"", string, "\": must be less than 48 characters",
                           (void *)0);
    return (1);
  }
  Ns_HtuuEncode((unsigned char *)string, (unsigned int )nbytes, bufcoded);
  Tcl_SetResult(interp, bufcoded, (Tcl_FreeProc *)1);
  return (0);
}
}
int NsTclHTUUDecodeObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int n ;
  char *string ;
  char *decoded ;

  {
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"string");
    return (1);
  }
  string = Tcl_GetStringFromObj((*(objv + 1)), & n);
  n += 3;
  decoded = (char *)ns_malloc((unsigned int )n);
  n = Ns_HtuuDecode(string, (unsigned char *)decoded, n);
  (*(decoded + n)) = (char )'\000';
  Tcl_SetResult(interp, decoded, (Tcl_FreeProc *)(& ns_free));
  return (0);
}
}
static char *opts___7[8]  = 
  {      (char *)"adjust",      (char *)"diff",      (char *)"get",      (char *)"incr", 
        (char *)"make",      (char *)"seconds",      (char *)"microseconds",      (char *)((void *)0)};
int NsTclTimeObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Ns_Time result ;
  Ns_Time t1 ;
  Ns_Time t2 ;
  enum __anonenum_opt_107___4 opt ;
  time_t tmp ;
  Tcl_Obj *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  time_t tmp___11 ;
  Tcl_Obj *tmp___12 ;
  Tcl_Obj *tmp___13 ;

  {
  if (objc < 2) {
    tmp = time((time_t *)((void *)0));
    tmp___0 = Tcl_GetObjResult(interp);
    Tcl_SetLongObj(tmp___0, tmp);
  } else {
    tmp___1 = Tcl_GetIndexFromObj(interp, (*(objv + 1)), opts___7, (char *)"option",
                                  0, (int *)(& opt));
    if (tmp___1 != 0) {
      return (1);
    }
    switch ((int )opt) {
    case 2: 
    Ns_GetTime(& result);
    break;
    case 4: ;
    if (objc != 3) {
      if (objc != 4) {
        Tcl_WrongNumArgs(interp, 2, objv, (char *)"sec ?usec?");
        return (1);
      }
    }
    tmp___2 = Tcl_GetLongFromObj(interp, (*(objv + 2)), & result.sec);
    if (tmp___2 != 0) {
      return (1);
    }
    if (objc == 3) {
      result.usec = 0L;
    } else {
      tmp___3 = Tcl_GetLongFromObj(interp, (*(objv + 3)), & result.usec);
      if (tmp___3 != 0) {
        return (1);
      }
    }
    break;
    case 3: ;
    if (objc != 4) {
      if (objc != 5) {
        Tcl_WrongNumArgs(interp, 2, objv, (char *)"time sec ?usec?");
        return (1);
      }
    }
    tmp___4 = Ns_TclGetTimeFromObj(interp, (*(objv + 2)), & result);
    if (tmp___4 != 0) {
      return (1);
    } else {
      tmp___5 = Tcl_GetLongFromObj(interp, (*(objv + 3)), & t2.sec);
      if (tmp___5 != 0) {
        return (1);
      }
    }
    if (objc == 4) {
      t2.usec = 0L;
    } else {
      tmp___6 = Tcl_GetLongFromObj(interp, (*(objv + 4)), & t2.usec);
      if (tmp___6 != 0) {
        return (1);
      }
    }
    Ns_IncrTime(& result, t2.sec, t2.usec);
    break;
    case 1: ;
    if (objc != 4) {
      Tcl_WrongNumArgs(interp, 2, objv, (char *)"time1 time2");
      return (1);
    }
    tmp___7 = Ns_TclGetTimeFromObj(interp, (*(objv + 2)), & t1);
    if (tmp___7 != 0) {
      return (1);
    } else {
      tmp___8 = Ns_TclGetTimeFromObj(interp, (*(objv + 3)), & t2);
      if (tmp___8 != 0) {
        return (1);
      }
    }
    Ns_DiffTime(& t1, & t2, & result);
    break;
    case 0: ;
    if (objc != 3) {
      Tcl_WrongNumArgs(interp, 2, objv, (char *)"time");
      return (1);
    }
    tmp___9 = Ns_TclGetTimeFromObj(interp, (*(objv + 2)), & result);
    if (tmp___9 != 0) {
      return (1);
    }
    Ns_AdjTime(& result);
    break;
    case 5: ;
    case 6: ;
    if (objc != 3) {
      Tcl_WrongNumArgs(interp, 2, objv, (char *)"time");
      return (1);
    }
    tmp___10 = Ns_TclGetTimeFromObj(interp, (*(objv + 2)), & result);
    if (tmp___10 != 0) {
      return (1);
    }
    if ((int )opt == 5) {
      tmp___11 = result.sec;
    } else {
      tmp___11 = result.usec;
    }
    tmp___12 = Tcl_GetObjResult(interp);
    Tcl_SetLongObj(tmp___12, tmp___11);
    return (0);
    break;
    }
    tmp___13 = Tcl_GetObjResult(interp);
    Ns_TclSetTimeObj(tmp___13, & result);
  }
  return (0);
}
}
int NsTclStrftimeObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ char *fmt ;
  char buf[200] ;
  time_t time___0 ;
  int tmp ;
  char *tmp___0 ;
  Tcl_Obj *tmp___1 ;
  struct tm *tmp___2 ;
  size_t tmp___3 ;

  {
  if (objc != 2) {
    if (objc != 3) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"time ?fmt?");
      return (1);
    }
  }
  tmp = Tcl_GetLongFromObj(interp, (*(objv + 1)), & time___0);
  if (tmp != 0) {
    return (1);
  }
  if (objc > 2) {
    fmt = Tcl_GetString((*(objv + 2)));
  } else {
    fmt = (char *)"%c";
  }
  tmp___2 = ns_localtime((time_t const   *)(& time___0));
  tmp___3 = strftime((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )fmt,
                     (struct tm  const  * __restrict  )tmp___2);
  if (tmp___3 == 0U) {
    tmp___0 = Tcl_GetString((*(objv + 1)));
    tmp___1 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___1, "invalid time: ", tmp___0, (void *)0);
    return (1);
  }
  Tcl_SetResult(interp, buf, (Tcl_FreeProc *)1);
  return (0);
}
}
int NsTclCrashCmd(ClientData dummy , Tcl_Interp *interp , int argc , char **argv ) 
{ char *death ;

  {
  death = (char *)((void *)0);
  (*death) = (char)1;
  return (1);
}
}
static int WordEndsInSemi(char *ip ) 
{ 

  {
  if ((unsigned int )ip == (unsigned int )((void *)0)) {
    return (0);
  }
  if ((int )(*ip) == 38) {
    ip ++;
  }
  while (1) {
    if ((int )(*ip) != 0) {
      if ((int )(*ip) != 32) {
        if ((int )(*ip) != 59) {
          if (! ((int )(*ip) != 38)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    ip ++;
  }
  if ((int )(*ip) == 59) {
    return (1);
  } else {
    return (0);
  }
}
}
extern void Tcl_Panic(char *format  , ...) ;
extern char *Tcl_Alloc(unsigned int size ) ;
extern int Tcl_ConvertToType(Tcl_Interp *interp , Tcl_Obj *objPtr , Tcl_ObjType *typePtr ) ;
extern Tcl_ObjType *Tcl_GetObjType(char *typeName ) ;
extern void Tcl_InvalidateStringRep(Tcl_Obj *objPtr ) ;
extern void Tcl_RegisterObjType(Tcl_ObjType *typePtr ) ;
static void SetTimeInternalRep(Tcl_Obj *objPtr , Ns_Time *timePtr ) ;
static int SetTimeFromAny(Tcl_Interp *interp , Tcl_Obj *objPtr ) ;
static void UpdateStringOfTime(Tcl_Obj *objPtr ) ;
static struct Tcl_ObjType timeType  =    {(char *)"ns:time", (Tcl_FreeInternalRepProc *)((void *)0), (Tcl_DupInternalRepProc *)((void *)0),
    & UpdateStringOfTime, & SetTimeFromAny};
static Tcl_ObjType *intTypePtr  ;
void NsTclInitTimeType(void) 
{ Tcl_Obj obj ;

  {
  if (sizeof(obj.internalRep) < sizeof(Ns_Time )) {
    Tcl_Panic((char *)"NsTclInitObjs: sizeof(obj.internalRep) < sizeof(Ns_Time)");
  }
  if (sizeof(int ) < sizeof(long )) {
    Tcl_Panic((char *)"NsTclInitObjs: sizeof(int) < sizeof(long)");
  }
  intTypePtr = Tcl_GetObjType((char *)"int");
  if ((unsigned int )intTypePtr == (unsigned int )((void *)0)) {
    Tcl_Panic((char *)"NsTclInitObjs: no int type");
  }
  Tcl_RegisterObjType(& timeType);
  return;
}
}
void Ns_TclSetTimeObj(Tcl_Obj *objPtr , Ns_Time *timePtr ) 
{ 

  {
  Tcl_InvalidateStringRep(objPtr);
  SetTimeInternalRep(objPtr, timePtr);
  return;
}
}
int Ns_TclGetTimeFromObj(Tcl_Interp *interp , Tcl_Obj *objPtr , Ns_Time *timePtr ) 
{ int tmp ;
  int tmp___0 ;

  {
  if ((unsigned int )objPtr->typePtr == (unsigned int )intTypePtr) {
    tmp = Tcl_GetLongFromObj(interp, objPtr, & timePtr->sec);
    if (tmp != 0) {
      return (1);
    }
    timePtr->usec = 0L;
  } else {
    tmp___0 = Tcl_ConvertToType(interp, objPtr, & timeType);
    if (tmp___0 != 0) {
      return (1);
    }
    (*timePtr) = (*((Ns_Time *)(& objPtr->internalRep)));
  }
  return (0);
}
}
static void UpdateStringOfTime(Tcl_Obj *objPtr ) 
{ Ns_Time *timePtr ;
  size_t len ;
  char buf[100] ;

  {
  timePtr = (Ns_Time *)(& objPtr->internalRep);
  Ns_AdjTime(timePtr);
  if (timePtr->usec == 0L) {
    len = (size_t )sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%ld",
                           timePtr->sec);
  } else {
    len = (size_t )sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%ld:%ld",
                           timePtr->sec, timePtr->usec);
  }
  objPtr->length = (int )len;
  objPtr->bytes = Tcl_Alloc(len + 1U);
  memcpy((void * __restrict  )objPtr->bytes, (void const   * __restrict  )(buf), len +
                                                                                 1U);
  return;
}
}
static int SetTimeFromAny(Tcl_Interp *interp , Tcl_Obj *objPtr ) 
{ char *str ;
  char *sep ;
  Ns_Time time___0 ;
  int result ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  str = Tcl_GetString(objPtr);
  tmp___0 = strchr((char const   *)str, ':');
  sep = tmp___0;
  if ((unsigned int )objPtr->typePtr == (unsigned int )intTypePtr) {
    goto _L;
  } else {
    if ((unsigned int )sep == (unsigned int )((void *)0)) {
      _L: 
      tmp___1 = Tcl_GetLongFromObj(interp, objPtr, & time___0.sec);
      if (tmp___1 != 0) {
        return (1);
      }
      time___0.usec = 0L;
    } else {
      (*sep) = (char )'\000';
      result = Tcl_GetInt(interp, str, (int *)(& time___0.sec));
      (*sep) = (char )':';
      if (result != 0) {
        return (1);
      }
      tmp___2 = Tcl_GetInt(interp, sep + 1, (int *)(& time___0.usec));
      if (tmp___2 != 0) {
        return (1);
      }
    }
  }
  Ns_AdjTime(& time___0);
  SetTimeInternalRep(objPtr, & time___0);
  return (0);
}
}
static void SetTimeInternalRep(Tcl_Obj *objPtr , Ns_Time *timePtr ) 
{ Tcl_ObjType *typePtr ;

  {
  typePtr = objPtr->typePtr;
  if ((unsigned int )typePtr != (unsigned int )((void *)0)) {
    if ((unsigned int )typePtr->freeIntRepProc != (unsigned int )((void *)0)) {
      ((*(typePtr->freeIntRepProc)))(objPtr);
    }
  }
  objPtr->typePtr = & timeType;
  (*((Ns_Time *)(& objPtr->internalRep))) = (*timePtr);
  Tcl_InvalidateStringRep(objPtr);
  objPtr->length = 0;
  return;
}
}
extern int Tcl_ListObjGetElements(Tcl_Interp *interp , Tcl_Obj *listPtr , int *objcPtr ,
                                  Tcl_Obj ***objvPtr ) ;
extern void Tcl_AllowExceptions(Tcl_Interp *interp ) ;
static int ProcRequest(void *arg , Ns_Conn *conn ) ;
static int AdpRequest(void *arg , Ns_Conn *conn ) ;
static int ProcFilter(void *arg , Ns_Conn *conn , int why ) ;
static Proc *NewProc(char *name , char *args ) ;
static void FreeProc(void *arg ) ;
static void AppendConnId(Tcl_DString *dsPtr , Ns_Conn *conn ) ;
static void RegisterFilterObj(NsInterp *itPtr , int when , int objc , Tcl_Obj **objv ) ;
static int GetNumArgs(Tcl_Interp *interp , Proc *procPtr ) ;
int Ns_TclRequest(Ns_Conn *conn , char *name ) 
{ Proc proc ;
  int tmp ;

  {
  proc.name = name;
  proc.args = (char *)((void *)0);
  proc.nargs = 0;
  tmp = ProcRequest((void *)(& proc), conn);
  return (tmp);
}
}
int NsTclRegisterProcObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int flags ;
  int idx ;
  Proc *procPtr ;
  NsInterp *itPtr ;
  char *server ;
  char *method ;
  char *url ;
  char *name ;
  char *args ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___30 ;
  size_t tmp___31 ;
  char *tmp___32 ;
  char *tmp___53 ;
  int tmp___54 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc < 4) {
    goto badargs;
  } else {
    if (objc > 7) {
      badargs: 
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-noinherit? method url proc ?args?");
      return (1);
    }
  }
  tmp = Tcl_GetString((*(objv + 1)));
  if ((int )(*tmp) == (int )(*"-noinherit")) {
    if (0) {
      tmp___56 = Tcl_GetString((*(objv + 1)));
      __s1_len = strlen((char const   *)tmp___56);
      __s2_len = strlen("-noinherit");
      tmp___57 = Tcl_GetString((*(objv + 1)));
      tmp___58 = Tcl_GetString((*(objv + 1)));
      if ((unsigned int )((void const   *)(tmp___57 + 1)) - (unsigned int )((void const   *)tmp___58) ==
          1U) {
        if (__s1_len >= 4U) {
          _L___1: 
          if (! ((unsigned int )((void const   *)("-noinherit" + 1)) - (unsigned int )((void const   *)"-noinherit") ==
                 1U)) {
            tmp___59 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___59 = 1;
            } else {
              tmp___59 = 0;
            }
          }
        } else {
          tmp___59 = 0;
        }
      } else {
        goto _L___1;
      }
      if (tmp___59) {
        if (__s1_len < __s2_len) {
          tmp___31 = __s1_len;
        } else {
          tmp___31 = __s2_len;
        }
        tmp___32 = Tcl_GetString((*(objv + 1)));
        tmp___30 = memcmp((void const   *)((char const   *)tmp___32), (void const   *)"-noinherit",
                          tmp___31 + 1U);
      } else {
        tmp___53 = Tcl_GetString((*(objv + 1)));
        tmp___54 = strcmp((char const   *)tmp___53, "-noinherit");
        tmp___30 = tmp___54;
      }
    } else {
      tmp___53 = Tcl_GetString((*(objv + 1)));
      tmp___54 = strcmp((char const   *)tmp___53, "-noinherit");
      tmp___30 = tmp___54;
    }
    if (tmp___30 == 0) {
      if (objc < 5) {
        goto badargs;
      }
      flags = 2;
      idx = 2;
    } else {
      goto _L___2;
    }
  } else {
    _L___2: 
    if (objc == 7) {
      goto badargs;
    }
    flags = 0;
    idx = 1;
  }
  server = (itPtr->servPtr)->server;
  tmp___60 = idx;
  idx ++;
  method = Tcl_GetString((*(objv + tmp___60)));
  tmp___61 = idx;
  idx ++;
  url = Tcl_GetString((*(objv + tmp___61)));
  tmp___62 = idx;
  idx ++;
  name = Tcl_GetString((*(objv + tmp___62)));
  if (idx < objc) {
    args = Tcl_GetString((*(objv + idx)));
  } else {
    args = (char *)((void *)0);
  }
  procPtr = NewProc(name, args);
  Ns_RegisterRequest(server, method, url, & ProcRequest, & FreeProc, (void *)procPtr,
                     flags);
  return (0);
}
}
int NsTclRegisterAdpObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  char *server ;
  char *method ;
  char *url ;
  char *file___1 ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___30 ;
  size_t tmp___31 ;
  char *tmp___32 ;
  char *tmp___53 ;
  int tmp___54 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  int tmp___59 ;
  char *tmp___60 ;
  int tmp___61 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 4) {
    if (objc != 5) {
      badargs: 
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-noinherit? method url file");
      return (1);
    }
  }
  if (objc == 5) {
    tmp = Tcl_GetString((*(objv + 1)));
    if ((int )(*tmp) == (int )(*"-noinherit")) {
      if (0) {
        tmp___56 = Tcl_GetString((*(objv + 1)));
        __s1_len = strlen((char const   *)tmp___56);
        __s2_len = strlen("-noinherit");
        tmp___57 = Tcl_GetString((*(objv + 1)));
        tmp___58 = Tcl_GetString((*(objv + 1)));
        if ((unsigned int )((void const   *)(tmp___57 + 1)) - (unsigned int )((void const   *)tmp___58) ==
            1U) {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("-noinherit" + 1)) - (unsigned int )((void const   *)"-noinherit") ==
                   1U)) {
              tmp___59 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___59 = 1;
              } else {
                tmp___59 = 0;
              }
            }
          } else {
            tmp___59 = 0;
          }
        } else {
          goto _L___0;
        }
        if (tmp___59) {
          if (__s1_len < __s2_len) {
            tmp___31 = __s1_len;
          } else {
            tmp___31 = __s2_len;
          }
          tmp___32 = Tcl_GetString((*(objv + 1)));
          tmp___30 = memcmp((void const   *)((char const   *)tmp___32), (void const   *)"-noinherit",
                            tmp___31 + 1U);
        } else {
          tmp___53 = Tcl_GetString((*(objv + 1)));
          tmp___54 = strcmp((char const   *)tmp___53, "-noinherit");
          tmp___30 = tmp___54;
        }
      } else {
        tmp___53 = Tcl_GetString((*(objv + 1)));
        tmp___54 = strcmp((char const   *)tmp___53, "-noinherit");
        tmp___30 = tmp___54;
      }
      if (! (tmp___30 == 0)) {
        goto badargs;
      }
    } else {
      goto badargs;
    }
  }
  server = (itPtr->servPtr)->server;
  method = Tcl_GetString((*(objv + (objc - 3))));
  url = Tcl_GetString((*(objv + (objc - 2))));
  tmp___60 = Tcl_GetString((*(objv + (objc - 1))));
  file___1 = ns_strdup((char const   *)tmp___60);
  if (objc == 5) {
    tmp___61 = 2;
  } else {
    tmp___61 = 0;
  }
  Ns_RegisterRequest(server, method, url, & AdpRequest, & ns_free, (void *)file___1,
                     tmp___61);
  return (0);
}
}
int NsTclUnRegisterObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  char *server ;
  char *tmp ;
  Tcl_Obj *tmp___0 ;
  char *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___32 ;
  size_t tmp___33 ;
  char *tmp___34 ;
  char *tmp___55 ;
  int tmp___56 ;
  char *tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;

  {
  itPtr = (NsInterp *)arg;
  server = (itPtr->servPtr)->server;
  if (objc != 3) {
    if (objc != 4) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-noinherit? method url");
      return (1);
    }
  }
  if (objc == 4) {
    tmp___1 = Tcl_GetString((*(objv + 1)));
    if ((int )(*tmp___1) == (int )(*"-noinherit")) {
      if (0) {
        tmp___58 = Tcl_GetString((*(objv + 1)));
        __s1_len = strlen((char const   *)tmp___58);
        __s2_len = strlen("-noinherit");
        tmp___59 = Tcl_GetString((*(objv + 1)));
        tmp___60 = Tcl_GetString((*(objv + 1)));
        if ((unsigned int )((void const   *)(tmp___59 + 1)) - (unsigned int )((void const   *)tmp___60) ==
            1U) {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("-noinherit" + 1)) - (unsigned int )((void const   *)"-noinherit") ==
                   1U)) {
              tmp___61 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___61 = 1;
              } else {
                tmp___61 = 0;
              }
            }
          } else {
            tmp___61 = 0;
          }
        } else {
          goto _L___0;
        }
        if (tmp___61) {
          if (__s1_len < __s2_len) {
            tmp___33 = __s1_len;
          } else {
            tmp___33 = __s2_len;
          }
          tmp___34 = Tcl_GetString((*(objv + 1)));
          tmp___32 = memcmp((void const   *)((char const   *)tmp___34), (void const   *)"-noinherit",
                            tmp___33 + 1U);
        } else {
          tmp___55 = Tcl_GetString((*(objv + 1)));
          tmp___56 = strcmp((char const   *)tmp___55, "-noinherit");
          tmp___32 = tmp___56;
        }
      } else {
        tmp___55 = Tcl_GetString((*(objv + 1)));
        tmp___56 = strcmp((char const   *)tmp___55, "-noinherit");
        tmp___32 = tmp___56;
      }
      if (! (tmp___32 == 0)) {
        tmp = Tcl_GetString((*(objv + 1)));
        tmp___0 = Tcl_GetObjResult(interp);
        Tcl_AppendStringsToObj(tmp___0, "unknown flag \"", tmp, "\": should be -noinherit",
                               (void *)0);
        return (1);
      }
    } else {
      tmp = Tcl_GetString((*(objv + 1)));
      tmp___0 = Tcl_GetObjResult(interp);
      Tcl_AppendStringsToObj(tmp___0, "unknown flag \"", tmp, "\": should be -noinherit",
                             (void *)0);
      return (1);
    }
  }
  if (objc == 3) {
    tmp___62 = 1;
  } else {
    tmp___62 = 0;
  }
  tmp___63 = Tcl_GetString((*(objv + (objc - 1))));
  tmp___64 = Tcl_GetString((*(objv + (objc - 2))));
  Ns_UnRegisterRequest(server, tmp___64, tmp___63, tmp___62);
  return (0);
}
}
int NsTclRegisterFilterObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  int lobjc ;
  Tcl_Obj **lobjv ;
  int when ;
  int i ;
  char *str ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___20 ;
  size_t tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 5) {
    if (objc != 6) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"when method urlPattern script ?arg?");
      return (1);
    }
  }
  tmp = Tcl_ListObjGetElements(interp, (*(objv + 1)), & lobjc, & lobjv);
  if (tmp != 0) {
    return (1);
  }
  if (lobjc == 0) {
    Tcl_SetResult(interp, (char *)"blank filter when specification", (Tcl_FreeProc *)0);
    return (1);
  }
  when = 0;
  i = 0;
  while (i < lobjc) {
    str = Tcl_GetString((*(lobjv + i)));
    if ((int )(*str) == (int )(*"preauth")) {
      if (0) {
        __s1_len___1 = strlen((char const   *)str);
        __s2_len___1 = strlen("preauth");
        if (! ((unsigned int )((void const   *)(str + 1)) - (unsigned int )((void const   *)str) ==
               1U)) {
          goto _L___5;
        } else {
          if (__s1_len___1 >= 4U) {
            _L___5: 
            if (! ((unsigned int )((void const   *)("preauth" + 1)) - (unsigned int )((void const   *)"preauth") ==
                   1U)) {
              tmp___23 = 1;
            } else {
              if (__s2_len___1 >= 4U) {
                tmp___23 = 1;
              } else {
                tmp___23 = 0;
              }
            }
          } else {
            tmp___23 = 0;
          }
        }
        if (tmp___23) {
          if (__s1_len___1 < __s2_len___1) {
            tmp___21 = __s1_len___1;
          } else {
            tmp___21 = __s2_len___1;
          }
          tmp___20 = memcmp((void const   *)((char const   *)str), (void const   *)"preauth",
                            tmp___21 + 1U);
        } else {
          tmp___22 = strcmp((char const   *)str, "preauth");
          tmp___20 = tmp___22;
        }
      } else {
        tmp___22 = strcmp((char const   *)str, "preauth");
        tmp___20 = tmp___22;
      }
      if (tmp___20 == 0) {
        when |= 1;
      } else {
        goto _L___6;
      }
    } else {
      _L___6: 
      if ((int )(*str) == (int )(*"postauth")) {
        if (0) {
          __s1_len___0 = strlen((char const   *)str);
          __s2_len___0 = strlen("postauth");
          if (! ((unsigned int )((void const   *)(str + 1)) - (unsigned int )((void const   *)str) ==
                 1U)) {
            goto _L___2;
          } else {
            if (__s1_len___0 >= 4U) {
              _L___2: 
              if (! ((unsigned int )((void const   *)("postauth" + 1)) - (unsigned int )((void const   *)"postauth") ==
                     1U)) {
                tmp___15 = 1;
              } else {
                if (__s2_len___0 >= 4U) {
                  tmp___15 = 1;
                } else {
                  tmp___15 = 0;
                }
              }
            } else {
              tmp___15 = 0;
            }
          }
          if (tmp___15) {
            if (__s1_len___0 < __s2_len___0) {
              tmp___13 = __s1_len___0;
            } else {
              tmp___13 = __s2_len___0;
            }
            tmp___12 = memcmp((void const   *)((char const   *)str), (void const   *)"postauth",
                              tmp___13 + 1U);
          } else {
            tmp___14 = strcmp((char const   *)str, "postauth");
            tmp___12 = tmp___14;
          }
        } else {
          tmp___14 = strcmp((char const   *)str, "postauth");
          tmp___12 = tmp___14;
        }
        if (tmp___12 == 0) {
          when |= 2;
        } else {
          goto _L___3;
        }
      } else {
        _L___3: 
        if ((int )(*str) == (int )(*"trace")) {
          if (0) {
            __s1_len = strlen((char const   *)str);
            __s2_len = strlen("trace");
            if (! ((unsigned int )((void const   *)(str + 1)) - (unsigned int )((void const   *)str) ==
                   1U)) {
              goto _L___0;
            } else {
              if (__s1_len >= 4U) {
                _L___0: 
                if (! ((unsigned int )((void const   *)("trace" + 1)) - (unsigned int )((void const   *)"trace") ==
                       1U)) {
                  tmp___7 = 1;
                } else {
                  if (__s2_len >= 4U) {
                    tmp___7 = 1;
                  } else {
                    tmp___7 = 0;
                  }
                }
              } else {
                tmp___7 = 0;
              }
            }
            if (tmp___7) {
              if (__s1_len < __s2_len) {
                tmp___5 = __s1_len;
              } else {
                tmp___5 = __s2_len;
              }
              tmp___4 = memcmp((void const   *)((char const   *)str), (void const   *)"trace",
                               tmp___5 + 1U);
            } else {
              tmp___6 = strcmp((char const   *)str, "trace");
              tmp___4 = tmp___6;
            }
          } else {
            tmp___6 = strcmp((char const   *)str, "trace");
            tmp___4 = tmp___6;
          }
          if (tmp___4 == 0) {
            when |= 4;
          } else {
            Tcl_AppendResult(interp, "unknown when \"", str, "\": should be preauth, postauth, or trace",
                             (void *)0);
            return (1);
          }
        } else {
          Tcl_AppendResult(interp, "unknown when \"", str, "\": should be preauth, postauth, or trace",
                           (void *)0);
          return (1);
        }
      }
    }
    i ++;
  }
  RegisterFilterObj(itPtr, when, objc - 2, objv + 2);
  return (0);
}
}
int NsTclRegisterTraceObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 4) {
    if (objc != 5) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"method urlPattern script ?arg?");
      return (1);
    }
  }
  RegisterFilterObj(itPtr, 8, objc - 1, objv + 1);
  return (0);
}
}
static int AdpRequest(void *arg , Ns_Conn *conn ) 
{ int tmp ;

  {
  tmp = Ns_AdpRequest(conn, (char *)arg);
  return (tmp);
}
}
static int ProcRequest(void *arg , Ns_Conn *conn ) 
{ Proc *procPtr ;
  Tcl_Interp *interp ;
  int cnt ;
  Tcl_DString cmd ;
  int retval ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  procPtr = (Proc *)arg;
  retval = 0;
  Tcl_DStringInit(& cmd);
  Tcl_DStringAppendElement(& cmd, procPtr->name);
  interp = Ns_GetConnInterp(conn);
  cnt = GetNumArgs(interp, procPtr);
  if (cnt != 0) {
    if (cnt > 1) {
      AppendConnId(& cmd, conn);
    }
    if (procPtr->args) {
      tmp = (char const   *)procPtr->args;
    } else {
      tmp = "";
    }
    Tcl_DStringAppendElement(& cmd, (char *)tmp);
  }
  tmp___1 = Tcl_GlobalEval(interp, cmd.string);
  if (tmp___1 != 0) {
    Ns_TclLogError(interp);
    tmp___0 = Ns_ConnResetReturn(conn);
    if (tmp___0 == 0) {
      retval = Ns_ConnReturnInternalError(conn);
    }
  }
  Tcl_DStringFree(& cmd);
  return (retval);
}
}
static int ProcFilter(void *arg , Ns_Conn *conn , int why ) 
{ Proc *procPtr ;
  Tcl_DString cmd ;
  Tcl_Interp *interp ;
  int status ;
  int cnt ;
  char *result ;
  char const   *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___20 ;
  size_t tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
  procPtr = (Proc *)arg;
  Tcl_DStringInit(& cmd);
  Tcl_DStringAppendElement(& cmd, procPtr->name);
  interp = Ns_GetConnInterp(conn);
  cnt = GetNumArgs(interp, procPtr);
  if (cnt > 1) {
    if (cnt > 2) {
      AppendConnId(& cmd, conn);
    }
    if (procPtr->args) {
      tmp = (char const   *)procPtr->args;
    } else {
      tmp = "";
    }
    Tcl_DStringAppendElement(& cmd, (char *)tmp);
  }
  switch (why) {
  case 1: 
  Tcl_DStringAppendElement(& cmd, (char *)"preauth");
  break;
  case 2: 
  Tcl_DStringAppendElement(& cmd, (char *)"postauth");
  break;
  case 4: 
  Tcl_DStringAppendElement(& cmd, (char *)"trace");
  break;
  }
  Tcl_AllowExceptions(interp);
  status = Tcl_GlobalEval(interp, cmd.string);
  if (status != 0) {
    Ns_TclLogError(interp);
  }
  result = Tcl_GetStringResult(interp);
  if (why == 8) {
    status = 0;
  } else {
    if (status != 0) {
      status = -1;
    } else {
      if ((int )(*result) == (int )(*"filter_ok")) {
        if (0) {
          __s1_len___1 = strlen((char const   *)result);
          __s2_len___1 = strlen("filter_ok");
          if (! ((unsigned int )((void const   *)(result + 1)) - (unsigned int )((void const   *)result) ==
                 1U)) {
            goto _L___5;
          } else {
            if (__s1_len___1 >= 4U) {
              _L___5: 
              if (! ((unsigned int )((void const   *)("filter_ok" + 1)) - (unsigned int )((void const   *)"filter_ok") ==
                     1U)) {
                tmp___23 = 1;
              } else {
                if (__s2_len___1 >= 4U) {
                  tmp___23 = 1;
                } else {
                  tmp___23 = 0;
                }
              }
            } else {
              tmp___23 = 0;
            }
          }
          if (tmp___23) {
            if (__s1_len___1 < __s2_len___1) {
              tmp___21 = __s1_len___1;
            } else {
              tmp___21 = __s2_len___1;
            }
            tmp___20 = memcmp((void const   *)((char const   *)result), (void const   *)"filter_ok",
                              tmp___21 + 1U);
          } else {
            tmp___22 = strcmp((char const   *)result, "filter_ok");
            tmp___20 = tmp___22;
          }
        } else {
          tmp___22 = strcmp((char const   *)result, "filter_ok");
          tmp___20 = tmp___22;
        }
        if (tmp___20 == 0) {
          status = 0;
        } else {
          goto _L___6;
        }
      } else {
        _L___6: 
        if ((int )(*result) == (int )(*"filter_break")) {
          if (0) {
            __s1_len___0 = strlen((char const   *)result);
            __s2_len___0 = strlen("filter_break");
            if (! ((unsigned int )((void const   *)(result + 1)) - (unsigned int )((void const   *)result) ==
                   1U)) {
              goto _L___2;
            } else {
              if (__s1_len___0 >= 4U) {
                _L___2: 
                if (! ((unsigned int )((void const   *)("filter_break" + 1)) - (unsigned int )((void const   *)"filter_break") ==
                       1U)) {
                  tmp___15 = 1;
                } else {
                  if (__s2_len___0 >= 4U) {
                    tmp___15 = 1;
                  } else {
                    tmp___15 = 0;
                  }
                }
              } else {
                tmp___15 = 0;
              }
            }
            if (tmp___15) {
              if (__s1_len___0 < __s2_len___0) {
                tmp___13 = __s1_len___0;
              } else {
                tmp___13 = __s2_len___0;
              }
              tmp___12 = memcmp((void const   *)((char const   *)result), (void const   *)"filter_break",
                                tmp___13 + 1U);
            } else {
              tmp___14 = strcmp((char const   *)result, "filter_break");
              tmp___12 = tmp___14;
            }
          } else {
            tmp___14 = strcmp((char const   *)result, "filter_break");
            tmp___12 = tmp___14;
          }
          if (tmp___12 == 0) {
            status = -4;
          } else {
            goto _L___3;
          }
        } else {
          _L___3: 
          if ((int )(*result) == (int )(*"filter_return")) {
            if (0) {
              __s1_len = strlen((char const   *)result);
              __s2_len = strlen("filter_return");
              if (! ((unsigned int )((void const   *)(result + 1)) - (unsigned int )((void const   *)result) ==
                     1U)) {
                goto _L___0;
              } else {
                if (__s1_len >= 4U) {
                  _L___0: 
                  if (! ((unsigned int )((void const   *)("filter_return" + 1)) -
                         (unsigned int )((void const   *)"filter_return") == 1U)) {
                    tmp___7 = 1;
                  } else {
                    if (__s2_len >= 4U) {
                      tmp___7 = 1;
                    } else {
                      tmp___7 = 0;
                    }
                  }
                } else {
                  tmp___7 = 0;
                }
              }
              if (tmp___7) {
                if (__s1_len < __s2_len) {
                  tmp___5 = __s1_len;
                } else {
                  tmp___5 = __s2_len;
                }
                tmp___4 = memcmp((void const   *)((char const   *)result), (void const   *)"filter_return",
                                 tmp___5 + 1U);
              } else {
                tmp___6 = strcmp((char const   *)result, "filter_return");
                tmp___4 = tmp___6;
              }
            } else {
              tmp___6 = strcmp((char const   *)result, "filter_return");
              tmp___4 = tmp___6;
            }
            if (tmp___4 == 0) {
              status = -5;
            } else {
              Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"tclfilter: %s return invalid result: %s",
                     procPtr->name, result);
              status = -1;
            }
          } else {
            Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"tclfilter: %s return invalid result: %s",
                   procPtr->name, result);
            status = -1;
          }
        }
      }
    }
  }
  Tcl_DStringFree(& cmd);
  return (status);
}
}
static int GetNumArgs(Tcl_Interp *interp , Proc *procPtr ) 
{ Tcl_Obj *objPtr ;
  Tcl_DString ds ;
  int tmp ;
  int tmp___0 ;

  {
  if (procPtr->nargs == -1) {
    Tcl_DStringInit(& ds);
    Tcl_DStringAppend(& ds, (char *)"llength [info args ", -1);
    Tcl_DStringAppendElement(& ds, procPtr->name);
    Tcl_DStringAppend(& ds, (char *)"]", 1);
    tmp___0 = Tcl_Eval(interp, ds.string);
    if (tmp___0 != 0) {
      procPtr->nargs = -2;
    } else {
      objPtr = Tcl_GetObjResult(interp);
      tmp = Tcl_GetIntFromObj(interp, objPtr, & procPtr->nargs);
      if (tmp != 0) {
        procPtr->nargs = -2;
      }
    }
    Tcl_DStringFree(& ds);
  }
  return (procPtr->nargs);
}
}
static void RegisterFilterObj(NsInterp *itPtr , int when , int objc , Tcl_Obj **objv ) 
{ Proc *procPtr ;
  char *server ;
  char *method ;
  char *url ;
  char *name ;
  char *args ;

  {
  server = (itPtr->servPtr)->server;
  method = Tcl_GetString((*(objv + 0)));
  url = Tcl_GetString((*(objv + 1)));
  name = Tcl_GetString((*(objv + 2)));
  if (objc > 3) {
    args = Tcl_GetString((*(objv + 3)));
  } else {
    args = (char *)((void *)0);
  }
  procPtr = NewProc(name, args);
  Ns_RegisterFilter(server, method, url, & ProcFilter, when, (void *)procPtr);
  return;
}
}
static void AppendConnId(Tcl_DString *dsPtr , Ns_Conn *conn ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  Tcl_DStringAppendElement(dsPtr, connPtr->idstr);
  return;
}
}
static Proc *NewProc(char *name , char *args ) 
{ Proc *procPtr ;

  {
  procPtr = (Proc *)ns_malloc(sizeof(Proc ));
  procPtr->name = ns_strdup((char const   *)name);
  procPtr->args = ns_strcopy((char const   *)args);
  procPtr->nargs = -1;
  return (procPtr);
}
}
static void FreeProc(void *arg ) 
{ Proc *procPtr ;

  {
  procPtr = (Proc *)arg;
  ns_free((void *)procPtr->name);
  if ((unsigned int )procPtr->args != (unsigned int )((void *)0)) {
    ns_free((void *)procPtr->args);
  }
  ns_free((void *)procPtr);
  return;
}
}
extern unsigned char *Tcl_GetByteArrayFromObj(Tcl_Obj *objPtr , int *lengthPtr ) ;
Ns_Set *Ns_TclGetSet(Tcl_Interp *interp , char *id ) ;
static int CheckId(Tcl_Interp *interp , char *id ) ;
static int Result(Tcl_Interp *interp , int result ) ;
static int GetConn(ClientData arg , Tcl_Interp *interp , Ns_Conn **connPtr ) ;
int NsTclHeadersObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int status ;
  int len ;
  Ns_Conn *conn ;
  char *type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if (objc < 3) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"connid status ?type len?");
    return (1);
  } else {
    if (objc > 5) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"connid status ?type len?");
      return (1);
    }
  }
  tmp = GetConn(arg, interp, & conn);
  if (tmp != 0) {
    return (1);
  }
  tmp___0 = Tcl_GetIntFromObj(interp, (*(objv + 2)), & status);
  if (tmp___0 != 0) {
    return (1);
  }
  if (objc < 4) {
    type = (char *)((void *)0);
  } else {
    type = Tcl_GetString((*(objv + 3)));
  }
  if (objc < 5) {
    len = 0;
  } else {
    tmp___1 = Tcl_GetIntFromObj(interp, (*(objv + 4)), & len);
    if (tmp___1 != 0) {
      return (1);
    }
  }
  Ns_ConnSetRequiredHeaders(conn, type, len);
  tmp___2 = Ns_ConnFlushHeaders(conn, status);
  tmp___3 = Result(interp, tmp___2);
  return (tmp___3);
}
}
int NsTclReturnObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Ns_Conn *conn ;
  int status ;
  int result ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  if (objc != 4) {
    if (objc != 5) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?connid? status type string");
      return (1);
    }
  }
  if (objc == 5) {
    tmp = Tcl_GetString((*(objv + 1)));
    tmp___0 = CheckId(interp, tmp);
    if (! tmp___0) {
      return (1);
    }
  }
  tmp___1 = GetConn(arg, interp, & conn);
  if (tmp___1 != 0) {
    return (1);
  }
  tmp___2 = Tcl_GetIntFromObj(interp, (*(objv + (objc - 3))), & status);
  if (tmp___2 != 0) {
    return (1);
  }
  tmp___3 = Tcl_GetString((*(objv + (objc - 2))));
  tmp___4 = Tcl_GetString((*(objv + (objc - 1))));
  result = Ns_ConnReturnCharData(conn, status, tmp___4, -1, tmp___3);
  tmp___5 = Result(interp, result);
  return (tmp___5);
}
}
int NsTclRespondObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int status ;
  char *type ;
  char *string ;
  char *filename ;
  Tcl_Channel chan ;
  int length ;
  Ns_Conn *conn ;
  int retval ;
  int i ;
  int tmp ;
  char *carg ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  Ns_Set *set ;
  char *tmp___4 ;
  char *tmp___5 ;
  Tcl_Obj *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  status = 200;
  type = (char *)((void *)0);
  string = (char *)((void *)0);
  filename = (char *)((void *)0);
  chan = (struct Tcl_Channel_ *)((void *)0);
  length = -1;
  if (objc < 3) {
    error: 
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-status status? ?-type type? { ?-string string? | ?-file filename? | ?-fileid fileid? } ?-length length? ?-headers setid?");
    return (1);
  }
  tmp = GetConn(arg, interp, & conn);
  if (tmp != 0) {
    return (1);
  }
  i = 0;
  while (i < objc) {
    tmp___0 = Tcl_GetString((*(objv + i)));
    carg = tmp___0;
    if ((int )(*carg) != 45) {
      goto __Cont;
    }
    i ++;
    if (i >= objc) {
      goto error;
    }
    tmp___13 = strcasecmp((char const   *)carg, "-status");
    if (tmp___13 == 0) {
      tmp___1 = Tcl_GetIntFromObj(interp, (*(objv + i)), & status);
      if (tmp___1 != 0) {
        goto error;
      }
    } else {
      tmp___12 = strcasecmp((char const   *)carg, "-type");
      if (tmp___12 == 0) {
        type = Tcl_GetString((*(objv + i)));
      } else {
        tmp___11 = strcasecmp((char const   *)carg, "-string");
        if (tmp___11 == 0) {
          string = Tcl_GetString((*(objv + i)));
        } else {
          tmp___10 = strcasecmp((char const   *)carg, "-file");
          if (tmp___10 == 0) {
            filename = Tcl_GetString((*(objv + i)));
          } else {
            tmp___9 = strcasecmp((char const   *)carg, "-fileid");
            if (tmp___9 == 0) {
              tmp___2 = Ns_TclGetOpenChannel(interp, carg, 0, 1, & chan);
              if (tmp___2 != 0) {
                goto error;
              }
            } else {
              tmp___8 = strcasecmp((char const   *)carg, "-length");
              if (tmp___8 == 0) {
                tmp___3 = Tcl_GetIntFromObj(interp, (*(objv + i)), & length);
                if (tmp___3 != 0) {
                  goto error;
                }
              } else {
                tmp___7 = strcasecmp((char const   *)carg, "-headers");
                if (tmp___7 == 0) {
                  tmp___4 = Tcl_GetString((*(objv + i)));
                  set = Ns_TclGetSet(interp, tmp___4);
                  if ((unsigned int )set == (unsigned int )((void *)0)) {
                    tmp___5 = Tcl_GetString((*(objv + i)));
                    tmp___6 = Tcl_GetObjResult(interp);
                    Tcl_AppendStringsToObj(tmp___6, "Illegal ns_set id: \"", tmp___5,
                                           "\"", (void *)0);
                    return (1);
                  }
                  Ns_ConnReplaceHeaders(conn, set);
                }
              }
            }
          }
        }
      }
    }
    __Cont: 
    i ++;
  }
  if ((((unsigned int )chan != (unsigned int )((void *)0)) + ((unsigned int )filename !=
                                                              (unsigned int )((void *)0))) +
      ((unsigned int )string != (unsigned int )((void *)0)) != 1) {
    Tcl_SetResult(interp, (char *)"must specify only one of -string, -file, or -type",
                  (Tcl_FreeProc *)0);
    return (1);
  }
  if ((unsigned int )chan != (unsigned int )((void *)0)) {
    if (length < 0) {
      Tcl_SetResult(interp, (char *)"length required when -fileid is used", (Tcl_FreeProc *)0);
      return (1);
    }
    retval = Ns_ConnReturnOpenChannel(conn, status, type, chan, length);
  } else {
    if ((unsigned int )filename != (unsigned int )((void *)0)) {
      retval = Ns_ConnReturnFile(conn, status, type, filename);
    } else {
      retval = Ns_ConnReturnCharData(conn, status, string, length, type);
    }
  }
  tmp___14 = Result(interp, retval);
  return (tmp___14);
}
}
int NsTclReturnFileObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int status ;
  Ns_Conn *conn ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if (objc != 4) {
    if (objc != 5) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?connid? status type file");
      return (1);
    }
  }
  if (objc == 5) {
    tmp = Tcl_GetString((*(objv + 1)));
    tmp___0 = CheckId(interp, tmp);
    if (! tmp___0) {
      return (1);
    }
  }
  tmp___1 = GetConn(arg, interp, & conn);
  if (tmp___1 != 0) {
    return (1);
  }
  tmp___2 = Tcl_GetIntFromObj(interp, (*(objv + (objc - 3))), & status);
  if (tmp___2 != 0) {
    return (1);
  }
  tmp___3 = Tcl_GetString((*(objv + (objc - 1))));
  tmp___4 = Tcl_GetString((*(objv + (objc - 2))));
  tmp___5 = Ns_ConnReturnFile(conn, status, tmp___4, tmp___3);
  tmp___6 = Result(interp, tmp___5);
  return (tmp___6);
}
}
int NsTclReturnFpObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int len ;
  int status ;
  Tcl_Channel chan ;
  Ns_Conn *conn ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  if (objc != 5) {
    if (objc != 6) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?connid? status type fileId len");
      return (1);
    }
  }
  if (objc == 6) {
    tmp = Tcl_GetString((*(objv + 1)));
    tmp___0 = CheckId(interp, tmp);
    if (! tmp___0) {
      return (1);
    }
  }
  tmp___1 = GetConn(arg, interp, & conn);
  if (tmp___1 != 0) {
    return (1);
  }
  tmp___2 = Tcl_GetIntFromObj(interp, (*(objv + (objc - 4))), & status);
  if (tmp___2 != 0) {
    return (1);
  }
  tmp___3 = Tcl_GetIntFromObj(interp, (*(objv + (objc - 1))), & len);
  if (tmp___3 != 0) {
    return (1);
  }
  tmp___4 = Tcl_GetString((*(objv + (objc - 2))));
  tmp___5 = Ns_TclGetOpenChannel(interp, tmp___4, 0, 1, & chan);
  if (tmp___5 != 0) {
    return (1);
  }
  tmp___6 = Tcl_GetString((*(objv + (objc - 3))));
  tmp___7 = Ns_ConnReturnOpenChannel(conn, status, tmp___6, chan, len);
  tmp___8 = Result(interp, tmp___7);
  return (tmp___8);
}
}
int NsTclReturnBadRequestObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Ns_Conn *conn ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if (objc != 2) {
    if (objc != 3) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?connid? reason");
      return (1);
    }
  }
  if (objc == 3) {
    tmp = Tcl_GetString((*(objv + 1)));
    tmp___0 = CheckId(interp, tmp);
    if (! tmp___0) {
      return (1);
    }
  }
  tmp___1 = GetConn(arg, interp, & conn);
  if (tmp___1 != 0) {
    return (1);
  }
  tmp___2 = Tcl_GetString((*(objv + (objc - 1))));
  tmp___3 = Ns_ConnReturnBadRequest(conn, tmp___2);
  tmp___4 = Result(interp, tmp___3);
  return (tmp___4);
}
}
static int ReturnObjCmd___0(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ,
                            int (*proc)(Ns_Conn * ) ) 
{ Ns_Conn *conn ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if (objc != 1) {
    if (objc != 2) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?connid?");
      return (1);
    }
  }
  if (objc == 2) {
    tmp = Tcl_GetString((*(objv + 1)));
    tmp___0 = CheckId(interp, tmp);
    if (! tmp___0) {
      return (1);
    }
  }
  tmp___1 = GetConn(arg, interp, & conn);
  if (tmp___1 != 0) {
    return (1);
  }
  tmp___2 = ((*proc))(conn);
  tmp___3 = Result(interp, tmp___2);
  return (tmp___3);
}
}
int NsTclReturnNotFoundObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = ReturnObjCmd___0(arg, interp, objc, objv, & Ns_ConnReturnNotFound);
  return (tmp);
}
}
int NsTclReturnUnauthorizedObjCmd(ClientData arg , Tcl_Interp *interp , int objc ,
                                  Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = ReturnObjCmd___0(arg, interp, objc, objv, & Ns_ConnReturnUnauthorized);
  return (tmp);
}
}
int NsTclReturnForbiddenObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = ReturnObjCmd___0(arg, interp, objc, objv, & Ns_ConnReturnForbidden);
  return (tmp);
}
}
int NsTclReturnErrorObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int status ;
  Ns_Conn *conn ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  if (objc != 3) {
    if (objc != 4) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?connid? status message");
      return (1);
    }
  }
  if (objc == 4) {
    tmp = Tcl_GetString((*(objv + 1)));
    tmp___0 = CheckId(interp, tmp);
    if (! tmp___0) {
      return (1);
    }
  }
  tmp___1 = GetConn(arg, interp, & conn);
  if (tmp___1 != 0) {
    return (1);
  }
  tmp___2 = Tcl_GetIntFromObj(interp, (*(objv + (objc - 2))), & status);
  if (tmp___2 != 0) {
    return (1);
  }
  tmp___3 = Tcl_GetString((*(objv + (objc - 1))));
  tmp___4 = Ns_ConnReturnAdminNotice(conn, status, (char *)"Request Error", tmp___3);
  tmp___5 = Result(interp, tmp___4);
  return (tmp___5);
}
}
static int ReturnNoticeCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ,
                           int admin ) 
{ int status ;
  int result ;
  Ns_Conn *conn ;
  char *longMessage ;
  int statusArg ;
  int messageArg ;
  int longMessageArg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  longMessage = (char *)((void *)0);
  statusArg = 0;
  messageArg = 0;
  longMessageArg = 0;
  if (argc == 3) {
    statusArg = 1;
    messageArg = 2;
  } else {
    if (argc == 4) {
      tmp = NsIsIdConn((*(argv + 1)));
      if (tmp == 1) {
        statusArg = 2;
        messageArg = 3;
      } else {
        statusArg = 1;
        messageArg = 2;
        longMessageArg = 3;
      }
    } else {
      if (argc == 5) {
        statusArg = 2;
        messageArg = 3;
        longMessageArg = 4;
      } else {
        Tcl_AppendResult(interp, "wrong # of args: should be \"", (*(argv + 0)), " status title ?message?\"",
                         (void *)0);
        return (1);
      }
    }
  }
  tmp___0 = GetConn(arg, interp, & conn);
  if (tmp___0 != 0) {
    return (1);
  }
  tmp___1 = Tcl_GetInt(interp, (*(argv + statusArg)), & status);
  if (tmp___1 != 0) {
    return (1);
  }
  if (longMessageArg != 0) {
    longMessage = (*(argv + longMessageArg));
  }
  if (admin) {
    result = Ns_ConnReturnAdminNotice(conn, status, (*(argv + messageArg)), longMessage);
  } else {
    result = Ns_ConnReturnNotice(conn, status, (*(argv + messageArg)), longMessage);
  }
  tmp___2 = Result(interp, result);
  return (tmp___2);
}
}
int NsTclReturnNoticeCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ int tmp ;

  {
  tmp = ReturnNoticeCmd(arg, interp, argc, argv, 0);
  return (tmp);
}
}
int NsTclReturnAdminNoticeCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ int tmp ;

  {
  tmp = ReturnNoticeCmd(arg, interp, argc, argv, 1);
  return (tmp);
}
}
int NsTclReturnRedirectObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Ns_Conn *conn ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if (objc != 2) {
    if (objc != 3) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?connid? location");
      return (1);
    }
  }
  if (objc == 3) {
    tmp = Tcl_GetString((*(objv + 1)));
    tmp___0 = CheckId(interp, tmp);
    if (! tmp___0) {
      return (1);
    }
  }
  tmp___1 = GetConn(arg, interp, & conn);
  if (tmp___1 != 0) {
    return (1);
  }
  tmp___2 = Tcl_GetString((*(objv + (objc - 1))));
  tmp___3 = Ns_ConnReturnRedirect(conn, tmp___2);
  tmp___4 = Result(interp, tmp___3);
  return (tmp___4);
}
}
int NsTclWriteObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Ns_Conn *conn ;
  char *bytes ;
  int length ;
  int result ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  Tcl_Encoding tmp___4 ;
  int tmp___5 ;

  {
  if (objc != 2) {
    if (objc != 3) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?connid? string");
      return (1);
    }
  }
  if (objc == 3) {
    tmp = Tcl_GetString((*(objv + 1)));
    tmp___0 = CheckId(interp, tmp);
    if (! tmp___0) {
      return (1);
    }
  }
  tmp___1 = GetConn(arg, interp, & conn);
  if (tmp___1 != 0) {
    return (1);
  }
  tmp___3 = Ns_ConnGetWriteEncodedFlag(conn);
  if (tmp___3) {
    tmp___4 = Ns_ConnGetEncoding(conn);
    if ((unsigned int )tmp___4 != (unsigned int )((void *)0)) {
      bytes = Tcl_GetStringFromObj((*(objv + (objc - 1))), & length);
      result = Ns_WriteCharConn(conn, bytes, length);
    } else {
      bytes = (char *)Tcl_GetByteArrayFromObj((*(objv + (objc - 1))), & length);
      result = Ns_WriteConn(conn, bytes, length);
    }
  } else {
    bytes = (char *)Tcl_GetByteArrayFromObj((*(objv + (objc - 1))), & length);
    result = Ns_WriteConn(conn, bytes, length);
  }
  tmp___5 = Result(interp, result);
  return (tmp___5);
}
}
int NsTclConnSendFpObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Ns_Conn *conn ;
  Tcl_Channel chan ;
  int len ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  Tcl_Obj *tmp___7 ;
  int tmp___8 ;

  {
  if (objc != 3) {
    if (objc != 4) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?connid? fp len");
      return (1);
    }
  }
  if (objc == 4) {
    tmp = Tcl_GetString((*(objv + 1)));
    tmp___0 = CheckId(interp, tmp);
    if (! tmp___0) {
      return (1);
    }
  }
  tmp___1 = GetConn(arg, interp, & conn);
  if (tmp___1 != 0) {
    return (1);
  }
  tmp___2 = Tcl_GetString((*(objv + (objc - 2))));
  tmp___3 = Ns_TclGetOpenChannel(interp, tmp___2, 0, 1, & chan);
  if (tmp___3 != 0) {
    return (1);
  }
  tmp___4 = Tcl_GetIntFromObj(interp, (*(objv + (objc - 1))), & len);
  if (tmp___4 != 0) {
    return (1);
  }
  tmp___8 = Ns_ConnSendChannel(conn, chan, len);
  if (tmp___8 != 0) {
    tmp___5 = Tcl_GetString((*(objv + (objc - 2))));
    tmp___6 = Tcl_GetString((*(objv + (objc - 1))));
    tmp___7 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___7, "could not send ", tmp___6, " bytes from channel ",
                           tmp___5, (void *)0);
    return (1);
  }
  return (0);
}
}
static int CheckId(Tcl_Interp *interp , char *id ) 
{ int tmp ;

  {
  tmp = NsIsIdConn(id);
  if (! tmp) {
    Tcl_AppendResult(interp, "invalid connid: ", id, (void *)0);
    return (0);
  }
  return (1);
}
}
static int Result(Tcl_Interp *interp , int result ) 
{ char const   *tmp ;

  {
  if (result == 0) {
    tmp = "1";
  } else {
    tmp = "0";
  }
  Tcl_SetResult(interp, (char *)tmp, (Tcl_FreeProc *)0);
  return (0);
}
}
static int GetConn(ClientData arg , Tcl_Interp *interp , Ns_Conn **connPtr ) 
{ NsInterp *itPtr ;

  {
  itPtr = (NsInterp *)arg;
  if ((unsigned int )itPtr->conn == (unsigned int )((void *)0)) {
    Tcl_SetResult(interp, (char *)"no connection", (Tcl_FreeProc *)0);
    return (1);
  }
  (*connPtr) = itPtr->conn;
  return (0);
}
}
static Callback___1 *NewCallback(Tcl_Interp *interp , char *proc , char *arg ) ;
static void EvalCallback(void *arg ) ;
static void FreeCallback(void *arg ) ;
static void FreeSched(void *arg , int id ) ;
static int ReturnValidId(Tcl_Interp *interp , int id , Callback___1 *cbPtr ) ;
static int AtCmd(AtProc *procPtr , Tcl_Interp *interp , int argc , char **argv ) ;
static int AtCmd(AtProc *procPtr , Tcl_Interp *interp , int argc , char **argv ) 
{ Callback___1 *cbPtr ;

  {
  if (argc != 2) {
    if (argc != 3) {
      Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " script | procname ?arg?\"",
                       (void *)0);
      return (1);
    }
  }
  cbPtr = NewCallback(interp, (*(argv + 1)), (*(argv + 2)));
  if ((unsigned int )procPtr == (unsigned int )(& Ns_RegisterAtSignal)) {
    ((*procPtr))(& NsTclSignalProc, (void *)cbPtr);
  } else {
    ((*procPtr))(& NsTclCallback, (void *)cbPtr);
  }
  return (0);
}
}
int NsTclAtSignalCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ int tmp ;

  {
  tmp = AtCmd(& Ns_RegisterAtSignal, interp, argc, argv);
  return (tmp);
}
}
int NsTclAtShutdownCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ int tmp ;

  {
  tmp = AtCmd(& Ns_RegisterShutdown, interp, argc, argv);
  return (tmp);
}
}
int NsTclAtExitCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ int tmp ;

  {
  tmp = AtCmd(& Ns_RegisterAtExit, interp, argc, argv);
  return (tmp);
}
}
int NsTclAfterCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ int id ;
  int seconds ;
  Callback___1 *cbPtr ;
  int tmp ;
  int tmp___0 ;

  {
  if (argc != 3) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " seconds script\"",
                     (void *)0);
    return (1);
  }
  tmp = Tcl_GetInt(interp, (*(argv + 1)), & seconds);
  if (tmp != 0) {
    return (1);
  }
  cbPtr = NewCallback(interp, (*(argv + 2)), (char *)((void *)0));
  id = Ns_After(seconds, (Ns_Callback *)(& NsTclSchedProc), (void *)cbPtr, & FreeCallback);
  tmp___0 = ReturnValidId(interp, id, cbPtr);
  return (tmp___0);
}
}
static int SchedCmd(Tcl_Interp *interp , int argc , char **argv , int cmd ) 
{ int id ;
  int ok ;
  char buf[10] ;
  int tmp ;

  {
  if (argc != 2) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " id\"",
                     (void *)0);
    return (1);
  }
  tmp = Tcl_GetInt(interp, (*(argv + 1)), & id);
  if (tmp != 0) {
    return (1);
  }
  switch (cmd) {
  case 117: ;
  case 99: 
  ok = Ns_Cancel(id);
  break;
  case 112: 
  ok = Ns_Pause(id);
  break;
  case 114: 
  ok = Ns_Resume(id);
  break;
  default: 
  ok = -1;
  }
  if (cmd != 117) {
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", ok);
    Tcl_SetResult(interp, buf, (Tcl_FreeProc *)1);
  }
  return (0);
}
}
int NsTclCancelCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ int tmp ;

  {
  tmp = SchedCmd(interp, argc, argv, 'c');
  return (tmp);
}
}
int NsTclPauseCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ int tmp ;

  {
  tmp = SchedCmd(interp, argc, argv, 'p');
  return (tmp);
}
}
int NsTclResumeCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ int tmp ;

  {
  tmp = SchedCmd(interp, argc, argv, 'r');
  return (tmp);
}
}
int NsTclUnscheduleCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ int tmp ;

  {
  tmp = SchedCmd(interp, argc, argv, 'u');
  return (tmp);
}
}
int NsTclSchedDailyCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ Callback___1 *cbPtr ;
  int flags ;
  int first___1 ;
  int id ;
  int hour ;
  int minute ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  first___1 = 1;
  flags = 0;
  while (1) {
    tmp___15 = argc;
    argc --;
    if (tmp___15) {
      if (! ((unsigned int )(*(argv + first___1)) != (unsigned int )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    if (0) {
      __s1_len___0 = strlen((char const   *)(*(argv + first___1)));
      __s2_len___0 = strlen("-thread");
      if (! ((unsigned int )((void const   *)((*(argv + first___1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                               first___1))) ==
             1U)) {
        goto _L___2;
      } else {
        if (__s1_len___0 >= 4U) {
          _L___2: 
          if (! ((unsigned int )((void const   *)("-thread" + 1)) - (unsigned int )((void const   *)"-thread") ==
                 1U)) {
            tmp___14 = 1;
          } else {
            if (__s2_len___0 >= 4U) {
              tmp___14 = 1;
            } else {
              tmp___14 = 0;
            }
          }
        } else {
          tmp___14 = 0;
        }
      }
      if (tmp___14) {
        if (__s1_len___0 < __s2_len___0) {
          tmp___12 = __s1_len___0;
        } else {
          tmp___12 = __s2_len___0;
        }
        tmp___11 = memcmp((void const   *)((char const   *)(*(argv + first___1))),
                          (void const   *)"-thread", tmp___12 + 1U);
      } else {
        tmp___13 = strcmp((char const   *)(*(argv + first___1)), "-thread");
        tmp___11 = tmp___13;
      }
    } else {
      tmp___13 = strcmp((char const   *)(*(argv + first___1)), "-thread");
      tmp___11 = tmp___13;
    }
    if (tmp___11 == 0) {
      flags |= 1;
    } else {
      if (0) {
        __s1_len = strlen((char const   *)(*(argv + first___1)));
        __s2_len = strlen("-once");
        if (! ((unsigned int )((void const   *)((*(argv + first___1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                                 first___1))) ==
               1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("-once" + 1)) - (unsigned int )((void const   *)"-once") ==
                   1U)) {
              tmp___6 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___6 = 1;
              } else {
                tmp___6 = 0;
              }
            }
          } else {
            tmp___6 = 0;
          }
        }
        if (tmp___6) {
          if (__s1_len < __s2_len) {
            tmp___4 = __s1_len;
          } else {
            tmp___4 = __s2_len;
          }
          tmp___3 = memcmp((void const   *)((char const   *)(*(argv + first___1))),
                           (void const   *)"-once", tmp___4 + 1U);
        } else {
          tmp___5 = strcmp((char const   *)(*(argv + first___1)), "-once");
          tmp___3 = tmp___5;
        }
      } else {
        tmp___5 = strcmp((char const   *)(*(argv + first___1)), "-once");
        tmp___3 = tmp___5;
      }
      if (tmp___3 == 0) {
        flags |= 2;
      } else {
        break;
      }
    }
    first___1 ++;
  }
  if (argc < 3) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " ?-once? ?-thread? hour minute { script | procname ?arg? }\"",
                     (char *)((void *)0));
    return (1);
  } else {
    if (argc > 4) {
      Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " ?-once? ?-thread? hour minute { script | procname ?arg? }\"",
                       (char *)((void *)0));
      return (1);
    }
  }
  tmp___16 = first___1;
  first___1 ++;
  tmp___17 = Tcl_GetInt(interp, (*(argv + tmp___16)), & hour);
  if (tmp___17 != 0) {
    return (1);
  }
  if (hour < 0) {
    Tcl_AppendResult(interp, "invalid hour \"", (*(argv + (first___1 - 1))), "\": should be >= 0 and <= 23",
                     (void *)0);
    return (1);
  } else {
    if (hour > 23) {
      Tcl_AppendResult(interp, "invalid hour \"", (*(argv + (first___1 - 1))), "\": should be >= 0 and <= 23",
                       (void *)0);
      return (1);
    }
  }
  tmp___18 = first___1;
  first___1 ++;
  tmp___19 = Tcl_GetInt(interp, (*(argv + tmp___18)), & minute);
  if (tmp___19 != 0) {
    return (1);
  }
  if (minute < 0) {
    Tcl_AppendResult(interp, "invalid minute \"", (*(argv + (first___1 - 1))), "\": should be >= 0 and <= 59",
                     (void *)0);
    return (1);
  } else {
    if (minute > 59) {
      Tcl_AppendResult(interp, "invalid minute \"", (*(argv + (first___1 - 1))), "\": should be >= 0 and <= 59",
                       (void *)0);
      return (1);
    }
  }
  cbPtr = NewCallback(interp, (*(argv + first___1)), (*(argv + (first___1 + 1))));
  id = Ns_ScheduleDaily(& NsTclSchedProc, (void *)cbPtr, flags, hour, minute, & FreeSched);
  tmp___20 = ReturnValidId(interp, id, cbPtr);
  return (tmp___20);
}
}
int NsTclSchedWeeklyCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ Callback___1 *cbPtr ;
  int flags ;
  int first___1 ;
  int id ;
  int day ;
  int hour ;
  int minute ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
  first___1 = 1;
  flags = 0;
  while (1) {
    tmp___15 = argc;
    argc --;
    if (tmp___15) {
      if (! ((unsigned int )(*(argv + first___1)) != (unsigned int )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    if (0) {
      __s1_len___0 = strlen((char const   *)(*(argv + first___1)));
      __s2_len___0 = strlen("-thread");
      if (! ((unsigned int )((void const   *)((*(argv + first___1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                               first___1))) ==
             1U)) {
        goto _L___2;
      } else {
        if (__s1_len___0 >= 4U) {
          _L___2: 
          if (! ((unsigned int )((void const   *)("-thread" + 1)) - (unsigned int )((void const   *)"-thread") ==
                 1U)) {
            tmp___14 = 1;
          } else {
            if (__s2_len___0 >= 4U) {
              tmp___14 = 1;
            } else {
              tmp___14 = 0;
            }
          }
        } else {
          tmp___14 = 0;
        }
      }
      if (tmp___14) {
        if (__s1_len___0 < __s2_len___0) {
          tmp___12 = __s1_len___0;
        } else {
          tmp___12 = __s2_len___0;
        }
        tmp___11 = memcmp((void const   *)((char const   *)(*(argv + first___1))),
                          (void const   *)"-thread", tmp___12 + 1U);
      } else {
        tmp___13 = strcmp((char const   *)(*(argv + first___1)), "-thread");
        tmp___11 = tmp___13;
      }
    } else {
      tmp___13 = strcmp((char const   *)(*(argv + first___1)), "-thread");
      tmp___11 = tmp___13;
    }
    if (tmp___11 == 0) {
      flags |= 1;
    } else {
      if (0) {
        __s1_len = strlen((char const   *)(*(argv + first___1)));
        __s2_len = strlen("-once");
        if (! ((unsigned int )((void const   *)((*(argv + first___1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                                 first___1))) ==
               1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("-once" + 1)) - (unsigned int )((void const   *)"-once") ==
                   1U)) {
              tmp___6 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___6 = 1;
              } else {
                tmp___6 = 0;
              }
            }
          } else {
            tmp___6 = 0;
          }
        }
        if (tmp___6) {
          if (__s1_len < __s2_len) {
            tmp___4 = __s1_len;
          } else {
            tmp___4 = __s2_len;
          }
          tmp___3 = memcmp((void const   *)((char const   *)(*(argv + first___1))),
                           (void const   *)"-once", tmp___4 + 1U);
        } else {
          tmp___5 = strcmp((char const   *)(*(argv + first___1)), "-once");
          tmp___3 = tmp___5;
        }
      } else {
        tmp___5 = strcmp((char const   *)(*(argv + first___1)), "-once");
        tmp___3 = tmp___5;
      }
      if (tmp___3 == 0) {
        flags |= 2;
      } else {
        break;
      }
    }
    first___1 ++;
  }
  if (argc < 4) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " ?-once? ?-thread? day hour minute { script | procname ?arg? }\"",
                     (char *)((void *)0));
    return (1);
  } else {
    if (argc > 5) {
      Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " ?-once? ?-thread? day hour minute { script | procname ?arg? }\"",
                       (char *)((void *)0));
      return (1);
    }
  }
  tmp___16 = first___1;
  first___1 ++;
  tmp___17 = Tcl_GetInt(interp, (*(argv + tmp___16)), & day);
  if (tmp___17 != 0) {
    return (1);
  }
  if (day < 0) {
    Tcl_AppendResult(interp, "invalid day \"", (*(argv + (first___1 - 1))), "\": should be >= 0 and <= 6",
                     (void *)0);
    return (1);
  } else {
    if (day > 6) {
      Tcl_AppendResult(interp, "invalid day \"", (*(argv + (first___1 - 1))), "\": should be >= 0 and <= 6",
                       (void *)0);
      return (1);
    }
  }
  tmp___18 = first___1;
  first___1 ++;
  tmp___19 = Tcl_GetInt(interp, (*(argv + tmp___18)), & hour);
  if (tmp___19 != 0) {
    return (1);
  }
  if (hour < 0) {
    Tcl_AppendResult(interp, "invalid hour \"", (*(argv + (first___1 - 1))), "\": should be >= 0 and <= 23",
                     (void *)0);
    return (1);
  } else {
    if (hour > 23) {
      Tcl_AppendResult(interp, "invalid hour \"", (*(argv + (first___1 - 1))), "\": should be >= 0 and <= 23",
                       (void *)0);
      return (1);
    }
  }
  tmp___20 = first___1;
  first___1 ++;
  tmp___21 = Tcl_GetInt(interp, (*(argv + tmp___20)), & minute);
  if (tmp___21 != 0) {
    return (1);
  }
  if (minute < 0) {
    Tcl_AppendResult(interp, "invalid minute \"", (*(argv + (first___1 - 1))), "\": should be >= 0 and <= 59",
                     (void *)0);
    return (1);
  } else {
    if (minute > 59) {
      Tcl_AppendResult(interp, "invalid minute \"", (*(argv + (first___1 - 1))), "\": should be >= 0 and <= 59",
                       (void *)0);
      return (1);
    }
  }
  cbPtr = NewCallback(interp, (*(argv + first___1)), (*(argv + (first___1 + 1))));
  id = Ns_ScheduleWeekly(& NsTclSchedProc, (void *)cbPtr, flags, day, hour, minute,
                         & FreeSched);
  tmp___22 = ReturnValidId(interp, id, cbPtr);
  return (tmp___22);
}
}
int NsTclSchedCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ Callback___1 *cbPtr ;
  int interval ;
  int flags ;
  int first___1 ;
  int id ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  first___1 = 1;
  flags = 0;
  while (1) {
    tmp___15 = argc;
    argc --;
    if (tmp___15) {
      if (! ((unsigned int )(*(argv + first___1)) != (unsigned int )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    if (0) {
      __s1_len___0 = strlen((char const   *)(*(argv + first___1)));
      __s2_len___0 = strlen("-thread");
      if (! ((unsigned int )((void const   *)((*(argv + first___1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                               first___1))) ==
             1U)) {
        goto _L___2;
      } else {
        if (__s1_len___0 >= 4U) {
          _L___2: 
          if (! ((unsigned int )((void const   *)("-thread" + 1)) - (unsigned int )((void const   *)"-thread") ==
                 1U)) {
            tmp___14 = 1;
          } else {
            if (__s2_len___0 >= 4U) {
              tmp___14 = 1;
            } else {
              tmp___14 = 0;
            }
          }
        } else {
          tmp___14 = 0;
        }
      }
      if (tmp___14) {
        if (__s1_len___0 < __s2_len___0) {
          tmp___12 = __s1_len___0;
        } else {
          tmp___12 = __s2_len___0;
        }
        tmp___11 = memcmp((void const   *)((char const   *)(*(argv + first___1))),
                          (void const   *)"-thread", tmp___12 + 1U);
      } else {
        tmp___13 = strcmp((char const   *)(*(argv + first___1)), "-thread");
        tmp___11 = tmp___13;
      }
    } else {
      tmp___13 = strcmp((char const   *)(*(argv + first___1)), "-thread");
      tmp___11 = tmp___13;
    }
    if (tmp___11 == 0) {
      flags |= 1;
    } else {
      if (0) {
        __s1_len = strlen((char const   *)(*(argv + first___1)));
        __s2_len = strlen("-once");
        if (! ((unsigned int )((void const   *)((*(argv + first___1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                                 first___1))) ==
               1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("-once" + 1)) - (unsigned int )((void const   *)"-once") ==
                   1U)) {
              tmp___6 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___6 = 1;
              } else {
                tmp___6 = 0;
              }
            }
          } else {
            tmp___6 = 0;
          }
        }
        if (tmp___6) {
          if (__s1_len < __s2_len) {
            tmp___4 = __s1_len;
          } else {
            tmp___4 = __s2_len;
          }
          tmp___3 = memcmp((void const   *)((char const   *)(*(argv + first___1))),
                           (void const   *)"-once", tmp___4 + 1U);
        } else {
          tmp___5 = strcmp((char const   *)(*(argv + first___1)), "-once");
          tmp___3 = tmp___5;
        }
      } else {
        tmp___5 = strcmp((char const   *)(*(argv + first___1)), "-once");
        tmp___3 = tmp___5;
      }
      if (tmp___3 == 0) {
        flags |= 2;
      } else {
        break;
      }
    }
    first___1 ++;
  }
  if (argc < 2) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " ?-once? ?-thread? interval { script | procname ?arg? }\"",
                     (char *)((void *)0));
    return (1);
  } else {
    if (argc > 3) {
      Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " ?-once? ?-thread? interval { script | procname ?arg? }\"",
                       (char *)((void *)0));
      return (1);
    }
  }
  tmp___16 = first___1;
  first___1 ++;
  tmp___17 = Tcl_GetInt(interp, (*(argv + tmp___16)), & interval);
  if (tmp___17 != 0) {
    return (1);
  }
  cbPtr = NewCallback(interp, (*(argv + first___1)), (*(argv + (first___1 + 1))));
  id = Ns_ScheduleProcEx(& NsTclSchedProc, (void *)cbPtr, flags, interval, & FreeSched);
  tmp___18 = ReturnValidId(interp, id, cbPtr);
  return (tmp___18);
}
}
static int ReturnValidId(Tcl_Interp *interp , int id , Callback___1 *cbPtr ) 
{ char buf[10] ;

  {
  if (id == -1) {
    Tcl_SetResult(interp, (char *)"could not schedule procedure", (Tcl_FreeProc *)0);
    FreeCallback((void *)cbPtr);
    return (1);
  }
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", id);
  Tcl_SetResult(interp, buf, (Tcl_FreeProc *)1);
  return (0);
}
}
static void EvalCallback(void *arg ) 
{ Callback___1 *cbPtr ;

  {
  cbPtr = (Callback___1 *)arg;
  Ns_TclEval((Tcl_DString *)((void *)0), cbPtr->server, cbPtr->script);
  return;
}
}
static Callback___1 *NewCallback(Tcl_Interp *interp , char *proc , char *arg ) 
{ Callback___1 *cbPtr ;
  char *argv[2] ;
  int tmp ;

  {
  argv[0] = proc;
  argv[1] = arg;
  cbPtr = (Callback___1 *)ns_malloc(sizeof(Callback___1 ));
  cbPtr->server = Ns_TclInterpServer(interp);
  if (arg) {
    tmp = 2;
  } else {
    tmp = 1;
  }
  cbPtr->script = Tcl_Concat(tmp, argv);
  return (cbPtr);
}
}
static void FreeCallback(void *arg ) 
{ Callback___1 *cbPtr ;

  {
  cbPtr = (Callback___1 *)arg;
  Tcl_Free(cbPtr->script);
  ns_free((void *)cbPtr);
  return;
}
}
static void FreeSched(void *arg , int id ) 
{ 

  {
  FreeCallback(arg);
  return;
}
}
void NsTclSchedProc(void *arg , int id ) 
{ 

  {
  EvalCallback(arg);
  return;
}
}
void NsTclSignalProc(void *arg ) 
{ 

  {
  EvalCallback(arg);
  return;
}
}
void NsTclCallback(void *arg ) 
{ 

  {
  EvalCallback(arg);
  FreeCallback(arg);
  return;
}
}
void NsTclArgProc(Tcl_DString *dsPtr , void *arg ) 
{ Callback___1 *cbPtr ;

  {
  cbPtr = (Callback___1 *)arg;
  Tcl_DStringAppendElement(dsPtr, cbPtr->script);
  return;
}
}
extern Tcl_Obj *Tcl_NewBooleanObj(int boolValue ) ;
int Ns_TclFreeSet(Tcl_Interp *interp , char *id ) ;
static int NoServer(Tcl_Interp *interp ) ;
static int LookupSet(NsInterp *itPtr , char *id , int delete , Ns_Set **setPtr ) ;
static int LookupObjSet(NsInterp *itPtr , Tcl_Obj *idPtr , int delete , Ns_Set **setPtr ) ;
static int LookupInterpSet(Tcl_Interp *interp , char *id , int delete , Ns_Set **setPtr ) ;
static int EnterSet(NsInterp *itPtr , Ns_Set *set , int flags ) ;
int Ns_TclEnterSet(Tcl_Interp *interp , Ns_Set *set , int flags ) 
{ NsInterp *itPtr ;
  NsInterp *tmp ;
  int tmp___0 ;

  {
  tmp = NsGetInterp(interp);
  itPtr = tmp;
  if ((unsigned int )itPtr == (unsigned int )((void *)0)) {
    Tcl_SetResult(interp, (char *)"ns_set not supported", (Tcl_FreeProc *)0);
    return (1);
  }
  tmp___0 = EnterSet(itPtr, set, flags);
  return (tmp___0);
}
}
Ns_Set *Ns_TclGetSet(Tcl_Interp *interp , char *id ) 
{ Ns_Set *set ;
  int tmp ;

  {
  tmp = LookupInterpSet(interp, id, 0, & set);
  if (tmp != 0) {
    return ((Ns_Set *)((void *)0));
  }
  return (set);
}
}
int Ns_TclGetSet2(Tcl_Interp *interp , char *id , Ns_Set **setPtr ) 
{ int tmp ;

  {
  tmp = LookupInterpSet(interp, id, 0, setPtr);
  return (tmp);
}
}
int Ns_TclFreeSet(Tcl_Interp *interp , char *id ) 
{ Ns_Set *set ;
  int tmp ;

  {
  tmp = LookupInterpSet(interp, id, 1, & set);
  if (tmp != 0) {
    return (1);
  }
  if ((int )(*id) == 100) {
    Ns_SetFree(set);
  } else {
    if ((int )(*id) == 115) {
      Ns_SetFree(set);
    }
  }
  return (0);
}
}
static char *opts___8[33]  = 
  {      (char *)"array",      (char *)"cleanup",      (char *)"copy",      (char *)"cput", 
        (char *)"create",      (char *)"delete",      (char *)"delkey",      (char *)"find", 
        (char *)"free",      (char *)"get",      (char *)"icput",      (char *)"idelete", 
        (char *)"idelkey",      (char *)"ifind",      (char *)"iget",      (char *)"isnull", 
        (char *)"iunique",      (char *)"key",      (char *)"list",      (char *)"merge", 
        (char *)"move",      (char *)"name",      (char *)"new",      (char *)"print", 
        (char *)"purge",      (char *)"put",      (char *)"size",      (char *)"split", 
        (char *)"truncate",      (char *)"unique",      (char *)"update",      (char *)"value", 
        (char *)((void *)0)};
int NsTclSetObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Ns_Set *set ;
  Ns_Set *set2Ptr ;
  Ns_Set **sets ;
  int locked ;
  int i ;
  int flags ;
  char *key___1 ;
  char *val ;
  char *name ;
  char *split ;
  Tcl_DString ds ;
  Tcl_HashTable *tablePtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  NsInterp *itPtr ;
  Tcl_Obj *objPtr ;
  int opt ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___33 ;
  size_t tmp___34 ;
  char *tmp___35 ;
  char *tmp___56 ;
  int tmp___57 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  int tmp___62 ;
  char *tmp___63 ;
  char *oflag ;
  char *tmp___64 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___69 ;
  size_t tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___77 ;
  size_t tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___87 ;
  int tmp___88 ;
  Ns_Set *tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___93 ;
  char *tmp___94 ;
  int tmp___95 ;
  char *tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  char *tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  char *tmp___102 ;
  char *tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc < 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"option ?arg ...?");
    return (1);
  }
  tmp = Tcl_GetIndexFromObj(interp, (*(objv + 1)), opts___8, (char *)"option", 0,
                            & opt);
  if (tmp != 0) {
    return (1);
  }
  if (opt == 4) {
    opt = 22;
  }
  switch (opt) {
  case 1: 
  tablePtr = & itPtr->sets;
  hPtr = Tcl_FirstHashEntry(tablePtr, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    if (tablePtr->keyType == 1) {
      tmp___0 = hPtr->key.oneWordValue;
    } else {
      if (tablePtr->keyType == -1) {
        tmp___0 = hPtr->key.oneWordValue;
      } else {
        tmp___0 = hPtr->key.string;
      }
    }
    key___1 = tmp___0;
    if ((int )(*key___1) == 100) {
      set = (Ns_Set *)hPtr->clientData;
      Ns_SetFree(set);
    } else {
      if ((int )(*key___1) == 115) {
        set = (Ns_Set *)hPtr->clientData;
        Ns_SetFree(set);
      }
    }
    hPtr = Tcl_NextHashEntry(& search);
  }
  Tcl_DeleteHashTable(tablePtr);
  Tcl_InitHashTable(tablePtr, 0);
  break;
  case 18: ;
  if (objc == 2) {
    tablePtr = & itPtr->sets;
    locked = 0;
  } else {
    tmp___2 = Tcl_GetString((*(objv + 2)));
    if ((int )(*tmp___2) == (int )(*"-shared")) {
      if (0) {
        tmp___59 = Tcl_GetString((*(objv + 2)));
        __s1_len = strlen((char const   *)tmp___59);
        __s2_len = strlen("-shared");
        tmp___60 = Tcl_GetString((*(objv + 2)));
        tmp___61 = Tcl_GetString((*(objv + 2)));
        if ((unsigned int )((void const   *)(tmp___60 + 1)) - (unsigned int )((void const   *)tmp___61) ==
            1U) {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("-shared" + 1)) - (unsigned int )((void const   *)"-shared") ==
                   1U)) {
              tmp___62 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___62 = 1;
              } else {
                tmp___62 = 0;
              }
            }
          } else {
            tmp___62 = 0;
          }
        } else {
          goto _L___0;
        }
        if (tmp___62) {
          if (__s1_len < __s2_len) {
            tmp___34 = __s1_len;
          } else {
            tmp___34 = __s2_len;
          }
          tmp___35 = Tcl_GetString((*(objv + 2)));
          tmp___33 = memcmp((void const   *)((char const   *)tmp___35), (void const   *)"-shared",
                            tmp___34 + 1U);
        } else {
          tmp___56 = Tcl_GetString((*(objv + 2)));
          tmp___57 = strcmp((char const   *)tmp___56, "-shared");
          tmp___33 = tmp___57;
        }
      } else {
        tmp___56 = Tcl_GetString((*(objv + 2)));
        tmp___57 = strcmp((char const   *)tmp___56, "-shared");
        tmp___33 = tmp___57;
      }
      if (tmp___33 == 0) {
        if ((unsigned int )itPtr->servPtr == (unsigned int )((void *)0)) {
          tmp___1 = NoServer(interp);
          return (tmp___1);
        }
        tablePtr = & (itPtr->servPtr)->sets.table;
        locked = 1;
        Ns_MutexLock(& (itPtr->servPtr)->sets.lock);
      } else {
        Tcl_WrongNumArgs(interp, 2, objv, (char *)"?-shared?");
        return (1);
      }
    } else {
      Tcl_WrongNumArgs(interp, 2, objv, (char *)"?-shared?");
      return (1);
    }
  }
  if ((unsigned int )tablePtr != (unsigned int )((void *)0)) {
    hPtr = Tcl_FirstHashEntry(tablePtr, & search);
    while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
      if (tablePtr->keyType == 1) {
        tmp___63 = hPtr->key.oneWordValue;
      } else {
        if (tablePtr->keyType == -1) {
          tmp___63 = hPtr->key.oneWordValue;
        } else {
          tmp___63 = hPtr->key.string;
        }
      }
      Tcl_AppendElement(interp, tmp___63);
      hPtr = Tcl_NextHashEntry(& search);
    }
  }
  if (locked) {
    Ns_MutexUnlock(& (itPtr->servPtr)->sets.lock);
  }
  break;
  case 22: ;
  case 2: ;
  case 27: 
  flags = 1;
  i = 2;
  if (objc > 2) {
    tmp___64 = Tcl_GetString((*(objv + 2)));
    oflag = tmp___64;
    if ((int )(*oflag) == (int )(*"-shared")) {
      if (0) {
        __s1_len___0 = strlen((char const   *)oflag);
        __s2_len___0 = strlen("-shared");
        if (! ((unsigned int )((void const   *)(oflag + 1)) - (unsigned int )((void const   *)oflag) ==
               1U)) {
          goto _L___2;
        } else {
          if (__s1_len___0 >= 4U) {
            _L___2: 
            if (! ((unsigned int )((void const   *)("-shared" + 1)) - (unsigned int )((void const   *)"-shared") ==
                   1U)) {
              tmp___72 = 1;
            } else {
              if (__s2_len___0 >= 4U) {
                tmp___72 = 1;
              } else {
                tmp___72 = 0;
              }
            }
          } else {
            tmp___72 = 0;
          }
        }
        if (tmp___72) {
          if (__s1_len___0 < __s2_len___0) {
            tmp___70 = __s1_len___0;
          } else {
            tmp___70 = __s2_len___0;
          }
          tmp___69 = memcmp((void const   *)((char const   *)oflag), (void const   *)"-shared",
                            tmp___70 + 1U);
        } else {
          tmp___71 = strcmp((char const   *)oflag, "-shared");
          tmp___69 = tmp___71;
        }
      } else {
        tmp___71 = strcmp((char const   *)oflag, "-shared");
        tmp___69 = tmp___71;
      }
      if (tmp___69 == 0) {
        flags |= 2;
        i ++;
      } else {
        goto _L___5;
      }
    } else {
      _L___5: 
      if ((int )(*oflag) == (int )(*"-persist")) {
        if (0) {
          __s1_len___1 = strlen((char const   *)oflag);
          __s2_len___1 = strlen("-persist");
          if (! ((unsigned int )((void const   *)(oflag + 1)) - (unsigned int )((void const   *)oflag) ==
                 1U)) {
            goto _L___4;
          } else {
            if (__s1_len___1 >= 4U) {
              _L___4: 
              if (! ((unsigned int )((void const   *)("-persist" + 1)) - (unsigned int )((void const   *)"-persist") ==
                     1U)) {
                tmp___80 = 1;
              } else {
                if (__s2_len___1 >= 4U) {
                  tmp___80 = 1;
                } else {
                  tmp___80 = 0;
                }
              }
            } else {
              tmp___80 = 0;
            }
          }
          if (tmp___80) {
            if (__s1_len___1 < __s2_len___1) {
              tmp___78 = __s1_len___1;
            } else {
              tmp___78 = __s2_len___1;
            }
            tmp___77 = memcmp((void const   *)((char const   *)oflag), (void const   *)"-persist",
                              tmp___78 + 1U);
          } else {
            tmp___79 = strcmp((char const   *)oflag, "-persist");
            tmp___77 = tmp___79;
          }
        } else {
          tmp___79 = strcmp((char const   *)oflag, "-persist");
          tmp___77 = tmp___79;
        }
        if (tmp___77 == 0) {
          flags |= 2;
          i ++;
        }
      }
    }
  }
  switch (opt) {
  case 22: ;
  if (i < objc) {
    tmp___83 = i;
    i ++;
    name = Tcl_GetString((*(objv + tmp___83)));
  } else {
    name = (char *)((void *)0);
  }
  set = Ns_SetCreate(name);
  while (i < objc) {
    tmp___84 = i;
    i ++;
    key___1 = Tcl_GetString((*(objv + tmp___84)));
    if (i < objc) {
      tmp___87 = i;
      i ++;
      val = Tcl_GetString((*(objv + tmp___87)));
    } else {
      val = (char *)((void *)0);
    }
    Ns_SetPut(set, key___1, val);
  }
  EnterSet(itPtr, set, flags);
  break;
  case 2: ;
  if (i >= objc) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"?-shared? setId");
    return (1);
  }
  tmp___88 = LookupObjSet(itPtr, (*(objv + i)), 0, & set);
  if (tmp___88 != 0) {
    return (1);
  }
  tmp___89 = Ns_SetCopy(set);
  EnterSet(itPtr, tmp___89, flags);
  break;
  case 27: ;
  if (objc - i < 1) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"?-shared? setId ?splitChar");
    return (1);
  }
  tmp___90 = i;
  i ++;
  tmp___91 = LookupObjSet(itPtr, (*(objv + tmp___90)), 0, & set);
  if (tmp___91 != 0) {
    return (1);
  }
  if (i < objc) {
    split = Tcl_GetString((*(objv + i)));
  } else {
    split = (char *)".";
  }
  sets = Ns_SetSplit(set, (*split));
  i = 0;
  while ((unsigned int )(*(sets + i)) != (unsigned int )((void *)0)) {
    EnterSet(itPtr, (*(sets + i)), flags);
    i ++;
  }
  ns_free((void *)sets);
  break;
  }
  break;
  default: ;
  if (objc < 3) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"setId ?args?");
    return (1);
  }
  tmp___93 = LookupObjSet(itPtr, (*(objv + 2)), 0, & set);
  if (tmp___93 != 0) {
    return (1);
  }
  switch (opt) {
  case 0: ;
  case 26: ;
  case 21: ;
  case 23: ;
  case 8: ;
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"setId");
    return (1);
  }
  switch (opt) {
  case 0: 
  Tcl_DStringInit(& ds);
  i = 0;
  while (i < set->size) {
    Tcl_DStringAppendElement(& ds, (set->fields + i)->name);
    Tcl_DStringAppendElement(& ds, (set->fields + i)->value);
    i ++;
  }
  Tcl_DStringResult(interp, & ds);
  break;
  case 26: 
  objPtr = Tcl_NewIntObj(set->size);
  Tcl_SetObjResult(interp, objPtr);
  break;
  case 21: 
  Tcl_SetResult(interp, set->name, (Tcl_FreeProc *)1);
  break;
  case 23: 
  Ns_SetPrint(set);
  break;
  case 8: 
  tmp___94 = Tcl_GetString((*(objv + 2)));
  Ns_TclFreeSet(interp, tmp___94);
  break;
  }
  break;
  case 7: ;
  case 13: ;
  case 9: ;
  case 14: ;
  case 6: ;
  case 12: ;
  case 29: ;
  case 16: ;
  if (objc != 4) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"setId key");
    return (1);
  }
  key___1 = Tcl_GetString((*(objv + 3)));
  switch (opt) {
  case 7: 
  tmp___95 = Ns_SetFind(set, key___1);
  objPtr = Tcl_NewIntObj(tmp___95);
  Tcl_SetObjResult(interp, objPtr);
  break;
  case 9: 
  tmp___96 = Ns_SetGet(set, key___1);
  Tcl_SetResult(interp, tmp___96, (Tcl_FreeProc *)1);
  break;
  case 5: ;
  case 6: 
  Ns_SetDeleteKey(set, key___1);
  break;
  case 29: 
  tmp___97 = Ns_SetUnique(set, key___1);
  objPtr = Tcl_NewIntObj(tmp___97);
  Tcl_SetObjResult(interp, objPtr);
  break;
  case 13: 
  tmp___98 = Ns_SetIFind(set, key___1);
  objPtr = Tcl_NewIntObj(tmp___98);
  Tcl_SetObjResult(interp, objPtr);
  break;
  case 14: 
  tmp___99 = Ns_SetIGet(set, key___1);
  Tcl_SetResult(interp, tmp___99, (Tcl_FreeProc *)1);
  break;
  case 11: ;
  case 12: 
  Ns_SetIDeleteKey(set, key___1);
  break;
  case 16: 
  tmp___100 = Ns_SetIUnique(set, key___1);
  objPtr = Tcl_NewIntObj(tmp___100);
  Tcl_SetObjResult(interp, objPtr);
  break;
  }
  break;
  case 31: ;
  case 15: ;
  case 17: ;
  case 5: ;
  case 28: ;
  if (objc != 4) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"setId index");
    return (1);
  }
  tmp___101 = Tcl_GetIntFromObj(interp, (*(objv + 3)), & i);
  if (tmp___101 != 0) {
    return (1);
  }
  if (i < 0) {
    tmp___102 = Tcl_GetString((*(objv + 3)));
    Tcl_AppendResult(interp, "invalid index \"", tmp___102, "\": must be >= 0", (void *)0);
    return (1);
  }
  if (i >= set->size) {
    tmp___103 = Tcl_GetString((*(objv + 3)));
    Tcl_AppendResult(interp, "invalid index \"", tmp___103, "\": beyond range of set fields",
                     (void *)0);
    return (1);
  }
  switch (opt) {
  case 31: 
  val = (set->fields + i)->value;
  Tcl_SetResult(interp, val, (Tcl_FreeProc *)1);
  break;
  case 15: 
  val = (set->fields + i)->value;
  if (val) {
    tmp___104 = 0;
  } else {
    tmp___104 = 1;
  }
  objPtr = Tcl_NewBooleanObj(tmp___104);
  Tcl_SetObjResult(interp, objPtr);
  break;
  case 17: 
  key___1 = (set->fields + i)->name;
  Tcl_SetResult(interp, key___1, (Tcl_FreeProc *)1);
  break;
  case 5: 
  Ns_SetDelete(set, i);
  break;
  case 28: 
  Ns_SetTrunc(set, i);
  break;
  }
  break;
  case 25: ;
  case 30: ;
  case 3: ;
  case 10: ;
  if (objc != 5) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"setId key value");
    return (1);
  }
  key___1 = Tcl_GetString((*(objv + 3)));
  val = Tcl_GetString((*(objv + 4)));
  switch (opt) {
  case 30: 
  Ns_SetDeleteKey(set, key___1);
  i = Ns_SetPut(set, key___1, val);
  break;
  case 10: 
  i = Ns_SetIFind(set, key___1);
  if (i < 0) {
    i = Ns_SetPut(set, key___1, val);
  }
  break;
  case 3: 
  i = Ns_SetFind(set, key___1);
  if (i < 0) {
    i = Ns_SetPut(set, key___1, val);
  }
  break;
  case 25: 
  i = Ns_SetPut(set, key___1, val);
  break;
  }
  objPtr = Tcl_NewIntObj(i);
  Tcl_SetObjResult(interp, objPtr);
  break;
  case 19: ;
  case 20: ;
  if (objc != 4) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"setTo setFrom");
    return (1);
  }
  tmp___105 = LookupObjSet(itPtr, (*(objv + 3)), 0, & set2Ptr);
  if (tmp___105 != 0) {
    return (1);
  }
  if (opt == 19) {
    Ns_SetMerge(set, set2Ptr);
  } else {
    Ns_SetMove(set, set2Ptr);
  }
  Tcl_SetObjResult(interp, (*(objv + 2)));
  break;
  }
  }
  return (0);
}
}
int NsTclParseHeaderCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ NsInterp *itPtr ;
  Ns_Set *set ;
  Ns_HeaderCaseDisposition disp ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___20 ;
  size_t tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;

  {
  itPtr = (NsInterp *)arg;
  if (argc != 3) {
    if (argc != 4) {
      Tcl_AppendResult(interp, "wrong # of args: should be \"", (*(argv + 0)), " set header ?tolower|toupper|preserve?\"",
                       (void *)0);
      return (1);
    }
  }
  tmp = LookupSet(itPtr, (*(argv + 1)), 0, & set);
  if (tmp != 0) {
    return (1);
  }
  if (argc < 4) {
    disp = (enum __anonenum_Ns_HeaderCaseDisposition_68 )1;
  } else {
    if ((int )(*((*(argv + 3)))) == (int )(*"toupper")) {
      if (0) {
        __s1_len___1 = strlen((char const   *)(*(argv + 3)));
        __s2_len___1 = strlen("toupper");
        if (! ((unsigned int )((void const   *)((*(argv + 3)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                         3))) ==
               1U)) {
          goto _L___5;
        } else {
          if (__s1_len___1 >= 4U) {
            _L___5: 
            if (! ((unsigned int )((void const   *)("toupper" + 1)) - (unsigned int )((void const   *)"toupper") ==
                   1U)) {
              tmp___23 = 1;
            } else {
              if (__s2_len___1 >= 4U) {
                tmp___23 = 1;
              } else {
                tmp___23 = 0;
              }
            }
          } else {
            tmp___23 = 0;
          }
        }
        if (tmp___23) {
          if (__s1_len___1 < __s2_len___1) {
            tmp___21 = __s1_len___1;
          } else {
            tmp___21 = __s2_len___1;
          }
          tmp___20 = memcmp((void const   *)((char const   *)(*(argv + 3))), (void const   *)"toupper",
                            tmp___21 + 1U);
        } else {
          tmp___22 = strcmp((char const   *)(*(argv + 3)), "toupper");
          tmp___20 = tmp___22;
        }
      } else {
        tmp___22 = strcmp((char const   *)(*(argv + 3)), "toupper");
        tmp___20 = tmp___22;
      }
      if (tmp___20 == 0) {
        disp = (enum __anonenum_Ns_HeaderCaseDisposition_68 )2;
      } else {
        goto _L___6;
      }
    } else {
      _L___6: 
      if ((int )(*((*(argv + 3)))) == (int )(*"tolower")) {
        if (0) {
          __s1_len___0 = strlen((char const   *)(*(argv + 3)));
          __s2_len___0 = strlen("tolower");
          if (! ((unsigned int )((void const   *)((*(argv + 3)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                           3))) ==
                 1U)) {
            goto _L___2;
          } else {
            if (__s1_len___0 >= 4U) {
              _L___2: 
              if (! ((unsigned int )((void const   *)("tolower" + 1)) - (unsigned int )((void const   *)"tolower") ==
                     1U)) {
                tmp___15 = 1;
              } else {
                if (__s2_len___0 >= 4U) {
                  tmp___15 = 1;
                } else {
                  tmp___15 = 0;
                }
              }
            } else {
              tmp___15 = 0;
            }
          }
          if (tmp___15) {
            if (__s1_len___0 < __s2_len___0) {
              tmp___13 = __s1_len___0;
            } else {
              tmp___13 = __s2_len___0;
            }
            tmp___12 = memcmp((void const   *)((char const   *)(*(argv + 3))), (void const   *)"tolower",
                              tmp___13 + 1U);
          } else {
            tmp___14 = strcmp((char const   *)(*(argv + 3)), "tolower");
            tmp___12 = tmp___14;
          }
        } else {
          tmp___14 = strcmp((char const   *)(*(argv + 3)), "tolower");
          tmp___12 = tmp___14;
        }
        if (tmp___12 == 0) {
          disp = (enum __anonenum_Ns_HeaderCaseDisposition_68 )1;
        } else {
          goto _L___3;
        }
      } else {
        _L___3: 
        if ((int )(*((*(argv + 3)))) == (int )(*"preserve")) {
          if (0) {
            __s1_len = strlen((char const   *)(*(argv + 3)));
            __s2_len = strlen("preserve");
            if (! ((unsigned int )((void const   *)((*(argv + 3)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                             3))) ==
                   1U)) {
              goto _L___0;
            } else {
              if (__s1_len >= 4U) {
                _L___0: 
                if (! ((unsigned int )((void const   *)("preserve" + 1)) - (unsigned int )((void const   *)"preserve") ==
                       1U)) {
                  tmp___7 = 1;
                } else {
                  if (__s2_len >= 4U) {
                    tmp___7 = 1;
                  } else {
                    tmp___7 = 0;
                  }
                }
              } else {
                tmp___7 = 0;
              }
            }
            if (tmp___7) {
              if (__s1_len < __s2_len) {
                tmp___5 = __s1_len;
              } else {
                tmp___5 = __s2_len;
              }
              tmp___4 = memcmp((void const   *)((char const   *)(*(argv + 3))), (void const   *)"preserve",
                               tmp___5 + 1U);
            } else {
              tmp___6 = strcmp((char const   *)(*(argv + 3)), "preserve");
              tmp___4 = tmp___6;
            }
          } else {
            tmp___6 = strcmp((char const   *)(*(argv + 3)), "preserve");
            tmp___4 = tmp___6;
          }
          if (tmp___4 == 0) {
            disp = (enum __anonenum_Ns_HeaderCaseDisposition_68 )0;
          } else {
            Tcl_AppendResult(interp, "unknown case disposition \"", (*(argv + 3)),
                             "\":  should be toupper, tolower, or preserve", (void *)0);
            return (1);
          }
        } else {
          Tcl_AppendResult(interp, "unknown case disposition \"", (*(argv + 3)), "\":  should be toupper, tolower, or preserve",
                           (void *)0);
          return (1);
        }
      }
    }
  }
  tmp___24 = Ns_ParseHeader(set, (*(argv + 2)), disp);
  if (tmp___24 != 0) {
    Tcl_AppendResult(interp, "invalid header:  ", (*(argv + 2)), (void *)0);
    return (1);
  }
  return (0);
}
}
static int EnterSet(NsInterp *itPtr , Ns_Set *set , int flags ) 
{ Tcl_HashTable *tablePtr ;
  Tcl_HashEntry *hPtr ;
  int new ;
  int next ;
  unsigned char type ;
  char buf[20] ;
  int tmp ;

  {
  if (flags & 2) {
    if ((unsigned int )itPtr->servPtr == (unsigned int )((void *)0)) {
      tmp = NoServer(itPtr->interp);
      return (tmp);
    }
    if (flags & 1) {
      type = (unsigned char )'s';
    } else {
      type = (unsigned char )'p';
    }
    tablePtr = & (itPtr->servPtr)->sets.table;
    Ns_MutexLock(& (itPtr->servPtr)->sets.lock);
  } else {
    tablePtr = & itPtr->sets;
    if (flags & 1) {
      type = (unsigned char )'d';
    } else {
      type = (unsigned char )'t';
    }
  }
  next = tablePtr->numEntries;
  while (1) {
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%c%u", type,
            next);
    next ++;
    hPtr = ((*(tablePtr->createProc)))(tablePtr, buf, & new);
    if (! (! new)) {
      break;
    }
  }
  hPtr->clientData = (void *)set;
  Tcl_AppendElement(itPtr->interp, buf);
  if (flags & 2) {
    Ns_MutexUnlock(& (itPtr->servPtr)->sets.lock);
  }
  return (0);
}
}
static int LookupObjSet(NsInterp *itPtr , Tcl_Obj *idPtr , int delete , Ns_Set **setPtr ) 
{ char *tmp ;
  int tmp___0 ;

  {
  tmp = Tcl_GetString(idPtr);
  tmp___0 = LookupSet(itPtr, tmp, delete, setPtr);
  return (tmp___0);
}
}
static int LookupInterpSet(Tcl_Interp *interp , char *id , int delete , Ns_Set **setPtr ) 
{ NsInterp *itPtr ;
  int tmp ;

  {
  itPtr = NsGetInterp(interp);
  if ((unsigned int )itPtr == (unsigned int )((void *)0)) {
    Tcl_SetResult(interp, (char *)"ns_set not supported", (Tcl_FreeProc *)0);
    return (1);
  }
  tmp = LookupSet(itPtr, id, delete, setPtr);
  return (tmp);
}
}
static int LookupSet(NsInterp *itPtr , char *id , int delete , Ns_Set **setPtr ) 
{ Tcl_HashTable *tablePtr ;
  Tcl_HashEntry *hPtr ;
  Ns_Set *set ;
  int tmp ;

  {
  set = (Ns_Set *)((void *)0);
  if ((int )(*id) == 115) {
    goto _L;
  } else {
    if ((int )(*id) == 112) {
      _L: 
      if ((unsigned int )itPtr->servPtr == (unsigned int )((void *)0)) {
        tmp = NoServer(itPtr->interp);
        return (tmp);
      }
      tablePtr = & (itPtr->servPtr)->sets.table;
      Ns_MutexLock(& (itPtr->servPtr)->sets.lock);
    } else {
      tablePtr = & itPtr->sets;
    }
  }
  hPtr = ((*(tablePtr->findProc)))(tablePtr, id);
  if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    set = (Ns_Set *)hPtr->clientData;
    if (delete) {
      Tcl_DeleteHashEntry(hPtr);
    }
  }
  if ((int )(*id) == 115) {
    Ns_MutexUnlock(& (itPtr->servPtr)->sets.lock);
  } else {
    if ((int )(*id) == 112) {
      Ns_MutexUnlock(& (itPtr->servPtr)->sets.lock);
    }
  }
  if ((unsigned int )set == (unsigned int )((void *)0)) {
    Tcl_AppendResult(itPtr->interp, "no such set: ", id, (void *)0);
    return (1);
  }
  (*setPtr) = set;
  return (0);
}
}
static int NoServer(Tcl_Interp *interp ) 
{ 

  {
  Tcl_SetResult(interp, (char *)"no server for shared sets", (Tcl_FreeProc *)0);
  return (1);
}
}
extern Tcl_Obj *Tcl_DuplicateObj(Tcl_Obj *objPtr ) ;
extern int Tcl_TraceVar2(Tcl_Interp *interp , char *part1 , char *part2 , int flags ,
                         Tcl_VarTraceProc *proc , ClientData clientData ) ;
extern int Tcl_UnsetVar(Tcl_Interp *interp , char *varName , int flags ) ;
extern int Tcl_VarEval(Tcl_Interp *interp  , ...) ;
extern ClientData Tcl_VarTraceInfo(Tcl_Interp *interp , char *varName , int flags ,
                                   Tcl_VarTraceProc *procPtr , ClientData prevClientData ) ;
void Ns_CsInit(Ns_Cs *csPtr ) ;
void Ns_CsDestroy(Ns_Cs *csPtr ) ;
static void ShareUnsetVar(Tcl_Interp *interp , char *varName , NsShareVar *valuePtr ) ;
static char *ShareTraceProc(ClientData clientData , Tcl_Interp *interp , char *name1 ,
                            char *name2 , int flags ) ;
static int ShareVar(NsInterp *itPtr , Tcl_Interp *interp , char *varName ) ;
static int InitShare(NsServer *servPtr , Tcl_Interp *interp , char *varName , char *script ) ;
static void RegisterShare(NsInterp *itPtr , Tcl_Interp *interp , char *varName , NsShareVar *valuePtr ) ;
static char *GetGlobalizedName(Tcl_DString *dsPtr , char *varName ) ;
int NsTclShareCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ NsInterp *itPtr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  itPtr = (NsInterp *)arg;
  if (argc < 2) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " ?-init script? varName ?varName ...?\"",
                     (void *)0);
    return (1);
  }
  if ((unsigned int )itPtr == (unsigned int )((void *)0)) {
    Tcl_SetResult(interp, (char *)"no server", (Tcl_FreeProc *)0);
    return (1);
  }
  if ((int )(*((*(argv + 1)))) == (int )(*"-init")) {
    if (0) {
      __s1_len = strlen((char const   *)(*(argv + 1)));
      __s2_len = strlen("-init");
      if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                       1))) ==
             1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: 
          if (! ((unsigned int )((void const   *)("-init" + 1)) - (unsigned int )((void const   *)"-init") ==
                 1U)) {
            tmp___9 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___9 = 1;
            } else {
              tmp___9 = 0;
            }
          }
        } else {
          tmp___9 = 0;
        }
      }
      if (tmp___9) {
        if (__s1_len < __s2_len) {
          tmp___7 = __s1_len;
        } else {
          tmp___7 = __s2_len;
        }
        tmp___6 = memcmp((void const   *)((char const   *)(*(argv + 1))), (void const   *)"-init",
                         tmp___7 + 1U);
      } else {
        tmp___8 = strcmp((char const   *)(*(argv + 1)), "-init");
        tmp___6 = tmp___8;
      }
    } else {
      tmp___8 = strcmp((char const   *)(*(argv + 1)), "-init");
      tmp___6 = tmp___8;
    }
    if (tmp___6 == 0) {
      if (argc != 4) {
        Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " -init script varName\"",
                         (void *)0);
        return (1);
      }
      tmp = ShareVar(itPtr, interp, (*(argv + 3)));
      if (tmp != 0) {
        return (1);
      } else {
        tmp___0 = InitShare(itPtr->servPtr, interp, (*(argv + 3)), (*(argv + 2)));
        if (tmp___0 != 0) {
          return (1);
        }
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    argc --;
    argv ++;
    while (argc > 0) {
      tmp___1 = ShareVar(itPtr, interp, (*argv));
      if (tmp___1 != 0) {
        return (1);
      }
      argc --;
      argv ++;
    }
  }
  return (0);
}
}
static int InitShare(NsServer *servPtr , Tcl_Interp *interp , char *varName , char *script ) 
{ Tcl_HashEntry *hPtr ;
  int new ;
  int result ;

  {
  Ns_MutexLock(& servPtr->share.lock);
  hPtr = ((*(servPtr->share.inits.createProc)))(& servPtr->share.inits, varName, & new);
  if (! new) {
    while ((unsigned int )hPtr->clientData == (unsigned int )((void *)0)) {
      Ns_CondWait(& servPtr->share.cond, & servPtr->share.lock);
    }
    result = 0;
  } else {
    Ns_MutexUnlock(& servPtr->share.lock);
    result = Tcl_EvalEx(interp, script, -1, 0);
    Ns_MutexLock(& servPtr->share.lock);
    hPtr->clientData = (void *)1;
    Ns_CondBroadcast(& servPtr->share.cond);
  }
  Ns_MutexUnlock(& servPtr->share.lock);
  return (result);
}
}
static int ShareVar(NsInterp *itPtr , Tcl_Interp *interp , char *varName ) 
{ NsServer *servPtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_DString ds ;
  NsShareVar *valuePtr ;
  char *s ;
  char *globalizedVarName ;
  int new ;
  char *tmp___0 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *string ;
  int length ;
  int argc ;
  char **argv ;
  int x ;
  Tcl_HashEntry *newEntry ;
  Tcl_Obj *newObj ;
  int new___0 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  servPtr = itPtr->servPtr;
  tmp___0 = strchr((char const   *)varName, '(');
  s = tmp___0;
  if ((unsigned int )s != (unsigned int )((void *)0)) {
    tmp___2 = strchr((char const   *)s, ')');
    if ((unsigned int )tmp___2 != (unsigned int )((void *)0)) {
      Tcl_AppendResult(interp, "can\'t share ", varName, ": must share whole arrays",
                       (char *)((void *)0));
      return (1);
    }
  }
  globalizedVarName = GetGlobalizedName(& ds, varName);
  Ns_CsEnter(& servPtr->share.cs);
  hPtr = ((*(servPtr->share.vars.createProc)))(& servPtr->share.vars, globalizedVarName,
                                               & new);
  if (! new) {
    valuePtr = (NsShareVar *)hPtr->clientData;
  } else {
    valuePtr = (NsShareVar *)ns_calloc(1U, sizeof(NsShareVar ));
    Ns_CsInit(& valuePtr->lock);
    valuePtr->flags = 0;
    tmp___3 = Tcl_VarEval(interp, "info exists ", globalizedVarName, (void *)0);
    if (tmp___3 != 0) {
      Tcl_AppendResult(interp, "error sharing ", globalizedVarName, " can\'t determine existence of variable",
                       (char *)((void *)0));
      Tcl_DStringFree(& ds);
      return (1);
    }
    if (0) {
      __s1_len = strlen((char const   *)interp->result);
      __s2_len = strlen("1");
      if (! ((unsigned int )((void const   *)(interp->result + 1)) - (unsigned int )((void const   *)interp->result) ==
             1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: 
          if (! ((unsigned int )((void const   *)("1" + 1)) - (unsigned int )((void const   *)"1") ==
                 1U)) {
            tmp___13 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___13 = 1;
            } else {
              tmp___13 = 0;
            }
          }
        } else {
          tmp___13 = 0;
        }
      }
      if (tmp___13) {
        if (__s1_len < __s2_len) {
          tmp___11 = __s1_len;
        } else {
          tmp___11 = __s2_len;
        }
        tmp___10 = memcmp((void const   *)((char const   *)interp->result), (void const   *)"1",
                          tmp___11 + 1U);
      } else {
        tmp___12 = strcmp((char const   *)interp->result, "1");
        tmp___10 = tmp___12;
      }
    } else {
      tmp___12 = strcmp((char const   *)interp->result, "1");
      tmp___10 = tmp___12;
    }
    if (tmp___10 == 0) {
      valuePtr->objPtr = Tcl_GetVar2Ex(interp, globalizedVarName, (char *)((void *)0),
                                       512);
      if ((unsigned int )valuePtr->objPtr != (unsigned int )((void *)0)) {
        string = Tcl_GetStringFromObj(valuePtr->objPtr, & length);
        valuePtr->objPtr = Tcl_NewStringObj(string, length);
        (valuePtr->objPtr)->refCount = (valuePtr->objPtr)->refCount + 1;
        valuePtr->flags = 1;
      } else {
        tmp___5 = Tcl_VarEval(interp, "array get ", globalizedVarName, (void *)0);
        if (tmp___5 == 0) {
          Tcl_InitHashTable(& valuePtr->array, 0);
          tmp___4 = Tcl_SplitList(interp, interp->result, & argc, & argv);
          if (tmp___4 == 0) {
            x = 0;
            while (x < argc) {
              newEntry = ((*(valuePtr->array.createProc)))(& valuePtr->array, (*(argv +
                                                                                 x)),
                                                           & new___0);
              newObj = Tcl_NewStringObj((*(argv + (x + 1))), -1);
              newObj->refCount = newObj->refCount + 1;
              newEntry->clientData = (void *)newObj;
              x += 2;
            }
            Tcl_Free((char *)argv);
          }
          valuePtr->flags = 2;
        }
      }
      Tcl_VarEval(interp, "unset ", globalizedVarName, (void *)0);
    }
    hPtr->clientData = (void *)valuePtr;
  }
  valuePtr->shareCount ++;
  RegisterShare(itPtr, interp, globalizedVarName, valuePtr);
  Tcl_VarEval(interp, "global ", varName, (void *)0);
  Ns_CsLeave(& servPtr->share.cs);
  Tcl_DStringFree(& ds);
  return (0);
}
}
static void RegisterShare(NsInterp *itPtr , Tcl_Interp *interp , char *varName , NsShareVar *valuePtr ) 
{ int traceFlags ;
  ClientData data ;
  ClientData shareData ;
  Tcl_Obj *tmp ;
  Tcl_HashSearch search ;
  Tcl_HashEntry *hPtr ;
  char *key___1 ;
  Tcl_Obj *objPtr ;
  char *tmp___0 ;
  Tcl_Obj *tmp___1 ;
  int tmp___2 ;

  {
  traceFlags = 2160;
  shareData = (void *)(& RegisterShare);
  data = (void *)0;
  while (1) {
    data = Tcl_VarTraceInfo(interp, varName, traceFlags, & ShareTraceProc, data);
    if ((unsigned int )data != (unsigned int )shareData) {
      if (! ((unsigned int )data != (unsigned int )((void *)0))) {
        break;
      }
    } else {
      break;
    }
  }
  if ((unsigned int )data == (unsigned int )((void *)0)) {
    if (valuePtr->flags & 1) {
      tmp = Tcl_DuplicateObj(valuePtr->objPtr);
      Tcl_SetVar2Ex(interp, varName, (char *)((void *)0), tmp, 1);
    } else {
      if (valuePtr->flags & 2) {
        hPtr = Tcl_FirstHashEntry(& valuePtr->array, & search);
        while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
          if (valuePtr->array.keyType == 1) {
            tmp___0 = hPtr->key.oneWordValue;
          } else {
            if (valuePtr->array.keyType == -1) {
              tmp___0 = hPtr->key.oneWordValue;
            } else {
              tmp___0 = hPtr->key.string;
            }
          }
          key___1 = tmp___0;
          objPtr = (Tcl_Obj *)hPtr->clientData;
          tmp___1 = Tcl_DuplicateObj(objPtr);
          Tcl_SetVar2Ex(interp, varName, key___1, tmp___1, 1);
          hPtr = Tcl_NextHashEntry(& search);
        }
      }
    }
    tmp___2 = Tcl_TraceVar2(interp, varName, (char *)((void *)0), traceFlags, & ShareTraceProc,
                            shareData);
    if (tmp___2 != 0) {
      Ns_Fatal((char *)"ns_share: could not trace: %s", varName);
    }
  }
  return;
}
}
static void ShareUnsetVar(Tcl_Interp *interp , char *varName , NsShareVar *valuePtr ) 
{ int tmp ;

  {
  valuePtr->flags |= 8;
  Tcl_UnsetVar(interp, varName, 0);
  tmp = Tcl_TraceVar2(interp, varName, (char *)((void *)0), 2160, & ShareTraceProc,
                      (void *)0);
  if (tmp != 0) {
    Ns_Fatal((char *)"ns_share: could not trace: %s", varName);
  }
  valuePtr->flags &= -9;
  return;
}
}
static char *ShareTraceProc(ClientData clientData , Tcl_Interp *interp , char *name1 ,
                            char *name2 , int flags ) 
{ NsShareVar *valuePtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashEntry *nextPtr ;
  Tcl_HashSearch search ;
  Tcl_Obj *objPtr ;
  Tcl_Obj *oldObjPtr ;
  Tcl_Obj *newObjPtr ;
  int new ;
  int destroyed ;
  int bail ;
  char *string ;
  int length ;
  char *name ;
  Tcl_DString ds ;
  NsInterp *itPtr ;
  NsInterp *tmp ;
  NsServer *servPtr ;
  char *tmp___0 ;
  char *tmp___1 ;
  Tcl_Obj *tmp___2 ;
  int tmp___3 ;

  {
  destroyed = 0;
  bail = 0;
  tmp = NsGetInterp(interp);
  itPtr = tmp;
  servPtr = itPtr->servPtr;
  tmp___0 = GetGlobalizedName(& ds, name1);
  name = tmp___0;
  Ns_CsEnter(& servPtr->share.cs);
  hPtr = ((*(servPtr->share.vars.findProc)))(& servPtr->share.vars, name);
  if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
    Ns_CsLeave(& servPtr->share.cs);
    goto done;
  }
  valuePtr = (NsShareVar *)hPtr->clientData;
  if (flags & 256) {
    valuePtr->shareCount --;
    if (valuePtr->shareCount == 0) {
      destroyed = 1;
      Tcl_DeleteHashEntry(hPtr);
    } else {
      bail = 1;
    }
  }
  if (valuePtr->flags & 8) {
    bail = 1;
  }
  Ns_CsLeave(& servPtr->share.cs);
  if (bail) {
    goto done;
  }
  Ns_CsEnter(& valuePtr->lock);
  if (flags & 2048) {
    if (valuePtr->flags & 2) {
      ShareUnsetVar(interp, name, valuePtr);
      hPtr = Tcl_FirstHashEntry(& valuePtr->array, & search);
      while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
        if (valuePtr->array.keyType == 1) {
          tmp___1 = hPtr->key.oneWordValue;
        } else {
          if (valuePtr->array.keyType == -1) {
            tmp___1 = hPtr->key.oneWordValue;
          } else {
            tmp___1 = hPtr->key.string;
          }
        }
        name2 = tmp___1;
        objPtr = (Tcl_Obj *)hPtr->clientData;
        tmp___2 = Tcl_DuplicateObj(objPtr);
        Tcl_SetVar2Ex(interp, name, name2, tmp___2, 0);
        hPtr = Tcl_NextHashEntry(& search);
      }
    }
  }
  if (flags & 32) {
    objPtr = Tcl_GetVar2Ex(interp, name, name2, 0);
    string = Tcl_GetStringFromObj(objPtr, & length);
    newObjPtr = Tcl_NewStringObj(string, length);
    newObjPtr->refCount = newObjPtr->refCount + 1;
    if ((unsigned int )name2 != (unsigned int )((void *)0)) {
      if (valuePtr->flags == 0) {
        Tcl_InitHashTable(& valuePtr->array, 0);
        valuePtr->flags = 2;
      }
      hPtr = ((*(valuePtr->array.createProc)))(& valuePtr->array, name2, & new);
      oldObjPtr = (Tcl_Obj *)hPtr->clientData;
      hPtr->clientData = (void *)((char *)newObjPtr);
    } else {
      oldObjPtr = valuePtr->objPtr;
      valuePtr->objPtr = newObjPtr;
    }
    if ((unsigned int )oldObjPtr != (unsigned int )((void *)0)) {
      oldObjPtr->refCount = oldObjPtr->refCount - 1;
      if (oldObjPtr->refCount <= 0) {
        TclFreeObj(oldObjPtr);
      }
    }
  }
  if (flags & 16) {
    objPtr = (Tcl_Obj *)((void *)0);
    if ((unsigned int )name2 != (unsigned int )((void *)0)) {
      hPtr = ((*(valuePtr->array.findProc)))(& valuePtr->array, name2);
      if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
        objPtr = (Tcl_Obj *)hPtr->clientData;
      }
    } else {
      if ((unsigned int )valuePtr->objPtr != (unsigned int )((void *)0)) {
        objPtr = valuePtr->objPtr;
      }
    }
    if ((unsigned int )objPtr != (unsigned int )((void *)0)) {
      newObjPtr = Tcl_DuplicateObj(objPtr);
      Tcl_SetVar2Ex(interp, name, name2, newObjPtr, 0);
    }
  }
  if (flags & 64) {
    if ((unsigned int )name2 != (unsigned int )((void *)0)) {
      hPtr = ((*(valuePtr->array.findProc)))(& valuePtr->array, name2);
      if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
        objPtr = (Tcl_Obj *)hPtr->clientData;
        objPtr->refCount = objPtr->refCount - 1;
        if (objPtr->refCount <= 0) {
          TclFreeObj(objPtr);
        }
        Tcl_DeleteHashEntry(hPtr);
      }
    } else {
      if (valuePtr->flags & 2) {
        hPtr = Tcl_FirstHashEntry(& valuePtr->array, & search);
        while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
          nextPtr = Tcl_NextHashEntry(& search);
          objPtr = (Tcl_Obj *)hPtr->clientData;
          objPtr->refCount = objPtr->refCount - 1;
          if (objPtr->refCount <= 0) {
            TclFreeObj(objPtr);
          }
          Tcl_DeleteHashEntry(hPtr);
          hPtr = nextPtr;
        }
        Tcl_DeleteHashTable(& valuePtr->array);
        valuePtr->flags &= -3;
      } else {
        if ((unsigned int )valuePtr->objPtr != (unsigned int )((void *)0)) {
          (valuePtr->objPtr)->refCount = (valuePtr->objPtr)->refCount - 1;
          if ((valuePtr->objPtr)->refCount <= 0) {
            TclFreeObj(valuePtr->objPtr);
          }
          valuePtr->objPtr = (Tcl_Obj *)((void *)0);
          valuePtr->flags &= -2;
        }
      }
    }
    if (! destroyed) {
      tmp___3 = Tcl_TraceVar2(interp, name, (char *)((void *)0), 2160, & ShareTraceProc,
                              (void *)0);
      if (tmp___3 != 0) {
        Ns_Fatal((char *)"Cannot set trace on share");
      }
    }
  }
  Ns_CsLeave(& valuePtr->lock);
  if (destroyed) {
    Ns_CsDestroy(& valuePtr->lock);
    Tcl_Free((char *)valuePtr);
  }
  done: 
  Tcl_DStringFree(& ds);
  return ((char *)((void *)0));
}
}
static char *GetGlobalizedName(Tcl_DString *dsPtr , char *varName ) 
{ int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  Tcl_DStringInit(dsPtr);
  if (0) {
    if (0) {
      __s1_len___0 = strlen("::");
      __s2_len___0 = strlen((char const   *)varName);
      if (! ((unsigned int )((void const   *)("::" + 1)) - (unsigned int )((void const   *)"::") ==
             1U)) {
        goto _L___2;
      } else {
        if (__s1_len___0 >= 4U) {
          _L___2: 
          if (! ((unsigned int )((void const   *)(varName + 1)) - (unsigned int )((void const   *)varName) ==
                 1U)) {
            tmp___18 = 1;
          } else {
            if (__s2_len___0 >= 4U) {
              tmp___18 = 1;
            } else {
              tmp___18 = 0;
            }
          }
        } else {
          tmp___18 = 0;
        }
      }
      if (tmp___18) {
        if (__s1_len___0 < __s2_len___0) {
          tmp___16 = __s1_len___0;
        } else {
          tmp___16 = __s2_len___0;
        }
        tmp___15 = memcmp((void const   *)"::", (void const   *)((char const   *)varName),
                          tmp___16 + 1U);
      } else {
        tmp___17 = strcmp("::", (char const   *)varName);
        tmp___15 = tmp___17;
      }
    } else {
      tmp___17 = strcmp("::", (char const   *)varName);
      tmp___15 = tmp___17;
    }
    tmp___10 = tmp___15;
  } else {
    tmp___10 = strncmp("::", (char const   *)varName, 2U);
  }
  if (tmp___10 != 0) {
    Tcl_DStringAppend(dsPtr, (char *)"::", 2);
  }
  Tcl_DStringAppend(dsPtr, varName, -1);
  return (dsPtr->string);
}
}
extern int Tcl_InputBuffered(Tcl_Channel chan ) ;
extern Tcl_Channel Tcl_MakeTcpClientChannel(ClientData tcpSocket ) ;
extern int Tcl_GetCharLength(Tcl_Obj *objPtr ) ;
static int GetSet(Tcl_Interp *interp , char *flist , int write___0 , fd_set **setPtrPtr ,
                  fd_set *setPtr , int *maxPtr ) ;
static void AppendReadyFiles(Tcl_Interp *interp , fd_set *setPtr , int write___0 ,
                             char *flist , Tcl_DString *dsPtr ) ;
static int EnterSock(Tcl_Interp *interp , int sock ) ;
static int EnterDup(Tcl_Interp *interp , int sock ) ;
static int EnterDupedSocks(Tcl_Interp *interp , int sock ) ;
static int SockSetBlockingObj(char *value , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
static int SockListenCallback(int sock , void *arg , int why ) ;
void NsTclSockArgProc(Tcl_DString *dsPtr , void *arg ) 
{ Callback___2 *cbPtr ;

  {
  cbPtr = (Callback___2 *)arg;
  Tcl_DStringAppendElement(dsPtr, cbPtr->script);
  return;
}
}
static int GetObjCmd(Tcl_Interp *interp , int objc , Tcl_Obj **objv , int byaddr ) 
{ Tcl_DString ds ;
  char *opt ;
  char *addr ;
  int all ;
  int status ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  all = 0;
  if (byaddr) {
    if (objc < 2) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-all? address");
      return (1);
    } else {
      if (objc > 3) {
        Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-all? address");
        return (1);
      }
    }
  } else {
    if (objc != 2) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"address");
      return (1);
    }
  }
  opt = Tcl_GetString((*(objv + 1)));
  if (objc >= 3) {
    if ((int )(*opt) == (int )(*"-all")) {
      if (0) {
        __s1_len = strlen((char const   *)opt);
        __s2_len = strlen("-all");
        if (! ((unsigned int )((void const   *)(opt + 1)) - (unsigned int )((void const   *)opt) ==
               1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("-all" + 1)) - (unsigned int )((void const   *)"-all") ==
                   1U)) {
              tmp___6 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___6 = 1;
              } else {
                tmp___6 = 0;
              }
            }
          } else {
            tmp___6 = 0;
          }
        }
        if (tmp___6) {
          if (__s1_len < __s2_len) {
            tmp___4 = __s1_len;
          } else {
            tmp___4 = __s2_len;
          }
          tmp___3 = memcmp((void const   *)((char const   *)opt), (void const   *)"-all",
                           tmp___4 + 1U);
        } else {
          tmp___5 = strcmp((char const   *)opt, "-all");
          tmp___3 = tmp___5;
        }
      } else {
        tmp___5 = strcmp((char const   *)opt, "-all");
        tmp___3 = tmp___5;
      }
      if (tmp___3 == 0) {
        all = 1;
        addr = Tcl_GetString((*(objv + 2)));
      } else {
        addr = opt;
      }
    } else {
      addr = opt;
    }
  } else {
    addr = opt;
  }
  Tcl_DStringInit(& ds);
  if (byaddr) {
    if (all) {
      status = Ns_GetAllAddrByHost(& ds, addr);
    } else {
      status = Ns_GetAddrByHost(& ds, addr);
    }
  } else {
    status = Ns_GetHostByAddr(& ds, addr);
  }
  if (status == 1) {
    Tcl_SetResult(interp, ds.string, (Tcl_FreeProc *)1);
  }
  Tcl_DStringFree(& ds);
  if (status != 1) {
    Tcl_AppendResult(interp, "could not lookup ", addr, (void *)0);
    return (1);
  }
  return (0);
}
}
int NsTclGetHostObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = GetObjCmd(interp, objc, objv, 0);
  return (tmp);
}
}
int NsTclGetAddrObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = GetObjCmd(interp, objc, objv, 1);
  return (tmp);
}
}
int NsTclSockSetBlockingObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = SockSetBlockingObj((char *)"1", interp, objc, objv);
  return (tmp);
}
}
int NsTclSockSetNonBlockingObjCmd(ClientData arg , Tcl_Interp *interp , int objc ,
                                  Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = SockSetBlockingObj((char *)"0", interp, objc, objv);
  return (tmp);
}
}
int NsTclSockNReadObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int nread ;
  Tcl_Channel chan ;
  int sock ;
  char buf[20] ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  Tcl_Obj *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"sockId");
    return (1);
  }
  tmp = Tcl_GetString((*(objv + 1)));
  chan = Tcl_GetChannel(interp, tmp, (int *)((void *)0));
  if ((unsigned int )chan == (unsigned int )((void *)0)) {
    return (1);
  } else {
    tmp___0 = Tcl_GetString((*(objv + 1)));
    tmp___1 = Ns_TclGetOpenFd(interp, tmp___0, 0, & sock);
    if (tmp___1 != 0) {
      return (1);
    }
  }
  tmp___4 = ioctl(sock, 21531UL, & nread);
  if (tmp___4 != 0) {
    tmp___2 = Tcl_PosixError(interp);
    tmp___3 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___3, "ns_sockioctl failed: ", tmp___2, (void *)0);
    return (1);
  }
  tmp___5 = Tcl_InputBuffered(chan);
  nread += tmp___5;
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", nread);
  Tcl_SetResult(interp, buf, (Tcl_FreeProc *)1);
  return (0);
}
}
int NsTclSockListenObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int sock ;
  char *addr ;
  int port ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  Tcl_Obj *tmp___10 ;
  int tmp___11 ;

  {
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"address port");
    return (1);
  }
  addr = Tcl_GetString((*(objv + 1)));
  if ((int )(*addr) == (int )(*"*")) {
    if (0) {
      __s1_len = strlen((char const   *)addr);
      __s2_len = strlen("*");
      if (! ((unsigned int )((void const   *)(addr + 1)) - (unsigned int )((void const   *)addr) ==
             1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: 
          if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                 1U)) {
            tmp___6 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___6 = 1;
            } else {
              tmp___6 = 0;
            }
          }
        } else {
          tmp___6 = 0;
        }
      }
      if (tmp___6) {
        if (__s1_len < __s2_len) {
          tmp___4 = __s1_len;
        } else {
          tmp___4 = __s2_len;
        }
        tmp___3 = memcmp((void const   *)((char const   *)addr), (void const   *)"*",
                         tmp___4 + 1U);
      } else {
        tmp___5 = strcmp((char const   *)addr, "*");
        tmp___3 = tmp___5;
      }
    } else {
      tmp___5 = strcmp((char const   *)addr, "*");
      tmp___3 = tmp___5;
    }
    if (tmp___3 == 0) {
      addr = (char *)((void *)0);
    }
  }
  tmp___7 = Tcl_GetIntFromObj(interp, (*(objv + 2)), & port);
  if (tmp___7 != 0) {
    return (1);
  }
  sock = Ns_SockListen(addr, port);
  if (sock == -1) {
    tmp___8 = Tcl_GetString((*(objv + 2)));
    tmp___9 = Tcl_GetString((*(objv + 1)));
    tmp___10 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___10, "could not listen on \"", tmp___9, ":", tmp___8,
                           "\"", (void *)0);
    return (1);
  }
  tmp___11 = EnterSock(interp, sock);
  return (tmp___11);
}
}
int NsTclSockAcceptObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int sock ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  Tcl_Obj *tmp___2 ;
  int tmp___3 ;

  {
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"sockId");
    return (1);
  }
  tmp = Tcl_GetString((*(objv + 1)));
  tmp___0 = Ns_TclGetOpenFd(interp, tmp, 0, & sock);
  if (tmp___0 != 0) {
    return (1);
  }
  sock = Ns_SockAccept(sock, (struct sockaddr *)((void *)0), (int *)0);
  if (sock == -1) {
    tmp___1 = Tcl_PosixError(interp);
    tmp___2 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___2, "accept failed: ", tmp___1, (void *)0);
    return (1);
  }
  tmp___3 = EnterDupedSocks(interp, sock);
  return (tmp___3);
}
}
int NsTclSockCheckObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Tcl_Obj *objPtr ;
  int sock ;
  char *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"sockId");
    return (1);
  }
  tmp = Tcl_GetString((*(objv + 1)));
  tmp___0 = Ns_TclGetOpenFd(interp, tmp, 1, & sock);
  if (tmp___0 != 0) {
    return (1);
  }
  tmp___1 = send(sock, (void const   *)((void *)0), 0U, 0);
  if (tmp___1 != 0) {
    objPtr = Tcl_NewBooleanObj(0);
  } else {
    objPtr = Tcl_NewBooleanObj(1);
  }
  Tcl_SetObjResult(interp, objPtr);
  return (0);
}
}
int NsTclSockOpenObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int sock ;
  int port ;
  int timeout ;
  int first___1 ;
  int async ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___30 ;
  size_t tmp___31 ;
  char *tmp___32 ;
  char *tmp___53 ;
  int tmp___54 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  int tmp___59 ;
  char *tmp___60 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___91 ;
  size_t tmp___92 ;
  char *tmp___93 ;
  char *tmp___114 ;
  int tmp___115 ;
  char *tmp___117 ;
  char *tmp___118 ;
  char *tmp___119 ;
  int tmp___120 ;
  char *tmp___121 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___152 ;
  size_t tmp___153 ;
  char *tmp___154 ;
  char *tmp___175 ;
  int tmp___176 ;
  char *tmp___178 ;
  char *tmp___179 ;
  char *tmp___180 ;
  int tmp___181 ;
  int tmp___182 ;
  int tmp___183 ;
  char *tmp___184 ;
  char *tmp___185 ;
  char *tmp___186 ;
  char *tmp___187 ;
  char *tmp___188 ;
  Tcl_Obj *tmp___189 ;
  int tmp___190 ;

  {
  if (objc < 3) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-nonblock|-timeout seconds? host port");
    return (1);
  } else {
    if (objc > 5) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-nonblock|-timeout seconds? host port");
      return (1);
    }
  }
  first___1 = 1;
  async = 0;
  timeout = -1;
  if (objc == 4) {
    tmp = Tcl_GetString((*(objv + 1)));
    if ((int )(*tmp) == (int )(*"-nonblock")) {
      if (0) {
        tmp___56 = Tcl_GetString((*(objv + 1)));
        __s1_len = strlen((char const   *)tmp___56);
        __s2_len = strlen("-nonblock");
        tmp___57 = Tcl_GetString((*(objv + 1)));
        tmp___58 = Tcl_GetString((*(objv + 1)));
        if ((unsigned int )((void const   *)(tmp___57 + 1)) - (unsigned int )((void const   *)tmp___58) ==
            1U) {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("-nonblock" + 1)) - (unsigned int )((void const   *)"-nonblock") ==
                   1U)) {
              tmp___59 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___59 = 1;
              } else {
                tmp___59 = 0;
              }
            }
          } else {
            tmp___59 = 0;
          }
        } else {
          goto _L___0;
        }
        if (tmp___59) {
          if (__s1_len < __s2_len) {
            tmp___31 = __s1_len;
          } else {
            tmp___31 = __s2_len;
          }
          tmp___32 = Tcl_GetString((*(objv + 1)));
          tmp___30 = memcmp((void const   *)((char const   *)tmp___32), (void const   *)"-nonblock",
                            tmp___31 + 1U);
        } else {
          tmp___53 = Tcl_GetString((*(objv + 1)));
          tmp___54 = strcmp((char const   *)tmp___53, "-nonblock");
          tmp___30 = tmp___54;
        }
      } else {
        tmp___53 = Tcl_GetString((*(objv + 1)));
        tmp___54 = strcmp((char const   *)tmp___53, "-nonblock");
        tmp___30 = tmp___54;
      }
      if (! (tmp___30 == 0)) {
        goto _L___3;
      }
    } else {
      _L___3: 
      tmp___60 = Tcl_GetString((*(objv + 1)));
      if ((int )(*tmp___60) == (int )(*"-async")) {
        if (0) {
          tmp___117 = Tcl_GetString((*(objv + 1)));
          __s1_len___0 = strlen((char const   *)tmp___117);
          __s2_len___0 = strlen("-async");
          tmp___118 = Tcl_GetString((*(objv + 1)));
          tmp___119 = Tcl_GetString((*(objv + 1)));
          if ((unsigned int )((void const   *)(tmp___118 + 1)) - (unsigned int )((void const   *)tmp___119) ==
              1U) {
            if (__s1_len___0 >= 4U) {
              _L___2: 
              if (! ((unsigned int )((void const   *)("-async" + 1)) - (unsigned int )((void const   *)"-async") ==
                     1U)) {
                tmp___120 = 1;
              } else {
                if (__s2_len___0 >= 4U) {
                  tmp___120 = 1;
                } else {
                  tmp___120 = 0;
                }
              }
            } else {
              tmp___120 = 0;
            }
          } else {
            goto _L___2;
          }
          if (tmp___120) {
            if (__s1_len___0 < __s2_len___0) {
              tmp___92 = __s1_len___0;
            } else {
              tmp___92 = __s2_len___0;
            }
            tmp___93 = Tcl_GetString((*(objv + 1)));
            tmp___91 = memcmp((void const   *)((char const   *)tmp___93), (void const   *)"-async",
                              tmp___92 + 1U);
          } else {
            tmp___114 = Tcl_GetString((*(objv + 1)));
            tmp___115 = strcmp((char const   *)tmp___114, "-async");
            tmp___91 = tmp___115;
          }
        } else {
          tmp___114 = Tcl_GetString((*(objv + 1)));
          tmp___115 = strcmp((char const   *)tmp___114, "-async");
          tmp___91 = tmp___115;
        }
        if (! (tmp___91 == 0)) {
          Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-nonblock|-timeout seconds? host port");
          return (1);
        }
      } else {
        Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-nonblock|-timeout seconds? host port");
        return (1);
      }
    }
    first___1 = 2;
    async = 1;
  } else {
    if (objc == 5) {
      tmp___121 = Tcl_GetString((*(objv + 1)));
      if ((int )(*tmp___121) == (int )(*"-timeout")) {
        if (0) {
          tmp___178 = Tcl_GetString((*(objv + 1)));
          __s1_len___1 = strlen((char const   *)tmp___178);
          __s2_len___1 = strlen("-timeout");
          tmp___179 = Tcl_GetString((*(objv + 1)));
          tmp___180 = Tcl_GetString((*(objv + 1)));
          if ((unsigned int )((void const   *)(tmp___179 + 1)) - (unsigned int )((void const   *)tmp___180) ==
              1U) {
            if (__s1_len___1 >= 4U) {
              _L___5: 
              if (! ((unsigned int )((void const   *)("-timeout" + 1)) - (unsigned int )((void const   *)"-timeout") ==
                     1U)) {
                tmp___181 = 1;
              } else {
                if (__s2_len___1 >= 4U) {
                  tmp___181 = 1;
                } else {
                  tmp___181 = 0;
                }
              }
            } else {
              tmp___181 = 0;
            }
          } else {
            goto _L___5;
          }
          if (tmp___181) {
            if (__s1_len___1 < __s2_len___1) {
              tmp___153 = __s1_len___1;
            } else {
              tmp___153 = __s2_len___1;
            }
            tmp___154 = Tcl_GetString((*(objv + 1)));
            tmp___152 = memcmp((void const   *)((char const   *)tmp___154), (void const   *)"-timeout",
                               tmp___153 + 1U);
          } else {
            tmp___175 = Tcl_GetString((*(objv + 1)));
            tmp___176 = strcmp((char const   *)tmp___175, "-timeout");
            tmp___152 = tmp___176;
          }
        } else {
          tmp___175 = Tcl_GetString((*(objv + 1)));
          tmp___176 = strcmp((char const   *)tmp___175, "-timeout");
          tmp___152 = tmp___176;
        }
        if (! (tmp___152 == 0)) {
          Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-nonblock|-timeout seconds? host port");
          return (1);
        }
      } else {
        Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-nonblock|-timeout seconds? host port");
        return (1);
      }
      tmp___182 = Tcl_GetIntFromObj(interp, (*(objv + 2)), & timeout);
      if (tmp___182 != 0) {
        return (1);
      }
      first___1 = 3;
    }
  }
  tmp___183 = Tcl_GetIntFromObj(interp, (*(objv + (first___1 + 1))), & port);
  if (tmp___183 != 0) {
    return (1);
  }
  if (async) {
    tmp___184 = Tcl_GetString((*(objv + first___1)));
    sock = Ns_SockAsyncConnect(tmp___184, port);
  } else {
    if (timeout < 0) {
      tmp___185 = Tcl_GetString((*(objv + first___1)));
      sock = Ns_SockConnect(tmp___185, port);
    } else {
      tmp___186 = Tcl_GetString((*(objv + first___1)));
      sock = Ns_SockTimedConnect(tmp___186, port, timeout);
    }
  }
  if (sock == -1) {
    tmp___187 = Tcl_GetString((*(objv + (first___1 + 1))));
    tmp___188 = Tcl_GetString((*(objv + first___1)));
    tmp___189 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___189, "could not connect to \"", tmp___188, ":", tmp___187,
                           "\"", (void *)0);
    return (1);
  }
  tmp___190 = EnterDupedSocks(interp, sock);
  return (tmp___190);
}
}
int NsTclSelectObjCmd(ClientData dummy , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ fd_set rset ;
  fd_set wset ;
  fd_set eset ;
  fd_set *rPtr ;
  fd_set *wPtr ;
  fd_set *ePtr ;
  int maxfd ;
  int i ;
  int status ;
  int arg ;
  Tcl_Channel chan ;
  struct timeval tv ;
  struct timeval *tvPtr ;
  Tcl_DString dsRfd ;
  Tcl_DString dsNbuf ;
  Tcl_Obj **fobjv ;
  int fobjc ;
  Ns_Time timeout ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___29 ;
  size_t tmp___30 ;
  char *tmp___31 ;
  char *tmp___52 ;
  int tmp___53 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  char *tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  char *tmp___71 ;
  int tmp___72 ;
  int *tmp___73 ;
  char *tmp___74 ;
  Tcl_Obj *tmp___75 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int __d0___1 ;
  int __d1___1 ;
  int tmp___76 ;
  char *tmp___77 ;
  int tmp___78 ;
  char *tmp___79 ;

  {
  status = 1;
  if (objc != 6) {
    if (objc != 4) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-timeout sec? rfds wfds efds");
      return (1);
    }
  }
  if (objc == 4) {
    tvPtr = (struct timeval *)((void *)0);
    arg = 1;
  } else {
    tvPtr = & tv;
    if (0) {
      tmp___55 = Tcl_GetString((*(objv + 1)));
      __s1_len = strlen((char const   *)tmp___55);
      __s2_len = strlen("-timeout");
      tmp___56 = Tcl_GetString((*(objv + 1)));
      tmp___57 = Tcl_GetString((*(objv + 1)));
      if ((unsigned int )((void const   *)(tmp___56 + 1)) - (unsigned int )((void const   *)tmp___57) ==
          1U) {
        if (__s1_len >= 4U) {
          _L___0: 
          if (! ((unsigned int )((void const   *)("-timeout" + 1)) - (unsigned int )((void const   *)"-timeout") ==
                 1U)) {
            tmp___58 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___58 = 1;
            } else {
              tmp___58 = 0;
            }
          }
        } else {
          tmp___58 = 0;
        }
      } else {
        goto _L___0;
      }
      if (tmp___58) {
        if (__s1_len < __s2_len) {
          tmp___30 = __s1_len;
        } else {
          tmp___30 = __s2_len;
        }
        tmp___31 = Tcl_GetString((*(objv + 1)));
        tmp___29 = memcmp((void const   *)((char const   *)tmp___31), (void const   *)"-timeout",
                          tmp___30 + 1U);
      } else {
        tmp___52 = Tcl_GetString((*(objv + 1)));
        tmp___53 = strcmp((char const   *)tmp___52, "-timeout");
        tmp___29 = tmp___53;
      }
    } else {
      tmp___52 = Tcl_GetString((*(objv + 1)));
      tmp___53 = strcmp((char const   *)tmp___52, "-timeout");
      tmp___29 = tmp___53;
    }
    if (tmp___29 != 0) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-timeout sec? rfds wfds efds");
      return (1);
    }
    tmp___59 = Ns_TclGetTimeFromObj(interp, (*(objv + 2)), & timeout);
    if (tmp___59 != 0) {
      return (1);
    }
    tv.tv_sec = timeout.sec;
    tv.tv_usec = timeout.usec;
    arg = 3;
  }
  tmp___60 = arg;
  arg ++;
  tmp___61 = Tcl_ListObjGetElements(interp, (*(objv + tmp___60)), & fobjc, & fobjv);
  if (tmp___61 != 0) {
    return (1);
  }
  Tcl_DStringInit(& dsRfd);
  Tcl_DStringInit(& dsNbuf);
  i = 0;
  while (i < fobjc) {
    tmp___62 = Tcl_GetString((*(fobjv + i)));
    chan = Tcl_GetChannel(interp, tmp___62, (int *)((void *)0));
    if ((unsigned int )chan == (unsigned int )((void *)0)) {
      goto done;
    }
    tmp___65 = Tcl_InputBuffered(chan);
    if (tmp___65 > 0) {
      tmp___63 = Tcl_GetString((*(fobjv + i)));
      Tcl_DStringAppendElement(& dsNbuf, tmp___63);
    } else {
      tmp___64 = Tcl_GetString((*(fobjv + i)));
      Tcl_DStringAppendElement(& dsRfd, tmp___64);
    }
    i ++;
  }
  if (dsNbuf.length > 0) {
    tv.tv_sec = 0L;
    tv.tv_usec = 0L;
    tvPtr = & tv;
  }
  maxfd = 0;
  tmp___66 = GetSet(interp, dsRfd.string, 0, & rPtr, & rset, & maxfd);
  if (tmp___66 != 0) {
    goto done;
  }
  tmp___67 = arg;
  arg ++;
  tmp___68 = Tcl_GetString((*(objv + tmp___67)));
  tmp___69 = GetSet(interp, tmp___68, 1, & wPtr, & wset, & maxfd);
  if (tmp___69 != 0) {
    goto done;
  }
  tmp___70 = arg;
  arg ++;
  tmp___71 = Tcl_GetString((*(objv + tmp___70)));
  tmp___72 = GetSet(interp, tmp___71, 0, & ePtr, & eset, & maxfd);
  if (tmp___72 != 0) {
    goto done;
  }
  if (dsNbuf.length == 0) {
    if ((unsigned int )rPtr == (unsigned int )((void *)0)) {
      if ((unsigned int )wPtr == (unsigned int )((void *)0)) {
        if ((unsigned int )ePtr == (unsigned int )((void *)0)) {
          if ((unsigned int )tvPtr == (unsigned int )((void *)0)) {
            status = 0;
          } else {
            goto _L___4;
          }
        } else {
          goto _L___4;
        }
      } else {
        goto _L___4;
      }
    } else {
      goto _L___4;
    }
  } else {
    _L___4: 
    while (1) {
      i = select(maxfd + 1, (fd_set * __restrict  )rPtr, (fd_set * __restrict  )wPtr,
                 (fd_set * __restrict  )ePtr, (struct timeval * __restrict  )tvPtr);
      if (i < 0) {
        tmp___73 = __errno_location();
        if (! ((*tmp___73) == 4)) {
          break;
        }
      } else {
        break;
      }
    }
    if (i == -1) {
      tmp___74 = Tcl_PosixError(interp);
      tmp___75 = Tcl_GetObjResult(interp);
      Tcl_AppendStringsToObj(tmp___75, "select failed: ", tmp___74, (void *)0);
    } else {
      if (i == 0) {
        if ((unsigned int )rPtr != (unsigned int )((void *)0)) {
          while (1) {
            __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0),
                                 "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& rPtr->fds_bits[0]): "memory");
            break;
          }
        }
        if ((unsigned int )wPtr != (unsigned int )((void *)0)) {
          while (1) {
            __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                                 "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& wPtr->fds_bits[0]): "memory");
            break;
          }
        }
        if ((unsigned int )ePtr != (unsigned int )((void *)0)) {
          while (1) {
            __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___1), "=D" (__d1___1): "a" (0),
                                 "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& ePtr->fds_bits[0]): "memory");
            break;
          }
        }
      }
      AppendReadyFiles(interp, rPtr, 0, dsRfd.string, & dsNbuf);
      arg -= 2;
      tmp___76 = arg;
      arg ++;
      tmp___77 = Tcl_GetString((*(objv + tmp___76)));
      AppendReadyFiles(interp, wPtr, 1, tmp___77, (Tcl_DString *)((void *)0));
      tmp___78 = arg;
      arg ++;
      tmp___79 = Tcl_GetString((*(objv + tmp___78)));
      AppendReadyFiles(interp, ePtr, 0, tmp___79, (Tcl_DString *)((void *)0));
      status = 0;
    }
  }
  done: 
  Tcl_DStringFree(& dsRfd);
  Tcl_DStringFree(& dsNbuf);
  return (status);
}
}
int NsTclSocketPairObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int socks[2] ;
  char *tmp ;
  Tcl_Obj *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = ns_sockpair(socks);
  if (tmp___1 != 0) {
    tmp = Tcl_PosixError(interp);
    tmp___0 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___0, "ns_sockpair failed:  ", tmp, (void *)0);
    return (1);
  }
  tmp___2 = EnterSock(interp, socks[0]);
  if (tmp___2 != 0) {
    close(socks[1]);
    return (1);
  }
  tmp___3 = EnterSock(interp, socks[1]);
  return (tmp___3);
}
}
int NsTclSockCallbackObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int sock ;
  int when ;
  char *s ;
  Callback___2 *cbPtr ;
  NsInterp *itPtr ;
  char *tmp ;
  Tcl_Obj *tmp___0 ;
  char *tmp___1 ;
  Tcl_Obj *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 4) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"sockId script when");
    return (1);
  }
  s = Tcl_GetString((*(objv + 3)));
  when = 0;
  while ((int )(*s) != 0) {
    if ((int )(*s) == 114) {
      when |= 1;
    } else {
      if ((int )(*s) == 119) {
        when |= 2;
      } else {
        if ((int )(*s) == 101) {
          when |= 4;
        } else {
          if ((int )(*s) == 120) {
            when |= 8;
          } else {
            tmp = Tcl_GetString((*(objv + 3)));
            tmp___0 = Tcl_GetObjResult(interp);
            Tcl_AppendStringsToObj(tmp___0, "invalid when specification \"", tmp,
                                   "\": should be one or more of r, w, e, or x", (void *)0);
            return (1);
          }
        }
      }
    }
    s ++;
  }
  if (when == 0) {
    tmp___1 = Tcl_GetString((*(objv + 3)));
    tmp___2 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___2, "invalid when specification \"", tmp___1, "\": should be one or more of r, w, e, or x",
                           (void *)0);
    return (1);
  }
  tmp___3 = Tcl_GetString((*(objv + 1)));
  tmp___4 = Ns_TclGetOpenFd(interp, tmp___3, when & 2, & sock);
  if (tmp___4 != 0) {
    return (1);
  }
  sock = dup(sock);
  tmp___5 = Tcl_GetCharLength((*(objv + 2)));
  cbPtr = (Callback___2 *)ns_malloc(sizeof(Callback___2 ) + (unsigned int )tmp___5);
  if (itPtr->servPtr) {
    cbPtr->server = (itPtr->servPtr)->server;
  } else {
    cbPtr->server = (char *)((void *)0);
  }
  cbPtr->chan = (struct Tcl_Channel_ *)((void *)0);
  cbPtr->when = when;
  tmp___6 = Tcl_GetString((*(objv + 2)));
  strcpy((char * __restrict  )(cbPtr->script), (char const   * __restrict  )tmp___6);
  tmp___7 = Ns_SockCallback(sock, & NsTclSockProc, (void *)cbPtr, when | 8);
  if (tmp___7 != 0) {
    Tcl_SetResult(interp, (char *)"could not register callback", (Tcl_FreeProc *)0);
    close(sock);
    ns_free((void *)cbPtr);
    return (1);
  }
  return (0);
}
}
int NsTclSockListenCallbackObjCmd(ClientData arg , Tcl_Interp *interp , int objc ,
                                  Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  ListenCallback___0 *lcbPtr ;
  int port ;
  char *addr ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 4) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"address port script");
    return (1);
  }
  tmp = Tcl_GetIntFromObj(interp, (*(objv + 2)), & port);
  if (tmp != 0) {
    return (1);
  }
  addr = Tcl_GetString((*(objv + 1)));
  if ((int )(*addr) == (int )(*"*")) {
    if (0) {
      __s1_len = strlen((char const   *)addr);
      __s2_len = strlen("*");
      if (! ((unsigned int )((void const   *)(addr + 1)) - (unsigned int )((void const   *)addr) ==
             1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: 
          if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                 1U)) {
            tmp___7 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___7 = 1;
            } else {
              tmp___7 = 0;
            }
          }
        } else {
          tmp___7 = 0;
        }
      }
      if (tmp___7) {
        if (__s1_len < __s2_len) {
          tmp___5 = __s1_len;
        } else {
          tmp___5 = __s2_len;
        }
        tmp___4 = memcmp((void const   *)((char const   *)addr), (void const   *)"*",
                         tmp___5 + 1U);
      } else {
        tmp___6 = strcmp((char const   *)addr, "*");
        tmp___4 = tmp___6;
      }
    } else {
      tmp___6 = strcmp((char const   *)addr, "*");
      tmp___4 = tmp___6;
    }
    if (tmp___4 == 0) {
      addr = (char *)((void *)0);
    }
  }
  tmp___8 = Tcl_GetCharLength((*(objv + 3)));
  lcbPtr = (ListenCallback___0 *)ns_malloc(sizeof(ListenCallback___0 ) + (unsigned int )tmp___8);
  if (itPtr->servPtr) {
    lcbPtr->server = (itPtr->servPtr)->server;
  } else {
    lcbPtr->server = (char *)((void *)0);
  }
  tmp___9 = Tcl_GetString((*(objv + 3)));
  strcpy((char * __restrict  )(lcbPtr->script), (char const   * __restrict  )tmp___9);
  tmp___10 = Ns_SockListenCallback(addr, port, & SockListenCallback, (void *)lcbPtr);
  if (tmp___10 != 0) {
    Tcl_SetResult(interp, (char *)"could not register callback", (Tcl_FreeProc *)0);
    ns_free((void *)lcbPtr);
    return (1);
  }
  return (0);
}
}
static int SockSetBlockingObj(char *value , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Tcl_Channel chan ;
  char *tmp ;
  int tmp___0 ;

  {
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"sockId");
    return (1);
  }
  tmp = Tcl_GetString((*(objv + 1)));
  chan = Tcl_GetChannel(interp, tmp, (int *)((void *)0));
  if ((unsigned int )chan == (unsigned int )((void *)0)) {
    return (1);
  }
  tmp___0 = Tcl_SetChannelOption(interp, chan, (char *)"-blocking", value);
  return (tmp___0);
}
}
static void AppendReadyFiles(Tcl_Interp *interp , fd_set *setPtr , int write___0 ,
                             char *flist , Tcl_DString *dsPtr ) 
{ int fargc ;
  char **fargv ;
  int sock ;
  Tcl_DString ds ;
  register char __result ;
  int tmp ;

  {
  Tcl_DStringInit(& ds);
  if ((unsigned int )dsPtr == (unsigned int )((void *)0)) {
    dsPtr = & ds;
  }
  Tcl_SplitList(interp, flist, & fargc, & fargv);
  while (1) {
    tmp = fargc;
    fargc --;
    if (! tmp) {
      break;
    }
    Ns_TclGetOpenFd(interp, (*(fargv + fargc)), write___0, & sock);
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )sock %
                                                                        (8U * sizeof(__fd_mask ))),
                         "m" (setPtr->fds_bits[(unsigned int )sock / (8U * sizeof(__fd_mask ))]): "cc");
    if (__result) {
      Tcl_DStringAppendElement(dsPtr, (*(fargv + fargc)));
    }
  }
  Tcl_AppendElement(interp, dsPtr->string);
  Tcl_Free((char *)fargv);
  Tcl_DStringFree(& ds);
  return;
}
}
static int GetSet(Tcl_Interp *interp , char *flist , int write___0 , fd_set **setPtrPtr ,
                  fd_set *setPtr , int *maxPtr ) 
{ int sock ;
  int fargc ;
  char **fargv ;
  int status ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = Tcl_SplitList(interp, flist, & fargc, & fargv);
  if (tmp != 0) {
    return (1);
  }
  if (fargc == 0) {
    Tcl_Free((char *)fargv);
    (*setPtrPtr) = (fd_set *)((void *)0);
    return (0);
  } else {
    (*setPtrPtr) = setPtr;
  }
  while (1) {
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) /
                                                                                    sizeof(__fd_mask )),
                         "1" (& setPtr->fds_bits[0]): "memory");
    break;
  }
  status = 0;
  while (1) {
    tmp___1 = fargc;
    fargc --;
    if (! tmp___1) {
      break;
    }
    tmp___0 = Ns_TclGetOpenFd(interp, (*(fargv + fargc)), write___0, & sock);
    if (tmp___0 != 0) {
      status = 1;
      break;
    }
    if (sock > (*maxPtr)) {
      (*maxPtr) = sock;
    }
    __asm__  volatile   ("btsl %1,%0": "=m" (setPtr->fds_bits[(unsigned int )sock /
                                                              (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )sock %
                                                                                                (8U *
                                                                                                 sizeof(__fd_mask ))): "cc",
                         "memory");
  }
  Tcl_Free((char *)fargv);
  return (status);
}
}
static int EnterSock(Tcl_Interp *interp , int sock ) 
{ Tcl_Channel chan ;
  char *tmp ;

  {
  chan = Tcl_MakeTcpClientChannel((void *)sock);
  if ((unsigned int )chan == (unsigned int )((void *)0)) {
    Tcl_AppendResult(interp, "could not open socket", (void *)0);
    close(sock);
    return (1);
  }
  Tcl_SetChannelOption(interp, chan, (char *)"-translation", (char *)"binary");
  Tcl_RegisterChannel(interp, chan);
  tmp = Tcl_GetChannelName(chan);
  Tcl_AppendElement(interp, tmp);
  return (0);
}
}
static int EnterDup(Tcl_Interp *interp , int sock ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  sock = dup(sock);
  if (sock == -1) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Tcl_AppendResult(interp, "could not dup socket: ", tmp___0, (void *)0);
    return (1);
  }
  tmp___1 = EnterSock(interp, sock);
  return (tmp___1);
}
}
static int EnterDupedSocks(Tcl_Interp *interp , int sock ) 
{ int tmp ;
  int tmp___0 ;

  {
  tmp = EnterSock(interp, sock);
  if (tmp != 0) {
    return (1);
  } else {
    tmp___0 = EnterDup(interp, sock);
    if (tmp___0 != 0) {
      return (1);
    }
  }
  return (0);
}
}
int NsTclSockProc(int sock , void *arg , int why ) 
{ Tcl_Interp *interp ;
  Tcl_DString script ;
  Tcl_Obj *objPtr ;
  char *w ;
  int result ;
  int ok ;
  Callback___2 *cbPtr ;
  char *tmp ;

  {
  cbPtr = (Callback___2 *)arg;
  if (why != 8) {
    goto _L;
  } else {
    if (cbPtr->when & 8) {
      _L: 
      Tcl_DStringInit(& script);
      interp = Ns_TclAllocateInterp(cbPtr->server);
      if ((unsigned int )cbPtr->chan == (unsigned int )((void *)0)) {
        cbPtr->chan = Tcl_MakeTcpClientChannel((void *)sock);
        if ((unsigned int )cbPtr->chan == (unsigned int )((void *)0)) {
          Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"could not make channel for sock: %d",
                 sock);
          why = 8;
          goto fail;
        }
        Tcl_RegisterChannel((Tcl_Interp *)((void *)0), cbPtr->chan);
        Tcl_SetChannelOption((Tcl_Interp *)((void *)0), cbPtr->chan, (char *)"-translation",
                             (char *)"binary");
      }
      Tcl_RegisterChannel(interp, cbPtr->chan);
      Tcl_DStringAppend(& script, cbPtr->script, -1);
      tmp = Tcl_GetChannelName(cbPtr->chan);
      Tcl_DStringAppendElement(& script, tmp);
      if (why == 1) {
        w = (char *)"r";
      } else {
        if (why == 2) {
          w = (char *)"w";
        } else {
          if (why == 4) {
            w = (char *)"e";
          } else {
            w = (char *)"x";
          }
        }
      }
      Tcl_DStringAppendElement(& script, w);
      result = Tcl_EvalEx(interp, script.string, script.length, 0);
      if (result != 0) {
        Ns_TclLogError(interp);
      } else {
        objPtr = Tcl_GetObjResult(interp);
        result = Tcl_GetBooleanFromObj(interp, objPtr, & ok);
        if (result != 0) {
          why = 8;
        } else {
          if (! ok) {
            why = 8;
          }
        }
      }
      Ns_TclDeAllocateInterp(interp);
      Tcl_DStringFree(& script);
    }
  }
  if (why == 8) {
    fail: 
    if ((unsigned int )cbPtr->chan != (unsigned int )((void *)0)) {
      Tcl_UnregisterChannel((Tcl_Interp *)((void *)0), cbPtr->chan);
    } else {
      close(sock);
    }
    ns_free((void *)cbPtr);
    return (0);
  }
  return (1);
}
}
static int SockListenCallback(int sock , void *arg , int why ) 
{ ListenCallback___0 *lcbPtr ;
  Tcl_Interp *interp ;
  Tcl_DString script ;
  Tcl_Obj *listPtr ;
  Tcl_Obj **objv ;
  int result ;
  int objc ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  lcbPtr = (ListenCallback___0 *)arg;
  interp = Ns_TclAllocateInterp(lcbPtr->server);
  result = EnterDupedSocks(interp, sock);
  if (result == 0) {
    listPtr = Tcl_GetObjResult(interp);
    tmp___1 = Tcl_ListObjGetElements(interp, listPtr, & objc, & objv);
    if (tmp___1 == 0) {
      if (objc == 2) {
        Tcl_DStringInit(& script);
        Tcl_DStringAppend(& script, lcbPtr->script, -1);
        tmp = Tcl_GetString((*(objv + 0)));
        Tcl_DStringAppendElement(& script, tmp);
        tmp___0 = Tcl_GetString((*(objv + 1)));
        Tcl_DStringAppendElement(& script, tmp___0);
        result = Tcl_EvalEx(interp, script.string, script.length, 0);
        Tcl_DStringFree(& script);
      }
    }
  }
  if (result != 0) {
    Ns_TclLogError(interp);
  }
  Ns_TclDeAllocateInterp(interp);
  return (1);
}
}
void Ns_RWLockDestroy(Ns_RWLock *rwPtr ) ;
int Ns_TimedWaitForEvent(Ns_Event *event , Ns_Mutex *lock___31 , int timeout ) ;
int Ns_TclThread(Tcl_Interp *interp , char *script , Ns_Thread *thrPtr ) ;
int Ns_TclDetachedThread(Tcl_Interp *interp , char *script ) ;
static int GetAddr___0(Tcl_Interp *interp , int type , char *id , void **addrPtr ) ;
static void SetAddr(Tcl_Interp *interp , int type , void *addr ) ;
static int GetArgs(Tcl_Interp *interp , int objc , Tcl_Obj **objv , char **opts___33 ,
                   int type , int create , int *optPtr , void **addrPtr ) ;
static void CreateTclThread(NsInterp *itPtr , char *script , int detached , Ns_Thread *thrPtr ) ;
static int SetAddrFromAny(Tcl_Interp *interp , Tcl_Obj *objPtr ) ;
static void UpdateStringOfAddr(Tcl_Obj *objPtr ) ;
static void SetAddrInternalRep(Tcl_Obj *objPtr , int type , void *addr ) ;
static int GetAddrFromObj(Tcl_Interp *interp , Tcl_Obj *objPtr , int type , void **addrPtr ) ;
static struct Tcl_ObjType addrType  =    {(char *)"ns:addr", (Tcl_FreeInternalRepProc *)((void *)0), (Tcl_DupInternalRepProc *)((void *)0),
    & UpdateStringOfAddr, & SetAddrFromAny};
void NsTclInitAddrType(void) 
{ 

  {
  Tcl_RegisterObjType(& addrType);
  return;
}
}
static char *opts___9[5]  = {      (char *)"create",      (char *)"destroy",      (char *)"lock",      (char *)"unlock", 
        (char *)((void *)0)};
int NsTclMutexObjCmd(ClientData data , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Ns_Mutex *lockPtr ;
  enum __anonenum_opt_107___5 opt ;
  int tmp ;
  char *tmp___0 ;

  {
  tmp = GetArgs(interp, objc, objv, opts___9, 'm', 0, (int *)(& opt), (void **)(& lockPtr));
  if (! tmp) {
    return (1);
  }
  switch ((int )opt) {
  case 0: 
  Ns_MutexInit(lockPtr);
  if (objc > 2) {
    tmp___0 = Tcl_GetString((*(objv + 2)));
    Ns_MutexSetName(lockPtr, tmp___0);
  }
  break;
  case 2: 
  Ns_MutexLock(lockPtr);
  break;
  case 3: 
  Ns_MutexUnlock(lockPtr);
  break;
  case 1: 
  Ns_MutexDestroy(lockPtr);
  ns_free((void *)lockPtr);
  break;
  }
  return (0);
}
}
static char *opts___10[5]  = {      (char *)"create",      (char *)"destroy",      (char *)"enter",      (char *)"leave", 
        (char *)((void *)0)};
int NsTclCritSecObjCmd(ClientData data , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Ns_Cs *csPtr ;
  enum __anonenum_opt_108___1 opt ;
  int tmp ;

  {
  tmp = GetArgs(interp, objc, objv, opts___10, 'c', 0, (int *)(& opt), (void **)(& csPtr));
  if (! tmp) {
    return (1);
  }
  switch ((int )opt) {
  case 0: 
  Ns_CsInit(csPtr);
  break;
  case 2: 
  Ns_CsEnter(csPtr);
  break;
  case 3: 
  Ns_CsLeave(csPtr);
  break;
  case 1: 
  Ns_CsDestroy(csPtr);
  ns_free((void *)csPtr);
  break;
  }
  return (0);
}
}
static char *opts___11[5]  = {      (char *)"create",      (char *)"destroy",      (char *)"release",      (char *)"wait", 
        (char *)((void *)0)};
int NsTclSemaObjCmd(ClientData data , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Ns_Sema *semaPtr ;
  int cnt ;
  enum __anonenum_opt_109 opt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = GetArgs(interp, objc, objv, opts___11, 's', 0, (int *)(& opt), (void **)(& semaPtr));
  if (! tmp) {
    return (1);
  }
  switch ((int )opt) {
  case 0: ;
  if (objc < 3) {
    cnt = 0;
  } else {
    tmp___0 = Tcl_GetIntFromObj(interp, (*(objv + 2)), & cnt);
    if (tmp___0 != 0) {
      return (1);
    }
  }
  Ns_SemaInit(semaPtr, cnt);
  break;
  case 2: ;
  if (objc < 4) {
    cnt = 1;
  } else {
    tmp___1 = Tcl_GetIntFromObj(interp, (*(objv + 3)), & cnt);
    if (tmp___1 != 0) {
      return (1);
    }
  }
  Ns_SemaPost(semaPtr, cnt);
  break;
  case 3: 
  Ns_SemaWait(semaPtr);
  break;
  case 1: 
  Ns_SemaDestroy(semaPtr);
  ns_free((void *)semaPtr);
  break;
  }
  return (0);
}
}
static char *opts___12[9]  = 
  {      (char *)"abswait",      (char *)"broadcast",      (char *)"create",      (char *)"destroy", 
        (char *)"set",      (char *)"signal",      (char *)"timedwait",      (char *)"wait", 
        (char *)((void *)0)};
int NsTclCondObjCmd(ClientData data , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Tcl_Obj *objPtr ;
  Ns_Cond *condPtr ;
  Ns_Mutex *lock___31 ;
  Ns_Time timeout ;
  int result ;
  enum __anonenum_opt_110 opt ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Ns_Event *eventPtr ;
  Ns_Time abstime ;

  {
  tmp = GetArgs(interp, objc, objv, opts___12, 'e', 2, (int *)(& opt), (void **)(& condPtr));
  if (! tmp) {
    return (1);
  }
  switch ((int )opt) {
  case 2: 
  Ns_CondInit(condPtr);
  break;
  case 0: ;
  case 6: ;
  case 7: ;
  if (objc < 4) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"condId mutexId ?timeout?");
    return (1);
  }
  tmp___0 = Tcl_GetString((*(objv + 3)));
  tmp___1 = GetAddr___0(interp, 'm', tmp___0, (void **)(& lock___31));
  if (tmp___1 != 0) {
    return (1);
  }
  if (objc < 5) {
    timeout.usec = 0L;
    timeout.sec = timeout.usec;
  } else {
    tmp___2 = Ns_TclGetTimeFromObj(interp, (*(objv + 4)), & timeout);
    if (tmp___2 != 0) {
      return (1);
    }
  }
  if ((int )opt == 0) {
    result = Ns_CondTimedWait(condPtr, lock___31, & timeout);
  } else {
    if ((int )opt == 6) {
      eventPtr = (Ns_Event *)condPtr;
      result = Ns_TimedWaitForEvent(eventPtr, lock___31, (int )timeout.sec);
    } else {
      if (objc < 5) {
        Ns_CondWait(condPtr, lock___31);
        result = 0;
      } else {
        if (timeout.sec == 0L) {
          if (timeout.usec == 0L) {
            Ns_CondWait(condPtr, lock___31);
            result = 0;
          } else {
            Ns_GetTime(& abstime);
            Ns_IncrTime(& abstime, timeout.sec, timeout.usec);
            result = Ns_CondTimedWait(condPtr, lock___31, & abstime);
          }
        } else {
          Ns_GetTime(& abstime);
          Ns_IncrTime(& abstime, timeout.sec, timeout.usec);
          result = Ns_CondTimedWait(condPtr, lock___31, & abstime);
        }
      }
    }
  }
  if (result == 0) {
    objPtr = Tcl_NewBooleanObj(1);
  } else {
    if (result == -2) {
      objPtr = Tcl_NewBooleanObj(0);
    } else {
      return (1);
    }
  }
  Tcl_SetObjResult(interp, objPtr);
  break;
  case 1: 
  Ns_CondBroadcast(condPtr);
  break;
  case 4: ;
  case 5: 
  Ns_CondSignal(condPtr);
  break;
  case 3: 
  Ns_CondDestroy(condPtr);
  ns_free((void *)condPtr);
  break;
  }
  return (0);
}
}
static char *opts___13[8]  = 
  {      (char *)"create",      (char *)"destroy",      (char *)"readlock",      (char *)"readunlock", 
        (char *)"writelock",      (char *)"writeunlock",      (char *)"unlock",      (char *)((void *)0)};
int NsTclRWLockObjCmd(ClientData data , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Ns_RWLock *rwlockPtr ;
  enum __anonenum_opt_111 opt ;
  int tmp ;

  {
  tmp = GetArgs(interp, objc, objv, opts___13, 'r', 0, (int *)(& opt), (void **)(& rwlockPtr));
  if (! tmp) {
    return (1);
  }
  switch ((int )opt) {
  case 0: 
  Ns_RWLockInit(rwlockPtr);
  break;
  case 2: 
  Ns_RWLockRdLock(rwlockPtr);
  break;
  case 4: 
  Ns_RWLockWrLock(rwlockPtr);
  break;
  case 3: ;
  case 5: ;
  case 6: 
  Ns_RWLockUnlock(rwlockPtr);
  break;
  case 1: 
  Ns_RWLockDestroy(rwlockPtr);
  ns_free((void *)rwlockPtr);
  break;
  }
  return (0);
}
}
int NsTclThreadCmd(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ NsInterp *itPtr ;
  void *status ;
  Ns_Thread tid ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  Tcl_Obj *tmp___9 ;
  char *tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___23 ;
  size_t tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___39 ;
  size_t tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___47 ;
  size_t tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___55 ;
  size_t tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___63 ;
  size_t tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___71 ;
  size_t tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___79 ;
  size_t tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___87 ;
  size_t tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;

  {
  itPtr = (NsInterp *)arg;
  if (argc < 2) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " command arg\"",
                     (void *)0);
    return (1);
  }
  if ((int )(*((*(argv + 1)))) == (int )(*"begin")) {
    if (0) {
      __s1_len___7 = strlen((char const   *)(*(argv + 1)));
      __s2_len___7 = strlen("begin");
      if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                       1))) ==
             1U)) {
        goto _L___23;
      } else {
        if (__s1_len___7 >= 4U) {
          _L___23: 
          if (! ((unsigned int )((void const   *)("begin" + 1)) - (unsigned int )((void const   *)"begin") ==
                 1U)) {
            tmp___74 = 1;
          } else {
            if (__s2_len___7 >= 4U) {
              tmp___74 = 1;
            } else {
              tmp___74 = 0;
            }
          }
        } else {
          tmp___74 = 0;
        }
      }
      if (tmp___74) {
        if (__s1_len___7 < __s2_len___7) {
          tmp___72 = __s1_len___7;
        } else {
          tmp___72 = __s2_len___7;
        }
        tmp___71 = memcmp((void const   *)((char const   *)(*(argv + 1))), (void const   *)"begin",
                          tmp___72 + 1U);
      } else {
        tmp___73 = strcmp((char const   *)(*(argv + 1)), "begin");
        tmp___71 = tmp___73;
      }
    } else {
      tmp___73 = strcmp((char const   *)(*(argv + 1)), "begin");
      tmp___71 = tmp___73;
    }
    if (tmp___71 == 0) {
      goto _L___28;
    } else {
      goto _L___31;
    }
  } else {
    _L___31: 
    if ((int )(*((*(argv + 1)))) == (int )(*"create")) {
      if (0) {
        __s1_len___8 = strlen((char const   *)(*(argv + 1)));
        __s2_len___8 = strlen("create");
        if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                         1))) ==
               1U)) {
          goto _L___25;
        } else {
          if (__s1_len___8 >= 4U) {
            _L___25: 
            if (! ((unsigned int )((void const   *)("create" + 1)) - (unsigned int )((void const   *)"create") ==
                   1U)) {
              tmp___82 = 1;
            } else {
              if (__s2_len___8 >= 4U) {
                tmp___82 = 1;
              } else {
                tmp___82 = 0;
              }
            }
          } else {
            tmp___82 = 0;
          }
        }
        if (tmp___82) {
          if (__s1_len___8 < __s2_len___8) {
            tmp___80 = __s1_len___8;
          } else {
            tmp___80 = __s2_len___8;
          }
          tmp___79 = memcmp((void const   *)((char const   *)(*(argv + 1))), (void const   *)"create",
                            tmp___80 + 1U);
        } else {
          tmp___81 = strcmp((char const   *)(*(argv + 1)), "create");
          tmp___79 = tmp___81;
        }
      } else {
        tmp___81 = strcmp((char const   *)(*(argv + 1)), "create");
        tmp___79 = tmp___81;
      }
      if (tmp___79 == 0) {
        goto _L___28;
      } else {
        goto _L___30;
      }
    } else {
      _L___30: 
      if ((int )(*((*(argv + 1)))) == (int )(*"begindetached")) {
        if (0) {
          __s1_len___9 = strlen((char const   *)(*(argv + 1)));
          __s2_len___9 = strlen("begindetached");
          if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                           1))) ==
                 1U)) {
            goto _L___27;
          } else {
            if (__s1_len___9 >= 4U) {
              _L___27: 
              if (! ((unsigned int )((void const   *)("begindetached" + 1)) - (unsigned int )((void const   *)"begindetached") ==
                     1U)) {
                tmp___90 = 1;
              } else {
                if (__s2_len___9 >= 4U) {
                  tmp___90 = 1;
                } else {
                  tmp___90 = 0;
                }
              }
            } else {
              tmp___90 = 0;
            }
          }
          if (tmp___90) {
            if (__s1_len___9 < __s2_len___9) {
              tmp___88 = __s1_len___9;
            } else {
              tmp___88 = __s2_len___9;
            }
            tmp___87 = memcmp((void const   *)((char const   *)(*(argv + 1))), (void const   *)"begindetached",
                              tmp___88 + 1U);
          } else {
            tmp___89 = strcmp((char const   *)(*(argv + 1)), "begindetached");
            tmp___87 = tmp___89;
          }
        } else {
          tmp___89 = strcmp((char const   *)(*(argv + 1)), "begindetached");
          tmp___87 = tmp___89;
        }
        if (tmp___87 == 0) {
          _L___28: 
          if (argc < 3) {
            Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)),
                             " ", (*(argv + 1)), " script\"", (void *)0);
            return (1);
          }
          if ((int )(*((*(argv + 1)))) == (int )(*"begindetached")) {
            if (0) {
              __s1_len = strlen((char const   *)(*(argv + 1)));
              __s2_len = strlen("begindetached");
              if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                               1))) ==
                     1U)) {
                goto _L___0;
              } else {
                if (__s1_len >= 4U) {
                  _L___0: 
                  if (! ((unsigned int )((void const   *)("begindetached" + 1)) -
                         (unsigned int )((void const   *)"begindetached") == 1U)) {
                    tmp___6 = 1;
                  } else {
                    if (__s2_len >= 4U) {
                      tmp___6 = 1;
                    } else {
                      tmp___6 = 0;
                    }
                  }
                } else {
                  tmp___6 = 0;
                }
              }
              if (tmp___6) {
                if (__s1_len < __s2_len) {
                  tmp___4 = __s1_len;
                } else {
                  tmp___4 = __s2_len;
                }
                tmp___3 = memcmp((void const   *)((char const   *)(*(argv + 1))),
                                 (void const   *)"begindetached", tmp___4 + 1U);
              } else {
                tmp___5 = strcmp((char const   *)(*(argv + 1)), "begindetached");
                tmp___3 = tmp___5;
              }
            } else {
              tmp___5 = strcmp((char const   *)(*(argv + 1)), "begindetached");
              tmp___3 = tmp___5;
            }
            if (tmp___3 == 0) {
              CreateTclThread(itPtr, (*(argv + 2)), 1, (Ns_Thread *)((void *)0));
            } else {
              CreateTclThread(itPtr, (*(argv + 2)), 0, & tid);
              SetAddr(interp, 't', (void *)tid);
            }
          } else {
            CreateTclThread(itPtr, (*(argv + 2)), 0, & tid);
            SetAddr(interp, 't', (void *)tid);
          }
        } else {
          goto _L___29;
        }
      } else {
        _L___29: 
        if ((int )(*((*(argv + 1)))) == (int )(*"wait")) {
          if (0) {
            __s1_len___5 = strlen((char const   *)(*(argv + 1)));
            __s2_len___5 = strlen("wait");
            if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                             1))) ==
                   1U)) {
              goto _L___16;
            } else {
              if (__s1_len___5 >= 4U) {
                _L___16: 
                if (! ((unsigned int )((void const   *)("wait" + 1)) - (unsigned int )((void const   *)"wait") ==
                       1U)) {
                  tmp___58 = 1;
                } else {
                  if (__s2_len___5 >= 4U) {
                    tmp___58 = 1;
                  } else {
                    tmp___58 = 0;
                  }
                }
              } else {
                tmp___58 = 0;
              }
            }
            if (tmp___58) {
              if (__s1_len___5 < __s2_len___5) {
                tmp___56 = __s1_len___5;
              } else {
                tmp___56 = __s2_len___5;
              }
              tmp___55 = memcmp((void const   *)((char const   *)(*(argv + 1))), (void const   *)"wait",
                                tmp___56 + 1U);
            } else {
              tmp___57 = strcmp((char const   *)(*(argv + 1)), "wait");
              tmp___55 = tmp___57;
            }
          } else {
            tmp___57 = strcmp((char const   *)(*(argv + 1)), "wait");
            tmp___55 = tmp___57;
          }
          if (tmp___55 == 0) {
            goto _L___19;
          } else {
            goto _L___21;
          }
        } else {
          _L___21: 
          if ((int )(*((*(argv + 1)))) == (int )(*"join")) {
            if (0) {
              __s1_len___6 = strlen((char const   *)(*(argv + 1)));
              __s2_len___6 = strlen("join");
              if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                               1))) ==
                     1U)) {
                goto _L___18;
              } else {
                if (__s1_len___6 >= 4U) {
                  _L___18: 
                  if (! ((unsigned int )((void const   *)("join" + 1)) - (unsigned int )((void const   *)"join") ==
                         1U)) {
                    tmp___66 = 1;
                  } else {
                    if (__s2_len___6 >= 4U) {
                      tmp___66 = 1;
                    } else {
                      tmp___66 = 0;
                    }
                  }
                } else {
                  tmp___66 = 0;
                }
              }
              if (tmp___66) {
                if (__s1_len___6 < __s2_len___6) {
                  tmp___64 = __s1_len___6;
                } else {
                  tmp___64 = __s2_len___6;
                }
                tmp___63 = memcmp((void const   *)((char const   *)(*(argv + 1))),
                                  (void const   *)"join", tmp___64 + 1U);
              } else {
                tmp___65 = strcmp((char const   *)(*(argv + 1)), "join");
                tmp___63 = tmp___65;
              }
            } else {
              tmp___65 = strcmp((char const   *)(*(argv + 1)), "join");
              tmp___63 = tmp___65;
            }
            if (tmp___63 == 0) {
              _L___19: 
              if (argc < 3) {
                Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)),
                                 " ", (*(argv + 1)), " tid\"", (void *)0);
                return (1);
              }
              tmp___7 = GetAddr___0(interp, 't', (*(argv + 2)), (void **)(& tid));
              if (tmp___7 != 0) {
                return (1);
              }
              Ns_ThreadJoin(& tid, & status);
              Tcl_SetResult(interp, (char *)status, (Tcl_FreeProc *)(& ns_free));
            } else {
              goto _L___20;
            }
          } else {
            _L___20: 
            if ((int )(*((*(argv + 1)))) == (int )(*"get")) {
              if (0) {
                __s1_len___4 = strlen((char const   *)(*(argv + 1)));
                __s2_len___4 = strlen("get");
                if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                                 1))) ==
                       1U)) {
                  goto _L___13;
                } else {
                  if (__s1_len___4 >= 4U) {
                    _L___13: 
                    if (! ((unsigned int )((void const   *)("get" + 1)) - (unsigned int )((void const   *)"get") ==
                           1U)) {
                      tmp___50 = 1;
                    } else {
                      if (__s2_len___4 >= 4U) {
                        tmp___50 = 1;
                      } else {
                        tmp___50 = 0;
                      }
                    }
                  } else {
                    tmp___50 = 0;
                  }
                }
                if (tmp___50) {
                  if (__s1_len___4 < __s2_len___4) {
                    tmp___48 = __s1_len___4;
                  } else {
                    tmp___48 = __s2_len___4;
                  }
                  tmp___47 = memcmp((void const   *)((char const   *)(*(argv + 1))),
                                    (void const   *)"get", tmp___48 + 1U);
                } else {
                  tmp___49 = strcmp((char const   *)(*(argv + 1)), "get");
                  tmp___47 = tmp___49;
                }
              } else {
                tmp___49 = strcmp((char const   *)(*(argv + 1)), "get");
                tmp___47 = tmp___49;
              }
              if (tmp___47 == 0) {
                Ns_ThreadSelf(& tid);
                SetAddr(interp, 't', (void *)tid);
              } else {
                goto _L___14;
              }
            } else {
              _L___14: 
              if ((int )(*((*(argv + 1)))) == (int )(*"getid")) {
                if (0) {
                  __s1_len___2 = strlen((char const   *)(*(argv + 1)));
                  __s2_len___2 = strlen("getid");
                  if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                                   1))) ==
                         1U)) {
                    goto _L___7;
                  } else {
                    if (__s1_len___2 >= 4U) {
                      _L___7: 
                      if (! ((unsigned int )((void const   *)("getid" + 1)) - (unsigned int )((void const   *)"getid") ==
                             1U)) {
                        tmp___34 = 1;
                      } else {
                        if (__s2_len___2 >= 4U) {
                          tmp___34 = 1;
                        } else {
                          tmp___34 = 0;
                        }
                      }
                    } else {
                      tmp___34 = 0;
                    }
                  }
                  if (tmp___34) {
                    if (__s1_len___2 < __s2_len___2) {
                      tmp___32 = __s1_len___2;
                    } else {
                      tmp___32 = __s2_len___2;
                    }
                    tmp___31 = memcmp((void const   *)((char const   *)(*(argv + 1))),
                                      (void const   *)"getid", tmp___32 + 1U);
                  } else {
                    tmp___33 = strcmp((char const   *)(*(argv + 1)), "getid");
                    tmp___31 = tmp___33;
                  }
                } else {
                  tmp___33 = strcmp((char const   *)(*(argv + 1)), "getid");
                  tmp___31 = tmp___33;
                }
                if (tmp___31 == 0) {
                  tmp___8 = Ns_ThreadId();
                  tmp___9 = Tcl_NewIntObj(tmp___8);
                  Tcl_SetObjResult(interp, tmp___9);
                } else {
                  goto _L___11;
                }
              } else {
                _L___11: 
                if ((int )(*((*(argv + 1)))) == (int )(*"id")) {
                  if (0) {
                    __s1_len___3 = strlen((char const   *)(*(argv + 1)));
                    __s2_len___3 = strlen("id");
                    if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) -
                           (unsigned int )((void const   *)(*(argv + 1))) == 1U)) {
                      goto _L___9;
                    } else {
                      if (__s1_len___3 >= 4U) {
                        _L___9: 
                        if (! ((unsigned int )((void const   *)("id" + 1)) - (unsigned int )((void const   *)"id") ==
                               1U)) {
                          tmp___42 = 1;
                        } else {
                          if (__s2_len___3 >= 4U) {
                            tmp___42 = 1;
                          } else {
                            tmp___42 = 0;
                          }
                        }
                      } else {
                        tmp___42 = 0;
                      }
                    }
                    if (tmp___42) {
                      if (__s1_len___3 < __s2_len___3) {
                        tmp___40 = __s1_len___3;
                      } else {
                        tmp___40 = __s2_len___3;
                      }
                      tmp___39 = memcmp((void const   *)((char const   *)(*(argv +
                                                                            1))),
                                        (void const   *)"id", tmp___40 + 1U);
                    } else {
                      tmp___41 = strcmp((char const   *)(*(argv + 1)), "id");
                      tmp___39 = tmp___41;
                    }
                  } else {
                    tmp___41 = strcmp((char const   *)(*(argv + 1)), "id");
                    tmp___39 = tmp___41;
                  }
                  if (tmp___39 == 0) {
                    tmp___8 = Ns_ThreadId();
                    tmp___9 = Tcl_NewIntObj(tmp___8);
                    Tcl_SetObjResult(interp, tmp___9);
                  } else {
                    goto _L___10;
                  }
                } else {
                  _L___10: 
                  if ((int )(*((*(argv + 1)))) == (int )(*"name")) {
                    if (0) {
                      __s1_len___1 = strlen((char const   *)(*(argv + 1)));
                      __s2_len___1 = strlen("name");
                      if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) -
                             (unsigned int )((void const   *)(*(argv + 1))) == 1U)) {
                        goto _L___4;
                      } else {
                        if (__s1_len___1 >= 4U) {
                          _L___4: 
                          if (! ((unsigned int )((void const   *)("name" + 1)) - (unsigned int )((void const   *)"name") ==
                                 1U)) {
                            tmp___26 = 1;
                          } else {
                            if (__s2_len___1 >= 4U) {
                              tmp___26 = 1;
                            } else {
                              tmp___26 = 0;
                            }
                          }
                        } else {
                          tmp___26 = 0;
                        }
                      }
                      if (tmp___26) {
                        if (__s1_len___1 < __s2_len___1) {
                          tmp___24 = __s1_len___1;
                        } else {
                          tmp___24 = __s2_len___1;
                        }
                        tmp___23 = memcmp((void const   *)((char const   *)(*(argv +
                                                                              1))),
                                          (void const   *)"name", tmp___24 + 1U);
                      } else {
                        tmp___25 = strcmp((char const   *)(*(argv + 1)), "name");
                        tmp___23 = tmp___25;
                      }
                    } else {
                      tmp___25 = strcmp((char const   *)(*(argv + 1)), "name");
                      tmp___23 = tmp___25;
                    }
                    if (tmp___23 == 0) {
                      if (argc > 2) {
                        Ns_ThreadSetName((*(argv + 2)));
                      }
                      tmp___10 = Ns_ThreadGetName();
                      Tcl_SetResult(interp, tmp___10, (Tcl_FreeProc *)1);
                    } else {
                      goto _L___5;
                    }
                  } else {
                    _L___5: 
                    if ((int )(*((*(argv + 1)))) == (int )(*"yield")) {
                      if (0) {
                        __s1_len___0 = strlen((char const   *)(*(argv + 1)));
                        __s2_len___0 = strlen("yield");
                        if (! ((unsigned int )((void const   *)((*(argv + 1)) + 1)) -
                               (unsigned int )((void const   *)(*(argv + 1))) == 1U)) {
                          goto _L___2;
                        } else {
                          if (__s1_len___0 >= 4U) {
                            _L___2: 
                            if (! ((unsigned int )((void const   *)("yield" + 1)) -
                                   (unsigned int )((void const   *)"yield") == 1U)) {
                              tmp___18 = 1;
                            } else {
                              if (__s2_len___0 >= 4U) {
                                tmp___18 = 1;
                              } else {
                                tmp___18 = 0;
                              }
                            }
                          } else {
                            tmp___18 = 0;
                          }
                        }
                        if (tmp___18) {
                          if (__s1_len___0 < __s2_len___0) {
                            tmp___16 = __s1_len___0;
                          } else {
                            tmp___16 = __s2_len___0;
                          }
                          tmp___15 = memcmp((void const   *)((char const   *)(*(argv +
                                                                                1))),
                                            (void const   *)"yield", tmp___16 + 1U);
                        } else {
                          tmp___17 = strcmp((char const   *)(*(argv + 1)), "yield");
                          tmp___15 = tmp___17;
                        }
                      } else {
                        tmp___17 = strcmp((char const   *)(*(argv + 1)), "yield");
                        tmp___15 = tmp___17;
                      }
                      if (tmp___15 == 0) {
                        Ns_ThreadYield();
                      } else {
                        Tcl_AppendResult(interp, "unknown command \"", (*(argv + 1)),
                                         "\":  should be begin, begindetached, create get, getid, id, join, wait, or yield",
                                         (void *)0);
                        return (1);
                      }
                    } else {
                      Tcl_AppendResult(interp, "unknown command \"", (*(argv + 1)),
                                       "\":  should be begin, begindetached, create get, getid, id, join, wait, or yield",
                                       (void *)0);
                      return (1);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return (0);
}
}
static void SetAddr(Tcl_Interp *interp , int type , void *addr ) 
{ char buf[40] ;

  {
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%cid%p", type,
          addr);
  Tcl_SetResult(interp, buf, (Tcl_FreeProc *)1);
  return;
}
}
static int GetAddr___0(Tcl_Interp *interp , int type , char *id , void **addrPtr ) 
{ void *addr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  tmp = id;
  id ++;
  if ((int )(*tmp) != type) {
    Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
    return (1);
  } else {
    tmp___0 = id;
    id ++;
    if ((int )(*tmp___0) != 105) {
      Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
      return (1);
    } else {
      tmp___1 = id;
      id ++;
      if ((int )(*tmp___1) != 100) {
        Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
        return (1);
      } else {
        tmp___2 = sscanf((char const   * __restrict  )id, (char const   * __restrict  )"%p",
                         & addr);
        if (tmp___2 != 1) {
          Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
          return (1);
        } else {
          if ((unsigned int )addr == (unsigned int )((void *)0)) {
            Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
            return (1);
          }
        }
      }
    }
  }
  (*addrPtr) = addr;
  return (0);
}
}
int Ns_TclThread(Tcl_Interp *interp , char *script , Ns_Thread *thrPtr ) 
{ NsInterp *itPtr ;
  NsInterp *tmp ;

  {
  tmp = NsGetInterp(interp);
  itPtr = tmp;
  CreateTclThread(itPtr, script, (unsigned int )thrPtr == (unsigned int )((void *)0),
                  thrPtr);
  return (0);
}
}
int Ns_TclDetachedThread(Tcl_Interp *interp , char *script ) 
{ int tmp ;

  {
  tmp = Ns_TclThread(interp, script, (Ns_Thread *)((void *)0));
  return (tmp);
}
}
static void CreateTclThread(NsInterp *itPtr , char *script , int detached , Ns_Thread *thrPtr ) 
{ ThreadArg *argPtr ;
  size_t tmp ;

  {
  tmp = strlen((char const   *)script);
  argPtr = (ThreadArg *)ns_malloc(sizeof(ThreadArg ) + tmp);
  argPtr->detached = detached;
  strcpy((char * __restrict  )(argPtr->script), (char const   * __restrict  )script);
  if ((unsigned int )itPtr != (unsigned int )((void *)0)) {
    if ((unsigned int )itPtr->servPtr != (unsigned int )((void *)0)) {
      argPtr->server = (itPtr->servPtr)->server;
    } else {
      argPtr->server = (char *)((void *)0);
    }
  } else {
    argPtr->server = (char *)((void *)0);
  }
  Ns_ThreadCreate(& NsTclThread, (void *)argPtr, 0L, thrPtr);
  return;
}
}
void NsTclThread(void *arg ) 
{ ThreadArg *argPtr ;
  Tcl_DString ds ;
  Tcl_DString *dsPtr ;
  int detached ;
  char *tmp ;

  {
  argPtr = (ThreadArg *)arg;
  detached = argPtr->detached;
  if (detached) {
    dsPtr = (Tcl_DString *)((void *)0);
  } else {
    Tcl_DStringInit(& ds);
    dsPtr = & ds;
  }
  Ns_WaitForStartup();
  Ns_TclEval(dsPtr, argPtr->server, argPtr->script);
  ns_free((void *)argPtr);
  if (! detached) {
    tmp = Ns_DStringExport(& ds);
    Ns_ThreadExit((void *)tmp);
  }
  return;
}
}
void NsTclThreadArgProc(Tcl_DString *dsPtr , void *arg ) 
{ ThreadArg *argPtr ;

  {
  argPtr = (ThreadArg *)arg;
  Tcl_DStringAppendElement(dsPtr, argPtr->script);
  return;
}
}
static int GetArgs(Tcl_Interp *interp , int objc , Tcl_Obj **objv , char **opts___33 ,
                   int type , int create , int *optPtr , void **addrPtr ) 
{ Tcl_Obj *objPtr ;
  int opt ;
  void *addr ;
  int tmp ;
  int tmp___0 ;

  {
  if (objc < 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"option ?arg ...?");
    return (0);
  }
  tmp = Tcl_GetIndexFromObj(interp, (*(objv + 1)), opts___33, (char *)"option", 0,
                            & opt);
  if (tmp != 0) {
    return (0);
  }
  if (opt == create) {
    addr = ns_malloc(sizeof(void *));
    objPtr = Tcl_GetObjResult(interp);
    SetAddrInternalRep(objPtr, type, addr);
  } else {
    if (objc < 3) {
      Tcl_WrongNumArgs(interp, 2, objv, (char *)"object");
      return (0);
    }
    tmp___0 = GetAddrFromObj(interp, (*(objv + 2)), type, & addr);
    if (tmp___0 != 0) {
      return (0);
    }
  }
  (*addrPtr) = addr;
  (*optPtr) = opt;
  return (1);
}
}
static int GetAddrFromObj(Tcl_Interp *interp , Tcl_Obj *objPtr , int type , void **addrPtr ) 
{ int tmp ;
  char *tmp___0 ;

  {
  tmp = Tcl_ConvertToType(interp, objPtr, & addrType);
  if (tmp != 0) {
    return (1);
  }
  if ((int )objPtr->internalRep.twoPtrValue.ptr1 != type) {
    tmp___0 = Tcl_GetString(objPtr);
    Tcl_AppendResult(interp, "incorrect type: ", tmp___0, (void *)0);
    return (1);
  }
  (*addrPtr) = objPtr->internalRep.twoPtrValue.ptr2;
  return (0);
}
}
static void UpdateStringOfAddr(Tcl_Obj *objPtr ) 
{ int type ;
  void *addr ;
  char buf[40] ;
  size_t len ;

  {
  type = (int )objPtr->internalRep.twoPtrValue.ptr1;
  addr = objPtr->internalRep.twoPtrValue.ptr2;
  len = (size_t )sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%cid%p",
                         type, addr);
  objPtr->bytes = Tcl_Alloc(len + 1U);
  strcpy((char * __restrict  )objPtr->bytes, (char const   * __restrict  )(buf));
  objPtr->length = (int )len;
  return;
}
}
static int SetAddrFromAny(Tcl_Interp *interp , Tcl_Obj *objPtr ) 
{ void *addr ;
  int type ;
  register char *id ;
  register char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  id = Tcl_GetString(objPtr);
  p = id;
  tmp = p;
  p ++;
  type = (int )(*tmp);
  if (type == 0) {
    Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
    return (1);
  } else {
    tmp___0 = p;
    p ++;
    if ((int )(*tmp___0) != 105) {
      Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
      return (1);
    } else {
      tmp___1 = p;
      p ++;
      if ((int )(*tmp___1) != 100) {
        Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
        return (1);
      } else {
        tmp___2 = sscanf((char const   * __restrict  )p, (char const   * __restrict  )"%p",
                         & addr);
        if (tmp___2 != 1) {
          Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
          return (1);
        } else {
          if ((unsigned int )addr == (unsigned int )((void *)0)) {
            Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
            return (1);
          }
        }
      }
    }
  }
  SetAddrInternalRep(objPtr, type, addr);
  return (0);
}
}
static void SetAddrInternalRep(Tcl_Obj *objPtr , int type , void *addr ) 
{ Tcl_ObjType *typePtr ;

  {
  typePtr = objPtr->typePtr;
  if ((unsigned int )typePtr != (unsigned int )((void *)0)) {
    if ((unsigned int )typePtr->freeIntRepProc != (unsigned int )((void *)0)) {
      ((*(typePtr->freeIntRepProc)))(objPtr);
    }
  }
  objPtr->typePtr = & addrType;
  objPtr->internalRep.twoPtrValue.ptr1 = (void *)type;
  objPtr->internalRep.twoPtrValue.ptr2 = addr;
  Tcl_InvalidateStringRep(objPtr);
  return;
}
}
extern void Tcl_SetStringObj(Tcl_Obj *objPtr , char *bytes , int length ) ;
static void SetVar(Array *arrayPtr , Tcl_Obj *key___1 , Tcl_Obj *value ) ;
static void UpdateVar(Tcl_HashEntry *hPtr , Tcl_Obj *obj ) ;
static void FlushArray(Array *arrayPtr ) ;
static Array *LockArray(void *arg , Tcl_Interp *interp , Tcl_Obj *arrayObj , int create ) ;
struct Bucket *NsTclCreateBuckets(char *server , int n ) 
{ char buf[32] ;
  Bucket *buckets ;

  {
  buckets = (Bucket *)ns_malloc(sizeof(Bucket ) * (unsigned int )n);
  while (1) {
    n --;
    if (! (n >= 0)) {
      break;
    }
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"nsv:%d", n);
    Tcl_InitHashTable(& (buckets + n)->arrays, 0);
    Ns_MutexInit(& (buckets + n)->lock);
    Ns_MutexSetName2(& (buckets + n)->lock, buf, server);
  }
  return (buckets);
}
}
int NsTclNsvGetObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Tcl_HashEntry *hPtr ;
  Array *arrayPtr ;
  char *tmp ;
  Tcl_Obj *tmp___0 ;
  char *tmp___1 ;

  {
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"array key");
    return (1);
  }
  arrayPtr = LockArray(arg, interp, (*(objv + 1)), 0);
  if ((unsigned int )arrayPtr == (unsigned int )((void *)0)) {
    return (1);
  }
  tmp = Tcl_GetString((*(objv + 2)));
  hPtr = ((*(arrayPtr->vars.findProc)))(& arrayPtr->vars, tmp);
  if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    tmp___0 = Tcl_GetObjResult(interp);
    Tcl_SetStringObj(tmp___0, (char *)hPtr->clientData, -1);
  }
  Ns_MutexUnlock(& (arrayPtr->bucketPtr)->lock);
  if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
    tmp___1 = Tcl_GetString((*(objv + 2)));
    Tcl_AppendResult(interp, "no such key: ", tmp___1, (void *)0);
    return (1);
  }
  return (0);
}
}
int NsTclNsvExistsObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Array *arrayPtr ;
  int exists ;
  char *tmp ;
  Tcl_HashEntry *tmp___0 ;
  Tcl_Obj *tmp___1 ;

  {
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"array key");
    return (1);
  }
  exists = 0;
  arrayPtr = LockArray(arg, (Tcl_Interp *)((void *)0), (*(objv + 1)), 0);
  if ((unsigned int )arrayPtr != (unsigned int )((void *)0)) {
    tmp = Tcl_GetString((*(objv + 2)));
    tmp___0 = ((*(arrayPtr->vars.findProc)))(& arrayPtr->vars, tmp);
    if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
      exists = 1;
    }
    Ns_MutexUnlock(& (arrayPtr->bucketPtr)->lock);
  }
  tmp___1 = Tcl_GetObjResult(interp);
  Tcl_SetBooleanObj(tmp___1, exists);
  return (0);
}
}
int NsTclNsvSetObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Array *arrayPtr ;
  int tmp ;

  {
  if (objc == 3) {
    tmp = NsTclNsvGetObjCmd(arg, interp, objc, objv);
    return (tmp);
  } else {
    if (objc != 4) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"array key ?value?");
      return (1);
    }
  }
  arrayPtr = LockArray(arg, interp, (*(objv + 1)), 1);
  SetVar(arrayPtr, (*(objv + 2)), (*(objv + 3)));
  Ns_MutexUnlock(& (arrayPtr->bucketPtr)->lock);
  Tcl_SetObjResult(interp, (*(objv + 3)));
  return (0);
}
}
int NsTclNsvIncrObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Array *arrayPtr ;
  int count ;
  int current ;
  int result ;
  int new ;
  char *value ;
  Tcl_HashEntry *hPtr ;
  int tmp ;
  char *tmp___0 ;
  Tcl_Obj *obj ;
  Tcl_Obj *tmp___1 ;

  {
  if (objc != 3) {
    if (objc != 4) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"array key ?count?");
      return (1);
    }
  }
  if (objc == 3) {
    count = 1;
  } else {
    tmp = Tcl_GetIntFromObj(interp, (*(objv + 3)), & count);
    if (tmp != 0) {
      return (1);
    }
  }
  arrayPtr = LockArray(arg, interp, (*(objv + 1)), 1);
  tmp___0 = Tcl_GetString((*(objv + 2)));
  hPtr = ((*(arrayPtr->vars.createProc)))(& arrayPtr->vars, tmp___0, & new);
  if (new) {
    current = 0;
    result = 0;
  } else {
    value = (char *)hPtr->clientData;
    result = Tcl_GetInt(interp, value, & current);
  }
  if (result == 0) {
    tmp___1 = Tcl_GetObjResult(interp);
    obj = tmp___1;
    current += count;
    Tcl_SetIntObj(obj, current);
    UpdateVar(hPtr, obj);
  }
  Ns_MutexUnlock(& (arrayPtr->bucketPtr)->lock);
  return (result);
}
}
int NsTclNsvLappendObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Array *arrayPtr ;
  int i ;
  int new ;
  Tcl_HashEntry *hPtr ;
  char *tmp ;
  Tcl_Obj *tmp___0 ;
  char *tmp___1 ;
  Tcl_Obj *tmp___2 ;

  {
  if (objc < 4) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"array key string ?string ...?");
    return (1);
  }
  arrayPtr = LockArray(arg, interp, (*(objv + 1)), 1);
  tmp = Tcl_GetString((*(objv + 2)));
  hPtr = ((*(arrayPtr->vars.createProc)))(& arrayPtr->vars, tmp, & new);
  if (new) {
    tmp___0 = Tcl_GetObjResult(interp);
    Tcl_SetListObj(tmp___0, objc - 3, objv + 3);
  } else {
    Tcl_SetResult(interp, (char *)hPtr->clientData, (Tcl_FreeProc *)1);
    i = 3;
    while (i < objc) {
      tmp___1 = Tcl_GetString((*(objv + i)));
      Tcl_AppendElement(interp, tmp___1);
      i ++;
    }
  }
  tmp___2 = Tcl_GetObjResult(interp);
  UpdateVar(hPtr, tmp___2);
  Ns_MutexUnlock(& (arrayPtr->bucketPtr)->lock);
  return (0);
}
}
int NsTclNsvAppendObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Array *arrayPtr ;
  int i ;
  int new ;
  Tcl_HashEntry *hPtr ;
  char *tmp ;
  char *tmp___0 ;
  Tcl_Obj *tmp___1 ;

  {
  if (objc < 4) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"array key string ?string ...?");
    return (1);
  }
  arrayPtr = LockArray(arg, interp, (*(objv + 1)), 1);
  tmp = Tcl_GetString((*(objv + 2)));
  hPtr = ((*(arrayPtr->vars.createProc)))(& arrayPtr->vars, tmp, & new);
  if (! new) {
    Tcl_SetResult(interp, (char *)hPtr->clientData, (Tcl_FreeProc *)1);
  }
  i = 3;
  while (i < objc) {
    tmp___0 = Tcl_GetString((*(objv + i)));
    Tcl_AppendResult(interp, tmp___0, (void *)0);
    i ++;
  }
  tmp___1 = Tcl_GetObjResult(interp);
  UpdateVar(hPtr, tmp___1);
  Ns_MutexUnlock(& (arrayPtr->bucketPtr)->lock);
  return (0);
}
}
static char *opts___14[7]  = {      (char *)"set",      (char *)"reset",      (char *)"get",      (char *)"names", 
        (char *)"size",      (char *)"exists",      (char *)((void *)0)};
int NsTclNsvArrayObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Array *arrayPtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  char *pattern ;
  char *key___1 ;
  int i ;
  int lobjc ;
  int size ;
  Tcl_Obj *result ;
  Tcl_Obj **lobjv ;
  int opt ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  if (objc < 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"option ...");
    return (1);
  }
  tmp = Tcl_GetIndexFromObj(interp, (*(objv + 1)), opts___14, (char *)"option", 0,
                            & opt);
  if (tmp != 0) {
    return (1);
  }
  result = Tcl_GetObjResult(interp);
  switch (opt) {
  case 0: ;
  case 1: ;
  if (objc != 4) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"array valueList");
    return (1);
  }
  tmp___0 = Tcl_ListObjGetElements(interp, (*(objv + 3)), & lobjc, & lobjv);
  if (tmp___0 != 0) {
    return (1);
  }
  if (lobjc & 1) {
    tmp___1 = Tcl_GetString((*(objv + 3)));
    Tcl_AppendResult(interp, "invalid list: ", tmp___1, (void *)0);
    return (1);
  }
  arrayPtr = LockArray(arg, interp, (*(objv + 2)), 1);
  if (opt == 1) {
    FlushArray(arrayPtr);
  }
  i = 0;
  while (i < lobjc) {
    SetVar(arrayPtr, (*(lobjv + i)), (*(lobjv + (i + 1))));
    i += 2;
  }
  Ns_MutexUnlock(& (arrayPtr->bucketPtr)->lock);
  break;
  case 4: ;
  case 5: ;
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"array");
    return (1);
  }
  arrayPtr = LockArray(arg, (Tcl_Interp *)((void *)0), (*(objv + 2)), 0);
  if ((unsigned int )arrayPtr == (unsigned int )((void *)0)) {
    size = 0;
  } else {
    if (opt == 4) {
      size = arrayPtr->vars.numEntries;
    } else {
      size = 1;
    }
    Ns_MutexUnlock(& (arrayPtr->bucketPtr)->lock);
  }
  if (opt == 5) {
    Tcl_SetBooleanObj(result, size);
  } else {
    Tcl_SetIntObj(result, size);
  }
  break;
  case 2: ;
  case 3: ;
  if (objc != 3) {
    if (objc != 4) {
      Tcl_WrongNumArgs(interp, 2, objv, (char *)"array ?pattern?");
      return (1);
    }
  }
  arrayPtr = LockArray(arg, (Tcl_Interp *)((void *)0), (*(objv + 2)), 0);
  if ((unsigned int )arrayPtr != (unsigned int )((void *)0)) {
    if (objc > 3) {
      pattern = Tcl_GetString((*(objv + 3)));
    } else {
      pattern = (char *)((void *)0);
    }
    hPtr = Tcl_FirstHashEntry(& arrayPtr->vars, & search);
    while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
      if (arrayPtr->vars.keyType == 1) {
        tmp___3 = hPtr->key.oneWordValue;
      } else {
        if (arrayPtr->vars.keyType == -1) {
          tmp___3 = hPtr->key.oneWordValue;
        } else {
          tmp___3 = hPtr->key.string;
        }
      }
      key___1 = tmp___3;
      if ((unsigned int )pattern == (unsigned int )((void *)0)) {
        goto _L;
      } else {
        tmp___4 = Tcl_StringMatch(key___1, pattern);
        if (tmp___4) {
          _L: 
          Tcl_AppendElement(interp, key___1);
          if (opt == 2) {
            Tcl_AppendElement(interp, (char *)hPtr->clientData);
          }
        }
      }
      hPtr = Tcl_NextHashEntry(& search);
    }
    Ns_MutexUnlock(& (arrayPtr->bucketPtr)->lock);
  }
  break;
  }
  return (0);
}
}
int NsTclNsvUnsetObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Tcl_HashEntry *hPtr ;
  Array *arrayPtr ;
  char *tmp ;
  char *tmp___0 ;

  {
  hPtr = (Tcl_HashEntry *)((void *)0);
  arrayPtr = (Array *)((void *)0);
  if (objc != 2) {
    if (objc != 3) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"array ?key?");
      return (1);
    }
  }
  arrayPtr = LockArray(arg, interp, (*(objv + 1)), 0);
  if ((unsigned int )arrayPtr == (unsigned int )((void *)0)) {
    return (1);
  }
  if (objc == 2) {
    Tcl_DeleteHashEntry(arrayPtr->entryPtr);
  } else {
    tmp = Tcl_GetString((*(objv + 2)));
    hPtr = ((*(arrayPtr->vars.findProc)))(& arrayPtr->vars, tmp);
    if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
      ns_free(hPtr->clientData);
      Tcl_DeleteHashEntry(hPtr);
    }
  }
  Ns_MutexUnlock(& (arrayPtr->bucketPtr)->lock);
  if (objc == 2) {
    FlushArray(arrayPtr);
    Tcl_DeleteHashTable(& arrayPtr->vars);
    ns_free((void *)arrayPtr);
  } else {
    if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
      tmp___0 = Tcl_GetString((*(objv + 2)));
      Tcl_AppendResult(interp, "no such key: ", tmp___0, (void *)0);
      return (1);
    }
  }
  return (0);
}
}
int NsTclNsvNamesObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  NsServer *servPtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  Tcl_Obj *result ;
  Bucket *bucketPtr ;
  char *pattern ;
  char *key___1 ;
  int i ;
  char *tmp___0 ;
  Tcl_Obj *tmp___1 ;
  int tmp___2 ;

  {
  itPtr = (NsInterp *)arg;
  servPtr = itPtr->servPtr;
  if (objc != 1) {
    if (objc != 2) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?pattern?");
      return (1);
    }
  }
  if (objc < 2) {
    pattern = (char *)((void *)0);
  } else {
    pattern = Tcl_GetString((*(objv + 1)));
  }
  result = Tcl_GetObjResult(interp);
  i = 0;
  while (i < servPtr->nsv.nbuckets) {
    bucketPtr = servPtr->nsv.buckets + i;
    Ns_MutexLock(& bucketPtr->lock);
    hPtr = Tcl_FirstHashEntry(& bucketPtr->arrays, & search);
    while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
      if (bucketPtr->arrays.keyType == 1) {
        tmp___0 = hPtr->key.oneWordValue;
      } else {
        if (bucketPtr->arrays.keyType == -1) {
          tmp___0 = hPtr->key.oneWordValue;
        } else {
          tmp___0 = hPtr->key.string;
        }
      }
      key___1 = tmp___0;
      if ((unsigned int )pattern == (unsigned int )((void *)0)) {
        tmp___1 = Tcl_NewStringObj(key___1, -1);
        Tcl_ListObjAppendElement((Tcl_Interp *)((void *)0), result, tmp___1);
      } else {
        tmp___2 = Tcl_StringMatch(key___1, pattern);
        if (tmp___2) {
          tmp___1 = Tcl_NewStringObj(key___1, -1);
          Tcl_ListObjAppendElement((Tcl_Interp *)((void *)0), result, tmp___1);
        }
      }
      hPtr = Tcl_NextHashEntry(& search);
    }
    Ns_MutexUnlock(& bucketPtr->lock);
    i ++;
  }
  return (0);
}
}
static Array *LockArray(void *arg , Tcl_Interp *interp , Tcl_Obj *arrayObj , int create ) 
{ NsInterp *itPtr ;
  Bucket *bucketPtr ;
  Tcl_HashEntry *hPtr ;
  Array *arrayPtr ;
  char *array ;
  register char *p ;
  register unsigned int result ;
  register int i ;
  int new ;

  {
  itPtr = (NsInterp *)arg;
  array = Tcl_GetString(arrayObj);
  p = array;
  result = 0U;
  while (1) {
    i = (int )(*p);
    p ++;
    if (i == 0) {
      break;
    }
    result += (result << 3) + (unsigned int )i;
  }
  i = (int )(result % (unsigned int )(itPtr->servPtr)->nsv.nbuckets);
  bucketPtr = (itPtr->servPtr)->nsv.buckets + i;
  Ns_MutexLock(& bucketPtr->lock);
  if (create) {
    hPtr = ((*(bucketPtr->arrays.createProc)))(& bucketPtr->arrays, array, & new);
    if (! new) {
      arrayPtr = (Array *)hPtr->clientData;
    } else {
      arrayPtr = (Array *)ns_malloc(sizeof(Array ));
      arrayPtr->bucketPtr = bucketPtr;
      arrayPtr->entryPtr = hPtr;
      Tcl_InitHashTable(& arrayPtr->vars, 0);
      hPtr->clientData = (void *)arrayPtr;
    }
  } else {
    hPtr = ((*(bucketPtr->arrays.findProc)))(& bucketPtr->arrays, array);
    if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
      Ns_MutexUnlock(& bucketPtr->lock);
      if ((unsigned int )interp != (unsigned int )((void *)0)) {
        Tcl_AppendResult(interp, "no such array: ", array, (void *)0);
      }
      return ((Array *)((void *)0));
    }
    arrayPtr = (Array *)hPtr->clientData;
  }
  return (arrayPtr);
}
}
static void UpdateVar(Tcl_HashEntry *hPtr , Tcl_Obj *obj ) 
{ char *str ;
  char *old ;
  char *new ;
  int len ;

  {
  str = Tcl_GetStringFromObj(obj, & len);
  old = (char *)hPtr->clientData;
  new = (char *)ns_realloc((void *)old, (unsigned int )(len + 1));
  memcpy((void * __restrict  )new, (void const   * __restrict  )str, (unsigned int )(len +
                                                                                     1));
  hPtr->clientData = (void *)new;
  return;
}
}
static void SetVar(Array *arrayPtr , Tcl_Obj *key___1 , Tcl_Obj *value ) 
{ Tcl_HashEntry *hPtr ;
  int new ;
  char *tmp ;

  {
  tmp = Tcl_GetString(key___1);
  hPtr = ((*(arrayPtr->vars.createProc)))(& arrayPtr->vars, tmp, & new);
  UpdateVar(hPtr, value);
  return;
}
}
static void FlushArray(Array *arrayPtr ) 
{ Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;

  {
  hPtr = Tcl_FirstHashEntry(& arrayPtr->vars, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    ns_free(hPtr->clientData);
    Tcl_DeleteHashEntry(hPtr);
    hPtr = Tcl_NextHashEntry(& search);
  }
  return;
}
}
static char *opts___15[6]  = {      (char *)"exists",      (char *)"get",      (char *)"list",      (char *)"set", 
        (char *)"unset",      (char *)((void *)0)};
int NsTclVarObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  NsServer *servPtr ;
  Tcl_HashTable *tablePtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  int new ;
  int code ;
  char *var ;
  char *val ;
  enum __anonenum_opt_107___6 opt ;
  int tmp ;
  int tmp___0 ;
  Tcl_Obj *tmp___1 ;
  char *tmp___3 ;

  {
  itPtr = (NsInterp *)arg;
  var = (char *)((void *)0);
  val = (char *)((void *)0);
  if (objc < 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"option ?args?");
    return (1);
  }
  tmp = Tcl_GetIndexFromObj(interp, (*(objv + 1)), opts___15, (char *)"option", 0,
                            (int *)(& opt));
  if (tmp != 0) {
    return (1);
  }
  servPtr = itPtr->servPtr;
  tablePtr = & servPtr->var.table;
  code = 0;
  if (objc > 2) {
    var = Tcl_GetString((*(objv + 2)));
  }
  Ns_MutexLock(& servPtr->var.lock);
  switch ((int )opt) {
  case 0: ;
  case 1: ;
  case 4: ;
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"var");
    code = 1;
  } else {
    hPtr = ((*(tablePtr->findProc)))(tablePtr, var);
    if ((int )opt == 0) {
      if (hPtr) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
      tmp___1 = Tcl_GetObjResult(interp);
      Tcl_SetBooleanObj(tmp___1, tmp___0);
    } else {
      if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
        Tcl_AppendResult(interp, "no such variable \"", var, "\"", (void *)0);
        code = 1;
      } else {
        if ((int )opt == 1) {
          Tcl_SetResult(interp, (char *)hPtr->clientData, (Tcl_FreeProc *)1);
        } else {
          ns_free(hPtr->clientData);
          Tcl_DeleteHashEntry(hPtr);
        }
      }
    }
  }
  break;
  case 3: ;
  if (objc != 4) {
    Tcl_WrongNumArgs(interp, 2, objv, (char *)"var value");
    code = 1;
  } else {
    hPtr = ((*(tablePtr->createProc)))(tablePtr, var, & new);
    if (! new) {
      ns_free(hPtr->clientData);
    }
    val = Tcl_GetString((*(objv + 3)));
    hPtr->clientData = (ClientData )ns_strdup((char const   *)val);
    Tcl_SetResult(interp, val, (Tcl_FreeProc *)1);
  }
  break;
  case 2: 
  hPtr = Tcl_FirstHashEntry(tablePtr, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    if (tablePtr->keyType == 1) {
      tmp___3 = hPtr->key.oneWordValue;
    } else {
      if (tablePtr->keyType == -1) {
        tmp___3 = hPtr->key.oneWordValue;
      } else {
        tmp___3 = hPtr->key.string;
      }
    }
    Tcl_AppendElement(interp, tmp___3);
    hPtr = Tcl_NextHashEntry(& search);
  }
  break;
  }
  Ns_MutexUnlock(& servPtr->var.lock);
  return (code);
}
}
extern char Tcl_Backslash(char *src , int *readPtr ) ;
extern char *Tcl_Merge(int argc , char **argv ) ;
char *Tcl_DeleteKeyedListField(Tcl_Interp *interp , char *fieldName , char *keyedList ) ;
int Tcl_GetKeyedListField(Tcl_Interp *interp , char *fieldName , char *keyedList ,
                          char **fieldValuePtr ) ;
int Tcl_GetKeyedListKeys(Tcl_Interp *interp , char *subFieldName , char *keyedList ,
                         int *keyesArgcPtr , char ***keyesArgvPtr ) ;
char *Tcl_SetKeyedListField(Tcl_Interp *interp , char *fieldName , char *fieldValue ,
                            char *keyedList ) ;
static char *tclXWrongArgs  =    (char *)"wrong # args: ";
static int FindElement(Tcl_Interp *interp , char *list , char **elementPtr , char **nextPtr ,
                       int *sizePtr , int *bracePtr ) ;
static void CopyAndCollapse(int count , char *src , char *dst ) ;
static int CompareKeyListField(Tcl_Interp *interp , char *fieldName , char *field ,
                               char **valuePtr , int *valueSizePtr , int *bracedPtr ) ;
static int SplitAndFindField(Tcl_Interp *interp , char *fieldName , char *keyedList ,
                             fieldInfo_t *fieldInfoPtr ) ;
static int CompareKeyListField(Tcl_Interp *interp , char *fieldName , char *field ,
                               char **valuePtr , int *valueSizePtr , int *bracedPtr ) 
{ char *elementPtr ;
  char *nextPtr ;
  int fieldNameSize ;
  int elementSize ;
  int tmp ;
  int tmp___11 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___22 ;

  {
  if ((int )(*(field + 0)) == 0) {
    interp->result = (char *)"invalid keyed list format: list contains an empty field entry";
    return (1);
  }
  tmp = FindElement(interp, field, & elementPtr, & nextPtr, & elementSize, (int *)((void *)0));
  if (tmp != 0) {
    return (1);
  }
  if (elementSize == 0) {
    interp->result = (char *)"invalid keyed list format: list contains an empty field name";
    return (1);
  }
  if ((int )(*(nextPtr + 0)) == 0) {
    Tcl_AppendResult(interp, "invalid keyed list format or inconsistent ", "field name scoping: no value associated with ",
                     "field \"", elementPtr, "\"", (char *)((void *)0));
    return (1);
  }
  fieldNameSize = (int )strlen((char const   *)fieldName);
  if (elementSize == fieldNameSize) {
    if ((int )(*(elementPtr + 0)) == (int )(*(fieldName + 0))) {
      if (0) {
        if (0) {
          __s1_len___0 = strlen((char const   *)elementPtr);
          __s2_len___0 = strlen((char const   *)fieldName);
          if (! ((unsigned int )((void const   *)(elementPtr + 1)) - (unsigned int )((void const   *)elementPtr) ==
                 1U)) {
            goto _L___2;
          } else {
            if (__s1_len___0 >= 4U) {
              _L___2: 
              if (! ((unsigned int )((void const   *)(fieldName + 1)) - (unsigned int )((void const   *)fieldName) ==
                     1U)) {
                tmp___19 = 1;
              } else {
                if (__s2_len___0 >= 4U) {
                  tmp___19 = 1;
                } else {
                  tmp___19 = 0;
                }
              }
            } else {
              tmp___19 = 0;
            }
          }
          if (tmp___19) {
            if (__s1_len___0 < __s2_len___0) {
              tmp___17 = __s1_len___0;
            } else {
              tmp___17 = __s2_len___0;
            }
            tmp___16 = memcmp((void const   *)((char const   *)elementPtr), (void const   *)((char const   *)fieldName),
                              tmp___17 + 1U);
          } else {
            tmp___18 = strcmp((char const   *)elementPtr, (char const   *)fieldName);
            tmp___16 = tmp___18;
          }
        } else {
          tmp___18 = strcmp((char const   *)elementPtr, (char const   *)fieldName);
          tmp___16 = tmp___18;
        }
        tmp___11 = tmp___16;
      } else {
        tmp___11 = strncmp((char const   *)elementPtr, (char const   *)fieldName,
                           (unsigned int )fieldNameSize);
      }
      if (! (tmp___11 == 0)) {
        return (3);
      }
    } else {
      return (3);
    }
  } else {
    return (3);
  }
  tmp___22 = FindElement(interp, nextPtr, & elementPtr, & nextPtr, & elementSize,
                         bracedPtr);
  if (tmp___22 != 0) {
    return (1);
  }
  if ((int )(*(nextPtr + 0)) != 0) {
    Tcl_AppendResult(interp, "invalid keyed list format: ", "trailing data following value in field: \"",
                     elementPtr, "\"", (char *)((void *)0));
    return (1);
  }
  (*valuePtr) = elementPtr;
  (*valueSizePtr) = elementSize;
  return (0);
}
}
static int SplitAndFindField(Tcl_Interp *interp , char *fieldName , char *keyedList ,
                             fieldInfo_t *fieldInfoPtr ) 
{ int idx ;
  int result ;
  int braced ;
  int tmp ;

  {
  if ((unsigned int )fieldName == (unsigned int )((char *)0)) {
    interp->result = (char *)"null key not allowed";
    return (1);
  }
  fieldInfoPtr->argv = (char **)((void *)0);
  tmp = Tcl_SplitList(interp, keyedList, & fieldInfoPtr->argc, & fieldInfoPtr->argv);
  if (tmp != 0) {
    goto errorExit;
  }
  result = 3;
  idx = 0;
  while (idx < fieldInfoPtr->argc) {
    result = CompareKeyListField(interp, fieldName, (*(fieldInfoPtr->argv + idx)),
                                 & fieldInfoPtr->valuePtr, & fieldInfoPtr->valueSize,
                                 & braced);
    if (result != 3) {
      break;
    }
    idx ++;
  }
  if (result == 1) {
    goto errorExit;
  }
  if (result == 3) {
    fieldInfoPtr->foundIdx = -1;
    fieldInfoPtr->valuePtr = (char *)((void *)0);
  } else {
    fieldInfoPtr->foundIdx = idx;
  }
  return (0);
  errorExit: 
  if ((unsigned int )fieldInfoPtr->argv != (unsigned int )((void *)0)) {
    Tcl_Free((char *)fieldInfoPtr->argv);
  }
  fieldInfoPtr->argv = (char **)((void *)0);
  return (1);
}
}
int Tcl_GetKeyedListKeys(Tcl_Interp *interp , char *subFieldName , char *keyedList ,
                         int *keyesArgcPtr , char ***keyesArgvPtr ) 
{ char *scanPtr ;
  char *subFieldList ;
  int result ;
  int keyCount ;
  int totalKeySize ;
  int idx ;
  char *fieldPtr ;
  char *keyPtr ;
  char *nextByte ;
  char *dummyPtr ;
  int fieldSize ;
  int keySize ;
  char **keyArgv ;
  unsigned short const   **tmp ;
  int tmp___1 ;

  {
  while ((int )(*keyedList) != 0) {
    tmp = __ctype_b_loc();
    if (((int const   )(*((*tmp) + (int )((unsigned char )(*keyedList)))) & 8192) ==
        0) {
      break;
    }
    keyedList ++;
  }
  subFieldList = (char *)((void *)0);
  if ((unsigned int )subFieldName != (unsigned int )((void *)0)) {
    if ((int )(*(subFieldName + 0)) != 0) {
      result = Tcl_GetKeyedListField(interp, subFieldName, keyedList, & subFieldList);
      if (result != 0) {
        return (result);
      }
      keyedList = subFieldList;
    }
  }
  keyCount = 0;
  totalKeySize = 0;
  scanPtr = keyedList;
  while ((int )(*scanPtr) != 0) {
    result = FindElement(interp, scanPtr, & fieldPtr, & scanPtr, & fieldSize, (int *)((void *)0));
    if (result != 0) {
      goto errorExit;
    }
    result = FindElement(interp, fieldPtr, & keyPtr, & dummyPtr, & keySize, (int *)((void *)0));
    if (result != 0) {
      goto errorExit;
    }
    keyCount ++;
    totalKeySize += keySize + 1;
  }
  keyArgv = (char **)Tcl_Alloc((unsigned int )(keyCount + 1) * sizeof(char *) + (unsigned int )totalKeySize);
  (*(keyArgv + keyCount)) = (char *)((void *)0);
  nextByte = (char *)keyArgv + (unsigned int )(keyCount + 1) * sizeof(char *);
  scanPtr = keyedList;
  idx = 0;
  while ((int )(*scanPtr) != 0) {
    FindElement(interp, scanPtr, & fieldPtr, & scanPtr, & fieldSize, (int *)((void *)0));
    FindElement(interp, fieldPtr, & keyPtr, & dummyPtr, & keySize, (int *)((void *)0));
    tmp___1 = idx;
    idx ++;
    (*(keyArgv + tmp___1)) = nextByte;
    strncpy((char * __restrict  )nextByte, (char const   * __restrict  )keyPtr, (unsigned int )keySize);
    (*(nextByte + keySize)) = (char )'\000';
    nextByte += keySize + 1;
  }
  (*keyesArgcPtr) = keyCount;
  (*keyesArgvPtr) = keyArgv;
  if ((unsigned int )subFieldList != (unsigned int )((void *)0)) {
    Tcl_Free(subFieldList);
  }
  return (0);
  errorExit: 
  if ((unsigned int )subFieldList != (unsigned int )((void *)0)) {
    Tcl_Free(subFieldList);
  }
  return (1);
}
}
int Tcl_GetKeyedListField(Tcl_Interp *interp , char *fieldName , char *keyedList ,
                          char **fieldValuePtr ) 
{ char *nameSeparPtr ;
  char *scanPtr ;
  char *valuePtr ;
  int valueSize ;
  int result ;
  int braced ;
  unsigned short const   **tmp ;
  char *tmp___1 ;
  char *fieldPtr ;
  int fieldSize ;
  char saveChar ;
  char saveChar___0 ;
  char *fieldValue ;

  {
  if ((unsigned int )fieldName == (unsigned int )((char *)0)) {
    interp->result = (char *)"null key not allowed";
    return (1);
  }
  while ((int )(*keyedList) != 0) {
    tmp = __ctype_b_loc();
    if (((int const   )(*((*tmp) + (int )((unsigned char )(*keyedList)))) & 8192) ==
        0) {
      break;
    }
    keyedList ++;
  }
  tmp___1 = strchr((char const   *)fieldName, '.');
  nameSeparPtr = tmp___1;
  if ((unsigned int )nameSeparPtr != (unsigned int )((void *)0)) {
    (*nameSeparPtr) = (char )'\000';
  }
  scanPtr = keyedList;
  result = 3;
  while ((int )(*scanPtr) != 0) {
    result = FindElement(interp, scanPtr, & fieldPtr, & scanPtr, & fieldSize, (int *)((void *)0));
    if (result != 0) {
      break;
    }
    saveChar = (*(fieldPtr + fieldSize));
    (*(fieldPtr + fieldSize)) = (char )'\000';
    result = CompareKeyListField(interp, fieldName, fieldPtr, & valuePtr, & valueSize,
                                 & braced);
    (*(fieldPtr + fieldSize)) = saveChar;
    if (result != 3) {
      break;
    }
  }
  if (result != 0) {
    goto exitPoint;
  }
  if ((unsigned int )nameSeparPtr != (unsigned int )((void *)0)) {
    saveChar___0 = (*(valuePtr + valueSize));
    (*(valuePtr + valueSize)) = (char )'\000';
    result = Tcl_GetKeyedListField(interp, nameSeparPtr + 1, valuePtr, fieldValuePtr);
    (*(valuePtr + valueSize)) = saveChar___0;
  } else {
    if ((unsigned int )fieldValuePtr != (unsigned int )((void *)0)) {
      fieldValue = Tcl_Alloc((unsigned int )(valueSize + 1));
      if (braced) {
        strncpy((char * __restrict  )fieldValue, (char const   * __restrict  )valuePtr,
                (unsigned int )valueSize);
        (*(fieldValue + valueSize)) = (char )'\000';
      } else {
        CopyAndCollapse(valueSize, valuePtr, fieldValue);
      }
      (*fieldValuePtr) = fieldValue;
    }
  }
  exitPoint: 
  if ((unsigned int )nameSeparPtr != (unsigned int )((void *)0)) {
    (*nameSeparPtr) = (char )'.';
  }
  return (result);
}
}
char *Tcl_SetKeyedListField(Tcl_Interp *interp , char *fieldName , char *fieldValue ,
                            char *keyedList ) 
{ char *nameSeparPtr ;
  char *newField ;
  char *newList ;
  fieldInfo_t fieldInfo ;
  char *elemArgv[2] ;
  char *tmp___0 ;
  int tmp___1 ;
  char saveChar ;

  {
  newField = (char *)((void *)0);
  if ((int )(*(fieldName + 0)) == 0) {
    Tcl_AppendResult(interp, "empty field name", (char *)((void *)0));
    return ((char *)((void *)0));
  }
  if ((unsigned int )keyedList == (unsigned int )((void *)0)) {
    keyedList = (char *)"";
  }
  tmp___0 = strchr((char const   *)fieldName, '.');
  nameSeparPtr = tmp___0;
  if ((unsigned int )nameSeparPtr != (unsigned int )((void *)0)) {
    (*nameSeparPtr) = (char )'\000';
  }
  tmp___1 = SplitAndFindField(interp, fieldName, keyedList, & fieldInfo);
  if (tmp___1 != 0) {
    goto errorExit;
  }
  elemArgv[0] = fieldName;
  if ((unsigned int )nameSeparPtr != (unsigned int )((void *)0)) {
    saveChar = (char)0;
    if ((unsigned int )fieldInfo.valuePtr != (unsigned int )((void *)0)) {
      saveChar = (*(fieldInfo.valuePtr + fieldInfo.valueSize));
      (*(fieldInfo.valuePtr + fieldInfo.valueSize)) = (char )'\000';
    }
    elemArgv[1] = Tcl_SetKeyedListField(interp, nameSeparPtr + 1, fieldValue, fieldInfo.valuePtr);
    if ((unsigned int )fieldInfo.valuePtr != (unsigned int )((void *)0)) {
      (*(fieldInfo.valuePtr + fieldInfo.valueSize)) = saveChar;
    }
    if ((unsigned int )elemArgv[1] == (unsigned int )((void *)0)) {
      goto errorExit;
    }
    newField = Tcl_Merge(2, elemArgv);
    Tcl_Free(elemArgv[1]);
  } else {
    elemArgv[1] = fieldValue;
    newField = Tcl_Merge(2, elemArgv);
  }
  if (fieldInfo.foundIdx == -1) {
    fieldInfo.foundIdx = fieldInfo.argc;
    fieldInfo.argc ++;
  }
  (*(fieldInfo.argv + fieldInfo.foundIdx)) = newField;
  newList = Tcl_Merge(fieldInfo.argc, fieldInfo.argv);
  if ((unsigned int )nameSeparPtr != (unsigned int )((void *)0)) {
    (*nameSeparPtr) = (char )'.';
  }
  Tcl_Free(newField);
  Tcl_Free((char *)fieldInfo.argv);
  return (newList);
  errorExit: 
  if ((unsigned int )nameSeparPtr != (unsigned int )((void *)0)) {
    (*nameSeparPtr) = (char )'.';
  }
  if ((unsigned int )newField != (unsigned int )((void *)0)) {
    Tcl_Free(newField);
  }
  if ((unsigned int )fieldInfo.argv != (unsigned int )((void *)0)) {
    Tcl_Free((char *)fieldInfo.argv);
  }
  return ((char *)((void *)0));
}
}
char *Tcl_DeleteKeyedListField(Tcl_Interp *interp , char *fieldName , char *keyedList ) 
{ char *nameSeparPtr ;
  char *newList ;
  int idx ;
  fieldInfo_t fieldInfo ;
  char *elemArgv[2] ;
  char *newElement ;
  char *tmp___0 ;
  int tmp___1 ;
  char saveChar ;

  {
  tmp___0 = strchr((char const   *)fieldName, '.');
  nameSeparPtr = tmp___0;
  if ((unsigned int )nameSeparPtr != (unsigned int )((void *)0)) {
    (*nameSeparPtr) = (char )'\000';
  }
  tmp___1 = SplitAndFindField(interp, fieldName, keyedList, & fieldInfo);
  if (tmp___1 != 0) {
    goto errorExit;
  }
  if (fieldInfo.foundIdx == -1) {
    Tcl_AppendResult(interp, "field name not found: \"", fieldName, "\"", (char *)((void *)0));
    goto errorExit;
  }
  elemArgv[0] = fieldName;
  if ((unsigned int )nameSeparPtr != (unsigned int )((void *)0)) {
    saveChar = (char)0;
    if ((unsigned int )fieldInfo.valuePtr != (unsigned int )((void *)0)) {
      saveChar = (*(fieldInfo.valuePtr + fieldInfo.valueSize));
      (*(fieldInfo.valuePtr + fieldInfo.valueSize)) = (char )'\000';
    }
    elemArgv[1] = Tcl_DeleteKeyedListField(interp, nameSeparPtr + 1, fieldInfo.valuePtr);
    if ((unsigned int )fieldInfo.valuePtr != (unsigned int )((void *)0)) {
      (*(fieldInfo.valuePtr + fieldInfo.valueSize)) = saveChar;
    }
    if ((unsigned int )elemArgv[1] == (unsigned int )((void *)0)) {
      goto errorExit;
    }
    if ((int )(*(elemArgv[1] + 0)) == 0) {
      newElement = (char *)((void *)0);
    } else {
      newElement = Tcl_Merge(2, elemArgv);
    }
    Tcl_Free(elemArgv[1]);
  } else {
    newElement = (char *)((void *)0);
  }
  if ((unsigned int )newElement == (unsigned int )((void *)0)) {
    idx = fieldInfo.foundIdx;
    while (idx < fieldInfo.argc) {
      (*(fieldInfo.argv + idx)) = (*(fieldInfo.argv + (idx + 1)));
      idx ++;
    }
    fieldInfo.argc --;
  } else {
    (*(fieldInfo.argv + fieldInfo.foundIdx)) = newElement;
  }
  newList = Tcl_Merge(fieldInfo.argc, fieldInfo.argv);
  if ((unsigned int )nameSeparPtr != (unsigned int )((void *)0)) {
    (*nameSeparPtr) = (char )'.';
  }
  if ((unsigned int )newElement != (unsigned int )((void *)0)) {
    Tcl_Free(newElement);
  }
  Tcl_Free((char *)fieldInfo.argv);
  return (newList);
  errorExit: 
  if ((unsigned int )nameSeparPtr != (unsigned int )((void *)0)) {
    (*nameSeparPtr) = (char )'.';
  }
  if ((unsigned int )fieldInfo.argv != (unsigned int )((void *)0)) {
    Tcl_Free((char *)fieldInfo.argv);
  }
  return ((char *)((void *)0));
}
}
int Tcl_KeyldelCmd(ClientData clientData , Tcl_Interp *interp , int argc , char **argv ) 
{ char *keyedList ;
  char *newList ;
  char *varPtr ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  if (argc != 3) {
    Tcl_AppendResult(interp, tclXWrongArgs, (*(argv + 0)), " listvar key", (char *)((void *)0));
    return (1);
  }
  tmp = Tcl_GetVar(interp, (*(argv + 1)), 512);
  keyedList = tmp;
  if ((unsigned int )keyedList == (unsigned int )((void *)0)) {
    return (1);
  }
  newList = Tcl_DeleteKeyedListField(interp, (*(argv + 2)), keyedList);
  if ((unsigned int )newList == (unsigned int )((void *)0)) {
    return (1);
  }
  tmp___0 = Tcl_SetVar(interp, (*(argv + 1)), newList, 512);
  varPtr = tmp___0;
  Tcl_Free(newList);
  if ((unsigned int )varPtr == (unsigned int )((void *)0)) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
int Tcl_KeylgetCmd(ClientData clientData , Tcl_Interp *interp , int argc , char **argv ) 
{ char *keyedList ;
  char *fieldValue ;
  char **fieldValuePtr ;
  int result ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  if (argc < 2) {
    Tcl_AppendResult(interp, tclXWrongArgs, (*(argv + 0)), " listvar ?key? ?retvar | {}?",
                     (char *)((void *)0));
    return (1);
  } else {
    if (argc > 4) {
      Tcl_AppendResult(interp, tclXWrongArgs, (*(argv + 0)), " listvar ?key? ?retvar | {}?",
                       (char *)((void *)0));
      return (1);
    }
  }
  tmp = Tcl_GetVar(interp, (*(argv + 1)), 512);
  keyedList = tmp;
  if ((unsigned int )keyedList == (unsigned int )((void *)0)) {
    return (1);
  }
  if (argc == 2) {
    tmp___0 = Tcl_KeylkeysCmd(clientData, interp, argc, argv);
    return (tmp___0);
  }
  if ((unsigned int )(*(argv + 2)) == (unsigned int )((char *)0)) {
    interp->result = (char *)"null key not allowed";
    return (1);
  }
  if (argc == 4) {
    if ((int )(*((*(argv + 3)) + 0)) == 0) {
      fieldValuePtr = (char **)((void *)0);
    } else {
      fieldValuePtr = & fieldValue;
    }
  } else {
    fieldValuePtr = & fieldValue;
  }
  result = Tcl_GetKeyedListField(interp, (*(argv + 2)), keyedList, fieldValuePtr);
  if (result == 1) {
    return (1);
  }
  if (result == 3) {
    if (argc == 3) {
      Tcl_AppendResult(interp, "key \"", (*(argv + 2)), "\" not found in keyed list",
                       (char *)((void *)0));
      return (1);
    } else {
      interp->result = (char *)"0";
      return (0);
    }
  }
  if (argc == 3) {
    Tcl_SetResult(interp, fieldValue, (Tcl_FreeProc *)3);
    return (0);
  }
  if ((int )(*((*(argv + 3)) + 0)) == 0) {
    interp->result = (char *)"1";
    return (0);
  }
  tmp___1 = Tcl_SetVar(interp, (*(argv + 3)), fieldValue, 512);
  if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
    result = 1;
  } else {
    result = 0;
  }
  Tcl_Free(fieldValue);
  interp->result = (char *)"1";
  return (result);
}
}
int Tcl_KeylkeysCmd(ClientData clientData , Tcl_Interp *interp , int argc , char **argv ) 
{ char *keyedList ;
  char **keyesArgv ;
  int result ;
  int keyesArgc ;
  char *tmp ;
  char *tmp___0 ;

  {
  if (argc < 2) {
    Tcl_AppendResult(interp, tclXWrongArgs, (*(argv + 0)), " listvar ?key?", (char *)((void *)0));
    return (1);
  } else {
    if (argc > 3) {
      Tcl_AppendResult(interp, tclXWrongArgs, (*(argv + 0)), " listvar ?key?", (char *)((void *)0));
      return (1);
    }
  }
  tmp = Tcl_GetVar(interp, (*(argv + 1)), 512);
  keyedList = tmp;
  if ((unsigned int )keyedList == (unsigned int )((void *)0)) {
    return (1);
  }
  result = Tcl_GetKeyedListKeys(interp, (*(argv + 2)), keyedList, & keyesArgc, & keyesArgv);
  if (result == 1) {
    return (1);
  }
  if (result == 3) {
    Tcl_AppendResult(interp, "field name not found: \"", (*(argv + 2)), "\"", (char *)((void *)0));
    return (1);
  }
  tmp___0 = Tcl_Merge(keyesArgc, keyesArgv);
  Tcl_SetResult(interp, tmp___0, (Tcl_FreeProc *)3);
  Tcl_Free((char *)keyesArgv);
  return (0);
}
}
int Tcl_KeylsetCmd(ClientData clientData , Tcl_Interp *interp , int argc , char **argv ) 
{ char *keyedList ;
  char *newList ;
  char *prevList ;
  char *varPtr ;
  int idx ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  if (argc < 4) {
    Tcl_AppendResult(interp, tclXWrongArgs, (*(argv + 0)), " listvar key value ?key value...?",
                     (char *)((void *)0));
    return (1);
  } else {
    if (argc % 2 != 0) {
      Tcl_AppendResult(interp, tclXWrongArgs, (*(argv + 0)), " listvar key value ?key value...?",
                       (char *)((void *)0));
      return (1);
    }
  }
  tmp = Tcl_GetVar(interp, (*(argv + 1)), 0);
  keyedList = tmp;
  newList = keyedList;
  idx = 2;
  while (idx < argc) {
    prevList = newList;
    newList = Tcl_SetKeyedListField(interp, (*(argv + idx)), (*(argv + (idx + 1))),
                                    prevList);
    if ((unsigned int )prevList != (unsigned int )keyedList) {
      Tcl_Free(prevList);
    }
    if ((unsigned int )newList == (unsigned int )((void *)0)) {
      return (1);
    }
    idx += 2;
  }
  tmp___0 = Tcl_SetVar(interp, (*(argv + 1)), newList, 512);
  varPtr = tmp___0;
  Tcl_Free(newList);
  if ((unsigned int )varPtr == (unsigned int )((void *)0)) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
static int FindElement(Tcl_Interp *interp , char *list , char **elementPtr , char **nextPtr ,
                       int *sizePtr , int *bracePtr ) 
{ register char *p ;
  int openBraces ;
  int inQuotes ;
  int size ;
  unsigned short const   **tmp ;
  char *p2 ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int size___0 ;
  char *p2___0 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  openBraces = 0;
  inQuotes = 0;
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*list)))) & 8192)) {
      break;
    }
    list ++;
  }
  if ((int )(*list) == 123) {
    openBraces = 1;
    list ++;
  } else {
    if ((int )(*list) == 34) {
      inQuotes = 1;
      list ++;
    }
  }
  if ((unsigned int )bracePtr != (unsigned int )((int *)0)) {
    (*bracePtr) = openBraces;
  }
  p = list;
  while (1) {
    switch ((int )(*p)) {
    case 123: ;
    if (openBraces != 0) {
      openBraces ++;
    }
    break;
    case 125: ;
    if (openBraces == 1) {
      size = p - list;
      p ++;
      tmp___0 = __ctype_b_loc();
      if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*p)))) & 8192) {
        goto done;
      } else {
        if ((int )(*p) == 0) {
          goto done;
        }
      }
      p2 = p;
      while (1) {
        if ((int )(*p2) != 0) {
          tmp___1 = __ctype_b_loc();
          if ((int const   )(*((*tmp___1) + (int )((unsigned char )(*p2)))) & 8192) {
            break;
          } else {
            if (! ((unsigned int )p2 < (unsigned int )(p + 20))) {
              break;
            }
          }
        } else {
          break;
        }
        p2 ++;
      }
      if ((unsigned int )interp != (unsigned int )((void *)0)) {
        Tcl_ResetResult(interp);
        sprintf((char * __restrict  )interp->result, (char const   * __restrict  )"list element in braces followed by \"%.*s\" instead of space",
                p2 - p, p);
      }
      return (1);
    } else {
      if (openBraces != 0) {
        openBraces --;
      }
    }
    break;
    case 92: 
    Tcl_Backslash(p, & size___0);
    p += size___0 - 1;
    break;
    case 32: ;
    case 12: ;
    case 10: ;
    case 13: ;
    case 9: ;
    case 11: ;
    if (openBraces == 0) {
      if (! inQuotes) {
        size = p - list;
        goto done;
      }
    }
    break;
    case 34: ;
    if (inQuotes) {
      size = p - list;
      p ++;
      tmp___2 = __ctype_b_loc();
      if ((int const   )(*((*tmp___2) + (int )((unsigned char )(*p)))) & 8192) {
        goto done;
      } else {
        if ((int )(*p) == 0) {
          goto done;
        }
      }
      p2___0 = p;
      while (1) {
        if ((int )(*p2___0) != 0) {
          tmp___3 = __ctype_b_loc();
          if ((int const   )(*((*tmp___3) + (int )((unsigned char )(*p2___0)))) &
              8192) {
            break;
          } else {
            if (! ((unsigned int )p2___0 < (unsigned int )(p + 20))) {
              break;
            }
          }
        } else {
          break;
        }
        p2___0 ++;
      }
      if ((unsigned int )interp != (unsigned int )((void *)0)) {
        Tcl_ResetResult(interp);
        sprintf((char * __restrict  )interp->result, (char const   * __restrict  )"list element in quotes followed by \"%.*s\" %s",
                p2___0 - p, p, "instead of space");
      }
      return (1);
    }
    break;
    case 0: ;
    if (openBraces != 0) {
      if ((unsigned int )interp != (unsigned int )((void *)0)) {
        Tcl_SetResult(interp, (char *)"unmatched open brace in list", (Tcl_FreeProc *)0);
      }
      return (1);
    } else {
      if (inQuotes) {
        if ((unsigned int )interp != (unsigned int )((void *)0)) {
          Tcl_SetResult(interp, (char *)"unmatched open quote in list", (Tcl_FreeProc *)0);
        }
        return (1);
      }
    }
    size = p - list;
    goto done;
    }
    p ++;
  }
  done: 
  while (1) {
    tmp___4 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___4) + (int )((unsigned char )(*p)))) & 8192)) {
      break;
    }
    p ++;
  }
  (*elementPtr) = list;
  (*nextPtr) = p;
  if ((unsigned int )sizePtr != (unsigned int )((int *)0)) {
    (*sizePtr) = size;
  }
  return (0);
}
}
static void CopyAndCollapse(int count , char *src , char *dst ) 
{ register char c ;
  int numRead ;

  {
  c = (*src);
  while (count > 0) {
    if ((int )c == 92) {
      (*dst) = Tcl_Backslash(src, & numRead);
      dst ++;
      src += numRead - 1;
      count -= numRead - 1;
    } else {
      (*dst) = c;
      dst ++;
    }
    src ++;
    c = (*src);
    count --;
  }
  (*dst) = (char)0;
  return;
}
}
extern int socketpair(int __domain , int __type , int __protocol , int *__fds ) ;
extern int pipe(int *__pipedes ) ;
extern int sigemptyset(sigset_t *__set ) ;
extern int sigfillset(sigset_t *__set ) ;
extern int sigaddset(sigset_t *__set , int __signo ) ;
extern  __attribute__((__noreturn__)) void abort(void) ;
int ns_sigmask(int how , sigset_t *set , sigset_t *oset ) ;
int ns_sigwait(sigset_t *set , int *sig ) ;
int ns_signal(int sig , void (*proc)(int  ) ) ;
int Ns_GetUserHome(Tcl_DString *pds , char *user ) ;
extern void pthread_kill_other_threads_np(void) ;
extern struct group *getgrnam(char const   *__name ) ;
extern struct passwd *getpwnam(char const   *__name ) ;
static Ns_Mutex lock___13  ;
static int debugMode  ;
void FatalSignalHandler(int signal___0 ) 
{ 

  {
  pthread_kill_other_threads_np();
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )3, (char *)"received fatal signal %d",
         signal___0);
  abort();
}
}
void NsBlockSignals(int debug ) 
{ sigset_t set ;

  {
  debugMode = debug;
  sigemptyset(& set);
  sigaddset(& set, 13);
  sigaddset(& set, 15);
  sigaddset(& set, 1);
  if (! debugMode) {
    sigaddset(& set, 2);
  }
  ns_sigmask(0, & set, (sigset_t *)((void *)0));
  ns_signal(4, & FatalSignalHandler);
  ns_signal(5, & FatalSignalHandler);
  ns_signal(7, & FatalSignalHandler);
  ns_signal(11, & FatalSignalHandler);
  ns_signal(8, & FatalSignalHandler);
  return;
}
}
void NsRestoreSignals(void) 
{ sigset_t set ;
  int sig ;

  {
  sig = 1;
  while (sig < 65) {
    ns_signal(sig, (void (*)(int  ))0);
    sig ++;
  }
  sigfillset(& set);
  ns_sigmask(1, & set, (sigset_t *)((void *)0));
  return;
}
}
void NsHandleSignals(void) 
{ sigset_t set ;
  int err ;
  int sig ;
  int *tmp ;
  char *tmp___0 ;

  {
  sigemptyset(& set);
  sigaddset(& set, 15);
  sigaddset(& set, 1);
  if (! debugMode) {
    sigaddset(& set, 2);
  }
  while (1) {
    while (1) {
      err = ns_sigwait(& set, & sig);
      if (! (err == 4)) {
        break;
      }
    }
    if (err != 0) {
      tmp = __errno_location();
      tmp___0 = strerror((*tmp));
      Ns_Fatal((char *)"signal: ns_sigwait failed: %s", tmp___0);
    }
    if (sig == 1) {
      NsRunSignalProcs();
    }
    if (! (sig == 1)) {
      break;
    }
  }
  ns_sigmask(1, & set, (sigset_t *)((void *)0));
  return;
}
}
void NsSendSignal(int sig ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp___1 = Ns_InfoPid();
  tmp___2 = kill(tmp___1, sig);
  if (tmp___2 != 0) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Ns_Fatal((char *)"unix: kill() failed: \'%s\'", tmp___0);
  }
  return;
}
}
static int Pipe(int *fds , int sockpair ) 
{ int err ;

  {
  if (sockpair) {
    err = socketpair(1, 1, 0, fds);
  } else {
    err = pipe(fds);
  }
  if (! err) {
    fcntl((*(fds + 0)), 2, 1);
    fcntl((*(fds + 1)), 2, 1);
  }
  return (err);
}
}
int ns_sockpair(int *socks ) 
{ int tmp ;

  {
  tmp = Pipe(socks, 1);
  return (tmp);
}
}
int ns_pipe(int *fds ) 
{ int tmp ;

  {
  tmp = Pipe(fds, 0);
  return (tmp);
}
}
int Ns_GetUserHome(Tcl_DString *pds , char *user ) 
{ struct passwd *pw ;
  int retcode ;

  {
  Ns_MutexLock(& lock___13);
  pw = getpwnam((char const   *)user);
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
    retcode = 0;
  } else {
    Tcl_DStringAppend(pds, pw->pw_dir, -1);
    retcode = 1;
  }
  Ns_MutexUnlock(& lock___13);
  return (retcode);
}
}
int Ns_GetGid(char *group ) 
{ int retcode ;
  struct group *grent ;

  {
  Ns_MutexLock(& lock___13);
  grent = getgrnam((char const   *)group);
  if ((unsigned int )grent == (unsigned int )((void *)0)) {
    retcode = -1;
  } else {
    retcode = (int )grent->gr_gid;
  }
  Ns_MutexUnlock(& lock___13);
  return (retcode);
}
}
int Ns_GetUserGid(char *user ) 
{ struct passwd *pw ;
  int retcode ;

  {
  Ns_MutexLock(& lock___13);
  pw = getpwnam((char const   *)user);
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
    retcode = -1;
  } else {
    retcode = (int )pw->pw_gid;
  }
  Ns_MutexUnlock(& lock___13);
  return (retcode);
}
}
int Ns_GetUid(char *user ) 
{ struct passwd *pw ;
  int retcode ;

  {
  Ns_MutexLock(& lock___13);
  pw = getpwnam((char const   *)user);
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
    retcode = -1;
  } else {
    retcode = (int )pw->pw_uid;
  }
  Ns_MutexUnlock(& lock___13);
  return (retcode);
}
}
char *Ns_RelativeUrl(char *url , char *location ) ;
int Ns_ParseUrl(char *url , char **pprotocol , char **phost , char **pport , char **ppath ,
                char **ptail ) ;
int Ns_AbsoluteUrl(Tcl_DString *dsPtr , char *url , char *base ) ;
char *Ns_RelativeUrl(char *url , char *location ) 
{ char *v ;

  {
  if ((unsigned int )url == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  } else {
    if ((unsigned int )location == (unsigned int )((void *)0)) {
      return ((char *)((void *)0));
    }
  }
  v = Ns_Match(location, url);
  if ((unsigned int )v != (unsigned int )((void *)0)) {
    url = v;
  }
  while (1) {
    if ((int )(*(url + 0)) == 47) {
      if (! ((int )(*(url + 1)) == 47)) {
        break;
      }
    } else {
      break;
    }
    url ++;
  }
  return (url);
}
}
int Ns_ParseUrl(char *url , char **pprotocol , char **phost , char **pport , char **ppath ,
                char **ptail ) 
{ char *end ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;

  {
  (*pprotocol) = (char *)((void *)0);
  (*phost) = (char *)((void *)0);
  (*pport) = (char *)((void *)0);
  (*ppath) = (char *)((void *)0);
  (*ptail) = (char *)((void *)0);
  tmp___0 = strchr((char const   *)url, ':');
  end = tmp___0;
  if ((unsigned int )end != (unsigned int )((void *)0)) {
    (*end) = (char )'\000';
    (*pprotocol) = url;
    url = end + 1;
    if ((int )(*url) == 47) {
      if ((int )(*(url + 1)) == 47) {
        url = url + 2;
        (*phost) = url;
        tmp___2 = strchr((char const   *)url, ':');
        end = tmp___2;
        if ((unsigned int )end != (unsigned int )((void *)0)) {
          (*end) = (char )'\000';
          url = end + 1;
          (*pport) = url;
        }
        tmp___4 = strchr((char const   *)url, '/');
        end = tmp___4;
        if ((unsigned int )end == (unsigned int )((void *)0)) {
          (*ppath) = (char *)"";
          (*ptail) = (char *)"";
          return (0);
        }
        (*end) = (char )'\000';
        url = end + 1;
      } else {
        url ++;
      }
    } else {
      url ++;
    }
    (*ppath) = url;
    end = strrchr((char const   *)url, '/');
    if ((unsigned int )end == (unsigned int )((void *)0)) {
      (*ptail) = (*ppath);
      (*ppath) = (char *)"";
    } else {
      (*end) = (char )'\000';
      (*ptail) = end + 1;
    }
  } else {
    if ((int )(*url) == 47) {
      url ++;
      (*ppath) = url;
      end = strrchr((char const   *)url, '/');
      if ((unsigned int )end == (unsigned int )((void *)0)) {
        (*ptail) = (*ppath);
        (*ppath) = (char *)"";
      } else {
        (*end) = (char )'\000';
        (*ptail) = end + 1;
      }
    } else {
      (*ptail) = url;
    }
  }
  return (0);
}
}
int Ns_AbsoluteUrl(Tcl_DString *dsPtr , char *url , char *base ) 
{ char *protocol ;
  char *host ;
  char *port ;
  char *path ;
  char *tail ;
  char *baseprotocol ;
  char *basehost ;
  char *baseport ;
  char *basepath ;
  char *basetail ;
  int status ;

  {
  status = 0;
  url = ns_strdup((char const   *)url);
  base = ns_strdup((char const   *)base);
  Ns_ParseUrl(url, & protocol, & host, & port, & path, & tail);
  Ns_ParseUrl(base, & baseprotocol, & basehost, & baseport, & basepath, & basetail);
  if ((unsigned int )baseprotocol == (unsigned int )((void *)0)) {
    status = -1;
    goto done;
  } else {
    if ((unsigned int )basehost == (unsigned int )((void *)0)) {
      status = -1;
      goto done;
    } else {
      if ((unsigned int )basepath == (unsigned int )((void *)0)) {
        status = -1;
        goto done;
      }
    }
  }
  if ((unsigned int )protocol == (unsigned int )((void *)0)) {
    protocol = baseprotocol;
  }
  if ((unsigned int )host == (unsigned int )((void *)0)) {
    host = basehost;
    port = baseport;
  }
  if ((unsigned int )path == (unsigned int )((void *)0)) {
    path = basepath;
  }
  Ns_DStringVarAppend(dsPtr, protocol, "://", host, (void *)0);
  if ((unsigned int )port != (unsigned int )((void *)0)) {
    Ns_DStringVarAppend(dsPtr, ":", port, (void *)0);
  }
  if ((int )(*path) == 0) {
    Ns_DStringVarAppend(dsPtr, "/", tail, (void *)0);
  } else {
    Ns_DStringVarAppend(dsPtr, "/", path, "/", tail, (void *)0);
  }
  done: 
  ns_free((void *)url);
  ns_free((void *)base);
  return (status);
}
}
char *Ns_EncodeUrlWithEncoding(Tcl_DString *dsPtr , char *string , Tcl_Encoding encoding ) ;
char *Ns_EncodeUrlCharset(Tcl_DString *dsPtr , char *string , char *charset ) ;
static Tcl_Encoding GetUrlEncoding(char *charset ) ;
struct __anonstruct_enc_107 enc[256]  = 
  {      {-1, 3, (char *)"00"}, 
        {-1, 3, (char *)"01"}, 
        {-1, 3, (char *)"02"}, 
        {-1, 3, (char *)"03"}, 
        {-1, 3, (char *)"04"}, 
        {-1, 3, (char *)"05"}, 
        {-1, 3, (char *)"06"}, 
        {-1, 3, (char *)"07"}, 
        {-1, 3, (char *)"08"}, 
        {-1, 3, (char *)"09"}, 
        {-1, 3, (char *)"0a"}, 
        {-1, 3, (char *)"0b"}, 
        {-1, 3, (char *)"0c"}, 
        {-1, 3, (char *)"0d"}, 
        {-1, 3, (char *)"0e"}, 
        {-1, 3, (char *)"0f"}, 
        {-1, 3, (char *)"10"}, 
        {-1, 3, (char *)"11"}, 
        {-1, 3, (char *)"12"}, 
        {-1, 3, (char *)"13"}, 
        {-1, 3, (char *)"14"}, 
        {-1, 3, (char *)"15"}, 
        {-1, 3, (char *)"16"}, 
        {-1, 3, (char *)"17"}, 
        {-1, 3, (char *)"18"}, 
        {-1, 3, (char *)"19"}, 
        {-1, 3, (char *)"1a"}, 
        {-1, 3, (char *)"1b"}, 
        {-1, 3, (char *)"1c"}, 
        {-1, 3, (char *)"1d"}, 
        {-1, 3, (char *)"1e"}, 
        {-1, 3, (char *)"1f"}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 3, (char *)"21"}, 
        {-1, 3, (char *)"22"}, 
        {-1, 3, (char *)"23"}, 
        {-1, 3, (char *)"24"}, 
        {-1, 3, (char *)"25"}, 
        {-1, 3, (char *)"26"}, 
        {-1, 3, (char *)"27"}, 
        {-1, 3, (char *)"28"}, 
        {-1, 3, (char *)"29"}, 
        {-1, 3, (char *)"2a"}, 
        {-1, 3, (char *)"2b"}, 
        {-1, 3, (char *)"2c"}, 
        {-1, 3, (char *)"2d"}, 
        {-1, 3, (char *)"2e"}, 
        {-1, 3, (char *)"2f"}, 
        {0, 1, (char *)((void *)0)}, 
        {1, 1, (char *)((void *)0)}, 
        {2, 1, (char *)((void *)0)}, 
        {3, 1, (char *)((void *)0)}, 
        {4, 1, (char *)((void *)0)}, 
        {5, 1, (char *)((void *)0)}, 
        {6, 1, (char *)((void *)0)}, 
        {7, 1, (char *)((void *)0)}, 
        {8, 1, (char *)((void *)0)}, 
        {9, 1, (char *)((void *)0)}, 
        {-1, 3, (char *)"3a"}, 
        {-1, 3, (char *)"3b"}, 
        {-1, 3, (char *)"3c"}, 
        {-1, 3, (char *)"3d"}, 
        {-1, 3, (char *)"3e"}, 
        {-1, 3, (char *)"3f"}, 
        {-1, 3, (char *)"40"}, 
        {10, 1, (char *)((void *)0)}, 
        {11, 1, (char *)((void *)0)}, 
        {12, 1, (char *)((void *)0)}, 
        {13, 1, (char *)((void *)0)}, 
        {14, 1, (char *)((void *)0)}, 
        {15, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 3, (char *)"5b"}, 
        {-1, 3, (char *)"5c"}, 
        {-1, 3, (char *)"5d"}, 
        {-1, 3, (char *)"5e"}, 
        {-1, 3, (char *)"5f"}, 
        {-1, 3, (char *)"60"}, 
        {10, 1, (char *)((void *)0)}, 
        {11, 1, (char *)((void *)0)}, 
        {12, 1, (char *)((void *)0)}, 
        {13, 1, (char *)((void *)0)}, 
        {14, 1, (char *)((void *)0)}, 
        {15, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 1, (char *)((void *)0)}, 
        {-1, 3, (char *)"7b"}, 
        {-1, 3, (char *)"7c"}, 
        {-1, 3, (char *)"7d"}, 
        {-1, 3, (char *)"7e"}, 
        {-1, 3, (char *)"7f"}, 
        {-1, 3, (char *)"80"}, 
        {-1, 3, (char *)"81"}, 
        {-1, 3, (char *)"82"}, 
        {-1, 3, (char *)"83"}, 
        {-1, 3, (char *)"84"}, 
        {-1, 3, (char *)"85"}, 
        {-1, 3, (char *)"86"}, 
        {-1, 3, (char *)"87"}, 
        {-1, 3, (char *)"88"}, 
        {-1, 3, (char *)"89"}, 
        {-1, 3, (char *)"8a"}, 
        {-1, 3, (char *)"8b"}, 
        {-1, 3, (char *)"8c"}, 
        {-1, 3, (char *)"8d"}, 
        {-1, 3, (char *)"8e"}, 
        {-1, 3, (char *)"8f"}, 
        {-1, 3, (char *)"90"}, 
        {-1, 3, (char *)"91"}, 
        {-1, 3, (char *)"92"}, 
        {-1, 3, (char *)"93"}, 
        {-1, 3, (char *)"94"}, 
        {-1, 3, (char *)"95"}, 
        {-1, 3, (char *)"96"}, 
        {-1, 3, (char *)"97"}, 
        {-1, 3, (char *)"98"}, 
        {-1, 3, (char *)"99"}, 
        {-1, 3, (char *)"9a"}, 
        {-1, 3, (char *)"9b"}, 
        {-1, 3, (char *)"9c"}, 
        {-1, 3, (char *)"9d"}, 
        {-1, 3, (char *)"9e"}, 
        {-1, 3, (char *)"9f"}, 
        {-1, 3, (char *)"a0"}, 
        {-1, 3, (char *)"a1"}, 
        {-1, 3, (char *)"a2"}, 
        {-1, 3, (char *)"a3"}, 
        {-1, 3, (char *)"a4"}, 
        {-1, 3, (char *)"a5"}, 
        {-1, 3, (char *)"a6"}, 
        {-1, 3, (char *)"a7"}, 
        {-1, 3, (char *)"a8"}, 
        {-1, 3, (char *)"a9"}, 
        {-1, 3, (char *)"aa"}, 
        {-1, 3, (char *)"ab"}, 
        {-1, 3, (char *)"ac"}, 
        {-1, 3, (char *)"ad"}, 
        {-1, 3, (char *)"ae"}, 
        {-1, 3, (char *)"af"}, 
        {-1, 3, (char *)"b0"}, 
        {-1, 3, (char *)"b1"}, 
        {-1, 3, (char *)"b2"}, 
        {-1, 3, (char *)"b3"}, 
        {-1, 3, (char *)"b4"}, 
        {-1, 3, (char *)"b5"}, 
        {-1, 3, (char *)"b6"}, 
        {-1, 3, (char *)"b7"}, 
        {-1, 3, (char *)"b8"}, 
        {-1, 3, (char *)"b9"}, 
        {-1, 3, (char *)"ba"}, 
        {-1, 3, (char *)"bb"}, 
        {-1, 3, (char *)"bc"}, 
        {-1, 3, (char *)"bd"}, 
        {-1, 3, (char *)"be"}, 
        {-1, 3, (char *)"bf"}, 
        {-1, 3, (char *)"c0"}, 
        {-1, 3, (char *)"c1"}, 
        {-1, 3, (char *)"c2"}, 
        {-1, 3, (char *)"c3"}, 
        {-1, 3, (char *)"c4"}, 
        {-1, 3, (char *)"c5"}, 
        {-1, 3, (char *)"c6"}, 
        {-1, 3, (char *)"c7"}, 
        {-1, 3, (char *)"c8"}, 
        {-1, 3, (char *)"c9"}, 
        {-1, 3, (char *)"ca"}, 
        {-1, 3, (char *)"cb"}, 
        {-1, 3, (char *)"cc"}, 
        {-1, 3, (char *)"cd"}, 
        {-1, 3, (char *)"ce"}, 
        {-1, 3, (char *)"cf"}, 
        {-1, 3, (char *)"d0"}, 
        {-1, 3, (char *)"d1"}, 
        {-1, 3, (char *)"d2"}, 
        {-1, 3, (char *)"d3"}, 
        {-1, 3, (char *)"d4"}, 
        {-1, 3, (char *)"d5"}, 
        {-1, 3, (char *)"d6"}, 
        {-1, 3, (char *)"d7"}, 
        {-1, 3, (char *)"d8"}, 
        {-1, 3, (char *)"d9"}, 
        {-1, 3, (char *)"da"}, 
        {-1, 3, (char *)"db"}, 
        {-1, 3, (char *)"dc"}, 
        {-1, 3, (char *)"dd"}, 
        {-1, 3, (char *)"de"}, 
        {-1, 3, (char *)"df"}, 
        {-1, 3, (char *)"e0"}, 
        {-1, 3, (char *)"e1"}, 
        {-1, 3, (char *)"e2"}, 
        {-1, 3, (char *)"e3"}, 
        {-1, 3, (char *)"e4"}, 
        {-1, 3, (char *)"e5"}, 
        {-1, 3, (char *)"e6"}, 
        {-1, 3, (char *)"e7"}, 
        {-1, 3, (char *)"e8"}, 
        {-1, 3, (char *)"e9"}, 
        {-1, 3, (char *)"ea"}, 
        {-1, 3, (char *)"eb"}, 
        {-1, 3, (char *)"ec"}, 
        {-1, 3, (char *)"ed"}, 
        {-1, 3, (char *)"ee"}, 
        {-1, 3, (char *)"ef"}, 
        {-1, 3, (char *)"f0"}, 
        {-1, 3, (char *)"f1"}, 
        {-1, 3, (char *)"f2"}, 
        {-1, 3, (char *)"f3"}, 
        {-1, 3, (char *)"f4"}, 
        {-1, 3, (char *)"f5"}, 
        {-1, 3, (char *)"f6"}, 
        {-1, 3, (char *)"f7"}, 
        {-1, 3, (char *)"f8"}, 
        {-1, 3, (char *)"f9"}, 
        {-1, 3, (char *)"fa"}, 
        {-1, 3, (char *)"fb"}, 
        {-1, 3, (char *)"fc"}, 
        {-1, 3, (char *)"fd"}, 
        {-1, 3, (char *)"fe"}, 
        {-1, 3, (char *)"ff"}};
char *Ns_EncodeUrlWithEncoding(Tcl_DString *dsPtr , char *string , Tcl_Encoding encoding ) 
{ register int i ;
  register int n ;
  register char *p ;
  register char *q ;
  Tcl_DString ds ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  if ((unsigned int )encoding != (unsigned int )((void *)0)) {
    string = Tcl_UtfToExternalDString(encoding, string, -1, & ds);
  }
  p = string;
  n = 0;
  while (1) {
    i = (int )((unsigned char )(*p));
    if (! (i != 0)) {
      break;
    }
    n += enc[i].len;
    p ++;
  }
  i = dsPtr->length;
  Tcl_DStringSetLength(dsPtr, dsPtr->length + n);
  q = dsPtr->string + i;
  p = string;
  while (1) {
    i = (int )((unsigned char )(*p));
    if (! (i != 0)) {
      break;
    }
    if ((int )((unsigned char )(*p)) == 32) {
      tmp = q;
      q ++;
      (*tmp) = (char )'+';
    } else {
      if ((unsigned int )enc[i].str == (unsigned int )((void *)0)) {
        tmp___0 = q;
        q ++;
        (*tmp___0) = (*p);
      } else {
        tmp___1 = q;
        q ++;
        (*tmp___1) = (char )'%';
        tmp___2 = q;
        q ++;
        (*tmp___2) = (*(enc[i].str + 0));
        tmp___3 = q;
        q ++;
        (*tmp___3) = (*(enc[i].str + 1));
      }
    }
    p ++;
  }
  if ((unsigned int )encoding != (unsigned int )((void *)0)) {
    Tcl_DStringFree(& ds);
  }
  return (dsPtr->string);
}
}
char *Ns_EncodeUrlCharset(Tcl_DString *dsPtr , char *string , char *charset ) 
{ Tcl_Encoding encoding ;
  Tcl_Encoding tmp ;
  char *tmp___0 ;

  {
  tmp = GetUrlEncoding(charset);
  encoding = tmp;
  tmp___0 = Ns_EncodeUrlWithEncoding(dsPtr, string, encoding);
  return (tmp___0);
}
}
char *Ns_DecodeUrlCharset(Tcl_DString *dsPtr , char *string , char *charset ) 
{ Tcl_Encoding encoding ;
  Tcl_Encoding tmp ;
  char *tmp___0 ;

  {
  tmp = GetUrlEncoding(charset);
  encoding = tmp;
  tmp___0 = Ns_DecodeUrlWithEncoding(dsPtr, string, encoding);
  return (tmp___0);
}
}
char *Ns_DecodeUrlWithEncoding(Tcl_DString *dsPtr , char *string , Tcl_Encoding encoding ) 
{ register int i ;
  register int j ;
  register int n ;
  register char *p ;
  register char *q ;
  char *copy ;
  int length ;
  Tcl_DString ds ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  copy = (char *)((void *)0);
  length = (int )strlen((char const   *)string);
  if ((unsigned int )encoding != (unsigned int )((void *)0)) {
    copy = (char *)ns_malloc((unsigned int )(length + 1));
    q = copy;
  } else {
    i = dsPtr->length;
    Tcl_DStringSetLength(dsPtr, i + length);
    q = dsPtr->string + i;
  }
  p = string;
  n = 0;
  while ((int )((unsigned char )(*p)) != 0) {
    if ((int )((unsigned char )(*(p + 0))) == 37) {
      i = enc[(unsigned char )(*(p + 1))].hex;
      if (i >= 0) {
        j = enc[(unsigned char )(*(p + 2))].hex;
        if (j >= 0) {
          tmp = q;
          q ++;
          (*tmp) = (char )((unsigned char )((i << 4) + j));
          p += 3;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if ((int )((unsigned char )(*p)) == 43) {
        tmp___0 = q;
        q ++;
        (*tmp___0) = (char )' ';
        p ++;
      } else {
        tmp___1 = q;
        q ++;
        tmp___2 = p;
        p ++;
        (*tmp___1) = (*tmp___2);
      }
    }
    n ++;
  }
  (*q) = (char )'\000';
  if ((unsigned int )encoding != (unsigned int )((void *)0)) {
    Tcl_ExternalToUtfDString(encoding, copy, n, & ds);
    Tcl_DStringAppend(dsPtr, ds.string, -1);
    Tcl_DStringFree(& ds);
    if (copy) {
      ns_free((void *)copy);
    }
  } else {
    Tcl_DStringSetLength(dsPtr, n);
  }
  return (dsPtr->string);
}
}
void NsUpdateUrlEncode(void) 
{ 

  {
  nsconf.encoding.urlCharset = Ns_ConfigGetValue((char *)"ns/parameters", (char *)"URLCharset");
  if ((unsigned int )nsconf.encoding.urlCharset != (unsigned int )((void *)0)) {
    nsconf.encoding.urlEncoding = Ns_GetCharsetEncoding(nsconf.encoding.urlCharset);
    if ((unsigned int )nsconf.encoding.urlEncoding == (unsigned int )((void *)0)) {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"no encoding found for charset \"%s\" from config",
             nsconf.encoding.urlCharset);
    }
  } else {
    nsconf.encoding.urlEncoding = (struct Tcl_Encoding_ *)((void *)0);
  }
  return;
}
}
static int EncodeObjCmd(Tcl_Interp *interp , int objc , Tcl_Obj **objv , int encode ) 
{ Tcl_DString ds ;
  char *charset ;
  char *data ;
  char *tmp ;
  char *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___31 ;
  size_t tmp___32 ;
  char *tmp___33 ;
  char *tmp___54 ;
  int tmp___55 ;
  char *tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;
  int tmp___60 ;

  {
  if (objc == 2) {
    charset = (char *)((void *)0);
    data = Tcl_GetString((*(objv + 1)));
  } else {
    if (objc == 4) {
      tmp___0 = Tcl_GetString((*(objv + 1)));
      if ((int )(*tmp___0) == (int )(*"-charset")) {
        if (0) {
          tmp___57 = Tcl_GetString((*(objv + 1)));
          __s1_len = strlen((char const   *)tmp___57);
          __s2_len = strlen("-charset");
          tmp___58 = Tcl_GetString((*(objv + 1)));
          tmp___59 = Tcl_GetString((*(objv + 1)));
          if ((unsigned int )((void const   *)(tmp___58 + 1)) - (unsigned int )((void const   *)tmp___59) ==
              1U) {
            if (__s1_len >= 4U) {
              _L___0: 
              if (! ((unsigned int )((void const   *)("-charset" + 1)) - (unsigned int )((void const   *)"-charset") ==
                     1U)) {
                tmp___60 = 1;
              } else {
                if (__s2_len >= 4U) {
                  tmp___60 = 1;
                } else {
                  tmp___60 = 0;
                }
              }
            } else {
              tmp___60 = 0;
            }
          } else {
            goto _L___0;
          }
          if (tmp___60) {
            if (__s1_len < __s2_len) {
              tmp___32 = __s1_len;
            } else {
              tmp___32 = __s2_len;
            }
            tmp___33 = Tcl_GetString((*(objv + 1)));
            tmp___31 = memcmp((void const   *)((char const   *)tmp___33), (void const   *)"-charset",
                              tmp___32 + 1U);
          } else {
            tmp___54 = Tcl_GetString((*(objv + 1)));
            tmp___55 = strcmp((char const   *)tmp___54, "-charset");
            tmp___31 = tmp___55;
          }
        } else {
          tmp___54 = Tcl_GetString((*(objv + 1)));
          tmp___55 = strcmp((char const   *)tmp___54, "-charset");
          tmp___31 = tmp___55;
        }
        if (tmp___31 == 0) {
          charset = Tcl_GetString((*(objv + 2)));
          data = Tcl_GetString((*(objv + 3)));
        } else {
          tmp = Tcl_GetString((*(objv + 0)));
          Tcl_AppendResult(interp, "bad usage: should be \"", tmp, " ?-charset charset? data\"",
                           (void *)0);
          return (1);
        }
      } else {
        tmp = Tcl_GetString((*(objv + 0)));
        Tcl_AppendResult(interp, "bad usage: should be \"", tmp, " ?-charset charset? data\"",
                         (void *)0);
        return (1);
      }
    } else {
      tmp = Tcl_GetString((*(objv + 0)));
      Tcl_AppendResult(interp, "bad usage: should be \"", tmp, " ?-charset charset? data\"",
                       (void *)0);
      return (1);
    }
  }
  Tcl_DStringInit(& ds);
  if (encode) {
    Ns_EncodeUrlCharset(& ds, data, charset);
  } else {
    Ns_DecodeUrlCharset(& ds, data, charset);
  }
  Tcl_DStringResult(interp, & ds);
  Tcl_DStringFree(& ds);
  return (0);
}
}
int NsTclUrlDecodeObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = EncodeObjCmd(interp, objc, objv, 0);
  return (tmp);
}
}
int NsTclUrlEncodeObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ int tmp ;

  {
  tmp = EncodeObjCmd(interp, objc, objv, 1);
  return (tmp);
}
}
static Tcl_Encoding GetUrlEncoding(char *charset ) 
{ Tcl_Encoding encoding ;
  Conn *connPtr ;
  Conn *tmp ;

  {
  encoding = (struct Tcl_Encoding_ *)((void *)0);
  if ((unsigned int )charset != (unsigned int )((void *)0)) {
    encoding = Ns_GetCharsetEncoding(charset);
    if ((unsigned int )encoding == (unsigned int )((void *)0)) {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"no encoding found for charset \"%s\"",
             charset);
    }
  }
  if ((unsigned int )encoding == (unsigned int )((void *)0)) {
    tmp = (Conn *)Ns_GetConn();
    connPtr = tmp;
    if ((unsigned int )connPtr != (unsigned int )((void *)0)) {
      encoding = connPtr->urlEncoding;
    }
  }
  return (encoding);
}
}
int Ns_FetchPage(Tcl_DString *dsPtr , char *url , char *server ) ;
int Ns_FetchURL(Tcl_DString *dsPtr , char *url , Ns_Set *headers ) ;
static int GetLine(Stream *sPtr , Tcl_DString *dsPtr ) ;
static int FillBuf(Stream *sPtr ) ;
int Ns_FetchPage(Tcl_DString *dsPtr , char *url , char *server ) 
{ Tcl_DString path ;
  int fd ;
  int nread ;
  char buf[1024] ;

  {
  Tcl_DStringInit(& path);
  Ns_UrlToFile(& path, server, url);
  fd = open((char const   *)path.string, 0);
  Tcl_DStringFree(& path);
  if (fd < 0) {
    return (-1);
  }
  while (1) {
    nread = read(fd, (void *)(buf), sizeof(buf));
    if (! (nread > 0)) {
      break;
    }
    Tcl_DStringAppend(dsPtr, buf, nread);
  }
  close(fd);
  return (0);
}
}
int Ns_FetchURL(Tcl_DString *dsPtr , char *url , Ns_Set *headers ) 
{ int sock ;
  char *p ;
  Tcl_DString ds ;
  Stream stream ;
  Ns_Request *request ;
  int status ;
  int tosend ;
  int n ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___23 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___28 ;
  size_t tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;

  {
  status = -1;
  sock = -1;
  Tcl_DStringInit(& ds);
  Ns_DStringVarAppend(& ds, "GET ", url, " HTTP/1.0", (void *)0);
  request = Ns_ParseRequest(ds.string);
  if ((unsigned int )request == (unsigned int )((void *)0)) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"urlopen: invalid url \'%s\'",
           url);
    goto done;
  } else {
    if ((unsigned int )request->protocol == (unsigned int )((void *)0)) {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"urlopen: invalid url \'%s\'",
             url);
      goto done;
    } else {
      if ((int )(*(request->protocol)) == (int )(*"http")) {
        if (0) {
          __s1_len = strlen((char const   *)request->protocol);
          __s2_len = strlen("http");
          if (! ((unsigned int )((void const   *)(request->protocol + 1)) - (unsigned int )((void const   *)request->protocol) ==
                 1U)) {
            goto _L___0;
          } else {
            if (__s1_len >= 4U) {
              _L___0: 
              if (! ((unsigned int )((void const   *)("http" + 1)) - (unsigned int )((void const   *)"http") ==
                     1U)) {
                tmp___6 = 1;
              } else {
                if (__s2_len >= 4U) {
                  tmp___6 = 1;
                } else {
                  tmp___6 = 0;
                }
              }
            } else {
              tmp___6 = 0;
            }
          }
          if (tmp___6) {
            if (__s1_len < __s2_len) {
              tmp___4 = __s1_len;
            } else {
              tmp___4 = __s2_len;
            }
            tmp___3 = memcmp((void const   *)((char const   *)request->protocol),
                             (void const   *)"http", tmp___4 + 1U);
          } else {
            tmp___5 = strcmp((char const   *)request->protocol, "http");
            tmp___3 = tmp___5;
          }
        } else {
          tmp___5 = strcmp((char const   *)request->protocol, "http");
          tmp___3 = tmp___5;
        }
        if (tmp___3 == 0) {
          if ((unsigned int )request->host == (unsigned int )((void *)0)) {
            Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"urlopen: invalid url \'%s\'",
                   url);
            goto done;
          }
        } else {
          Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"urlopen: invalid url \'%s\'",
                 url);
          goto done;
        }
      } else {
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"urlopen: invalid url \'%s\'",
               url);
        goto done;
      }
    }
  }
  if ((int )request->port == 0) {
    request->port = (unsigned short)80;
  }
  sock = Ns_SockConnect(request->host, (int )request->port);
  if (sock == -1) {
    tmp___7 = __errno_location();
    tmp___8 = strerror((*tmp___7));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"urlopen: failed to connect to \'%s\': \'%s\'",
           url, tmp___8);
    goto done;
  }
  Tcl_DStringSetLength(& ds, 0);
  Ns_DStringVarAppend(& ds, "GET ", request->url, (void *)0);
  if ((unsigned int )request->query != (unsigned int )((void *)0)) {
    Ns_DStringVarAppend(& ds, "?", request->query, (void *)0);
  }
  Tcl_DStringAppend(& ds, (char *)" HTTP/1.0\r\nAccept: */*\r\n\r\n", -1);
  p = ds.string;
  tosend = ds.length;
  while (tosend > 0) {
    n = send(sock, (void const   *)p, (unsigned int )tosend, 0);
    if (n == -1) {
      tmp___9 = __errno_location();
      tmp___10 = strerror((*tmp___9));
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"urlopen: failed to send data to \'%s\': \'%s\'",
             url, tmp___10);
      goto done;
    }
    tosend -= n;
    p += n;
  }
  stream.cnt = 0;
  stream.error = 0;
  stream.ptr = stream.buf;
  stream.sock = sock;
  tmp___11 = GetLine(& stream, & ds);
  if (! tmp___11) {
    goto done;
  }
  if ((unsigned int )headers != (unsigned int )((void *)0)) {
    if (0) {
      if (0) {
        __s1_len___1 = strlen((char const   *)ds.string);
        __s2_len___1 = strlen("HTTP");
        if (! ((unsigned int )((void const   *)(ds.string + 1)) - (unsigned int )((void const   *)ds.string) ==
               1U)) {
          goto _L___4;
        } else {
          if (__s1_len___1 >= 4U) {
            _L___4: 
            if (! ((unsigned int )((void const   *)("HTTP" + 1)) - (unsigned int )((void const   *)"HTTP") ==
                   1U)) {
              tmp___31 = 1;
            } else {
              if (__s2_len___1 >= 4U) {
                tmp___31 = 1;
              } else {
                tmp___31 = 0;
              }
            }
          } else {
            tmp___31 = 0;
          }
        }
        if (tmp___31) {
          if (__s1_len___1 < __s2_len___1) {
            tmp___29 = __s1_len___1;
          } else {
            tmp___29 = __s2_len___1;
          }
          tmp___28 = memcmp((void const   *)((char const   *)ds.string), (void const   *)"HTTP",
                            tmp___29 + 1U);
        } else {
          tmp___30 = strcmp((char const   *)ds.string, "HTTP");
          tmp___28 = tmp___30;
        }
      } else {
        tmp___30 = strcmp((char const   *)ds.string, "HTTP");
        tmp___28 = tmp___30;
      }
      tmp___23 = tmp___28;
    } else {
      tmp___23 = strncmp((char const   *)ds.string, "HTTP", 4U);
    }
    if (tmp___23 == 0) {
      if ((unsigned int )headers->name != (unsigned int )((void *)0)) {
        ns_free((void *)headers->name);
      }
      headers->name = Ns_DStringExport(& ds);
    }
  }
  while (1) {
    tmp___34 = GetLine(& stream, & ds);
    if (! tmp___34) {
      goto done;
    }
    if (ds.length > 0) {
      if ((unsigned int )headers != (unsigned int )((void *)0)) {
        tmp___35 = Ns_ParseHeader(headers, ds.string, (enum __anonenum_Ns_HeaderCaseDisposition_68 )0);
        if (tmp___35 != 0) {
          goto done;
        }
      }
    }
    if (! (ds.length > 0)) {
      break;
    }
  }
  while (1) {
    Tcl_DStringAppend(dsPtr, stream.ptr, stream.cnt);
    tmp___36 = FillBuf(& stream);
    if (! tmp___36) {
      break;
    }
  }
  if (! stream.error) {
    status = 0;
  }
  done: 
  if ((unsigned int )request != (unsigned int )((void *)0)) {
    Ns_FreeRequest(request);
  }
  if (sock != -1) {
    close(sock);
  }
  Tcl_DStringFree(& ds);
  return (status);
}
}
int NsTclGetUrlObjCmd(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ NsInterp *itPtr ;
  Tcl_DString ds ;
  Ns_Set *headers ;
  int status ;
  int code ;
  char *url ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  Tcl_Obj *tmp___2 ;
  Tcl_Obj *tmp___3 ;
  Tcl_Obj *tmp___4 ;

  {
  itPtr = (NsInterp *)arg;
  if (objc != 3) {
    if (objc != 2) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"url ?headersSetIdVar?");
      return (1);
    }
  }
  code = 1;
  if (objc == 2) {
    headers = (Ns_Set *)((void *)0);
  } else {
    headers = Ns_SetCreate((char *)((void *)0));
  }
  Tcl_DStringInit(& ds);
  url = Tcl_GetString((*(objv + 1)));
  if ((int )(*(url + 1)) == 47) {
    tmp = Tcl_GetString((*(objv + 1)));
    status = Ns_FetchPage(& ds, tmp, (itPtr->servPtr)->server);
  } else {
    tmp___0 = Tcl_GetString((*(objv + 1)));
    status = Ns_FetchURL(& ds, tmp___0, headers);
  }
  if (status != 0) {
    tmp___1 = Tcl_GetString((*(objv + 1)));
    tmp___2 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___2, "could not fetch: ", tmp___1, (void *)0);
    if ((unsigned int )headers != (unsigned int )((void *)0)) {
      Ns_SetFree(headers);
    }
    goto done;
  }
  if (objc == 3) {
    Ns_TclEnterSet(interp, headers, 1);
    tmp___3 = Tcl_GetObjResult(interp);
    tmp___4 = Tcl_ObjSetVar2(interp, (*(objv + 2)), (Tcl_Obj *)((void *)0), tmp___3,
                             512);
    if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
      goto done;
    }
  }
  Tcl_SetResult(interp, ds.string, (Tcl_FreeProc *)1);
  code = 0;
  done: 
  Tcl_DStringFree(& ds);
  return (code);
}
}
static int FillBuf(Stream *sPtr ) 
{ int n ;
  int *tmp ;
  char *tmp___0 ;

  {
  n = recv(sPtr->sock, (void *)(sPtr->buf), 2048U, 0);
  if (n <= 0) {
    if (n < 0) {
      tmp = __errno_location();
      tmp___0 = strerror((*tmp));
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"urlopen: failed to fill socket stream buffer: \'%s\'",
             tmp___0);
      sPtr->error = 1;
    }
    return (0);
  }
  sPtr->buf[n] = (char )'\000';
  sPtr->ptr = sPtr->buf;
  sPtr->cnt = n;
  return (1);
}
}
static int GetLine(Stream *sPtr , Tcl_DString *dsPtr ) 
{ char *eol ;
  int n ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  Tcl_DStringSetLength(dsPtr, 0);
  while (1) {
    if (sPtr->cnt > 0) {
      tmp___0 = strchr((char const   *)sPtr->ptr, '\n');
      eol = tmp___0;
      if ((unsigned int )eol == (unsigned int )((void *)0)) {
        n = sPtr->cnt;
      } else {
        tmp___1 = eol;
        eol ++;
        (*tmp___1) = (char )'\000';
        n = eol - sPtr->ptr;
      }
      Tcl_DStringAppend(dsPtr, sPtr->ptr, n - 1);
      sPtr->ptr += n;
      sPtr->cnt -= n;
      if ((unsigned int )eol != (unsigned int )((void *)0)) {
        n = dsPtr->length;
        if (n > 0) {
          if ((int )(*(dsPtr->string + (n - 1))) == 13) {
            Tcl_DStringSetLength(dsPtr, n - 1);
          }
        }
        return (1);
      }
    }
    tmp___2 = FillBuf(sPtr);
    if (! tmp___2) {
      break;
    }
  }
  return (0);
}
}
void *Ns_UrlSpecificGetFast(char *server , char *method , char *url , int id ) ;
void *Ns_UrlSpecificGetExact(char *server , char *method , char *url , int id , int flags ) ;
int Ns_ServerSpecificAlloc(void) ;
void Ns_ServerSpecificSet(char *handle , int id , void *data , int flags , void (*deletefunc)(void * ) ) ;
void *Ns_ServerSpecificGet(char *handle , int id ) ;
void *Ns_ServerSpecificDestroy(char *handle , int id , int flags ) ;
static void NodeDestroy(Node *nodePtr ) ;
static int CmpNodes(Node **leftPtrPtr , Node **rightPtrPtr ) ;
static int CmpIdWithNode(int id , Node **nodePtrPtr ) ;
static Ns_Index *IndexNodeCreate(void) ;
static void IndexNodeDestroy(Ns_Index *indexPtr ) ;
static int CmpBranches(Branch **leftPtrPtr , Branch **rightPtrPtr ) ;
static int CmpKeyWithBranch(char *key___1 , Branch **branchPtrPtr ) ;
static void MkSeq(Tcl_DString *dsPtr , char *server , char *method , char *url ) ;
static void TrieInit(Trie *triePtr ) ;
static void TrieAdd(Trie *triePtr , char *seq , int id , void *data , int flags ,
                    void (*deletefunc)(void * ) ) ;
static void TrieTrunc(Trie *triePtr , int id ) ;
static int TrieBranchTrunc(Trie *triePtr , char *seq , int id ) ;
static void *TrieFind(Trie *triePtr , char *seq , int id , int *depthPtr ) ;
static void *TrieFindExact(Trie *triePtr , char *seq , int id , int flags ) ;
static void *TrieDelete(Trie *triePtr , char *seq , int id , int flags ) ;
static int CmpChannels(Channel **leftPtrPtr , Channel **rightPtrPtr ) ;
static int CmpKeyWithChannel(char *key___1 , Channel **channelPtrPtr ) ;
static int CmpChannelsAsStrings(Channel **leftPtrPtr , Channel **rightPtrPtr ) ;
static int CmpKeyWithChannelAsStrings(char *key___1 , Channel **channelPtrPtr ) ;
static void JunctionInit(Junction *juncPtr ) ;
static void JunctionAdd(Junction *juncPtr , char *seq , int id , void *data , int flags ,
                        void (*deletefunc)(void * ) ) ;
static void JunctionBranchTrunc(Junction *juncPtr , char *seq , int id ) ;
static void *JunctionFind(Junction *juncPtr , char *seq , int id , int fast ) ;
static void *JunctionFindExact(Junction *juncPtr , char *seq , int id , int flags ,
                               int fast ) ;
static void *JunctionDelete(Junction *juncPtr , char *seq , int id , int flags ) ;
static Junction urlspace  ;
static Ns_Mutex lock___14  ;
void NsInitUrlSpace(void) 
{ 

  {
  Ns_MutexSetName(& lock___14, (char *)"ns:urlspace");
  JunctionInit(& urlspace);
  return;
}
}
static int nextid  =    0;
int Ns_UrlSpecificAlloc(void) 
{ int id ;
  int tmp ;

  {
  Ns_MutexLock(& lock___14);
  tmp = nextid;
  nextid ++;
  id = tmp;
  Ns_MutexUnlock(& lock___14);
  return (id);
}
}
void Ns_UrlSpecificSet(char *server , char *method , char *url , int id , void *data ,
                       int flags , void (*deletefunc)(void * ) ) 
{ Tcl_DString ds ;

  {
  Tcl_DStringInit(& ds);
  MkSeq(& ds, server, method, url);
  Ns_MutexLock(& lock___14);
  JunctionAdd(& urlspace, ds.string, id, data, flags, deletefunc);
  Ns_MutexUnlock(& lock___14);
  Tcl_DStringFree(& ds);
  return;
}
}
void *Ns_UrlSpecificGet(char *server , char *method , char *url , int id ) 
{ Tcl_DString ds ;
  void *data ;

  {
  Tcl_DStringInit(& ds);
  MkSeq(& ds, server, method, url);
  Ns_MutexLock(& lock___14);
  data = JunctionFind(& urlspace, ds.string, id, 0);
  Ns_MutexUnlock(& lock___14);
  Tcl_DStringFree(& ds);
  return (data);
}
}
void *Ns_UrlSpecificGetFast(char *server , char *method , char *url , int id ) 
{ Tcl_DString ds ;
  void *data ;

  {
  Tcl_DStringInit(& ds);
  MkSeq(& ds, server, method, url);
  Ns_MutexLock(& lock___14);
  data = JunctionFind(& urlspace, ds.string, id, 1);
  Ns_MutexUnlock(& lock___14);
  Tcl_DStringFree(& ds);
  return (data);
}
}
void *Ns_UrlSpecificGetExact(char *server , char *method , char *url , int id , int flags ) 
{ Tcl_DString ds ;
  void *data ;

  {
  Tcl_DStringInit(& ds);
  MkSeq(& ds, server, method, url);
  Ns_MutexLock(& lock___14);
  data = JunctionFindExact(& urlspace, ds.string, id, flags, 0);
  Ns_MutexUnlock(& lock___14);
  Tcl_DStringFree(& ds);
  return (data);
}
}
void *Ns_UrlSpecificDestroy(char *server , char *method , char *url , int id , int flags ) 
{ Tcl_DString ds ;
  void *data ;

  {
  data = (void *)0;
  Tcl_DStringInit(& ds);
  MkSeq(& ds, server, method, url);
  Ns_MutexLock(& lock___14);
  if (flags & 8) {
    JunctionBranchTrunc(& urlspace, ds.string, id);
    data = (void *)0;
  } else {
    data = JunctionDelete(& urlspace, ds.string, id, flags);
  }
  Ns_MutexUnlock(& lock___14);
  Tcl_DStringFree(& ds);
  return (data);
}
}
int Ns_ServerSpecificAlloc(void) 
{ int tmp ;

  {
  tmp = Ns_UrlSpecificAlloc();
  return (tmp);
}
}
void Ns_ServerSpecificSet(char *handle , int id , void *data , int flags , void (*deletefunc)(void * ) ) 
{ 

  {
  Ns_UrlSpecificSet(handle, (char *)((void *)0), (char *)((void *)0), id, data, flags,
                    deletefunc);
  return;
}
}
void *Ns_ServerSpecificGet(char *handle , int id ) 
{ void *tmp ;

  {
  tmp = Ns_UrlSpecificGet(handle, (char *)((void *)0), (char *)((void *)0), id);
  return (tmp);
}
}
void *Ns_ServerSpecificDestroy(char *handle , int id , int flags ) 
{ void *tmp ;

  {
  tmp = Ns_UrlSpecificDestroy(handle, (char *)((void *)0), (char *)((void *)0), id,
                              flags);
  return (tmp);
}
}
static void NodeDestroy(Node *nodePtr ) 
{ 

  {
  if ((unsigned int )nodePtr == (unsigned int )((void *)0)) {
    goto done;
  }
  if ((unsigned int )nodePtr->deletefuncNoInherit != (unsigned int )((void *)0)) {
    ((*(nodePtr->deletefuncNoInherit)))(nodePtr->dataNoInherit);
  }
  if ((unsigned int )nodePtr->deletefuncInherit != (unsigned int )((void *)0)) {
    ((*(nodePtr->deletefuncInherit)))(nodePtr->dataInherit);
  }
  ns_free((void *)nodePtr);
  done: 
  return;
}
}
static int CmpNodes(Node **leftPtrPtr , Node **rightPtrPtr ) 
{ int tmp ;

  {
  if (((*leftPtrPtr))->id != ((*rightPtrPtr))->id) {
    if (((*leftPtrPtr))->id > ((*rightPtrPtr))->id) {
      tmp = 1;
    } else {
      tmp = -1;
    }
    return (tmp);
  } else {
    return (0);
  }
}
}
static int CmpIdWithNode(int id , Node **nodePtrPtr ) 
{ int tmp ;

  {
  if (id != ((*nodePtrPtr))->id) {
    if (id > ((*nodePtrPtr))->id) {
      tmp = 1;
    } else {
      tmp = -1;
    }
    return (tmp);
  } else {
    return (0);
  }
}
}
static Ns_Index *IndexNodeCreate(void) 
{ Ns_Index *indexPtr ;

  {
  indexPtr = (Ns_Index *)ns_malloc(sizeof(Ns_Index ));
  Ns_IndexInit(indexPtr, 5, (int (*)(void const   * , void const   * ))(& CmpNodes),
               (int (*)(void const   * , void const   * ))(& CmpIdWithNode));
  return (indexPtr);
}
}
static void IndexNodeDestroy(Ns_Index *indexPtr ) 
{ int i ;
  void *tmp ;
  int tmp___0 ;

  {
  i = indexPtr->n;
  while (1) {
    tmp___0 = i;
    i --;
    if (! tmp___0) {
      break;
    }
    tmp = Ns_IndexEl(indexPtr, i);
    NodeDestroy((Node *)tmp);
  }
  Ns_IndexDestroy(indexPtr);
  ns_free((void *)indexPtr);
  return;
}
}
static int CmpBranches(Branch **leftPtrPtr , Branch **rightPtrPtr ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if (0) {
    __s1_len = strlen((char const   *)((*leftPtrPtr))->word);
    __s2_len = strlen((char const   *)((*rightPtrPtr))->word);
    if (! ((unsigned int )((void const   *)(((*leftPtrPtr))->word + 1)) - (unsigned int )((void const   *)((*leftPtrPtr))->word) ==
           1U)) {
      goto _L___0;
    } else {
      if (__s1_len >= 4U) {
        _L___0: 
        if (! ((unsigned int )((void const   *)(((*rightPtrPtr))->word + 1)) - (unsigned int )((void const   *)((*rightPtrPtr))->word) ==
               1U)) {
          tmp___6 = 1;
        } else {
          if (__s2_len >= 4U) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        }
      } else {
        tmp___6 = 0;
      }
    }
    if (tmp___6) {
      if (__s1_len < __s2_len) {
        tmp___4 = __s1_len;
      } else {
        tmp___4 = __s2_len;
      }
      tmp___3 = memcmp((void const   *)((char const   *)((*leftPtrPtr))->word), (void const   *)((char const   *)((*rightPtrPtr))->word),
                       tmp___4 + 1U);
    } else {
      tmp___5 = strcmp((char const   *)((*leftPtrPtr))->word, (char const   *)((*rightPtrPtr))->word);
      tmp___3 = tmp___5;
    }
  } else {
    tmp___5 = strcmp((char const   *)((*leftPtrPtr))->word, (char const   *)((*rightPtrPtr))->word);
    tmp___3 = tmp___5;
  }
  return (tmp___3);
}
}
static int CmpKeyWithBranch(char *key___1 , Branch **branchPtrPtr ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if (0) {
    __s1_len = strlen((char const   *)key___1);
    __s2_len = strlen((char const   *)((*branchPtrPtr))->word);
    if (! ((unsigned int )((void const   *)(key___1 + 1)) - (unsigned int )((void const   *)key___1) ==
           1U)) {
      goto _L___0;
    } else {
      if (__s1_len >= 4U) {
        _L___0: 
        if (! ((unsigned int )((void const   *)(((*branchPtrPtr))->word + 1)) - (unsigned int )((void const   *)((*branchPtrPtr))->word) ==
               1U)) {
          tmp___6 = 1;
        } else {
          if (__s2_len >= 4U) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        }
      } else {
        tmp___6 = 0;
      }
    }
    if (tmp___6) {
      if (__s1_len < __s2_len) {
        tmp___4 = __s1_len;
      } else {
        tmp___4 = __s2_len;
      }
      tmp___3 = memcmp((void const   *)((char const   *)key___1), (void const   *)((char const   *)((*branchPtrPtr))->word),
                       tmp___4 + 1U);
    } else {
      tmp___5 = strcmp((char const   *)key___1, (char const   *)((*branchPtrPtr))->word);
      tmp___3 = tmp___5;
    }
  } else {
    tmp___5 = strcmp((char const   *)key___1, (char const   *)((*branchPtrPtr))->word);
    tmp___3 = tmp___5;
  }
  return (tmp___3);
}
}
static void TrieInit(Trie *triePtr ) 
{ 

  {
  Ns_IndexInit(& triePtr->branches, 25, (int (*)(void const   * , void const   * ))(& CmpBranches),
               (int (*)(void const   * , void const   * ))(& CmpKeyWithBranch));
  triePtr->indexnode = (Ns_Index *)((void *)0);
  return;
}
}
static void TrieAdd(Trie *triePtr , char *seq , int id , void *data , int flags ,
                    void (*deletefunc)(void * ) ) 
{ Node *nodePtr ;
  Branch *branchPtr ;
  size_t tmp ;

  {
  if ((int )(*seq) == 0) {
    if ((unsigned int )triePtr->indexnode == (unsigned int )((void *)0)) {
      triePtr->indexnode = IndexNodeCreate();
      nodePtr = (Node *)((void *)0);
    } else {
      nodePtr = (Node *)Ns_IndexFind(triePtr->indexnode, (void *)id);
    }
    if ((unsigned int )nodePtr == (unsigned int )((void *)0)) {
      nodePtr = (Node *)ns_malloc(sizeof(Node ));
      nodePtr->id = id;
      Ns_IndexAdd(triePtr->indexnode, (void *)nodePtr);
      nodePtr->dataInherit = (void *)0;
      nodePtr->dataNoInherit = (void *)0;
      nodePtr->deletefuncInherit = (void (*)(void * ))((void *)0);
      nodePtr->deletefuncNoInherit = (void (*)(void * ))((void *)0);
    } else {
      if ((flags & 4) == 0) {
        if ((flags & 2) != 0) {
          if ((unsigned int )nodePtr->deletefuncNoInherit != (unsigned int )((void *)0)) {
            ((*(nodePtr->deletefuncNoInherit)))(nodePtr->dataNoInherit);
          }
        } else {
          if ((unsigned int )nodePtr->deletefuncInherit != (unsigned int )((void *)0)) {
            ((*(nodePtr->deletefuncInherit)))(nodePtr->dataInherit);
          }
        }
      }
    }
    if (flags & 2) {
      nodePtr->dataNoInherit = data;
      nodePtr->deletefuncNoInherit = deletefunc;
    } else {
      nodePtr->dataInherit = data;
      nodePtr->deletefuncInherit = deletefunc;
    }
  } else {
    branchPtr = (Branch *)Ns_IndexFind(& triePtr->branches, (void *)seq);
    if ((unsigned int )branchPtr == (unsigned int )((void *)0)) {
      branchPtr = (Branch *)ns_malloc(sizeof(Branch ));
      branchPtr->word = ns_strdup((char const   *)seq);
      TrieInit(& branchPtr->node);
      Ns_IndexAdd(& triePtr->branches, (void *)branchPtr);
    }
    tmp = strlen((char const   *)seq);
    TrieAdd(& branchPtr->node, (seq + tmp) + 1, id, data, flags, deletefunc);
  }
  return;
}
}
static void TrieTrunc(Trie *triePtr , int id ) 
{ int n ;
  int i ;
  Branch *branchPtr ;
  Node *nodePtr ;

  {
  n = triePtr->branches.n;
  if (n > 0) {
    i = 0;
    while (i < n) {
      branchPtr = (Branch *)Ns_IndexEl(& triePtr->branches, i);
      TrieTrunc(& branchPtr->node, id);
      i ++;
    }
  }
  if ((unsigned int )triePtr->indexnode != (unsigned int )((void *)0)) {
    if (id != -1) {
      nodePtr = (Node *)Ns_IndexFind(triePtr->indexnode, (void *)id);
      if ((unsigned int )nodePtr != (unsigned int )((void *)0)) {
        NodeDestroy(nodePtr);
        Ns_IndexDel(triePtr->indexnode, (void *)nodePtr);
      }
    } else {
      IndexNodeDestroy(triePtr->indexnode);
      triePtr->indexnode = (Ns_Index *)((void *)0);
    }
  }
  return;
}
}
static int TrieBranchTrunc(Trie *triePtr , char *seq , int id ) 
{ Branch *branchPtr ;
  size_t tmp ;
  int tmp___0 ;

  {
  if ((int )(*seq) != 0) {
    branchPtr = (Branch *)Ns_IndexFind(& triePtr->branches, (void *)seq);
    if ((unsigned int )branchPtr != (unsigned int )((void *)0)) {
      tmp = strlen((char const   *)seq);
      tmp___0 = TrieBranchTrunc(& branchPtr->node, (seq + tmp) + 1, id);
      return (tmp___0);
    } else {
      return (-1);
    }
  } else {
    TrieTrunc(triePtr, id);
    return (0);
  }
}
}
static void *TrieFind(Trie *triePtr , char *seq , int id , int *depthPtr ) 
{ void *data ;
  int ldepth ;
  Node *nodePtr ;
  Branch *branchPtr ;
  void *p ;
  size_t tmp ;
  void *tmp___0 ;

  {
  data = (void *)0;
  ldepth = (*depthPtr);
  if ((unsigned int )triePtr->indexnode != (unsigned int )((void *)0)) {
    nodePtr = (Node *)Ns_IndexFind(triePtr->indexnode, (void *)id);
    if ((unsigned int )nodePtr != (unsigned int )((void *)0)) {
      if ((int )(*seq) == 0) {
        if ((unsigned int )nodePtr->dataNoInherit != (unsigned int )((void *)0)) {
          data = nodePtr->dataNoInherit;
        } else {
          data = nodePtr->dataInherit;
        }
      } else {
        data = nodePtr->dataInherit;
      }
    }
  }
  if ((int )(*seq) != 0) {
    branchPtr = (Branch *)Ns_IndexFind(& triePtr->branches, (void *)seq);
    ldepth ++;
    if ((unsigned int )branchPtr != (unsigned int )((void *)0)) {
      tmp = strlen((char const   *)seq);
      tmp___0 = TrieFind(& branchPtr->node, (seq + tmp) + 1, id, & ldepth);
      p = tmp___0;
      if ((unsigned int )p != (unsigned int )((void *)0)) {
        data = p;
        (*depthPtr) = ldepth;
      }
    }
  }
  return (data);
}
}
static void *TrieFindExact(Trie *triePtr , char *seq , int id , int flags ) 
{ void *data ;
  Branch *branchPtr ;
  size_t tmp ;
  Node *nodePtr ;

  {
  data = (void *)0;
  if ((int )(*seq) != 0) {
    branchPtr = (Branch *)Ns_IndexFind(& triePtr->branches, (void *)seq);
    if ((unsigned int )branchPtr != (unsigned int )((void *)0)) {
      tmp = strlen((char const   *)seq);
      data = TrieFindExact(& branchPtr->node, (seq + tmp) + 1, id, flags);
    }
  } else {
    if ((unsigned int )triePtr->indexnode != (unsigned int )((void *)0)) {
      nodePtr = (Node *)Ns_IndexFind(triePtr->indexnode, (void *)id);
      if ((unsigned int )nodePtr != (unsigned int )((void *)0)) {
        if (flags & 2) {
          data = nodePtr->dataNoInherit;
        } else {
          data = nodePtr->dataInherit;
        }
      }
    }
  }
  return (data);
}
}
static void *TrieDelete(Trie *triePtr , char *seq , int id , int flags ) 
{ void *data ;
  Branch *branchPtr ;
  size_t tmp ;
  Node *nodePtr ;

  {
  data = (void *)0;
  if ((int )(*seq) != 0) {
    branchPtr = (Branch *)Ns_IndexFind(& triePtr->branches, (void *)seq);
    if ((unsigned int )branchPtr != (unsigned int )((void *)0)) {
      tmp = strlen((char const   *)seq);
      data = TrieDelete(& branchPtr->node, (seq + tmp) + 1, id, flags);
    }
  } else {
    if ((unsigned int )triePtr->indexnode != (unsigned int )((void *)0)) {
      nodePtr = (Node *)Ns_IndexFind(triePtr->indexnode, (void *)id);
      if ((unsigned int )nodePtr != (unsigned int )((void *)0)) {
        if (flags & 2) {
          data = nodePtr->dataNoInherit;
          nodePtr->dataNoInherit = (void *)0;
          if ((unsigned int )nodePtr->deletefuncNoInherit != (unsigned int )((void *)0)) {
            if (! (flags & 4)) {
              ((*(nodePtr->deletefuncNoInherit)))(data);
            }
            nodePtr->deletefuncNoInherit = (void (*)(void * ))((void *)0);
          }
        } else {
          data = nodePtr->dataInherit;
          nodePtr->dataInherit = (void *)0;
          if ((unsigned int )nodePtr->deletefuncInherit != (unsigned int )((void *)0)) {
            if (! (flags & 4)) {
              ((*(nodePtr->deletefuncInherit)))(data);
            }
            nodePtr->deletefuncInherit = (void (*)(void * ))((void *)0);
          }
        }
      }
    }
  }
  return (data);
}
}
static int CmpChannels(Channel **leftPtrPtr , Channel **rightPtrPtr ) 
{ int lcontainsr ;
  int rcontainsl ;

  {
  lcontainsr = Tcl_StringMatch(((*rightPtrPtr))->filter, ((*leftPtrPtr))->filter);
  rcontainsl = Tcl_StringMatch(((*leftPtrPtr))->filter, ((*rightPtrPtr))->filter);
  if (lcontainsr) {
    if (rcontainsl) {
      return (0);
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (lcontainsr) {
      return (1);
    } else {
      if (rcontainsl) {
        return (-1);
      } else {
        return (0);
      }
    }
  }
}
}
static int CmpKeyWithChannel(char *key___1 , Channel **channelPtrPtr ) 
{ int lcontainsr ;
  int rcontainsl ;

  {
  lcontainsr = Tcl_StringMatch(((*channelPtrPtr))->filter, key___1);
  rcontainsl = Tcl_StringMatch(key___1, ((*channelPtrPtr))->filter);
  if (lcontainsr) {
    if (rcontainsl) {
      return (0);
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (lcontainsr) {
      return (1);
    } else {
      if (rcontainsl) {
        return (-1);
      } else {
        return (0);
      }
    }
  }
}
}
static int CmpChannelsAsStrings(Channel **leftPtrPtr , Channel **rightPtrPtr ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if (0) {
    __s1_len = strlen((char const   *)((*leftPtrPtr))->filter);
    __s2_len = strlen((char const   *)((*rightPtrPtr))->filter);
    if (! ((unsigned int )((void const   *)(((*leftPtrPtr))->filter + 1)) - (unsigned int )((void const   *)((*leftPtrPtr))->filter) ==
           1U)) {
      goto _L___0;
    } else {
      if (__s1_len >= 4U) {
        _L___0: 
        if (! ((unsigned int )((void const   *)(((*rightPtrPtr))->filter + 1)) - (unsigned int )((void const   *)((*rightPtrPtr))->filter) ==
               1U)) {
          tmp___6 = 1;
        } else {
          if (__s2_len >= 4U) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        }
      } else {
        tmp___6 = 0;
      }
    }
    if (tmp___6) {
      if (__s1_len < __s2_len) {
        tmp___4 = __s1_len;
      } else {
        tmp___4 = __s2_len;
      }
      tmp___3 = memcmp((void const   *)((char const   *)((*leftPtrPtr))->filter),
                       (void const   *)((char const   *)((*rightPtrPtr))->filter),
                       tmp___4 + 1U);
    } else {
      tmp___5 = strcmp((char const   *)((*leftPtrPtr))->filter, (char const   *)((*rightPtrPtr))->filter);
      tmp___3 = tmp___5;
    }
  } else {
    tmp___5 = strcmp((char const   *)((*leftPtrPtr))->filter, (char const   *)((*rightPtrPtr))->filter);
    tmp___3 = tmp___5;
  }
  return (tmp___3);
}
}
static int CmpKeyWithChannelAsStrings(char *key___1 , Channel **channelPtrPtr ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if (0) {
    __s1_len = strlen((char const   *)key___1);
    __s2_len = strlen((char const   *)((*channelPtrPtr))->filter);
    if (! ((unsigned int )((void const   *)(key___1 + 1)) - (unsigned int )((void const   *)key___1) ==
           1U)) {
      goto _L___0;
    } else {
      if (__s1_len >= 4U) {
        _L___0: 
        if (! ((unsigned int )((void const   *)(((*channelPtrPtr))->filter + 1)) -
               (unsigned int )((void const   *)((*channelPtrPtr))->filter) == 1U)) {
          tmp___6 = 1;
        } else {
          if (__s2_len >= 4U) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        }
      } else {
        tmp___6 = 0;
      }
    }
    if (tmp___6) {
      if (__s1_len < __s2_len) {
        tmp___4 = __s1_len;
      } else {
        tmp___4 = __s2_len;
      }
      tmp___3 = memcmp((void const   *)((char const   *)key___1), (void const   *)((char const   *)((*channelPtrPtr))->filter),
                       tmp___4 + 1U);
    } else {
      tmp___5 = strcmp((char const   *)key___1, (char const   *)((*channelPtrPtr))->filter);
      tmp___3 = tmp___5;
    }
  } else {
    tmp___5 = strcmp((char const   *)key___1, (char const   *)((*channelPtrPtr))->filter);
    tmp___3 = tmp___5;
  }
  return (tmp___3);
}
}
static void JunctionInit(Junction *juncPtr ) 
{ 

  {
  Ns_IndexInit(& juncPtr->byuse, 5, (int (*)(void const   * , void const   * ))(& CmpChannels),
               (int (*)(void const   * , void const   * ))(& CmpKeyWithChannel));
  Ns_IndexInit(& juncPtr->byname, 5, (int (*)(void const   * , void const   * ))(& CmpChannelsAsStrings),
               (int (*)(void const   * , void const   * ))(& CmpKeyWithChannelAsStrings));
  return;
}
}
static void JunctionBranchTrunc(Junction *juncPtr , char *seq , int id ) 
{ int i ;
  int n ;
  Channel *channelPtr ;
  Channel *tmp ;

  {
  n = juncPtr->byuse.n;
  i = 0;
  while (i < n) {
    tmp = (Channel *)Ns_IndexEl(& juncPtr->byuse, i);
    channelPtr = tmp;
    TrieBranchTrunc(& channelPtr->trie, seq, id);
    i ++;
  }
  return;
}
}
static void JunctionAdd(Junction *juncPtr , char *seq , int id , void *data , int flags ,
                        void (*deletefunc)(void * ) ) 
{ Channel *channelPtr ;
  Tcl_DString dsWord ;
  char *p ;
  int l ;
  int depth ;
  size_t tmp ;
  char *tmp___1 ;
  char *tmp___3 ;

  {
  depth = 0;
  p = seq;
  while (1) {
    tmp = strlen((char const   *)p);
    l = (int )(tmp + 1U);
    if (! ((int )(*(p + l)) != 0)) {
      break;
    }
    depth ++;
    p += l;
  }
  Tcl_DStringInit(& dsWord);
  if ((unsigned int )p != (unsigned int )((void *)0)) {
    if (depth > 1) {
      tmp___1 = strchr((char const   *)p, '*');
      if (tmp___1) {
        Tcl_DStringAppend(& dsWord, p, -1);
        (*p) = (char )'\000';
      } else {
        tmp___3 = strchr((char const   *)p, '?');
        if (tmp___3) {
          Tcl_DStringAppend(& dsWord, p, -1);
          (*p) = (char )'\000';
        } else {
          Tcl_DStringAppend(& dsWord, (char *)"*", -1);
        }
      }
    } else {
      Tcl_DStringAppend(& dsWord, (char *)"*", -1);
    }
  } else {
    Tcl_DStringAppend(& dsWord, (char *)"*", -1);
  }
  channelPtr = (Channel *)Ns_IndexFind(& juncPtr->byname, (void *)dsWord.string);
  if ((unsigned int )channelPtr == (unsigned int )((void *)0)) {
    channelPtr = (Channel *)ns_malloc(sizeof(Channel ));
    channelPtr->filter = ns_strdup((char const   *)dsWord.string);
    TrieInit(& channelPtr->trie);
    Ns_IndexAdd(& juncPtr->byuse, (void *)channelPtr);
    Ns_IndexAdd(& juncPtr->byname, (void *)channelPtr);
  }
  TrieAdd(& channelPtr->trie, seq, id, data, flags, deletefunc);
  Tcl_DStringFree(& dsWord);
  return;
}
}
static void *JunctionFind(Junction *juncPtr , char *seq , int id , int fast ) 
{ char *p ;
  int l ;
  int i ;
  int n ;
  void *data ;
  int depth ;
  size_t tmp ;
  size_t tmp___0 ;
  Channel *channelPtr ;
  Channel *tmp___1 ;
  int doit ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *candidate ;
  int cdepth ;

  {
  n = 0;
  p = seq;
  while (1) {
    tmp = strlen((char const   *)p);
    l = (int )(tmp + 1U);
    if (! ((int )(*(p + l)) != 0)) {
      break;
    }
    n ++;
    p += l;
  }
  if (n < 2) {
    tmp___0 = strlen((char const   *)p);
    p += tmp___0 + 1U;
  }
  data = (void *)0;
  l = juncPtr->byuse.n;
  i = 0;
  while (i < l) {
    tmp___1 = (Channel *)Ns_IndexEl(& juncPtr->byuse, i);
    channelPtr = tmp___1;
    if (fast) {
      if (0) {
        __s1_len = strlen((char const   *)p);
        __s2_len = strlen((char const   *)channelPtr->filter);
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) ==
               1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)(channelPtr->filter + 1)) - (unsigned int )((void const   *)channelPtr->filter) ==
                   1U)) {
              tmp___9 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___9 = 1;
              } else {
                tmp___9 = 0;
              }
            }
          } else {
            tmp___9 = 0;
          }
        }
        if (tmp___9) {
          if (__s1_len < __s2_len) {
            tmp___7 = __s1_len;
          } else {
            tmp___7 = __s2_len;
          }
          tmp___6 = memcmp((void const   *)((char const   *)p), (void const   *)((char const   *)channelPtr->filter),
                           tmp___7 + 1U);
        } else {
          tmp___8 = strcmp((char const   *)p, (char const   *)channelPtr->filter);
          tmp___6 = tmp___8;
        }
      } else {
        tmp___8 = strcmp((char const   *)p, (char const   *)channelPtr->filter);
        tmp___6 = tmp___8;
      }
      if (tmp___6) {
        tmp___10 = 0;
      } else {
        tmp___10 = 1;
      }
      doit = tmp___10;
    } else {
      doit = Tcl_StringMatch(p, channelPtr->filter);
    }
    if (doit) {
      if ((unsigned int )data == (unsigned int )((void *)0)) {
        depth = 0;
        data = TrieFind(& channelPtr->trie, seq, id, & depth);
      } else {
        cdepth = 0;
        candidate = TrieFind(& channelPtr->trie, seq, id, & cdepth);
        if ((unsigned int )candidate != (unsigned int )((void *)0)) {
          if (cdepth > depth) {
            data = candidate;
            depth = cdepth;
          }
        }
      }
    }
    i ++;
  }
  return (data);
}
}
static void *JunctionFindExact(Junction *juncPtr , char *seq , int id , int flags ,
                               int fast ) 
{ char *p ;
  int l ;
  int i ;
  int depth ;
  void *data ;
  size_t tmp ;
  Channel *channelPtr ;
  Channel *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  Channel *channelPtr___0 ;
  Channel *tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  depth = 0;
  p = seq;
  while (1) {
    tmp = strlen((char const   *)p);
    l = (int )(tmp + 1U);
    if (! ((int )(*(p + l)) != 0)) {
      break;
    }
    depth ++;
    p += l;
  }
  data = (void *)0;
  l = juncPtr->byuse.n;
  i = 0;
  while (i < l) {
    tmp___0 = (Channel *)Ns_IndexEl(& juncPtr->byuse, i);
    channelPtr = tmp___0;
    if (0) {
      __s1_len = strlen((char const   *)p);
      __s2_len = strlen((char const   *)channelPtr->filter);
      if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) ==
             1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: 
          if (! ((unsigned int )((void const   *)(channelPtr->filter + 1)) - (unsigned int )((void const   *)channelPtr->filter) ==
                 1U)) {
            tmp___8 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___8 = 1;
            } else {
              tmp___8 = 0;
            }
          }
        } else {
          tmp___8 = 0;
        }
      }
      if (tmp___8) {
        if (__s1_len < __s2_len) {
          tmp___6 = __s1_len;
        } else {
          tmp___6 = __s2_len;
        }
        tmp___5 = memcmp((void const   *)((char const   *)p), (void const   *)((char const   *)channelPtr->filter),
                         tmp___6 + 1U);
      } else {
        tmp___7 = strcmp((char const   *)p, (char const   *)channelPtr->filter);
        tmp___5 = tmp___7;
      }
    } else {
      tmp___7 = strcmp((char const   *)p, (char const   *)channelPtr->filter);
      tmp___5 = tmp___7;
    }
    if (tmp___5 == 0) {
      (*p) = (char )'\000';
      data = TrieFindExact(& channelPtr->trie, seq, id, flags);
      goto done;
    }
    i ++;
  }
  i = 0;
  while (i < l) {
    tmp___9 = (Channel *)Ns_IndexEl(& juncPtr->byuse, i);
    channelPtr___0 = tmp___9;
    if (0) {
      __s1_len___0 = strlen("*");
      __s2_len___0 = strlen((char const   *)channelPtr___0->filter);
      if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
             1U)) {
        goto _L___2;
      } else {
        if (__s1_len___0 >= 4U) {
          _L___2: 
          if (! ((unsigned int )((void const   *)(channelPtr___0->filter + 1)) - (unsigned int )((void const   *)channelPtr___0->filter) ==
                 1U)) {
            tmp___17 = 1;
          } else {
            if (__s2_len___0 >= 4U) {
              tmp___17 = 1;
            } else {
              tmp___17 = 0;
            }
          }
        } else {
          tmp___17 = 0;
        }
      }
      if (tmp___17) {
        if (__s1_len___0 < __s2_len___0) {
          tmp___15 = __s1_len___0;
        } else {
          tmp___15 = __s2_len___0;
        }
        tmp___14 = memcmp((void const   *)"*", (void const   *)((char const   *)channelPtr___0->filter),
                          tmp___15 + 1U);
      } else {
        tmp___16 = strcmp("*", (char const   *)channelPtr___0->filter);
        tmp___14 = tmp___16;
      }
    } else {
      tmp___16 = strcmp("*", (char const   *)channelPtr___0->filter);
      tmp___14 = tmp___16;
    }
    if (tmp___14 == 0) {
      data = TrieFindExact(& channelPtr___0->trie, seq, id, flags);
      break;
    }
    i ++;
  }
  done: 
  return (data);
}
}
static void *JunctionDelete(Junction *juncPtr , char *seq , int id , int flags ) 
{ char *p ;
  int l ;
  int i ;
  int depth ;
  void *data ;
  size_t tmp ;
  Channel *channelPtr ;
  Channel *tmp___0 ;
  int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  depth = 0;
  p = seq;
  while (1) {
    tmp = strlen((char const   *)p);
    l = (int )(tmp + 1U);
    if (! ((int )(*(p + l)) != 0)) {
      break;
    }
    depth ++;
    p += l;
  }
  data = (void *)0;
  l = juncPtr->byuse.n;
  i = 0;
  while (1) {
    if (i < l) {
      if (! ((unsigned int )data == (unsigned int )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    tmp___0 = (Channel *)Ns_IndexEl(& juncPtr->byuse, i);
    channelPtr = tmp___0;
    if (depth == 2) {
      if (0) {
        __s1_len = strlen((char const   *)p);
        __s2_len = strlen((char const   *)channelPtr->filter);
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) ==
               1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)(channelPtr->filter + 1)) - (unsigned int )((void const   *)channelPtr->filter) ==
                   1U)) {
              tmp___9 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___9 = 1;
              } else {
                tmp___9 = 0;
              }
            }
          } else {
            tmp___9 = 0;
          }
        }
        if (tmp___9) {
          if (__s1_len < __s2_len) {
            tmp___7 = __s1_len;
          } else {
            tmp___7 = __s2_len;
          }
          tmp___6 = memcmp((void const   *)((char const   *)p), (void const   *)((char const   *)channelPtr->filter),
                           tmp___7 + 1U);
        } else {
          tmp___8 = strcmp((char const   *)p, (char const   *)channelPtr->filter);
          tmp___6 = tmp___8;
        }
      } else {
        tmp___8 = strcmp((char const   *)p, (char const   *)channelPtr->filter);
        tmp___6 = tmp___8;
      }
      if (tmp___6 == 0) {
        (*p) = (char )'\000';
        data = TrieFindExact(& channelPtr->trie, seq, id, flags);
        if ((unsigned int )data != (unsigned int )((void *)0)) {
          TrieDelete(& channelPtr->trie, seq, id, flags);
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      tmp___1 = Tcl_StringMatch(p, channelPtr->filter);
      if (tmp___1) {
        data = TrieFindExact(& channelPtr->trie, seq, id, flags);
        if ((unsigned int )data != (unsigned int )((void *)0)) {
          TrieDelete(& channelPtr->trie, seq, id, flags);
        }
      }
    }
    i ++;
  }
  return (data);
}
}
static void MkSeq(Tcl_DString *dsPtr , char *server , char *method , char *url ) 
{ char *p ;
  int done ;
  size_t tmp ;
  size_t tmp___0 ;
  int l ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
  if ((unsigned int )method != (unsigned int )((void *)0)) {
    if ((unsigned int )url != (unsigned int )((void *)0)) {
      tmp = strlen((char const   *)server);
      Tcl_DStringAppend(dsPtr, server, (int )(tmp + 1U));
      tmp___0 = strlen((char const   *)method);
      Tcl_DStringAppend(dsPtr, method, (int )(tmp___0 + 1U));
      done = 0;
      while (1) {
        if (! done) {
          if (! ((int )(*url) != 0)) {
            break;
          }
        } else {
          break;
        }
        if ((int )(*url) != 47) {
          tmp___2 = strchr((char const   *)url, '/');
          p = tmp___2;
          if ((unsigned int )p != (unsigned int )((void *)0)) {
            l = p - url;
          } else {
            l = (int )strlen((char const   *)url);
            done = 1;
          }
          tmp___3 = l;
          l ++;
          Tcl_DStringAppend(dsPtr, url, tmp___3);
          Tcl_DStringAppend(dsPtr, (char *)"\000", 1);
          url += l;
        } else {
          url ++;
        }
      }
      Tcl_DStringAppend(dsPtr, (char *)"\000", 1);
    } else {
      tmp___4 = strlen((char const   *)server);
      Tcl_DStringAppend(dsPtr, server, (int )(tmp___4 + 1U));
      Tcl_DStringAppend(dsPtr, (char *)"\000", 1);
    }
  } else {
    tmp___4 = strlen((char const   *)server);
    Tcl_DStringAppend(dsPtr, server, (int )(tmp___4 + 1U));
    Tcl_DStringAppend(dsPtr, (char *)"\000", 1);
  }
  return;
}
}
static char six2pr[64]  = 
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'+',      (char )'/'};
static int pr2six[256]  = 
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      62, 
        -1,      -1,      -1,      63, 
        52,      53,      54,      55, 
        56,      57,      58,      59, 
        60,      61,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      0,      1,      2, 
        3,      4,      5,      6, 
        7,      8,      9,      10, 
        11,      12,      13,      14, 
        15,      16,      17,      18, 
        19,      20,      21,      22, 
        23,      24,      25,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      26,      27,      28, 
        29,      30,      31,      32, 
        33,      34,      35,      36, 
        37,      38,      39,      40, 
        41,      42,      43,      44, 
        45,      46,      47,      48, 
        49,      50,      51,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
int Ns_HtuuEncode(unsigned char *input , unsigned int len , char *output ) 
{ register unsigned char *p ;
  register unsigned char *q ;
  register int n ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;

  {
  p = input;
  q = (unsigned char *)output;
  n = (int )(len / 3U);
  while (n > 0) {
    tmp = q;
    q ++;
    (*tmp) = (unsigned char )six2pr[(int )(*(p + 0)) >> 2];
    tmp___0 = q;
    q ++;
    (*tmp___0) = (unsigned char )six2pr[(((int )(*(p + 0)) << 4) & 48) | (((int )(*(p +
                                                                                    1)) >>
                                                                           4) & 15)];
    tmp___1 = q;
    q ++;
    (*tmp___1) = (unsigned char )six2pr[(((int )(*(p + 1)) << 2) & 60) | (((int )(*(p +
                                                                                    2)) >>
                                                                           6) & 3)];
    tmp___2 = q;
    q ++;
    (*tmp___2) = (unsigned char )six2pr[(int )(*(p + 2)) & 63];
    p += 3;
    n --;
  }
  n = (int )(len % 3U);
  if (n > 0) {
    tmp___3 = q;
    q ++;
    (*tmp___3) = (unsigned char )six2pr[(int )(*(p + 0)) >> 2];
    if (n == 1) {
      tmp___4 = q;
      q ++;
      (*tmp___4) = (unsigned char )six2pr[((int )(*(p + 0)) << 4) & 48];
      tmp___5 = q;
      q ++;
      (*tmp___5) = (unsigned char )'=';
    } else {
      tmp___6 = q;
      q ++;
      (*tmp___6) = (unsigned char )six2pr[(((int )(*(p + 0)) << 4) & 48) | (((int )(*(p +
                                                                                      1)) >>
                                                                             4) &
                                                                            15)];
      tmp___7 = q;
      q ++;
      (*tmp___7) = (unsigned char )six2pr[((int )(*(p + 1)) << 2) & 60];
    }
    tmp___8 = q;
    q ++;
    (*tmp___8) = (unsigned char )'=';
  }
  (*q) = (unsigned char )'\000';
  return (q - (unsigned char *)output);
}
}
int Ns_HtuuDecode(char *input , unsigned char *output , int outputlen ) 
{ register unsigned char *p ;
  register unsigned char *q ;
  register int len ;
  register int n ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;

  {
  while (1) {
    if (! ((int )(*input) == 32)) {
      if (! ((int )(*input) == 9)) {
        break;
      }
    }
    input ++;
  }
  p = (unsigned char *)input;
  while (pr2six[(int )(*p)] >= 0) {
    p ++;
  }
  len = p - (unsigned char *)input;
  p = (unsigned char *)input;
  q = output;
  n = len / 4;
  while (n > 0) {
    tmp = q;
    q ++;
    (*tmp) = (unsigned char )(((int )((unsigned char )pr2six[(int )(*(p + 0))]) <<
                               2) | ((int )((unsigned char )pr2six[(int )(*(p + 1))]) >>
                                     4));
    tmp___0 = q;
    q ++;
    (*tmp___0) = (unsigned char )(((int )((unsigned char )pr2six[(int )(*(p + 1))]) <<
                                   4) | ((int )((unsigned char )pr2six[(int )(*(p +
                                                                                2))]) >>
                                         2));
    tmp___1 = q;
    q ++;
    (*tmp___1) = (unsigned char )(((int )((unsigned char )pr2six[(int )(*(p + 2))]) <<
                                   6) | (int )((unsigned char )pr2six[(int )(*(p +
                                                                               3))]));
    p += 4;
    n --;
  }
  n = len % 4;
  if (n > 1) {
    tmp___2 = q;
    q ++;
    (*tmp___2) = (unsigned char )(((int )((unsigned char )pr2six[(int )(*(p + 0))]) <<
                                   2) | ((int )((unsigned char )pr2six[(int )(*(p +
                                                                                1))]) >>
                                         4));
  }
  if (n > 2) {
    tmp___3 = q;
    q ++;
    (*tmp___3) = (unsigned char )(((int )((unsigned char )pr2six[(int )(*(p + 1))]) <<
                                   4) | ((int )((unsigned char )pr2six[(int )(*(p +
                                                                                2))]) >>
                                         2));
  }
  if (q - output < outputlen) {
    (*q) = (unsigned char )'\000';
  }
  return (q - output);
}
}
char *nsBuildDate  =    (char *)"Mar 10 2006 at 16:32:06";
void NsThreadFatal(char *func___1 , char *osfunc , int err ) ;
void NsThreadFatal(char *func___1 , char *osfunc , int err ) 
{ char *tmp ;

  {
  tmp = strerror(err);
  Tcl_Panic((char *)"nsthreads: %s failed in %s: %s", osfunc, func___1, tmp);
  return;
}
}
void NsInitMaster(void) ;
static Ns_Cs master  ;
static int initialized___1  ;
void NsInitMaster(void) 
{ 

  {
  Ns_CsInit(& master);
  initialized___1 = 1;
  return;
}
}
void Ns_MasterLock(void) 
{ 

  {
  if (initialized___1) {
    Ns_CsEnter(& master);
  }
  return;
}
}
void Ns_MasterUnlock(void) 
{ 

  {
  if (initialized___1) {
    Ns_CsLeave(& master);
  }
  return;
}
}
extern char *Tcl_Realloc(char *ptr , unsigned int size ) ;
void *ns_realloc(void *ptr , size_t size ) 
{ char *tmp___1 ;

  {
  if (ptr) {
    tmp___1 = Tcl_Realloc((char *)ptr, size);
  } else {
    tmp___1 = Tcl_Alloc(size);
  }
  return ((void *)tmp___1);
}
}
void *ns_malloc(size_t size ) 
{ void *tmp ;

  {
  tmp = (void *)Tcl_Alloc(size);
  return (tmp);
}
}
void ns_free(void *ptr ) 
{ 

  {
  if ((unsigned int )ptr != (unsigned int )((void *)0)) {
    Tcl_Free((char *)ptr);
  }
  return;
}
}
void *ns_calloc(size_t num , size_t esize ) 
{ void *new ;
  size_t size ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_55 *__u ;
  __uint8_t __c ;
  void *__s___1 ;

  {
  size = num * esize;
  new = ns_malloc(size);
  if (0) {
    if (size == 1U) {
      __s___1 = new;
      (*((__uint8_t *)__s___1)) = (unsigned char)0;
    } else {
      __s___0 = new;
      __u = (union __anonunion___u_55 *)__s___0;
      __c = (unsigned char)0;
      switch ((int )size) {
      case 15: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_55 *)((void *)__u + 4);
      case 11: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_55 *)((void *)__u + 4);
      case 7: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_55 *)((void *)__u + 4);
      case 3: 
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
      __u = (union __anonunion___u_55 *)((void *)__u + 2);
      __u->__uc = __c;
      break;
      case 14: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_55 *)((void *)__u + 4);
      case 10: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_55 *)((void *)__u + 4);
      case 6: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_55 *)((void *)__u + 4);
      case 2: 
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
      break;
      case 13: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_55 *)((void *)__u + 4);
      case 9: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_55 *)((void *)__u + 4);
      case 5: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_55 *)((void *)__u + 4);
      case 1: 
      __u->__uc = __c;
      break;
      case 16: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_55 *)((void *)__u + 4);
      case 12: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_55 *)((void *)__u + 4);
      case 8: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_55 *)((void *)__u + 4);
      case 4: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case 0: ;
      break;
      }
    }
  } else {
    __s = new;
    __builtin_memset(__s, '\000', (int )size);
  }
  return (new);
}
}
char *ns_strcopy(char const   *old ) 
{ char *tmp___0 ;

  {
  if ((unsigned int )old == (unsigned int )((void *)0)) {
    tmp___0 = (char *)((void *)0);
  } else {
    tmp___0 = ns_strdup(old);
  }
  return (tmp___0);
}
}
char *ns_strdup(char const   *old ) 
{ char *new ;
  size_t tmp ;

  {
  tmp = strlen(old);
  new = (char *)ns_malloc(tmp + 1U);
  strcpy((char * __restrict  )new, (char const   * __restrict  )old);
  return (new);
}
}
void NsMutexInitNext(Ns_Mutex *mutex , char *prefix , unsigned int *nextPtr ) ;
void *NsGetLock(Ns_Mutex *mutex ) ;
void *NsLockAlloc(void) ;
void NsLockFree(void *lock___31 ) ;
void NsLockSet(void *lock___31 ) ;
int NsLockTry(void *lock___31 ) ;
void NsLockUnset(void *lock___31 ) ;
static Mutex *GetMutex(Ns_Mutex *mutex ) ;
static Mutex *firstMutexPtr  ;
static unsigned int nextid___0  ;
void Ns_MutexInit(Ns_Mutex *mutex ) 
{ Mutex *mutexPtr ;
  unsigned int tmp ;

  {
  mutexPtr = (Mutex *)ns_calloc(1U, sizeof(Mutex ));
  mutexPtr->lock = NsLockAlloc();
  Ns_MasterLock();
  mutexPtr->nextPtr = firstMutexPtr;
  firstMutexPtr = mutexPtr;
  tmp = nextid___0;
  nextid___0 ++;
  mutexPtr->id = tmp;
  sprintf((char * __restrict  )(mutexPtr->name), (char const   * __restrict  )"mu%d",
          mutexPtr->id);
  Ns_MasterUnlock();
  (*mutex) = (struct Ns_Mutex_ *)mutexPtr;
  return;
}
}
void Ns_MutexSetName(Ns_Mutex *mutex , char *name ) 
{ 

  {
  Ns_MutexSetName2(mutex, name, (char *)((void *)0));
  return;
}
}
void Ns_MutexSetName2(Ns_Mutex *mutex , char *prefix , char *name ) 
{ Mutex *mutexPtr ;
  Mutex *tmp___0 ;
  int plen ;
  int nlen ;
  char *p ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___16 ;

  {
  if ((*mutex)) {
    tmp___0 = (Mutex *)(*mutex);
  } else {
    tmp___0 = GetMutex(mutex);
  }
  mutexPtr = tmp___0;
  plen = (int )strlen((char const   *)prefix);
  if (plen > 32) {
    plen = 32;
    nlen = 0;
  } else {
    if (name) {
      nlen = (int )strlen((char const   *)name);
    } else {
      nlen = 0;
    }
    if ((nlen + plen) + 1 > 32) {
      nlen = (32 - plen) - 1;
    }
  }
  Ns_MasterLock();
  tmp___8 = strncpy((char * __restrict  )(mutexPtr->name), (char const   * __restrict  )prefix,
                    (unsigned int )plen);
  p = tmp___8 + plen;
  if (nlen > 0) {
    tmp___9 = p;
    p ++;
    (*tmp___9) = (char )':';
    tmp___16 = strncpy((char * __restrict  )p, (char const   * __restrict  )name,
                       (unsigned int )nlen);
    p = tmp___16 + nlen;
  }
  (*p) = (char )'\000';
  Ns_MasterUnlock();
  return;
}
}
void Ns_MutexDestroy(Ns_Mutex *mutex ) 
{ Mutex **mutexPtrPtr ;
  Mutex *mutexPtr ;

  {
  mutexPtr = (Mutex *)(*mutex);
  if ((unsigned int )mutexPtr != (unsigned int )((void *)0)) {
    NsLockFree(mutexPtr->lock);
    Ns_MasterLock();
    mutexPtrPtr = & firstMutexPtr;
    while ((unsigned int )(*mutexPtrPtr) != (unsigned int )mutexPtr) {
      mutexPtrPtr = & ((*mutexPtrPtr))->nextPtr;
    }
    (*mutexPtrPtr) = mutexPtr->nextPtr;
    Ns_MasterUnlock();
    ns_free((void *)mutexPtr);
    (*mutex) = (struct Ns_Mutex_ *)((void *)0);
  }
  return;
}
}
void Ns_MutexLock(Ns_Mutex *mutex ) 
{ Mutex *mutexPtr ;
  Mutex *tmp___0 ;
  int tmp___1 ;

  {
  if ((*mutex)) {
    tmp___0 = (Mutex *)(*mutex);
  } else {
    tmp___0 = GetMutex(mutex);
  }
  mutexPtr = tmp___0;
  tmp___1 = NsLockTry(mutexPtr->lock);
  if (! tmp___1) {
    NsLockSet(mutexPtr->lock);
    mutexPtr->nbusy ++;
  }
  mutexPtr->nlock ++;
  return;
}
}
int Ns_MutexTryLock(Ns_Mutex *mutex ) 
{ Mutex *mutexPtr ;
  Mutex *tmp___0 ;
  int tmp___1 ;

  {
  if ((*mutex)) {
    tmp___0 = (Mutex *)(*mutex);
  } else {
    tmp___0 = GetMutex(mutex);
  }
  mutexPtr = tmp___0;
  tmp___1 = NsLockTry(mutexPtr->lock);
  if (! tmp___1) {
    return (-2);
  }
  mutexPtr->nlock ++;
  return (0);
}
}
void Ns_MutexUnlock(Ns_Mutex *mutex ) 
{ Mutex *mutexPtr ;

  {
  mutexPtr = (Mutex *)(*mutex);
  NsLockUnset(mutexPtr->lock);
  return;
}
}
void Ns_MutexList(Tcl_DString *dsPtr ) 
{ Mutex *mutexPtr ;
  char buf[100] ;

  {
  Ns_MasterLock();
  mutexPtr = firstMutexPtr;
  while ((unsigned int )mutexPtr != (unsigned int )((void *)0)) {
    Tcl_DStringStartSublist(dsPtr);
    Tcl_DStringAppendElement(dsPtr, mutexPtr->name);
    Tcl_DStringAppendElement(dsPtr, (char *)"");
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )" %d %lu %lu",
            mutexPtr->id, mutexPtr->nlock, mutexPtr->nbusy);
    Tcl_DStringAppend(dsPtr, buf, -1);
    Tcl_DStringEndSublist(dsPtr);
    mutexPtr = mutexPtr->nextPtr;
  }
  Ns_MasterUnlock();
  return;
}
}
void NsMutexInitNext(Ns_Mutex *mutex , char *prefix , unsigned int *nextPtr ) 
{ unsigned int id ;
  char buf[20] ;

  {
  Ns_MasterLock();
  id = (*nextPtr);
  (*nextPtr) = id + 1U;
  Ns_MasterUnlock();
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"ns:%s:%u", prefix,
          id);
  Ns_MutexInit(mutex);
  Ns_MutexSetName(mutex, buf);
  return;
}
}
void *NsGetLock(Ns_Mutex *mutex ) 
{ Mutex *mutexPtr ;
  Mutex *tmp___0 ;

  {
  if ((*mutex)) {
    tmp___0 = (Mutex *)(*mutex);
  } else {
    tmp___0 = GetMutex(mutex);
  }
  mutexPtr = tmp___0;
  return (mutexPtr->lock);
}
}
static Mutex *GetMutex(Ns_Mutex *mutex ) 
{ 

  {
  Ns_MasterLock();
  if ((unsigned int )(*mutex) == (unsigned int )((void *)0)) {
    Ns_MutexInit(mutex);
  }
  Ns_MasterUnlock();
  return ((Mutex *)(*mutex));
}
}
static unsigned int nextid___1  =    0U;
void Ns_CsInit(Ns_Cs *csPtr ) 
{ CsLock *lockPtr ;

  {
  lockPtr = (CsLock *)ns_malloc(sizeof(CsLock ));
  NsMutexInitNext(& lockPtr->mutex, (char *)"cs", & nextid___1);
  Ns_CondInit(& lockPtr->cond);
  lockPtr->count = 0;
  (*csPtr) = (struct Ns_Cs_ *)lockPtr;
  return;
}
}
void Ns_CsDestroy(Ns_Cs *csPtr ) 
{ CsLock *lockPtr ;

  {
  lockPtr = (CsLock *)(*csPtr);
  if ((unsigned int )lockPtr != (unsigned int )((void *)0)) {
    Ns_MutexDestroy(& lockPtr->mutex);
    Ns_CondDestroy(& lockPtr->cond);
    lockPtr->count = 0;
    ns_free((void *)lockPtr);
    (*csPtr) = (struct Ns_Cs_ *)((void *)0);
  }
  return;
}
}
void Ns_CsEnter(Ns_Cs *csPtr ) 
{ CsLock *lockPtr ;
  int tid ;
  int tmp ;

  {
  tmp = Ns_ThreadId();
  tid = tmp;
  if ((unsigned int )(*csPtr) == (unsigned int )((void *)0)) {
    Ns_MasterLock();
    if ((unsigned int )(*csPtr) == (unsigned int )((void *)0)) {
      Ns_CsInit(csPtr);
    }
    Ns_MasterUnlock();
  }
  lockPtr = (CsLock *)(*csPtr);
  Ns_MutexLock(& lockPtr->mutex);
  while (1) {
    if (lockPtr->count > 0) {
      if (! (lockPtr->tid != tid)) {
        break;
      }
    } else {
      break;
    }
    Ns_CondWait(& lockPtr->cond, & lockPtr->mutex);
  }
  lockPtr->tid = tid;
  lockPtr->count ++;
  Ns_MutexUnlock(& lockPtr->mutex);
  return;
}
}
void Ns_CsLeave(Ns_Cs *csPtr ) 
{ CsLock *lockPtr ;

  {
  lockPtr = (CsLock *)(*csPtr);
  Ns_MutexLock(& lockPtr->mutex);
  lockPtr->count --;
  if (lockPtr->count == 0) {
    Ns_CondSignal(& lockPtr->cond);
  }
  Ns_MutexUnlock(& lockPtr->mutex);
  return;
}
}
static RwLock *GetRwLock(Ns_RWLock *rwPtr ) ;
static unsigned int nextid___2  =    0U;
void Ns_RWLockInit(Ns_RWLock *rwPtr ) 
{ RwLock *lockPtr ;

  {
  lockPtr = (RwLock *)ns_calloc(1U, sizeof(RwLock ));
  NsMutexInitNext(& lockPtr->mutex, (char *)"rw", & nextid___2);
  Ns_CondInit(& lockPtr->rcond);
  Ns_CondInit(& lockPtr->wcond);
  lockPtr->nreaders = 0;
  lockPtr->nwriters = 0;
  lockPtr->lockcnt = 0;
  (*rwPtr) = (struct Ns_RWLock_ *)lockPtr;
  return;
}
}
void Ns_RWLockDestroy(Ns_RWLock *rwPtr ) 
{ RwLock *lockPtr ;

  {
  lockPtr = (RwLock *)(*rwPtr);
  if ((unsigned int )lockPtr != (unsigned int )((void *)0)) {
    Ns_MutexDestroy(& lockPtr->mutex);
    Ns_CondDestroy(& lockPtr->rcond);
    Ns_CondDestroy(& lockPtr->wcond);
    ns_free((void *)lockPtr);
    (*rwPtr) = (struct Ns_RWLock_ *)((void *)0);
  }
  return;
}
}
void Ns_RWLockRdLock(Ns_RWLock *rwPtr ) 
{ RwLock *lockPtr ;
  RwLock *tmp ;

  {
  tmp = GetRwLock(rwPtr);
  lockPtr = tmp;
  Ns_MutexLock(& lockPtr->mutex);
  while (1) {
    if (! (lockPtr->lockcnt < 0)) {
      if (! (lockPtr->nwriters > 0)) {
        break;
      }
    }
    lockPtr->nreaders ++;
    Ns_CondWait(& lockPtr->rcond, & lockPtr->mutex);
    lockPtr->nreaders --;
  }
  lockPtr->lockcnt ++;
  Ns_MutexUnlock(& lockPtr->mutex);
  return;
}
}
void Ns_RWLockWrLock(Ns_RWLock *rwPtr ) 
{ RwLock *lockPtr ;
  RwLock *tmp ;

  {
  tmp = GetRwLock(rwPtr);
  lockPtr = tmp;
  Ns_MutexLock(& lockPtr->mutex);
  while (lockPtr->lockcnt != 0) {
    lockPtr->nwriters ++;
    Ns_CondWait(& lockPtr->wcond, & lockPtr->mutex);
    lockPtr->nwriters --;
  }
  lockPtr->lockcnt = -1;
  Ns_MutexUnlock(& lockPtr->mutex);
  return;
}
}
void Ns_RWLockUnlock(Ns_RWLock *rwPtr ) 
{ RwLock *lockPtr ;

  {
  lockPtr = (RwLock *)(*rwPtr);
  Ns_MutexLock(& lockPtr->mutex);
  lockPtr->lockcnt --;
  if (lockPtr->lockcnt < 0) {
    lockPtr->lockcnt = 0;
  }
  if (lockPtr->nwriters) {
    Ns_CondSignal(& lockPtr->wcond);
  } else {
    if (lockPtr->nreaders) {
      Ns_CondBroadcast(& lockPtr->rcond);
    }
  }
  Ns_MutexUnlock(& lockPtr->mutex);
  return;
}
}
static RwLock *GetRwLock(Ns_RWLock *rwPtr ) 
{ 

  {
  if ((unsigned int )(*rwPtr) == (unsigned int )((void *)0)) {
    Ns_MasterLock();
    if ((unsigned int )(*rwPtr) == (unsigned int )((void *)0)) {
      Ns_RWLockInit(rwPtr);
    }
    Ns_MasterUnlock();
  }
  return ((RwLock *)(*rwPtr));
}
}
extern int readdir_r(DIR * __restrict  __dirp , struct dirent * __restrict  __entry ,
                     struct dirent ** __restrict  __result ) ;
extern char *__strtok_r(char * __restrict  __s , char const   * __restrict  __delim ,
                        char ** __restrict  __save_ptr ) ;
extern struct tm *gmtime_r(time_t const   * __restrict  __timer , struct tm * __restrict  __tp ) ;
extern struct tm *localtime_r(time_t const   * __restrict  __timer , struct tm * __restrict  __tp ) ;
extern char *asctime_r(struct tm  const  * __restrict  __tp , char * __restrict  __buf ) ;
extern char *ctime_r(time_t const   * __restrict  __timer , char * __restrict  __buf ) ;
char *ns_ctime(time_t const   *clock___0 ) ;
char *ns_asctime(struct tm  const  *tmPtr ) ;
char *ns_strtok(char *s1 , char const   *s2 ) ;
void NsInitReentrant(void) ;
static Ns_Tls tls___1  ;
static Tls *GetTls(void) ;
void NsInitReentrant(void) 
{ 

  {
  Ns_TlsAlloc(& tls___1, & ns_free);
  return;
}
}
char *ns_inet_ntoa(struct in_addr addr ) 
{ Tls *tlsPtr ;
  Tls *tmp ;
  union __anonunion_u_56 u ;

  {
  tmp = GetTls();
  tlsPtr = tmp;
  u.l = (unsigned long )addr.s_addr;
  sprintf((char * __restrict  )(tlsPtr->nabuf), (char const   * __restrict  )"%u.%u.%u.%u",
          u.b[0], u.b[1], u.b[2], u.b[3]);
  return (tlsPtr->nabuf);
}
}
struct dirent *ns_readdir(DIR *dir ) 
{ struct dirent *ent ;
  Tls *tlsPtr ;
  Tls *tmp ;
  int tmp___0 ;

  {
  tmp = GetTls();
  tlsPtr = tmp;
  ent = & tlsPtr->rdbuf.ent;
  tmp___0 = readdir_r((DIR * __restrict  )dir, (struct dirent * __restrict  )ent,
                      (struct dirent ** __restrict  )(& ent));
  if (tmp___0 != 0) {
    ent = (struct dirent *)((void *)0);
  }
  return (ent);
}
}
struct tm *ns_localtime(time_t const   *clock___0 ) 
{ Tls *tlsPtr ;
  Tls *tmp ;
  struct tm *tmp___0 ;

  {
  tmp = GetTls();
  tlsPtr = tmp;
  tmp___0 = localtime_r((time_t const   * __restrict  )clock___0, (struct tm * __restrict  )(& tlsPtr->ltbuf));
  return (tmp___0);
}
}
struct tm *ns_gmtime(time_t const   *clock___0 ) 
{ Tls *tlsPtr ;
  Tls *tmp ;
  struct tm *tmp___0 ;

  {
  tmp = GetTls();
  tlsPtr = tmp;
  tmp___0 = gmtime_r((time_t const   * __restrict  )clock___0, (struct tm * __restrict  )(& tlsPtr->gtbuf));
  return (tmp___0);
}
}
char *ns_ctime(time_t const   *clock___0 ) 
{ Tls *tlsPtr ;
  Tls *tmp ;
  char *tmp___0 ;

  {
  tmp = GetTls();
  tlsPtr = tmp;
  tmp___0 = ctime_r((time_t const   * __restrict  )clock___0, (char * __restrict  )(tlsPtr->ctbuf));
  return (tmp___0);
}
}
char *ns_asctime(struct tm  const  *tmPtr ) 
{ Tls *tlsPtr ;
  Tls *tmp ;
  char *tmp___0 ;

  {
  tmp = GetTls();
  tlsPtr = tmp;
  tmp___0 = asctime_r((struct tm  const  * __restrict  )tmPtr, (char * __restrict  )(tlsPtr->asbuf));
  return (tmp___0);
}
}
char *ns_strtok(char *s1 , char const   *s2 ) 
{ Tls *tlsPtr ;
  Tls *tmp ;
  char *tmp___3 ;

  {
  tmp = GetTls();
  tlsPtr = tmp;
  tmp___3 = __strtok_r((char * __restrict  )s1, (char const   * __restrict  )s2, (char ** __restrict  )(& tlsPtr->stbuf));
  return (tmp___3);
}
}
static Tls *GetTls(void) 
{ Tls *tlsPtr ;

  {
  tlsPtr = (Tls *)Ns_TlsGet(& tls___1);
  if ((unsigned int )tlsPtr == (unsigned int )((void *)0)) {
    tlsPtr = (Tls *)ns_calloc(1U, sizeof(Tls ));
    Ns_TlsSet(& tls___1, (void *)tlsPtr);
  }
  return (tlsPtr);
}
}
static unsigned int nextid___3  =    0U;
void Ns_SemaInit(Ns_Sema *semaPtr , int count ) 
{ Sema *sPtr ;

  {
  sPtr = (Sema *)ns_malloc(sizeof(Sema ));
  sPtr->count = count;
  NsMutexInitNext(& sPtr->lock, (char *)"sm", & nextid___3);
  Ns_CondInit(& sPtr->cond);
  (*semaPtr) = (struct Ns_Sema_ *)sPtr;
  return;
}
}
void Ns_SemaDestroy(Ns_Sema *semaPtr ) 
{ Sema *sPtr ;

  {
  if ((unsigned int )(*semaPtr) != (unsigned int )((void *)0)) {
    sPtr = (Sema *)(*semaPtr);
    Ns_MutexDestroy(& sPtr->lock);
    Ns_CondDestroy(& sPtr->cond);
    ns_free((void *)sPtr);
    (*semaPtr) = (struct Ns_Sema_ *)((void *)0);
  }
  return;
}
}
void Ns_SemaWait(Ns_Sema *semaPtr ) 
{ Sema *sPtr ;

  {
  sPtr = (Sema *)(*semaPtr);
  Ns_MutexLock(& sPtr->lock);
  while (sPtr->count == 0) {
    Ns_CondWait(& sPtr->cond, & sPtr->lock);
  }
  sPtr->count --;
  Ns_MutexUnlock(& sPtr->lock);
  return;
}
}
void Ns_SemaPost(Ns_Sema *semaPtr , int count ) 
{ Sema *sPtr ;

  {
  sPtr = (Sema *)(*semaPtr);
  Ns_MutexLock(& sPtr->lock);
  sPtr->count += count;
  if (count == 1) {
    Ns_CondSignal(& sPtr->cond);
  } else {
    Ns_CondBroadcast(& sPtr->cond);
  }
  Ns_MutexUnlock(& sPtr->lock);
  return;
}
}
char *Ns_ThreadGetParent(void) ;
void NsInitThreads(void) ;
void NsThreadMain(void *arg ) ;
void NsCreateThread(void *arg , long stacksize___1 , Ns_Thread *resultPtr ) ;
static Thread *NewThread(void) ;
static Thread *GetThread(void) ;
static void CleanupThread(void *arg ) ;
static Thread *firstThreadPtr  ;
static Ns_Tls key  ;
static long stacksize  =    65536L;
static int once___0  =    0;
void NsInitThreads(void) 
{ 

  {
  if (! once___0) {
    once___0 = 1;
    NsInitMaster();
    NsInitReentrant();
    Ns_TlsAlloc(& key, & CleanupThread);
  }
  return;
}
}
void Ns_ThreadCreate(Ns_ThreadProc *proc , void *arg , long stack , Ns_Thread *resultPtr ) 
{ Thread *thrPtr ;
  char *tmp ;

  {
  Ns_MasterLock();
  if (stack <= 0L) {
    stack = stacksize;
  }
  if (stack < 16384L) {
    stack = 16384L;
  }
  thrPtr = NewThread();
  thrPtr->proc = proc;
  thrPtr->arg = arg;
  if ((unsigned int )resultPtr == (unsigned int )((void *)0)) {
    thrPtr->flags = 1;
  }
  tmp = Ns_ThreadGetName();
  strcpy((char * __restrict  )(thrPtr->parent), (char const   * __restrict  )tmp);
  Ns_MasterUnlock();
  NsCreateThread((void *)thrPtr, stack, resultPtr);
  return;
}
}
long Ns_ThreadStackSize(long size ) 
{ long prev ;

  {
  Ns_MasterLock();
  prev = stacksize;
  if (size > 0L) {
    stacksize = size;
  }
  Ns_MasterUnlock();
  return (prev);
}
}
void NsThreadMain(void *arg ) 
{ Thread *thrPtr ;
  char name[32] ;

  {
  thrPtr = (Thread *)arg;
  thrPtr->tid = Ns_ThreadId();
  Ns_TlsSet(& key, (void *)thrPtr);
  sprintf((char * __restrict  )(name), (char const   * __restrict  )"-thread%d-",
          thrPtr->tid);
  Ns_ThreadSetName(name);
  ((*(thrPtr->proc)))(thrPtr->arg);
  return;
}
}
char *Ns_ThreadGetName(void) 
{ Thread *thisPtr ;
  Thread *tmp ;

  {
  tmp = GetThread();
  thisPtr = tmp;
  return (thisPtr->name);
}
}
void Ns_ThreadSetName(char *name ) 
{ Thread *thisPtr ;
  Thread *tmp ;

  {
  tmp = GetThread();
  thisPtr = tmp;
  Ns_MasterLock();
  strncpy((char * __restrict  )(thisPtr->name), (char const   * __restrict  )name,
          32U);
  Ns_MasterUnlock();
  return;
}
}
char *Ns_ThreadGetParent(void) 
{ Thread *thisPtr ;
  Thread *tmp ;

  {
  tmp = GetThread();
  thisPtr = tmp;
  return (thisPtr->parent);
}
}
void Ns_ThreadList(Tcl_DString *dsPtr , Ns_ThreadArgProc *proc ) 
{ Thread *thrPtr ;
  char buf[100] ;

  {
  Ns_MasterLock();
  thrPtr = firstThreadPtr;
  while ((unsigned int )thrPtr != (unsigned int )((void *)0)) {
    Tcl_DStringStartSublist(dsPtr);
    Tcl_DStringAppendElement(dsPtr, thrPtr->name);
    Tcl_DStringAppendElement(dsPtr, thrPtr->parent);
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )" %d %d %ld",
            thrPtr->tid, thrPtr->flags, thrPtr->ctime);
    Tcl_DStringAppend(dsPtr, buf, -1);
    if ((unsigned int )proc != (unsigned int )((void *)0)) {
      ((*proc))(dsPtr, (void *)thrPtr->proc, thrPtr->arg);
    } else {
      sprintf((char * __restrict  )(buf), (char const   * __restrict  )" %p %p", thrPtr->proc,
              thrPtr->arg);
      Tcl_DStringAppend(dsPtr, buf, -1);
    }
    Tcl_DStringEndSublist(dsPtr);
    thrPtr = thrPtr->nextPtr;
  }
  Ns_MasterUnlock();
  return;
}
}
static Thread *NewThread(void) 
{ Thread *thrPtr ;

  {
  thrPtr = (Thread *)ns_calloc(1U, sizeof(Thread ));
  thrPtr->ctime = time((time_t *)((void *)0));
  Ns_MasterLock();
  thrPtr->nextPtr = firstThreadPtr;
  firstThreadPtr = thrPtr;
  Ns_MasterUnlock();
  return (thrPtr);
}
}
static Thread *GetThread(void) 
{ Thread *thisPtr ;

  {
  thisPtr = (Thread *)Ns_TlsGet(& key);
  if ((unsigned int )thisPtr == (unsigned int )((void *)0)) {
    thisPtr = NewThread();
    thisPtr->flags = 1;
    thisPtr->tid = Ns_ThreadId();
    Ns_TlsSet(& key, (void *)thisPtr);
  }
  return (thisPtr);
}
}
static void CleanupThread(void *arg ) 
{ Thread **thrPtrPtr ;
  Thread *thrPtr ;

  {
  thrPtr = (Thread *)arg;
  Ns_MasterLock();
  thrPtrPtr = & firstThreadPtr;
  while ((unsigned int )(*thrPtrPtr) != (unsigned int )thrPtr) {
    thrPtrPtr = & ((*thrPtrPtr))->nextPtr;
  }
  (*thrPtrPtr) = thrPtr->nextPtr;
  thrPtr->nextPtr = (struct Thread *)((void *)0);
  Ns_MasterUnlock();
  ns_free((void *)thrPtr);
  return;
}
}
void NsCleanupTls(void **slots ) ;
void **NsGetTls(void) ;
int nsThreadMaxTls  =    100;
static Ns_TlsCleanup *cleanupProcs___0[100]  ;
static int nextkey  =    1;
void Ns_TlsAlloc(Ns_Tls *keyPtr , Ns_TlsCleanup *cleanup ) 
{ int key___3 ;
  int tmp ;

  {
  Ns_MasterLock();
  if (nextkey == 100) {
    Tcl_Panic((char *)"Ns_TlsAlloc: exceded max tls: %d", 100);
  }
  tmp = nextkey;
  nextkey ++;
  key___3 = tmp;
  cleanupProcs___0[key___3] = cleanup;
  Ns_MasterUnlock();
  (*keyPtr) = (struct Ns_Tls_ *)((void *)key___3);
  return;
}
}
void Ns_TlsSet(Ns_Tls *keyPtr , void *value ) 
{ void **slots ;
  void **tmp ;
  int key___3 ;

  {
  tmp = NsGetTls();
  slots = tmp;
  key___3 = (int )(*keyPtr);
  if (key___3 < 1) {
    Tcl_Panic((char *)"Ns_TlsSet: invalid key: %d: should be between 1 and %d", key___3,
              100);
  } else {
    if (key___3 >= 100) {
      Tcl_Panic((char *)"Ns_TlsSet: invalid key: %d: should be between 1 and %d",
                key___3, 100);
    }
  }
  (*(slots + key___3)) = value;
  return;
}
}
void *Ns_TlsGet(Ns_Tls *keyPtr ) 
{ void **slots ;
  void **tmp ;
  int key___3 ;

  {
  tmp = NsGetTls();
  slots = tmp;
  key___3 = (int )(*keyPtr);
  if (key___3 < 1) {
    Tcl_Panic((char *)"Ns_TlsGet: invalid key: %d: should be between 1 and %d", key___3,
              100);
  } else {
    if (key___3 >= 100) {
      Tcl_Panic((char *)"Ns_TlsGet: invalid key: %d: should be between 1 and %d",
                key___3, 100);
    }
  }
  return ((*(slots + key___3)));
}
}
void NsCleanupTls(void **slots ) 
{ int i ;
  int trys ;
  int retry ;
  void *arg ;
  int tmp ;
  int tmp___0 ;

  {
  trys = 0;
  while (1) {
    retry = 0;
    i = 100;
    while (1) {
      tmp = i;
      i --;
      if (! (tmp > 0)) {
        break;
      }
      if ((unsigned int )cleanupProcs___0[i] != (unsigned int )((void *)0)) {
        if ((unsigned int )(*(slots + i)) != (unsigned int )((void *)0)) {
          arg = (*(slots + i));
          (*(slots + i)) = (void *)0;
          ((*(cleanupProcs___0[i])))(arg);
          retry = 1;
        }
      }
    }
    if (retry) {
      tmp___0 = trys;
      trys ++;
      if (! (tmp___0 < 5)) {
        break;
      }
    } else {
      break;
    }
  }
  return;
}
}
extern int sigaction(int __sig , struct sigaction  const  * __restrict  __act , struct sigaction * __restrict  __oact ) ;
extern int sigwait(sigset_t const   * __restrict  __set , int * __restrict  __sig ) ;
extern int pthread_sigmask(int __how , __sigset_t const   * __restrict  __newmask ,
                           __sigset_t * __restrict  __oldmask ) ;
int ns_sigmask(int how , sigset_t *set , sigset_t *oset ) 
{ int tmp ;

  {
  tmp = pthread_sigmask(how, (__sigset_t const   * __restrict  )set, (__sigset_t * __restrict  )oset);
  return (tmp);
}
}
int ns_signal(int sig , void (*proc)(int  ) ) 
{ struct sigaction sa ;
  int tmp ;

  {
  sa.sa_flags = 0;
  sa.__sigaction_handler.sa_handler = proc;
  sigemptyset(& sa.sa_mask);
  tmp = sigaction(sig, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  return (tmp);
}
}
int ns_sigwait(sigset_t *set , int *sig ) 
{ int tmp ;

  {
  tmp = sigwait((sigset_t const   * __restrict  )set, (int * __restrict  )sig);
  return (tmp);
}
}
int Ns_InitializeMutex(Ns_Mutex *mutexPtr ) ;
int Ns_DestroyMutex(Ns_Mutex *mutexPtr ) ;
int Ns_LockMutex(Ns_Mutex *mutexPtr ) ;
int Ns_UnlockMutex(Ns_Mutex *mutexPtr ) ;
int Ns_InitializeCriticalSection(Ns_CriticalSection *cs ) ;
int Ns_DestroyCriticalSection(Ns_CriticalSection *cs ) ;
int Ns_EnterCriticalSection(Ns_CriticalSection *cs ) ;
int Ns_LeaveCriticalSection(Ns_CriticalSection *cs ) ;
int Ns_InitializeEvent(Ns_Event *event ) ;
int Ns_DestroyEvent(Ns_Event *event ) ;
int Ns_SetEvent(Ns_Event *event ) ;
int Ns_BroadcastEvent(Ns_Event *event ) ;
int Ns_WaitForEvent(Ns_Event *event , Ns_Mutex *lock___31 ) ;
int Ns_AbsTimedWaitForEvent(Ns_Event *event , Ns_Mutex *lock___31 , time_t abstime ) ;
int Ns_UTimedWaitForEvent(Ns_Event *event , Ns_Mutex *lock___31 , int seconds , int microseconds ) ;
int Ns_InitializeRWLock(Ns_RWLock *lock___31 ) ;
int Ns_DestroyRWLock(Ns_RWLock *lock___31 ) ;
int Ns_ReadLockRWLock(Ns_RWLock *lock___31 ) ;
int Ns_ReadUnlockRWLock(Ns_RWLock *lock___31 ) ;
int Ns_WriteLockRWLock(Ns_RWLock *lock___31 ) ;
int Ns_WriteUnlockRWLock(Ns_RWLock *lock___31 ) ;
int Ns_InitializeSemaphore(Ns_Semaphore *sema___1 , int initCount ) ;
int Ns_DestroySemaphore(Ns_Semaphore *sema___1 ) ;
int Ns_WaitForSemaphore(Ns_Semaphore *sema___1 ) ;
int Ns_ReleaseSemaphore(Ns_Semaphore *sema___1 , int count ) ;
int Ns_AllocThreadLocalStorage(Ns_ThreadLocalStorage *tls___4 , Ns_TlsCleanup *cleanup ) ;
int Ns_SetThreadLocalStorage(Ns_ThreadLocalStorage *tls___4 , void *p ) ;
int Ns_GetThreadLocalStorage(Ns_ThreadLocalStorage *tls___4 , void **p ) ;
int Ns_WaitForThread(Ns_Thread *thrPtr ) ;
int Ns_WaitThread(Ns_Thread *thrPtr , int *exitCodePtr ) ;
void Ns_ExitThread(int exitCode ) ;
int Ns_BeginDetachedThread(Ns_ThreadProc *proc , void *arg ) ;
int Ns_BeginThread(Ns_ThreadProc *proc , void *arg , Ns_Thread *thrPtr ) ;
int Ns_GetThreadId(void) ;
void Ns_GetThread(Ns_Thread *threadPtr ) ;
Ns_Pool *Ns_PoolCreate(char *name ) ;
void Ns_PoolFlush(Ns_Pool *pool ) ;
void Ns_PoolDestroy(Ns_Pool *pool ) ;
void *Ns_PoolAlloc(Ns_Pool *pool , size_t reqsize ) ;
void Ns_PoolFree(Ns_Pool *pool , void *ptr ) ;
void *Ns_PoolRealloc(Ns_Pool *pool , void *ptr , size_t reqsize ) ;
void *Ns_PoolCalloc(Ns_Pool *pool , size_t nelem , size_t elsize ) ;
char *Ns_PoolStrDup(Ns_Pool *pool , char *old ) ;
char *Ns_PoolStrCopy(Ns_Pool *pool , char *old ) ;
void *Ns_ThreadMalloc(size_t size ) ;
void *Ns_ThreadAlloc(size_t size ) ;
void *Ns_ThreadRealloc(void *ptr , size_t size ) ;
void Ns_ThreadFree(void *ptr ) ;
void *Ns_ThreadCalloc(size_t nelem , size_t elsize ) ;
char *Ns_ThreadStrDup(char *old ) ;
char *Ns_ThreadStrCopy(char *old ) ;
int Ns_InitializeMutex(Ns_Mutex *mutexPtr ) 
{ 

  {
  Ns_MutexInit(mutexPtr);
  return (0);
}
}
int Ns_DestroyMutex(Ns_Mutex *mutexPtr ) 
{ 

  {
  Ns_MutexDestroy(mutexPtr);
  return (0);
}
}
int Ns_LockMutex(Ns_Mutex *mutexPtr ) 
{ 

  {
  Ns_MutexLock(mutexPtr);
  return (0);
}
}
int Ns_UnlockMutex(Ns_Mutex *mutexPtr ) 
{ 

  {
  Ns_MutexUnlock(mutexPtr);
  return (0);
}
}
int Ns_InitializeCriticalSection(Ns_CriticalSection *cs ) 
{ 

  {
  Ns_CsInit((Ns_Cs *)cs);
  return (0);
}
}
int Ns_DestroyCriticalSection(Ns_CriticalSection *cs ) 
{ 

  {
  Ns_CsDestroy((Ns_Cs *)cs);
  return (0);
}
}
int Ns_EnterCriticalSection(Ns_CriticalSection *cs ) 
{ 

  {
  Ns_CsEnter((Ns_Cs *)cs);
  return (0);
}
}
int Ns_LeaveCriticalSection(Ns_CriticalSection *cs ) 
{ 

  {
  Ns_CsLeave((Ns_Cs *)cs);
  return (0);
}
}
int Ns_InitializeEvent(Ns_Event *event ) 
{ 

  {
  Ns_CondInit((Ns_Cond *)event);
  return (0);
}
}
int Ns_DestroyEvent(Ns_Event *event ) 
{ 

  {
  Ns_CondDestroy((Ns_Cond *)event);
  return (0);
}
}
int Ns_SetEvent(Ns_Event *event ) 
{ 

  {
  Ns_CondSignal((Ns_Cond *)event);
  return (0);
}
}
int Ns_BroadcastEvent(Ns_Event *event ) 
{ 

  {
  Ns_CondBroadcast((Ns_Cond *)event);
  return (0);
}
}
int Ns_WaitForEvent(Ns_Event *event , Ns_Mutex *lock___31 ) 
{ int tmp ;

  {
  tmp = Ns_CondTimedWait((Ns_Cond *)event, lock___31, (Ns_Time *)((void *)0));
  return (tmp);
}
}
int Ns_TimedWaitForEvent(Ns_Event *event , Ns_Mutex *lock___31 , int timeout ) 
{ int tmp ;

  {
  tmp = Ns_UTimedWaitForEvent(event, lock___31, timeout, 0);
  return (tmp);
}
}
int Ns_AbsTimedWaitForEvent(Ns_Event *event , Ns_Mutex *lock___31 , time_t abstime ) 
{ Ns_Time wait ;
  int tmp ;

  {
  wait.sec = abstime;
  wait.usec = 0L;
  tmp = Ns_CondTimedWait((Ns_Cond *)event, lock___31, & wait);
  return (tmp);
}
}
int Ns_UTimedWaitForEvent(Ns_Event *event , Ns_Mutex *lock___31 , int seconds , int microseconds ) 
{ Ns_Time to ;
  Ns_Time *timePtr ;
  int tmp ;

  {
  if (seconds <= 0) {
    if (microseconds <= 0) {
      timePtr = (Ns_Time *)((void *)0);
    } else {
      Ns_GetTime(& to);
      Ns_IncrTime(& to, (long )seconds, (long )microseconds);
      timePtr = & to;
    }
  } else {
    Ns_GetTime(& to);
    Ns_IncrTime(& to, (long )seconds, (long )microseconds);
    timePtr = & to;
  }
  tmp = Ns_CondTimedWait((Ns_Cond *)event, lock___31, timePtr);
  return (tmp);
}
}
int Ns_InitializeRWLock(Ns_RWLock *lock___31 ) 
{ 

  {
  Ns_RWLockInit(lock___31);
  return (0);
}
}
int Ns_DestroyRWLock(Ns_RWLock *lock___31 ) 
{ 

  {
  Ns_RWLockDestroy(lock___31);
  return (0);
}
}
int Ns_ReadLockRWLock(Ns_RWLock *lock___31 ) 
{ 

  {
  Ns_RWLockRdLock(lock___31);
  return (0);
}
}
int Ns_ReadUnlockRWLock(Ns_RWLock *lock___31 ) 
{ 

  {
  Ns_RWLockUnlock(lock___31);
  return (0);
}
}
int Ns_WriteLockRWLock(Ns_RWLock *lock___31 ) 
{ 

  {
  Ns_RWLockWrLock(lock___31);
  return (0);
}
}
int Ns_WriteUnlockRWLock(Ns_RWLock *lock___31 ) 
{ 

  {
  Ns_RWLockUnlock(lock___31);
  return (0);
}
}
int Ns_InitializeSemaphore(Ns_Semaphore *sema___1 , int initCount ) 
{ 

  {
  Ns_SemaInit((Ns_Sema *)sema___1, initCount);
  return (0);
}
}
int Ns_DestroySemaphore(Ns_Semaphore *sema___1 ) 
{ 

  {
  Ns_SemaDestroy((Ns_Sema *)sema___1);
  return (0);
}
}
int Ns_WaitForSemaphore(Ns_Semaphore *sema___1 ) 
{ 

  {
  Ns_SemaWait((Ns_Sema *)sema___1);
  return (0);
}
}
int Ns_ReleaseSemaphore(Ns_Semaphore *sema___1 , int count ) 
{ 

  {
  Ns_SemaPost((Ns_Sema *)sema___1, count);
  return (0);
}
}
int Ns_AllocThreadLocalStorage(Ns_ThreadLocalStorage *tls___4 , Ns_TlsCleanup *cleanup ) 
{ 

  {
  Ns_TlsAlloc((Ns_Tls *)tls___4, cleanup);
  return (0);
}
}
int Ns_SetThreadLocalStorage(Ns_ThreadLocalStorage *tls___4 , void *p ) 
{ 

  {
  Ns_TlsSet((Ns_Tls *)tls___4, p);
  return (0);
}
}
int Ns_GetThreadLocalStorage(Ns_ThreadLocalStorage *tls___4 , void **p ) 
{ 

  {
  (*p) = Ns_TlsGet((Ns_Tls *)tls___4);
  return (0);
}
}
int Ns_WaitForThread(Ns_Thread *thrPtr ) 
{ 

  {
  Ns_ThreadJoin(thrPtr, (void **)((void *)0));
  return (0);
}
}
int Ns_WaitThread(Ns_Thread *thrPtr , int *exitCodePtr ) 
{ void *arg ;

  {
  Ns_ThreadJoin(thrPtr, & arg);
  if ((unsigned int )exitCodePtr != (unsigned int )((void *)0)) {
    (*exitCodePtr) = (int )arg;
  }
  return (0);
}
}
void Ns_ExitThread(int exitCode ) 
{ 

  {
  Ns_ThreadExit((void *)exitCode);
  return;
}
}
int Ns_BeginDetachedThread(Ns_ThreadProc *proc , void *arg ) 
{ 

  {
  Ns_ThreadCreate(proc, arg, 0L, (Ns_Thread *)((void *)0));
  return (0);
}
}
int Ns_BeginThread(Ns_ThreadProc *proc , void *arg , Ns_Thread *thrPtr ) 
{ Ns_Thread thr ;
  Ns_Thread *tmp ;

  {
  if (thrPtr) {
    tmp = thrPtr;
  } else {
    tmp = & thr;
  }
  Ns_ThreadCreate(proc, arg, 0L, tmp);
  return (0);
}
}
int Ns_GetThreadId(void) 
{ int tmp ;

  {
  tmp = Ns_ThreadId();
  return (tmp);
}
}
void Ns_GetThread(Ns_Thread *threadPtr ) 
{ 

  {
  Ns_ThreadSelf(threadPtr);
  return;
}
}
Ns_Pool *Ns_ThreadPool(void) 
{ 

  {
  return ((Ns_Pool *)-1);
}
}
void *Ns_ThreadMalloc(size_t size ) 
{ void *tmp ;

  {
  tmp = ns_malloc(size);
  return (tmp);
}
}
void *Ns_ThreadRealloc(void *ptr , size_t size ) 
{ void *tmp ;

  {
  tmp = ns_realloc(ptr, size);
  return (tmp);
}
}
void Ns_ThreadFree(void *ptr ) 
{ 

  {
  ns_free(ptr);
  return;
}
}
void *Ns_ThreadCalloc(size_t nelem , size_t elsize ) 
{ void *tmp ;

  {
  tmp = ns_calloc(nelem, elsize);
  return (tmp);
}
}
char *Ns_ThreadStrDup(char *old ) 
{ char *tmp ;

  {
  tmp = ns_strdup((char const   *)old);
  return (tmp);
}
}
char *Ns_ThreadStrCopy(char *old ) 
{ char *tmp ;

  {
  tmp = ns_strcopy((char const   *)old);
  return (tmp);
}
}
Ns_Pool *Ns_PoolCreate(char *name ) 
{ 

  {
  return ((Ns_Pool *)-1);
}
}
void Ns_PoolFlush(Ns_Pool *pool ) 
{ 

  {
  return;
}
}
void Ns_PoolDestroy(Ns_Pool *pool ) 
{ 

  {
  return;
}
}
void *Ns_PoolAlloc(Ns_Pool *pool , size_t reqsize ) 
{ void *tmp ;

  {
  tmp = ns_malloc(reqsize);
  return (tmp);
}
}
void Ns_PoolFree(Ns_Pool *pool , void *ptr ) 
{ 

  {
  ns_free(ptr);
  return;
}
}
void *Ns_PoolRealloc(Ns_Pool *pool , void *ptr , size_t reqsize ) 
{ void *tmp ;

  {
  tmp = ns_realloc(ptr, reqsize);
  return (tmp);
}
}
void *Ns_PoolCalloc(Ns_Pool *pool , size_t nelem , size_t elsize ) 
{ void *tmp ;

  {
  tmp = ns_calloc(nelem, elsize);
  return (tmp);
}
}
char *Ns_PoolStrDup(Ns_Pool *pool , char *old ) 
{ char *tmp ;

  {
  tmp = ns_strdup((char const   *)old);
  return (tmp);
}
}
char *Ns_PoolStrCopy(Ns_Pool *pool , char *old ) 
{ char *tmp ;

  {
  tmp = ns_strcopy((char const   *)old);
  return (tmp);
}
}
int Ns_PoolBlockSize(void *ptr , int *reqPtr , int *usePtr ) 
{ 

  {
  return (-1);
}
}
void *Ns_Malloc(size_t size ) 
{ void *tmp ;

  {
  tmp = ns_malloc(size);
  return (tmp);
}
}
void *Ns_Realloc(void *ptr , size_t size ) 
{ void *tmp ;

  {
  tmp = ns_realloc(ptr, size);
  return (tmp);
}
}
void *Ns_Calloc(size_t nelem , size_t elsize ) 
{ void *tmp ;

  {
  tmp = ns_calloc(nelem, elsize);
  return (tmp);
}
}
void Ns_Free(void *ptr ) 
{ 

  {
  ns_free(ptr);
  return;
}
}
char *Ns_StrDup(char *str ) 
{ char *tmp ;

  {
  tmp = ns_strdup((char const   *)str);
  return (tmp);
}
}
char *Ns_StrCopy(char *str ) 
{ char *tmp ;

  {
  tmp = ns_strcopy((char const   *)str);
  return (tmp);
}
}
void *Ns_ThreadAlloc(size_t size ) 
{ void *tmp ;

  {
  tmp = Ns_ThreadMalloc(size);
  return (tmp);
}
}
extern int gettimeofday(struct timeval * __restrict  __tv , __timezone_ptr_t __tz ) ;
void Ns_GetTime(Ns_Time *timePtr ) 
{ struct timeval tv ;

  {
  gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((void *)0));
  timePtr->sec = tv.tv_sec;
  timePtr->usec = tv.tv_usec;
  return;
}
}
void Ns_AdjTime(Ns_Time *timePtr ) 
{ 

  {
  if (timePtr->usec < 0L) {
    timePtr->sec = timePtr->sec + (timePtr->usec / 1000000L - 1L);
    timePtr->usec = timePtr->usec % 1000000L + 1000000L;
  } else {
    if (timePtr->usec > 1000000L) {
      timePtr->sec = timePtr->sec + timePtr->usec / 1000000L;
      timePtr->usec = timePtr->usec % 1000000L;
    }
  }
  return;
}
}
int Ns_DiffTime(Ns_Time *t1 , Ns_Time *t0 , Ns_Time *diffPtr ) 
{ Ns_Time diff ;

  {
  if ((unsigned int )diffPtr == (unsigned int )((void *)0)) {
    diffPtr = & diff;
  }
  if (t1->usec >= t0->usec) {
    diffPtr->sec = t1->sec - t0->sec;
    diffPtr->usec = t1->usec - t0->usec;
  } else {
    diffPtr->sec = (t1->sec - t0->sec) - 1L;
    diffPtr->usec = (1000000L + t1->usec) - t0->usec;
  }
  Ns_AdjTime(diffPtr);
  if (diffPtr->sec < 0L) {
    return (-1);
  } else {
    if (diffPtr->sec == 0L) {
      if (diffPtr->usec == 0L) {
        return (0);
      } else {
        return (1);
      }
    } else {
      return (1);
    }
  }
}
}
void Ns_IncrTime(Ns_Time *timePtr , time_t sec , long usec ) 
{ 

  {
  timePtr->usec = timePtr->usec + usec;
  timePtr->sec = timePtr->sec + sec;
  Ns_AdjTime(timePtr);
  return;
}
}
extern __pid_t fork(void) ;
int ns_fork(void) 
{ int tmp ;

  {
  tmp = fork();
  return (tmp);
}
}
int Ns_Fork(void) 
{ int tmp ;

  {
  tmp = ns_fork();
  return (tmp);
}
}
void NsthreadsInit(void) ;
extern int sched_yield(void) ;
extern int pthread_create(pthread_t * __restrict  __threadp , pthread_attr_t const   * __restrict  __attr ,
                          void *(*__start_routine)(void * ) , void * __restrict  __arg ) ;
extern pthread_t pthread_self(void) ;
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern int pthread_detach(pthread_t __th ) ;
extern int pthread_attr_init(pthread_attr_t *__attr ) ;
extern int pthread_attr_destroy(pthread_attr_t *__attr ) ;
extern int pthread_attr_setscope(pthread_attr_t *__attr , int __scope ) ;
extern int pthread_attr_setstacksize(pthread_attr_t *__attr , size_t __stacksize ) ;
extern int pthread_mutex_init(pthread_mutex_t * __restrict  __mutex , pthread_mutexattr_t const   * __restrict  __mutex_attr ) ;
extern int pthread_mutex_destroy(pthread_mutex_t *__mutex ) ;
extern int pthread_mutex_trylock(pthread_mutex_t *__mutex ) ;
extern int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
extern int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
extern int pthread_cond_init(pthread_cond_t * __restrict  __cond , pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern int pthread_cond_destroy(pthread_cond_t *__cond ) ;
extern int pthread_cond_signal(pthread_cond_t *__cond ) ;
extern int pthread_cond_broadcast(pthread_cond_t *__cond ) ;
extern int pthread_cond_wait(pthread_cond_t * __restrict  __cond , pthread_mutex_t * __restrict  __mutex ) ;
extern int pthread_cond_timedwait(pthread_cond_t * __restrict  __cond , pthread_mutex_t * __restrict  __mutex ,
                                  struct timespec  const  * __restrict  __abstime ) ;
extern int pthread_key_create(pthread_key_t *__key , void (*__destr_function)(void * ) ) ;
extern int pthread_setspecific(pthread_key_t __key , void const   *__pointer ) ;
extern void *pthread_getspecific(pthread_key_t __key ) ;
static pthread_cond_t *GetCond(Ns_Cond *cond___9 ) ;
static pthread_key_t key___0  ;
static void CleanupTls(void *arg ) ;
static void *ThreadMain(void *arg ) ;
void NsthreadsInit(void) 
{ int err ;

  {
  err = pthread_key_create(& key___0, & CleanupTls);
  if (err != 0) {
    NsThreadFatal((char *)"NsthreadsInit", (char *)"pthread_key_create", err);
  }
  NsInitThreads();
  return;
}
}
void **NsGetTls(void) 
{ void **slots ;

  {
  slots = (void **)pthread_getspecific(key___0);
  if ((unsigned int )slots == (unsigned int )((void *)0)) {
    slots = (void **)ns_calloc(100U, sizeof(void *));
    pthread_setspecific(key___0, (void const   *)slots);
  }
  return (slots);
}
}
char *NsThreadLibName(void) 
{ 

  {
  return ((char *)"pthread");
}
}
void *NsLockAlloc(void) 
{ pthread_mutex_t *lock___31 ;
  int err ;

  {
  lock___31 = (pthread_mutex_t *)ns_malloc(sizeof(pthread_mutex_t ));
  err = pthread_mutex_init((pthread_mutex_t * __restrict  )lock___31, (pthread_mutexattr_t const   * __restrict  )((void *)0));
  if (err != 0) {
    NsThreadFatal((char *)"NsLockAlloc", (char *)"pthread_mutex_init", err);
  }
  return ((void *)lock___31);
}
}
void NsLockFree(void *lock___31 ) 
{ int err ;

  {
  err = pthread_mutex_destroy((pthread_mutex_t *)lock___31);
  if (err != 0) {
    NsThreadFatal((char *)"NsLockFree", (char *)"pthread_mutex_destroy", err);
  }
  ns_free(lock___31);
  return;
}
}
void NsLockSet(void *lock___31 ) 
{ int err ;

  {
  err = pthread_mutex_lock((pthread_mutex_t *)lock___31);
  if (err != 0) {
    NsThreadFatal((char *)"NsLockSet", (char *)"pthread_mutex_lock", err);
  }
  return;
}
}
int NsLockTry(void *lock___31 ) 
{ int err ;

  {
  err = pthread_mutex_trylock((pthread_mutex_t *)lock___31);
  if (err == 16) {
    return (0);
  } else {
    if (err != 0) {
      NsThreadFatal((char *)"NsLockTry", (char *)"pthread_mutex_trylock", err);
    }
  }
  return (1);
}
}
void NsLockUnset(void *lock___31 ) 
{ int err ;

  {
  err = pthread_mutex_unlock((pthread_mutex_t *)lock___31);
  if (err != 0) {
    NsThreadFatal((char *)"NsLockUnset", (char *)"pthread_mutex_unlock", err);
  }
  return;
}
}
static char *func  =    (char *)"NsCreateThread";
void NsCreateThread(void *arg , long stacksize___1 , Ns_Thread *resultPtr ) 
{ pthread_attr_t attr ;
  pthread_t thr ;
  int err ;

  {
  err = pthread_attr_init(& attr);
  if (err != 0) {
    NsThreadFatal(func, (char *)"pthread_attr_init", err);
  }
  err = pthread_attr_setstacksize(& attr, (unsigned int )stacksize___1);
  if (err != 0) {
    NsThreadFatal(func, (char *)"pthread_attr_setstacksize", err);
  }
  err = pthread_attr_setscope(& attr, 0);
  if (err != 0) {
    if (err != 95) {
      NsThreadFatal(func, (char *)"pthread_setscope", err);
    }
  }
  err = pthread_create((pthread_t * __restrict  )(& thr), (pthread_attr_t const   * __restrict  )(& attr),
                       & ThreadMain, (void * __restrict  )arg);
  if (err != 0) {
    NsThreadFatal(func, (char *)"pthread_create", err);
  }
  err = pthread_attr_destroy(& attr);
  if (err != 0) {
    NsThreadFatal(func, (char *)"pthread_attr_destroy", err);
  }
  if ((unsigned int )resultPtr != (unsigned int )((void *)0)) {
    (*resultPtr) = (struct Ns_Thread_ *)thr;
  } else {
    err = pthread_detach(thr);
    if (err != 0) {
      NsThreadFatal(func, (char *)"pthread_detach", err);
    }
  }
  return;
}
}
void Ns_ThreadExit(void *arg ) 
{ 

  {
  pthread_exit(arg);
}
}
void Ns_ThreadJoin(Ns_Thread *thread , void **argPtr ) 
{ pthread_t thr ;
  int err ;

  {
  thr = (unsigned long )(*thread);
  err = pthread_join(thr, argPtr);
  if (err != 0) {
    NsThreadFatal((char *)"Ns_ThreadJoin", (char *)"pthread_join", err);
  }
  return;
}
}
void Ns_ThreadYield(void) 
{ 

  {
  sched_yield();
  return;
}
}
int Ns_ThreadId(void) 
{ int tmp ;

  {
  tmp = (int )pthread_self();
  return (tmp);
}
}
void Ns_ThreadSelf(Ns_Thread *threadPtr ) 
{ 

  {
  (*threadPtr) = (Ns_Thread )pthread_self();
  return;
}
}
void Ns_CondInit(Ns_Cond *cond___9 ) 
{ pthread_cond_t *condPtr ;
  int err ;

  {
  condPtr = (pthread_cond_t *)ns_malloc(sizeof(pthread_cond_t ));
  err = pthread_cond_init((pthread_cond_t * __restrict  )condPtr, (pthread_condattr_t const   * __restrict  )((void *)0));
  if (err != 0) {
    NsThreadFatal((char *)"Ns_CondInit", (char *)"pthread_cond_init", err);
  }
  (*cond___9) = (struct Ns_Cond_ *)condPtr;
  return;
}
}
void Ns_CondDestroy(Ns_Cond *cond___9 ) 
{ pthread_cond_t *condPtr ;
  int err ;

  {
  condPtr = (pthread_cond_t *)(*cond___9);
  if ((unsigned int )condPtr != (unsigned int )((void *)0)) {
    err = pthread_cond_destroy(condPtr);
    if (err != 0) {
      NsThreadFatal((char *)"Ns_CondDestroy", (char *)"pthread_cond_destroy", err);
    }
    ns_free((void *)condPtr);
    (*cond___9) = (struct Ns_Cond_ *)((void *)0);
  }
  return;
}
}
void Ns_CondSignal(Ns_Cond *cond___9 ) 
{ int err ;
  pthread_cond_t *tmp ;

  {
  tmp = GetCond(cond___9);
  err = pthread_cond_signal(tmp);
  if (err != 0) {
    NsThreadFatal((char *)"Ns_CondSignal", (char *)"pthread_cond_signal", err);
  }
  return;
}
}
void Ns_CondBroadcast(Ns_Cond *cond___9 ) 
{ int err ;
  pthread_cond_t *tmp ;

  {
  tmp = GetCond(cond___9);
  err = pthread_cond_broadcast(tmp);
  if (err != 0) {
    NsThreadFatal((char *)"Ns_CondBroadcast", (char *)"pthread_cond_broadcast", err);
  }
  return;
}
}
void Ns_CondWait(Ns_Cond *cond___9 , Ns_Mutex *mutex ) 
{ int err ;
  void *tmp ;
  pthread_cond_t *tmp___0 ;

  {
  tmp = NsGetLock(mutex);
  tmp___0 = GetCond(cond___9);
  err = pthread_cond_wait((pthread_cond_t * __restrict  )tmp___0, (pthread_mutex_t * __restrict  )tmp);
  if (err != 0) {
    NsThreadFatal((char *)"Ns_CondWait", (char *)"pthread_cond_wait", err);
  }
  return;
}
}
int Ns_CondTimedWait(Ns_Cond *cond___9 , Ns_Mutex *mutex , Ns_Time *timePtr ) 
{ int err ;
  int status ;
  struct timespec ts ;
  void *tmp ;
  pthread_cond_t *tmp___0 ;

  {
  status = -1;
  if ((unsigned int )timePtr == (unsigned int )((void *)0)) {
    Ns_CondWait(cond___9, mutex);
    return (0);
  }
  ts.tv_sec = timePtr->sec;
  ts.tv_nsec = timePtr->usec * 1000L;
  while (1) {
    tmp = NsGetLock(mutex);
    tmp___0 = GetCond(cond___9);
    err = pthread_cond_timedwait((pthread_cond_t * __restrict  )tmp___0, (pthread_mutex_t * __restrict  )tmp,
                                 (struct timespec  const  * __restrict  )(& ts));
    if (! (err == 4)) {
      break;
    }
  }
  if (err == 110) {
    status = -2;
  } else {
    if (err != 0) {
      NsThreadFatal((char *)"Ns_CondTimedWait", (char *)"pthread_cond_timedwait",
                    err);
    } else {
      status = 0;
    }
  }
  return (status);
}
}
static pthread_cond_t *GetCond(Ns_Cond *cond___9 ) 
{ 

  {
  if ((unsigned int )(*cond___9) == (unsigned int )((void *)0)) {
    Ns_MasterLock();
    if ((unsigned int )(*cond___9) == (unsigned int )((void *)0)) {
      Ns_CondInit(cond___9);
    }
    Ns_MasterUnlock();
  }
  return ((pthread_cond_t *)(*cond___9));
}
}
static void *ThreadMain(void *arg ) 
{ 

  {
  NsThreadMain(arg);
  return ((void *)0);
}
}
static void CleanupTls(void *arg ) 
{ void **slots ;

  {
  slots = (void **)arg;
  pthread_setspecific(key___0, (void const   *)arg);
  NsCleanupTls(slots);
  pthread_setspecific(key___0, (void const   *)((void *)0));
  ns_free((void *)slots);
  return;
}
}
static int ReturnObjCmd___1(NsInterp *itPtr , int objc , Tcl_Obj **objv , int exception ) ;
static int EvalObjCmd___0(NsInterp *itPtr , int objc , Tcl_Obj **objv , int safe ) ;
static int IsValidAdpContext___0(NsInterp *itPtr ) ;
static int EvalObjCmd___0(NsInterp *itPtr , int objc , Tcl_Obj **objv , int safe ) 
{ int tmp ;

  {
  if (objc < 2) {
    Tcl_WrongNumArgs(itPtr->interp, 1, objv, (char *)"page ?args ...?");
    return (1);
  }
  tmp = NsAdpEval(itPtr, objc - 1, objv + 1, safe, (char *)((void *)0));
  return (tmp);
}
}
static int ReturnObjCmd___1(NsInterp *itPtr , int objc , Tcl_Obj **objv , int exception ) 
{ 

  {
  if (objc != 1) {
    if (objc != 2) {
      Tcl_WrongNumArgs(itPtr->interp, 1, objv, (char *)"?retval?");
      return (1);
    }
  }
  itPtr->adp.exception = exception;
  if (objc == 2) {
    Tcl_SetObjResult(itPtr->interp, (*(objv + 1)));
  }
  return (1);
}
}
static int IsValidAdpContext___0(NsInterp *itPtr ) 
{ 

  {
  return ((unsigned int )itPtr->adp.outputPtr != (unsigned int )((void *)0));
}
}
static Page *ParseFile___0(NsInterp *itPtr , char *file___1 , struct stat *stPtr ) ;
static void PushFrame___0(NsInterp *itPtr , Frame *framePtr , char *file___1 , int objc ,
                          Tcl_Obj **objv , Tcl_DString *outputPtr ) ;
static void PopFrame___0(NsInterp *itPtr , Frame *framePtr ) ;
static void LogError___0(NsInterp *itPtr , int nscript ) ;
static int AdpRun___0(NsInterp *itPtr , char *file___1 , int objc , Tcl_Obj **objv ,
                      Tcl_DString *outputPtr ) ;
static int AdpEval___0(NsInterp *itPtr , AdpCode *codePtr , Tcl_Obj **objs ) ;
static void ParseFree___0(AdpParse *parsePtr ) ;
static int AdpDebug___0(NsInterp *itPtr , char *ptr , int len , int nscript ) ;
static void FreeInterpPage___0(void *arg ) ;
static int AdpRun___0(NsInterp *itPtr , char *file___1 , int objc , Tcl_Obj **objv ,
                      Tcl_DString *outputPtr ) 
{ NsServer *servPtr ;
  Tcl_Interp *interp ;
  Tcl_HashEntry *hPtr ;
  struct stat st ;
  Tcl_DString tmp ;
  Tcl_DString path ;
  Frame frame ;
  InterpPage *ipagePtr ;
  Page *pagePtr ;
  Page *oldPagePtr ;
  Ns_Entry *ePtr ;
  int new ;
  int n ;
  char *p ;
  char *key___1 ;
  FileKey ukey ;
  int status ;
  int tmp___0 ;
  Ns_Set *hdrs ;
  char *host ;
  char *port ;
  char *procs___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  servPtr = itPtr->servPtr;
  interp = itPtr->interp;
  ipagePtr = (InterpPage *)((void *)0);
  pagePtr = (Page *)((void *)0);
  status = 1;
  Tcl_DStringInit(& tmp);
  Tcl_DStringInit(& path);
  key___1 = (char *)(& ukey);
  tmp___0 = Ns_PathIsAbsolute(file___1);
  if (tmp___0) {
    Ns_NormalizePath(& path, file___1);
  } else {
    Ns_MakePath(& tmp, itPtr->adp.cwd, file___1, (void *)0);
    Ns_NormalizePath(& path, tmp.string);
    Tcl_DStringSetLength(& tmp, 0);
  }
  file___1 = path.string;
  if (itPtr->adp.debugLevel > 0) {
    itPtr->adp.debugLevel = itPtr->adp.debugLevel + 1;
  } else {
    if (servPtr->adp.enabledebug != 0) {
      if ((unsigned int )itPtr->adp.debugFile != (unsigned int )((void *)0)) {
        p = strrchr((char const   *)file___1, '/');
        if ((unsigned int )p != (unsigned int )((void *)0)) {
          tmp___3 = Tcl_StringMatch(p + 1, itPtr->adp.debugFile);
          if (tmp___3) {
            hdrs = Ns_ConnGetQuery(itPtr->conn);
            host = Ns_SetIGet(hdrs, (char *)"dhost");
            port = Ns_SetIGet(hdrs, (char *)"dport");
            procs___0 = Ns_SetIGet(hdrs, (char *)"dprocs");
            tmp___2 = NsAdpDebug(itPtr, host, port, procs___0);
            if (tmp___2 != 0) {
              tmp___1 = Tcl_GetStringResult(interp);
              Ns_ConnReturnNotice(itPtr->conn, 200, (char *)"Debug Init Failed", tmp___1);
              itPtr->adp.exception = 2;
              goto done;
            }
          }
        }
      }
    }
  }
  if ((unsigned int )itPtr->adp.cache == (unsigned int )((void *)0)) {
    Ns_DStringPrintf(& tmp, (char *)"nsadp:%s:%p", (itPtr->servPtr)->server, itPtr);
    itPtr->adp.cache = Ns_CacheCreateSz(tmp.string, (int )(sizeof(FileKey ) / sizeof(int )),
                                        (itPtr->servPtr)->adp.cachesize, & FreeInterpPage___0);
    Tcl_DStringSetLength(& tmp, 0);
  }
  tmp___5 = stat__extinline((char const   *)file___1, & st);
  if (tmp___5 != 0) {
    tmp___4 = Tcl_PosixError(interp);
    Tcl_AppendResult(interp, "could not stat \"", file___1, "\": ", tmp___4, (void *)0);
  } else {
    if (((st.st_mode & 61440U) == 32768U) == 0) {
      Tcl_AppendResult(interp, "not an ordinary file: ", file___1, (void *)0);
    } else {
      ukey.dev = st.st_dev;
      ukey.ino = st.st_ino;
      ePtr = Ns_CacheFindEntry(itPtr->adp.cache, key___1);
      if ((unsigned int )ePtr != (unsigned int )((void *)0)) {
        ipagePtr = (InterpPage *)Ns_CacheGetValue(ePtr);
        if ((ipagePtr->pagePtr)->mtime != st.st_mtim.tv_sec) {
          Ns_CacheFlushEntry(ePtr);
          ipagePtr = (InterpPage *)((void *)0);
        } else {
          if ((ipagePtr->pagePtr)->size != st.st_size) {
            Ns_CacheFlushEntry(ePtr);
            ipagePtr = (InterpPage *)((void *)0);
          }
        }
      }
      if ((unsigned int )ipagePtr == (unsigned int )((void *)0)) {
        Ns_MutexLock(& servPtr->adp.pagelock);
        hPtr = ((*(servPtr->adp.pages.createProc)))(& servPtr->adp.pages, key___1,
                                                    & new);
        while (1) {
          if (! new) {
            pagePtr = (Page *)hPtr->clientData;
            if (! ((unsigned int )pagePtr == (unsigned int )((void *)0))) {
              break;
            }
          } else {
            break;
          }
          Ns_CondWait(& servPtr->adp.pagecond, & servPtr->adp.pagelock);
          hPtr = ((*(servPtr->adp.pages.createProc)))(& servPtr->adp.pages, key___1,
                                                      & new);
        }
        if (! new) {
          if (pagePtr->mtime != st.st_mtim.tv_sec) {
            hPtr->clientData = (void *)0;
            pagePtr->hPtr = (Tcl_HashEntry *)((void *)0);
            new = 1;
          } else {
            if (pagePtr->size != st.st_size) {
              hPtr->clientData = (void *)0;
              pagePtr->hPtr = (Tcl_HashEntry *)((void *)0);
              new = 1;
            }
          }
        }
        if (new) {
          Ns_MutexUnlock(& servPtr->adp.pagelock);
          pagePtr = ParseFile___0(itPtr, file___1, & st);
          Ns_MutexLock(& servPtr->adp.pagelock);
          if ((unsigned int )pagePtr == (unsigned int )((void *)0)) {
            Tcl_DeleteHashEntry(hPtr);
          } else {
            if (ukey.dev != st.st_dev) {
              goto _L;
            } else {
              if (ukey.ino != st.st_ino) {
                _L: 
                Tcl_DeleteHashEntry(hPtr);
                ukey.dev = st.st_dev;
                ukey.ino = st.st_ino;
                hPtr = ((*(servPtr->adp.pages.createProc)))(& servPtr->adp.pages,
                                                            key___1, & new);
                if (! new) {
                  oldPagePtr = (Page *)hPtr->clientData;
                  oldPagePtr->hPtr = (Tcl_HashEntry *)((void *)0);
                }
              }
            }
            pagePtr->hPtr = hPtr;
            hPtr->clientData = (void *)pagePtr;
          }
          Ns_CondBroadcast(& servPtr->adp.pagecond);
        }
        if ((unsigned int )pagePtr != (unsigned int )((void *)0)) {
          pagePtr->refcnt = pagePtr->refcnt + 1;
        }
        Ns_MutexUnlock(& servPtr->adp.pagelock);
        if ((unsigned int )pagePtr != (unsigned int )((void *)0)) {
          n = (int )(sizeof(Tcl_Obj *) * (unsigned int )pagePtr->code.nscripts);
          ipagePtr = (InterpPage *)ns_calloc(1U, sizeof(InterpPage ) + (unsigned int )n);
          ipagePtr->pagePtr = pagePtr;
          ePtr = Ns_CacheCreateEntry(itPtr->adp.cache, key___1, & new);
          if (! new) {
            Ns_CacheUnsetValue(ePtr);
          }
          Ns_CacheSetValueSz(ePtr, (void *)ipagePtr, (unsigned int )(ipagePtr->pagePtr)->size);
        }
      }
    }
  }
  if ((unsigned int )ipagePtr != (unsigned int )((void *)0)) {
    PushFrame___0(itPtr, & frame, file___1, objc, objv, outputPtr);
    status = AdpEval___0(itPtr, & (ipagePtr->pagePtr)->code, ipagePtr->objs);
    PopFrame___0(itPtr, & frame);
    Ns_MutexLock(& servPtr->adp.pagelock);
    (ipagePtr->pagePtr)->evals = (ipagePtr->pagePtr)->evals + 1;
    Ns_MutexUnlock(& servPtr->adp.pagelock);
  }
  if (itPtr->adp.debugLevel > 0) {
    itPtr->adp.debugLevel = itPtr->adp.debugLevel - 1;
  }
  done: 
  Tcl_DStringFree(& path);
  Tcl_DStringFree(& tmp);
  return (status);
}
}
static void PushFrame___0(NsInterp *itPtr , Frame *framePtr , char *file___1 , int objc ,
                          Tcl_Obj **objv , Tcl_DString *outputPtr ) 
{ char *slash ;

  {
  framePtr->cwd = itPtr->adp.cwd;
  framePtr->objc = itPtr->adp.objc;
  framePtr->objv = itPtr->adp.objv;
  framePtr->outputPtr = itPtr->adp.outputPtr;
  itPtr->adp.outputPtr = outputPtr;
  itPtr->adp.objc = objc;
  itPtr->adp.objv = objv;
  itPtr->adp.depth = itPtr->adp.depth + 1;
  Tcl_DStringInit(& framePtr->cwdBuf);
  if ((unsigned int )file___1 != (unsigned int )((void *)0)) {
    slash = strrchr((char const   *)file___1, '/');
    Tcl_DStringAppend(& framePtr->cwdBuf, file___1, slash - file___1);
    itPtr->adp.cwd = framePtr->cwdBuf.string;
  }
  return;
}
}
static void PopFrame___0(NsInterp *itPtr , Frame *framePtr ) 
{ 

  {
  itPtr->adp.objc = framePtr->objc;
  itPtr->adp.objv = framePtr->objv;
  itPtr->adp.cwd = framePtr->cwd;
  itPtr->adp.outputPtr = framePtr->outputPtr;
  itPtr->adp.depth = itPtr->adp.depth - 1;
  Tcl_DStringFree(& framePtr->cwdBuf);
  return;
}
}
static Page *ParseFile___0(NsInterp *itPtr , char *file___1 , struct stat *stPtr ) 
{ Tcl_Interp *interp ;
  Tcl_Encoding encoding ;
  Tcl_DString utf ;
  char *page ;
  char *buf ;
  int fd ;
  int n ;
  int trys ;
  size_t size ;
  Page *pagePtr ;
  AdpParse parse ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  __off_t tmp___4 ;
  size_t tmp___5 ;

  {
  interp = itPtr->interp;
  fd = open((char const   *)file___1, 0);
  if (fd < 0) {
    tmp = Tcl_PosixError(interp);
    Tcl_AppendResult(interp, "could not open \"", file___1, "\": ", tmp, (void *)0);
    return ((Page *)((void *)0));
  }
  pagePtr = (Page *)((void *)0);
  buf = (char *)((void *)0);
  trys = 0;
  while (1) {
    tmp___1 = fstat__extinline(fd, stPtr);
    if (tmp___1 != 0) {
      tmp___0 = Tcl_PosixError(interp);
      Tcl_AppendResult(interp, "could not fstat \"", file___1, "\": ", tmp___0, (void *)0);
      goto done;
    }
    size = (unsigned int )stPtr->st_size;
    buf = (char *)ns_realloc((void *)buf, size + 1U);
    n = read(fd, (void *)buf, size + 1U);
    if (n < 0) {
      tmp___2 = Tcl_PosixError(interp);
      Tcl_AppendResult(interp, "could not read \"", file___1, "\": ", tmp___2, (void *)0);
      goto done;
    }
    if ((unsigned int )n != size) {
      tmp___4 = lseek(fd, 0L, 0);
      if (tmp___4 != 0L) {
        tmp___3 = Tcl_PosixError(interp);
        Tcl_AppendResult(interp, "could not lseek \"", file___1, "\": ", tmp___3,
                         (void *)0);
        goto done;
      }
      Ns_ThreadYield();
    }
    if ((unsigned int )n != size) {
      trys ++;
      if (! (trys < 10)) {
        break;
      }
    } else {
      break;
    }
  }
  if ((unsigned int )n != size) {
    Tcl_AppendResult(interp, "inconsistant file: ", file___1, (void *)0);
  } else {
    (*(buf + n)) = (char )'\000';
    Tcl_DStringInit(& utf);
    encoding = Ns_GetFileEncoding(file___1);
    if ((unsigned int )encoding == (unsigned int )((void *)0)) {
      page = buf;
    } else {
      Tcl_ExternalToUtfDString(encoding, buf, n, & utf);
      page = utf.string;
    }
    NsAdpParse(& parse, itPtr->servPtr, page, 0);
    Tcl_DStringFree(& utf);
    tmp___5 = strlen((char const   *)file___1);
    n = (int )(((unsigned int )(parse.hdr.length + parse.text.length) + tmp___5) +
               1U);
    pagePtr = (Page *)ns_malloc(sizeof(Page ) + (unsigned int )n);
    pagePtr->servPtr = itPtr->servPtr;
    pagePtr->refcnt = 0;
    pagePtr->evals = 0;
    pagePtr->mtime = stPtr->st_mtim.tv_sec;
    pagePtr->size = stPtr->st_size;
    pagePtr->code.nblocks = parse.code.nblocks;
    pagePtr->code.nscripts = parse.code.nscripts;
    pagePtr->code.len = (int *)(pagePtr + 1);
    pagePtr->code.base = (char *)(pagePtr->code.len + parse.code.nblocks);
    pagePtr->file = pagePtr->code.base + parse.text.length;
    memcpy((void * __restrict  )pagePtr->code.len, (void const   * __restrict  )parse.hdr.string,
           (unsigned int )parse.hdr.length);
    memcpy((void * __restrict  )pagePtr->code.base, (void const   * __restrict  )parse.text.string,
           (unsigned int )parse.text.length);
    strcpy((char * __restrict  )pagePtr->file, (char const   * __restrict  )file___1);
    ParseFree___0(& parse);
  }
  done: 
  ns_free((void *)buf);
  close(fd);
  return (pagePtr);
}
}
static void LogError___0(NsInterp *itPtr , int nscript ) 
{ Tcl_Interp *interp ;
  Tcl_DString ds ;
  Tcl_Obj *objv[2] ;
  char *file___1 ;
  char *script ;
  char buffer[154] ;
  size_t tmp ;

  {
  interp = itPtr->interp;
  Tcl_DStringInit(& ds);
  Tcl_DStringAppend(& ds, (char *)"\n    invoked from within chunk: ", -1);
  Ns_DStringPrintf(& ds, (char *)"%d", nscript);
  Tcl_DStringAppend(& ds, (char *)" of adp: ", -1);
  script = Tcl_GetString((*(itPtr->adp.objv + 0)));
  tmp = strlen((char const   *)script);
  if (tmp > 150U) {
    sprintf((char * __restrict  )(buffer), (char const   * __restrict  )"%.*s...",
            150, script);
    script = buffer;
  }
  Tcl_DStringAppend(& ds, script, -1);
  Tcl_AddErrorInfo(interp, ds.string);
  Ns_TclLogError(interp);
  Tcl_DStringFree(& ds);
  file___1 = (itPtr->servPtr)->adp.errorpage;
  if ((unsigned int )file___1 != (unsigned int )((void *)0)) {
    if (itPtr->adp.errorLevel == 0) {
      itPtr->adp.errorLevel = itPtr->adp.errorLevel + 1;
      objv[0] = Tcl_NewStringObj(file___1, -1);
      (objv[0])->refCount = (objv[0])->refCount + 1;
      objv[1] = Tcl_GetVar2Ex(interp, (char *)"errorInfo", (char *)((void *)0), 1);
      if ((unsigned int )objv[1] == (unsigned int )((void *)0)) {
        objv[1] = Tcl_GetObjResult(interp);
      }
      NsAdpInclude(itPtr, file___1, 2, objv);
      (objv[0])->refCount = (objv[0])->refCount - 1;
      if ((objv[0])->refCount <= 0) {
        TclFreeObj(objv[0]);
      }
      itPtr->adp.errorLevel = itPtr->adp.errorLevel - 1;
    }
  }
  return;
}
}
static int AdpEval___0(NsInterp *itPtr , AdpCode *codePtr , Tcl_Obj **objs ) 
{ Tcl_Interp *interp ;
  Tcl_Obj *objPtr ;
  int nscript ;
  int result ;
  int len ;
  int i ;
  char *ptr ;

  {
  interp = itPtr->interp;
  ptr = codePtr->base;
  nscript = 0;
  result = 0;
  i = 0;
  while (1) {
    if (itPtr->adp.exception == 0) {
      if (! (i < codePtr->nblocks)) {
        break;
      }
    } else {
      break;
    }
    len = (*(codePtr->len + i));
    if (len > 0) {
      if ((unsigned int )itPtr->adp.outputPtr != (unsigned int )((void *)0)) {
        Tcl_DStringAppend(itPtr->adp.outputPtr, ptr, len);
      }
    } else {
      len = - len;
      if (itPtr->adp.debugLevel > 0) {
        result = AdpDebug___0(itPtr, ptr, len, nscript);
      } else {
        if ((unsigned int )objs == (unsigned int )((void *)0)) {
          result = Tcl_EvalEx(interp, ptr, len, 0);
        } else {
          objPtr = (*(objs + nscript));
          if ((unsigned int )objPtr != (unsigned int )((void *)0)) {
            result = Tcl_EvalObjEx(interp, objPtr, 0);
          } else {
            objPtr = Tcl_NewStringObj(ptr, len);
            objPtr->refCount = objPtr->refCount + 1;
            result = Tcl_EvalObjEx(interp, objPtr, 0);
            (*(objs + nscript)) = objPtr;
          }
        }
      }
      if (result != 0) {
        if (result != 2) {
          if (itPtr->adp.exception == 0) {
            LogError___0(itPtr, nscript);
          }
        }
      }
      nscript ++;
    }
    ptr += len;
    NsAdpFlush(itPtr);
    i ++;
  }
  if (itPtr->adp.exception == 4) {
    itPtr->adp.exception = 0;
    result = 0;
  }
  NsAdpFlush(itPtr);
  return (result);
}
}
static int AdpDebug___0(NsInterp *itPtr , char *ptr , int len , int nscript ) 
{ int code ;
  int fd ;
  Tcl_Interp *interp ;
  int level ;
  char *file___1 ;
  char *tmp ;
  char buf[10] ;
  char debugfile[255] ;
  Tcl_DString ds ;
  char *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;
  char *tmp___3 ;

  {
  interp = itPtr->interp;
  level = itPtr->adp.debugLevel;
  tmp = Tcl_GetString((*(itPtr->adp.objv + 0)));
  file___1 = tmp;
  code = 1;
  Tcl_DStringInit(& ds);
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", level);
  Ns_DStringVarAppend(& ds, "#\n# level: ", buf, "\n", (void *)0);
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", nscript);
  Ns_DStringVarAppend(& ds, "# chunk: ", buf, "\n# file:  ", file___1, "\n#\n\n",
                      (void *)0);
  Tcl_DStringAppend(& ds, ptr, len);
  sprintf((char * __restrict  )(debugfile), (char const   * __restrict  )"/tmp/adp%d.%d.XXXXXX",
          level, nscript);
  tmp___3 = mktemp(debugfile);
  if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
    Tcl_SetResult(interp, (char *)"could not create adp debug file", (Tcl_FreeProc *)0);
  } else {
    fd = open((char const   *)(debugfile), 577, 420);
    if (fd < 0) {
      tmp___0 = Tcl_PosixError(interp);
      Tcl_AppendResult(interp, "could not create adp debug file \"", debugfile, "\": ",
                       tmp___0, (void *)0);
    } else {
      tmp___2 = write(fd, (void const   *)ds.string, (unsigned int )ds.length);
      if (tmp___2 < 0) {
        tmp___1 = Tcl_PosixError(interp);
        Tcl_AppendResult(interp, "write to \"", debugfile, "\" failed: ", tmp___1,
                         (void *)0);
      } else {
        Tcl_DStringSetLength(& ds, 0);
        Ns_DStringVarAppend(& ds, "source ", debugfile, (void *)0);
        code = Tcl_EvalEx(interp, ds.string, ds.length, 0);
      }
      close(fd);
      unlink((char const   *)(debugfile));
    }
  }
  Tcl_DStringFree(& ds);
  return (code);
}
}
static void FreeInterpPage___0(void *arg ) 
{ InterpPage *ipagePtr ;
  Page *pagePtr ;
  NsServer *servPtr ;
  int i ;

  {
  ipagePtr = (InterpPage *)arg;
  pagePtr = ipagePtr->pagePtr;
  servPtr = pagePtr->servPtr;
  i = 0;
  while (i < pagePtr->code.nscripts) {
    if ((unsigned int )ipagePtr->objs[i] != (unsigned int )((void *)0)) {
      (ipagePtr->objs[i])->refCount = (ipagePtr->objs[i])->refCount - 1;
      if ((ipagePtr->objs[i])->refCount <= 0) {
        TclFreeObj(ipagePtr->objs[i]);
      }
    }
    i ++;
  }
  Ns_MutexLock(& servPtr->adp.pagelock);
  pagePtr->refcnt = pagePtr->refcnt - 1;
  if (pagePtr->refcnt == 0) {
    if ((unsigned int )pagePtr->hPtr != (unsigned int )((void *)0)) {
      Tcl_DeleteHashEntry(pagePtr->hPtr);
    }
    ns_free((void *)pagePtr);
  }
  Ns_MutexUnlock(& servPtr->adp.pagelock);
  ns_free((void *)ipagePtr);
  return;
}
}
static void ParseFree___0(AdpParse *parsePtr ) 
{ 

  {
  Tcl_DStringFree(& parsePtr->hdr);
  Tcl_DStringFree(& parsePtr->text);
  return;
}
}
static void AppendBlock___0(AdpParse *parsePtr , char *s , char *e___1 , int type ) ;
static void Parse___0(AdpParse *parsePtr , NsServer *servPtr , char *utf ) ;
static int RegisterCmd___0(ClientData arg , Tcl_Interp *interp , int argc , char **argv ,
                           int type ) ;
static int RegisterCmd___0(ClientData arg , Tcl_Interp *interp , int argc , char **argv ,
                           int type ) 
{ NsInterp *itPtr ;
  NsServer *servPtr ;
  char *string ;
  Tcl_HashEntry *hPtr ;
  int new ;
  int slen ;
  int elen ;
  Tag *tagPtr ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
  itPtr = (NsInterp *)arg;
  servPtr = itPtr->servPtr;
  if (argc != 4) {
    if (argc != 3) {
      if (type == 1) {
        tmp = "adp";
      } else {
        tmp = "proc";
      }
      Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " tag ?endtag? ",
                       tmp, "\"", (void *)0);
      return (1);
    }
  }
  string = (*(argv + (argc - 1)));
  tmp___0 = strlen((char const   *)string);
  slen = (int )(tmp___0 + 1U);
  if (argc == 3) {
    elen = 0;
  } else {
    tmp___1 = strlen((char const   *)(*(argv + 2)));
    elen = (int )(tmp___1 + 1U);
  }
  tagPtr = (Tag *)ns_malloc((sizeof(Tag ) + (unsigned int )slen) + (unsigned int )elen);
  tagPtr->type = type;
  tagPtr->string = (char *)tagPtr + sizeof(Tag );
  memcpy((void * __restrict  )tagPtr->string, (void const   * __restrict  )string,
         (unsigned int )slen);
  if (argc == 3) {
    tagPtr->endtag = (char *)((void *)0);
  } else {
    tagPtr->endtag = tagPtr->string + slen;
    memcpy((void * __restrict  )tagPtr->endtag, (void const   * __restrict  )(*(argv +
                                                                                2)),
           (unsigned int )elen);
  }
  Ns_RWLockWrLock(& servPtr->adp.taglock);
  hPtr = ((*(servPtr->adp.tags.createProc)))(& servPtr->adp.tags, (*(argv + 1)), & new);
  if (! new) {
    ns_free(hPtr->clientData);
  }
  hPtr->clientData = (void *)tagPtr;
  if (servPtr->adp.tags.keyType == 1) {
    tmp___2 = hPtr->key.oneWordValue;
  } else {
    if (servPtr->adp.tags.keyType == -1) {
      tmp___2 = hPtr->key.oneWordValue;
    } else {
      tmp___2 = hPtr->key.string;
    }
  }
  tagPtr->tag = tmp___2;
  Ns_RWLockUnlock(& servPtr->adp.taglock);
  return (0);
}
}
static void AppendBlock___0(AdpParse *parsePtr , char *s , char *e___1 , int type ) 
{ int len ;

  {
  if ((unsigned int )s < (unsigned int )e___1) {
    parsePtr->code.nblocks = parsePtr->code.nblocks + 1;
    len = e___1 - s;
    if (type == 83) {
      len = (int )((unsigned int )len + (sizeof("ns_adp_append ") - 1U));
      Tcl_DStringAppend(& parsePtr->text, (char *)"ns_adp_append ", (int )(sizeof("ns_adp_append ") -
                                                                           1U));
    }
    Tcl_DStringAppend(& parsePtr->text, s, e___1 - s);
    if (type != 116) {
      parsePtr->code.nscripts = parsePtr->code.nscripts + 1;
      len = - len;
    }
    Tcl_DStringAppend(& parsePtr->hdr, (char *)(& len), (int )sizeof(len));
  }
  return;
}
}
static void GetTag___0(Tcl_DString *dsPtr , char *s , char *e___1 , char **aPtr ) 
{ char *t ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  s ++;
  while (1) {
    if ((unsigned int )s < (unsigned int )e___1) {
      tmp = __ctype_b_loc();
      if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*s)))) & 8192)) {
        break;
      }
    } else {
      break;
    }
    s ++;
  }
  t = s;
  while (1) {
    if ((unsigned int )s < (unsigned int )e___1) {
      tmp___0 = __ctype_b_loc();
      if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*s)))) & 8192) {
        break;
      }
    } else {
      break;
    }
    s ++;
  }
  Tcl_DStringSetLength(dsPtr, 0);
  Tcl_DStringAppend(dsPtr, t, s - t);
  if ((unsigned int )aPtr != (unsigned int )((void *)0)) {
    while (1) {
      if ((unsigned int )s < (unsigned int )e___1) {
        tmp___1 = __ctype_b_loc();
        if (! ((int const   )(*((*tmp___1) + (int )((unsigned char )(*s)))) & 8192)) {
          break;
        }
      } else {
        break;
      }
      s ++;
    }
    (*aPtr) = s;
  }
  dsPtr->length = Tcl_UtfToLower(dsPtr->string);
  return;
}
}
static void ParseAtts___0(char *s , char *e___1 , int *servPtr , Tcl_DString *attsPtr ,
                          int atts ) 
{ char *vs ;
  char *ve ;
  char *as ;
  char *ae ;
  char end ;
  char vsave ;
  char asave ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  vs = (char *)((void *)0);
  ve = (char *)((void *)0);
  as = (char *)((void *)0);
  ae = (char *)((void *)0);
  end = (char)0;
  vsave = (char)0;
  asave = (char)0;
  if ((unsigned int )servPtr != (unsigned int )((void *)0)) {
    (*servPtr) = 0;
  }
  while ((unsigned int )s < (unsigned int )e___1) {
    while (1) {
      if ((unsigned int )s < (unsigned int )e___1) {
        tmp = __ctype_b_loc();
        if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*s)))) & 8192)) {
          break;
        }
      } else {
        break;
      }
      s ++;
    }
    if ((unsigned int )s == (unsigned int )e___1) {
      break;
    }
    as = s;
    if ((int )(*s) != 39) {
      if ((int )(*s) != 34) {
        while (1) {
          if ((unsigned int )s < (unsigned int )e___1) {
            tmp___0 = __ctype_b_loc();
            if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*s)))) & 8192) {
              break;
            } else {
              if (! ((int )(*s) != 61)) {
                break;
              }
            }
          } else {
            break;
          }
          s ++;
        }
      } else {
        goto _L;
      }
    } else {
      _L: 
      s ++;
      while (1) {
        if ((unsigned int )s < (unsigned int )e___1) {
          if (! ((int )(*s) != (int )(*as))) {
            break;
          }
        } else {
          break;
        }
        s ++;
      }
      s ++;
    }
    ae = s;
    while (1) {
      if ((unsigned int )s < (unsigned int )e___1) {
        tmp___1 = __ctype_b_loc();
        if (! ((int const   )(*((*tmp___1) + (int )((unsigned char )(*s)))) & 8192)) {
          break;
        }
      } else {
        break;
      }
      s ++;
    }
    if ((int )(*s) != 61) {
      vs = as;
    } else {
      while (1) {
        s ++;
        if ((unsigned int )s < (unsigned int )e___1) {
          tmp___2 = __ctype_b_loc();
          if (! ((int const   )(*((*tmp___2) + (int )((unsigned char )(*s)))) & 8192)) {
            break;
          }
        } else {
          break;
        }
      }
      vs = s;
      if ((int )(*s) != 34) {
        while (1) {
          if ((unsigned int )s < (unsigned int )e___1) {
            tmp___3 = __ctype_b_loc();
            if ((int const   )(*((*tmp___3) + (int )((unsigned char )(*s)))) & 8192) {
              break;
            }
          } else {
            break;
          }
          s ++;
        }
      } else {
        s ++;
        while (1) {
          if ((unsigned int )s < (unsigned int )e___1) {
            if (! ((int )(*s) != (int )(*vs))) {
              break;
            }
          } else {
            break;
          }
          s ++;
        }
        s ++;
      }
      ve = s;
      end = (*vs);
      if ((int )end != 61) {
        if ((int )end != 34) {
          end = (char)0;
        }
      }
      if (end) {
        if ((unsigned int )ve > (unsigned int )vs) {
          if ((int )(*(ve + -1)) == (int )end) {
            vs ++;
            ve --;
          }
        }
      }
      vsave = (*ve);
      (*ve) = (char )'\000';
    }
    asave = (*ae);
    (*ae) = (char )'\000';
    if ((unsigned int )attsPtr != (unsigned int )((void *)0)) {
      if (atts) {
        Tcl_DStringAppendElement(attsPtr, as);
      }
      Tcl_DStringAppendElement(attsPtr, vs);
    }
    if ((unsigned int )servPtr != (unsigned int )((void *)0)) {
      if ((unsigned int )vs != (unsigned int )as) {
        tmp___8 = strcasecmp((char const   *)as, "runat");
        if (tmp___8 == 0) {
          tmp___9 = strcasecmp((char const   *)vs, "server");
          if (tmp___9 == 0) {
            (*servPtr) |= 2;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          tmp___6 = strcasecmp((char const   *)as, "language");
          if (tmp___6 == 0) {
            tmp___7 = strcasecmp((char const   *)vs, "tcl");
            if (tmp___7 == 0) {
              goto _L___0;
            } else {
              (*servPtr) |= 4;
            }
          } else {
            _L___0: 
            tmp___4 = strcasecmp((char const   *)as, "stream");
            if (tmp___4 == 0) {
              tmp___5 = strcasecmp((char const   *)vs, "on");
              if (tmp___5 == 0) {
                (*servPtr) |= 1;
              }
            }
          }
        }
      }
    }
    (*ae) = asave;
    if ((unsigned int )vs != (unsigned int )as) {
      (*ve) = vsave;
    }
  }
  return;
}
}
static int IsServer___0(char *tag , char *as , char *ae , int *streamPtr ) 
{ int serv ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if ((unsigned int )as < (unsigned int )ae) {
    if ((int )(*tag) == (int )(*"script")) {
      if (0) {
        __s1_len = strlen((char const   *)tag);
        __s2_len = strlen("script");
        if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
               1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("script" + 1)) - (unsigned int )((void const   *)"script") ==
                   1U)) {
              tmp___6 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___6 = 1;
              } else {
                tmp___6 = 0;
              }
            }
          } else {
            tmp___6 = 0;
          }
        }
        if (tmp___6) {
          if (__s1_len < __s2_len) {
            tmp___4 = __s1_len;
          } else {
            tmp___4 = __s2_len;
          }
          tmp___3 = memcmp((void const   *)((char const   *)tag), (void const   *)"script",
                           tmp___4 + 1U);
        } else {
          tmp___5 = strcmp((char const   *)tag, "script");
          tmp___3 = tmp___5;
        }
      } else {
        tmp___5 = strcmp((char const   *)tag, "script");
        tmp___3 = tmp___5;
      }
      if (tmp___3 == 0) {
        ParseAtts___0(as, ae, & serv, (Tcl_DString *)((void *)0), 1);
        if (serv & 2) {
          if (! (serv & 4)) {
            (*streamPtr) = serv & 1;
            return (1);
          }
        }
      }
    }
  }
  return (0);
}
}
static void AppendTag___0(AdpParse *parsePtr , Tag *tagPtr , char *as , char *ae ,
                          char *se ) 
{ Tcl_DString script ;
  char save ;

  {
  Tcl_DStringInit(& script);
  Tcl_DStringAppend(& script, (char *)"ns_adp_append [", -1);
  if (tagPtr->type == 1) {
    Tcl_DStringAppend(& script, (char *)"ns_adp_eval ", -1);
  }
  Tcl_DStringAppendElement(& script, tagPtr->string);
  if (tagPtr->type == 2) {
    ParseAtts___0(as, ae, (int *)((void *)0), & script, 0);
  }
  if ((unsigned int )se > (unsigned int )ae) {
    save = (*se);
    (*se) = (char )'\000';
    Tcl_DStringAppendElement(& script, ae + 1);
    (*se) = save;
  }
  if (tagPtr->type != 2) {
    Tcl_DStringAppend(& script, (char *)" [ns_set create", -1);
    Tcl_DStringAppendElement(& script, tagPtr->tag);
    ParseAtts___0(as, ae, (int *)((void *)0), & script, 1);
    Tcl_DStringAppend(& script, (char *)"]", 1);
  }
  Tcl_DStringAppend(& script, (char *)"]", 1);
  AppendBlock___0(parsePtr, script.string, script.string + script.length, 's');
  Tcl_DStringFree(& script);
  return;
}
}
static void Parse___0(AdpParse *parsePtr , NsServer *servPtr , char *utf ) 
{ Tag *tagPtr ;
  char *ss ;
  char *se ;
  char *s ;
  char *e___1 ;
  char *a ;
  char *as ;
  char *ae ;
  char *t ;
  int level ;
  int state ;
  int stream ;
  int streamdone ;
  Tcl_DString tag ;
  Tcl_HashEntry *hPtr ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___11 ;
  char *tmp___13 ;
  size_t tmp___14 ;

  {
  tagPtr = (Tag *)((void *)0);
  ss = (char *)((void *)0);
  se = (char *)((void *)0);
  s = (char *)((void *)0);
  e___1 = (char *)((void *)0);
  a = (char *)((void *)0);
  as = (char *)((void *)0);
  ae = (char *)((void *)0);
  t = (char *)((void *)0);
  level = 0;
  hPtr = (Tcl_HashEntry *)((void *)0);
  Tcl_DStringInit(& tag);
  t = utf;
  streamdone = 0;
  state = 0;
  Ns_RWLockRdLock(& servPtr->adp.taglock);
  while (1) {
    tmp___11 = strchr((char const   *)utf, '<');
    s = tmp___11;
    if (s) {
      tmp___13 = strchr((char const   *)s, '>');
      e___1 = tmp___13;
      if (! e___1) {
        break;
      }
    } else {
      break;
    }
    switch (state) {
    case 0: 
    GetTag___0(& tag, s, e___1, & a);
    tmp = IsServer___0(tag.string, a, e___1, & stream);
    if (tmp) {
      ss = s;
      se = e___1 + 1;
      state = 1;
    } else {
      hPtr = ((*(servPtr->adp.tags.findProc)))(& servPtr->adp.tags, tag.string);
      if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
        tagPtr = (Tag *)hPtr->clientData;
        if ((unsigned int )tagPtr->endtag == (unsigned int )((void *)0)) {
          AppendBlock___0(parsePtr, t, s, 't');
          t = e___1 + 1;
          AppendTag___0(parsePtr, tagPtr, a, e___1, (char *)((void *)0));
        } else {
          ss = s;
          as = a;
          ae = e___1;
          level = 1;
          state = 2;
        }
      }
    }
    break;
    case 1: 
    GetTag___0(& tag, s, e___1, (char **)((void *)0));
    if ((int )(*(tag.string)) == (int )(*"/script")) {
      if (0) {
        __s1_len = strlen((char const   *)tag.string);
        __s2_len = strlen("/script");
        if (! ((unsigned int )((void const   *)(tag.string + 1)) - (unsigned int )((void const   *)tag.string) ==
               1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("/script" + 1)) - (unsigned int )((void const   *)"/script") ==
                   1U)) {
              tmp___7 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___7 = 1;
              } else {
                tmp___7 = 0;
              }
            }
          } else {
            tmp___7 = 0;
          }
        }
        if (tmp___7) {
          if (__s1_len < __s2_len) {
            tmp___5 = __s1_len;
          } else {
            tmp___5 = __s2_len;
          }
          tmp___4 = memcmp((void const   *)((char const   *)tag.string), (void const   *)"/script",
                           tmp___5 + 1U);
        } else {
          tmp___6 = strcmp((char const   *)tag.string, "/script");
          tmp___4 = tmp___6;
        }
      } else {
        tmp___6 = strcmp((char const   *)tag.string, "/script");
        tmp___4 = tmp___6;
      }
      if (tmp___4 == 0) {
        AppendBlock___0(parsePtr, t, ss, 't');
        t = e___1 + 1;
        if (stream) {
          if (! streamdone) {
            AppendBlock___0(parsePtr, (char *)"ns_adp_stream", (char *)((void *)0),
                            's');
            streamdone = 1;
          }
        }
        AppendBlock___0(parsePtr, se, s, 's');
        state = 0;
      }
    }
    break;
    case 2: 
    GetTag___0(& tag, s, e___1, (char **)((void *)0));
    tmp___9 = strcasecmp((char const   *)tag.string, (char const   *)tagPtr->tag);
    if (tmp___9 == 0) {
      level ++;
    } else {
      tmp___8 = strcasecmp((char const   *)tag.string, (char const   *)tagPtr->endtag);
      if (tmp___8 == 0) {
        level --;
        if (level == 0) {
          AppendBlock___0(parsePtr, t, ss, 't');
          t = e___1 + 1;
          AppendTag___0(parsePtr, tagPtr, as, ae, s);
          state = 0;
        }
      }
    }
    break;
    }
    utf = s + 1;
  }
  Ns_RWLockUnlock(& servPtr->adp.taglock);
  tmp___14 = strlen((char const   *)t);
  AppendBlock___0(parsePtr, t, t + tmp___14, 't');
  Tcl_DStringFree(& tag);
  return;
}
}
static int AdpFlush___0(NsInterp *itPtr , int stream ) ;
static int AdpFlush___0(NsInterp *itPtr , int stream ) 
{ Tcl_Encoding encoding ;
  Ns_Conn *conn ;
  Tcl_DString ds ;
  Tcl_DString cds ;
  int result ;
  int len ;
  char *buf ;
  char *type ;
  char *ahdr ;
  Ns_Set *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  Tcl_DStringInit(& ds);
  Tcl_DStringInit(& cds);
  conn = itPtr->conn;
  buf = (itPtr->adp.responsePtr)->string;
  len = (itPtr->adp.responsePtr)->length;
  type = (itPtr->adp.typePtr)->string;
  encoding = Ns_ConnGetEncoding(conn);
  if ((unsigned int )encoding != (unsigned int )((void *)0)) {
    Tcl_UtfToExternalDString(encoding, buf, len, & ds);
    buf = ds.string;
    len = ds.length;
  }
  if (itPtr->adp.compress) {
    if ((itPtr->servPtr)->adp.compress.enable) {
      if (! (conn->flags & 16)) {
        if (! (conn->flags & 4)) {
          if (! stream) {
            if (len >= (itPtr->servPtr)->adp.compress.minsize) {
              tmp = Ns_ConnHeaders(conn);
              ahdr = Ns_SetIGet(tmp, (char *)"Accept-Encoding");
              if ((unsigned int )ahdr != (unsigned int )((void *)0)) {
                tmp___0 = strstr((char const   *)ahdr, "gzip");
                if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
                  tmp___1 = Ns_CompressGzip(buf, len, & cds, (itPtr->servPtr)->adp.compress.level);
                  if (tmp___1 == 0) {
                    Ns_ConnCondSetHeaders(conn, (char *)"Content-Encoding", (char *)"gzip");
                    buf = cds.string;
                    len = cds.length;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (! (conn->flags & 16)) {
    if ((itPtr->servPtr)->adp.enableexpire) {
      Ns_ConnCondSetHeaders(conn, (char *)"Expires", (char *)"now");
    }
    if (stream) {
      tmp___2 = -1;
    } else {
      tmp___2 = len;
    }
    Ns_ConnSetRequiredHeaders(conn, type, tmp___2);
    Ns_ConnQueueHeaders(conn, 200);
  }
  if (conn->flags & 4) {
    buf = (char *)((void *)0);
    len = 0;
  }
  result = Ns_WriteConn(conn, buf, len);
  if (result == 0) {
    if (! stream) {
      result = Ns_ConnClose(conn);
    }
  }
  Tcl_DStringFree(& ds);
  Tcl_DStringFree(& cds);
  Tcl_DStringSetLength(itPtr->adp.responsePtr, 0);
  return (result);
}
}
static Ns_UserAuthorizeProc *userProcPtr___0  ;
static void PreBind___0(char *line ) ;
static Tcl_HashTable prebound___0  ;
static Ns_Mutex lock___15  ;
static void PreBind___0(char *line ) 
{ Tcl_HashEntry *hPtr ;
  int new ;
  int sock ;
  int port ;
  struct sockaddr_in sa ;
  char *err ;
  char *ent ;
  char *p ;
  char *q ;
  char *addr ;
  char *baddr ;
  char *tmp___0 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  ent = line;
  while (1) {
    tmp___0 = strchr((char const   *)ent, ',');
    p = tmp___0;
    if ((unsigned int )p != (unsigned int )((void *)0)) {
      (*p) = (char )'\000';
    }
    baddr = (char *)((void *)0);
    addr = (char *)"0.0.0.0";
    tmp___2 = strchr((char const   *)ent, ':');
    q = tmp___2;
    if ((unsigned int )q == (unsigned int )((void *)0)) {
      port = atoi__extinline((char const   *)ent);
    } else {
      (*q) = (char )'\000';
      port = atoi__extinline((char const   *)(q + 1));
      addr = ent;
      baddr = addr;
    }
    if (port == 0) {
      err = (char *)"invalid port";
    } else {
      tmp___4 = Ns_GetSockAddr(& sa, baddr, port);
      if (tmp___4 != 0) {
        err = (char *)"invalid address";
      } else {
        hPtr = ((*(prebound___0.createProc)))(& prebound___0, (char *)(& sa), & new);
        if (! new) {
          err = (char *)"duplicate entry";
        } else {
          sock = Ns_SockBind(& sa);
          if (sock == -1) {
            Tcl_DeleteHashEntry(hPtr);
            tmp___3 = __errno_location();
            err = strerror((*tmp___3));
          } else {
            hPtr->clientData = (void *)sock;
            err = (char *)((void *)0);
          }
        }
      }
    }
    if ((unsigned int )q != (unsigned int )((void *)0)) {
      (*q) = (char )':';
    }
    if ((unsigned int )p != (unsigned int )((void *)0)) {
      tmp___5 = p;
      p ++;
      (*tmp___5) = (char )',';
    }
    if ((unsigned int )err != (unsigned int )((void *)0)) {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"prebind: invalid entry: %s: %s",
             ent, err);
    } else {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"prebind: bound: %s",
             ent);
    }
    ent = p;
    if (! ((unsigned int )ent != (unsigned int )((void *)0))) {
      break;
    }
  }
  return;
}
}
static Ns_Cache *CacheCreate___0(char *name , int keys , time_t timeout , size_t maxSize ,
                                 Ns_Callback *freeProc ) ;
static int GetCache___0(Tcl_Interp *interp , char *name , Cache **cachePtrPtr ) ;
static void Delink___0(Entry *ePtr ) ;
static void Push___0(Entry *ePtr ) ;
static Tcl_HashTable caches___0  ;
static Ns_Mutex lock___16  ;
static Ns_Cache *CacheCreate___0(char *name , int keys , time_t timeout , size_t maxSize ,
                                 Ns_Callback *freeProc ) 
{ Cache *cachePtr ;
  int new ;
  size_t tmp ;
  Cache *prevPtr ;

  {
  tmp = strlen((char const   *)name);
  cachePtr = (Cache *)ns_calloc(1U, sizeof(Cache ) + tmp);
  cachePtr->freeProc = freeProc;
  cachePtr->timeout = timeout;
  cachePtr->maxSize = maxSize;
  cachePtr->currentSize = 0U;
  cachePtr->keys = keys;
  strcpy((char * __restrict  )(cachePtr->name), (char const   * __restrict  )name);
  cachePtr->nmiss = 0U;
  cachePtr->nhit = cachePtr->nmiss;
  cachePtr->nflush = cachePtr->nhit;
  Ns_MutexSetName2(& cachePtr->lock, (char *)"ns:cache", name);
  Tcl_InitHashTable(& cachePtr->entriesTable, keys);
  if (timeout > 0L) {
    cachePtr->schedId = Ns_ScheduleProc(& NsCachePurge, (void *)cachePtr, 0, (int )timeout);
  } else {
    cachePtr->schedId = -1;
  }
  cachePtr->schedStop = 0;
  Ns_MutexLock(& lock___16);
  cachePtr->hPtr = ((*(caches___0.createProc)))(& caches___0, name, & new);
  if (! new) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"cache: duplicate cache name: %s",
           name);
    prevPtr = (Cache *)(cachePtr->hPtr)->clientData;
    prevPtr->hPtr = (Tcl_HashEntry *)((void *)0);
  }
  (cachePtr->hPtr)->clientData = (void *)cachePtr;
  Ns_MutexUnlock(& lock___16);
  return ((Ns_Cache *)cachePtr);
}
}
static void Delink___0(Entry *ePtr ) 
{ 

  {
  if ((unsigned int )ePtr->prevPtr != (unsigned int )((void *)0)) {
    (ePtr->prevPtr)->nextPtr = ePtr->nextPtr;
  } else {
    (ePtr->cachePtr)->firstEntryPtr = ePtr->nextPtr;
  }
  if ((unsigned int )ePtr->nextPtr != (unsigned int )((void *)0)) {
    (ePtr->nextPtr)->prevPtr = ePtr->prevPtr;
  } else {
    (ePtr->cachePtr)->lastEntryPtr = ePtr->prevPtr;
  }
  ePtr->nextPtr = (struct Entry *)((void *)0);
  ePtr->prevPtr = ePtr->nextPtr;
  return;
}
}
static void Push___0(Entry *ePtr ) 
{ 

  {
  if ((ePtr->cachePtr)->timeout > 0L) {
    Ns_GetTime(& ePtr->mtime);
  }
  if ((unsigned int )(ePtr->cachePtr)->firstEntryPtr != (unsigned int )((void *)0)) {
    ((ePtr->cachePtr)->firstEntryPtr)->prevPtr = ePtr;
  }
  ePtr->prevPtr = (struct Entry *)((void *)0);
  ePtr->nextPtr = (ePtr->cachePtr)->firstEntryPtr;
  (ePtr->cachePtr)->firstEntryPtr = ePtr;
  if ((unsigned int )(ePtr->cachePtr)->lastEntryPtr == (unsigned int )((void *)0)) {
    (ePtr->cachePtr)->lastEntryPtr = ePtr;
  }
  return;
}
}
static int GetCache___0(Tcl_Interp *interp , char *name , Cache **cachePtrPtr ) 
{ 

  {
  (*cachePtrPtr) = (Cache *)Ns_CacheFind(name);
  if ((unsigned int )(*cachePtrPtr) == (unsigned int )((void *)0)) {
    Tcl_AppendResult(interp, "no such cache: ", name, (void *)0);
    return (1);
  }
  return (0);
}
}
static void RunThread___0(void *arg ) ;
static void RunCallbacks___0(Callback *cbPtr ) ;
static void RunStart___0(Callback **firstPtrPtr , Ns_Thread *threadPtr ) ;
static void RunWait___0(Callback **firstPtrPtr , Ns_Thread *threadPtr , Ns_Time *toPtr ) ;
static void *RegisterAt___0(Callback **firstPtrPtr , Ns_Callback *proc , void *arg ) ;
static Callback *firstPreStartup___0  ;
static Callback *firstStartup___0  ;
static Callback *firstSignal___0  ;
static Callback *firstServerShutdown___0  ;
static Callback *firstShutdown___0  ;
static Callback *firstExit___0  ;
static Callback *firstReady___0  ;
static Ns_Mutex lock___17  ;
static Ns_Cond cond___4  ;
static int shutdownPending___3  ;
static Ns_Thread serverShutdownThread___0  ;
static int first___0  =    1;
static void *RegisterAt___0(Callback **firstPtrPtr , Ns_Callback *proc , void *arg ) 
{ Callback *cbPtr ;

  {
  cbPtr = (Callback *)ns_malloc(sizeof(Callback ));
  cbPtr->proc = proc;
  cbPtr->arg = arg;
  Ns_MutexLock(& lock___17);
  if (first___0) {
    Ns_MutexSetName(& lock___17, (char *)"ns:callbacks");
    first___0 = 0;
  }
  if (shutdownPending___3) {
    ns_free((void *)cbPtr);
    cbPtr = (Callback *)((void *)0);
  } else {
    cbPtr->nextPtr = (*firstPtrPtr);
    (*firstPtrPtr) = cbPtr;
  }
  Ns_MutexUnlock(& lock___17);
  return ((void *)cbPtr);
}
}
static void RunCallbacks___0(Callback *cbPtr ) 
{ 

  {
  while ((unsigned int )cbPtr != (unsigned int )((void *)0)) {
    ((*(cbPtr->proc)))(cbPtr->arg);
    cbPtr = cbPtr->nextPtr;
  }
  return;
}
}
static void RunStart___0(Callback **firstPtrPtr , Ns_Thread *threadPtr ) 
{ 

  {
  Ns_MutexLock(& lock___17);
  if ((unsigned int )(*firstPtrPtr) != (unsigned int )((void *)0)) {
    Ns_ThreadCreate(& RunThread___0, (void *)firstPtrPtr, 0L, threadPtr);
  } else {
    (*threadPtr) = (struct Ns_Thread_ *)((void *)0);
  }
  Ns_MutexUnlock(& lock___17);
  return;
}
}
static void RunWait___0(Callback **firstPtrPtr , Ns_Thread *threadPtr , Ns_Time *toPtr ) 
{ int status ;

  {
  status = 0;
  Ns_MutexLock(& lock___17);
  while (1) {
    if (status == 0) {
      if (! ((unsigned int )(*firstPtrPtr) != (unsigned int )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    status = Ns_CondTimedWait(& cond___4, & lock___17, toPtr);
  }
  Ns_MutexUnlock(& lock___17);
  if (status != 0) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"callbacks: timeout waiting for shutdown procs");
  } else {
    if ((unsigned int )(*threadPtr) != (unsigned int )((void *)0)) {
      Ns_ThreadJoin(threadPtr, (void **)((void *)0));
    }
  }
  return;
}
}
static void RunThread___0(void *arg ) 
{ Callback **firstPtrPtr ;
  Callback *firstPtr___1 ;

  {
  firstPtrPtr = (Callback **)arg;
  Ns_ThreadSetName((char *)"-shutdown-");
  Ns_MutexLock(& lock___17);
  firstPtr___1 = (*firstPtrPtr);
  Ns_MutexUnlock(& lock___17);
  RunCallbacks___0(firstPtr___1);
  Ns_MutexLock(& lock___17);
  while ((unsigned int )(*firstPtrPtr) != (unsigned int )((void *)0)) {
    firstPtr___1 = (*firstPtrPtr);
    (*firstPtrPtr) = firstPtr___1->nextPtr;
    ns_free((void *)firstPtr___1);
  }
  Ns_CondSignal(& cond___4);
  Ns_MutexUnlock(& lock___17);
  return;
}
}
static void AppendList___0(Tcl_DString *dsPtr , char *list , Callback *firstPtr___1 ) 
{ Callback *cbPtr ;

  {
  cbPtr = firstPtr___1;
  while ((unsigned int )cbPtr != (unsigned int )((void *)0)) {
    Tcl_DStringStartSublist(dsPtr);
    Tcl_DStringAppendElement(dsPtr, list);
    Ns_GetProcInfo(dsPtr, (void *)cbPtr->proc, cbPtr->arg);
    Tcl_DStringEndSublist(dsPtr);
    cbPtr = cbPtr->nextPtr;
  }
  return;
}
}
static Ns_Callback *cleanupProcs___1[16]  ;
static void **GetSlot___0(Ns_Cls *clsPtr , Ns_Conn *conn ) ;
static int nextId___1  =    1;
static void **GetSlot___0(Ns_Cls *clsPtr , Ns_Conn *conn ) 
{ Conn *connPtr ;
  int idx ;

  {
  connPtr = (Conn *)conn;
  idx = (int )(*clsPtr);
  if (idx < 1) {
    Ns_Fatal((char *)"Ns_Cls: invalid key: %d: must be between 1 and %d", idx, 16);
  } else {
    if (idx >= 16) {
      Ns_Fatal((char *)"Ns_Cls: invalid key: %d: must be between 1 and %d", idx, 16);
    }
  }
  return (& connPtr->cls[idx]);
}
}
static char header___0[10]  = 
  {      (char)31,      (char)-117,      (char)8,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)3};
static int SectionCmd___0(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
static int ParamCmd___0(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) ;
static Ns_Set *GetSection___0(char *section , int create ) ;
static char *ConfigGet___0(char *section , char *key___1 , int exact ) ;
static char *ConfigGet___0(char *section , char *key___1 , int exact ) 
{ Ns_Set *set ;
  int i ;
  char *s ;

  {
  s = (char *)((void *)0);
  if ((unsigned int )section != (unsigned int )((void *)0)) {
    if ((unsigned int )key___1 != (unsigned int )((void *)0)) {
      set = Ns_ConfigGetSection(section);
      if ((unsigned int )set != (unsigned int )((void *)0)) {
        if (exact) {
          i = Ns_SetFind(set, key___1);
        } else {
          i = Ns_SetIFind(set, key___1);
        }
        if (i >= 0) {
          s = (set->fields + i)->value;
        }
      }
    }
  }
  return (s);
}
}
static int ParamCmd___0(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ Ns_Set *set ;

  {
  if (argc != 3) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " key value",
                     (void *)0);
    return (1);
  }
  set = (*((Ns_Set **)arg));
  if ((unsigned int )set == (unsigned int )((void *)0)) {
    Tcl_AppendResult(interp, (*(argv + 0)), " not preceded by an ns_section command.",
                     (void *)0);
    return (1);
  }
  Ns_SetPut(set, (*(argv + 1)), (*(argv + 2)));
  return (0);
}
}
static int SectionCmd___0(ClientData arg , Tcl_Interp *interp , int argc , char **argv ) 
{ Ns_Set **set ;

  {
  if (argc != 2) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " sectionname",
                     (void *)0);
    return (1);
  }
  set = (Ns_Set **)arg;
  (*set) = GetSection___0((*(argv + 1)), 1);
  return (0);
}
}
static Ns_Set *GetSection___0(char *section , int create ) 
{ Tcl_DString ds ;
  Tcl_HashEntry *hPtr ;
  int new ;
  Ns_Set *set ;
  char *s ;
  unsigned short const   **tmp ;
  int __res ;
  __int32_t const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  Tcl_DStringInit(& ds);
  s = section;
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*s)))) & 8192)) {
      break;
    }
    s ++;
  }
  Tcl_DStringAppend(& ds, s, -1);
  s = ds.string;
  while ((int )(*s) != 0) {
    if ((int )(*s) == 92) {
      (*s) = (char )'/';
    } else {
      tmp___3 = __ctype_b_loc();
      if ((int const   )(*((*tmp___3) + (int )((unsigned char )(*s)))) & 256) {
        if (sizeof((unsigned char )(*s)) > 1U) {
          __res = tolower__extinline((int )((unsigned char )(*s)));
        } else {
          tmp___2 = __ctype_tolower_loc();
          __res = (*((*tmp___2) + (int )((unsigned char )(*s))));
        }
        (*s) = (char )__res;
      }
    }
    s ++;
  }
  while (1) {
    s --;
    if ((unsigned int )s > (unsigned int )ds.string) {
      tmp___4 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___4) + (int )((unsigned char )(*s)))) & 8192)) {
        break;
      }
    } else {
      break;
    }
    (*s) = (char )'\000';
  }
  section = ds.string;
  set = (Ns_Set *)((void *)0);
  if (! create) {
    hPtr = ((*(nsconf.sections.findProc)))(& nsconf.sections, section);
  } else {
    hPtr = ((*(nsconf.sections.createProc)))(& nsconf.sections, section, & new);
    if (new) {
      set = Ns_SetCreate(section);
      hPtr->clientData = (void *)set;
    }
  }
  if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    set = (Ns_Set *)hPtr->clientData;
  }
  Tcl_DStringFree(& ds);
  return (set);
}
}
static int GetChan___0(Tcl_Interp *interp , char *id , Tcl_Channel *chanPtr ) ;
static int GetIndices___0(Tcl_Interp *interp , Conn *connPtr , Tcl_Obj **objv , int *offPtr ,
                          int *lenPtr ) ;
static char *opts___16[38]  = 
  {      (char *)"authpassword",      (char *)"authuser",      (char *)"close",      (char *)"content", 
        (char *)"contentlength",      (char *)"copy",      (char *)"driver",      (char *)"encoding", 
        (char *)"files",      (char *)"fileoffset",      (char *)"filelength",      (char *)"fileheaders", 
        (char *)"flags",      (char *)"form",      (char *)"headers",      (char *)"host", 
        (char *)"id",      (char *)"isconnected",      (char *)"location",      (char *)"method", 
        (char *)"outputheaders",      (char *)"peeraddr",      (char *)"peerport",      (char *)"port", 
        (char *)"protocol",      (char *)"query",      (char *)"request",      (char *)"server", 
        (char *)"sock",      (char *)"start",      (char *)"status",      (char *)"url", 
        (char *)"urlc",      (char *)"urlencoding",      (char *)"urlv",      (char *)"version", 
        (char *)"write_encoded",      (char *)((void *)0)};
static int GetChan___0(Tcl_Interp *interp , char *id , Tcl_Channel *chanPtr ) 
{ Tcl_Channel chan ;
  int mode ;

  {
  chan = Tcl_GetChannel(interp, id, & mode);
  if ((unsigned int )chan == (unsigned int )((struct Tcl_Channel_ *)((void *)0))) {
    return (1);
  }
  if ((mode & 4) == 0) {
    Tcl_AppendResult(interp, "channel \"", id, "\" wasn\'t opened for writing", (char *)((void *)0));
    return (1);
  }
  (*chanPtr) = chan;
  return (0);
}
}
static int GetIndices___0(Tcl_Interp *interp , Conn *connPtr , Tcl_Obj **objv , int *offPtr ,
                          int *lenPtr ) 
{ int off ;
  int len ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  tmp = Tcl_GetIntFromObj(interp, (*(objv + 0)), & off);
  if (tmp != 0) {
    return (1);
  } else {
    tmp___0 = Tcl_GetIntFromObj(interp, (*(objv + 1)), & len);
    if (tmp___0 != 0) {
      return (1);
    }
  }
  if (off < 0) {
    tmp___1 = Tcl_GetString((*(objv + 0)));
    Tcl_AppendResult(interp, "invalid offset: ", tmp___1, (void *)0);
    return (1);
  } else {
    if (off > (connPtr->reqPtr)->length) {
      tmp___1 = Tcl_GetString((*(objv + 0)));
      Tcl_AppendResult(interp, "invalid offset: ", tmp___1, (void *)0);
      return (1);
    }
  }
  if (len < 0) {
    tmp___2 = Tcl_GetString((*(objv + 1)));
    Tcl_AppendResult(interp, "invalid length: ", tmp___2, (void *)0);
    return (1);
  } else {
    if (len > (connPtr->reqPtr)->length - off) {
      tmp___2 = Tcl_GetString((*(objv + 1)));
      Tcl_AppendResult(interp, "invalid length: ", tmp___2, (void *)0);
      return (1);
    }
  }
  (*offPtr) = off;
  (*lenPtr) = len;
  return (0);
}
}
static int ConnSend___0(Ns_Conn *conn , int nsend , Tcl_Channel chan , FILE *fp ,
                        int fd ) ;
static int ConnCopy___0(Ns_Conn *conn , size_t tocopy , Tcl_Channel chan , FILE *fp ,
                        int fd ) ;
static int ConnCopy___0(Ns_Conn *conn , size_t tocopy , Tcl_Channel chan , FILE *fp ,
                        int fd ) 
{ Conn *connPtr ;
  Request *reqPtr ;
  int nwrote ;
  int ncopy ;
  int tmp ;

  {
  connPtr = (Conn *)conn;
  reqPtr = connPtr->reqPtr;
  ncopy = (int )tocopy;
  if ((unsigned int )connPtr->sockPtr == (unsigned int )((void *)0)) {
    return (-1);
  } else {
    if (reqPtr->avail < ncopy) {
      return (-1);
    }
  }
  while (ncopy > 0) {
    if ((unsigned int )chan != (unsigned int )((void *)0)) {
      nwrote = Tcl_Write(chan, reqPtr->next, ncopy);
    } else {
      if ((unsigned int )fp != (unsigned int )((void *)0)) {
        nwrote = (int )fwrite((void const   * __restrict  )reqPtr->next, 1U, (unsigned int )ncopy,
                              (FILE * __restrict  )fp);
        tmp = ferror(fp);
        if (tmp) {
          nwrote = -1;
        }
      } else {
        nwrote = write(fd, (void const   *)reqPtr->next, (unsigned int )ncopy);
      }
    }
    if (nwrote < 0) {
      return (-1);
    }
    ncopy -= nwrote;
    reqPtr->next = reqPtr->next + nwrote;
    reqPtr->avail = reqPtr->avail - nwrote;
  }
  return (0);
}
}
static int ConnSend___0(Ns_Conn *conn , int nsend , Tcl_Channel chan , FILE *fp ,
                        int fd ) 
{ int toread ;
  int nread ;
  int status ;
  char buf[2048] ;
  int tmp ;

  {
  if (nsend == 0) {
    Ns_WriteConn(conn, (char *)((void *)0), 0);
  }
  status = 0;
  while (1) {
    if (status == 0) {
      if (! (nsend > 0)) {
        break;
      }
    } else {
      break;
    }
    toread = nsend;
    if ((unsigned int )toread > sizeof(buf)) {
      toread = (int )sizeof(buf);
    }
    if ((unsigned int )chan != (unsigned int )((void *)0)) {
      nread = Tcl_Read(chan, buf, toread);
    } else {
      if ((unsigned int )fp != (unsigned int )((void *)0)) {
        nread = (int )fread((void * __restrict  )(buf), 1U, (unsigned int )toread,
                            (FILE * __restrict  )fp);
        tmp = ferror(fp);
        if (tmp) {
          nread = -1;
        }
      } else {
        nread = read(fd, (void *)(buf), (unsigned int )toread);
      }
    }
    if (nread == -1) {
      status = -1;
    } else {
      if (nread == 0) {
        nsend = 0;
      } else {
        status = Ns_WriteConn(conn, buf, nread);
        if (status == 0) {
          nsend -= nread;
        }
      }
    }
  }
  return (status);
}
}
static char const   IP___0[64]  = 
  {      (char const   )58,      (char const   )50,      (char const   )42,      (char const   )34, 
        (char const   )26,      (char const   )18,      (char const   )10,      (char const   )2, 
        (char const   )60,      (char const   )52,      (char const   )44,      (char const   )36, 
        (char const   )28,      (char const   )20,      (char const   )12,      (char const   )4, 
        (char const   )62,      (char const   )54,      (char const   )46,      (char const   )38, 
        (char const   )30,      (char const   )22,      (char const   )14,      (char const   )6, 
        (char const   )64,      (char const   )56,      (char const   )48,      (char const   )40, 
        (char const   )32,      (char const   )24,      (char const   )16,      (char const   )8, 
        (char const   )57,      (char const   )49,      (char const   )41,      (char const   )33, 
        (char const   )25,      (char const   )17,      (char const   )9,      (char const   )1, 
        (char const   )59,      (char const   )51,      (char const   )43,      (char const   )35, 
        (char const   )27,      (char const   )19,      (char const   )11,      (char const   )3, 
        (char const   )61,      (char const   )53,      (char const   )45,      (char const   )37, 
        (char const   )29,      (char const   )21,      (char const   )13,      (char const   )5, 
        (char const   )63,      (char const   )55,      (char const   )47,      (char const   )39, 
        (char const   )31,      (char const   )23,      (char const   )15,      (char const   )7};
static char const   FP___0[64]  = 
  {      (char const   )40,      (char const   )8,      (char const   )48,      (char const   )16, 
        (char const   )56,      (char const   )24,      (char const   )64,      (char const   )32, 
        (char const   )39,      (char const   )7,      (char const   )47,      (char const   )15, 
        (char const   )55,      (char const   )23,      (char const   )63,      (char const   )31, 
        (char const   )38,      (char const   )6,      (char const   )46,      (char const   )14, 
        (char const   )54,      (char const   )22,      (char const   )62,      (char const   )30, 
        (char const   )37,      (char const   )5,      (char const   )45,      (char const   )13, 
        (char const   )53,      (char const   )21,      (char const   )61,      (char const   )29, 
        (char const   )36,      (char const   )4,      (char const   )44,      (char const   )12, 
        (char const   )52,      (char const   )20,      (char const   )60,      (char const   )28, 
        (char const   )35,      (char const   )3,      (char const   )43,      (char const   )11, 
        (char const   )51,      (char const   )19,      (char const   )59,      (char const   )27, 
        (char const   )34,      (char const   )2,      (char const   )42,      (char const   )10, 
        (char const   )50,      (char const   )18,      (char const   )58,      (char const   )26, 
        (char const   )33,      (char const   )1,      (char const   )41,      (char const   )9, 
        (char const   )49,      (char const   )17,      (char const   )57,      (char const   )25};
static char const   PC1_C___0[28]  = 
  {      (char const   )57,      (char const   )49,      (char const   )41,      (char const   )33, 
        (char const   )25,      (char const   )17,      (char const   )9,      (char const   )1, 
        (char const   )58,      (char const   )50,      (char const   )42,      (char const   )34, 
        (char const   )26,      (char const   )18,      (char const   )10,      (char const   )2, 
        (char const   )59,      (char const   )51,      (char const   )43,      (char const   )35, 
        (char const   )27,      (char const   )19,      (char const   )11,      (char const   )3, 
        (char const   )60,      (char const   )52,      (char const   )44,      (char const   )36};
static char const   PC1_D___0[28]  = 
  {      (char const   )63,      (char const   )55,      (char const   )47,      (char const   )39, 
        (char const   )31,      (char const   )23,      (char const   )15,      (char const   )7, 
        (char const   )62,      (char const   )54,      (char const   )46,      (char const   )38, 
        (char const   )30,      (char const   )22,      (char const   )14,      (char const   )6, 
        (char const   )61,      (char const   )53,      (char const   )45,      (char const   )37, 
        (char const   )29,      (char const   )21,      (char const   )13,      (char const   )5, 
        (char const   )28,      (char const   )20,      (char const   )12,      (char const   )4};
static char const   shifts___0[16]  = 
  {      (char const   )1,      (char const   )1,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )1,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )1};
static char const   PC2_C___0[24]  = 
  {      (char const   )14,      (char const   )17,      (char const   )11,      (char const   )24, 
        (char const   )1,      (char const   )5,      (char const   )3,      (char const   )28, 
        (char const   )15,      (char const   )6,      (char const   )21,      (char const   )10, 
        (char const   )23,      (char const   )19,      (char const   )12,      (char const   )4, 
        (char const   )26,      (char const   )8,      (char const   )16,      (char const   )7, 
        (char const   )27,      (char const   )20,      (char const   )13,      (char const   )2};
static char const   PC2_D___0[24]  = 
  {      (char const   )41,      (char const   )52,      (char const   )31,      (char const   )37, 
        (char const   )47,      (char const   )55,      (char const   )30,      (char const   )40, 
        (char const   )51,      (char const   )45,      (char const   )33,      (char const   )48, 
        (char const   )44,      (char const   )49,      (char const   )39,      (char const   )56, 
        (char const   )34,      (char const   )53,      (char const   )46,      (char const   )42, 
        (char const   )50,      (char const   )36,      (char const   )29,      (char const   )32};
static char const   e___0[48]  = 
  {      (char const   )32,      (char const   )1,      (char const   )2,      (char const   )3, 
        (char const   )4,      (char const   )5,      (char const   )4,      (char const   )5, 
        (char const   )6,      (char const   )7,      (char const   )8,      (char const   )9, 
        (char const   )8,      (char const   )9,      (char const   )10,      (char const   )11, 
        (char const   )12,      (char const   )13,      (char const   )12,      (char const   )13, 
        (char const   )14,      (char const   )15,      (char const   )16,      (char const   )17, 
        (char const   )16,      (char const   )17,      (char const   )18,      (char const   )19, 
        (char const   )20,      (char const   )21,      (char const   )20,      (char const   )21, 
        (char const   )22,      (char const   )23,      (char const   )24,      (char const   )25, 
        (char const   )24,      (char const   )25,      (char const   )26,      (char const   )27, 
        (char const   )28,      (char const   )29,      (char const   )28,      (char const   )29, 
        (char const   )30,      (char const   )31,      (char const   )32,      (char const   )1};
static void setkey_private___0(struct sched *sp , char const   *key___1 ) 
{ register int i ;
  register int j ;
  register int k ;
  int t ;

  {
  i = 0;
  while (i < 28) {
    sp->C[i] = (char )(*(key___1 + ((int const   )PC1_C___0[i] - 1)));
    sp->D[i] = (char )(*(key___1 + ((int const   )PC1_D___0[i] - 1)));
    i ++;
  }
  i = 0;
  while (i < 16) {
    k = 0;
    while (k < (int )shifts___0[i]) {
      t = (int )sp->C[0];
      j = 0;
      while (j < 27) {
        sp->C[j] = sp->C[j + 1];
        j ++;
      }
      sp->C[27] = (char )t;
      t = (int )sp->D[0];
      j = 0;
      while (j < 27) {
        sp->D[j] = sp->D[j + 1];
        j ++;
      }
      sp->D[27] = (char )t;
      k ++;
    }
    j = 0;
    while (j < 24) {
      sp->KS[i][j] = sp->C[(int const   )PC2_C___0[j] - 1];
      sp->KS[i][j + 24] = sp->D[((int const   )PC2_D___0[j] - 28) - 1];
      j ++;
    }
    i ++;
  }
  i = 0;
  while (i < 48) {
    sp->E[i] = (char )e___0[i];
    i ++;
  }
  return;
}
}
static char const   S___0[8][64]  = 
  { {        (char const   )14,        (char const   )4,        (char const   )13,        (char const   )1, 
            (char const   )2,        (char const   )15,        (char const   )11,        (char const   )8, 
            (char const   )3,        (char const   )10,        (char const   )6,        (char const   )12, 
            (char const   )5,        (char const   )9,        (char const   )0,        (char const   )7, 
            (char const   )0,        (char const   )15,        (char const   )7,        (char const   )4, 
            (char const   )14,        (char const   )2,        (char const   )13,        (char const   )1, 
            (char const   )10,        (char const   )6,        (char const   )12,        (char const   )11, 
            (char const   )9,        (char const   )5,        (char const   )3,        (char const   )8, 
            (char const   )4,        (char const   )1,        (char const   )14,        (char const   )8, 
            (char const   )13,        (char const   )6,        (char const   )2,        (char const   )11, 
            (char const   )15,        (char const   )12,        (char const   )9,        (char const   )7, 
            (char const   )3,        (char const   )10,        (char const   )5,        (char const   )0, 
            (char const   )15,        (char const   )12,        (char const   )8,        (char const   )2, 
            (char const   )4,        (char const   )9,        (char const   )1,        (char const   )7, 
            (char const   )5,        (char const   )11,        (char const   )3,        (char const   )14, 
            (char const   )10,        (char const   )0,        (char const   )6,        (char const   )13}, 
   {        (char const   )15,        (char const   )1,        (char const   )8,        (char const   )14, 
            (char const   )6,        (char const   )11,        (char const   )3,        (char const   )4, 
            (char const   )9,        (char const   )7,        (char const   )2,        (char const   )13, 
            (char const   )12,        (char const   )0,        (char const   )5,        (char const   )10, 
            (char const   )3,        (char const   )13,        (char const   )4,        (char const   )7, 
            (char const   )15,        (char const   )2,        (char const   )8,        (char const   )14, 
            (char const   )12,        (char const   )0,        (char const   )1,        (char const   )10, 
            (char const   )6,        (char const   )9,        (char const   )11,        (char const   )5, 
            (char const   )0,        (char const   )14,        (char const   )7,        (char const   )11, 
            (char const   )10,        (char const   )4,        (char const   )13,        (char const   )1, 
            (char const   )5,        (char const   )8,        (char const   )12,        (char const   )6, 
            (char const   )9,        (char const   )3,        (char const   )2,        (char const   )15, 
            (char const   )13,        (char const   )8,        (char const   )10,        (char const   )1, 
            (char const   )3,        (char const   )15,        (char const   )4,        (char const   )2, 
            (char const   )11,        (char const   )6,        (char const   )7,        (char const   )12, 
            (char const   )0,        (char const   )5,        (char const   )14,        (char const   )9}, 
   {        (char const   )10,        (char const   )0,        (char const   )9,        (char const   )14, 
            (char const   )6,        (char const   )3,        (char const   )15,        (char const   )5, 
            (char const   )1,        (char const   )13,        (char const   )12,        (char const   )7, 
            (char const   )11,        (char const   )4,        (char const   )2,        (char const   )8, 
            (char const   )13,        (char const   )7,        (char const   )0,        (char const   )9, 
            (char const   )3,        (char const   )4,        (char const   )6,        (char const   )10, 
            (char const   )2,        (char const   )8,        (char const   )5,        (char const   )14, 
            (char const   )12,        (char const   )11,        (char const   )15,        (char const   )1, 
            (char const   )13,        (char const   )6,        (char const   )4,        (char const   )9, 
            (char const   )8,        (char const   )15,        (char const   )3,        (char const   )0, 
            (char const   )11,        (char const   )1,        (char const   )2,        (char const   )12, 
            (char const   )5,        (char const   )10,        (char const   )14,        (char const   )7, 
            (char const   )1,        (char const   )10,        (char const   )13,        (char const   )0, 
            (char const   )6,        (char const   )9,        (char const   )8,        (char const   )7, 
            (char const   )4,        (char const   )15,        (char const   )14,        (char const   )3, 
            (char const   )11,        (char const   )5,        (char const   )2,        (char const   )12}, 
   {        (char const   )7,        (char const   )13,        (char const   )14,        (char const   )3, 
            (char const   )0,        (char const   )6,        (char const   )9,        (char const   )10, 
            (char const   )1,        (char const   )2,        (char const   )8,        (char const   )5, 
            (char const   )11,        (char const   )12,        (char const   )4,        (char const   )15, 
            (char const   )13,        (char const   )8,        (char const   )11,        (char const   )5, 
            (char const   )6,        (char const   )15,        (char const   )0,        (char const   )3, 
            (char const   )4,        (char const   )7,        (char const   )2,        (char const   )12, 
            (char const   )1,        (char const   )10,        (char const   )14,        (char const   )9, 
            (char const   )10,        (char const   )6,        (char const   )9,        (char const   )0, 
            (char const   )12,        (char const   )11,        (char const   )7,        (char const   )13, 
            (char const   )15,        (char const   )1,        (char const   )3,        (char const   )14, 
            (char const   )5,        (char const   )2,        (char const   )8,        (char const   )4, 
            (char const   )3,        (char const   )15,        (char const   )0,        (char const   )6, 
            (char const   )10,        (char const   )1,        (char const   )13,        (char const   )8, 
            (char const   )9,        (char const   )4,        (char const   )5,        (char const   )11, 
            (char const   )12,        (char const   )7,        (char const   )2,        (char const   )14}, 
   {        (char const   )2,        (char const   )12,        (char const   )4,        (char const   )1, 
            (char const   )7,        (char const   )10,        (char const   )11,        (char const   )6, 
            (char const   )8,        (char const   )5,        (char const   )3,        (char const   )15, 
            (char const   )13,        (char const   )0,        (char const   )14,        (char const   )9, 
            (char const   )14,        (char const   )11,        (char const   )2,        (char const   )12, 
            (char const   )4,        (char const   )7,        (char const   )13,        (char const   )1, 
            (char const   )5,        (char const   )0,        (char const   )15,        (char const   )10, 
            (char const   )3,        (char const   )9,        (char const   )8,        (char const   )6, 
            (char const   )4,        (char const   )2,        (char const   )1,        (char const   )11, 
            (char const   )10,        (char const   )13,        (char const   )7,        (char const   )8, 
            (char const   )15,        (char const   )9,        (char const   )12,        (char const   )5, 
            (char const   )6,        (char const   )3,        (char const   )0,        (char const   )14, 
            (char const   )11,        (char const   )8,        (char const   )12,        (char const   )7, 
            (char const   )1,        (char const   )14,        (char const   )2,        (char const   )13, 
            (char const   )6,        (char const   )15,        (char const   )0,        (char const   )9, 
            (char const   )10,        (char const   )4,        (char const   )5,        (char const   )3}, 
   {        (char const   )12,        (char const   )1,        (char const   )10,        (char const   )15, 
            (char const   )9,        (char const   )2,        (char const   )6,        (char const   )8, 
            (char const   )0,        (char const   )13,        (char const   )3,        (char const   )4, 
            (char const   )14,        (char const   )7,        (char const   )5,        (char const   )11, 
            (char const   )10,        (char const   )15,        (char const   )4,        (char const   )2, 
            (char const   )7,        (char const   )12,        (char const   )9,        (char const   )5, 
            (char const   )6,        (char const   )1,        (char const   )13,        (char const   )14, 
            (char const   )0,        (char const   )11,        (char const   )3,        (char const   )8, 
            (char const   )9,        (char const   )14,        (char const   )15,        (char const   )5, 
            (char const   )2,        (char const   )8,        (char const   )12,        (char const   )3, 
            (char const   )7,        (char const   )0,        (char const   )4,        (char const   )10, 
            (char const   )1,        (char const   )13,        (char const   )11,        (char const   )6, 
            (char const   )4,        (char const   )3,        (char const   )2,        (char const   )12, 
            (char const   )9,        (char const   )5,        (char const   )15,        (char const   )10, 
            (char const   )11,        (char const   )14,        (char const   )1,        (char const   )7, 
            (char const   )6,        (char const   )0,        (char const   )8,        (char const   )13}, 
   {        (char const   )4,        (char const   )11,        (char const   )2,        (char const   )14, 
            (char const   )15,        (char const   )0,        (char const   )8,        (char const   )13, 
            (char const   )3,        (char const   )12,        (char const   )9,        (char const   )7, 
            (char const   )5,        (char const   )10,        (char const   )6,        (char const   )1, 
            (char const   )13,        (char const   )0,        (char const   )11,        (char const   )7, 
            (char const   )4,        (char const   )9,        (char const   )1,        (char const   )10, 
            (char const   )14,        (char const   )3,        (char const   )5,        (char const   )12, 
            (char const   )2,        (char const   )15,        (char const   )8,        (char const   )6, 
            (char const   )1,        (char const   )4,        (char const   )11,        (char const   )13, 
            (char const   )12,        (char const   )3,        (char const   )7,        (char const   )14, 
            (char const   )10,        (char const   )15,        (char const   )6,        (char const   )8, 
            (char const   )0,        (char const   )5,        (char const   )9,        (char const   )2, 
            (char const   )6,        (char const   )11,        (char const   )13,        (char const   )8, 
            (char const   )1,        (char const   )4,        (char const   )10,        (char const   )7, 
            (char const   )9,        (char const   )5,        (char const   )0,        (char const   )15, 
            (char const   )14,        (char const   )2,        (char const   )3,        (char const   )12}, 
   {        (char const   )13,        (char const   )2,        (char const   )8,        (char const   )4, 
            (char const   )6,        (char const   )15,        (char const   )11,        (char const   )1, 
            (char const   )10,        (char const   )9,        (char const   )3,        (char const   )14, 
            (char const   )5,        (char const   )0,        (char const   )12,        (char const   )7, 
            (char const   )1,        (char const   )15,        (char const   )13,        (char const   )8, 
            (char const   )10,        (char const   )3,        (char const   )7,        (char const   )4, 
            (char const   )12,        (char const   )5,        (char const   )6,        (char const   )11, 
            (char const   )0,        (char const   )14,        (char const   )9,        (char const   )2, 
            (char const   )7,        (char const   )11,        (char const   )4,        (char const   )1, 
            (char const   )9,        (char const   )12,        (char const   )14,        (char const   )2, 
            (char const   )0,        (char const   )6,        (char const   )10,        (char const   )13, 
            (char const   )15,        (char const   )3,        (char const   )5,        (char const   )8, 
            (char const   )2,        (char const   )1,        (char const   )14,        (char const   )7, 
            (char const   )4,        (char const   )10,        (char const   )8,        (char const   )13, 
            (char const   )15,        (char const   )12,        (char const   )9,        (char const   )0, 
            (char const   )3,        (char const   )5,        (char const   )6,        (char const   )11}};
static char const   P___0[32]  = 
  {      (char const   )16,      (char const   )7,      (char const   )20,      (char const   )21, 
        (char const   )29,      (char const   )12,      (char const   )28,      (char const   )17, 
        (char const   )1,      (char const   )15,      (char const   )23,      (char const   )26, 
        (char const   )5,      (char const   )18,      (char const   )31,      (char const   )10, 
        (char const   )2,      (char const   )8,      (char const   )24,      (char const   )14, 
        (char const   )32,      (char const   )27,      (char const   )3,      (char const   )9, 
        (char const   )19,      (char const   )13,      (char const   )30,      (char const   )6, 
        (char const   )22,      (char const   )11,      (char const   )4,      (char const   )25};
static void encrypt_private___0(struct sched *sp , char *block , int edflag ) 
{ char L[64] ;
  char *R ;
  char tempL[32] ;
  char f[32] ;
  char preS[48] ;
  int i ;
  int ii ;
  register int t ;
  register int j ;
  register int k ;

  {
  R = L + 32;
  j = 0;
  while (j < 64) {
    L[j] = (*(block + ((int const   )IP___0[j] - 1)));
    j ++;
  }
  ii = 0;
  while (ii < 16) {
    if (edflag) {
      i = 15 - ii;
    } else {
      i = ii;
    }
    j = 0;
    while (j < 32) {
      tempL[j] = (*(R + j));
      j ++;
    }
    j = 0;
    while (j < 48) {
      preS[j] = (char )((int )(*(R + ((int )sp->E[j] - 1))) ^ (int )sp->KS[i][j]);
      j ++;
    }
    j = 0;
    while (j < 8) {
      t = 6 * j;
      k = (int )S___0[j][((((((int )preS[t] << 5) + ((int )preS[t + 1] << 3)) + ((int )preS[t +
                                                                                            2] <<
                                                                                 2)) +
                           ((int )preS[t + 3] << 1)) + (int )preS[t + 4]) + ((int )preS[t +
                                                                                        5] <<
                                                                             4)];
      t = 4 * j;
      f[t] = (char )((k >> 3) & 1);
      f[t + 1] = (char )((k >> 2) & 1);
      f[t + 2] = (char )((k >> 1) & 1);
      f[t + 3] = (char )(k & 1);
      j ++;
    }
    j = 0;
    while (j < 32) {
      (*(R + j)) = (char )((int )L[j] ^ (int )f[(int const   )P___0[j] - 1]);
      j ++;
    }
    j = 0;
    while (j < 32) {
      L[j] = tempL[j];
      j ++;
    }
    ii ++;
  }
  j = 0;
  while (j < 32) {
    t = (int )L[j];
    L[j] = (*(R + j));
    (*(R + j)) = (char )t;
    j ++;
  }
  j = 0;
  while (j < 64) {
    (*(block + j)) = L[(int const   )FP___0[j] - 1];
    j ++;
  }
  return;
}
}
static Ns_Cache *hostCache___0  ;
static Ns_Cache *addrCache___0  ;
static Ns_Mutex lock___18  ;
static int cachetimeout___0  ;
static int GetAddr___1(Tcl_DString *dsPtr , char *host ) ;
static int GetHost___0(Tcl_DString *dsPtr , char *addr ) ;
static int DnsGet___0(GetProc *getProc , Tcl_DString *dsPtr , Ns_Cache **cachePtr ,
                      char *key___1 , int all ) ;
static int DnsGet___0(GetProc *getProc , Tcl_DString *dsPtr , Ns_Cache **cachePtr ,
                      char *key___1 , int all ) 
{ int status ;
  int new ;
  int timeout ;
  Value *vPtr ;
  Ns_Entry *ePtr ;
  Ns_Cache *cache ;
  time_t now ;
  char *p ;
  unsigned short const   **tmp ;

  {
  status = 0;
  vPtr = (Value *)((void *)0);
  ePtr = (Ns_Entry *)((void *)0);
  cache = (Ns_Cache *)((void *)0);
  Ns_MutexLock(& lock___18);
  cache = (*cachePtr);
  timeout = cachetimeout___0;
  Ns_MutexUnlock(& lock___18);
  if ((unsigned int )cache == (unsigned int )((void *)0)) {
    status = ((*getProc))(dsPtr, key___1);
  } else {
    time(& now);
    Ns_CacheLock(cache);
    ePtr = Ns_CacheCreateEntry(cache, key___1, & new);
    if (! new) {
      while (1) {
        if ((unsigned int )ePtr != (unsigned int )((void *)0)) {
          vPtr = (Value *)Ns_CacheGetValue(ePtr);
          if (! ((unsigned int )vPtr == (unsigned int )((void *)0))) {
            break;
          }
        } else {
          break;
        }
        Ns_CacheWait(cache);
        ePtr = Ns_CacheFindEntry(cache, key___1);
      }
      if ((unsigned int )ePtr == (unsigned int )((void *)0)) {
        status = 0;
      } else {
        if (vPtr->expires < now) {
          Ns_CacheUnsetValue(ePtr);
          new = 1;
        } else {
          Tcl_DStringAppend(dsPtr, vPtr->value, -1);
          status = 1;
        }
      }
    }
    if (new) {
      Ns_CacheUnlock(cache);
      status = ((*getProc))(dsPtr, key___1);
      Ns_CacheLock(cache);
      ePtr = Ns_CacheCreateEntry(cache, key___1, & new);
      if (status != 1) {
        Ns_CacheFlushEntry(ePtr);
      } else {
        Ns_CacheUnsetValue(ePtr);
        vPtr = (Value *)ns_malloc(sizeof(Value ) + (unsigned int )dsPtr->length);
        vPtr->expires = now + (long )timeout;
        strcpy((char * __restrict  )(vPtr->value), (char const   * __restrict  )dsPtr->string);
        Ns_CacheSetValueSz(ePtr, (void *)vPtr, 1U);
      }
      Ns_CacheBroadcast(cache);
    }
    Ns_CacheUnlock(cache);
  }
  if (status == 1) {
    if ((unsigned int )getProc == (unsigned int )(& GetAddr___1)) {
      if (! all) {
        p = dsPtr->string;
        while (1) {
          if ((*p)) {
            tmp = __ctype_b_loc();
            if ((int const   )(*((*tmp) + (int )((unsigned char )(*p)))) & 8192) {
              break;
            }
          } else {
            break;
          }
          p ++;
        }
        Tcl_DStringSetLength(dsPtr, p - dsPtr->string);
      }
    }
  }
  return (status);
}
}
static int GetHost___0(Tcl_DString *dsPtr , char *addr ) 
{ struct sockaddr_in sa ;
  char buf[1025] ;
  int result ;
  int status ;
  char const   *tmp ;

  {
  status = 0;
  sa.sin_family = (unsigned short)2;
  sa.sin_addr.s_addr = inet_addr((char const   *)addr);
  result = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr  const  *)(& sa)),
                       sizeof(struct sockaddr_in ), (char * __restrict  )(buf), sizeof(buf),
                       (char * __restrict  )((void *)0), 0U, 8U);
  if (result != 0) {
    tmp = gai_strerror(result);
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"dns: getnameinfo failed: %s",
           tmp);
  } else {
    Tcl_DStringAppend(dsPtr, buf, -1);
    status = 1;
  }
  return (status);
}
}
static int GetAddr___1(Tcl_DString *dsPtr , char *host ) 
{ struct addrinfo hints ;
  struct addrinfo *res ;
  struct addrinfo *ptr ;
  int result ;
  int status ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_107___2 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  char const   *tmp ;
  char *tmp___0 ;

  {
  status = 0;
  if (sizeof(hints) <= 16U) {
    if (sizeof(hints) == 1U) {
      __s___1 = (void *)(& hints);
      (*((__uint8_t *)__s___1)) = (unsigned char)0;
    } else {
      __s___0 = (void *)(& hints);
      __u = (union __anonunion___u_107___2 *)__s___0;
      __c = (unsigned char)0;
      switch ((int )sizeof(hints)) {
      case 15: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___2 *)((void *)__u + 4);
      case 11: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___2 *)((void *)__u + 4);
      case 7: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___2 *)((void *)__u + 4);
      case 3: 
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
      __u = (union __anonunion___u_107___2 *)((void *)__u + 2);
      __u->__uc = __c;
      break;
      case 14: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___2 *)((void *)__u + 4);
      case 10: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___2 *)((void *)__u + 4);
      case 6: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___2 *)((void *)__u + 4);
      case 2: 
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
      break;
      case 13: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___2 *)((void *)__u + 4);
      case 9: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___2 *)((void *)__u + 4);
      case 5: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___2 *)((void *)__u + 4);
      case 1: 
      __u->__uc = __c;
      break;
      case 16: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___2 *)((void *)__u + 4);
      case 12: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___2 *)((void *)__u + 4);
      case 8: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      __u = (union __anonunion___u_107___2 *)((void *)__u + 4);
      case 4: 
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case 0: ;
      break;
      }
    }
  } else {
    __s = (void *)(& hints);
    __builtin_memset(__s, '\000', (int )sizeof(hints));
  }
  hints.ai_family = 2;
  hints.ai_socktype = 1;
  result = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )((void *)0),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& res));
  if (result != 0) {
    tmp = gai_strerror(result);
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"dns: getaddrinfo failed for %s: %s",
           host, tmp);
  } else {
    ptr = res;
    while ((unsigned int )ptr != (unsigned int )((void *)0)) {
      tmp___0 = ns_inet_ntoa(((struct sockaddr_in *)ptr->ai_addr)->sin_addr);
      Tcl_DStringAppendElement(dsPtr, tmp___0);
      ptr = ptr->ai_next;
    }
    freeaddrinfo(res);
    status = 1;
  }
  return (status);
}
}
static void DriverThread___0(void *ignored ) ;
static Sock *SockAccept___0(Driver *drvPtr ) ;
static void SockRelease___0(Sock *sockPtr , ReleaseReasons reason ) ;
static void SockTrigger___0(void) ;
static Driver *firstDrvPtr___0  ;
static Sock *firstClosePtr___0  ;
static int SockRead___0(Sock *sockPtr ) ;
static void SockPoll___0(Sock *sockPtr , Ns_Time *timeoutPtr ) ;
static void SockTimeout___0(Sock *sockPtr , Ns_Time *nowPtr , int timeout ) ;
static int SetServer___0(Sock *sockPtr ) ;
static Request *firstReqPtr___0  ;
static Ns_Mutex reqLock___0  ;
static Sock *firstSockPtr___0  ;
static int shutdownPending___4  ;
static int stopped___0  ;
static int nactive___0  ;
static Ns_Thread driverThread___0  ;
static int trigPipe___1[2]  ;
static Ns_Mutex lock___19  ;
static Ns_Cond cond___5  ;
static unsigned int nfds___0  ;
static unsigned int maxfds___0  ;
static struct pollfd *pfds___0  ;
static Tcl_HashTable hosts___0  ;
static ServerMap *defMapPtr___0  ;
static void DriverThread___0(void *ignored ) 
{ char c ;
  int n ;
  int stopping ;
  int pollto ;
  Sock *sockPtr ;
  Sock *closePtr ;
  Sock *nextPtr ;
  Sock *waitPtr ;
  Sock *readPtr ;
  Driver *activeDrvPtr ;
  Driver *drvPtr ;
  Driver *nextDrvPtr ;
  Driver *idleDrvPtr ;
  Driver *acceptDrvPtr ;
  char drain[1024] ;
  Ns_Time timeout ;
  Ns_Time now ;
  Ns_Time diff ;
  unsigned int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  ssize_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  Ns_ThreadSetName((char *)"-driver-");
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"starting");
  activeDrvPtr = (Driver *)((void *)0);
  drvPtr = firstDrvPtr___0;
  firstDrvPtr___0 = (Driver *)((void *)0);
  while ((unsigned int )drvPtr != (unsigned int )((void *)0)) {
    nextDrvPtr = drvPtr->nextPtr;
    if (drvPtr->sock != -1) {
      drvPtr->nextPtr = activeDrvPtr;
      activeDrvPtr = drvPtr;
    } else {
      drvPtr->nextPtr = firstDrvPtr___0;
      firstDrvPtr___0 = drvPtr;
    }
    drvPtr = nextDrvPtr;
  }
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"driver: accepting connections");
  readPtr = (Sock *)((void *)0);
  waitPtr = readPtr;
  closePtr = waitPtr;
  Ns_GetTime(& now);
  stopping = 0;
  maxfds___0 += 100U;
  pfds___0 = (struct pollfd *)ns_malloc(sizeof(struct pollfd ) * maxfds___0);
  (pfds___0 + 0)->fd = trigPipe___1[0];
  (pfds___0 + 0)->events = (short)1;
  while (1) {
    if (! (! stopping)) {
      if (! nactive___0) {
        break;
      }
    }
    nfds___0 = 1U;
    if ((unsigned int )waitPtr == (unsigned int )((void *)0)) {
      drvPtr = activeDrvPtr;
      while ((unsigned int )drvPtr != (unsigned int )((void *)0)) {
        (pfds___0 + nfds___0)->fd = drvPtr->sock;
        (pfds___0 + nfds___0)->events = (short)1;
        tmp = nfds___0;
        nfds___0 ++;
        drvPtr->pidx = (int )tmp;
        drvPtr = drvPtr->nextPtr;
      }
    }
    if ((unsigned int )readPtr == (unsigned int )((void *)0)) {
      if ((unsigned int )closePtr == (unsigned int )((void *)0)) {
        pollto = -1;
      } else {
        goto _L;
      }
    } else {
      _L: 
      timeout.sec = 2147483647L;
      timeout.usec = 2147483647L;
      sockPtr = readPtr;
      while ((unsigned int )sockPtr != (unsigned int )((void *)0)) {
        SockPoll___0(sockPtr, & timeout);
        sockPtr = sockPtr->nextPtr;
      }
      sockPtr = closePtr;
      while ((unsigned int )sockPtr != (unsigned int )((void *)0)) {
        SockPoll___0(sockPtr, & timeout);
        sockPtr = sockPtr->nextPtr;
      }
      tmp___0 = Ns_DiffTime(& timeout, & now, & diff);
      if (tmp___0 > 0) {
        pollto = (int )(diff.sec * 1000L + diff.usec / 1000L);
      } else {
        pollto = 0;
      }
    }
    (pfds___0 + 0)->revents = (short)0;
    while (1) {
      n = poll(pfds___0, (unsigned long )nfds___0, pollto);
      if (n < 0) {
        tmp___1 = __errno_location();
        if (! ((*tmp___1) == 4)) {
          break;
        }
      } else {
        break;
      }
    }
    if (n < 0) {
      tmp___2 = __errno_location();
      tmp___3 = strerror((*tmp___2));
      Ns_Fatal((char *)"driver: poll() failed: %s", tmp___3);
    }
    if ((int )(pfds___0 + 0)->revents & 1) {
      tmp___6 = recv(trigPipe___1[0], (void *)(& c), 1U, 0);
      if (tmp___6 != 1) {
        tmp___4 = __errno_location();
        tmp___5 = strerror((*tmp___4));
        Ns_Fatal((char *)"driver: trigger recv() failed: %s", tmp___5);
      }
    }
    Ns_GetTime(& now);
    if ((unsigned int )closePtr != (unsigned int )((void *)0)) {
      sockPtr = closePtr;
      closePtr = (Sock *)((void *)0);
      while ((unsigned int )sockPtr != (unsigned int )((void *)0)) {
        nextPtr = sockPtr->nextPtr;
        if ((int )(pfds___0 + sockPtr->pidx)->revents & 1) {
          n = recv(sockPtr->sock, (void *)(drain), sizeof(drain), 0);
          if (n <= 0) {
            sockPtr->timeout = now;
          }
        }
        tmp___7 = Ns_DiffTime(& sockPtr->timeout, & now, & diff);
        if (tmp___7 <= 0) {
          SockRelease___0(sockPtr, (enum __anonenum_ReleaseReasons_107 )0);
        } else {
          sockPtr->nextPtr = closePtr;
          closePtr = sockPtr;
        }
        sockPtr = nextPtr;
      }
    }
    sockPtr = readPtr;
    readPtr = (Sock *)((void *)0);
    while ((unsigned int )sockPtr != (unsigned int )((void *)0)) {
      nextPtr = sockPtr->nextPtr;
      if (! ((int )(pfds___0 + sockPtr->pidx)->revents & 1)) {
        tmp___8 = Ns_DiffTime(& sockPtr->timeout, & now, & diff);
        if (tmp___8 <= 0) {
          SockRelease___0(sockPtr, (enum __anonenum_ReleaseReasons_107 )1);
        } else {
          sockPtr->nextPtr = readPtr;
          readPtr = sockPtr;
        }
      } else {
        sockPtr->keep = 0;
        if ((sockPtr->drvPtr)->opts & 1) {
          n = SockRead___0(sockPtr);
        } else {
          n = 0;
        }
        switch (n) {
        case 1: 
        SockTimeout___0(sockPtr, & now, (sockPtr->drvPtr)->recvwait);
        sockPtr->nextPtr = readPtr;
        readPtr = sockPtr;
        break;
        case 0: 
        tmp___9 = SetServer___0(sockPtr);
        if (tmp___9) {
          sockPtr->nextPtr = waitPtr;
          waitPtr = sockPtr;
        } else {
          SockRelease___0(sockPtr, (enum __anonenum_ReleaseReasons_107 )2);
        }
        break;
        default: 
        SockRelease___0(sockPtr, (enum __anonenum_ReleaseReasons_107 )3);
        break;
        }
      }
      sockPtr = nextPtr;
    }
    if ((unsigned int )waitPtr != (unsigned int )((void *)0)) {
      sockPtr = (Sock *)((void *)0);
      while (1) {
        nextPtr = waitPtr;
        if (! ((unsigned int )nextPtr != (unsigned int )((void *)0))) {
          break;
        }
        waitPtr = nextPtr->nextPtr;
        nextPtr->nextPtr = sockPtr;
        sockPtr = nextPtr;
      }
      while ((unsigned int )sockPtr != (unsigned int )((void *)0)) {
        nextPtr = sockPtr->nextPtr;
        if ((unsigned int )waitPtr != (unsigned int )((void *)0)) {
          sockPtr->nextPtr = waitPtr;
          waitPtr = sockPtr;
        } else {
          tmp___10 = NsQueueConn(sockPtr, & now);
          if (! tmp___10) {
            sockPtr->nextPtr = waitPtr;
            waitPtr = sockPtr;
          }
        }
        sockPtr = nextPtr;
      }
    }
    if ((unsigned int )waitPtr == (unsigned int )((void *)0)) {
      drvPtr = activeDrvPtr;
      acceptDrvPtr = (Driver *)((void *)0);
      idleDrvPtr = acceptDrvPtr;
      activeDrvPtr = idleDrvPtr;
      while ((unsigned int )drvPtr != (unsigned int )((void *)0)) {
        nextDrvPtr = drvPtr->nextPtr;
        if ((unsigned int )waitPtr != (unsigned int )((void *)0)) {
          drvPtr->nextPtr = idleDrvPtr;
          idleDrvPtr = drvPtr;
        } else {
          if (! ((int )(pfds___0 + drvPtr->pidx)->revents & 1)) {
            drvPtr->nextPtr = idleDrvPtr;
            idleDrvPtr = drvPtr;
          } else {
            sockPtr = SockAccept___0(drvPtr);
            if ((unsigned int )sockPtr == (unsigned int )((void *)0)) {
              drvPtr->nextPtr = idleDrvPtr;
              idleDrvPtr = drvPtr;
            } else {
              drvPtr->nextPtr = acceptDrvPtr;
              acceptDrvPtr = drvPtr;
              SockTimeout___0(sockPtr, & now, (sockPtr->drvPtr)->recvwait);
              sockPtr->nextPtr = readPtr;
              readPtr = sockPtr;
            }
          }
        }
        drvPtr = nextDrvPtr;
      }
      while (1) {
        drvPtr = acceptDrvPtr;
        if (! ((unsigned int )drvPtr != (unsigned int )((void *)0))) {
          break;
        }
        acceptDrvPtr = drvPtr->nextPtr;
        drvPtr->nextPtr = activeDrvPtr;
        activeDrvPtr = drvPtr;
      }
      while (1) {
        drvPtr = idleDrvPtr;
        if (! ((unsigned int )drvPtr != (unsigned int )((void *)0))) {
          break;
        }
        idleDrvPtr = drvPtr->nextPtr;
        drvPtr->nextPtr = activeDrvPtr;
        activeDrvPtr = drvPtr;
      }
    }
    Ns_MutexLock(& lock___19);
    sockPtr = firstClosePtr___0;
    firstClosePtr___0 = (Sock *)((void *)0);
    stopping = shutdownPending___4;
    Ns_MutexUnlock(& lock___19);
    while ((unsigned int )sockPtr != (unsigned int )((void *)0)) {
      nextPtr = sockPtr->nextPtr;
      if (sockPtr->keep) {
        SockTimeout___0(sockPtr, & now, (sockPtr->drvPtr)->keepwait);
        sockPtr->nextPtr = readPtr;
        readPtr = sockPtr;
      } else {
        tmp___11 = shutdown(sockPtr->sock, 1);
        if (tmp___11 != 0) {
          SockRelease___0(sockPtr, (enum __anonenum_ReleaseReasons_107 )4);
        } else {
          SockTimeout___0(sockPtr, & now, (sockPtr->drvPtr)->closewait);
          sockPtr->nextPtr = closePtr;
          closePtr = sockPtr;
        }
      }
      sockPtr = nextPtr;
    }
    if (stopping) {
      while (1) {
        drvPtr = activeDrvPtr;
        if (! ((unsigned int )drvPtr != (unsigned int )((void *)0))) {
          break;
        }
        activeDrvPtr = drvPtr->nextPtr;
        close(drvPtr->sock);
        drvPtr->sock = -1;
        drvPtr->nextPtr = firstDrvPtr___0;
        firstDrvPtr___0 = drvPtr;
      }
    }
  }
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"exiting");
  Ns_MutexLock(& lock___19);
  stopped___0 = 1;
  Ns_CondBroadcast(& cond___5);
  Ns_MutexUnlock(& lock___19);
  return;
}
}
static int SetServer___0(Sock *sockPtr ) 
{ ServerMap *mapPtr ;
  Tcl_HashEntry *hPtr ;
  char *host ;
  int status ;

  {
  mapPtr = (ServerMap *)((void *)0);
  status = 1;
  sockPtr->servPtr = (sockPtr->drvPtr)->servPtr;
  sockPtr->location = (sockPtr->drvPtr)->location;
  if (sockPtr->reqPtr) {
    host = Ns_SetIGet((sockPtr->reqPtr)->headers, (char *)"Host");
    if (! host) {
      if (((sockPtr->reqPtr)->request)->version >= 1.1) {
        status = 0;
      }
    }
  }
  if ((unsigned int )sockPtr->servPtr == (unsigned int )((void *)0)) {
    if (host) {
      hPtr = ((*(hosts___0.findProc)))(& hosts___0, host);
      if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
        mapPtr = (ServerMap *)hPtr->clientData;
      }
    }
    if (! mapPtr) {
      mapPtr = defMapPtr___0;
    }
    if (mapPtr) {
      sockPtr->servPtr = mapPtr->servPtr;
      sockPtr->location = mapPtr->location;
    }
    if ((unsigned int )sockPtr->servPtr == (unsigned int )((void *)0)) {
      status = 0;
    }
  }
  if (! status) {
    if (sockPtr->reqPtr) {
      ns_free((void *)((sockPtr->reqPtr)->request)->method);
      ((sockPtr->reqPtr)->request)->method = ns_strdup("BAD");
    }
  }
  return (1);
}
}
static void SockPoll___0(Sock *sockPtr , Ns_Time *timeoutPtr ) 
{ unsigned int tmp ;
  int tmp___0 ;

  {
  if (nfds___0 >= maxfds___0) {
    maxfds___0 += 100U;
    pfds___0 = (struct pollfd *)ns_realloc((void *)pfds___0, maxfds___0 * sizeof(struct pollfd ));
  }
  (pfds___0 + nfds___0)->fd = sockPtr->sock;
  (pfds___0 + nfds___0)->events = (short)1;
  (pfds___0 + nfds___0)->revents = (short)0;
  tmp = nfds___0;
  nfds___0 ++;
  sockPtr->pidx = (int )tmp;
  tmp___0 = Ns_DiffTime(& sockPtr->timeout, timeoutPtr, (Ns_Time *)((void *)0));
  if (tmp___0 < 0) {
    (*timeoutPtr) = sockPtr->timeout;
  }
  return;
}
}
static void SockTimeout___0(Sock *sockPtr , Ns_Time *nowPtr , int timeout ) 
{ 

  {
  sockPtr->timeout = (*nowPtr);
  Ns_IncrTime(& sockPtr->timeout, (long )timeout, 0L);
  return;
}
}
static Sock *SockAccept___0(Driver *drvPtr ) 
{ Sock *sockPtr ;
  int slen ;

  {
  sockPtr = firstSockPtr___0;
  if ((unsigned int )sockPtr != (unsigned int )((void *)0)) {
    firstSockPtr___0 = sockPtr->nextPtr;
  } else {
    sockPtr = (Sock *)ns_malloc(sizeof(Sock ));
    sockPtr->reqPtr = (Request *)((void *)0);
  }
  slen = (int )sizeof(struct sockaddr_in );
  sockPtr->drvPtr = drvPtr;
  sockPtr->keep = 0;
  sockPtr->arg = (void *)0;
  sockPtr->sock = Ns_SockAccept(drvPtr->sock, (struct sockaddr *)(& sockPtr->sa),
                                & slen);
  if (sockPtr->sock == -1) {
    sockPtr->nextPtr = firstSockPtr___0;
    firstSockPtr___0 = sockPtr;
    return ((Sock *)((void *)0));
  }
  Ns_SockSetNonBlocking(sockPtr->sock);
  if (drvPtr->sndbuf > 0) {
    setsockopt(sockPtr->sock, 1, 7, (void const   *)((char *)(& drvPtr->sndbuf)),
               sizeof(drvPtr->sndbuf));
  }
  if (drvPtr->rcvbuf > 0) {
    setsockopt(sockPtr->sock, 1, 8, (void const   *)((char *)(& drvPtr->rcvbuf)),
               sizeof(drvPtr->rcvbuf));
  }
  nactive___0 ++;
  return (sockPtr);
}
}
static void SockRelease___0(Sock *sockPtr , ReleaseReasons reason ) 
{ char *errMsg ;
  register unsigned short __v ;
  register unsigned short __x ;
  char *tmp ;

  {
  errMsg = (char *)((void *)0);
  switch ((int )reason) {
  case 0: ;
  break;
  case 1: ;
  if (! sockPtr->keep) {
    if ((sockPtr->drvPtr)->loggingFlags & 1U) {
      errMsg = (char *)"Timeout during read";
    }
  }
  break;
  case 2: ;
  if ((sockPtr->drvPtr)->loggingFlags & 2U) {
    errMsg = (char *)"No Server found for request";
  }
  break;
  case 3: ;
  if ((sockPtr->drvPtr)->loggingFlags & 4U) {
    errMsg = (char *)"Unable to read request";
  }
  break;
  case 4: ;
  if ((sockPtr->drvPtr)->loggingFlags & 8U) {
    errMsg = (char *)"Unable to shutdown socket";
  }
  break;
  }
  if ((unsigned int )errMsg != (unsigned int )((void *)0)) {
    __x = sockPtr->sa.sin_port;
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
    tmp = ns_inet_ntoa(sockPtr->sa.sin_addr);
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"Releasing Socket; %s, Peer =  %s:%d",
           errMsg, tmp, __v);
  }
  nactive___0 --;
  close(sockPtr->sock);
  sockPtr->sock = -1;
  if ((unsigned int )sockPtr->reqPtr != (unsigned int )((void *)0)) {
    NsFreeRequest(sockPtr->reqPtr);
    sockPtr->reqPtr = (Request *)((void *)0);
  }
  sockPtr->nextPtr = firstSockPtr___0;
  firstSockPtr___0 = sockPtr;
  return;
}
}
static void SockTrigger___0(void) 
{ int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
  tmp___1 = send(trigPipe___1[1], (void const   *)"", 1U, 0);
  if (tmp___1 != 1) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Ns_Fatal((char *)"driver: trigger send() failed: %s", tmp___0);
  }
  return;
}
}
static int SockRead___0(Sock *sockPtr ) 
{ Ns_Sock *sock ;
  struct iovec buf ;
  Request *reqPtr ;
  Tcl_DString *bufPtr ;
  char *s ;
  char *e___1 ;
  char save ;
  int cnt ;
  int len ;
  int nread ;
  int n ;
  register unsigned short __v ;
  register unsigned short __x ;
  char *tmp ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  sock = (Ns_Sock *)sockPtr;
  reqPtr = sockPtr->reqPtr;
  if ((unsigned int )reqPtr == (unsigned int )((void *)0)) {
    Ns_MutexLock(& reqLock___0);
    reqPtr = firstReqPtr___0;
    if ((unsigned int )reqPtr != (unsigned int )((void *)0)) {
      firstReqPtr___0 = reqPtr->nextPtr;
    }
    Ns_MutexUnlock(& reqLock___0);
    if ((unsigned int )reqPtr == (unsigned int )((void *)0)) {
      reqPtr = (Request *)ns_malloc(sizeof(Request ));
      Tcl_DStringInit(& reqPtr->buffer);
      reqPtr->headers = Ns_SetCreate((char *)((void *)0));
      reqPtr->request = (Ns_Request *)((void *)0);
      reqPtr->content = (char *)((void *)0);
      reqPtr->next = reqPtr->content;
      reqPtr->avail = 0;
      reqPtr->length = reqPtr->avail;
      reqPtr->roff = 0;
      reqPtr->woff = reqPtr->roff;
      reqPtr->coff = reqPtr->woff;
      reqPtr->leadblanks = 0;
    }
    sockPtr->reqPtr = reqPtr;
    __x = sockPtr->sa.sin_port;
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
    reqPtr->port = (int )__v;
    tmp = ns_inet_ntoa(sockPtr->sa.sin_addr);
    strcpy((char * __restrict  )(reqPtr->peer), (char const   * __restrict  )tmp);
  }
  bufPtr = & reqPtr->buffer;
  if (reqPtr->length == 0) {
    nread = (sockPtr->drvPtr)->bufsize;
  } else {
    nread = reqPtr->length - reqPtr->avail;
  }
  len = bufPtr->length;
  n = len + nread;
  if (n > (sockPtr->drvPtr)->maxinput) {
    n = (sockPtr->drvPtr)->maxinput;
    nread = n - len;
    if (nread == 0) {
      return (-1);
    }
  }
  Tcl_DStringSetLength(bufPtr, len + nread);
  buf.iov_base = (void *)(bufPtr->string + reqPtr->woff);
  buf.iov_len = (unsigned int )nread;
  n = ((*((sockPtr->drvPtr)->proc)))((enum __anonenum_Ns_DriverCmd_69 )0, sock, & buf,
                                     1);
  if (n <= 0) {
    return (-1);
  }
  Tcl_DStringSetLength(bufPtr, len + n);
  reqPtr->woff = reqPtr->woff + n;
  reqPtr->avail = reqPtr->avail + n;
  while (reqPtr->coff == 0) {
    s = bufPtr->string + reqPtr->roff;
    tmp___1 = strchr((char const   *)s, '\n');
    e___1 = tmp___1;
    if ((unsigned int )e___1 == (unsigned int )((void *)0)) {
      return (1);
    }
    cnt = (e___1 - s) + 1;
    reqPtr->roff = reqPtr->roff + cnt;
    reqPtr->avail = reqPtr->avail - cnt;
    if ((unsigned int )e___1 > (unsigned int )s) {
      if ((int )(*(e___1 + -1)) == 13) {
        e___1 --;
      }
    }
    if ((unsigned int )e___1 == (unsigned int )s) {
      if (bufPtr->length == 0) {
        reqPtr->leadblanks = reqPtr->leadblanks + 1;
        if (reqPtr->leadblanks > 2) {
          return (-1);
        }
        reqPtr->roff = 0;
        reqPtr->woff = reqPtr->roff;
        Tcl_DStringSetLength(bufPtr, 0);
        return (1);
      }
      reqPtr->coff = reqPtr->roff;
      s = Ns_SetIGet(reqPtr->headers, (char *)"content-length");
      if ((unsigned int )s != (unsigned int )((void *)0)) {
        reqPtr->length = atoi__extinline((char const   *)s);
        if (reqPtr->length < 0) {
          if (reqPtr->length > ((sockPtr->drvPtr)->servPtr)->limits.maxpost) {
            return (-1);
          }
        }
      }
    } else {
      save = (*e___1);
      (*e___1) = (char )'\000';
      if ((unsigned int )reqPtr->request == (unsigned int )((void *)0)) {
        reqPtr->request = Ns_ParseRequest(s);
        if ((unsigned int )reqPtr->request == (unsigned int )((void *)0)) {
          return (-1);
        }
      } else {
        tmp___2 = Ns_ParseHeader(reqPtr->headers, s, (enum __anonenum_Ns_HeaderCaseDisposition_68 )0);
        if (tmp___2 != 0) {
          return (-1);
        }
      }
      (*e___1) = save;
      if ((reqPtr->request)->version <= 0.0) {
        reqPtr->coff = reqPtr->roff;
      }
    }
  }
  if (reqPtr->coff > 0) {
    if (reqPtr->length <= reqPtr->avail) {
      reqPtr->content = bufPtr->string + reqPtr->coff;
      reqPtr->next = reqPtr->content;
      reqPtr->avail = reqPtr->length;
      if (reqPtr->length > 0) {
        (*(reqPtr->content + reqPtr->length)) = (char )'\000';
      }
      if (reqPtr->request) {
        tmp___3 = 0;
      } else {
        tmp___3 = -1;
      }
      return (tmp___3);
    }
  }
  return (1);
}
}
static void AddExtension___0(char *ext , char *name ) ;
static void AddCharset___0(char *charset , char *name ) ;
static Tcl_Encoding GetCharsetEncoding___0(char *charset , int len ) ;
static char *RebuildCharsetList___0(void) ;
static int GetDefaultHackContentTypeP___0(void) ;
static Tcl_Encoding GetDefaultCharset___0(void) ;
static Tcl_Encoding GetDefaultEncoding___0(void) ;
static Tcl_HashTable encodings___0  ;
static Tcl_HashTable charsets___0  ;
static Tcl_HashTable extensions___0  ;
static Ns_Mutex lock___20  ;
static Ns_Cond cond___6  ;
static char *charsetList___0  =    (char *)((void *)0);
static struct __anonstruct_builtinExt_107___0 builtinExt___0[5]  = {      {(char *)".txt", (char *)"ascii"}, 
        {(char *)".htm", (char *)"iso8859-1"}, 
        {(char *)".html", (char *)"iso8859-1"}, 
        {(char *)".adp", (char *)"iso8859-1"}, 
        {(char *)((void *)0), (char *)((void *)0)}};
static struct __anonstruct_builtinChar_108___0 builtinChar___0[65]  = 
  {      {(char *)"iso-2022-jp", (char *)"iso2022-jp"}, 
        {(char *)"iso-2022-kr", (char *)"iso2022-kr"}, 
        {(char *)"iso-8859-1", (char *)"iso8859-1"}, 
        {(char *)"iso-8859-2", (char *)"iso8859-2"}, 
        {(char *)"iso-8859-3", (char *)"iso8859-3"}, 
        {(char *)"iso-8859-4", (char *)"iso8859-4"}, 
        {(char *)"iso-8859-5", (char *)"iso8859-5"}, 
        {(char *)"iso-8859-6", (char *)"iso8859-6"}, 
        {(char *)"iso-8859-7", (char *)"iso8859-7"}, 
        {(char *)"iso-8859-8", (char *)"iso8859-8"}, 
        {(char *)"iso-8859-9", (char *)"iso8859-9"}, 
        {(char *)"korean", (char *)"ksc5601"}, 
        {(char *)"ksc_5601", (char *)"ksc5601"}, 
        {(char *)"mac", (char *)"macRoman"}, 
        {(char *)"mac-centeuro", (char *)"macCentEuro"}, 
        {(char *)"mac-centraleupore", (char *)"macCentEuro"}, 
        {(char *)"mac-croatian", (char *)"macCroatian"}, 
        {(char *)"mac-cyrillic", (char *)"macCyrillic"}, 
        {(char *)"mac-greek", (char *)"macGreek"}, 
        {(char *)"mac-iceland", (char *)"macIceland"}, 
        {(char *)"mac-japan", (char *)"macJapan"}, 
        {(char *)"mac-roman", (char *)"macRoman"}, 
        {(char *)"mac-romania", (char *)"macRomania"}, 
        {(char *)"mac-thai", (char *)"macThai"}, 
        {(char *)"mac-turkish", (char *)"macTurkish"}, 
        {(char *)"mac-ukraine", (char *)"macUkraine"}, 
        {(char *)"maccenteuro", (char *)"macCentEuro"}, 
        {(char *)"maccentraleupore", (char *)"macCentEuro"}, 
        {(char *)"maccroatian", (char *)"macCroatian"}, 
        {(char *)"maccyrillic", (char *)"macCyrillic"}, 
        {(char *)"macgreek", (char *)"macGreek"}, 
        {(char *)"maciceland", (char *)"macIceland"}, 
        {(char *)"macintosh", (char *)"macRoman"}, 
        {(char *)"macjapan", (char *)"macJapan"}, 
        {(char *)"macroman", (char *)"macRoman"}, 
        {(char *)"macromania", (char *)"macRomania"}, 
        {(char *)"macthai", (char *)"macThai"}, 
        {(char *)"macturkish", (char *)"macTurkish"}, 
        {(char *)"macukraine", (char *)"macUkraine"}, 
        {(char *)"shift_jis", (char *)"shiftjis"}, 
        {(char *)"us-ascii", (char *)"ascii"}, 
        {(char *)"windows-1250", (char *)"cp1250"}, 
        {(char *)"windows-1251", (char *)"cp1251"}, 
        {(char *)"windows-1252", (char *)"cp1252"}, 
        {(char *)"windows-1253", (char *)"cp1253"}, 
        {(char *)"windows-1254", (char *)"cp1254"}, 
        {(char *)"windows-1255", (char *)"cp1255"}, 
        {(char *)"windows-1256", (char *)"cp1256"}, 
        {(char *)"windows-1257", (char *)"cp1257"}, 
        {(char *)"windows-1258", (char *)"cp1258"}, 
        {(char *)"x-mac", (char *)"macRoman"}, 
        {(char *)"x-mac-centeuro", (char *)"macCentEuro"}, 
        {(char *)"x-mac-centraleupore", (char *)"macCentEuro"}, 
        {(char *)"x-mac-croatian", (char *)"macCroatian"}, 
        {(char *)"x-mac-cyrillic", (char *)"macCyrillic"}, 
        {(char *)"x-mac-greek", (char *)"macGreek"}, 
        {(char *)"x-mac-iceland", (char *)"macIceland"}, 
        {(char *)"x-mac-japan", (char *)"macJapan"}, 
        {(char *)"x-mac-roman", (char *)"macRoman"}, 
        {(char *)"x-mac-romania", (char *)"macRomania"}, 
        {(char *)"x-mac-thai", (char *)"macThai"}, 
        {(char *)"x-mac-turkish", (char *)"macTurkish"}, 
        {(char *)"x-mac-ukraine", (char *)"macUkraine"}, 
        {(char *)"x-macintosh", (char *)"macRoman"}, 
        {(char *)((void *)0), (char *)((void *)0)}};
static void AddExtension___0(char *ext , char *name ) 
{ Tcl_HashEntry *hPtr ;
  int new ;

  {
  hPtr = ((*(extensions___0.createProc)))(& extensions___0, ext, & new);
  hPtr->clientData = (void *)name;
  return;
}
}
static void AddCharset___0(char *charset , char *name ) 
{ Tcl_HashEntry *hPtr ;
  Tcl_DString ds ;
  int new ;
  char *tmp ;

  {
  Tcl_DStringInit(& ds);
  tmp = Tcl_DStringAppend(& ds, charset, -1);
  charset = Ns_StrToLower(tmp);
  hPtr = ((*(charsets___0.createProc)))(& charsets___0, charset, & new);
  hPtr->clientData = (void *)name;
  Tcl_DStringFree(& ds);
  return;
}
}
static Tcl_Encoding GetCharsetEncoding___0(char *charset , int len ) 
{ Tcl_HashEntry *hPtr ;
  Tcl_Encoding encoding ;
  Tcl_DString ds ;
  char *tmp ;

  {
  Tcl_DStringInit(& ds);
  Tcl_DStringAppend(& ds, charset, len);
  tmp = Ns_StrToLower(ds.string);
  charset = Ns_StrTrim(tmp);
  hPtr = ((*(charsets___0.findProc)))(& charsets___0, charset);
  if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    charset = (char *)hPtr->clientData;
  }
  encoding = Ns_GetEncoding(charset);
  Tcl_DStringFree(& ds);
  return (encoding);
}
}
static char *RebuildCharsetList___0(void) 
{ Tcl_HashEntry *entry ;
  Tcl_HashSearch search ;
  Tcl_DString ds ;
  char *tmp ;

  {
  Tcl_DStringInit(& ds);
  Ns_MutexLock(& lock___20);
  entry = Tcl_FirstHashEntry(& charsets___0, & search);
  while ((unsigned int )entry != (unsigned int )((void *)0)) {
    if (charsets___0.keyType == 1) {
      tmp = entry->key.oneWordValue;
    } else {
      if (charsets___0.keyType == -1) {
        tmp = entry->key.oneWordValue;
      } else {
        tmp = entry->key.string;
      }
    }
    Tcl_DStringAppendElement(& ds, tmp);
    entry = Tcl_NextHashEntry(& search);
  }
  Ns_MutexUnlock(& lock___20);
  if ((unsigned int )charsetList___0 != (unsigned int )((void *)0)) {
    ns_free((void *)charsetList___0);
  }
  charsetList___0 = ns_strdup((char const   *)ds.string);
  Tcl_DStringFree(& ds);
  return (charsetList___0);
}
}
static Tcl_Encoding GetDefaultEncoding___0(void) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)Ns_GetConn();
  if ((unsigned int )connPtr != (unsigned int )((void *)0)) {
    if ((unsigned int )connPtr->servPtr != (unsigned int )((void *)0)) {
      return ((connPtr->servPtr)->encoding.outputEncoding);
    } else {
      return (nsconf.encoding.outputEncoding);
    }
  } else {
    return (nsconf.encoding.outputEncoding);
  }
}
}
static Tcl_Encoding GetDefaultCharset___0(void) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)Ns_GetConn();
  if ((unsigned int )connPtr != (unsigned int )((void *)0)) {
    if ((unsigned int )connPtr->servPtr != (unsigned int )((void *)0)) {
      return ((struct Tcl_Encoding_ *)(connPtr->servPtr)->encoding.outputCharset);
    } else {
      return ((struct Tcl_Encoding_ *)nsconf.encoding.outputCharset);
    }
  } else {
    return ((struct Tcl_Encoding_ *)nsconf.encoding.outputCharset);
  }
}
}
static int GetDefaultHackContentTypeP___0(void) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)Ns_GetConn();
  if ((unsigned int )connPtr != (unsigned int )((void *)0)) {
    if ((unsigned int )connPtr->servPtr != (unsigned int )((void *)0)) {
      return ((connPtr->servPtr)->encoding.hackContentTypeP);
    } else {
      return (nsconf.encoding.hackContentTypeP);
    }
  } else {
    return (nsconf.encoding.hackContentTypeP);
  }
}
}
static int ExecProc___0(char *exec , char *dir , int fdin , int fdout , char **argv ,
                        char **envp ) ;
static int ExecProc___0(char *exec , char *dir , int fdin , int fdout , char **argv ,
                        char **envp ) 
{ struct iovec iov[2] ;
  int pid ;
  int nread ;
  int errpipe[2] ;
  int errnum ;
  int result ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  tmp___1 = ns_pipe(errpipe);
  if (tmp___1 < 0) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"exec: ns_pipe() failed: %s",
           tmp___0);
    return (-1);
  }
  pid = ns_fork();
  if (pid < 0) {
    close(errpipe[0]);
    close(errpipe[1]);
    tmp___2 = __errno_location();
    tmp___3 = strerror((*tmp___2));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"exec: ns_fork() failed: %s",
           tmp___3);
    return (-1);
  }
  iov[0].iov_base = (void *)((char *)(& result));
  iov[1].iov_base = (void *)((char *)(& errnum));
  iov[1].iov_len = sizeof(int );
  iov[0].iov_len = iov[1].iov_len;
  if (pid == 0) {
    close(errpipe[0]);
    if ((unsigned int )dir != (unsigned int )((void *)0)) {
      tmp___6 = chdir((char const   *)dir);
      if (tmp___6 != 0) {
        result = -2;
      } else {
        goto _L___3;
      }
    } else {
      _L___3: 
      if (fdin == 1) {
        fdin = dup(1);
        if (fdin < 0) {
          result = -1;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: 
        if (fdout == 0) {
          fdout = dup(0);
          if (fdout < 0) {
            result = -1;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          if (fdin != 0) {
            tmp___4 = dup2(fdin, 0);
            if (tmp___4 < 0) {
              result = -1;
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
            if (fdout != 1) {
              tmp___5 = dup2(fdout, 1);
              if (tmp___5 < 0) {
                result = -1;
              } else {
                goto _L;
              }
            } else {
              _L: 
              if (fdin > 2) {
                close(fdin);
              }
              if (fdout > 2) {
                close(fdout);
              }
              NsRestoreSignals();
              Ns_NoCloseOnExec(0);
              Ns_NoCloseOnExec(1);
              Ns_NoCloseOnExec(2);
              execve((char const   *)exec, (char * const  *)argv, (char * const  *)envp);
              result = -3;
            }
          }
        }
      }
    }
    tmp___7 = __errno_location();
    errnum = (*tmp___7);
    writev(errpipe[1], (struct iovec  const  *)(iov), 2);
    _exit(1);
  } else {
    close(errpipe[1]);
    while (1) {
      nread = readv(errpipe[0], (struct iovec  const  *)(iov), 2);
      if (nread < 0) {
        tmp___8 = __errno_location();
        if (! ((*tmp___8) == 4)) {
          break;
        }
      } else {
        break;
      }
    }
    close(errpipe[0]);
    if (nread == 0) {
      errnum = 0;
      result = pid;
    } else {
      if ((unsigned int )nread != sizeof(int ) * 2U) {
        tmp___9 = __errno_location();
        tmp___10 = strerror((*tmp___9));
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"exec: %s: error reading status from child: %s",
               exec, tmp___10);
      } else {
        switch (result) {
        case -2: 
        tmp___11 = strerror(errnum);
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"exec %s: chdir(%s) failed: %s",
               exec, dir, tmp___11);
        break;
        case -1: 
        tmp___12 = strerror(errnum);
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"exec %s: dup(%d) failed: %s",
               exec, tmp___12);
        break;
        case -3: 
        tmp___13 = strerror(errnum);
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"exec %s: execve() failed: %s",
               exec, tmp___13);
        break;
        default: 
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"exec %s: unknown result from child: %d",
               exec, result);
        break;
        }
      }
      waitpid(pid, (int *)((void *)0), 0);
    }
  }
  return (result);
}
}
static void FreeEntry___0(void *arg ) ;
static void DecrEntry___0(File *filePtr ) ;
static int UrlIs___0(char *server , char *url , int dir ) ;
static int FastStat___0(char *file___1 , struct stat *stPtr ) ;
static int FastReturn___0(NsServer *servPtr , Ns_Conn *conn , int status , char *type ,
                          char *file___1 , struct stat *stPtr ) ;
static int UrlIs___0(char *server , char *url , int dir ) 
{ Tcl_DString ds ;
  int is ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  is = 0;
  Tcl_DStringInit(& ds);
  tmp = Ns_UrlToFile(& ds, server, url);
  if (tmp == 0) {
    tmp___0 = stat__extinline((char const   *)ds.string, & st);
    if (tmp___0 == 0) {
      if (dir) {
        if ((st.st_mode & 61440U) == 16384U) {
          is = 1;
        } else {
          goto _L;
        }
      } else {
        _L: 
        if (dir == 0) {
          if ((st.st_mode & 61440U) == 32768U) {
            is = 1;
          }
        }
      }
    }
  }
  Tcl_DStringFree(& ds);
  return (is);
}
}
static int FastGetRestart___0(Ns_Conn *conn , char *page ) 
{ int status ;
  Tcl_DString ds ;

  {
  Tcl_DStringInit(& ds);
  Ns_MakePath(& ds, (conn->request)->url, page, (void *)0);
  status = Ns_ConnRedirect(conn, ds.string);
  Tcl_DStringFree(& ds);
  return (status);
}
}
static void FreeEntry___0(void *arg ) 
{ File *filePtr ;

  {
  filePtr = (File *)arg;
  DecrEntry___0(filePtr);
  return;
}
}
static void DecrEntry___0(File *filePtr ) 
{ 

  {
  filePtr->refcnt = filePtr->refcnt - 1;
  if (filePtr->refcnt == 0) {
    ns_free((void *)filePtr);
  }
  return;
}
}
static int FastStat___0(char *file___1 , struct stat *stPtr ) 
{ int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  tmp___3 = stat__extinline((char const   *)file___1, stPtr);
  if (tmp___3 != 0) {
    tmp___1 = __errno_location();
    if ((*tmp___1) != 2) {
      tmp___2 = __errno_location();
      if ((*tmp___2) != 13) {
        tmp = __errno_location();
        tmp___0 = strerror((*tmp));
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"fastpath: stat(%s) failed: %s",
               file___1, tmp___0);
      }
    }
    return (0);
  }
  return (1);
}
}
static int FastReturn___0(NsServer *servPtr , Ns_Conn *conn , int status , char *type ,
                          char *file___1 , struct stat *stPtr ) 
{ int result ;
  int fd ;
  int new ;
  int nread ;
  File *filePtr ;
  char *key___1 ;
  Ns_Entry *entPtr ;
  char *map ;
  FileKey ukey ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  result = -1;
  if ((unsigned int )type == (unsigned int )((void *)0)) {
    type = Ns_GetMimeType(file___1);
  }
  Ns_ConnSetLastModifiedHeader(conn, & stPtr->st_mtim.tv_sec);
  tmp___0 = Ns_ConnModifiedSince(conn, stPtr->st_mtim.tv_sec);
  if (tmp___0 == 0) {
    tmp = Ns_ConnReturnNotModified(conn);
    return (tmp);
  }
  if (conn->flags & 4) {
    Ns_ConnSetRequiredHeaders(conn, type, (int )stPtr->st_size);
    tmp___1 = Ns_ConnFlushHeaders(conn, status);
    return (tmp___1);
  }
  if ((unsigned int )servPtr->fastpath.cache == (unsigned int )((void *)0)) {
    goto _L;
  } else {
    if (stPtr->st_size > (long )servPtr->fastpath.cachemaxentry) {
      _L: 
      fd = open((char const   *)file___1, 0);
      if (fd < 0) {
        tmp___2 = __errno_location();
        tmp___3 = strerror((*tmp___2));
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"fastpath: open(%s) failed: %s",
               file___1, tmp___3);
        goto notfound;
      }
      if (servPtr->fastpath.mmap) {
        map = (char *)mmap((void *)0, (unsigned int )stPtr->st_size, 1, 1, fd, 0L);
        if ((unsigned int )map != (unsigned int )((void *)-1)) {
          close(fd);
          fd = -1;
          result = Ns_ConnReturnData(conn, status, map, (int )stPtr->st_size, type);
          munmap((void *)map, (unsigned int )stPtr->st_size);
        }
      }
      if (fd != -1) {
        result = Ns_ConnReturnOpenFd(conn, status, type, fd, (int )stPtr->st_size);
        close(fd);
      }
    } else {
      ukey.dev = stPtr->st_dev;
      ukey.ino = stPtr->st_ino;
      key___1 = (char *)(& ukey);
      filePtr = (File *)((void *)0);
      Ns_CacheLock(servPtr->fastpath.cache);
      entPtr = Ns_CacheCreateEntry(servPtr->fastpath.cache, key___1, & new);
      if (! new) {
        while (1) {
          if ((unsigned int )entPtr != (unsigned int )((void *)0)) {
            filePtr = (File *)Ns_CacheGetValue(entPtr);
            if (! ((unsigned int )filePtr == (unsigned int )((void *)0))) {
              break;
            }
          } else {
            break;
          }
          Ns_CacheWait(servPtr->fastpath.cache);
          entPtr = Ns_CacheFindEntry(servPtr->fastpath.cache, key___1);
        }
        if ((unsigned int )filePtr != (unsigned int )((void *)0)) {
          if (filePtr->mtime != stPtr->st_mtim.tv_sec) {
            Ns_CacheUnsetValue(entPtr);
            new = 1;
          } else {
            if ((long )filePtr->size != stPtr->st_size) {
              Ns_CacheUnsetValue(entPtr);
              new = 1;
            }
          }
        }
      }
      if (new) {
        Ns_CacheUnlock(servPtr->fastpath.cache);
        fd = open((char const   *)file___1, 0);
        if (fd < 0) {
          filePtr = (File *)((void *)0);
          tmp___4 = __errno_location();
          tmp___5 = strerror((*tmp___4));
          Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"fastpath: failed to open \'%s\': \'%s\'",
                 file___1, tmp___5);
        } else {
          filePtr = (File *)ns_malloc((unsigned int )((unsigned long )sizeof(File ) +
                                                      (unsigned long )stPtr->st_size));
          filePtr->refcnt = 1;
          filePtr->size = (int )stPtr->st_size;
          filePtr->mtime = stPtr->st_mtim.tv_sec;
          nread = read(fd, (void *)(filePtr->bytes), (unsigned int )filePtr->size);
          close(fd);
          if (nread != filePtr->size) {
            tmp___6 = __errno_location();
            tmp___7 = strerror((*tmp___6));
            Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"fastpath: failed to read \'%s\': \'%s\'",
                   file___1, tmp___7);
            ns_free((void *)filePtr);
            filePtr = (File *)((void *)0);
          }
        }
        Ns_CacheLock(servPtr->fastpath.cache);
        entPtr = Ns_CacheCreateEntry(servPtr->fastpath.cache, key___1, & new);
        if ((unsigned int )filePtr != (unsigned int )((void *)0)) {
          Ns_CacheSetValueSz(entPtr, (void *)filePtr, (unsigned int )filePtr->size);
        } else {
          Ns_CacheFlushEntry(entPtr);
        }
        Ns_CacheBroadcast(servPtr->fastpath.cache);
      }
      if ((unsigned int )filePtr != (unsigned int )((void *)0)) {
        filePtr->refcnt = filePtr->refcnt + 1;
        Ns_CacheUnlock(servPtr->fastpath.cache);
        result = Ns_ConnReturnData(conn, status, filePtr->bytes, filePtr->size, type);
        Ns_CacheLock(servPtr->fastpath.cache);
        DecrEntry___0(filePtr);
      }
      Ns_CacheUnlock(servPtr->fastpath.cache);
      if ((unsigned int )filePtr == (unsigned int )((void *)0)) {
        goto notfound;
      }
    }
  }
  return (result);
  notfound: 
  tmp___8 = Ns_ConnReturnNotFound(conn);
  return (tmp___8);
}
}
static Tmp *firstTmpPtr___0  ;
static Ns_Mutex lock___21  ;
static Trace *NewTrace___0(Ns_TraceProc *proc , void *arg ) ;
static void RunTraces___1(Ns_Conn *conn , Trace *tracePtr ) ;
static void *RegisterCleanup___0(NsServer *servPtr , Ns_TraceProc *proc , void *arg ) ;
static void *RegisterCleanup___0(NsServer *servPtr , Ns_TraceProc *proc , void *arg ) 
{ Trace *tracePtr ;

  {
  if ((unsigned int )servPtr == (unsigned int )((void *)0)) {
    return ((void *)0);
  }
  tracePtr = NewTrace___0(proc, arg);
  tracePtr->nextPtr = servPtr->filter.firstCleanupPtr;
  servPtr->filter.firstCleanupPtr = tracePtr;
  return ((void *)tracePtr);
}
}
static void RunTraces___1(Ns_Conn *conn , Trace *tracePtr ) 
{ 

  {
  while ((unsigned int )tracePtr != (unsigned int )((void *)0)) {
    ((*(tracePtr->proc)))(tracePtr->arg, conn);
    tracePtr = tracePtr->nextPtr;
  }
  return;
}
}
static Trace *NewTrace___0(Ns_TraceProc *proc , void *arg ) 
{ Trace *tracePtr ;

  {
  tracePtr = (Trace *)ns_malloc(sizeof(Trace ));
  tracePtr->proc = proc;
  tracePtr->arg = arg;
  return (tracePtr);
}
}
static void ParseQuery___0(char *form , Ns_Set *set , Tcl_Encoding encoding ) ;
static void ParseMultiInput___0(Conn *connPtr , char *start , char *end ) ;
static char *Ext2Utf___0(Tcl_DString *dsPtr , char *start , int len , Tcl_Encoding encoding ) ;
static int GetBoundary___0(Tcl_DString *dsPtr , Ns_Conn *conn ) ;
static char *NextBoundry___0(Tcl_DString *dsPtr , char *s , char *e___1 ) ;
static int GetValue___0(char *hdr , char *att , char **vsPtr , char **vePtr ) ;
static void ParseQuery___0(char *form , Ns_Set *set , Tcl_Encoding encoding ) 
{ char *p ;
  char *k ;
  char *v ;
  Tcl_DString kds ;
  Tcl_DString vds ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  Tcl_DStringInit(& kds);
  Tcl_DStringInit(& vds);
  p = form;
  while ((unsigned int )p != (unsigned int )((void *)0)) {
    k = p;
    tmp___0 = strchr((char const   *)p, '&');
    p = tmp___0;
    if ((unsigned int )p != (unsigned int )((void *)0)) {
      (*p) = (char )'\000';
    }
    tmp___2 = strchr((char const   *)k, '=');
    v = tmp___2;
    if ((unsigned int )v != (unsigned int )((void *)0)) {
      (*v) = (char )'\000';
    }
    Tcl_DStringSetLength(& kds, 0);
    k = Ns_DecodeUrlWithEncoding(& kds, k, encoding);
    if ((unsigned int )v != (unsigned int )((void *)0)) {
      Tcl_DStringSetLength(& vds, 0);
      Ns_DecodeUrlWithEncoding(& vds, v + 1, encoding);
      (*v) = (char )'=';
      v = vds.string;
    }
    Ns_SetPut(set, k, v);
    if ((unsigned int )p != (unsigned int )((void *)0)) {
      tmp___3 = p;
      p ++;
      (*tmp___3) = (char )'&';
    }
  }
  Tcl_DStringFree(& kds);
  Tcl_DStringFree(& vds);
  return;
}
}
static void ParseMultiInput___0(Conn *connPtr , char *start , char *end ) 
{ Tcl_Encoding encoding ;
  Tcl_DString kds ;
  Tcl_DString vds ;
  Tcl_HashEntry *hPtr ;
  FormFile *filePtr ;
  char *s ;
  char *e___1 ;
  char *ks ;
  char *ke ;
  char *fs ;
  char *fe ;
  char save ;
  char saveend ;
  char *key___1 ;
  char *value ;
  char *disp ;
  Ns_Set *set ;
  int new ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  encoding = connPtr->urlEncoding;
  Tcl_DStringInit(& kds);
  Tcl_DStringInit(& vds);
  set = Ns_SetCreate((char *)((void *)0));
  if ((unsigned int )end > (unsigned int )start) {
    if ((int )(*(end + -1)) == 10) {
      end --;
    }
  }
  if ((unsigned int )end > (unsigned int )start) {
    if ((int )(*(end + -1)) == 13) {
      end --;
    }
  }
  saveend = (*end);
  (*end) = (char )'\000';
  fs = (char *)((void *)0);
  ks = fs;
  while (1) {
    tmp___0 = strchr((char const   *)start, '\n');
    e___1 = tmp___0;
    if (! ((unsigned int )e___1 != (unsigned int )((void *)0))) {
      break;
    }
    s = start;
    start = e___1 + 1;
    if ((unsigned int )e___1 > (unsigned int )s) {
      if ((int )(*(e___1 + -1)) == 13) {
        e___1 --;
      }
    }
    if ((unsigned int )s == (unsigned int )e___1) {
      break;
    }
    save = (*e___1);
    (*e___1) = (char )'\000';
    Ns_ParseHeader(set, s, (enum __anonenum_Ns_HeaderCaseDisposition_68 )1);
    (*e___1) = save;
  }
  disp = Ns_SetGet(set, (char *)"content-disposition");
  if ((unsigned int )disp != (unsigned int )((void *)0)) {
    tmp___2 = GetValue___0(disp, (char *)"name=", & ks, & ke);
    if (tmp___2) {
      key___1 = Ext2Utf___0(& kds, ks, ke - ks, encoding);
      tmp___1 = GetValue___0(disp, (char *)"filename=", & fs, & fe);
      if (tmp___1) {
        value = Ext2Utf___0(& vds, fs, fe - fs, encoding);
        hPtr = ((*(connPtr->files.createProc)))(& connPtr->files, key___1, & new);
        if (new) {
          filePtr = (FormFile *)ns_malloc(sizeof(FormFile ));
          filePtr->hdrs = set;
          filePtr->off = (long )(start - (connPtr->reqPtr)->content);
          filePtr->len = (long )(end - start);
          hPtr->clientData = (void *)filePtr;
          set = (Ns_Set *)((void *)0);
        }
      } else {
        value = Ext2Utf___0(& vds, start, end - start, encoding);
      }
      Ns_SetPut(connPtr->query, key___1, value);
    }
  }
  (*end) = saveend;
  Tcl_DStringFree(& kds);
  Tcl_DStringFree(& vds);
  if ((unsigned int )set != (unsigned int )((void *)0)) {
    Ns_SetFree(set);
  }
  return;
}
}
static int GetBoundary___0(Tcl_DString *dsPtr , Ns_Conn *conn ) 
{ char *type ;
  char *bs ;
  char *be ;
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
  type = Ns_SetIGet(conn->headers, (char *)"content-type");
  if ((unsigned int )type != (unsigned int )((void *)0)) {
    tmp___0 = Ns_StrCaseFind(type, (char *)"multipart/form-data");
    if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
      bs = Ns_StrCaseFind(type, (char *)"boundary=");
      if ((unsigned int )bs != (unsigned int )((void *)0)) {
        bs += 9;
        be = bs;
        while (1) {
          if ((*be)) {
            tmp = __ctype_b_loc();
            if ((int const   )(*((*tmp) + (int )((unsigned char )(*be)))) & 8192) {
              break;
            }
          } else {
            break;
          }
          be ++;
        }
        Tcl_DStringAppend(dsPtr, (char *)"--", 2);
        Tcl_DStringAppend(dsPtr, bs, be - bs);
        return (1);
      }
    }
  }
  return (0);
}
}
static char *NextBoundry___0(Tcl_DString *dsPtr , char *s , char *e___1 ) 
{ char c ;
  char sc ;
  char *find ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  find = dsPtr->string;
  tmp = find;
  find ++;
  c = (*tmp);
  len = (unsigned int )(dsPtr->length - 1);
  e___1 -= len;
  while (1) {
    while (1) {
      tmp___0 = s;
      s ++;
      sc = (*tmp___0);
      if ((unsigned int )s > (unsigned int )e___1) {
        return ((char *)((void *)0));
      }
      if (! ((int )sc != (int )c)) {
        break;
      }
    }
    if (0) {
      if (0) {
        __s1_len___0 = strlen((char const   *)s);
        __s2_len___0 = strlen((char const   *)find);
        if (! ((unsigned int )((void const   *)(s + 1)) - (unsigned int )((void const   *)s) ==
               1U)) {
          goto _L___2;
        } else {
          if (__s1_len___0 >= 4U) {
            _L___2: 
            if (! ((unsigned int )((void const   *)(find + 1)) - (unsigned int )((void const   *)find) ==
                   1U)) {
              tmp___20 = 1;
            } else {
              if (__s2_len___0 >= 4U) {
                tmp___20 = 1;
              } else {
                tmp___20 = 0;
              }
            }
          } else {
            tmp___20 = 0;
          }
        }
        if (tmp___20) {
          if (__s1_len___0 < __s2_len___0) {
            tmp___18 = __s1_len___0;
          } else {
            tmp___18 = __s2_len___0;
          }
          tmp___17 = memcmp((void const   *)((char const   *)s), (void const   *)((char const   *)find),
                            tmp___18 + 1U);
        } else {
          tmp___19 = strcmp((char const   *)s, (char const   *)find);
          tmp___17 = tmp___19;
        }
      } else {
        tmp___19 = strcmp((char const   *)s, (char const   *)find);
        tmp___17 = tmp___19;
      }
      tmp___12 = tmp___17;
    } else {
      tmp___12 = strncmp((char const   *)s, (char const   *)find, len);
    }
    if (! (tmp___12 != 0)) {
      break;
    }
  }
  s --;
  return (s);
}
}
static int GetValue___0(char *hdr , char *att , char **vsPtr , char **vePtr ) 
{ char *s ;
  char *e___1 ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  s = Ns_StrCaseFind(hdr, att);
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    return (0);
  }
  tmp = strlen((char const   *)att);
  s += tmp;
  e___1 = s;
  if ((int )(*s) != 34) {
    if ((int )(*s) != 39) {
      while (1) {
        if ((*e___1)) {
          tmp___0 = __ctype_b_loc();
          if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*e___1)))) & 8192) {
            break;
          }
        } else {
          break;
        }
        e___1 ++;
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    e___1 ++;
    while (1) {
      if ((*e___1)) {
        if (! ((int )(*e___1) != (int )(*s))) {
          break;
        }
      } else {
        break;
      }
      e___1 ++;
    }
    s ++;
  }
  (*vsPtr) = s;
  (*vePtr) = e___1;
  return (1);
}
}
static char *Ext2Utf___0(Tcl_DString *dsPtr , char *start , int len , Tcl_Encoding encoding ) 
{ 

  {
  if ((unsigned int )encoding == (unsigned int )((void *)0)) {
    Tcl_DStringSetLength(dsPtr, 0);
    Tcl_DStringAppend(dsPtr, start, len);
  } else {
    Tcl_DStringFree(dsPtr);
    Tcl_ExternalToUtfDString(encoding, start, len, dsPtr);
  }
  return (dsPtr->string);
}
}
static int MakeNum___0(char *s ) ;
static int MakeMonth___0(char *s ) ;
static char *month_names___0[12]  = 
  {      (char *)"Jan",      (char *)"Feb",      (char *)"Mar",      (char *)"Apr", 
        (char *)"May",      (char *)"Jun",      (char *)"Jul",      (char *)"Aug", 
        (char *)"Sep",      (char *)"Oct",      (char *)"Nov",      (char *)"Dec"};
static int MakeNum___0(char *s ) 
{ 

  {
  if ((int )(*s) >= 48) {
    if ((int )(*s) <= 57) {
      return (10 * ((int )(*s) - 48) + ((int )(*(s + 1)) - 48));
    } else {
      return ((int )(*(s + 1)) - 48);
    }
  } else {
    return ((int )(*(s + 1)) - 48);
  }
}
}
static int MakeMonth___0(char *s ) 
{ int i ;
  int __res ;
  __int32_t const   **tmp___1 ;
  int __res___0 ;
  __int32_t const   **tmp___4 ;
  int __res___1 ;
  __int32_t const   **tmp___7 ;
  int tmp___19 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;

  {
  if (sizeof((*s)) > 1U) {
    __res = toupper__extinline((int )(*s));
  } else {
    tmp___1 = __ctype_toupper_loc();
    __res = (*((*tmp___1) + (int )(*s)));
  }
  (*s) = (char )__res;
  if (sizeof((*(s + 1))) > 1U) {
    __res___0 = tolower__extinline((int )(*(s + 1)));
  } else {
    tmp___4 = __ctype_tolower_loc();
    __res___0 = (*((*tmp___4) + (int )(*(s + 1))));
  }
  (*(s + 1)) = (char )__res___0;
  if (sizeof((*(s + 2))) > 1U) {
    __res___1 = tolower__extinline((int )(*(s + 2)));
  } else {
    tmp___7 = __ctype_tolower_loc();
    __res___1 = (*((*tmp___7) + (int )(*(s + 2))));
  }
  (*(s + 2)) = (char )__res___1;
  i = 0;
  while (i < 12) {
    if (0) {
      if (0) {
        __s1_len___0 = strlen((char const   *)month_names___0[i]);
        __s2_len___0 = strlen((char const   *)s);
        if (! ((unsigned int )((void const   *)(month_names___0[i] + 1)) - (unsigned int )((void const   *)month_names___0[i]) ==
               1U)) {
          goto _L___2;
        } else {
          if (__s1_len___0 >= 4U) {
            _L___2: 
            if (! ((unsigned int )((void const   *)(s + 1)) - (unsigned int )((void const   *)s) ==
                   1U)) {
              tmp___27 = 1;
            } else {
              if (__s2_len___0 >= 4U) {
                tmp___27 = 1;
              } else {
                tmp___27 = 0;
              }
            }
          } else {
            tmp___27 = 0;
          }
        }
        if (tmp___27) {
          if (__s1_len___0 < __s2_len___0) {
            tmp___25 = __s1_len___0;
          } else {
            tmp___25 = __s2_len___0;
          }
          tmp___24 = memcmp((void const   *)((char const   *)month_names___0[i]),
                            (void const   *)((char const   *)s), tmp___25 + 1U);
        } else {
          tmp___26 = strcmp((char const   *)month_names___0[i], (char const   *)s);
          tmp___24 = tmp___26;
        }
      } else {
        tmp___26 = strcmp((char const   *)month_names___0[i], (char const   *)s);
        tmp___24 = tmp___26;
      }
      tmp___19 = tmp___24;
    } else {
      tmp___19 = strncmp((char const   *)month_names___0[i], (char const   *)s, 3U);
    }
    if (! tmp___19) {
      return (i);
    }
    i ++;
  }
  return (0);
}
}
static int BinSearch___0(void **elPtrPtr , void **listPtrPtr , int n , Ns_IndexCmpProc *cmpProc ) ;
static int BinSearchKey___0(void *key___1 , void **listPtrPtr , int n , Ns_IndexCmpProc *cmpProc ) ;
static int BinSearch___0(void **elPtrPtr , void **listPtrPtr , int n , Ns_IndexCmpProc *cmpProc ) 
{ int cond___9 ;
  int low ;
  int high ;
  int mid ;
  int tmp ;

  {
  cond___9 = 0;
  low = 0;
  high = 0;
  mid = 0;
  low = 0;
  high = n - 1;
  while (low <= high) {
    mid = (low + high) / 2;
    cond___9 = ((*cmpProc))((void const   *)elPtrPtr, (void const   *)(listPtrPtr +
                                                                       mid));
    if (cond___9 < 0) {
      high = mid - 1;
    } else {
      if (cond___9 > 0) {
        low = mid + 1;
      } else {
        return (mid);
      }
    }
  }
  if (high < mid) {
    tmp = mid;
  } else {
    tmp = low;
  }
  return (tmp);
}
}
static int BinSearchKey___0(void *key___1 , void **listPtrPtr , int n , Ns_IndexCmpProc *cmpProc ) 
{ int cond___9 ;
  int low ;
  int high ;
  int mid ;
  int tmp ;

  {
  cond___9 = 0;
  low = 0;
  high = 0;
  mid = 0;
  low = 0;
  high = n - 1;
  while (low <= high) {
    mid = (low + high) / 2;
    cond___9 = ((*cmpProc))((void const   *)key___1, (void const   *)(listPtrPtr +
                                                                      mid));
    if (cond___9 < 0) {
      high = mid - 1;
    } else {
      if (cond___9 > 0) {
        low = mid + 1;
      } else {
        return (mid);
      }
    }
  }
  if (high < mid) {
    tmp = mid;
  } else {
    tmp = low;
  }
  return (tmp);
}
}
static int CmpStr___0(char **leftPtr , char **rightPtr ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if (0) {
    __s1_len = strlen((char const   *)(*leftPtr));
    __s2_len = strlen((char const   *)(*rightPtr));
    if (! ((unsigned int )((void const   *)((*leftPtr) + 1)) - (unsigned int )((void const   *)(*leftPtr)) ==
           1U)) {
      goto _L___0;
    } else {
      if (__s1_len >= 4U) {
        _L___0: 
        if (! ((unsigned int )((void const   *)((*rightPtr) + 1)) - (unsigned int )((void const   *)(*rightPtr)) ==
               1U)) {
          tmp___6 = 1;
        } else {
          if (__s2_len >= 4U) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        }
      } else {
        tmp___6 = 0;
      }
    }
    if (tmp___6) {
      if (__s1_len < __s2_len) {
        tmp___4 = __s1_len;
      } else {
        tmp___4 = __s2_len;
      }
      tmp___3 = memcmp((void const   *)((char const   *)(*leftPtr)), (void const   *)((char const   *)(*rightPtr)),
                       tmp___4 + 1U);
    } else {
      tmp___5 = strcmp((char const   *)(*leftPtr), (char const   *)(*rightPtr));
      tmp___3 = tmp___5;
    }
  } else {
    tmp___5 = strcmp((char const   *)(*leftPtr), (char const   *)(*rightPtr));
    tmp___3 = tmp___5;
  }
  return (tmp___3);
}
}
static int CmpKeyWithStr___0(char *key___1 , char **elPtr ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if (0) {
    __s1_len = strlen((char const   *)key___1);
    __s2_len = strlen((char const   *)(*elPtr));
    if (! ((unsigned int )((void const   *)(key___1 + 1)) - (unsigned int )((void const   *)key___1) ==
           1U)) {
      goto _L___0;
    } else {
      if (__s1_len >= 4U) {
        _L___0: 
        if (! ((unsigned int )((void const   *)((*elPtr) + 1)) - (unsigned int )((void const   *)(*elPtr)) ==
               1U)) {
          tmp___6 = 1;
        } else {
          if (__s2_len >= 4U) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        }
      } else {
        tmp___6 = 0;
      }
    }
    if (tmp___6) {
      if (__s1_len < __s2_len) {
        tmp___4 = __s1_len;
      } else {
        tmp___4 = __s2_len;
      }
      tmp___3 = memcmp((void const   *)((char const   *)key___1), (void const   *)((char const   *)(*elPtr)),
                       tmp___4 + 1U);
    } else {
      tmp___5 = strcmp((char const   *)key___1, (char const   *)(*elPtr));
      tmp___3 = tmp___5;
    }
  } else {
    tmp___5 = strcmp((char const   *)key___1, (char const   *)(*elPtr));
    tmp___3 = tmp___5;
  }
  return (tmp___3);
}
}
static int CmpInts___0(int *leftPtr , int *rightPtr ) 
{ int tmp ;

  {
  if ((*leftPtr) == (*rightPtr)) {
    return (0);
  } else {
    if ((*leftPtr) < (*rightPtr)) {
      tmp = -1;
    } else {
      tmp = 1;
    }
    return (tmp);
  }
}
}
static int CmpKeyWithInt___0(int *keyPtr , int *elPtr ) 
{ int tmp ;

  {
  if ((*keyPtr) == (*elPtr)) {
    return (0);
  } else {
    if ((*keyPtr) < (*elPtr)) {
      tmp = -1;
    } else {
      tmp = 1;
    }
    return (tmp);
  }
}
}
static void ThreadArgProc___0(Tcl_DString *dsPtr , void *proc , void *arg ) ;
static char *opts___17[31]  = 
  {      (char *)"address",      (char *)"argv0",      (char *)"boottime",      (char *)"builddate", 
        (char *)"callbacks",      (char *)"config",      (char *)"home",      (char *)"hostname", 
        (char *)"label",      (char *)"locks",      (char *)"log",      (char *)"major", 
        (char *)"minor",      (char *)"name",      (char *)"nsd",      (char *)"pageroot", 
        (char *)"patchlevel",      (char *)"pid",      (char *)"platform",      (char *)"pools", 
        (char *)"scheduled",      (char *)"server",      (char *)"servers",      (char *)"sockcallbacks", 
        (char *)"tag",      (char *)"tcllib",      (char *)"threads",      (char *)"uptime", 
        (char *)"version",      (char *)"winnt",      (char *)((void *)0)};
static void ThreadArgProc___0(Tcl_DString *dsPtr , void *proc , void *arg ) 
{ 

  {
  Ns_GetProcInfo(dsPtr, proc, arg);
  return;
}
}
static int once___1  =    0;
static int ListenCallback___1(int sock , void *arg , int why ) ;
static Tcl_HashTable portsTable___0  ;
static Ns_Mutex lock___22  ;
static int ListenCallback___1(int sock , void *arg , int why ) 
{ struct sockaddr_in sa ;
  int len ;
  Tcl_HashTable *tablePtr ;
  Tcl_HashEntry *hPtr ;
  int new ;
  ListenData *ldPtr ;

  {
  tablePtr = (Tcl_HashTable *)arg;
  if (why == 8) {
    close(sock);
    return (0);
  }
  new = Ns_SockAccept(sock, (struct sockaddr *)((void *)0), (int *)((void *)0));
  if (new != -1) {
    Ns_SockSetBlocking(new);
    len = (int )sizeof(sa);
    getsockname(new, (struct sockaddr * __restrict  )((struct sockaddr *)(& sa)),
                (socklen_t * __restrict  )(& len));
    ldPtr = (ListenData *)((void *)0);
    Ns_MutexLock(& lock___22);
    hPtr = ((*(tablePtr->findProc)))(tablePtr, (char *)sa.sin_addr.s_addr);
    if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
      hPtr = ((*(tablePtr->findProc)))(tablePtr, (char *)0U);
    }
    if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
      ldPtr = (ListenData *)hPtr->clientData;
    }
    Ns_MutexUnlock(& lock___22);
    if ((unsigned int )ldPtr == (unsigned int )((void *)0)) {
      close(new);
    } else {
      ((*(ldPtr->proc)))(new, ldPtr->arg, why);
    }
  }
  return (1);
}
}
static int LogReOpen___0(void) ;
static void Log___0(Ns_LogSeverity severity , char *fmt , va_list ap ) ;
static Cache___0 *LogGetCache___0(void) ;
static void LogFreeCache___0(void *arg ) ;
static void LogFlush___0(Cache___0 *cachePtr ) ;
static char *LogTime___0(Cache___0 *cachePtr , int gmtoff , long *usecPtr ) ;
static int LogStart___0(Cache___0 *cachePtr , Ns_LogSeverity severity ) ;
static void LogEnd___0(Cache___0 *cachePtr ) ;
static Ns_Tls tls___2  ;
static Ns_Mutex lock___23  ;
static Ns_LogFlushProc *flushProcPtr___0  ;
static Ns_LogProc *nslogProcPtr___0  ;
static char *opts___18[8]  = 
  {      (char *)"hold",      (char *)"count",      (char *)"get",      (char *)"peek", 
        (char *)"flush",      (char *)"release",      (char *)"truncate",      (char *)((void *)0)};
static void Log___0(Ns_LogSeverity severity , char *fmt , va_list ap ) 
{ Cache___0 *cachePtr ;
  int tmp ;

  {
  cachePtr = LogGetCache___0();
  if ((unsigned int )nslogProcPtr___0 == (unsigned int )((void *)0)) {
    tmp = LogStart___0(cachePtr, severity);
    if (tmp) {
      Ns_DStringVPrintf(& cachePtr->buffer, fmt, ap);
      LogEnd___0(cachePtr);
    }
  } else {
    ((*nslogProcPtr___0))(& cachePtr->buffer, severity, fmt, ap);
    cachePtr->count = cachePtr->count + 1;
    if (! cachePtr->hold) {
      LogFlush___0(cachePtr);
    }
  }
  return;
}
}
static int LogStart___0(Cache___0 *cachePtr , Ns_LogSeverity severity ) 
{ char *severityStr ;
  char buf[10] ;
  long usec ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  switch ((int )severity) {
  case 0: ;
  if (nsconf.log.flags & 16) {
    return (0);
  }
  severityStr = (char *)"Notice";
  break;
  case 1: 
  severityStr = (char *)"Warning";
  break;
  case 2: 
  severityStr = (char *)"Error";
  break;
  case 3: 
  severityStr = (char *)"Fatal";
  break;
  case 4: 
  severityStr = (char *)"Bug";
  break;
  case 5: ;
  if (! (nsconf.log.flags & 4)) {
    return (0);
  }
  severityStr = (char *)"Debug";
  break;
  case 6: ;
  if (! (nsconf.log.flags & 8)) {
    return (0);
  }
  severityStr = (char *)"Dev";
  break;
  default: ;
  if ((int )severity > nsconf.log.maxlevel) {
    return (0);
  }
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"Level%d", severity);
  severityStr = buf;
  break;
  }
  tmp = LogTime___0(cachePtr, 0, & usec);
  Tcl_DStringAppend(& cachePtr->buffer, tmp, -1);
  if (nsconf.log.flags & 32) {
    Tcl_DStringSetLength(& cachePtr->buffer, cachePtr->buffer.length - 1);
    Ns_DStringPrintf(& cachePtr->buffer, (char *)".%ld]", usec);
  }
  tmp___0 = Ns_ThreadGetName();
  tmp___1 = Ns_ThreadId();
  tmp___2 = Ns_InfoPid();
  Ns_DStringPrintf(& cachePtr->buffer, (char *)"[%d.%lu][%s] %s: ", tmp___2, (unsigned long )tmp___1,
                   tmp___0, severityStr);
  if (nsconf.log.flags & 2) {
    Tcl_DStringAppend(& cachePtr->buffer, (char *)"\n    ", -1);
  }
  return (1);
}
}
static void LogEnd___0(Cache___0 *cachePtr ) 
{ 

  {
  Tcl_DStringAppend(& cachePtr->buffer, (char *)"\n", 1);
  if (nsconf.log.flags & 2) {
    Tcl_DStringAppend(& cachePtr->buffer, (char *)"\n", 1);
  }
  cachePtr->count = cachePtr->count + 1;
  if (! cachePtr->hold) {
    LogFlush___0(cachePtr);
  }
  return;
}
}
static void LogFlush___0(Cache___0 *cachePtr ) 
{ Tcl_DString *dsPtr ;

  {
  dsPtr = & cachePtr->buffer;
  Ns_MutexLock(& lock___23);
  if ((unsigned int )flushProcPtr___0 == (unsigned int )((void *)0)) {
    write(2, (void const   *)dsPtr->string, (unsigned int )dsPtr->length);
  } else {
    ((*flushProcPtr___0))(dsPtr->string, (unsigned int )dsPtr->length);
  }
  Ns_MutexUnlock(& lock___23);
  Tcl_DStringFree(dsPtr);
  cachePtr->count = 0;
  return;
}
}
static int LogReOpen___0(void) 
{ int fd ;
  int status ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  status = 0;
  fd = open((char const   *)nsconf.log.file, 1089, 420);
  if (fd < 0) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"log: failed to re-open log file \'%s\': \'%s\'",
           nsconf.log.file, tmp___0);
    status = -1;
  } else {
    if (fd != 2) {
      tmp___3 = dup2(fd, 2);
      if (tmp___3 == -1) {
        tmp___1 = __errno_location();
        tmp___2 = strerror((*tmp___1));
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"dup2(%s, STDERR_FILENO) failed: %s\n",
                nsconf.log.file, tmp___2);
        status = -1;
      }
    }
    tmp___6 = dup2(2, 1);
    if (tmp___6 == -1) {
      tmp___4 = __errno_location();
      tmp___5 = strerror((*tmp___4));
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"log: failed to route stdout to file: \'%s\'",
             tmp___5);
      status = -1;
    }
    if (fd != 2) {
      if (fd != 1) {
        close(fd);
      }
    }
  }
  return (status);
}
}
static char *LogTime___0(Cache___0 *cachePtr , int gmtoff , long *usecPtr ) 
{ time_t *tp___1 ;
  struct tm *ptm ;
  int gmtoffset ;
  int n ;
  int sign ;
  char *bp ;
  Ns_Time now ;
  int tmp ;

  {
  if (gmtoff) {
    tp___1 = & cachePtr->gtime;
    bp = cachePtr->gbuf;
  } else {
    tp___1 = & cachePtr->ltime;
    bp = cachePtr->lbuf;
  }
  Ns_GetTime(& now);
  if ((*tp___1) != now.sec) {
    (*tp___1) = now.sec;
    ptm = ns_localtime((time_t const   *)(& now.sec));
    n = (int )strftime((char * __restrict  )bp, 32U, (char const   * __restrict  )"[%d/%b/%Y:%H:%M:%S",
                       (struct tm  const  * __restrict  )ptm);
    if (! gmtoff) {
      tmp = n;
      n ++;
      (*(bp + tmp)) = (char )']';
      (*(bp + n)) = (char )'\000';
    } else {
      gmtoffset = (int )(ptm->tm_gmtoff / 60L);
      if (gmtoffset < 0) {
        sign = '-';
        gmtoffset *= -1;
      } else {
        sign = '+';
      }
      sprintf((char * __restrict  )(bp + n), (char const   * __restrict  )" %c%02d%02d]",
              sign, gmtoffset / 60, gmtoffset % 60);
    }
  }
  if ((unsigned int )usecPtr != (unsigned int )((void *)0)) {
    (*usecPtr) = now.usec;
  }
  return (bp);
}
}
static Cache___0 *LogGetCache___0(void) 
{ Cache___0 *cachePtr ;

  {
  cachePtr = (Cache___0 *)Ns_TlsGet(& tls___2);
  if ((unsigned int )cachePtr == (unsigned int )((void *)0)) {
    cachePtr = (Cache___0 *)ns_calloc(1U, sizeof(Cache___0 ));
    Tcl_DStringInit(& cachePtr->buffer);
    Ns_TlsSet(& tls___2, (void *)cachePtr);
  }
  return (cachePtr);
}
}
static void LogFreeCache___0(void *arg ) 
{ Cache___0 *cachePtr ;

  {
  cachePtr = (Cache___0 *)arg;
  LogFlush___0(cachePtr);
  Tcl_DStringFree(& cachePtr->buffer);
  ns_free((void *)cachePtr);
  return;
}
}
static void AddType___0(char *ext , char *type ) ;
static char *LowerDString___0(Tcl_DString *dsPtr , char *ext ) ;
static Tcl_HashTable types___0  ;
static char *defaultType___0  =    (char *)"*/*";
static char *noextType___0  =    (char *)"*/*";
static struct exttype typetab___0[82]  = 
  {      {(char *)".adp", (char *)"text/html; charset=iso-8859-1"}, 
        {(char *)".dci", (char *)"text/html; charset=iso-8859-1"}, 
        {(char *)".htm", (char *)"text/html; charset=iso-8859-1"}, 
        {(char *)".html", (char *)"text/html; charset=iso-8859-1"}, 
        {(char *)".sht", (char *)"text/html; charset=iso-8859-1"}, 
        {(char *)".shtml", (char *)"text/html; charset=iso-8859-1"}, 
        {(char *)".ai", (char *)"application/postscript"}, 
        {(char *)".aif", (char *)"audio/aiff"}, 
        {(char *)".aifc", (char *)"audio/aiff"}, 
        {(char *)".aiff", (char *)"audio/aiff"}, 
        {(char *)".ani", (char *)"application/x-navi-animation"}, 
        {(char *)".art", (char *)"image/x-art"}, 
        {(char *)".au", (char *)"audio/basic"}, 
        {(char *)".avi", (char *)"video/x-msvideo"}, 
        {(char *)".bin", (char *)"application/x-macbinary"}, 
        {(char *)".bmp", (char *)"image/bmp"}, 
        {(char *)".css", (char *)"text/css"}, 
        {(char *)".csv", (char *)"application/csv"}, 
        {(char *)".dcr", (char *)"application/x-director"}, 
        {(char *)".dir", (char *)"application/x-director"}, 
        {(char *)".dp", (char *)"application/commonground"}, 
        {(char *)".dxr", (char *)"application/x-director"}, 
        {(char *)".elm", (char *)"text/plain"}, 
        {(char *)".eml", (char *)"text/plain"}, 
        {(char *)".exe", (char *)"application/octet-stream"}, 
        {(char *)".gbt", (char *)"text/plain"}, 
        {(char *)".gif", (char *)"image/gif"}, 
        {(char *)".gz", (char *)"application/x-compressed"}, 
        {(char *)".hqx", (char *)"application/mac-binhex40"}, 
        {(char *)".jfif", (char *)"image/jpeg"}, 
        {(char *)".jpe", (char *)"image/jpeg"}, 
        {(char *)".jpg", (char *)"image/jpeg"}, 
        {(char *)".jpeg", (char *)"image/jpeg"}, 
        {(char *)".js", (char *)"application/x-javascript"}, 
        {(char *)".ls", (char *)"application/x-javascript"}, 
        {(char *)".map", (char *)"application/x-navimap"}, 
        {(char *)".mid", (char *)"audio/x-midi"}, 
        {(char *)".midi", (char *)"audio/x-midi"}, 
        {(char *)".mocha", (char *)"application/x-javascript"}, 
        {(char *)".mov", (char *)"video/quicktime"}, 
        {(char *)".mpe", (char *)"video/mpeg"}, 
        {(char *)".mpeg", (char *)"video/mpeg"}, 
        {(char *)".mpg", (char *)"video/mpeg"}, 
        {(char *)".nvd", (char *)"application/x-navidoc"}, 
        {(char *)".nvm", (char *)"application/x-navimap"}, 
        {(char *)".pbm", (char *)"image/x-portable-bitmap"}, 
        {(char *)".pdf", (char *)"application/pdf"}, 
        {(char *)".pgm", (char *)"image/x-portable-graymap"}, 
        {(char *)".pic", (char *)"image/pict"}, 
        {(char *)".pict", (char *)"image/pict"}, 
        {(char *)".pnm", (char *)"image/x-portable-anymap"}, 
        {(char *)".png", (char *)"image/png"}, 
        {(char *)".ps", (char *)"application/postscript"}, 
        {(char *)".qt", (char *)"video/quicktime"}, 
        {(char *)".ra", (char *)"audio/x-pn-realaudio"}, 
        {(char *)".ram", (char *)"audio/x-pn-realaudio"}, 
        {(char *)".ras", (char *)"image/x-cmu-raster"}, 
        {(char *)".rgb", (char *)"image/x-rgb"}, 
        {(char *)".rtf", (char *)"application/rtf"}, 
        {(char *)".sit", (char *)"application/x-stuffit"}, 
        {(char *)".snd", (char *)"audio/basic"}, 
        {(char *)".sql", (char *)"application/x-sql"}, 
        {(char *)".stl", (char *)"application/x-navistyle"}, 
        {(char *)".tar", (char *)"application/x-tar"}, 
        {(char *)".tcl", (char *)"text/plain"}, 
        {(char *)".text", (char *)"text/plain"}, 
        {(char *)".tgz", (char *)"application/x-compressed"}, 
        {(char *)".tif", (char *)"image/tiff"}, 
        {(char *)".tiff", (char *)"image/tiff"}, 
        {(char *)".txt", (char *)"text/plain"}, 
        {(char *)".xbm", (char *)"image/x-xbitmap"}, 
        {(char *)".xpm", (char *)"image/x-xpixmap"}, 
        {(char *)".xht", (char *)"application/xhtml+xml"}, 
        {(char *)".xhtml", (char *)"application/xhtml+xml"}, 
        {(char *)".xml", (char *)"text/xml"}, 
        {(char *)".xsl", (char *)"text/xml"}, 
        {(char *)".vrml", (char *)"x-world/x-vrml"}, 
        {(char *)".wav", (char *)"audio/x-wav"}, 
        {(char *)".wrl", (char *)"x-world/x-vrml"}, 
        {(char *)".z", (char *)"application/x-compressed"}, 
        {(char *)".zip", (char *)"application/x-zip-compressed"}, 
        {(char *)((void *)0), (char *)((void *)0)}};
static void AddType___0(char *ext , char *type ) 
{ Tcl_DString ds ;
  Tcl_HashEntry *he ;
  int new ;

  {
  Tcl_DStringInit(& ds);
  ext = LowerDString___0(& ds, ext);
  he = ((*(types___0.createProc)))(& types___0, ext, & new);
  if (new == 0) {
    ns_free(he->clientData);
  }
  he->clientData = (ClientData )ns_strdup((char const   *)type);
  Tcl_DStringFree(& ds);
  return;
}
}
static char *LowerDString___0(Tcl_DString *dsPtr , char *ext ) 
{ int __res ;
  __int32_t const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  Tcl_DStringAppend(dsPtr, ext, -1);
  ext = dsPtr->string;
  while ((int )(*ext) != 0) {
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + (int )((unsigned char )(*ext)))) & 256) {
      if (sizeof((unsigned char )(*ext)) > 1U) {
        __res = tolower__extinline((int )((unsigned char )(*ext)));
      } else {
        tmp___1 = __ctype_tolower_loc();
        __res = (*((*tmp___1) + (int )((unsigned char )(*ext))));
      }
      (*ext) = (char )__res;
    }
    ext ++;
  }
  return (dsPtr->string);
}
}
static Tcl_HashTable modulesTable___0  ;
static void *DlOpen___0(char *file___1 ) ;
static void *DlSym___0(void *handle , char *name ) ;
static void *DlSym2___0(void *handle , char *name ) ;
static char *DlError___0(void) ;
static Module *firstPtr___0  ;
static void *DlOpen___0(char *file___1 ) 
{ void *tmp ;

  {
  tmp = dlopen((char const   *)file___1, 258);
  return (tmp);
}
}
static void *DlSym___0(void *handle , char *name ) 
{ Tcl_DString ds ;
  void *symbol ;

  {
  symbol = DlSym2___0(handle, name);
  if ((unsigned int )symbol == (unsigned int )((void *)0)) {
    Tcl_DStringInit(& ds);
    Ns_DStringVarAppend(& ds, "_", name, (void *)0);
    symbol = DlSym2___0(handle, ds.string);
    Tcl_DStringFree(& ds);
  }
  return (symbol);
}
}
static void *DlSym2___0(void *handle , char *name ) 
{ void *symbol ;

  {
  symbol = (void *)0;
  symbol = dlsym((void * __restrict  )handle, (char const   * __restrict  )name);
  return (symbol);
}
}
static char *DlError___0(void) 
{ char *tmp ;

  {
  tmp = dlerror();
  return (tmp);
}
}
static int GetInt___0(char *key___1 , int def ) ;
static int GetBool___0(char *key___1 , int def ) ;
static char cwd___0[4096]  ;
static int GetInt___0(char *key___1 , int def ) 
{ int i ;
  int tmp ;

  {
  tmp = Ns_ConfigGetInt((char *)"ns/parameters", key___1, & i);
  if (tmp) {
    if (i < 0) {
      i = def;
    }
  } else {
    i = def;
  }
  return (i);
}
}
static int GetBool___0(char *key___1 , int def ) 
{ int i ;
  int tmp ;

  {
  tmp = Ns_ConfigGetBool((char *)"ns/parameters", key___1, & i);
  if (! tmp) {
    i = def;
  }
  return (i);
}
}
static void UsageError___0(char *msg ) ;
static void StatusMsg___0(int state ) ;
static char *FindConfig___0(char *config ) ;
static void StatusMsg___0(int state ) 
{ char *what ;
  char *tmp ;
  char *tmp___0 ;
  __gid_t tmp___1 ;
  __gid_t tmp___2 ;
  __uid_t tmp___3 ;
  __uid_t tmp___4 ;

  {
  switch (state) {
  case 0: 
  what = (char *)"starting";
  break;
  case 1: 
  what = (char *)"running";
  break;
  case 2: 
  what = (char *)"stopping";
  break;
  case 3: 
  what = (char *)"exiting";
  break;
  default: 
  what = (char *)"unknown";
  break;
  }
  tmp = Ns_InfoServerVersion();
  tmp___0 = Ns_InfoServerName();
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"nsmain: %s/%s %s", tmp___0,
         tmp, what);
  if (state < 2) {
    tmp___1 = getegid();
    tmp___2 = getgid();
    tmp___3 = geteuid();
    tmp___4 = getuid();
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"nsmain: security info: uid=%d, euid=%d, gid=%d, egid=%d",
           tmp___4, tmp___3, tmp___2, tmp___1);
  }
  return;
}
}
static void UsageError___0(char *msg ) 
{ int tmp ;

  {
  if ((unsigned int )msg != (unsigned int )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nError: %s\n",
            msg);
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nUsage: %s [-h|V] [-i|f] [-u <user>] [-g <group>] [-r <path>] [-b <address:port>|-B <file>] [-s <server>] -t <file>\n\n  -h  help (this message)\n  -V  version and release information\n  -i  inittab mode\n  -f  foreground mode\n  -d  debugger-friendly mode (ignore SIGINT)\n  -u  run as <user>\n  -g  run as <group>\n  -r  chroot to <path>\n  -b  bind <address:port>\n  -B  bind address:port list from <file>\n  -s  use server named <server> in config file\n  -t  read config from <file> (REQUIRED)\n\n",
          nsconf.argv0);
  if (msg) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  exit(tmp);
}
}
static char *FindConfig___0(char *config ) 
{ Tcl_DString ds1 ;
  Tcl_DString ds2 ;
  char cwd___1[4096] ;
  int tmp ;
  char *tmp___0 ;

  {
  Tcl_DStringInit(& ds1);
  Tcl_DStringInit(& ds2);
  tmp = Ns_PathIsAbsolute(config);
  if (! tmp) {
    tmp___0 = getcwd(cwd___1, sizeof(cwd___1));
    if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
      Ns_MakePath(& ds2, cwd___1, config, (void *)0);
      config = ds2.string;
    }
  }
  Ns_NormalizePath(& ds1, config);
  config = Ns_DStringExport(& ds1);
  Tcl_DStringFree(& ds2);
  return (config);
}
}
static void FreeReq___0(void *arg ) ;
static Ns_Mutex ulock___0  ;
static int uid___0  ;
static void FreeReq___0(void *arg ) 
{ Req *reqPtr ;

  {
  reqPtr = (Req *)arg;
  reqPtr->refcnt = reqPtr->refcnt - 1;
  if (reqPtr->refcnt == 0) {
    if ((unsigned int )reqPtr->delete != (unsigned int )((void *)0)) {
      ((*(reqPtr->delete)))(reqPtr->arg);
    }
    ns_free((void *)reqPtr);
  }
  return;
}
}
static char *MakePath___0(Tcl_DString *dest , va_list *pap ) ;
static char *MakePath___0(Tcl_DString *dest , va_list *pap ) 
{ char *s ;
  int len ;
  char temp ;
  unsigned short const   **tmp ;

  {
  while (1) {
    s = __builtin_va_arg((*pap), char *);
    if (! ((unsigned int )s != (unsigned int )((void *)0))) {
      break;
    }
    tmp = __ctype_b_loc();
    if ((int const   )(*((*tmp) + (int )(*s))) & 1024) {
      if ((int )(*(s + 1)) == 58) {
        temp = (*(s + 2));
        (*(s + 2)) = (char)0;
        Tcl_DStringAppend(dest, s, 2);
        (*(s + 2)) = temp;
        s += 2;
      }
    }
    while ((*s)) {
      while (1) {
        if (! ((int )(*s) == 47)) {
          if (! ((int )(*s) == 92)) {
            break;
          }
        }
        s ++;
      }
      if ((*s)) {
        Tcl_DStringAppend(dest, (char *)"/", 1);
        len = 0;
        while (1) {
          if ((int )(*(s + len)) != 0) {
            if ((int )(*(s + len)) == 47) {
              break;
            } else {
              if ((int )(*(s + len)) == 92) {
                break;
              }
            }
          } else {
            break;
          }
          len ++;
        }
        Tcl_DStringAppend(dest, s, len);
        s += len;
      }
    }
  }
  return (dest->string);
}
}
static char *GetFile___0(char *procname ) ;
static char *file___0  ;
static char *GetFile___0(char *procname ) 
{ Tcl_DString ds ;

  {
  if ((unsigned int )file___0 == (unsigned int )((void *)0)) {
    file___0 = Ns_ConfigGetValue((char *)"ns/parameters", (char *)"pidfile");
    if ((unsigned int )file___0 == (unsigned int )((void *)0)) {
      Tcl_DStringInit(& ds);
      Ns_HomePath(& ds, "log/nspid.", (void *)0);
      Tcl_DStringAppend(& ds, procname, -1);
      file___0 = Ns_DStringExport(& ds);
    }
  }
  return (file___0);
}
}
static void AppendAddr___0(Tcl_DString *dsPtr , char *prefix , void *addr ) ;
static Tcl_HashTable info___0  ;
static struct Info nullInfo___0  =    {(Ns_ArgProc *)((void *)0), (char *)((void *)0)};
static void AppendAddr___0(Tcl_DString *dsPtr , char *prefix , void *addr ) 
{ char buf[30] ;

  {
  if ((unsigned int )addr == (unsigned int )((void *)0)) {
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%s:0x0", prefix);
  } else {
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%s:%p", prefix,
            addr);
  }
  Tcl_DStringAppendElement(dsPtr, buf);
  return;
}
}
static void ConnRun___0(Conn *connPtr ) ;
static void ParseAuth___0(Conn *connPtr , char *auth ) ;
static void CreateConnThread___0(ConnPool *poolPtr ) ;
static void JoinConnThread___0(Ns_Thread *threadPtr ) ;
static void AppendConn___0(Tcl_DString *dsPtr , Conn *connPtr , char *state ) ;
static void AppendConnList___0(Tcl_DString *dsPtr , Conn *firstPtr___1 , char *state ) ;
static Ns_Tls argtls___0  ;
static int poolid___0  ;
static char *opts___19[9]  = 
  {      (char *)"active",      (char *)"all",      (char *)"connections",      (char *)"keepalive", 
        (char *)"pools",      (char *)"queued",      (char *)"threads",      (char *)"waiting", 
        (char *)((void *)0)};
static void ConnRun___0(Conn *connPtr ) 
{ Ns_Conn *conn ;
  NsServer *servPtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  FormFile *filePtr ;
  int i ;
  int status ;
  char *auth ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  conn = (Ns_Conn *)connPtr;
  servPtr = connPtr->servPtr;
  connPtr->reqPtr = NsGetRequest(connPtr->sockPtr);
  if ((unsigned int )connPtr->reqPtr == (unsigned int )((void *)0)) {
    Ns_ConnClose(conn);
    return;
  }
  connPtr->contentLength = (connPtr->reqPtr)->length;
  connPtr->headers = (connPtr->reqPtr)->headers;
  connPtr->request = (connPtr->reqPtr)->request;
  connPtr->flags = 0;
  connPtr->nContentSent = 0;
  connPtr->responseStatus = 0;
  connPtr->responseLength = 0;
  connPtr->recursionCount = 0;
  connPtr->encoding = servPtr->encoding.outputEncoding;
  connPtr->urlEncoding = servPtr->encoding.urlEncoding;
  Tcl_DStringInit(& connPtr->queued);
  Tcl_InitHashTable(& connPtr->files, 0);
  sprintf((char * __restrict  )(connPtr->idstr), (char const   * __restrict  )"cns%d",
          connPtr->id);
  connPtr->outputheaders = Ns_SetCreate((char *)((void *)0));
  if ((connPtr->request)->version < 1.0) {
    conn->flags = conn->flags | 2;
  }
  if ((int )servPtr->opts.hdrcase != 0) {
    i = 0;
    while (i < (connPtr->headers)->size) {
      if ((int )servPtr->opts.hdrcase == 1) {
        Ns_StrToLower(((connPtr->headers)->fields + i)->name);
      } else {
        Ns_StrToUpper(((connPtr->headers)->fields + i)->name);
      }
      i ++;
    }
  }
  auth = Ns_SetIGet(connPtr->headers, (char *)"authorization");
  if ((unsigned int )auth != (unsigned int )((void *)0)) {
    ParseAuth___0(connPtr, auth);
  }
  if ((conn->request)->method) {
    if ((int )(*((conn->request)->method)) == (int )(*"HEAD")) {
      if (0) {
        __s1_len = strlen((char const   *)(conn->request)->method);
        __s2_len = strlen("HEAD");
        if (! ((unsigned int )((void const   *)((conn->request)->method + 1)) - (unsigned int )((void const   *)(conn->request)->method) ==
               1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("HEAD" + 1)) - (unsigned int )((void const   *)"HEAD") ==
                   1U)) {
              tmp___6 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___6 = 1;
              } else {
                tmp___6 = 0;
              }
            }
          } else {
            tmp___6 = 0;
          }
        }
        if (tmp___6) {
          if (__s1_len < __s2_len) {
            tmp___4 = __s1_len;
          } else {
            tmp___4 = __s2_len;
          }
          tmp___3 = memcmp((void const   *)((char const   *)(conn->request)->method),
                           (void const   *)"HEAD", tmp___4 + 1U);
        } else {
          tmp___5 = strcmp((char const   *)(conn->request)->method, "HEAD");
          tmp___3 = tmp___5;
        }
      } else {
        tmp___5 = strcmp((char const   *)(conn->request)->method, "HEAD");
        tmp___3 = tmp___5;
      }
      if (tmp___3 == 0) {
        conn->flags = conn->flags | 4;
      }
    }
  }
  if ((unsigned int )(connPtr->request)->protocol != (unsigned int )((void *)0)) {
    if ((unsigned int )(connPtr->request)->host != (unsigned int )((void *)0)) {
      status = NsConnRunProxyRequest((Ns_Conn *)connPtr);
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    status = NsRunFilters(conn, 1);
    if (status == 0) {
      status = Ns_AuthorizeRequest(servPtr->server, (connPtr->request)->method, (connPtr->request)->url,
                                   connPtr->authUser, connPtr->authPasswd, (connPtr->reqPtr)->peer);
      switch (status) {
      case 0: 
      status = NsRunFilters(conn, 2);
      if (status == 0) {
        status = Ns_ConnRunRequest(conn);
      }
      break;
      case -3: 
      Ns_ConnReturnForbidden(conn);
      break;
      case -2: 
      Ns_ConnReturnUnauthorized(conn);
      break;
      case -1: ;
      default: 
      Ns_ConnReturnInternalError(conn);
      break;
      }
    } else {
      if (status != -5) {
        Ns_ConnReturnInternalError(conn);
        status = -5;
      }
    }
  }
  Ns_ConnClose(conn);
  if (status == 0) {
    goto _L___2;
  } else {
    if (status == -5) {
      _L___2: 
      status = NsRunFilters(conn, 4);
      if (status == 0) {
        NsRunFilters(conn, 8);
        NsRunTraces(conn);
      }
    }
  }
  NsRunCleanups(conn);
  NsClsCleanup(connPtr);
  Ns_FreeConnInterp(conn);
  if ((unsigned int )connPtr->authUser != (unsigned int )((void *)0)) {
    ns_free((void *)connPtr->authUser);
    connPtr->authPasswd = (char *)((void *)0);
    connPtr->authUser = connPtr->authPasswd;
  }
  if ((unsigned int )connPtr->query != (unsigned int )((void *)0)) {
    Ns_SetFree(connPtr->query);
    connPtr->query = (Ns_Set *)((void *)0);
  }
  hPtr = Tcl_FirstHashEntry(& connPtr->files, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    filePtr = (FormFile *)hPtr->clientData;
    Ns_SetFree(filePtr->hdrs);
    ns_free((void *)filePtr);
    hPtr = Tcl_NextHashEntry(& search);
  }
  Tcl_DeleteHashTable(& connPtr->files);
  Tcl_DStringFree(& connPtr->queued);
  Ns_SetFree(connPtr->outputheaders);
  connPtr->outputheaders = (Ns_Set *)((void *)0);
  NsFreeRequest(connPtr->reqPtr);
  connPtr->reqPtr = (struct Request *)((void *)0);
  return;
}
}
static void ParseAuth___0(Conn *connPtr , char *auth ) 
{ register char *p ;
  register char *q ;
  int n ;
  char save ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  p = auth;
  while (1) {
    if ((int )(*p) != 0) {
      tmp = __ctype_b_loc();
      if ((int const   )(*((*tmp) + (int )((unsigned char )(*p)))) & 8192) {
        break;
      }
    } else {
      break;
    }
    p ++;
  }
  if ((int )(*p) != 0) {
    save = (*p);
    (*p) = (char )'\000';
    tmp___5 = strcasecmp((char const   *)auth, "Basic");
    if (tmp___5 == 0) {
      q = p + 1;
      while (1) {
        if ((int )(*q) != 0) {
          tmp___0 = __ctype_b_loc();
          if (! ((int const   )(*((*tmp___0) + (int )((unsigned char )(*q)))) & 8192)) {
            break;
          }
        } else {
          break;
        }
        q ++;
      }
      tmp___1 = strlen((char const   *)q);
      n = (int )(tmp___1 + 3U);
      connPtr->authUser = (char *)ns_malloc((unsigned int )n);
      n = Ns_HtuuDecode(q, (unsigned char *)connPtr->authUser, n);
      (*(connPtr->authUser + n)) = (char )'\000';
      tmp___3 = strchr((char const   *)connPtr->authUser, ':');
      q = tmp___3;
      if ((unsigned int )q != (unsigned int )((void *)0)) {
        tmp___4 = q;
        q ++;
        (*tmp___4) = (char )'\000';
        connPtr->authPasswd = q;
      }
    }
    (*p) = save;
  }
  return;
}
}
static void CreateConnThread___0(ConnPool *poolPtr ) 
{ Ns_Thread thread ;
  Arg *argPtr ;

  {
  argPtr = (Arg *)ns_malloc(sizeof(Arg ));
  argPtr->poolPtr = poolPtr;
  argPtr->connPtr = (Conn *)((void *)0);
  Ns_ThreadCreate(& NsConnThread, (void *)argPtr, 0L, & thread);
  return;
}
}
static void JoinConnThread___0(Ns_Thread *threadPtr ) 
{ Arg *argPtr ;

  {
  Ns_ThreadJoin(threadPtr, (void **)(& argPtr));
  ns_free((void *)argPtr);
  return;
}
}
static void AppendConn___0(Tcl_DString *dsPtr , Conn *connPtr , char *state ) 
{ char buf[100] ;
  char *p ;
  Ns_Time now ;
  Ns_Time diff ;
  char *tmp ;
  char *tmp___6 ;
  char *tmp___13 ;

  {
  Tcl_DStringStartSublist(dsPtr);
  if ((unsigned int )connPtr != (unsigned int )((void *)0)) {
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", connPtr->id);
    Tcl_DStringAppendElement(dsPtr, buf);
    tmp = Ns_ConnPeer((Ns_Conn *)connPtr);
    Tcl_DStringAppendElement(dsPtr, tmp);
    Tcl_DStringAppendElement(dsPtr, state);
    if (connPtr->request) {
      if ((connPtr->request)->method) {
        p = (connPtr->request)->method;
      } else {
        p = (char *)"?";
      }
    } else {
      p = (char *)"?";
    }
    tmp___6 = strncpy((char * __restrict  )(buf), (char const   * __restrict  )p,
                      sizeof(buf));
    Tcl_DStringAppendElement(dsPtr, tmp___6);
    if (connPtr->request) {
      if ((connPtr->request)->url) {
        p = (connPtr->request)->url;
      } else {
        p = (char *)"?";
      }
    } else {
      p = (char *)"?";
    }
    tmp___13 = strncpy((char * __restrict  )(buf), (char const   * __restrict  )p,
                       sizeof(buf));
    Tcl_DStringAppendElement(dsPtr, tmp___13);
    Ns_GetTime(& now);
    Ns_DiffTime(& now, & connPtr->startTime, & diff);
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%ld.%ld", diff.sec,
            diff.usec);
    Tcl_DStringAppendElement(dsPtr, buf);
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", connPtr->nContentSent);
    Tcl_DStringAppendElement(dsPtr, buf);
  }
  Tcl_DStringEndSublist(dsPtr);
  return;
}
}
static void AppendConnList___0(Tcl_DString *dsPtr , Conn *firstPtr___1 , char *state ) 
{ 

  {
  while ((unsigned int )firstPtr___1 != (unsigned int )((void *)0)) {
    AppendConn___0(dsPtr, firstPtr___1, state);
    firstPtr___1 = firstPtr___1->nextPtr;
  }
  return;
}
}
static void CounterThread___0(void *ignored ) ;
static unsigned long TrueRand___0(void) ;
static unsigned long Roulette___0(void) ;
static unsigned long volatile   counter___0  ;
static char volatile   fRun___0  ;
static char volatile   fCount___0  ;
static Ns_Sema sema___0  ;
static Ns_Cs lock___24  ;
static int volatile   initialized___2  ;
static void CounterThread___0(void *ignored ) 
{ 

  {
  while (fRun___0) {
    Ns_SemaWait(& sema___0);
    if (fRun___0) {
      while (fCount___0) {
        counter___0 ++;
      }
    }
  }
  return;
}
}
static unsigned long TrueRand___0(void) 
{ int i ;
  unsigned long tmp ;

  {
  i = 0;
  while (i < 10) {
    Roulette___0();
    i ++;
  }
  tmp = Roulette___0();
  return (tmp);
}
}
static unsigned long ocount___0  ;
static unsigned long randbuf___0  ;
static unsigned long Roulette___0(void) 
{ struct timeval tv ;

  {
  counter___0 = (unsigned long volatile   )0;
  fCount___0 = (char volatile   )1;
  Ns_SemaPost(& sema___0, 1);
  tv.tv_sec = 0L;
  tv.tv_usec = 31000L;
  select(0, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )((void *)0),
         (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& tv));
  fCount___0 = (char volatile   )0;
  counter___0 ^= ((counter___0 >> 3) ^ (counter___0 >> 6)) ^ (unsigned long volatile   )ocount___0;
  counter___0 &= 7UL;
  ocount___0 = (unsigned long )counter___0;
  randbuf___0 = (randbuf___0 << 3) ^ (unsigned long )counter___0;
  return (randbuf___0);
}
}
static void SetUrl___0(Ns_Request *request , char *url ) ;
static void FreeUrl___0(Ns_Request *request ) ;
static void FreeUrl___0(Ns_Request *request ) 
{ 

  {
  if ((unsigned int )request->url != (unsigned int )((void *)0)) {
    ns_free((void *)request->url);
    request->url = (char *)((void *)0);
  }
  if ((unsigned int )request->urlv != (unsigned int )((void *)0)) {
    ns_free((void *)(*(request->urlv + 0)));
    ns_free((void *)request->urlv);
    request->urlv = (char **)((void *)0);
  }
  return;
}
}
static void SetUrl___0(Ns_Request *request , char *url ) 
{ Tcl_DString ds1 ;
  Tcl_DString ds2 ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
  Tcl_DStringInit(& ds1);
  Tcl_DStringInit(& ds2);
  tmp___0 = strchr((char const   *)url, '?');
  p = tmp___0;
  if ((unsigned int )p != (unsigned int )((void *)0)) {
    tmp___1 = p;
    p ++;
    (*tmp___1) = (char )'\000';
    if ((unsigned int )request->query != (unsigned int )((void *)0)) {
      ns_free((void *)request->query);
    }
    request->query = ns_strdup((char const   *)p);
  }
  p = Ns_DecodeUrlCharset(& ds1, url, (char *)((void *)0));
  if ((unsigned int )p == (unsigned int )((void *)0)) {
    p = url;
  }
  Ns_NormalizePath(& ds2, p);
  Tcl_DStringSetLength(& ds1, 0);
  while ((int )(*url) == 47) {
    url ++;
  }
  if ((int )(*url) != 0) {
    tmp___2 = strlen((char const   *)url);
    if ((int )(*(url + (tmp___2 - 1U))) == 47) {
      Tcl_DStringAppend(& ds2, (char *)"/", -1);
    }
  }
  request->url = ns_strdup((char const   *)ds2.string);
  Tcl_DStringFree(& ds2);
  p = ns_strdup((char const   *)(request->url + 1));
  Tcl_DStringAppend(& ds1, (char *)(& p), (int )sizeof(char *));
  while ((int )(*p) != 0) {
    if ((int )(*p) == 47) {
      tmp___3 = p;
      p ++;
      (*tmp___3) = (char )'\000';
      if ((int )(*p) == 0) {
        break;
      }
      Tcl_DStringAppend(& ds1, (char *)(& p), (int )sizeof(char *));
    }
    p ++;
  }
  request->urlc = (int )((unsigned int )ds1.length / sizeof(char *));
  p = (char *)((void *)0);
  Tcl_DStringAppend(& ds1, (char *)(& p), (int )sizeof(char *));
  request->urlv = (char **)ns_malloc((unsigned int )ds1.length);
  memcpy((void * __restrict  )request->urlv, (void const   * __restrict  )ds1.string,
         (unsigned int )ds1.length);
  Tcl_DStringFree(& ds1);
  return;
}
}
static int ReturnRedirect___0(Ns_Conn *conn , int status , int *resultPtr ) ;
static int ReturnOpen___0(Ns_Conn *conn , int status , char *type , Tcl_Channel chan ,
                          FILE *fp , int fd , int len ) ;
static int ReturnCharData___0(Ns_Conn *conn , int status , char *data , int len ,
                              char *type , int sendRaw ) ;
static struct __anonstruct_reasons_107___0 reasons___0[47]  = 
  {      {100, (char *)"Continue"}, 
        {101, (char *)"Switching Protocols"}, 
        {102, (char *)"Processing"}, 
        {200, (char *)"OK"}, 
        {201, (char *)"Created"}, 
        {202, (char *)"Accepted"}, 
        {203, (char *)"Non-Authoritative Information"}, 
        {204, (char *)"No Content"}, 
        {205, (char *)"Reset Content"}, 
        {206, (char *)"Partial Content"}, 
        {207, (char *)"Multi-Status"}, 
        {300, (char *)"Multiple Choices"}, 
        {301, (char *)"Moved"}, 
        {302, (char *)"Found"}, 
        {303, (char *)"See Other"}, 
        {304, (char *)"Not Modified"}, 
        {305, (char *)"Use Proxy"}, 
        {307, (char *)"Temporary Redirect"}, 
        {400, (char *)"Bad Request"}, 
        {401, (char *)"Unauthorized"}, 
        {402, (char *)"Payment Required"}, 
        {403, (char *)"Forbidden"}, 
        {404, (char *)"Not Found"}, 
        {405, (char *)"Method Not Allowed"}, 
        {406, (char *)"Not Acceptable"}, 
        {407, (char *)"Proxy Authentication Required"}, 
        {408, (char *)"Request Timeout"}, 
        {409, (char *)"Conflict"}, 
        {410, (char *)"Gone"}, 
        {411, (char *)"Length Required"}, 
        {412, (char *)"Precondition Failed"}, 
        {413, (char *)"Request Entity Too Large"}, 
        {414, (char *)"Request-URI Too Long"}, 
        {415, (char *)"Unsupported Media Type"}, 
        {416, (char *)"Requested Range Not Satisfiable"}, 
        {417, (char *)"Expectation Failed"}, 
        {422, (char *)"Unprocessable Entity"}, 
        {423, (char *)"Locked"}, 
        {424, (char *)"Method Failure"}, 
        {425, (char *)"Insufficient Space On Resource"}, 
        {500, (char *)"Internal Server Error"}, 
        {501, (char *)"Not Implemented"}, 
        {502, (char *)"Bad Gateway"}, 
        {503, (char *)"Service Unavailable"}, 
        {504, (char *)"Gateway Timeout"}, 
        {505, (char *)"HTTP Version Not Supported"}, 
        {507, (char *)"Insufficient Storage"}};
static int nreasons___0  =    (int )(sizeof(reasons___0) / sizeof(reasons___0[0]));
static int IsSetupForChunkedEncoding___0(Ns_Conn *conn ) 
{ int headerCount ;
  int i ;
  Ns_Set *outHeaders ;
  int tmp ;
  int tmp___0 ;

  {
  headerCount = 0;
  if ((unsigned int )conn == (unsigned int )((void *)0)) {
    return (0);
  }
  outHeaders = Ns_ConnOutputHeaders(conn);
  headerCount = outHeaders->size;
  if (outHeaders) {
    if (headerCount) {
      i = 0;
      while (i < headerCount) {
        tmp = strcasecmp((char const   *)(outHeaders->fields + i)->name, "Transfer-Encoding");
        if (! tmp) {
          tmp___0 = strcasecmp((char const   *)(outHeaders->fields + i)->value, "chunked");
          if (! tmp___0) {
            return (1);
          }
        }
        i ++;
      }
    }
  }
  return (0);
}
}
static int ReturnCharData___0(Ns_Conn *conn , int status , char *data , int len ,
                              char *type , int sendRaw ) 
{ int result ;
  Conn *connPtr ;
  Tcl_DString ds ;
  Tcl_Encoding enc___0 ;
  Tcl_DString type_ds ;
  int new_type ;

  {
  new_type = 0;
  connPtr = (Conn *)conn;
  if (! sendRaw) {
    NsComputeEncodingFromType(type, & enc___0, & new_type, & type_ds);
    if (new_type) {
      type = type_ds.string;
    }
    if ((unsigned int )enc___0 != (unsigned int )((void *)0)) {
      connPtr->encoding = enc___0;
    } else {
      if ((unsigned int )connPtr->encoding == (unsigned int )((void *)0)) {
        sendRaw = 1;
      }
    }
  }
  if (! sendRaw) {
    Tcl_UtfToExternalDString(connPtr->encoding, data, len, & ds);
    data = ds.string;
    len = ds.length;
  } else {
    if (len == -1) {
      if (data) {
        len = (int )strlen((char const   *)data);
      } else {
        len = 0;
      }
    }
  }
  Ns_ConnSetRequiredHeaders(conn, type, len);
  Ns_ConnQueueHeaders(conn, status);
  if (conn->flags & 4) {
    data = (char *)((void *)0);
    len = 0;
  }
  result = Ns_WriteConn(conn, data, len);
  if (result == 0) {
    result = Ns_ConnClose(conn);
  }
  if (! sendRaw) {
    if ((unsigned int )connPtr->encoding != (unsigned int )((void *)0)) {
      Tcl_DStringFree(& ds);
    }
  }
  if (new_type) {
    Tcl_DStringFree(& type_ds);
  }
  return (result);
}
}
static int ReturnRedirect___0(Ns_Conn *conn , int status , int *resultPtr ) 
{ Tcl_HashEntry *hPtr ;
  Conn *connPtr ;
  NsServer *servPtr ;

  {
  connPtr = (Conn *)conn;
  servPtr = connPtr->servPtr;
  hPtr = ((*(servPtr->request.redirect.findProc)))(& servPtr->request.redirect, (char *)status);
  if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    connPtr->recursionCount = connPtr->recursionCount + 1;
    if (connPtr->recursionCount > 3) {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"return: failed to redirect \'%d\': exceeded recursion limit of %d",
             status, 3);
    } else {
      (*resultPtr) = Ns_ConnRedirect(conn, (char *)hPtr->clientData);
      return (1);
    }
  }
  return (0);
}
}
static int ReturnOpen___0(Ns_Conn *conn , int status , char *type , Tcl_Channel chan ,
                          FILE *fp , int fd , int len ) 
{ int result ;

  {
  Ns_ConnSetRequiredHeaders(conn, type, len);
  Ns_ConnQueueHeaders(conn, status);
  if ((unsigned int )chan != (unsigned int )((void *)0)) {
    result = Ns_ConnSendChannel(conn, chan, len);
  } else {
    if ((unsigned int )fp != (unsigned int )((void *)0)) {
      result = Ns_ConnSendFp(conn, fp, len);
    } else {
      result = Ns_ConnSendFd(conn, fd, len);
    }
  }
  if (result == 0) {
    result = Ns_ConnClose(conn);
  }
  return (result);
}
}
static int AppendFile___0(Tcl_DString *dsPtr , char *dir , char *tail ) ;
static int CmpFile___0(void const   *arg1 , void const   *arg2 ) ;
static int Rename___0(char *from , char *to ) ;
static int Exists___0(char *file___1 ) ;
static int Unlink___0(char *file___1 ) ;
static int AppendFile___0(Tcl_DString *dsPtr , char *dir , char *tail ) 
{ File___0 *fPtr ;
  struct stat st ;
  size_t tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  tmp = strlen((char const   *)dir);
  tmp___0 = strlen((char const   *)tail);
  fPtr = (File___0 *)ns_malloc((sizeof(File___0 ) + tmp) + tmp___0);
  sprintf((char * __restrict  )(fPtr->name), (char const   * __restrict  )"%s/%s",
          dir, tail);
  tmp___3 = stat__extinline((char const   *)(fPtr->name), & st);
  if (tmp___3 != 0) {
    tmp___1 = __errno_location();
    tmp___2 = strerror((*tmp___1));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"rollfile: failed to append to file \'%s\': \'%s\'",
           fPtr->name, tmp___2);
    ns_free((void *)fPtr);
    return (0);
  }
  fPtr->mtime = st.st_mtim.tv_sec;
  Tcl_DStringAppend(dsPtr, (char *)(& fPtr), (int )sizeof(File___0 *));
  return (1);
}
}
static int CmpFile___0(void const   *arg1 , void const   *arg2 ) 
{ File___0 *f1Ptr ;
  File___0 *f2Ptr ;

  {
  f1Ptr = (*((File___0 **)arg1));
  f2Ptr = (*((File___0 **)arg2));
  if (f1Ptr->mtime < f2Ptr->mtime) {
    return (1);
  } else {
    if (f1Ptr->mtime > f2Ptr->mtime) {
      return (-1);
    }
  }
  return (0);
}
}
static int Unlink___0(char *file___1 ) 
{ int err ;
  int *tmp ;
  char *tmp___0 ;

  {
  err = unlink((char const   *)file___1);
  if (err != 0) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"rollfile: failed to delete file \'%s\': \'%s\'",
           file___1, tmp___0);
  }
  return (err);
}
}
static int Rename___0(char *from , char *to ) 
{ int err ;
  int *tmp ;
  char *tmp___0 ;

  {
  err = rename((char const   *)from, (char const   *)to);
  if (err != 0) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"rollfile: failed to rename file \'%s\' to \'%s\': \'%s\'",
           from, to, tmp___0);
  }
  return (err);
}
}
static int Exists___0(char *file___1 ) 
{ int exists ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  tmp___2 = access((char const   *)file___1, 0);
  if (tmp___2 == 0) {
    exists = 1;
  } else {
    tmp___1 = __errno_location();
    if ((*tmp___1) == 2) {
      exists = 0;
    } else {
      tmp = __errno_location();
      tmp___0 = strerror((*tmp));
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"rollfile: failed to determine if file \'%s\' exists: \'%s\'",
             file___1, tmp___0);
      exists = -1;
    }
  }
  return (exists);
}
}
static void SchedThread___0(void *ignored ) ;
static void EventThread___0(void *arg ) ;
static void QueueEvent___0(Event *ePtr , time_t *nowPtr ) ;
static Event *DeQueueEvent___0(int k ) ;
static void FreeEvent___0(Event *ePtr ) ;
static Tcl_HashTable eventsTable___0  ;
static Ns_Mutex lock___25  ;
static Ns_Cond schedcond___0  ;
static Ns_Cond eventcond___0  ;
static Event **queue___0  ;
static int nqueue___0  ;
static int maxqueue___0  ;
static int running___1  ;
static int shutdownPending___5  ;
static Ns_Thread schedThread___0  ;
static int nThreads___0  ;
static int nIdleThreads___0  ;
static Event *threadEventPtr___0  ;
static Ns_Thread *eventThreads___0  ;
static int nextId___2  ;
static void QueueEvent___0(Event *ePtr , time_t *nowPtr ) 
{ struct tm *tp___1 ;
  int tmp ;
  int j ;
  int k ;
  Event *tmp___0 ;

  {
  if (ePtr->flags & 16) {
    return;
  }
  if (ePtr->flags & 12) {
    tp___1 = ns_localtime((time_t const   *)nowPtr);
    tp___1->tm_sec = ePtr->interval;
    tp___1->tm_hour = 0;
    tp___1->tm_min = 0;
    if (ePtr->flags & 8) {
      tp___1->tm_mday = tp___1->tm_mday - tp___1->tm_wday;
    }
    ePtr->nextqueue = mktime(tp___1);
    if (ePtr->nextqueue <= (*nowPtr)) {
      if (ePtr->flags & 8) {
        tmp = 7;
      } else {
        tmp = 1;
      }
      tp___1->tm_mday = tp___1->tm_mday + tmp;
      ePtr->nextqueue = mktime(tp___1);
    }
  } else {
    ePtr->nextqueue = (*nowPtr) + (long )ePtr->interval;
  }
  nqueue___0 ++;
  ePtr->qid = nqueue___0;
  if (maxqueue___0 <= nqueue___0) {
    maxqueue___0 += 1000;
    queue___0 = (Event **)ns_realloc((void *)queue___0, sizeof(Event *) * (unsigned int )(maxqueue___0 +
                                                                                          1));
  }
  (*(queue___0 + nqueue___0)) = ePtr;
  if (nqueue___0 > 1) {
    k = nqueue___0;
    j = k / 2;
    while (1) {
      if (k > 1) {
        if (! (((*(queue___0 + j)))->nextqueue > ((*(queue___0 + k)))->nextqueue)) {
          break;
        }
      } else {
        break;
      }
      tmp___0 = (*(queue___0 + j));
      (*(queue___0 + j)) = (*(queue___0 + k));
      (*(queue___0 + k)) = tmp___0;
      ((*(queue___0 + j)))->qid = j;
      ((*(queue___0 + k)))->qid = k;
      k = j;
      j = k / 2;
    }
  }
  if (running___1) {
    Ns_CondSignal(& schedcond___0);
  } else {
    running___1 = 1;
    Ns_ThreadCreate(& SchedThread___0, (void *)0, 0L, & schedThread___0);
  }
  return;
}
}
static Event *DeQueueEvent___0(int k ) 
{ Event *ePtr ;
  int j ;
  Event *tmp ;
  int tmp___0 ;
  Event *tmp___1 ;

  {
  tmp = (*(queue___0 + k));
  (*(queue___0 + k)) = (*(queue___0 + nqueue___0));
  (*(queue___0 + nqueue___0)) = tmp;
  ((*(queue___0 + k)))->qid = k;
  ((*(queue___0 + nqueue___0)))->qid = nqueue___0;
  tmp___0 = nqueue___0;
  nqueue___0 --;
  ePtr = (*(queue___0 + tmp___0));
  ePtr->qid = 0;
  while (1) {
    j = 2 * k;
    if (! (j <= nqueue___0)) {
      break;
    }
    if (j < nqueue___0) {
      if (((*(queue___0 + j)))->nextqueue > ((*(queue___0 + (j + 1))))->nextqueue) {
        j ++;
      }
    }
    if (((*(queue___0 + j)))->nextqueue > ((*(queue___0 + k)))->nextqueue) {
      break;
    }
    tmp___1 = (*(queue___0 + k));
    (*(queue___0 + k)) = (*(queue___0 + j));
    (*(queue___0 + j)) = tmp___1;
    ((*(queue___0 + k)))->qid = k;
    ((*(queue___0 + j)))->qid = j;
    k = j;
  }
  return (ePtr);
}
}
static void EventThread___0(void *arg ) 
{ Event *ePtr ;
  char name[20] ;
  char idle[20] ;
  time_t now ;

  {
  sprintf((char * __restrict  )(idle), (char const   * __restrict  )"-sched:idle%d-",
          (int )arg);
  Ns_ThreadSetName(idle);
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"starting");
  Ns_MutexLock(& lock___25);
  while (1) {
    while (1) {
      if ((unsigned int )threadEventPtr___0 == (unsigned int )((void *)0)) {
        if (! (! shutdownPending___5)) {
          break;
        }
      } else {
        break;
      }
      Ns_CondWait(& eventcond___0, & lock___25);
    }
    if ((unsigned int )threadEventPtr___0 == (unsigned int )((void *)0)) {
      break;
    }
    ePtr = threadEventPtr___0;
    threadEventPtr___0 = ePtr->nextPtr;
    if ((unsigned int )threadEventPtr___0 != (unsigned int )((void *)0)) {
      Ns_CondSignal(& eventcond___0);
    }
    nIdleThreads___0 --;
    Ns_MutexUnlock(& lock___25);
    sprintf((char * __restrict  )(name), (char const   * __restrict  )"-sched:%u-",
            ePtr->id);
    Ns_ThreadSetName(name);
    ((*(ePtr->proc)))(ePtr->arg, (int )ePtr->id);
    Ns_ThreadSetName(idle);
    time(& now);
    Ns_MutexLock(& lock___25);
    nIdleThreads___0 ++;
    if ((unsigned int )ePtr->hPtr == (unsigned int )((void *)0)) {
      Ns_MutexUnlock(& lock___25);
      FreeEvent___0(ePtr);
      Ns_MutexLock(& lock___25);
    } else {
      ePtr->flags = ePtr->flags & -33;
      ePtr->lastend = now;
      QueueEvent___0(ePtr, & now);
    }
  }
  Ns_MutexUnlock(& lock___25);
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"exiting");
  return;
}
}
static void FreeEvent___0(Event *ePtr ) 
{ 

  {
  if ((unsigned int )ePtr->deleteProc != (unsigned int )((void *)0)) {
    ((*(ePtr->deleteProc)))(ePtr->arg, (int )ePtr->id);
  }
  ns_free((void *)ePtr);
  return;
}
}
static void SchedThread___0(void *ignored ) 
{ Event *ePtr ;
  Event *readyPtr ;
  time_t now ;
  Ns_Time timeout ;
  int elapsed ;
  Ns_Thread *joinThreads ;
  int nJoinThreads ;
  int tmp___0 ;

  {
  Ns_WaitForStartup();
  Ns_ThreadSetName((char *)"-sched-");
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"sched: starting");
  readyPtr = (Event *)((void *)0);
  Ns_MutexLock(& lock___25);
  while (! shutdownPending___5) {
    time(& now);
    while (1) {
      if (nqueue___0 > 0) {
        if (! (((*(queue___0 + 1)))->nextqueue <= now)) {
          break;
        }
      } else {
        break;
      }
      ePtr = DeQueueEvent___0(1);
      if (ePtr->flags & 2) {
        Tcl_DeleteHashEntry(ePtr->hPtr);
        ePtr->hPtr = (Tcl_HashEntry *)((void *)0);
      }
      ePtr->lastqueue = now;
      if (ePtr->flags & 1) {
        ePtr->flags = ePtr->flags | 32;
        ePtr->laststart = now;
        ePtr->nextPtr = threadEventPtr___0;
        threadEventPtr___0 = ePtr;
      } else {
        ePtr->nextPtr = readyPtr;
        readyPtr = ePtr;
      }
    }
    if ((unsigned int )threadEventPtr___0 != (unsigned int )((void *)0)) {
      if (nIdleThreads___0 == 0) {
        eventThreads___0 = (Ns_Thread *)ns_realloc((void *)eventThreads___0, sizeof(Ns_Thread ) *
                                                                             (unsigned int )(nThreads___0 +
                                                                                             1));
        Ns_ThreadCreate(& EventThread___0, (void *)nThreads___0, 0L, eventThreads___0 +
                                                                     nThreads___0);
        nIdleThreads___0 ++;
        nThreads___0 ++;
      }
      Ns_CondSignal(& eventcond___0);
    }
    while (1) {
      ePtr = readyPtr;
      if (! ((unsigned int )ePtr != (unsigned int )((void *)0))) {
        break;
      }
      readyPtr = ePtr->nextPtr;
      ePtr->laststart = now;
      ePtr->flags = ePtr->flags | 32;
      Ns_MutexUnlock(& lock___25);
      ((*(ePtr->proc)))(ePtr->arg, (int )ePtr->id);
      time(& now);
      elapsed = (int )difftime(now, ePtr->laststart);
      if (elapsed > nsconf.sched.maxelapsed) {
        Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"sched: excessive time taken by proc %d (%d seconds)",
               ePtr->id, elapsed);
      }
      if ((unsigned int )ePtr->hPtr == (unsigned int )((void *)0)) {
        FreeEvent___0(ePtr);
        ePtr = (Event *)((void *)0);
      }
      Ns_MutexLock(& lock___25);
      if ((unsigned int )ePtr != (unsigned int )((void *)0)) {
        ePtr->flags = ePtr->flags & -33;
        ePtr->lastend = now;
        QueueEvent___0(ePtr, & now);
      }
    }
    if (nqueue___0 == 0) {
      Ns_CondWait(& schedcond___0, & lock___25);
    } else {
      if (! shutdownPending___5) {
        timeout.sec = ((*(queue___0 + 1)))->nextqueue;
        timeout.usec = 0L;
        Ns_CondTimedWait(& schedcond___0, & lock___25, & timeout);
      }
    }
  }
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"sched: shutdown started");
  if (nThreads___0 > 0) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"sched: waiting for event threads...");
    Ns_CondBroadcast(& eventcond___0);
    while (nThreads___0 > 0) {
      joinThreads = eventThreads___0;
      nJoinThreads = nThreads___0;
      eventThreads___0 = (Ns_Thread *)((void *)0);
      nThreads___0 = 0;
      Ns_MutexUnlock(& lock___25);
      while (1) {
        nJoinThreads --;
        if (! (nJoinThreads >= 0)) {
          break;
        }
        Ns_ThreadJoin(joinThreads + nJoinThreads, (void **)((void *)0));
      }
      ns_free((void *)joinThreads);
      Ns_MutexLock(& lock___25);
    }
  }
  Ns_MutexUnlock(& lock___25);
  while (nqueue___0 > 0) {
    tmp___0 = nqueue___0;
    nqueue___0 --;
    FreeEvent___0((*(queue___0 + tmp___0)));
  }
  ns_free((void *)queue___0);
  Tcl_DeleteHashTable(& eventsTable___0);
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"sched: shutdown complete");
  Ns_MutexLock(& lock___25);
  running___1 = 0;
  Ns_CondBroadcast(& schedcond___0);
  Ns_MutexUnlock(& lock___25);
  return;
}
}
static void CreatePool___0(NsServer *servPtr , char *pool ) ;
static NsServer *initServPtr___0  ;
static void CreatePool___0(NsServer *servPtr , char *pool ) 
{ ConnPool *poolPtr ;
  Conn *connBufPtr ;
  Conn *connPtr ;
  int i ;
  int n ;
  int maxconns ;
  char *path ;
  Ns_Set *set ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  poolPtr = (ConnPool *)ns_calloc(1U, sizeof(ConnPool ));
  poolPtr->pool = pool;
  poolPtr->servPtr = servPtr;
  if ((int )(*pool) == 0) {
    path = Ns_ConfigGetPath(servPtr->server, (char *)((void *)0), (void *)0);
    servPtr->pools.defaultPtr = poolPtr;
  } else {
    path = Ns_ConfigGetPath(servPtr->server, (char *)((void *)0), "pool", pool, (void *)0);
    set = Ns_ConfigGetSection(path);
    i = 0;
    while (1) {
      if ((unsigned int )set != (unsigned int )((void *)0)) {
        if (! (i < set->size)) {
          break;
        }
      } else {
        break;
      }
      tmp = strcasecmp((char const   *)(set->fields + i)->name, "map");
      if (! tmp) {
        NsMapPool(poolPtr, (set->fields + i)->value);
      }
      i ++;
    }
  }
  poolPtr->nextPtr = servPtr->pools.firstPtr;
  servPtr->pools.firstPtr = poolPtr;
  tmp___0 = Ns_ConfigGetInt(path, (char *)"maxconnections", & maxconns);
  if (! tmp___0) {
    maxconns = 100;
  }
  connBufPtr = (Conn *)ns_calloc((unsigned int )maxconns, sizeof(Conn ));
  n = 0;
  while (n < maxconns - 1) {
    connPtr = connBufPtr + n;
    connPtr->nextPtr = connBufPtr + (n + 1);
    n ++;
  }
  (connBufPtr + n)->nextPtr = (struct Conn *)((void *)0);
  poolPtr->queue.freePtr = connBufPtr + 0;
  tmp___1 = Ns_ConfigGetInt(path, (char *)"minthreads", & poolPtr->threads.min);
  if (! tmp___1) {
    poolPtr->threads.min = 0;
  }
  tmp___2 = Ns_ConfigGetInt(path, (char *)"maxthreads", & poolPtr->threads.max);
  if (! tmp___2) {
    poolPtr->threads.max = 10;
  }
  tmp___3 = Ns_ConfigGetInt(path, (char *)"threadtimeout", & poolPtr->threads.timeout);
  if (! tmp___3) {
    poolPtr->threads.timeout = 120;
  }
  if (poolPtr->threads.max > maxconns) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"serv: cannot have more maxthreads than maxconns: %d max threads adjusted down to %d max connections",
           poolPtr->threads.max, maxconns);
    poolPtr->threads.max = maxconns;
  }
  if (poolPtr->threads.min > poolPtr->threads.max) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"serv: cannot have more minthreads than maxthreads: %d min threads adjusted down to %d max threads",
           poolPtr->threads.min, poolPtr->threads.max);
    poolPtr->threads.min = poolPtr->threads.max;
  }
  tmp___4 = Ns_ConfigGetInt(path, (char *)"minthreads", & poolPtr->threads.min);
  if (! tmp___4) {
    poolPtr->threads.min = 0;
  }
  tmp___5 = Ns_ConfigGetInt(path, (char *)"maxthreads", & poolPtr->threads.max);
  if (! tmp___5) {
    poolPtr->threads.max = 10;
  }
  tmp___6 = Ns_ConfigGetInt(path, (char *)"threadtimeout", & poolPtr->threads.timeout);
  if (! tmp___6) {
    poolPtr->threads.timeout = 120;
  }
  if (poolPtr->threads.max > maxconns) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"serv: cannot have more maxthreads than maxconns: %d max threads adjusted down to %d max connections",
           poolPtr->threads.max, maxconns);
    poolPtr->threads.max = maxconns;
  }
  if (poolPtr->threads.min > poolPtr->threads.max) {
    Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"serv: cannot have more minthreads than maxthreads: %d min threads adjusted down to %d max threads",
           poolPtr->threads.min, poolPtr->threads.max);
    poolPtr->threads.min = poolPtr->threads.max;
  }
  return;
}
}
static int SockConnect___0(char *host , int port , char *lhost , int lport , int async ) ;
static int SockSetup___0(int sock ) ;
static int SockConnect___0(char *host , int port , char *lhost , int lport , int async ) 
{ int sock ;
  struct sockaddr_in lsa ;
  struct sockaddr_in sa ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  tmp = Ns_GetSockAddr(& sa, host, port);
  if (tmp != 0) {
    return (-1);
  } else {
    tmp___0 = Ns_GetSockAddr(& lsa, lhost, lport);
    if (tmp___0 != 0) {
      return (-1);
    }
  }
  sock = Ns_SockBind(& lsa);
  if (sock != -1) {
    if (async) {
      Ns_SockSetNonBlocking(sock);
    }
    tmp___2 = connect(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& sa)),
                      sizeof(sa));
    if (tmp___2 != 0) {
      tmp___1 = __errno_location();
      err = (*tmp___1);
      if (! async) {
        close(sock);
        sock = -1;
      } else {
        if (err != 115) {
          if (err != 11) {
            close(sock);
            sock = -1;
          }
        }
      }
    }
    if (async) {
      if (sock != -1) {
        Ns_SockSetBlocking(sock);
      }
    }
  }
  return (sock);
}
}
static int CloseLater___0(int sock , void *arg , int why ) 
{ 

  {
  close(sock);
  return (0);
}
}
static int SockSetup___0(int sock ) 
{ 

  {
  fcntl(sock, 2, 1);
  return (sock);
}
}
static void SockCallbackThread___0(void *ignored ) ;
static int Queue___1(int sock , Ns_SockProc *proc , void *arg , int when ) ;
static void CallbackTrigger___0(void) ;
static Callback___0 *firstQueuePtr___0  ;
static Callback___0 *lastQueuePtr___0  ;
static int shutdownPending___6  ;
static int running___2  ;
static Ns_Thread sockThread___0  ;
static Ns_Mutex lock___26  ;
static Ns_Cond cond___7  ;
static int trigPipe___2[2]  ;
static Tcl_HashTable table___0  ;
static void CallbackTrigger___0(void) 
{ int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
  tmp___1 = send(trigPipe___2[1], (void const   *)"", 1U, 0);
  if (tmp___1 != 1) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Ns_Fatal((char *)"trigger send() failed: %s", tmp___0);
  }
  return;
}
}
static int Queue___1(int sock , Ns_SockProc *proc , void *arg , int when ) 
{ Callback___0 *cbPtr ;
  int status ;
  int trigger ;
  int create ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  cbPtr = (Callback___0 *)ns_malloc(sizeof(Callback___0 ));
  cbPtr->sock = sock;
  cbPtr->proc = proc;
  cbPtr->arg = arg;
  cbPtr->when = when;
  create = 0;
  trigger = create;
  Ns_MutexLock(& lock___26);
  if (shutdownPending___6) {
    ns_free((void *)cbPtr);
    status = -1;
  } else {
    if (! running___2) {
      Tcl_InitHashTable(& table___0, 1);
      Ns_MutexSetName(& lock___26, (char *)"ns:sockcallbacks");
      create = 1;
      running___2 = 1;
    } else {
      if ((unsigned int )firstQueuePtr___0 == (unsigned int )((void *)0)) {
        trigger = 1;
      }
    }
    if ((unsigned int )firstQueuePtr___0 == (unsigned int )((void *)0)) {
      firstQueuePtr___0 = cbPtr;
    } else {
      lastQueuePtr___0->nextPtr = cbPtr;
    }
    cbPtr->nextPtr = (struct Callback___0 *)((void *)0);
    lastQueuePtr___0 = cbPtr;
    status = 0;
  }
  Ns_MutexUnlock(& lock___26);
  if (trigger) {
    CallbackTrigger___0();
  } else {
    if (create) {
      tmp___1 = ns_sockpair(trigPipe___2);
      if (tmp___1 != 0) {
        tmp = __errno_location();
        tmp___0 = strerror((*tmp));
        Ns_Fatal((char *)"ns_sockpair() failed: %s", tmp___0);
      }
      Ns_ThreadCreate(& SockCallbackThread___0, (void *)0, 0L, & sockThread___0);
    }
  }
  return (status);
}
}
static void SockCallbackThread___0(void *ignored ) 
{ char c ;
  int when[3] ;
  int events[3] ;
  int n ;
  int i ;
  int new ;
  int stop ;
  int max ;
  int nfds___1 ;
  Callback___0 *cbPtr ;
  Callback___0 *nextPtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  struct pollfd *pfds___1 ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;

  {
  Ns_ThreadSetName((char *)"-socks-");
  Ns_WaitForStartup();
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"socks: starting");
  events[0] = 1;
  events[1] = 4;
  events[2] = 2;
  when[0] = 1;
  when[1] = 2;
  when[2] = 20;
  max = 100;
  pfds___1 = (struct pollfd *)ns_malloc(sizeof(struct pollfd ) * (unsigned int )max);
  (pfds___1 + 0)->fd = trigPipe___2[0];
  (pfds___1 + 0)->events = (short)1;
  while (1) {
    Ns_MutexLock(& lock___26);
    cbPtr = firstQueuePtr___0;
    firstQueuePtr___0 = (Callback___0 *)((void *)0);
    lastQueuePtr___0 = (Callback___0 *)((void *)0);
    stop = shutdownPending___6;
    Ns_MutexUnlock(& lock___26);
    while ((unsigned int )cbPtr != (unsigned int )((void *)0)) {
      nextPtr = cbPtr->nextPtr;
      if (cbPtr->when & 32) {
        hPtr = ((*(table___0.findProc)))(& table___0, (char *)cbPtr->sock);
        if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
          ns_free(hPtr->clientData);
          Tcl_DeleteHashEntry(hPtr);
        }
        if ((unsigned int )cbPtr->proc != (unsigned int )((void *)0)) {
          ((*(cbPtr->proc)))(cbPtr->sock, cbPtr->arg, 32);
        }
        ns_free((void *)cbPtr);
      } else {
        hPtr = ((*(table___0.createProc)))(& table___0, (char *)cbPtr->sock, & new);
        if (! new) {
          ns_free(hPtr->clientData);
        }
        hPtr->clientData = (void *)cbPtr;
      }
      cbPtr = nextPtr;
    }
    if (max <= table___0.numEntries) {
      max = table___0.numEntries + 100;
      pfds___1 = (struct pollfd *)ns_realloc((void *)pfds___1, (unsigned int )max);
    }
    nfds___1 = 1;
    hPtr = Tcl_FirstHashEntry(& table___0, & search);
    while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
      cbPtr = (Callback___0 *)hPtr->clientData;
      if (! (cbPtr->when & 255)) {
        Tcl_DeleteHashEntry(hPtr);
        ns_free((void *)cbPtr);
      } else {
        cbPtr->idx = nfds___1;
        (pfds___1 + nfds___1)->fd = cbPtr->sock;
        (pfds___1 + nfds___1)->revents = (short)0;
        (pfds___1 + nfds___1)->events = (pfds___1 + nfds___1)->revents;
        i = 0;
        while (i < 3) {
          if (cbPtr->when & when[i]) {
            (pfds___1 + nfds___1)->events = (short )((int )(pfds___1 + nfds___1)->events |
                                                     events[i]);
          }
          i ++;
        }
        nfds___1 ++;
      }
      hPtr = Tcl_NextHashEntry(& search);
    }
    if (stop) {
      break;
    }
    (pfds___1 + 0)->revents = (short)0;
    while (1) {
      n = poll(pfds___1, (unsigned long )((unsigned int )nfds___1), -1);
      if (n < 0) {
        tmp = __errno_location();
        if (! ((*tmp) == 4)) {
          break;
        }
      } else {
        break;
      }
    }
    if (n < 0) {
      tmp___0 = __errno_location();
      tmp___1 = strerror((*tmp___0));
      Ns_Fatal((char *)"poll() failed: %s", tmp___1);
    }
    if ((int )(pfds___1 + 0)->revents & 1) {
      tmp___4 = recv(trigPipe___2[0], (void *)(& c), 1U, 0);
      if (tmp___4 != 1) {
        tmp___2 = __errno_location();
        tmp___3 = strerror((*tmp___2));
        Ns_Fatal((char *)"trigger read() failed: %s", tmp___3);
      }
    }
    hPtr = Tcl_FirstHashEntry(& table___0, & search);
    while (1) {
      if (n > 0) {
        if (! ((unsigned int )hPtr != (unsigned int )((void *)0))) {
          break;
        }
      } else {
        break;
      }
      cbPtr = (Callback___0 *)hPtr->clientData;
      i = 0;
      while (i < 3) {
        if (cbPtr->when & when[i]) {
          if ((int )(pfds___1 + cbPtr->idx)->revents & events[i]) {
            tmp___5 = ((*(cbPtr->proc)))(cbPtr->sock, cbPtr->arg, when[i]);
            if (! tmp___5) {
              cbPtr->when = 0;
            }
          }
        }
        i ++;
      }
      hPtr = Tcl_NextHashEntry(& search);
    }
  }
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"socks: shutdown pending");
  hPtr = Tcl_FirstHashEntry(& table___0, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    cbPtr = (Callback___0 *)hPtr->clientData;
    if (cbPtr->when & 8) {
      ((*(cbPtr->proc)))(cbPtr->sock, cbPtr->arg, 8);
    }
    hPtr = Tcl_NextHashEntry(& search);
  }
  hPtr = Tcl_FirstHashEntry(& table___0, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    ns_free(hPtr->clientData);
    hPtr = Tcl_NextHashEntry(& search);
  }
  Tcl_DeleteHashTable(& table___0);
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"socks: shutdown complete");
  Ns_MutexLock(& lock___26);
  running___2 = 0;
  Ns_CondBroadcast(& cond___7);
  Ns_MutexUnlock(& lock___26);
  return;
}
}
static void RunAtClose___0(NsInterp *itPtr , int run ) ;
static void RunAtClose___0(NsInterp *itPtr , int run ) 
{ Tcl_Interp *interp ;
  AtClose *atPtr ;
  int tmp ;

  {
  interp = itPtr->interp;
  while (1) {
    atPtr = itPtr->firstAtClosePtr;
    if (! ((unsigned int )atPtr != (unsigned int )((void *)0))) {
      break;
    }
    itPtr->firstAtClosePtr = atPtr->nextPtr;
    if (run) {
      tmp = Tcl_GlobalEval(interp, atPtr->script);
      if (tmp != 0) {
        Ns_TclLogError(interp);
      }
    }
    ns_free((void *)atPtr);
  }
  return;
}
}
static Cmd cmds___0[98]  = 
  {      {(char *)"ns_crypt", (Tcl_CmdProc *)((void *)0), & NsTclCryptObjCmd}, 
        {(char *)"ns_sleep", (Tcl_CmdProc *)((void *)0), & NsTclSleepObjCmd}, 
        {(char *)"ns_localtime", (Tcl_CmdProc *)((void *)0), & NsTclLocalTimeObjCmd}, 
        {(char *)"ns_gmtime",
      (Tcl_CmdProc *)((void *)0), & NsTclGmTimeObjCmd}, 
        {(char *)"ns_time", (Tcl_CmdProc *)((void *)0), & NsTclTimeObjCmd}, 
        {(char *)"ns_fmttime", (Tcl_CmdProc *)((void *)0), & NsTclStrftimeObjCmd}, 
        {(char *)"ns_httptime", (Tcl_CmdProc *)((void *)0), & NsTclHttpTimeObjCmd}, 
        {(char *)"ns_parsehttptime", (Tcl_CmdProc *)((void *)0), & NsTclParseHttpTimeObjCmd}, 
        {(char *)"ns_parsequery",
      (Tcl_CmdProc *)((void *)0), & NsTclParseQueryObjCmd}, 
        {(char *)"ns_rand", (Tcl_CmdProc *)((void *)0), & NsTclRandObjCmd}, 
        {(char *)"ns_info", (Tcl_CmdProc *)((void *)0), & NsTclInfoObjCmd}, 
        {(char *)"ns_modulepath", (Tcl_CmdProc *)((void *)0), & NsTclModulePathObjCmd}, 
        {(char *)"ns_log",
      (Tcl_CmdProc *)((void *)0), & NsTclLogObjCmd}, 
        {(char *)"ns_logctl", (Tcl_CmdProc *)((void *)0), & NsTclLogCtlObjCmd}, 
        {(char *)"ns_logroll", (Tcl_CmdProc *)((void *)0), & NsTclLogRollObjCmd}, 
        {(char *)"ns_urlencode", (Tcl_CmdProc *)((void *)0), & NsTclUrlEncodeObjCmd}, 
        {(char *)"ns_urldecode",
      (Tcl_CmdProc *)((void *)0), & NsTclUrlDecodeObjCmd}, 
        {(char *)"ns_uuencode", (Tcl_CmdProc *)((void *)0), & NsTclHTUUEncodeObjCmd}, 
        {(char *)"ns_uudecode",
      (Tcl_CmdProc *)((void *)0), & NsTclHTUUDecodeObjCmd}, 
        {(char *)"ns_gifsize", (Tcl_CmdProc *)((void *)0), & NsTclGifSizeObjCmd}, 
        {(char *)"ns_jpegsize", (Tcl_CmdProc *)((void *)0), & NsTclJpegSizeObjCmd}, 
        {(char *)"ns_guesstype", (Tcl_CmdProc *)((void *)0), & NsTclGuessTypeObjCmd}, 
        {(char *)"ns_striphtml",
      & NsTclStripHtmlCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_quotehtml", & NsTclQuoteHtmlCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_hrefs",
      & NsTclHrefsCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_config", & NsTclConfigCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_configsection", & NsTclConfigSectionCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_configsections",
      & NsTclConfigSectionsCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_unlink", (Tcl_CmdProc *)((void *)0), & NsTclUnlinkObjCmd}, 
        {(char *)"ns_mkdir", (Tcl_CmdProc *)((void *)0), & NsTclMkdirObjCmd}, 
        {(char *)"ns_rmdir", (Tcl_CmdProc *)((void *)0), & NsTclRmdirObjCmd}, 
        {(char *)"ns_cp", (Tcl_CmdProc *)((void *)0), & NsTclCpObjCmd}, 
        {(char *)"ns_cpfp", (Tcl_CmdProc *)((void *)0), & NsTclCpFpObjCmd}, 
        {(char *)"ns_rollfile", (Tcl_CmdProc *)((void *)0), & NsTclRollFileObjCmd}, 
        {(char *)"ns_purgefiles", (Tcl_CmdProc *)((void *)0), & NsTclPurgeFilesObjCmd}, 
        {(char *)"ns_mktemp",
      & NsTclMkTempCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_tmpnam", (Tcl_CmdProc *)((void *)0), & NsTclTmpNamObjCmd}, 
        {(char *)"ns_normalizepath", (Tcl_CmdProc *)((void *)0), & NsTclNormalizePathObjCmd}, 
        {(char *)"ns_link",
      (Tcl_CmdProc *)((void *)0), & NsTclLinkObjCmd}, 
        {(char *)"ns_symlink", (Tcl_CmdProc *)((void *)0), & NsTclSymlinkObjCmd}, 
        {(char *)"ns_rename", (Tcl_CmdProc *)((void *)0), & NsTclRenameObjCmd}, 
        {(char *)"ns_kill", (Tcl_CmdProc *)((void *)0), & NsTclKillObjCmd}, 
        {(char *)"ns_writefp", (Tcl_CmdProc *)((void *)0), & NsTclWriteFpObjCmd}, 
        {(char *)"ns_truncate", (Tcl_CmdProc *)((void *)0), & NsTclTruncateObjCmd}, 
        {(char *)"ns_ftruncate", (Tcl_CmdProc *)((void *)0), & NsTclFTruncateObjCmd}, 
        {(char *)"ns_chmod",
      (Tcl_CmdProc *)((void *)0), & NsTclChmodObjCmd}, 
        {(char *)"ns_env", & NsTclEnvCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"env", & NsTclEnvCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_job", (Tcl_CmdProc *)((void *)0), & NsTclJobObjCmd}, 
        {(char *)"ns_http", (Tcl_CmdProc *)((void *)0), & NsTclHttpObjCmd}, 
        {(char *)"ns_schedule_proc", & NsTclSchedCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_schedule_daily",
      & NsTclSchedDailyCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_schedule_weekly", & NsTclSchedWeeklyCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_atsignal",
      & NsTclAtSignalCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_atshutdown", & NsTclAtShutdownCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_atexit",
      & NsTclAtExitCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_after", & NsTclAfterCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_cancel", & NsTclCancelCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_pause", & NsTclPauseCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_resume", & NsTclResumeCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_unschedule_proc", & NsTclUnscheduleCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_set",
      (Tcl_CmdProc *)((void *)0), & NsTclSetObjCmd}, 
        {(char *)"ns_parseheader", & NsTclParseHeaderCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_sockcallback",
      (Tcl_CmdProc *)((void *)0), & NsTclSockCallbackObjCmd}, 
        {(char *)"ns_socklistencallback", (Tcl_CmdProc *)((void *)0), & NsTclSockListenCallbackObjCmd}, 
        {(char *)"ns_sockblocking",
      (Tcl_CmdProc *)((void *)0), & NsTclSockSetBlockingObjCmd}, 
        {(char *)"ns_socknonblocking", (Tcl_CmdProc *)((void *)0), & NsTclSockSetNonBlockingObjCmd}, 
        {(char *)"ns_socknread",
      (Tcl_CmdProc *)((void *)0), & NsTclSockNReadObjCmd}, 
        {(char *)"ns_sockopen", (Tcl_CmdProc *)((void *)0), & NsTclSockOpenObjCmd}, 
        {(char *)"ns_socklisten", (Tcl_CmdProc *)((void *)0), & NsTclSockListenObjCmd}, 
        {(char *)"ns_sockaccept",
      (Tcl_CmdProc *)((void *)0), & NsTclSockAcceptObjCmd}, 
        {(char *)"ns_sockcheck", (Tcl_CmdProc *)((void *)0), & NsTclSockCheckObjCmd}, 
        {(char *)"ns_sockselect",
      (Tcl_CmdProc *)((void *)0), & NsTclSelectObjCmd}, 
        {(char *)"ns_socketpair", (Tcl_CmdProc *)((void *)0), & NsTclSocketPairObjCmd}, 
        {(char *)"ns_hostbyaddr",
      (Tcl_CmdProc *)((void *)0), & NsTclGetHostObjCmd}, 
        {(char *)"ns_addrbyhost", (Tcl_CmdProc *)((void *)0), & NsTclGetAddrObjCmd}, 
        {(char *)"keyldel", & Tcl_KeyldelCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"keylget", & Tcl_KeylgetCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"keylkeys", & Tcl_KeylkeysCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"keylset", & Tcl_KeylsetCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_cache_flush", & NsTclCacheFlushCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_cache_stats",
      & NsTclCacheStatsCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_cache_names", & NsTclCacheNamesCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_cache_size",
      & NsTclCacheSizeCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_cache_keys", & NsTclCacheKeysCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_thread",
      & NsTclThreadCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_mutex", (Tcl_CmdProc *)((void *)0), & NsTclMutexObjCmd}, 
        {(char *)"ns_cond", (Tcl_CmdProc *)((void *)0), & NsTclCondObjCmd}, 
        {(char *)"ns_event", (Tcl_CmdProc *)((void *)0), & NsTclCondObjCmd}, 
        {(char *)"ns_rwlock", (Tcl_CmdProc *)((void *)0), & NsTclRWLockObjCmd}, 
        {(char *)"ns_sema", (Tcl_CmdProc *)((void *)0), & NsTclSemaObjCmd}, 
        {(char *)"ns_critsec", (Tcl_CmdProc *)((void *)0), & NsTclCritSecObjCmd}, 
        {(char *)"ns_init", (Tcl_CmdProc *)((void *)0), & NsTclDummyObjCmd}, 
        {(char *)"ns_cleanup", (Tcl_CmdProc *)((void *)0), & NsTclDummyObjCmd}, 
        {(char *)"ns_markfordelete", (Tcl_CmdProc *)((void *)0), & NsTclMarkForDeleteObjCmd}, 
        {(char *)"ns_charsets",
      & NsTclCharsetsCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_encodingforcharset", & NsTclEncodingForCharsetCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)((void *)0),
      (Tcl_CmdProc *)((void *)0), (Tcl_ObjCmdProc *)0}};
static Cmd servCmds___0[75]  = 
  {      {(char *)"ns_register_filter", (Tcl_CmdProc *)((void *)0), & NsTclRegisterFilterObjCmd}, 
        {(char *)"ns_register_trace",
      (Tcl_CmdProc *)((void *)0), & NsTclRegisterTraceObjCmd}, 
        {(char *)"ns_register_adp", (Tcl_CmdProc *)((void *)0), & NsTclRegisterAdpObjCmd}, 
        {(char *)"ns_register_proc",
      (Tcl_CmdProc *)((void *)0), & NsTclRegisterProcObjCmd}, 
        {(char *)"ns_unregister_adp", (Tcl_CmdProc *)((void *)0), & NsTclUnRegisterObjCmd}, 
        {(char *)"ns_unregister_proc",
      (Tcl_CmdProc *)((void *)0), & NsTclUnRegisterObjCmd}, 
        {(char *)"ns_atclose", & NsTclAtCloseCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_return", (Tcl_CmdProc *)((void *)0), & NsTclReturnObjCmd}, 
        {(char *)"ns_respond", (Tcl_CmdProc *)((void *)0), & NsTclRespondObjCmd}, 
        {(char *)"ns_returnfile", (Tcl_CmdProc *)((void *)0), & NsTclReturnFileObjCmd}, 
        {(char *)"ns_returnfp",
      (Tcl_CmdProc *)((void *)0), & NsTclReturnFpObjCmd}, 
        {(char *)"ns_returnbadrequest", (Tcl_CmdProc *)((void *)0), & NsTclReturnBadRequestObjCmd}, 
        {(char *)"ns_returnerror",
      (Tcl_CmdProc *)((void *)0), & NsTclReturnErrorObjCmd}, 
        {(char *)"ns_returnnotice", & NsTclReturnNoticeCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_returnadminnotice",
      & NsTclReturnAdminNoticeCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_returnredirect", (Tcl_CmdProc *)((void *)0), & NsTclReturnRedirectObjCmd}, 
        {(char *)"ns_headers",
      (Tcl_CmdProc *)((void *)0), & NsTclHeadersObjCmd}, 
        {(char *)"ns_write", (Tcl_CmdProc *)((void *)0), & NsTclWriteObjCmd}, 
        {(char *)"ns_connsendfp", (Tcl_CmdProc *)((void *)0), & NsTclConnSendFpObjCmd}, 
        {(char *)"ns_returnforbidden",
      (Tcl_CmdProc *)((void *)0), & NsTclReturnForbiddenObjCmd}, 
        {(char *)"ns_returnunauthorized", (Tcl_CmdProc *)((void *)0), & NsTclReturnUnauthorizedObjCmd}, 
        {(char *)"ns_returnnotfound",
      (Tcl_CmdProc *)((void *)0), & NsTclReturnNotFoundObjCmd}, 
        {(char *)"ns_chan", (Tcl_CmdProc *)((void *)0), & NsTclChanObjCmd}, 
        {(char *)"ns_url2file", (Tcl_CmdProc *)((void *)0), & NsTclUrl2FileObjCmd}, 
        {(char *)"ns_library", & NsTclLibraryCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_geturl", (Tcl_CmdProc *)((void *)0), & NsTclGetUrlObjCmd}, 
        {(char *)"ns_checkurl", (Tcl_CmdProc *)((void *)0), & NsTclRequestAuthorizeObjCmd}, 
        {(char *)"ns_requestauthorize",
      (Tcl_CmdProc *)((void *)0), & NsTclRequestAuthorizeObjCmd}, 
        {(char *)"ns_shutdown", (Tcl_CmdProc *)((void *)0), & NsTclShutdownObjCmd}, 
        {(char *)"ns_conncptofp", (Tcl_CmdProc *)((void *)0), & NsTclWriteContentObjCmd}, 
        {(char *)"ns_writecontent",
      (Tcl_CmdProc *)((void *)0), & NsTclWriteContentObjCmd}, 
        {(char *)"ns_conn", (Tcl_CmdProc *)((void *)0), & NsTclConnObjCmd}, 
        {(char *)"ns_startcontent", (Tcl_CmdProc *)((void *)0), & NsTclStartContentObjCmd}, 
        {(char *)"ns_register_adptag",
      & NsTclRegisterTagCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_adp_registeradp", & NsTclAdpRegisterAdpCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_adp_registertag",
      & NsTclAdpRegisterAdpCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_adp_registerproc", & NsTclAdpRegisterProcCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_adp_stats",
      & NsTclAdpStatsCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_adp_debug", & NsTclAdpDebugCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"_ns_adp_include", (Tcl_CmdProc *)((void *)0), & NsTclAdpIncludeObjCmd}, 
        {(char *)"ns_adp_eval",
      (Tcl_CmdProc *)((void *)0), & NsTclAdpEvalObjCmd}, 
        {(char *)"ns_adp_safeeval", (Tcl_CmdProc *)((void *)0), & NsTclAdpSafeEvalObjCmd}, 
        {(char *)"ns_adp_parse",
      (Tcl_CmdProc *)((void *)0), & NsTclAdpParseObjCmd}, 
        {(char *)"ns_puts", (Tcl_CmdProc *)((void *)0), & NsTclAdpPutsObjCmd}, 
        {(char *)"ns_adp_puts", (Tcl_CmdProc *)((void *)0), & NsTclAdpPutsObjCmd}, 
        {(char *)"ns_adp_append", (Tcl_CmdProc *)((void *)0), & NsTclAdpAppendObjCmd}, 
        {(char *)"ns_adp_dir",
      (Tcl_CmdProc *)((void *)0), & NsTclAdpDirObjCmd}, 
        {(char *)"ns_adp_return", (Tcl_CmdProc *)((void *)0), & NsTclAdpReturnObjCmd}, 
        {(char *)"ns_adp_break",
      (Tcl_CmdProc *)((void *)0), & NsTclAdpBreakObjCmd}, 
        {(char *)"ns_adp_abort", (Tcl_CmdProc *)((void *)0), & NsTclAdpAbortObjCmd}, 
        {(char *)"ns_adp_tell", (Tcl_CmdProc *)((void *)0), & NsTclAdpTellObjCmd}, 
        {(char *)"ns_adp_trunc", (Tcl_CmdProc *)((void *)0), & NsTclAdpTruncObjCmd}, 
        {(char *)"ns_adp_dump", (Tcl_CmdProc *)((void *)0), & NsTclAdpDumpObjCmd}, 
        {(char *)"ns_adp_argc", (Tcl_CmdProc *)((void *)0), & NsTclAdpArgcObjCmd}, 
        {(char *)"ns_adp_argv", (Tcl_CmdProc *)((void *)0), & NsTclAdpArgvObjCmd}, 
        {(char *)"ns_adp_bind_args", (Tcl_CmdProc *)((void *)0), & NsTclAdpBindArgsObjCmd}, 
        {(char *)"ns_adp_exception",
      (Tcl_CmdProc *)((void *)0), & NsTclAdpExceptionObjCmd}, 
        {(char *)"ns_adp_stream", (Tcl_CmdProc *)((void *)0), & NsTclAdpStreamObjCmd}, 
        {(char *)"ns_adp_mime",
      (Tcl_CmdProc *)((void *)0), & NsTclAdpMimeTypeObjCmd}, 
        {(char *)"ns_adp_mimetype", (Tcl_CmdProc *)((void *)0), & NsTclAdpMimeTypeObjCmd}, 
        {(char *)"ns_adp_compress",
      (Tcl_CmdProc *)((void *)0), & NsTclAdpCompressObjCmd}, 
        {(char *)"ns_share", & NsTclShareCmd, (Tcl_ObjCmdProc *)((void *)0)}, 
        {(char *)"ns_var", (Tcl_CmdProc *)((void *)0), & NsTclVarObjCmd}, 
        {(char *)"nsv_get", (Tcl_CmdProc *)((void *)0), & NsTclNsvGetObjCmd}, 
        {(char *)"nsv_exists", (Tcl_CmdProc *)((void *)0), & NsTclNsvExistsObjCmd}, 
        {(char *)"nsv_set", (Tcl_CmdProc *)((void *)0), & NsTclNsvSetObjCmd}, 
        {(char *)"nsv_incr", (Tcl_CmdProc *)((void *)0), & NsTclNsvIncrObjCmd}, 
        {(char *)"nsv_append", (Tcl_CmdProc *)((void *)0), & NsTclNsvAppendObjCmd}, 
        {(char *)"nsv_lappend", (Tcl_CmdProc *)((void *)0), & NsTclNsvLappendObjCmd}, 
        {(char *)"nsv_array",
      (Tcl_CmdProc *)((void *)0), & NsTclNsvArrayObjCmd}, 
        {(char *)"nsv_unset", (Tcl_CmdProc *)((void *)0), & NsTclNsvUnsetObjCmd}, 
        {(char *)"nsv_names", (Tcl_CmdProc *)((void *)0), & NsTclNsvNamesObjCmd}, 
        {(char *)"ns_server", (Tcl_CmdProc *)((void *)0), & NsTclServerObjCmd}, 
        {(char *)"ns_ictl", (Tcl_CmdProc *)((void *)0), & NsTclICtlObjCmd}, 
        {(char *)((void *)0), (Tcl_CmdProc *)((void *)0), (Tcl_ObjCmdProc *)0}};
static void AddCmds___0(Cmd *cmdPtr , ClientData arg , Tcl_Interp *interp ) 
{ 

  {
  while ((unsigned int )cmdPtr->name != (unsigned int )((void *)0)) {
    if ((unsigned int )cmdPtr->objProc != (unsigned int )((void *)0)) {
      Tcl_CreateObjCommand(interp, cmdPtr->name, cmdPtr->objProc, arg, (Tcl_CmdDeleteProc *)((void *)0));
    } else {
      Tcl_CreateCommand(interp, cmdPtr->name, cmdPtr->proc, arg, (Tcl_CmdDeleteProc *)((void *)0));
    }
    cmdPtr ++;
  }
  return;
}
}
static int PutEnv___0(Tcl_Interp *interp , char *name , char *value ) ;
static Ns_Mutex lock___27  ;
static int PutEnv___0(Tcl_Interp *interp , char *name , char *value ) 
{ char *s ;
  size_t len ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  len = strlen((char const   *)name);
  if ((unsigned int )value != (unsigned int )((void *)0)) {
    tmp = strlen((char const   *)value);
    len += tmp + 1U;
  }
  s = (char *)malloc(len + 1U);
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    Tcl_SetResult(interp, (char *)"could not allocate memory for new env entry", (Tcl_FreeProc *)0);
    return (1);
  }
  strcpy((char * __restrict  )s, (char const   * __restrict  )name);
  if ((unsigned int )value != (unsigned int )((void *)0)) {
    strcat((char * __restrict  )s, (char const   * __restrict  )"=");
    strcat((char * __restrict  )s, (char const   * __restrict  )value);
  }
  tmp___1 = putenv(s);
  if (tmp___1 != 0) {
    tmp___0 = Tcl_PosixError(interp);
    Tcl_AppendResult(interp, "could not put environment entry \"", s, "\": ", tmp___0,
                     (void *)0);
    free((void *)s);
    return (1);
  }
  return (0);
}
}
static void SpliceChannel___0(Tcl_Interp *interp , Tcl_Channel chan ) ;
static void UnspliceChannel___0(Tcl_Interp *interp , Tcl_Channel chan ) ;
static int GetOpenChannel___0(Tcl_Interp *interp , Tcl_Obj *obj , int write___0 ,
                              int check , Tcl_Channel *chanPtr ) 
{ char *tmp ;
  int tmp___0 ;

  {
  tmp = Tcl_GetString(obj);
  tmp___0 = Ns_TclGetOpenChannel(interp, tmp, write___0, check, chanPtr);
  return (tmp___0);
}
}
static int FileObjCmd___0(Tcl_Interp *interp , int objc , Tcl_Obj **objv , char *cmd ) 
{ int max ;
  int status ;
  int tmp ;
  char *tmp___0 ;
  Tcl_Obj *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  Tcl_Obj *tmp___6 ;

  {
  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"file backupMax");
    return (1);
  }
  tmp = Tcl_GetIntFromObj(interp, (*(objv + 2)), & max);
  if (tmp != 0) {
    return (1);
  }
  if (max <= 0) {
    tmp___0 = Tcl_GetString((*(objv + 2)));
    tmp___1 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___1, "invalid max \"", tmp___0, "\": should be > 0 and <= 1000.",
                           (void *)0);
    return (1);
  } else {
    if (max > 1000) {
      tmp___0 = Tcl_GetString((*(objv + 2)));
      tmp___1 = Tcl_GetObjResult(interp);
      Tcl_AppendStringsToObj(tmp___1, "invalid max \"", tmp___0, "\": should be > 0 and <= 1000.",
                             (void *)0);
      return (1);
    }
  }
  if ((int )(*cmd) == 112) {
    tmp___2 = Tcl_GetString((*(objv + 1)));
    status = Ns_PurgeFiles(tmp___2, max);
  } else {
    tmp___3 = Tcl_GetString((*(objv + 1)));
    status = Ns_RollFile(tmp___3, max);
  }
  if (status != 0) {
    tmp___4 = Tcl_PosixError(interp);
    tmp___5 = Tcl_GetString((*(objv + 1)));
    tmp___6 = Tcl_GetObjResult(interp);
    Tcl_AppendStringsToObj(tmp___6, "could not ", cmd, " \"", tmp___5, "\": ", tmp___4,
                           (void *)0);
    return (1);
  }
  return (0);
}
}
static char *opts___20[6]  = {      (char *)"cleanup",      (char *)"list",      (char *)"create",      (char *)"put", 
        (char *)"get",      (char *)((void *)0)};
static void SpliceChannel___0(Tcl_Interp *interp , Tcl_Channel chan ) 
{ 

  {
  Tcl_SpliceChannel(chan);
  Tcl_RegisterChannel(interp, chan);
  Tcl_UnregisterChannel((Tcl_Interp *)((void *)0), chan);
  return;
}
}
static void UnspliceChannel___0(Tcl_Interp *interp , Tcl_Channel chan ) 
{ 

  {
  Tcl_ClearChannelHandlers(chan);
  Tcl_RegisterChannel((Tcl_Interp *)((void *)0), chan);
  Tcl_UnregisterChannel(interp, chan);
  Tcl_CutChannel(chan);
  return;
}
}
static int HttpSend___0(int sock , void *arg , int why ) ;
static int HttpRecv___0(int sock , void *arg , int why ) ;
static int HttpCancel___0(int sock , void *arg , int why ) ;
static int HttpDone___0(int sock , Http *httpPtr , int state ) ;
static Http *HttpOpen___0(char *method , char *url , Ns_Set *hdrs , char *body ) ;
static void HttpClose___0(Http *httpPtr , int nb ) ;
static int HttpAbort___0(Http *httpPtr ) ;
static char *HttpResult___0(char *response , Ns_Set *hdrs ) ;
static Ns_Mutex lock___28  ;
static Ns_Cond cond___8  ;
static char *opts___21[5]  = {      (char *)"cancel",      (char *)"cleanup",      (char *)"queue",      (char *)"wait", 
        (char *)((void *)0)};
static Http *HttpOpen___0(char *method , char *url , Ns_Set *hdrs , char *body ) 
{ Http *httpPtr ;
  int sock ;
  char *host ;
  char *file___1 ;
  char *port ;
  int i ;
  int body_len ;
  char lenbuf[20] ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___22 ;
  char *tmp___24 ;
  char const   *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;

  {
  httpPtr = (Http *)((void *)0);
  body_len = 0;
  if (0) {
    if (0) {
      __s1_len___0 = strlen((char const   *)url);
      __s2_len___0 = strlen("http://");
      if (! ((unsigned int )((void const   *)(url + 1)) - (unsigned int )((void const   *)url) ==
             1U)) {
        goto _L___2;
      } else {
        if (__s1_len___0 >= 4U) {
          _L___2: 
          if (! ((unsigned int )((void const   *)("http://" + 1)) - (unsigned int )((void const   *)"http://") ==
                 1U)) {
            tmp___18 = 1;
          } else {
            if (__s2_len___0 >= 4U) {
              tmp___18 = 1;
            } else {
              tmp___18 = 0;
            }
          }
        } else {
          tmp___18 = 0;
        }
      }
      if (tmp___18) {
        if (__s1_len___0 < __s2_len___0) {
          tmp___16 = __s1_len___0;
        } else {
          tmp___16 = __s2_len___0;
        }
        tmp___15 = memcmp((void const   *)((char const   *)url), (void const   *)"http://",
                          tmp___16 + 1U);
      } else {
        tmp___17 = strcmp((char const   *)url, "http://");
        tmp___15 = tmp___17;
      }
    } else {
      tmp___17 = strcmp((char const   *)url, "http://");
      tmp___15 = tmp___17;
    }
    tmp___10 = tmp___15;
  } else {
    tmp___10 = strncmp((char const   *)url, "http://", 7U);
  }
  if (tmp___10 != 0) {
    return ((Http *)((void *)0));
  } else {
    if ((int )(*(url + 7)) == 0) {
      return ((Http *)((void *)0));
    }
  }
  host = url + 7;
  tmp___22 = strchr((char const   *)host, '/');
  file___1 = tmp___22;
  if ((unsigned int )file___1 != (unsigned int )((void *)0)) {
    (*file___1) = (char )'\000';
  }
  tmp___24 = strchr((char const   *)host, ':');
  port = tmp___24;
  if ((unsigned int )port == (unsigned int )((void *)0)) {
    i = 80;
  } else {
    (*port) = (char )'\000';
    i = atoi__extinline((char const   *)(port + 1));
  }
  sock = Ns_SockAsyncConnect(host, i);
  if ((unsigned int )port != (unsigned int )((void *)0)) {
    (*port) = (char )':';
  }
  if (sock != -1) {
    httpPtr = (Http *)ns_malloc(sizeof(Http ));
    httpPtr->state = 1;
    httpPtr->sock = sock;
    Tcl_DStringInit(& httpPtr->ds);
    if ((unsigned int )file___1 != (unsigned int )((void *)0)) {
      (*file___1) = (char )'/';
    }
    Tcl_DStringAppend(& httpPtr->ds, method, -1);
    Ns_StrToUpper(httpPtr->ds.string);
    if (file___1) {
      tmp___25 = (char const   *)file___1;
    } else {
      tmp___25 = "/";
    }
    Ns_DStringVarAppend(& httpPtr->ds, " ", tmp___25, " HTTP/1.0\r\n", (void *)0);
    if ((unsigned int )file___1 != (unsigned int )((void *)0)) {
      (*file___1) = (char )'\000';
    }
    tmp___26 = Ns_InfoServerVersion();
    tmp___27 = Ns_InfoServerName();
    Ns_DStringVarAppend(& httpPtr->ds, "User-Agent: ", tmp___27, "/", tmp___26, "\r\nConnection: close\r\nHost: ",
                        host, "\r\n", (void *)0);
    if ((unsigned int )file___1 != (unsigned int )((void *)0)) {
      (*file___1) = (char )'/';
    }
    if ((unsigned int )hdrs != (unsigned int )((void *)0)) {
      i = 0;
      while (i < hdrs->size) {
        Ns_DStringVarAppend(& httpPtr->ds, (hdrs->fields + i)->name, ": ", (hdrs->fields +
                                                                            i)->value,
                            "\r\n", (void *)0);
        i ++;
      }
    }
    if ((unsigned int )body != (unsigned int )((void *)0)) {
      body_len = (int )strlen((char const   *)body);
      if (body_len > 0) {
        sprintf((char * __restrict  )(lenbuf), (char const   * __restrict  )"%d",
                body_len);
        Ns_DStringVarAppend(& httpPtr->ds, "Content-Length: ", lenbuf, "\r\n", (void *)0);
      }
    }
    Tcl_DStringAppend(& httpPtr->ds, (char *)"\r\n", 2);
    if (body_len > 0) {
      Tcl_DStringAppend(& httpPtr->ds, body, body_len);
    }
    httpPtr->next = httpPtr->ds.string;
    httpPtr->len = (unsigned int )httpPtr->ds.length;
  }
  if ((unsigned int )file___1 != (unsigned int )((void *)0)) {
    (*file___1) = (char )'/';
  }
  return (httpPtr);
}
}
static char *HttpResult___0(char *response , Ns_Set *hdrs ) 
{ int firsthdr ;
  int len ;
  char *eoh ;
  char *body ;
  char *p ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___2 ;

  {
  body = response;
  eoh = strstr((char const   *)response, "\r\n\r\n");
  if ((unsigned int )eoh != (unsigned int )((void *)0)) {
    body = eoh + 4;
  } else {
    eoh = strstr((char const   *)response, "\n\n");
    if ((unsigned int )eoh != (unsigned int )((void *)0)) {
      body = eoh + 2;
    }
  }
  if ((unsigned int )eoh != (unsigned int )((void *)0)) {
    (*eoh) = (char )'\000';
  }
  if ((unsigned int )hdrs != (unsigned int )((void *)0)) {
    firsthdr = 1;
    p = response;
    while (1) {
      tmp___2 = strchr((char const   *)p, '\n');
      eoh = tmp___2;
      if (! ((unsigned int )eoh != (unsigned int )((void *)0))) {
        break;
      }
      tmp = eoh;
      eoh ++;
      (*tmp) = (char )'\000';
      len = (int )strlen((char const   *)p);
      if (len > 0) {
        if ((int )(*(p + (len - 1))) == 13) {
          (*(p + (len - 1))) = (char )'\000';
        }
      }
      if (firsthdr) {
        if ((unsigned int )hdrs->name != (unsigned int )((void *)0)) {
          ns_free((void *)hdrs->name);
        }
        hdrs->name = ns_strdup((char const   *)p);
        firsthdr = 0;
      } else {
        tmp___0 = Ns_ParseHeader(hdrs, p, (enum __anonenum_Ns_HeaderCaseDisposition_68 )1);
        if (tmp___0 != 0) {
          break;
        }
      }
      p = eoh;
    }
  }
  return (body);
}
}
static void HttpClose___0(Http *httpPtr , int nb ) 
{ 

  {
  Tcl_DStringFree(& httpPtr->ds);
  if (nb) {
    close(httpPtr->sock);
  } else {
    close(httpPtr->sock);
  }
  ns_free((void *)httpPtr);
  return;
}
}
static int HttpSend___0(int sock , void *arg , int why ) 
{ Http *httpPtr ;
  int n ;
  int tmp ;

  {
  httpPtr = (Http *)arg;
  n = send(sock, (void const   *)httpPtr->next, httpPtr->len, 0);
  if (n < 0) {
    Tcl_DStringFree(& httpPtr->ds);
    tmp = HttpDone___0(sock, httpPtr, 36);
    return (tmp);
  }
  httpPtr->next = httpPtr->next + n;
  httpPtr->len = httpPtr->len - (unsigned int )n;
  if (httpPtr->len == 0U) {
    shutdown(sock, 1);
    Tcl_DStringSetLength(& httpPtr->ds, 0);
    Ns_MutexLock(& lock___28);
    httpPtr->state = 2;
    Ns_MutexUnlock(& lock___28);
    Ns_SockCallback(sock, & HttpRecv___0, arg, 1);
  }
  return (1);
}
}
static int HttpRecv___0(int sock , void *arg , int why ) 
{ Http *httpPtr ;
  char buf[1024] ;
  int n ;
  int state ;
  int tmp ;

  {
  httpPtr = (Http *)arg;
  n = recv(sock, (void *)(buf), sizeof(buf), 0);
  if (n > 0) {
    Tcl_DStringAppend(& httpPtr->ds, buf, n);
    return (1);
  }
  state = 4;
  if (n < 0) {
    state |= 32;
  } else {
    state |= 16;
  }
  Ns_GetTime(& httpPtr->etime);
  tmp = HttpDone___0(sock, httpPtr, state);
  return (tmp);
}
}
static int HttpCancel___0(int sock , void *arg , int why ) 
{ Http *httpPtr ;
  int tmp ;

  {
  httpPtr = (Http *)arg;
  tmp = HttpDone___0(sock, httpPtr, 12);
  return (tmp);
}
}
static int HttpDone___0(int sock , Http *httpPtr , int state ) 
{ 

  {
  Ns_MutexLock(& lock___28);
  httpPtr->state = state;
  Ns_MutexUnlock(& lock___28);
  Ns_CondBroadcast(& cond___8);
  return (0);
}
}
static int HttpAbort___0(Http *httpPtr ) 
{ int state ;

  {
  Ns_MutexLock(& lock___28);
  state = httpPtr->state;
  if (! (state & 4)) {
    Ns_SockCancelCallbackEx(httpPtr->sock, & HttpCancel___0, (void *)httpPtr);
    while (! (httpPtr->state & 4)) {
      Ns_CondWait(& cond___8, & lock___28);
    }
  }
  Ns_MutexUnlock(& lock___28);
  HttpClose___0(httpPtr, 1);
  return (state);
}
}
static int ChanGetc___0(Tcl_Channel chan ) ;
static int JpegNextMarker___0(Tcl_Channel chan ) ;
static int JpegSize___0(Tcl_Channel chan , int *wPtr , int *hPtr ) ;
static int JpegRead2Bytes___0(Tcl_Channel chan ) ;
static int AppendObjDims___0(Tcl_Interp *interp , int w , int h ) ;
static int JpegSize___0(Tcl_Channel chan , int *wPtr , int *hPtr ) 
{ unsigned int i ;
  unsigned int w ;
  unsigned int h ;
  Tcl_WideInt numbytes ;
  int tmp ;
  int tmp___0 ;
  Tcl_WideInt tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___2 = ChanGetc___0(chan);
  if (tmp___2 == 255) {
    tmp___3 = ChanGetc___0(chan);
    if (tmp___3 == 216) {
      while (1) {
        i = (unsigned int )JpegNextMarker___0(chan);
        if (i == 4294967295U) {
          break;
        } else {
          if (i == 218U) {
            break;
          } else {
            if (i == 217U) {
              break;
            }
          }
        }
        if (192U <= i) {
          if (i <= 195U) {
            tmp = JpegRead2Bytes___0(chan);
            if (tmp != -1) {
              tmp___0 = ChanGetc___0(chan);
              if (tmp___0 != -1) {
                h = (unsigned int )JpegRead2Bytes___0(chan);
                if (h != 4294967295U) {
                  w = (unsigned int )JpegRead2Bytes___0(chan);
                  if (w != 4294967295U) {
                    (*wPtr) = (int )w;
                    (*hPtr) = (int )h;
                    return (0);
                  }
                }
              }
            }
            break;
          }
        }
        numbytes = (Tcl_WideInt )JpegRead2Bytes___0(chan);
        if (numbytes < 2LL) {
          break;
        } else {
          tmp___1 = Tcl_Seek(chan, numbytes - 2LL, 1);
          if (tmp___1 == -1LL) {
            break;
          }
        }
      }
    }
  }
  return (1);
}
}
static int JpegRead2Bytes___0(Tcl_Channel chan ) 
{ int c1 ;
  int c2 ;

  {
  c1 = ChanGetc___0(chan);
  c2 = ChanGetc___0(chan);
  if (c1 == -1) {
    return (-1);
  } else {
    if (c2 == -1) {
      return (-1);
    }
  }
  return ((int )((unsigned int )((int )((unsigned int )c1 << 8)) + (unsigned int )c2));
}
}
static int JpegNextMarker___0(Tcl_Channel chan ) 
{ int c ;

  {
  c = ChanGetc___0(chan);
  while (1) {
    if (c != -1) {
      if (! (c != 255)) {
        break;
      }
    } else {
      break;
    }
    c = ChanGetc___0(chan);
  }
  if (c != -1) {
    while (1) {
      c = ChanGetc___0(chan);
      if (! (c == 255)) {
        break;
      }
    }
  }
  return (c);
}
}
static int ChanGetc___0(Tcl_Channel chan ) 
{ unsigned char buf[1] ;
  int tmp ;

  {
  tmp = Tcl_Read(chan, (char *)(buf), 1);
  if (tmp != 1) {
    return (-1);
  }
  return ((int )buf[0]);
}
}
static int AppendObjDims___0(Tcl_Interp *interp , int w , int h ) 
{ char buf[20] ;
  Tcl_Obj *result ;
  Tcl_Obj *tmp ;
  Tcl_Obj *tmp___0 ;
  int tmp___1 ;
  Tcl_Obj *tmp___2 ;
  int tmp___3 ;

  {
  tmp = Tcl_NewObj();
  result = tmp;
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", w);
  tmp___0 = Tcl_NewStringObj(buf, -1);
  tmp___1 = Tcl_ListObjAppendElement(interp, result, tmp___0);
  if (tmp___1) {
    return (1);
  }
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", h);
  tmp___2 = Tcl_NewStringObj(buf, -1);
  tmp___3 = Tcl_ListObjAppendElement(interp, result, tmp___2);
  if (tmp___3) {
    return (1);
  }
  Tcl_SetObjResult(interp, result);
  return (0);
}
}
static void FreeData___0(ClientData arg , Tcl_Interp *interp ) ;
static void DeleteInterps___0(void *arg ) ;
static int InitInterp___0(Tcl_Interp *interp , NsServer *servPtr , NsInterp **itPtrPtr ) ;
static int UpdateInterp___0(NsInterp *itPtr ) ;
static Tcl_HashEntry *GetHashEntry___0(NsServer *servPtr ) ;
static int RegisterTrace___0(NsServer *servPtr , int idx , Ns_TclTraceProc *proc ,
                             void *arg ) ;
static void RunTraces___2(NsInterp *itPtr , int idx ) ;
static int TclScriptTraceCB___0(Tcl_Interp *interp , void *arg ) ;
static int TclInitScriptCB___0(Tcl_Interp *interp , void *arg ) ;
static Ns_Tls tls___3  ;
static Ns_Mutex initLock___0  ;
static char *opts___22[12]  = 
  {      (char *)"addmodule",      (char *)"cleanup",      (char *)"epoch",      (char *)"get", 
        (char *)"getmodules",      (char *)"save",      (char *)"update",      (char *)"oncreate", 
        (char *)"oncleanup",      (char *)"oninit",      (char *)"ondelete",      (char *)((void *)0)};
static int TclScriptTraceCB___0(Tcl_Interp *interp , void *arg ) 
{ char *script ;
  int status ;

  {
  script = (char *)arg;
  status = 0;
  if ((unsigned int )script != (unsigned int )((void *)0)) {
    status = Tcl_EvalEx(interp, script, -1, 131072);
  }
  return (status);
}
}
static int TclInitScriptCB___0(Tcl_Interp *interp , void *arg ) 
{ char *script ;
  int status ;
  int tmp ;

  {
  script = (char *)arg;
  status = 0;
  if ((unsigned int )script != (unsigned int )((void *)0)) {
    tmp = Tcl_EvalEx(interp, script, -1, 131072);
    if (tmp != 0) {
      status = -1;
    }
  }
  return (status);
}
}
static int volatile   initialized___3  =    (int volatile   )0;
static int InitInterp___0(Tcl_Interp *interp , NsServer *servPtr , NsInterp **itPtrPtr ) 
{ NsInterp *itPtr ;
  int result ;
  int updateResult ;
  int tmp ;

  {
  result = 0;
  updateResult = 0;
  tmp = Tcl_Init(interp);
  if (tmp != 0) {
    Ns_TclLogError(interp);
    result = 1;
  }
  if (! initialized___3) {
    Ns_MasterLock();
    if (! initialized___3) {
      NsTclInitQueueType();
      NsTclInitAddrType();
      NsTclInitTimeType();
      initialized___3 = (int volatile   )1;
    }
    Ns_MasterUnlock();
  }
  itPtr = (NsInterp *)ns_calloc(1U, sizeof(NsInterp ));
  itPtr->interp = interp;
  itPtr->servPtr = servPtr;
  Tcl_InitHashTable(& itPtr->sets, 0);
  Tcl_InitHashTable(& itPtr->chans, 0);
  Tcl_InitHashTable(& itPtr->https, 0);
  Tcl_SetAssocData(interp, (char *)"ns:data", & FreeData___0, (void *)itPtr);
  NsTclAddCmds(interp, itPtr);
  if ((unsigned int )servPtr != (unsigned int )((void *)0)) {
    NsTclAddServerCmds(interp, itPtr);
    RunTraces___2(itPtr, 0);
    RunTraces___2(itPtr, 1);
    if (nsconf.tcl.lockoninit) {
      Ns_MutexLock(& initLock___0);
    }
    updateResult = UpdateInterp___0(itPtr);
    if (nsconf.tcl.lockoninit) {
      Ns_MutexUnlock(& initLock___0);
    }
    if (updateResult != 0) {
      Ns_TclLogError(interp);
      result = 1;
    }
  }
  if ((unsigned int )itPtrPtr != (unsigned int )((void *)0)) {
    (*itPtrPtr) = itPtr;
  }
  return (result);
}
}
static int UpdateInterp___0(NsInterp *itPtr ) 
{ int result ;

  {
  result = 0;
  Ns_RWLockRdLock(& (itPtr->servPtr)->tcl.lock);
  if (itPtr->epoch != (itPtr->servPtr)->tcl.epoch) {
    result = Tcl_EvalEx(itPtr->interp, (itPtr->servPtr)->tcl.script, (itPtr->servPtr)->tcl.length,
                        131072);
    itPtr->epoch = (itPtr->servPtr)->tcl.epoch;
  }
  Ns_RWLockUnlock(& (itPtr->servPtr)->tcl.lock);
  return (result);
}
}
static void FreeData___0(ClientData arg , Tcl_Interp *interp ) 
{ NsInterp *itPtr ;

  {
  itPtr = (NsInterp *)arg;
  NsFreeAdp(itPtr);
  Tcl_DeleteHashTable(& itPtr->sets);
  Tcl_DeleteHashTable(& itPtr->chans);
  Tcl_DeleteHashTable(& itPtr->https);
  ns_free((void *)itPtr);
  return;
}
}
static void DeleteInterps___0(void *arg ) 
{ Tcl_HashTable *tablePtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;
  NsInterp *itPtr ;

  {
  tablePtr = (Tcl_HashTable *)arg;
  hPtr = Tcl_FirstHashEntry(tablePtr, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    while (1) {
      itPtr = (NsInterp *)hPtr->clientData;
      if (! ((unsigned int )itPtr != (unsigned int )((void *)0))) {
        break;
      }
      hPtr->clientData = (void *)itPtr->nextPtr;
      RunTraces___2(itPtr, 3);
      Tcl_DeleteInterp(itPtr->interp);
    }
    hPtr = Tcl_NextHashEntry(& search);
  }
  Tcl_DeleteHashTable(tablePtr);
  ns_free((void *)tablePtr);
  Tcl_FinalizeThread();
  return;
}
}
static Tcl_HashEntry *GetHashEntry___0(NsServer *servPtr ) 
{ Tcl_HashTable *tablePtr ;
  int ignored ;
  Tcl_HashEntry *tmp ;

  {
  tablePtr = (Tcl_HashTable *)Ns_TlsGet(& tls___3);
  if ((unsigned int )tablePtr == (unsigned int )((void *)0)) {
    tablePtr = (Tcl_HashTable *)ns_malloc(sizeof(Tcl_HashTable ));
    Tcl_InitHashTable(tablePtr, 1);
    Ns_TlsSet(& tls___3, (void *)tablePtr);
  }
  tmp = ((*(tablePtr->createProc)))(tablePtr, (char *)servPtr, & ignored);
  return (tmp);
}
}
static int RegisterTrace___0(NsServer *servPtr , int idx , Ns_TclTraceProc *proc ,
                             void *arg ) 
{ Trace___0 *tracePtr ;
  Trace___0 **firstPtrPtr ;

  {
  if ((unsigned int )servPtr == (unsigned int )((void *)0)) {
    return (-1);
  }
  tracePtr = (Trace___0 *)ns_malloc(sizeof(Trace___0 ));
  tracePtr->proc = proc;
  tracePtr->arg = arg;
  tracePtr->nextPtr = (struct Trace1 *)((void *)0);
  firstPtrPtr = (Trace___0 **)(& servPtr->tcl.traces[idx]);
  while ((unsigned int )(*firstPtrPtr) != (unsigned int )((void *)0)) {
    firstPtrPtr = & ((*firstPtrPtr))->nextPtr;
  }
  (*firstPtrPtr) = tracePtr;
  return (0);
}
}
static void RunTraces___2(NsInterp *itPtr , int idx ) 
{ Trace___0 *tracePtr ;
  int tmp ;

  {
  if ((unsigned int )itPtr->servPtr != (unsigned int )((void *)0)) {
    tracePtr = (Trace___0 *)(itPtr->servPtr)->tcl.traces[idx];
    while ((unsigned int )tracePtr != (unsigned int )((void *)0)) {
      tmp = ((*(tracePtr->proc)))(itPtr->interp, tracePtr->arg);
      if (tmp != 0) {
        Ns_TclLogError(itPtr->interp);
      }
      tracePtr = tracePtr->nextPtr;
    }
  }
  return;
}
}
static void JobThread___0(void *arg ) ;
static Job *getNextJob___0(void) ;
static int LookupQueue___0(Tcl_Interp *interp , char *queueId , Queue___0 **queuePtr ,
                           int locked ) ;
static int ReleaseQueue___0(Queue___0 *queuePtr , int locked ) ;
static int AnyDone___0(Queue___0 *queue___1 ) ;
static char *GetJobCodeStr___0(int code ) ;
static char *GetJobStateStr___0(JobStates state ) ;
static char *GetJobTypeStr___0(JobTypes type ) ;
static char *GetJobReqStr___0(JobRequests req ) ;
static char *GetQueueReqStr___0(QueueRequests req ) ;
static char *GetTpReqStr___0(ThreadPoolRequests req ) ;
static int AppendField___0(Tcl_Interp *interp , Tcl_Obj *list , char *name , char *value ) ;
static int AppendFieldInt___0(Tcl_Interp *interp , Tcl_Obj *list , char *name , int value ) ;
static int AppendFieldLong___0(Tcl_Interp *interp , Tcl_Obj *list , char *name , long value ) ;
static int AppendFieldDouble___0(Tcl_Interp *interp , Tcl_Obj *list , char *name ,
                                 double value ) ;
static double ComputeDelta___0(Ns_Time *start , Ns_Time *end ) ;
static ThreadPool tp___0  ;
static char *opts___23[13]  = 
  {      (char *)"cancel",      (char *)"create",      (char *)"delete",      (char *)"genid", 
        (char *)"jobs",      (char *)"joblist",      (char *)"threadlist",      (char *)"queue", 
        (char *)"queues",      (char *)"queuelist",      (char *)"wait",      (char *)"waitany", 
        (char *)((void *)0)};
static void JobThread___0(void *arg ) 
{ Tcl_Interp *interp ;
  Job *jobPtr ;
  char buf[100] ;
  char *err ;
  Queue___0 *queuePtr ;
  Tcl_HashEntry *jPtr ;
  int tmp ;
  char *tmp___0 ;

  {
  Ns_WaitForStartup();
  Ns_MutexLock(& tp___0.queuelock);
  tmp = tp___0.nextThreadId;
  tp___0.nextThreadId = tp___0.nextThreadId + 1;
  snprintf((char * __restrict  )(buf), 100U, (char const   * __restrict  )"-ns_job_%x-",
           tmp);
  Ns_ThreadSetName(buf);
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"Starting thread: %s", buf);
  while (1) {
    tp___0.nidle = tp___0.nidle + 1;
    while (1) {
      jobPtr = getNextJob___0();
      if ((unsigned int )jobPtr == (unsigned int )((void *)0)) {
        if (! (! ((int )tp___0.req == 1))) {
          break;
        }
      } else {
        break;
      }
      Ns_CondWait(& tp___0.cond, & tp___0.queuelock);
    }
    tp___0.nidle = tp___0.nidle - 1;
    if ((int )tp___0.req == 1) {
      break;
    }
    Ns_MutexUnlock(& tp___0.queuelock);
    interp = Ns_TclAllocateInterp(jobPtr->server);
    Ns_GetTime(& jobPtr->endTime);
    Ns_GetTime(& jobPtr->startTime);
    jobPtr->code = Tcl_EvalEx(interp, jobPtr->script.string, -1, 0);
    tmp___0 = Tcl_GetStringResult(interp);
    Tcl_DStringAppend(& jobPtr->results, tmp___0, -1);
    err = Tcl_GetVar(interp, (char *)"errorCode", 1);
    if ((unsigned int )err != (unsigned int )((void *)0)) {
      jobPtr->errorCode = ns_strdup((char const   *)err);
    }
    err = Tcl_GetVar(interp, (char *)"errorInfo", 1);
    if ((unsigned int )err != (unsigned int )((void *)0)) {
      jobPtr->errorInfo = ns_strdup((char const   *)err);
    }
    Ns_GetTime(& jobPtr->endTime);
    Ns_TclDeAllocateInterp(interp);
    Ns_MutexLock(& tp___0.queuelock);
    LookupQueue___0((Tcl_Interp *)((void *)0), jobPtr->queueId, & queuePtr, 1);
    queuePtr->nRunning = queuePtr->nRunning - 1;
    jobPtr->state = (enum JobStates )2;
    if ((int )jobPtr->req == 2) {
      jPtr = ((*(queuePtr->jobs.findProc)))(& queuePtr->jobs, jobPtr->id.string);
      Tcl_DeleteHashEntry(jPtr);
      FreeJob(jobPtr);
    } else {
      if ((int )jobPtr->type == 1) {
        jPtr = ((*(queuePtr->jobs.findProc)))(& queuePtr->jobs, jobPtr->id.string);
        Tcl_DeleteHashEntry(jPtr);
        FreeJob(jobPtr);
      }
    }
    Ns_CondBroadcast(& queuePtr->cond);
    ReleaseQueue___0(queuePtr, 1);
  }
  tp___0.nthreads = tp___0.nthreads - 1;
  Ns_CondBroadcast(& tp___0.cond);
  Ns_MutexUnlock(& tp___0.queuelock);
  Ns_Log((enum __anonenum_Ns_LogSeverity_67 )0, (char *)"exiting");
  return;
}
}
static Job *getNextJob___0(void) 
{ Queue___0 *queuePtr ;
  Tcl_HashEntry *jPtr ;
  Job *prev ;
  Job *tmp ;
  Job *jobPtr ;
  int done ;

  {
  prev = (Job *)((void *)0);
  tmp = (Job *)((void *)0);
  jobPtr = (Job *)((void *)0);
  done = 0;
  jobPtr = tp___0.firstPtr;
  prev = tp___0.firstPtr;
  while (1) {
    if (! done) {
      if (! ((unsigned int )jobPtr != (unsigned int )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    LookupQueue___0((Tcl_Interp *)((void *)0), jobPtr->queueId, & queuePtr, 1);
    if ((int )jobPtr->req == 2) {
      tmp = jobPtr;
      if ((unsigned int )jobPtr == (unsigned int )tp___0.firstPtr) {
        tp___0.firstPtr = jobPtr->nextPtr;
      } else {
        prev->nextPtr = jobPtr->nextPtr;
      }
      jobPtr = jobPtr->nextPtr;
      jPtr = ((*(queuePtr->jobs.findProc)))(& queuePtr->jobs, tmp->id.string);
      Tcl_DeleteHashEntry(jPtr);
      FreeJob(tmp);
    } else {
      if (queuePtr->nRunning < queuePtr->maxThreads) {
        if ((unsigned int )jobPtr == (unsigned int )tp___0.firstPtr) {
          tp___0.firstPtr = jobPtr->nextPtr;
        } else {
          prev->nextPtr = jobPtr->nextPtr;
        }
        done = 1;
        jobPtr->state = (enum JobStates )1;
        queuePtr->nRunning = queuePtr->nRunning + 1;
      } else {
        prev = jobPtr;
        jobPtr = jobPtr->nextPtr;
      }
    }
    ReleaseQueue___0(queuePtr, 1);
  }
  return (jobPtr);
}
}
static int LookupQueue___0(Tcl_Interp *interp , char *queueId , Queue___0 **queuePtr ,
                           int locked ) 
{ Tcl_HashEntry *hPtr ;

  {
  if (! locked) {
    Ns_MutexLock(& tp___0.queuelock);
  }
  (*queuePtr) = (Queue___0 *)((void *)0);
  hPtr = ((*(tp___0.queues.findProc)))(& tp___0.queues, queueId);
  if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    (*queuePtr) = (Queue___0 *)hPtr->clientData;
    Ns_MutexLock(& ((*queuePtr))->lock);
    ((*queuePtr))->refCount = ((*queuePtr))->refCount + 1;
  }
  if (! locked) {
    Ns_MutexUnlock(& tp___0.queuelock);
  }
  if ((unsigned int )(*queuePtr) == (unsigned int )((void *)0)) {
    if ((unsigned int )interp != (unsigned int )((void *)0)) {
      Tcl_AppendResult(interp, "no such queue: ", queueId, (void *)0);
    }
    return (1);
  }
  return (0);
}
}
static int ReleaseQueue___0(Queue___0 *queuePtr , int locked ) 
{ Tcl_HashEntry *qPtr ;
  Tcl_HashSearch search ;
  int deleted ;
  Tcl_HashEntry *tmp ;

  {
  deleted = 0;
  queuePtr->refCount = queuePtr->refCount - 1;
  if ((int )queuePtr->req == 1) {
    if (queuePtr->refCount <= 0) {
      tmp = Tcl_FirstHashEntry(& queuePtr->jobs, & search);
      if ((unsigned int )tmp == (unsigned int )((void *)0)) {
        if (! locked) {
          Ns_MutexLock(& tp___0.queuelock);
        }
        qPtr = ((*(tp___0.queues.findProc)))(& tp___0.queues, queuePtr->name);
        if ((unsigned int )qPtr != (unsigned int )((void *)0)) {
          Tcl_DeleteHashEntry(qPtr);
          tp___0.maxThreads = tp___0.maxThreads - queuePtr->maxThreads;
          deleted = 1;
        }
        Ns_MutexUnlock(& queuePtr->lock);
        FreeQueue(queuePtr);
        if (! locked) {
          Ns_MutexUnlock(& tp___0.queuelock);
        }
      } else {
        Ns_MutexUnlock(& queuePtr->lock);
      }
    } else {
      Ns_MutexUnlock(& queuePtr->lock);
    }
  } else {
    Ns_MutexUnlock(& queuePtr->lock);
  }
  return (deleted);
}
}
static int AnyDone___0(Queue___0 *queue___1 ) 
{ Tcl_HashEntry *hPtr ;
  Job *jobPtr ;
  Tcl_HashSearch search ;

  {
  hPtr = Tcl_FirstHashEntry(& queue___1->jobs, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    jobPtr = (Job *)hPtr->clientData;
    if ((int )jobPtr->state == 2) {
      return (1);
    }
    hPtr = Tcl_NextHashEntry(& search);
  }
  return (0);
}
}
static char *codeArr___0[6]  = {      (char *)"TCL_OK",      (char *)"TCL_ERROR",      (char *)"TCL_RETURN",      (char *)"TCL_BREAK", 
        (char *)"TCL_CONTINUE",      (char *)"UNKNOWN_CODE"};
static int max_code_index___0  =    5;
static char *GetJobCodeStr___0(int code ) 
{ 

  {
  if (code > max_code_index___0) {
    code = max_code_index___0;
  }
  return (codeArr___0[code]);
}
}
static char *stateArr___0[4]  = {      (char *)"scheduled",      (char *)"running",      (char *)"done",      (char *)"unknown"};
static int max_state_index___0  =    3;
static char *GetJobStateStr___0(JobStates state ) 
{ 

  {
  if ((int )state > max_state_index___0) {
    state = (enum JobStates )max_state_index___0;
  }
  return (stateArr___0[state]);
}
}
static char *typeArr___0[3]  = {      (char *)"nondetached",      (char *)"detached",      (char *)"unknown"};
static int max_type_index___0  =    2;
static char *GetJobTypeStr___0(JobTypes type ) 
{ 

  {
  if ((int )type > max_type_index___0) {
    type = (enum JobTypes )max_type_index___0;
  }
  return (typeArr___0[type]);
}
}
static char *reqArr___2[4]  = {      (char *)"none",      (char *)"wait",      (char *)"cancel",      (char *)"unknown"};
static int req_max_index___2  =    3;
static char *GetJobReqStr___0(JobRequests req ) 
{ 

  {
  if ((int )req > req_max_index___2) {
    req = (enum JobRequests )req_max_index___2;
  }
  return (reqArr___2[req]);
}
}
static char *reqArr___3[2]  = {      (char *)"none",      (char *)"delete"};
static int req_max_index___3  =    1;
static char *GetQueueReqStr___0(QueueRequests req ) 
{ 

  {
  if ((int )req > req_max_index___3) {
    req = (enum QueueRequests )req_max_index___3;
  }
  return (reqArr___3[req]);
}
}
static char *reqArr___4[2]  = {      (char *)"none",      (char *)"stop"};
static int req_max_index___4  =    1;
static char *GetTpReqStr___0(ThreadPoolRequests req ) 
{ 

  {
  if ((int )req > req_max_index___4) {
    req = (enum ThreadPoolRequests )req_max_index___4;
  }
  return (reqArr___4[req]);
}
}
static int AppendField___0(Tcl_Interp *interp , Tcl_Obj *list , char *name , char *value ) 
{ size_t tmp ;
  Tcl_Obj *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  Tcl_Obj *tmp___3 ;
  int tmp___4 ;

  {
  tmp = strlen((char const   *)name);
  tmp___0 = Tcl_NewStringObj(name, (int )tmp);
  tmp___1 = Tcl_ListObjAppendElement(interp, list, tmp___0);
  if (tmp___1 == 1) {
    return (1);
  }
  tmp___2 = strlen((char const   *)value);
  tmp___3 = Tcl_NewStringObj(value, (int )tmp___2);
  tmp___4 = Tcl_ListObjAppendElement(interp, list, tmp___3);
  if (tmp___4 == 1) {
    return (1);
  }
  return (0);
}
}
static int AppendFieldInt___0(Tcl_Interp *interp , Tcl_Obj *list , char *name , int value ) 
{ size_t tmp ;
  Tcl_Obj *tmp___0 ;
  int tmp___1 ;
  Tcl_Obj *tmp___2 ;
  int tmp___3 ;

  {
  tmp = strlen((char const   *)name);
  tmp___0 = Tcl_NewStringObj(name, (int )tmp);
  tmp___1 = Tcl_ListObjAppendElement(interp, list, tmp___0);
  if (tmp___1 == 1) {
    return (1);
  }
  tmp___2 = Tcl_NewIntObj(value);
  tmp___3 = Tcl_ListObjAppendElement(interp, list, tmp___2);
  if (tmp___3 == 1) {
    return (1);
  }
  return (0);
}
}
static int AppendFieldLong___0(Tcl_Interp *interp , Tcl_Obj *list , char *name , long value ) 
{ size_t tmp ;
  Tcl_Obj *tmp___0 ;
  int tmp___1 ;
  Tcl_Obj *tmp___2 ;
  int tmp___3 ;

  {
  tmp = strlen((char const   *)name);
  tmp___0 = Tcl_NewStringObj(name, (int )tmp);
  tmp___1 = Tcl_ListObjAppendElement(interp, list, tmp___0);
  if (tmp___1 == 1) {
    return (1);
  }
  tmp___2 = Tcl_NewLongObj(value);
  tmp___3 = Tcl_ListObjAppendElement(interp, list, tmp___2);
  if (tmp___3 == 1) {
    return (1);
  }
  return (0);
}
}
static int AppendFieldDouble___0(Tcl_Interp *interp , Tcl_Obj *list , char *name ,
                                 double value ) 
{ size_t tmp ;
  Tcl_Obj *tmp___0 ;
  int tmp___1 ;
  Tcl_Obj *tmp___2 ;
  int tmp___3 ;

  {
  tmp = strlen((char const   *)name);
  tmp___0 = Tcl_NewStringObj(name, (int )tmp);
  tmp___1 = Tcl_ListObjAppendElement(interp, list, tmp___0);
  if (tmp___1 == 1) {
    return (1);
  }
  tmp___2 = Tcl_NewDoubleObj(value);
  tmp___3 = Tcl_ListObjAppendElement(interp, list, tmp___2);
  if (tmp___3 == 1) {
    return (1);
  }
  return (0);
}
}
static double ComputeDelta___0(Ns_Time *start , Ns_Time *end ) 
{ Ns_Time diff ;

  {
  Ns_DiffTime(end, start, & diff);
  return ((double )diff.sec * 1000.0 + (double )diff.usec / 1000.0);
}
}
static int WordEndsInSemi___0(char *ip ) ;
static int TmObjCmd___0(ClientData isgmt , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ time_t now ;
  struct tm *ptm ;
  Tcl_Obj *objPtr[9] ;
  Tcl_Obj *tmp ;

  {
  if (objc != 1) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"");
    return (1);
  }
  now = time((time_t *)((void *)0));
  if (isgmt) {
    ptm = ns_gmtime((time_t const   *)(& now));
  } else {
    ptm = ns_localtime((time_t const   *)(& now));
  }
  objPtr[0] = Tcl_NewIntObj(ptm->tm_sec);
  objPtr[1] = Tcl_NewIntObj(ptm->tm_min);
  objPtr[2] = Tcl_NewIntObj(ptm->tm_hour);
  objPtr[3] = Tcl_NewIntObj(ptm->tm_mday);
  objPtr[4] = Tcl_NewIntObj(ptm->tm_mon);
  objPtr[5] = Tcl_NewIntObj(ptm->tm_year);
  objPtr[6] = Tcl_NewIntObj(ptm->tm_wday);
  objPtr[7] = Tcl_NewIntObj(ptm->tm_yday);
  objPtr[8] = Tcl_NewIntObj(ptm->tm_isdst);
  tmp = Tcl_GetObjResult(interp);
  Tcl_SetListObj(tmp, 9, objPtr);
  return (0);
}
}
static char *opts___24[8]  = 
  {      (char *)"adjust",      (char *)"diff",      (char *)"get",      (char *)"incr", 
        (char *)"make",      (char *)"seconds",      (char *)"microseconds",      (char *)((void *)0)};
static int WordEndsInSemi___0(char *ip ) 
{ 

  {
  if ((unsigned int )ip == (unsigned int )((void *)0)) {
    return (0);
  }
  if ((int )(*ip) == 38) {
    ip ++;
  }
  while (1) {
    if ((int )(*ip) != 0) {
      if ((int )(*ip) != 32) {
        if ((int )(*ip) != 59) {
          if (! ((int )(*ip) != 38)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    ip ++;
  }
  if ((int )(*ip) == 59) {
    return (1);
  } else {
    return (0);
  }
}
}
static void SetTimeInternalRep___0(Tcl_Obj *objPtr , Ns_Time *timePtr ) ;
static int SetTimeFromAny___0(Tcl_Interp *interp , Tcl_Obj *objPtr ) ;
static void UpdateStringOfTime___0(Tcl_Obj *objPtr ) ;
static struct Tcl_ObjType timeType___0  =    {(char *)"ns:time", (Tcl_FreeInternalRepProc *)((void *)0), (Tcl_DupInternalRepProc *)((void *)0),
    & UpdateStringOfTime___0, & SetTimeFromAny___0};
static Tcl_ObjType *intTypePtr___0  ;
static void UpdateStringOfTime___0(Tcl_Obj *objPtr ) 
{ Ns_Time *timePtr ;
  size_t len ;
  char buf[100] ;

  {
  timePtr = (Ns_Time *)(& objPtr->internalRep);
  Ns_AdjTime(timePtr);
  if (timePtr->usec == 0L) {
    len = (size_t )sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%ld",
                           timePtr->sec);
  } else {
    len = (size_t )sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%ld:%ld",
                           timePtr->sec, timePtr->usec);
  }
  objPtr->length = (int )len;
  objPtr->bytes = Tcl_Alloc(len + 1U);
  memcpy((void * __restrict  )objPtr->bytes, (void const   * __restrict  )(buf), len +
                                                                                 1U);
  return;
}
}
static int SetTimeFromAny___0(Tcl_Interp *interp , Tcl_Obj *objPtr ) 
{ char *str ;
  char *sep ;
  Ns_Time time___0 ;
  int result ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  str = Tcl_GetString(objPtr);
  tmp___0 = strchr((char const   *)str, ':');
  sep = tmp___0;
  if ((unsigned int )objPtr->typePtr == (unsigned int )intTypePtr___0) {
    goto _L;
  } else {
    if ((unsigned int )sep == (unsigned int )((void *)0)) {
      _L: 
      tmp___1 = Tcl_GetLongFromObj(interp, objPtr, & time___0.sec);
      if (tmp___1 != 0) {
        return (1);
      }
      time___0.usec = 0L;
    } else {
      (*sep) = (char )'\000';
      result = Tcl_GetInt(interp, str, (int *)(& time___0.sec));
      (*sep) = (char )':';
      if (result != 0) {
        return (1);
      }
      tmp___2 = Tcl_GetInt(interp, sep + 1, (int *)(& time___0.usec));
      if (tmp___2 != 0) {
        return (1);
      }
    }
  }
  Ns_AdjTime(& time___0);
  SetTimeInternalRep___0(objPtr, & time___0);
  return (0);
}
}
static void SetTimeInternalRep___0(Tcl_Obj *objPtr , Ns_Time *timePtr ) 
{ Tcl_ObjType *typePtr ;

  {
  typePtr = objPtr->typePtr;
  if ((unsigned int )typePtr != (unsigned int )((void *)0)) {
    if ((unsigned int )typePtr->freeIntRepProc != (unsigned int )((void *)0)) {
      ((*(typePtr->freeIntRepProc)))(objPtr);
    }
  }
  objPtr->typePtr = & timeType___0;
  (*((Ns_Time *)(& objPtr->internalRep))) = (*timePtr);
  Tcl_InvalidateStringRep(objPtr);
  objPtr->length = 0;
  return;
}
}
static int ProcRequest___0(void *arg , Ns_Conn *conn ) ;
static int AdpRequest___0(void *arg , Ns_Conn *conn ) ;
static int ProcFilter___0(void *arg , Ns_Conn *conn , int why ) ;
static Proc *NewProc___0(char *name , char *args ) ;
static void FreeProc___0(void *arg ) ;
static void AppendConnId___0(Tcl_DString *dsPtr , Ns_Conn *conn ) ;
static void RegisterFilterObj___0(NsInterp *itPtr , int when , int objc , Tcl_Obj **objv ) ;
static int GetNumArgs___0(Tcl_Interp *interp , Proc *procPtr ) ;
static int AdpRequest___0(void *arg , Ns_Conn *conn ) 
{ int tmp ;

  {
  tmp = Ns_AdpRequest(conn, (char *)arg);
  return (tmp);
}
}
static int ProcRequest___0(void *arg , Ns_Conn *conn ) 
{ Proc *procPtr ;
  Tcl_Interp *interp ;
  int cnt ;
  Tcl_DString cmd ;
  int retval ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  procPtr = (Proc *)arg;
  retval = 0;
  Tcl_DStringInit(& cmd);
  Tcl_DStringAppendElement(& cmd, procPtr->name);
  interp = Ns_GetConnInterp(conn);
  cnt = GetNumArgs___0(interp, procPtr);
  if (cnt != 0) {
    if (cnt > 1) {
      AppendConnId___0(& cmd, conn);
    }
    if (procPtr->args) {
      tmp = (char const   *)procPtr->args;
    } else {
      tmp = "";
    }
    Tcl_DStringAppendElement(& cmd, (char *)tmp);
  }
  tmp___1 = Tcl_GlobalEval(interp, cmd.string);
  if (tmp___1 != 0) {
    Ns_TclLogError(interp);
    tmp___0 = Ns_ConnResetReturn(conn);
    if (tmp___0 == 0) {
      retval = Ns_ConnReturnInternalError(conn);
    }
  }
  Tcl_DStringFree(& cmd);
  return (retval);
}
}
static int ProcFilter___0(void *arg , Ns_Conn *conn , int why ) 
{ Proc *procPtr ;
  Tcl_DString cmd ;
  Tcl_Interp *interp ;
  int status ;
  int cnt ;
  char *result ;
  char const   *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___20 ;
  size_t tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
  procPtr = (Proc *)arg;
  Tcl_DStringInit(& cmd);
  Tcl_DStringAppendElement(& cmd, procPtr->name);
  interp = Ns_GetConnInterp(conn);
  cnt = GetNumArgs___0(interp, procPtr);
  if (cnt > 1) {
    if (cnt > 2) {
      AppendConnId___0(& cmd, conn);
    }
    if (procPtr->args) {
      tmp = (char const   *)procPtr->args;
    } else {
      tmp = "";
    }
    Tcl_DStringAppendElement(& cmd, (char *)tmp);
  }
  switch (why) {
  case 1: 
  Tcl_DStringAppendElement(& cmd, (char *)"preauth");
  break;
  case 2: 
  Tcl_DStringAppendElement(& cmd, (char *)"postauth");
  break;
  case 4: 
  Tcl_DStringAppendElement(& cmd, (char *)"trace");
  break;
  }
  Tcl_AllowExceptions(interp);
  status = Tcl_GlobalEval(interp, cmd.string);
  if (status != 0) {
    Ns_TclLogError(interp);
  }
  result = Tcl_GetStringResult(interp);
  if (why == 8) {
    status = 0;
  } else {
    if (status != 0) {
      status = -1;
    } else {
      if ((int )(*result) == (int )(*"filter_ok")) {
        if (0) {
          __s1_len___1 = strlen((char const   *)result);
          __s2_len___1 = strlen("filter_ok");
          if (! ((unsigned int )((void const   *)(result + 1)) - (unsigned int )((void const   *)result) ==
                 1U)) {
            goto _L___5;
          } else {
            if (__s1_len___1 >= 4U) {
              _L___5: 
              if (! ((unsigned int )((void const   *)("filter_ok" + 1)) - (unsigned int )((void const   *)"filter_ok") ==
                     1U)) {
                tmp___23 = 1;
              } else {
                if (__s2_len___1 >= 4U) {
                  tmp___23 = 1;
                } else {
                  tmp___23 = 0;
                }
              }
            } else {
              tmp___23 = 0;
            }
          }
          if (tmp___23) {
            if (__s1_len___1 < __s2_len___1) {
              tmp___21 = __s1_len___1;
            } else {
              tmp___21 = __s2_len___1;
            }
            tmp___20 = memcmp((void const   *)((char const   *)result), (void const   *)"filter_ok",
                              tmp___21 + 1U);
          } else {
            tmp___22 = strcmp((char const   *)result, "filter_ok");
            tmp___20 = tmp___22;
          }
        } else {
          tmp___22 = strcmp((char const   *)result, "filter_ok");
          tmp___20 = tmp___22;
        }
        if (tmp___20 == 0) {
          status = 0;
        } else {
          goto _L___6;
        }
      } else {
        _L___6: 
        if ((int )(*result) == (int )(*"filter_break")) {
          if (0) {
            __s1_len___0 = strlen((char const   *)result);
            __s2_len___0 = strlen("filter_break");
            if (! ((unsigned int )((void const   *)(result + 1)) - (unsigned int )((void const   *)result) ==
                   1U)) {
              goto _L___2;
            } else {
              if (__s1_len___0 >= 4U) {
                _L___2: 
                if (! ((unsigned int )((void const   *)("filter_break" + 1)) - (unsigned int )((void const   *)"filter_break") ==
                       1U)) {
                  tmp___15 = 1;
                } else {
                  if (__s2_len___0 >= 4U) {
                    tmp___15 = 1;
                  } else {
                    tmp___15 = 0;
                  }
                }
              } else {
                tmp___15 = 0;
              }
            }
            if (tmp___15) {
              if (__s1_len___0 < __s2_len___0) {
                tmp___13 = __s1_len___0;
              } else {
                tmp___13 = __s2_len___0;
              }
              tmp___12 = memcmp((void const   *)((char const   *)result), (void const   *)"filter_break",
                                tmp___13 + 1U);
            } else {
              tmp___14 = strcmp((char const   *)result, "filter_break");
              tmp___12 = tmp___14;
            }
          } else {
            tmp___14 = strcmp((char const   *)result, "filter_break");
            tmp___12 = tmp___14;
          }
          if (tmp___12 == 0) {
            status = -4;
          } else {
            goto _L___3;
          }
        } else {
          _L___3: 
          if ((int )(*result) == (int )(*"filter_return")) {
            if (0) {
              __s1_len = strlen((char const   *)result);
              __s2_len = strlen("filter_return");
              if (! ((unsigned int )((void const   *)(result + 1)) - (unsigned int )((void const   *)result) ==
                     1U)) {
                goto _L___0;
              } else {
                if (__s1_len >= 4U) {
                  _L___0: 
                  if (! ((unsigned int )((void const   *)("filter_return" + 1)) -
                         (unsigned int )((void const   *)"filter_return") == 1U)) {
                    tmp___7 = 1;
                  } else {
                    if (__s2_len >= 4U) {
                      tmp___7 = 1;
                    } else {
                      tmp___7 = 0;
                    }
                  }
                } else {
                  tmp___7 = 0;
                }
              }
              if (tmp___7) {
                if (__s1_len < __s2_len) {
                  tmp___5 = __s1_len;
                } else {
                  tmp___5 = __s2_len;
                }
                tmp___4 = memcmp((void const   *)((char const   *)result), (void const   *)"filter_return",
                                 tmp___5 + 1U);
              } else {
                tmp___6 = strcmp((char const   *)result, "filter_return");
                tmp___4 = tmp___6;
              }
            } else {
              tmp___6 = strcmp((char const   *)result, "filter_return");
              tmp___4 = tmp___6;
            }
            if (tmp___4 == 0) {
              status = -5;
            } else {
              Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"tclfilter: %s return invalid result: %s",
                     procPtr->name, result);
              status = -1;
            }
          } else {
            Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"tclfilter: %s return invalid result: %s",
                   procPtr->name, result);
            status = -1;
          }
        }
      }
    }
  }
  Tcl_DStringFree(& cmd);
  return (status);
}
}
static int GetNumArgs___0(Tcl_Interp *interp , Proc *procPtr ) 
{ Tcl_Obj *objPtr ;
  Tcl_DString ds ;
  int tmp ;
  int tmp___0 ;

  {
  if (procPtr->nargs == -1) {
    Tcl_DStringInit(& ds);
    Tcl_DStringAppend(& ds, (char *)"llength [info args ", -1);
    Tcl_DStringAppendElement(& ds, procPtr->name);
    Tcl_DStringAppend(& ds, (char *)"]", 1);
    tmp___0 = Tcl_Eval(interp, ds.string);
    if (tmp___0 != 0) {
      procPtr->nargs = -2;
    } else {
      objPtr = Tcl_GetObjResult(interp);
      tmp = Tcl_GetIntFromObj(interp, objPtr, & procPtr->nargs);
      if (tmp != 0) {
        procPtr->nargs = -2;
      }
    }
    Tcl_DStringFree(& ds);
  }
  return (procPtr->nargs);
}
}
static void RegisterFilterObj___0(NsInterp *itPtr , int when , int objc , Tcl_Obj **objv ) 
{ Proc *procPtr ;
  char *server ;
  char *method ;
  char *url ;
  char *name ;
  char *args ;

  {
  server = (itPtr->servPtr)->server;
  method = Tcl_GetString((*(objv + 0)));
  url = Tcl_GetString((*(objv + 1)));
  name = Tcl_GetString((*(objv + 2)));
  if (objc > 3) {
    args = Tcl_GetString((*(objv + 3)));
  } else {
    args = (char *)((void *)0);
  }
  procPtr = NewProc___0(name, args);
  Ns_RegisterFilter(server, method, url, & ProcFilter___0, when, (void *)procPtr);
  return;
}
}
static void AppendConnId___0(Tcl_DString *dsPtr , Ns_Conn *conn ) 
{ Conn *connPtr ;

  {
  connPtr = (Conn *)conn;
  Tcl_DStringAppendElement(dsPtr, connPtr->idstr);
  return;
}
}
static Proc *NewProc___0(char *name , char *args ) 
{ Proc *procPtr ;

  {
  procPtr = (Proc *)ns_malloc(sizeof(Proc ));
  procPtr->name = ns_strdup((char const   *)name);
  procPtr->args = ns_strcopy((char const   *)args);
  procPtr->nargs = -1;
  return (procPtr);
}
}
static void FreeProc___0(void *arg ) 
{ Proc *procPtr ;

  {
  procPtr = (Proc *)arg;
  ns_free((void *)procPtr->name);
  if ((unsigned int )procPtr->args != (unsigned int )((void *)0)) {
    ns_free((void *)procPtr->args);
  }
  ns_free((void *)procPtr);
  return;
}
}
static int CheckId___0(Tcl_Interp *interp , char *id ) ;
static int Result___0(Tcl_Interp *interp , int result ) ;
static int GetConn___0(ClientData arg , Tcl_Interp *interp , Ns_Conn **connPtr ) ;
static int ReturnObjCmd___2(ClientData arg , Tcl_Interp *interp , int objc , Tcl_Obj **objv ,
                            int (*proc)(Ns_Conn * ) ) 
{ Ns_Conn *conn ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if (objc != 1) {
    if (objc != 2) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?connid?");
      return (1);
    }
  }
  if (objc == 2) {
    tmp = Tcl_GetString((*(objv + 1)));
    tmp___0 = CheckId___0(interp, tmp);
    if (! tmp___0) {
      return (1);
    }
  }
  tmp___1 = GetConn___0(arg, interp, & conn);
  if (tmp___1 != 0) {
    return (1);
  }
  tmp___2 = ((*proc))(conn);
  tmp___3 = Result___0(interp, tmp___2);
  return (tmp___3);
}
}
static int ReturnNoticeCmd___0(ClientData arg , Tcl_Interp *interp , int argc , char **argv ,
                               int admin ) 
{ int status ;
  int result ;
  Ns_Conn *conn ;
  char *longMessage ;
  int statusArg ;
  int messageArg ;
  int longMessageArg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  longMessage = (char *)((void *)0);
  statusArg = 0;
  messageArg = 0;
  longMessageArg = 0;
  if (argc == 3) {
    statusArg = 1;
    messageArg = 2;
  } else {
    if (argc == 4) {
      tmp = NsIsIdConn((*(argv + 1)));
      if (tmp == 1) {
        statusArg = 2;
        messageArg = 3;
      } else {
        statusArg = 1;
        messageArg = 2;
        longMessageArg = 3;
      }
    } else {
      if (argc == 5) {
        statusArg = 2;
        messageArg = 3;
        longMessageArg = 4;
      } else {
        Tcl_AppendResult(interp, "wrong # of args: should be \"", (*(argv + 0)), " status title ?message?\"",
                         (void *)0);
        return (1);
      }
    }
  }
  tmp___0 = GetConn___0(arg, interp, & conn);
  if (tmp___0 != 0) {
    return (1);
  }
  tmp___1 = Tcl_GetInt(interp, (*(argv + statusArg)), & status);
  if (tmp___1 != 0) {
    return (1);
  }
  if (longMessageArg != 0) {
    longMessage = (*(argv + longMessageArg));
  }
  if (admin) {
    result = Ns_ConnReturnAdminNotice(conn, status, (*(argv + messageArg)), longMessage);
  } else {
    result = Ns_ConnReturnNotice(conn, status, (*(argv + messageArg)), longMessage);
  }
  tmp___2 = Result___0(interp, result);
  return (tmp___2);
}
}
static int CheckId___0(Tcl_Interp *interp , char *id ) 
{ int tmp ;

  {
  tmp = NsIsIdConn(id);
  if (! tmp) {
    Tcl_AppendResult(interp, "invalid connid: ", id, (void *)0);
    return (0);
  }
  return (1);
}
}
static int Result___0(Tcl_Interp *interp , int result ) 
{ char const   *tmp ;

  {
  if (result == 0) {
    tmp = "1";
  } else {
    tmp = "0";
  }
  Tcl_SetResult(interp, (char *)tmp, (Tcl_FreeProc *)0);
  return (0);
}
}
static int GetConn___0(ClientData arg , Tcl_Interp *interp , Ns_Conn **connPtr ) 
{ NsInterp *itPtr ;

  {
  itPtr = (NsInterp *)arg;
  if ((unsigned int )itPtr->conn == (unsigned int )((void *)0)) {
    Tcl_SetResult(interp, (char *)"no connection", (Tcl_FreeProc *)0);
    return (1);
  }
  (*connPtr) = itPtr->conn;
  return (0);
}
}
static Callback___1 *NewCallback___0(Tcl_Interp *interp , char *proc , char *arg ) ;
static void EvalCallback___0(void *arg ) ;
static void FreeCallback___0(void *arg ) ;
static void FreeSched___0(void *arg , int id ) ;
static int ReturnValidId___0(Tcl_Interp *interp , int id , Callback___1 *cbPtr ) ;
static int AtCmd___0(AtProc *procPtr , Tcl_Interp *interp , int argc , char **argv ) ;
static int AtCmd___0(AtProc *procPtr , Tcl_Interp *interp , int argc , char **argv ) 
{ Callback___1 *cbPtr ;

  {
  if (argc != 2) {
    if (argc != 3) {
      Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " script | procname ?arg?\"",
                       (void *)0);
      return (1);
    }
  }
  cbPtr = NewCallback___0(interp, (*(argv + 1)), (*(argv + 2)));
  if ((unsigned int )procPtr == (unsigned int )(& Ns_RegisterAtSignal)) {
    ((*procPtr))(& NsTclSignalProc, (void *)cbPtr);
  } else {
    ((*procPtr))(& NsTclCallback, (void *)cbPtr);
  }
  return (0);
}
}
static int SchedCmd___0(Tcl_Interp *interp , int argc , char **argv , int cmd ) 
{ int id ;
  int ok ;
  char buf[10] ;
  int tmp ;

  {
  if (argc != 2) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", (*(argv + 0)), " id\"",
                     (void *)0);
    return (1);
  }
  tmp = Tcl_GetInt(interp, (*(argv + 1)), & id);
  if (tmp != 0) {
    return (1);
  }
  switch (cmd) {
  case 117: ;
  case 99: 
  ok = Ns_Cancel(id);
  break;
  case 112: 
  ok = Ns_Pause(id);
  break;
  case 114: 
  ok = Ns_Resume(id);
  break;
  default: 
  ok = -1;
  }
  if (cmd != 117) {
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", ok);
    Tcl_SetResult(interp, buf, (Tcl_FreeProc *)1);
  }
  return (0);
}
}
static int ReturnValidId___0(Tcl_Interp *interp , int id , Callback___1 *cbPtr ) 
{ char buf[10] ;

  {
  if (id == -1) {
    Tcl_SetResult(interp, (char *)"could not schedule procedure", (Tcl_FreeProc *)0);
    FreeCallback___0((void *)cbPtr);
    return (1);
  }
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", id);
  Tcl_SetResult(interp, buf, (Tcl_FreeProc *)1);
  return (0);
}
}
static void EvalCallback___0(void *arg ) 
{ Callback___1 *cbPtr ;

  {
  cbPtr = (Callback___1 *)arg;
  Ns_TclEval((Tcl_DString *)((void *)0), cbPtr->server, cbPtr->script);
  return;
}
}
static Callback___1 *NewCallback___0(Tcl_Interp *interp , char *proc , char *arg ) 
{ Callback___1 *cbPtr ;
  char *argv[2] ;
  int tmp ;

  {
  argv[0] = proc;
  argv[1] = arg;
  cbPtr = (Callback___1 *)ns_malloc(sizeof(Callback___1 ));
  cbPtr->server = Ns_TclInterpServer(interp);
  if (arg) {
    tmp = 2;
  } else {
    tmp = 1;
  }
  cbPtr->script = Tcl_Concat(tmp, argv);
  return (cbPtr);
}
}
static void FreeCallback___0(void *arg ) 
{ Callback___1 *cbPtr ;

  {
  cbPtr = (Callback___1 *)arg;
  Tcl_Free(cbPtr->script);
  ns_free((void *)cbPtr);
  return;
}
}
static void FreeSched___0(void *arg , int id ) 
{ 

  {
  FreeCallback___0(arg);
  return;
}
}
static int NoServer___0(Tcl_Interp *interp ) ;
static int LookupSet___0(NsInterp *itPtr , char *id , int delete , Ns_Set **setPtr ) ;
static int LookupObjSet___0(NsInterp *itPtr , Tcl_Obj *idPtr , int delete , Ns_Set **setPtr ) ;
static int LookupInterpSet___0(Tcl_Interp *interp , char *id , int delete , Ns_Set **setPtr ) ;
static int EnterSet___0(NsInterp *itPtr , Ns_Set *set , int flags ) ;
static char *opts___25[33]  = 
  {      (char *)"array",      (char *)"cleanup",      (char *)"copy",      (char *)"cput", 
        (char *)"create",      (char *)"delete",      (char *)"delkey",      (char *)"find", 
        (char *)"free",      (char *)"get",      (char *)"icput",      (char *)"idelete", 
        (char *)"idelkey",      (char *)"ifind",      (char *)"iget",      (char *)"isnull", 
        (char *)"iunique",      (char *)"key",      (char *)"list",      (char *)"merge", 
        (char *)"move",      (char *)"name",      (char *)"new",      (char *)"print", 
        (char *)"purge",      (char *)"put",      (char *)"size",      (char *)"split", 
        (char *)"truncate",      (char *)"unique",      (char *)"update",      (char *)"value", 
        (char *)((void *)0)};
static int EnterSet___0(NsInterp *itPtr , Ns_Set *set , int flags ) 
{ Tcl_HashTable *tablePtr ;
  Tcl_HashEntry *hPtr ;
  int new ;
  int next ;
  unsigned char type ;
  char buf[20] ;
  int tmp ;

  {
  if (flags & 2) {
    if ((unsigned int )itPtr->servPtr == (unsigned int )((void *)0)) {
      tmp = NoServer___0(itPtr->interp);
      return (tmp);
    }
    if (flags & 1) {
      type = (unsigned char )'s';
    } else {
      type = (unsigned char )'p';
    }
    tablePtr = & (itPtr->servPtr)->sets.table;
    Ns_MutexLock(& (itPtr->servPtr)->sets.lock);
  } else {
    tablePtr = & itPtr->sets;
    if (flags & 1) {
      type = (unsigned char )'d';
    } else {
      type = (unsigned char )'t';
    }
  }
  next = tablePtr->numEntries;
  while (1) {
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%c%u", type,
            next);
    next ++;
    hPtr = ((*(tablePtr->createProc)))(tablePtr, buf, & new);
    if (! (! new)) {
      break;
    }
  }
  hPtr->clientData = (void *)set;
  Tcl_AppendElement(itPtr->interp, buf);
  if (flags & 2) {
    Ns_MutexUnlock(& (itPtr->servPtr)->sets.lock);
  }
  return (0);
}
}
static int LookupObjSet___0(NsInterp *itPtr , Tcl_Obj *idPtr , int delete , Ns_Set **setPtr ) 
{ char *tmp ;
  int tmp___0 ;

  {
  tmp = Tcl_GetString(idPtr);
  tmp___0 = LookupSet___0(itPtr, tmp, delete, setPtr);
  return (tmp___0);
}
}
static int LookupInterpSet___0(Tcl_Interp *interp , char *id , int delete , Ns_Set **setPtr ) 
{ NsInterp *itPtr ;
  int tmp ;

  {
  itPtr = NsGetInterp(interp);
  if ((unsigned int )itPtr == (unsigned int )((void *)0)) {
    Tcl_SetResult(interp, (char *)"ns_set not supported", (Tcl_FreeProc *)0);
    return (1);
  }
  tmp = LookupSet___0(itPtr, id, delete, setPtr);
  return (tmp);
}
}
static int LookupSet___0(NsInterp *itPtr , char *id , int delete , Ns_Set **setPtr ) 
{ Tcl_HashTable *tablePtr ;
  Tcl_HashEntry *hPtr ;
  Ns_Set *set ;
  int tmp ;

  {
  set = (Ns_Set *)((void *)0);
  if ((int )(*id) == 115) {
    goto _L;
  } else {
    if ((int )(*id) == 112) {
      _L: 
      if ((unsigned int )itPtr->servPtr == (unsigned int )((void *)0)) {
        tmp = NoServer___0(itPtr->interp);
        return (tmp);
      }
      tablePtr = & (itPtr->servPtr)->sets.table;
      Ns_MutexLock(& (itPtr->servPtr)->sets.lock);
    } else {
      tablePtr = & itPtr->sets;
    }
  }
  hPtr = ((*(tablePtr->findProc)))(tablePtr, id);
  if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    set = (Ns_Set *)hPtr->clientData;
    if (delete) {
      Tcl_DeleteHashEntry(hPtr);
    }
  }
  if ((int )(*id) == 115) {
    Ns_MutexUnlock(& (itPtr->servPtr)->sets.lock);
  } else {
    if ((int )(*id) == 112) {
      Ns_MutexUnlock(& (itPtr->servPtr)->sets.lock);
    }
  }
  if ((unsigned int )set == (unsigned int )((void *)0)) {
    Tcl_AppendResult(itPtr->interp, "no such set: ", id, (void *)0);
    return (1);
  }
  (*setPtr) = set;
  return (0);
}
}
static int NoServer___0(Tcl_Interp *interp ) 
{ 

  {
  Tcl_SetResult(interp, (char *)"no server for shared sets", (Tcl_FreeProc *)0);
  return (1);
}
}
static void ShareUnsetVar___0(Tcl_Interp *interp , char *varName , NsShareVar *valuePtr ) ;
static char *ShareTraceProc___0(ClientData clientData , Tcl_Interp *interp , char *name1 ,
                                char *name2 , int flags ) ;
static int ShareVar___0(NsInterp *itPtr , Tcl_Interp *interp , char *varName ) ;
static int InitShare___0(NsServer *servPtr , Tcl_Interp *interp , char *varName ,
                         char *script ) ;
static void RegisterShare___0(NsInterp *itPtr , Tcl_Interp *interp , char *varName ,
                              NsShareVar *valuePtr ) ;
static char *GetGlobalizedName___0(Tcl_DString *dsPtr , char *varName ) ;
static int InitShare___0(NsServer *servPtr , Tcl_Interp *interp , char *varName ,
                         char *script ) 
{ Tcl_HashEntry *hPtr ;
  int new ;
  int result ;

  {
  Ns_MutexLock(& servPtr->share.lock);
  hPtr = ((*(servPtr->share.inits.createProc)))(& servPtr->share.inits, varName, & new);
  if (! new) {
    while ((unsigned int )hPtr->clientData == (unsigned int )((void *)0)) {
      Ns_CondWait(& servPtr->share.cond, & servPtr->share.lock);
    }
    result = 0;
  } else {
    Ns_MutexUnlock(& servPtr->share.lock);
    result = Tcl_EvalEx(interp, script, -1, 0);
    Ns_MutexLock(& servPtr->share.lock);
    hPtr->clientData = (void *)1;
    Ns_CondBroadcast(& servPtr->share.cond);
  }
  Ns_MutexUnlock(& servPtr->share.lock);
  return (result);
}
}
static int ShareVar___0(NsInterp *itPtr , Tcl_Interp *interp , char *varName ) 
{ NsServer *servPtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_DString ds ;
  NsShareVar *valuePtr ;
  char *s ;
  char *globalizedVarName ;
  int new ;
  char *tmp___0 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *string ;
  int length ;
  int argc ;
  char **argv ;
  int x ;
  Tcl_HashEntry *newEntry ;
  Tcl_Obj *newObj ;
  int new___0 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  servPtr = itPtr->servPtr;
  tmp___0 = strchr((char const   *)varName, '(');
  s = tmp___0;
  if ((unsigned int )s != (unsigned int )((void *)0)) {
    tmp___2 = strchr((char const   *)s, ')');
    if ((unsigned int )tmp___2 != (unsigned int )((void *)0)) {
      Tcl_AppendResult(interp, "can\'t share ", varName, ": must share whole arrays",
                       (char *)((void *)0));
      return (1);
    }
  }
  globalizedVarName = GetGlobalizedName___0(& ds, varName);
  Ns_CsEnter(& servPtr->share.cs);
  hPtr = ((*(servPtr->share.vars.createProc)))(& servPtr->share.vars, globalizedVarName,
                                               & new);
  if (! new) {
    valuePtr = (NsShareVar *)hPtr->clientData;
  } else {
    valuePtr = (NsShareVar *)ns_calloc(1U, sizeof(NsShareVar ));
    Ns_CsInit(& valuePtr->lock);
    valuePtr->flags = 0;
    tmp___3 = Tcl_VarEval(interp, "info exists ", globalizedVarName, (void *)0);
    if (tmp___3 != 0) {
      Tcl_AppendResult(interp, "error sharing ", globalizedVarName, " can\'t determine existence of variable",
                       (char *)((void *)0));
      Tcl_DStringFree(& ds);
      return (1);
    }
    if (0) {
      __s1_len = strlen((char const   *)interp->result);
      __s2_len = strlen("1");
      if (! ((unsigned int )((void const   *)(interp->result + 1)) - (unsigned int )((void const   *)interp->result) ==
             1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: 
          if (! ((unsigned int )((void const   *)("1" + 1)) - (unsigned int )((void const   *)"1") ==
                 1U)) {
            tmp___13 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___13 = 1;
            } else {
              tmp___13 = 0;
            }
          }
        } else {
          tmp___13 = 0;
        }
      }
      if (tmp___13) {
        if (__s1_len < __s2_len) {
          tmp___11 = __s1_len;
        } else {
          tmp___11 = __s2_len;
        }
        tmp___10 = memcmp((void const   *)((char const   *)interp->result), (void const   *)"1",
                          tmp___11 + 1U);
      } else {
        tmp___12 = strcmp((char const   *)interp->result, "1");
        tmp___10 = tmp___12;
      }
    } else {
      tmp___12 = strcmp((char const   *)interp->result, "1");
      tmp___10 = tmp___12;
    }
    if (tmp___10 == 0) {
      valuePtr->objPtr = Tcl_GetVar2Ex(interp, globalizedVarName, (char *)((void *)0),
                                       512);
      if ((unsigned int )valuePtr->objPtr != (unsigned int )((void *)0)) {
        string = Tcl_GetStringFromObj(valuePtr->objPtr, & length);
        valuePtr->objPtr = Tcl_NewStringObj(string, length);
        (valuePtr->objPtr)->refCount = (valuePtr->objPtr)->refCount + 1;
        valuePtr->flags = 1;
      } else {
        tmp___5 = Tcl_VarEval(interp, "array get ", globalizedVarName, (void *)0);
        if (tmp___5 == 0) {
          Tcl_InitHashTable(& valuePtr->array, 0);
          tmp___4 = Tcl_SplitList(interp, interp->result, & argc, & argv);
          if (tmp___4 == 0) {
            x = 0;
            while (x < argc) {
              newEntry = ((*(valuePtr->array.createProc)))(& valuePtr->array, (*(argv +
                                                                                 x)),
                                                           & new___0);
              newObj = Tcl_NewStringObj((*(argv + (x + 1))), -1);
              newObj->refCount = newObj->refCount + 1;
              newEntry->clientData = (void *)newObj;
              x += 2;
            }
            Tcl_Free((char *)argv);
          }
          valuePtr->flags = 2;
        }
      }
      Tcl_VarEval(interp, "unset ", globalizedVarName, (void *)0);
    }
    hPtr->clientData = (void *)valuePtr;
  }
  valuePtr->shareCount = valuePtr->shareCount + 1;
  RegisterShare___0(itPtr, interp, globalizedVarName, valuePtr);
  Tcl_VarEval(interp, "global ", varName, (void *)0);
  Ns_CsLeave(& servPtr->share.cs);
  Tcl_DStringFree(& ds);
  return (0);
}
}
static void RegisterShare___0(NsInterp *itPtr , Tcl_Interp *interp , char *varName ,
                              NsShareVar *valuePtr ) 
{ int traceFlags ;
  ClientData data ;
  ClientData shareData ;
  Tcl_Obj *tmp ;
  Tcl_HashSearch search ;
  Tcl_HashEntry *hPtr ;
  char *key___1 ;
  Tcl_Obj *objPtr ;
  char *tmp___0 ;
  Tcl_Obj *tmp___1 ;
  int tmp___2 ;

  {
  traceFlags = 2160;
  shareData = (void *)(& RegisterShare___0);
  data = (void *)0;
  while (1) {
    data = Tcl_VarTraceInfo(interp, varName, traceFlags, & ShareTraceProc___0, data);
    if ((unsigned int )data != (unsigned int )shareData) {
      if (! ((unsigned int )data != (unsigned int )((void *)0))) {
        break;
      }
    } else {
      break;
    }
  }
  if ((unsigned int )data == (unsigned int )((void *)0)) {
    if (valuePtr->flags & 1) {
      tmp = Tcl_DuplicateObj(valuePtr->objPtr);
      Tcl_SetVar2Ex(interp, varName, (char *)((void *)0), tmp, 1);
    } else {
      if (valuePtr->flags & 2) {
        hPtr = Tcl_FirstHashEntry(& valuePtr->array, & search);
        while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
          if (valuePtr->array.keyType == 1) {
            tmp___0 = hPtr->key.oneWordValue;
          } else {
            if (valuePtr->array.keyType == -1) {
              tmp___0 = hPtr->key.oneWordValue;
            } else {
              tmp___0 = hPtr->key.string;
            }
          }
          key___1 = tmp___0;
          objPtr = (Tcl_Obj *)hPtr->clientData;
          tmp___1 = Tcl_DuplicateObj(objPtr);
          Tcl_SetVar2Ex(interp, varName, key___1, tmp___1, 1);
          hPtr = Tcl_NextHashEntry(& search);
        }
      }
    }
    tmp___2 = Tcl_TraceVar2(interp, varName, (char *)((void *)0), traceFlags, & ShareTraceProc___0,
                            shareData);
    if (tmp___2 != 0) {
      Ns_Fatal((char *)"ns_share: could not trace: %s", varName);
    }
  }
  return;
}
}
static void ShareUnsetVar___0(Tcl_Interp *interp , char *varName , NsShareVar *valuePtr ) 
{ int tmp ;

  {
  valuePtr->flags = valuePtr->flags | 8;
  Tcl_UnsetVar(interp, varName, 0);
  tmp = Tcl_TraceVar2(interp, varName, (char *)((void *)0), 2160, & ShareTraceProc___0,
                      (void *)0);
  if (tmp != 0) {
    Ns_Fatal((char *)"ns_share: could not trace: %s", varName);
  }
  valuePtr->flags = valuePtr->flags & -9;
  return;
}
}
static char *ShareTraceProc___0(ClientData clientData , Tcl_Interp *interp , char *name1 ,
                                char *name2 , int flags ) 
{ NsShareVar *valuePtr ;
  Tcl_HashEntry *hPtr ;
  Tcl_HashEntry *nextPtr ;
  Tcl_HashSearch search ;
  Tcl_Obj *objPtr ;
  Tcl_Obj *oldObjPtr ;
  Tcl_Obj *newObjPtr ;
  int new ;
  int destroyed ;
  int bail ;
  char *string ;
  int length ;
  char *name ;
  Tcl_DString ds ;
  NsInterp *itPtr ;
  NsInterp *tmp ;
  NsServer *servPtr ;
  char *tmp___0 ;
  char *tmp___1 ;
  Tcl_Obj *tmp___2 ;
  int tmp___3 ;

  {
  destroyed = 0;
  bail = 0;
  tmp = NsGetInterp(interp);
  itPtr = tmp;
  servPtr = itPtr->servPtr;
  tmp___0 = GetGlobalizedName___0(& ds, name1);
  name = tmp___0;
  Ns_CsEnter(& servPtr->share.cs);
  hPtr = ((*(servPtr->share.vars.findProc)))(& servPtr->share.vars, name);
  if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
    Ns_CsLeave(& servPtr->share.cs);
    goto done;
  }
  valuePtr = (NsShareVar *)hPtr->clientData;
  if (flags & 256) {
    valuePtr->shareCount = valuePtr->shareCount - 1;
    if (valuePtr->shareCount == 0) {
      destroyed = 1;
      Tcl_DeleteHashEntry(hPtr);
    } else {
      bail = 1;
    }
  }
  if (valuePtr->flags & 8) {
    bail = 1;
  }
  Ns_CsLeave(& servPtr->share.cs);
  if (bail) {
    goto done;
  }
  Ns_CsEnter(& valuePtr->lock);
  if (flags & 2048) {
    if (valuePtr->flags & 2) {
      ShareUnsetVar___0(interp, name, valuePtr);
      hPtr = Tcl_FirstHashEntry(& valuePtr->array, & search);
      while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
        if (valuePtr->array.keyType == 1) {
          tmp___1 = hPtr->key.oneWordValue;
        } else {
          if (valuePtr->array.keyType == -1) {
            tmp___1 = hPtr->key.oneWordValue;
          } else {
            tmp___1 = hPtr->key.string;
          }
        }
        name2 = tmp___1;
        objPtr = (Tcl_Obj *)hPtr->clientData;
        tmp___2 = Tcl_DuplicateObj(objPtr);
        Tcl_SetVar2Ex(interp, name, name2, tmp___2, 0);
        hPtr = Tcl_NextHashEntry(& search);
      }
    }
  }
  if (flags & 32) {
    objPtr = Tcl_GetVar2Ex(interp, name, name2, 0);
    string = Tcl_GetStringFromObj(objPtr, & length);
    newObjPtr = Tcl_NewStringObj(string, length);
    newObjPtr->refCount = newObjPtr->refCount + 1;
    if ((unsigned int )name2 != (unsigned int )((void *)0)) {
      if (valuePtr->flags == 0) {
        Tcl_InitHashTable(& valuePtr->array, 0);
        valuePtr->flags = 2;
      }
      hPtr = ((*(valuePtr->array.createProc)))(& valuePtr->array, name2, & new);
      oldObjPtr = (Tcl_Obj *)hPtr->clientData;
      hPtr->clientData = (void *)((char *)newObjPtr);
    } else {
      oldObjPtr = valuePtr->objPtr;
      valuePtr->objPtr = newObjPtr;
    }
    if ((unsigned int )oldObjPtr != (unsigned int )((void *)0)) {
      oldObjPtr->refCount = oldObjPtr->refCount - 1;
      if (oldObjPtr->refCount <= 0) {
        TclFreeObj(oldObjPtr);
      }
    }
  }
  if (flags & 16) {
    objPtr = (Tcl_Obj *)((void *)0);
    if ((unsigned int )name2 != (unsigned int )((void *)0)) {
      hPtr = ((*(valuePtr->array.findProc)))(& valuePtr->array, name2);
      if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
        objPtr = (Tcl_Obj *)hPtr->clientData;
      }
    } else {
      if ((unsigned int )valuePtr->objPtr != (unsigned int )((void *)0)) {
        objPtr = valuePtr->objPtr;
      }
    }
    if ((unsigned int )objPtr != (unsigned int )((void *)0)) {
      newObjPtr = Tcl_DuplicateObj(objPtr);
      Tcl_SetVar2Ex(interp, name, name2, newObjPtr, 0);
    }
  }
  if (flags & 64) {
    if ((unsigned int )name2 != (unsigned int )((void *)0)) {
      hPtr = ((*(valuePtr->array.findProc)))(& valuePtr->array, name2);
      if ((unsigned int )hPtr != (unsigned int )((void *)0)) {
        objPtr = (Tcl_Obj *)hPtr->clientData;
        objPtr->refCount = objPtr->refCount - 1;
        if (objPtr->refCount <= 0) {
          TclFreeObj(objPtr);
        }
        Tcl_DeleteHashEntry(hPtr);
      }
    } else {
      if (valuePtr->flags & 2) {
        hPtr = Tcl_FirstHashEntry(& valuePtr->array, & search);
        while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
          nextPtr = Tcl_NextHashEntry(& search);
          objPtr = (Tcl_Obj *)hPtr->clientData;
          objPtr->refCount = objPtr->refCount - 1;
          if (objPtr->refCount <= 0) {
            TclFreeObj(objPtr);
          }
          Tcl_DeleteHashEntry(hPtr);
          hPtr = nextPtr;
        }
        Tcl_DeleteHashTable(& valuePtr->array);
        valuePtr->flags = valuePtr->flags & -3;
      } else {
        if ((unsigned int )valuePtr->objPtr != (unsigned int )((void *)0)) {
          (valuePtr->objPtr)->refCount = (valuePtr->objPtr)->refCount - 1;
          if ((valuePtr->objPtr)->refCount <= 0) {
            TclFreeObj(valuePtr->objPtr);
          }
          valuePtr->objPtr = (Tcl_Obj *)((void *)0);
          valuePtr->flags = valuePtr->flags & -2;
        }
      }
    }
    if (! destroyed) {
      tmp___3 = Tcl_TraceVar2(interp, name, (char *)((void *)0), 2160, & ShareTraceProc___0,
                              (void *)0);
      if (tmp___3 != 0) {
        Ns_Fatal((char *)"Cannot set trace on share");
      }
    }
  }
  Ns_CsLeave(& valuePtr->lock);
  if (destroyed) {
    Ns_CsDestroy(& valuePtr->lock);
    Tcl_Free((char *)valuePtr);
  }
  done: 
  Tcl_DStringFree(& ds);
  return ((char *)((void *)0));
}
}
static char *GetGlobalizedName___0(Tcl_DString *dsPtr , char *varName ) 
{ int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  Tcl_DStringInit(dsPtr);
  if (0) {
    if (0) {
      __s1_len___0 = strlen("::");
      __s2_len___0 = strlen((char const   *)varName);
      if (! ((unsigned int )((void const   *)("::" + 1)) - (unsigned int )((void const   *)"::") ==
             1U)) {
        goto _L___2;
      } else {
        if (__s1_len___0 >= 4U) {
          _L___2: 
          if (! ((unsigned int )((void const   *)(varName + 1)) - (unsigned int )((void const   *)varName) ==
                 1U)) {
            tmp___18 = 1;
          } else {
            if (__s2_len___0 >= 4U) {
              tmp___18 = 1;
            } else {
              tmp___18 = 0;
            }
          }
        } else {
          tmp___18 = 0;
        }
      }
      if (tmp___18) {
        if (__s1_len___0 < __s2_len___0) {
          tmp___16 = __s1_len___0;
        } else {
          tmp___16 = __s2_len___0;
        }
        tmp___15 = memcmp((void const   *)"::", (void const   *)((char const   *)varName),
                          tmp___16 + 1U);
      } else {
        tmp___17 = strcmp("::", (char const   *)varName);
        tmp___15 = tmp___17;
      }
    } else {
      tmp___17 = strcmp("::", (char const   *)varName);
      tmp___15 = tmp___17;
    }
    tmp___10 = tmp___15;
  } else {
    tmp___10 = strncmp("::", (char const   *)varName, 2U);
  }
  if (tmp___10 != 0) {
    Tcl_DStringAppend(dsPtr, (char *)"::", 2);
  }
  Tcl_DStringAppend(dsPtr, varName, -1);
  return (dsPtr->string);
}
}
static int GetSet___0(Tcl_Interp *interp , char *flist , int write___0 , fd_set **setPtrPtr ,
                      fd_set *setPtr , int *maxPtr ) ;
static void AppendReadyFiles___0(Tcl_Interp *interp , fd_set *setPtr , int write___0 ,
                                 char *flist , Tcl_DString *dsPtr ) ;
static int EnterSock___0(Tcl_Interp *interp , int sock ) ;
static int EnterDup___0(Tcl_Interp *interp , int sock ) ;
static int EnterDupedSocks___0(Tcl_Interp *interp , int sock ) ;
static int SockSetBlockingObj___0(char *value , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) ;
static int SockListenCallback___0(int sock , void *arg , int why ) ;
static int GetObjCmd___0(Tcl_Interp *interp , int objc , Tcl_Obj **objv , int byaddr ) 
{ Tcl_DString ds ;
  char *opt ;
  char *addr ;
  int all ;
  int status ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  all = 0;
  if (byaddr) {
    if (objc < 2) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-all? address");
      return (1);
    } else {
      if (objc > 3) {
        Tcl_WrongNumArgs(interp, 1, objv, (char *)"?-all? address");
        return (1);
      }
    }
  } else {
    if (objc != 2) {
      Tcl_WrongNumArgs(interp, 1, objv, (char *)"address");
      return (1);
    }
  }
  opt = Tcl_GetString((*(objv + 1)));
  if (objc >= 3) {
    if ((int )(*opt) == (int )(*"-all")) {
      if (0) {
        __s1_len = strlen((char const   *)opt);
        __s2_len = strlen("-all");
        if (! ((unsigned int )((void const   *)(opt + 1)) - (unsigned int )((void const   *)opt) ==
               1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("-all" + 1)) - (unsigned int )((void const   *)"-all") ==
                   1U)) {
              tmp___6 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___6 = 1;
              } else {
                tmp___6 = 0;
              }
            }
          } else {
            tmp___6 = 0;
          }
        }
        if (tmp___6) {
          if (__s1_len < __s2_len) {
            tmp___4 = __s1_len;
          } else {
            tmp___4 = __s2_len;
          }
          tmp___3 = memcmp((void const   *)((char const   *)opt), (void const   *)"-all",
                           tmp___4 + 1U);
        } else {
          tmp___5 = strcmp((char const   *)opt, "-all");
          tmp___3 = tmp___5;
        }
      } else {
        tmp___5 = strcmp((char const   *)opt, "-all");
        tmp___3 = tmp___5;
      }
      if (tmp___3 == 0) {
        all = 1;
        addr = Tcl_GetString((*(objv + 2)));
      } else {
        addr = opt;
      }
    } else {
      addr = opt;
    }
  } else {
    addr = opt;
  }
  Tcl_DStringInit(& ds);
  if (byaddr) {
    if (all) {
      status = Ns_GetAllAddrByHost(& ds, addr);
    } else {
      status = Ns_GetAddrByHost(& ds, addr);
    }
  } else {
    status = Ns_GetHostByAddr(& ds, addr);
  }
  if (status == 1) {
    Tcl_SetResult(interp, ds.string, (Tcl_FreeProc *)1);
  }
  Tcl_DStringFree(& ds);
  if (status != 1) {
    Tcl_AppendResult(interp, "could not lookup ", addr, (void *)0);
    return (1);
  }
  return (0);
}
}
static int SockSetBlockingObj___0(char *value , Tcl_Interp *interp , int objc , Tcl_Obj **objv ) 
{ Tcl_Channel chan ;
  char *tmp ;
  int tmp___0 ;

  {
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"sockId");
    return (1);
  }
  tmp = Tcl_GetString((*(objv + 1)));
  chan = Tcl_GetChannel(interp, tmp, (int *)((void *)0));
  if ((unsigned int )chan == (unsigned int )((void *)0)) {
    return (1);
  }
  tmp___0 = Tcl_SetChannelOption(interp, chan, (char *)"-blocking", value);
  return (tmp___0);
}
}
static void AppendReadyFiles___0(Tcl_Interp *interp , fd_set *setPtr , int write___0 ,
                                 char *flist , Tcl_DString *dsPtr ) 
{ int fargc ;
  char **fargv ;
  int sock ;
  Tcl_DString ds ;
  register char __result ;
  int tmp ;

  {
  Tcl_DStringInit(& ds);
  if ((unsigned int )dsPtr == (unsigned int )((void *)0)) {
    dsPtr = & ds;
  }
  Tcl_SplitList(interp, flist, & fargc, & fargv);
  while (1) {
    tmp = fargc;
    fargc --;
    if (! tmp) {
      break;
    }
    Ns_TclGetOpenFd(interp, (*(fargv + fargc)), write___0, & sock);
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )sock %
                                                                        (8U * sizeof(__fd_mask ))),
                         "m" (setPtr->fds_bits[(unsigned int )sock / (8U * sizeof(__fd_mask ))]): "cc");
    if (__result) {
      Tcl_DStringAppendElement(dsPtr, (*(fargv + fargc)));
    }
  }
  Tcl_AppendElement(interp, dsPtr->string);
  Tcl_Free((char *)fargv);
  Tcl_DStringFree(& ds);
  return;
}
}
static int GetSet___0(Tcl_Interp *interp , char *flist , int write___0 , fd_set **setPtrPtr ,
                      fd_set *setPtr , int *maxPtr ) 
{ int sock ;
  int fargc ;
  char **fargv ;
  int status ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = Tcl_SplitList(interp, flist, & fargc, & fargv);
  if (tmp != 0) {
    return (1);
  }
  if (fargc == 0) {
    Tcl_Free((char *)fargv);
    (*setPtrPtr) = (fd_set *)((void *)0);
    return (0);
  } else {
    (*setPtrPtr) = setPtr;
  }
  while (1) {
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) /
                                                                                    sizeof(__fd_mask )),
                         "1" (& setPtr->fds_bits[0]): "memory");
    break;
  }
  status = 0;
  while (1) {
    tmp___1 = fargc;
    fargc --;
    if (! tmp___1) {
      break;
    }
    tmp___0 = Ns_TclGetOpenFd(interp, (*(fargv + fargc)), write___0, & sock);
    if (tmp___0 != 0) {
      status = 1;
      break;
    }
    if (sock > (*maxPtr)) {
      (*maxPtr) = sock;
    }
    __asm__  volatile   ("btsl %1,%0": "=m" (setPtr->fds_bits[(unsigned int )sock /
                                                              (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )sock %
                                                                                                (8U *
                                                                                                 sizeof(__fd_mask ))): "cc",
                         "memory");
  }
  Tcl_Free((char *)fargv);
  return (status);
}
}
static int EnterSock___0(Tcl_Interp *interp , int sock ) 
{ Tcl_Channel chan ;
  char *tmp ;

  {
  chan = Tcl_MakeTcpClientChannel((void *)sock);
  if ((unsigned int )chan == (unsigned int )((void *)0)) {
    Tcl_AppendResult(interp, "could not open socket", (void *)0);
    close(sock);
    return (1);
  }
  Tcl_SetChannelOption(interp, chan, (char *)"-translation", (char *)"binary");
  Tcl_RegisterChannel(interp, chan);
  tmp = Tcl_GetChannelName(chan);
  Tcl_AppendElement(interp, tmp);
  return (0);
}
}
static int EnterDup___0(Tcl_Interp *interp , int sock ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  sock = dup(sock);
  if (sock == -1) {
    tmp = __errno_location();
    tmp___0 = strerror((*tmp));
    Tcl_AppendResult(interp, "could not dup socket: ", tmp___0, (void *)0);
    return (1);
  }
  tmp___1 = EnterSock___0(interp, sock);
  return (tmp___1);
}
}
static int EnterDupedSocks___0(Tcl_Interp *interp , int sock ) 
{ int tmp ;
  int tmp___0 ;

  {
  tmp = EnterSock___0(interp, sock);
  if (tmp != 0) {
    return (1);
  } else {
    tmp___0 = EnterDup___0(interp, sock);
    if (tmp___0 != 0) {
      return (1);
    }
  }
  return (0);
}
}
static int SockListenCallback___0(int sock , void *arg , int why ) 
{ ListenCallback___0 *lcbPtr ;
  Tcl_Interp *interp ;
  Tcl_DString script ;
  Tcl_Obj *listPtr ;
  Tcl_Obj **objv ;
  int result ;
  int objc ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  lcbPtr = (ListenCallback___0 *)arg;
  interp = Ns_TclAllocateInterp(lcbPtr->server);
  result = EnterDupedSocks___0(interp, sock);
  if (result == 0) {
    listPtr = Tcl_GetObjResult(interp);
    tmp___1 = Tcl_ListObjGetElements(interp, listPtr, & objc, & objv);
    if (tmp___1 == 0) {
      if (objc == 2) {
        Tcl_DStringInit(& script);
        Tcl_DStringAppend(& script, lcbPtr->script, -1);
        tmp = Tcl_GetString((*(objv + 0)));
        Tcl_DStringAppendElement(& script, tmp);
        tmp___0 = Tcl_GetString((*(objv + 1)));
        Tcl_DStringAppendElement(& script, tmp___0);
        result = Tcl_EvalEx(interp, script.string, script.length, 0);
        Tcl_DStringFree(& script);
      }
    }
  }
  if (result != 0) {
    Ns_TclLogError(interp);
  }
  Ns_TclDeAllocateInterp(interp);
  return (1);
}
}
static int GetAddr___2(Tcl_Interp *interp , int type , char *id , void **addrPtr ) ;
static void SetAddr___0(Tcl_Interp *interp , int type , void *addr ) ;
static int GetArgs___0(Tcl_Interp *interp , int objc , Tcl_Obj **objv , char **opts___33 ,
                       int type , int create , int *optPtr , void **addrPtr ) ;
static void CreateTclThread___0(NsInterp *itPtr , char *script , int detached , Ns_Thread *thrPtr ) ;
static int SetAddrFromAny___0(Tcl_Interp *interp , Tcl_Obj *objPtr ) ;
static void UpdateStringOfAddr___0(Tcl_Obj *objPtr ) ;
static void SetAddrInternalRep___0(Tcl_Obj *objPtr , int type , void *addr ) ;
static int GetAddrFromObj___0(Tcl_Interp *interp , Tcl_Obj *objPtr , int type , void **addrPtr ) ;
static struct Tcl_ObjType addrType___0  =    {(char *)"ns:addr", (Tcl_FreeInternalRepProc *)((void *)0), (Tcl_DupInternalRepProc *)((void *)0),
    & UpdateStringOfAddr___0, & SetAddrFromAny___0};
static char *opts___26[5]  = {      (char *)"create",      (char *)"destroy",      (char *)"lock",      (char *)"unlock", 
        (char *)((void *)0)};
static char *opts___27[5]  = {      (char *)"create",      (char *)"destroy",      (char *)"enter",      (char *)"leave", 
        (char *)((void *)0)};
static char *opts___28[5]  = {      (char *)"create",      (char *)"destroy",      (char *)"release",      (char *)"wait", 
        (char *)((void *)0)};
static char *opts___29[9]  = 
  {      (char *)"abswait",      (char *)"broadcast",      (char *)"create",      (char *)"destroy", 
        (char *)"set",      (char *)"signal",      (char *)"timedwait",      (char *)"wait", 
        (char *)((void *)0)};
static char *opts___30[8]  = 
  {      (char *)"create",      (char *)"destroy",      (char *)"readlock",      (char *)"readunlock", 
        (char *)"writelock",      (char *)"writeunlock",      (char *)"unlock",      (char *)((void *)0)};
static void SetAddr___0(Tcl_Interp *interp , int type , void *addr ) 
{ char buf[40] ;

  {
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%cid%p", type,
          addr);
  Tcl_SetResult(interp, buf, (Tcl_FreeProc *)1);
  return;
}
}
static int GetAddr___2(Tcl_Interp *interp , int type , char *id , void **addrPtr ) 
{ void *addr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  tmp = id;
  id ++;
  if ((int )(*tmp) != type) {
    Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
    return (1);
  } else {
    tmp___0 = id;
    id ++;
    if ((int )(*tmp___0) != 105) {
      Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
      return (1);
    } else {
      tmp___1 = id;
      id ++;
      if ((int )(*tmp___1) != 100) {
        Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
        return (1);
      } else {
        tmp___2 = sscanf((char const   * __restrict  )id, (char const   * __restrict  )"%p",
                         & addr);
        if (tmp___2 != 1) {
          Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
          return (1);
        } else {
          if ((unsigned int )addr == (unsigned int )((void *)0)) {
            Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
            return (1);
          }
        }
      }
    }
  }
  (*addrPtr) = addr;
  return (0);
}
}
static void CreateTclThread___0(NsInterp *itPtr , char *script , int detached , Ns_Thread *thrPtr ) 
{ ThreadArg *argPtr ;
  size_t tmp ;

  {
  tmp = strlen((char const   *)script);
  argPtr = (ThreadArg *)ns_malloc(sizeof(ThreadArg ) + tmp);
  argPtr->detached = detached;
  strcpy((char * __restrict  )(argPtr->script), (char const   * __restrict  )script);
  if ((unsigned int )itPtr != (unsigned int )((void *)0)) {
    if ((unsigned int )itPtr->servPtr != (unsigned int )((void *)0)) {
      argPtr->server = (itPtr->servPtr)->server;
    } else {
      argPtr->server = (char *)((void *)0);
    }
  } else {
    argPtr->server = (char *)((void *)0);
  }
  Ns_ThreadCreate(& NsTclThread, (void *)argPtr, 0L, thrPtr);
  return;
}
}
static int GetArgs___0(Tcl_Interp *interp , int objc , Tcl_Obj **objv , char **opts___33 ,
                       int type , int create , int *optPtr , void **addrPtr ) 
{ Tcl_Obj *objPtr ;
  int opt ;
  void *addr ;
  int tmp ;
  int tmp___0 ;

  {
  if (objc < 2) {
    Tcl_WrongNumArgs(interp, 1, objv, (char *)"option ?arg ...?");
    return (0);
  }
  tmp = Tcl_GetIndexFromObj(interp, (*(objv + 1)), opts___33, (char *)"option", 0,
                            & opt);
  if (tmp != 0) {
    return (0);
  }
  if (opt == create) {
    addr = ns_malloc(sizeof(void *));
    objPtr = Tcl_GetObjResult(interp);
    SetAddrInternalRep___0(objPtr, type, addr);
  } else {
    if (objc < 3) {
      Tcl_WrongNumArgs(interp, 2, objv, (char *)"object");
      return (0);
    }
    tmp___0 = GetAddrFromObj___0(interp, (*(objv + 2)), type, & addr);
    if (tmp___0 != 0) {
      return (0);
    }
  }
  (*addrPtr) = addr;
  (*optPtr) = opt;
  return (1);
}
}
static int GetAddrFromObj___0(Tcl_Interp *interp , Tcl_Obj *objPtr , int type , void **addrPtr ) 
{ int tmp ;
  char *tmp___0 ;

  {
  tmp = Tcl_ConvertToType(interp, objPtr, & addrType___0);
  if (tmp != 0) {
    return (1);
  }
  if ((int )objPtr->internalRep.twoPtrValue.ptr1 != type) {
    tmp___0 = Tcl_GetString(objPtr);
    Tcl_AppendResult(interp, "incorrect type: ", tmp___0, (void *)0);
    return (1);
  }
  (*addrPtr) = objPtr->internalRep.twoPtrValue.ptr2;
  return (0);
}
}
static void UpdateStringOfAddr___0(Tcl_Obj *objPtr ) 
{ int type ;
  void *addr ;
  char buf[40] ;
  size_t len ;

  {
  type = (int )objPtr->internalRep.twoPtrValue.ptr1;
  addr = objPtr->internalRep.twoPtrValue.ptr2;
  len = (size_t )sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%cid%p",
                         type, addr);
  objPtr->bytes = Tcl_Alloc(len + 1U);
  strcpy((char * __restrict  )objPtr->bytes, (char const   * __restrict  )(buf));
  objPtr->length = (int )len;
  return;
}
}
static int SetAddrFromAny___0(Tcl_Interp *interp , Tcl_Obj *objPtr ) 
{ void *addr ;
  int type ;
  register char *id ;
  register char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  id = Tcl_GetString(objPtr);
  p = id;
  tmp = p;
  p ++;
  type = (int )(*tmp);
  if (type == 0) {
    Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
    return (1);
  } else {
    tmp___0 = p;
    p ++;
    if ((int )(*tmp___0) != 105) {
      Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
      return (1);
    } else {
      tmp___1 = p;
      p ++;
      if ((int )(*tmp___1) != 100) {
        Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
        return (1);
      } else {
        tmp___2 = sscanf((char const   * __restrict  )p, (char const   * __restrict  )"%p",
                         & addr);
        if (tmp___2 != 1) {
          Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
          return (1);
        } else {
          if ((unsigned int )addr == (unsigned int )((void *)0)) {
            Tcl_AppendResult(interp, "invalid thread object id \"", id, "\"", (void *)0);
            return (1);
          }
        }
      }
    }
  }
  SetAddrInternalRep___0(objPtr, type, addr);
  return (0);
}
}
static void SetAddrInternalRep___0(Tcl_Obj *objPtr , int type , void *addr ) 
{ Tcl_ObjType *typePtr ;

  {
  typePtr = objPtr->typePtr;
  if ((unsigned int )typePtr != (unsigned int )((void *)0)) {
    if ((unsigned int )typePtr->freeIntRepProc != (unsigned int )((void *)0)) {
      ((*(typePtr->freeIntRepProc)))(objPtr);
    }
  }
  objPtr->typePtr = & addrType___0;
  objPtr->internalRep.twoPtrValue.ptr1 = (void *)type;
  objPtr->internalRep.twoPtrValue.ptr2 = addr;
  Tcl_InvalidateStringRep(objPtr);
  return;
}
}
static void SetVar___0(Array *arrayPtr , Tcl_Obj *key___1 , Tcl_Obj *value ) ;
static void UpdateVar___0(Tcl_HashEntry *hPtr , Tcl_Obj *obj ) ;
static void FlushArray___0(Array *arrayPtr ) ;
static Array *LockArray___0(void *arg , Tcl_Interp *interp , Tcl_Obj *arrayObj , int create ) ;
static char *opts___31[7]  = {      (char *)"set",      (char *)"reset",      (char *)"get",      (char *)"names", 
        (char *)"size",      (char *)"exists",      (char *)((void *)0)};
static Array *LockArray___0(void *arg , Tcl_Interp *interp , Tcl_Obj *arrayObj , int create ) 
{ NsInterp *itPtr ;
  Bucket *bucketPtr ;
  Tcl_HashEntry *hPtr ;
  Array *arrayPtr ;
  char *array ;
  register char *p ;
  register unsigned int result ;
  register int i ;
  int new ;

  {
  itPtr = (NsInterp *)arg;
  array = Tcl_GetString(arrayObj);
  p = array;
  result = 0U;
  while (1) {
    i = (int )(*p);
    p ++;
    if (i == 0) {
      break;
    }
    result += (result << 3) + (unsigned int )i;
  }
  i = (int )(result % (unsigned int )(itPtr->servPtr)->nsv.nbuckets);
  bucketPtr = (itPtr->servPtr)->nsv.buckets + i;
  Ns_MutexLock(& bucketPtr->lock);
  if (create) {
    hPtr = ((*(bucketPtr->arrays.createProc)))(& bucketPtr->arrays, array, & new);
    if (! new) {
      arrayPtr = (Array *)hPtr->clientData;
    } else {
      arrayPtr = (Array *)ns_malloc(sizeof(Array ));
      arrayPtr->bucketPtr = bucketPtr;
      arrayPtr->entryPtr = hPtr;
      Tcl_InitHashTable(& arrayPtr->vars, 0);
      hPtr->clientData = (void *)arrayPtr;
    }
  } else {
    hPtr = ((*(bucketPtr->arrays.findProc)))(& bucketPtr->arrays, array);
    if ((unsigned int )hPtr == (unsigned int )((void *)0)) {
      Ns_MutexUnlock(& bucketPtr->lock);
      if ((unsigned int )interp != (unsigned int )((void *)0)) {
        Tcl_AppendResult(interp, "no such array: ", array, (void *)0);
      }
      return ((Array *)((void *)0));
    }
    arrayPtr = (Array *)hPtr->clientData;
  }
  return (arrayPtr);
}
}
static void UpdateVar___0(Tcl_HashEntry *hPtr , Tcl_Obj *obj ) 
{ char *str ;
  char *old ;
  char *new ;
  int len ;

  {
  str = Tcl_GetStringFromObj(obj, & len);
  old = (char *)hPtr->clientData;
  new = (char *)ns_realloc((void *)old, (unsigned int )(len + 1));
  memcpy((void * __restrict  )new, (void const   * __restrict  )str, (unsigned int )(len +
                                                                                     1));
  hPtr->clientData = (void *)new;
  return;
}
}
static void SetVar___0(Array *arrayPtr , Tcl_Obj *key___1 , Tcl_Obj *value ) 
{ Tcl_HashEntry *hPtr ;
  int new ;
  char *tmp ;

  {
  tmp = Tcl_GetString(key___1);
  hPtr = ((*(arrayPtr->vars.createProc)))(& arrayPtr->vars, tmp, & new);
  UpdateVar___0(hPtr, value);
  return;
}
}
static void FlushArray___0(Array *arrayPtr ) 
{ Tcl_HashEntry *hPtr ;
  Tcl_HashSearch search ;

  {
  hPtr = Tcl_FirstHashEntry(& arrayPtr->vars, & search);
  while ((unsigned int )hPtr != (unsigned int )((void *)0)) {
    ns_free(hPtr->clientData);
    Tcl_DeleteHashEntry(hPtr);
    hPtr = Tcl_NextHashEntry(& search);
  }
  return;
}
}
static char *opts___32[6]  = {      (char *)"exists",      (char *)"get",      (char *)"list",      (char *)"set", 
        (char *)"unset",      (char *)((void *)0)};
static char *tclXWrongArgs___0  =    (char *)"wrong # args: ";
static int FindElement___0(Tcl_Interp *interp , char *list , char **elementPtr , char **nextPtr ,
                           int *sizePtr , int *bracePtr ) ;
static void CopyAndCollapse___0(int count , char *src , char *dst ) ;
static int CompareKeyListField___0(Tcl_Interp *interp , char *fieldName , char *field ,
                                   char **valuePtr , int *valueSizePtr , int *bracedPtr ) ;
static int SplitAndFindField___0(Tcl_Interp *interp , char *fieldName , char *keyedList ,
                                 fieldInfo_t *fieldInfoPtr ) ;
static int CompareKeyListField___0(Tcl_Interp *interp , char *fieldName , char *field ,
                                   char **valuePtr , int *valueSizePtr , int *bracedPtr ) 
{ char *elementPtr ;
  char *nextPtr ;
  int fieldNameSize ;
  int elementSize ;
  int tmp ;
  int tmp___11 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___22 ;

  {
  if ((int )(*(field + 0)) == 0) {
    interp->result = (char *)"invalid keyed list format: list contains an empty field entry";
    return (1);
  }
  tmp = FindElement___0(interp, field, & elementPtr, & nextPtr, & elementSize, (int *)((void *)0));
  if (tmp != 0) {
    return (1);
  }
  if (elementSize == 0) {
    interp->result = (char *)"invalid keyed list format: list contains an empty field name";
    return (1);
  }
  if ((int )(*(nextPtr + 0)) == 0) {
    Tcl_AppendResult(interp, "invalid keyed list format or inconsistent ", "field name scoping: no value associated with ",
                     "field \"", elementPtr, "\"", (char *)((void *)0));
    return (1);
  }
  fieldNameSize = (int )strlen((char const   *)fieldName);
  if (elementSize == fieldNameSize) {
    if ((int )(*(elementPtr + 0)) == (int )(*(fieldName + 0))) {
      if (0) {
        if (0) {
          __s1_len___0 = strlen((char const   *)elementPtr);
          __s2_len___0 = strlen((char const   *)fieldName);
          if (! ((unsigned int )((void const   *)(elementPtr + 1)) - (unsigned int )((void const   *)elementPtr) ==
                 1U)) {
            goto _L___2;
          } else {
            if (__s1_len___0 >= 4U) {
              _L___2: 
              if (! ((unsigned int )((void const   *)(fieldName + 1)) - (unsigned int )((void const   *)fieldName) ==
                     1U)) {
                tmp___19 = 1;
              } else {
                if (__s2_len___0 >= 4U) {
                  tmp___19 = 1;
                } else {
                  tmp___19 = 0;
                }
              }
            } else {
              tmp___19 = 0;
            }
          }
          if (tmp___19) {
            if (__s1_len___0 < __s2_len___0) {
              tmp___17 = __s1_len___0;
            } else {
              tmp___17 = __s2_len___0;
            }
            tmp___16 = memcmp((void const   *)((char const   *)elementPtr), (void const   *)((char const   *)fieldName),
                              tmp___17 + 1U);
          } else {
            tmp___18 = strcmp((char const   *)elementPtr, (char const   *)fieldName);
            tmp___16 = tmp___18;
          }
        } else {
          tmp___18 = strcmp((char const   *)elementPtr, (char const   *)fieldName);
          tmp___16 = tmp___18;
        }
        tmp___11 = tmp___16;
      } else {
        tmp___11 = strncmp((char const   *)elementPtr, (char const   *)fieldName,
                           (unsigned int )fieldNameSize);
      }
      if (! (tmp___11 == 0)) {
        return (3);
      }
    } else {
      return (3);
    }
  } else {
    return (3);
  }
  tmp___22 = FindElement___0(interp, nextPtr, & elementPtr, & nextPtr, & elementSize,
                             bracedPtr);
  if (tmp___22 != 0) {
    return (1);
  }
  if ((int )(*(nextPtr + 0)) != 0) {
    Tcl_AppendResult(interp, "invalid keyed list format: ", "trailing data following value in field: \"",
                     elementPtr, "\"", (char *)((void *)0));
    return (1);
  }
  (*valuePtr) = elementPtr;
  (*valueSizePtr) = elementSize;
  return (0);
}
}
static int SplitAndFindField___0(Tcl_Interp *interp , char *fieldName , char *keyedList ,
                                 fieldInfo_t *fieldInfoPtr ) 
{ int idx ;
  int result ;
  int braced ;
  int tmp ;

  {
  if ((unsigned int )fieldName == (unsigned int )((char *)0)) {
    interp->result = (char *)"null key not allowed";
    return (1);
  }
  fieldInfoPtr->argv = (char **)((void *)0);
  tmp = Tcl_SplitList(interp, keyedList, & fieldInfoPtr->argc, & fieldInfoPtr->argv);
  if (tmp != 0) {
    goto errorExit;
  }
  result = 3;
  idx = 0;
  while (idx < fieldInfoPtr->argc) {
    result = CompareKeyListField___0(interp, fieldName, (*(fieldInfoPtr->argv + idx)),
                                     & fieldInfoPtr->valuePtr, & fieldInfoPtr->valueSize,
                                     & braced);
    if (result != 3) {
      break;
    }
    idx ++;
  }
  if (result == 1) {
    goto errorExit;
  }
  if (result == 3) {
    fieldInfoPtr->foundIdx = -1;
    fieldInfoPtr->valuePtr = (char *)((void *)0);
  } else {
    fieldInfoPtr->foundIdx = idx;
  }
  return (0);
  errorExit: 
  if ((unsigned int )fieldInfoPtr->argv != (unsigned int )((void *)0)) {
    Tcl_Free((char *)fieldInfoPtr->argv);
  }
  fieldInfoPtr->argv = (char **)((void *)0);
  return (1);
}
}
static int FindElement___0(Tcl_Interp *interp , char *list , char **elementPtr , char **nextPtr ,
                           int *sizePtr , int *bracePtr ) 
{ register char *p ;
  int openBraces ;
  int inQuotes ;
  int size ;
  unsigned short const   **tmp ;
  char *p2 ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int size___0 ;
  char *p2___0 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  openBraces = 0;
  inQuotes = 0;
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*list)))) & 8192)) {
      break;
    }
    list ++;
  }
  if ((int )(*list) == 123) {
    openBraces = 1;
    list ++;
  } else {
    if ((int )(*list) == 34) {
      inQuotes = 1;
      list ++;
    }
  }
  if ((unsigned int )bracePtr != (unsigned int )((int *)0)) {
    (*bracePtr) = openBraces;
  }
  p = list;
  while (1) {
    switch ((int )(*p)) {
    case 123: ;
    if (openBraces != 0) {
      openBraces ++;
    }
    break;
    case 125: ;
    if (openBraces == 1) {
      size = p - list;
      p ++;
      tmp___0 = __ctype_b_loc();
      if ((int const   )(*((*tmp___0) + (int )((unsigned char )(*p)))) & 8192) {
        goto done;
      } else {
        if ((int )(*p) == 0) {
          goto done;
        }
      }
      p2 = p;
      while (1) {
        if ((int )(*p2) != 0) {
          tmp___1 = __ctype_b_loc();
          if ((int const   )(*((*tmp___1) + (int )((unsigned char )(*p2)))) & 8192) {
            break;
          } else {
            if (! ((unsigned int )p2 < (unsigned int )(p + 20))) {
              break;
            }
          }
        } else {
          break;
        }
        p2 ++;
      }
      if ((unsigned int )interp != (unsigned int )((void *)0)) {
        Tcl_ResetResult(interp);
        sprintf((char * __restrict  )interp->result, (char const   * __restrict  )"list element in braces followed by \"%.*s\" instead of space",
                p2 - p, p);
      }
      return (1);
    } else {
      if (openBraces != 0) {
        openBraces --;
      }
    }
    break;
    case 92: 
    Tcl_Backslash(p, & size___0);
    p += size___0 - 1;
    break;
    case 32: ;
    case 12: ;
    case 10: ;
    case 13: ;
    case 9: ;
    case 11: ;
    if (openBraces == 0) {
      if (! inQuotes) {
        size = p - list;
        goto done;
      }
    }
    break;
    case 34: ;
    if (inQuotes) {
      size = p - list;
      p ++;
      tmp___2 = __ctype_b_loc();
      if ((int const   )(*((*tmp___2) + (int )((unsigned char )(*p)))) & 8192) {
        goto done;
      } else {
        if ((int )(*p) == 0) {
          goto done;
        }
      }
      p2___0 = p;
      while (1) {
        if ((int )(*p2___0) != 0) {
          tmp___3 = __ctype_b_loc();
          if ((int const   )(*((*tmp___3) + (int )((unsigned char )(*p2___0)))) &
              8192) {
            break;
          } else {
            if (! ((unsigned int )p2___0 < (unsigned int )(p + 20))) {
              break;
            }
          }
        } else {
          break;
        }
        p2___0 ++;
      }
      if ((unsigned int )interp != (unsigned int )((void *)0)) {
        Tcl_ResetResult(interp);
        sprintf((char * __restrict  )interp->result, (char const   * __restrict  )"list element in quotes followed by \"%.*s\" %s",
                p2___0 - p, p, "instead of space");
      }
      return (1);
    }
    break;
    case 0: ;
    if (openBraces != 0) {
      if ((unsigned int )interp != (unsigned int )((void *)0)) {
        Tcl_SetResult(interp, (char *)"unmatched open brace in list", (Tcl_FreeProc *)0);
      }
      return (1);
    } else {
      if (inQuotes) {
        if ((unsigned int )interp != (unsigned int )((void *)0)) {
          Tcl_SetResult(interp, (char *)"unmatched open quote in list", (Tcl_FreeProc *)0);
        }
        return (1);
      }
    }
    size = p - list;
    goto done;
    }
    p ++;
  }
  done: 
  while (1) {
    tmp___4 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___4) + (int )((unsigned char )(*p)))) & 8192)) {
      break;
    }
    p ++;
  }
  (*elementPtr) = list;
  (*nextPtr) = p;
  if ((unsigned int )sizePtr != (unsigned int )((int *)0)) {
    (*sizePtr) = size;
  }
  return (0);
}
}
static void CopyAndCollapse___0(int count , char *src , char *dst ) 
{ register char c ;
  int numRead ;

  {
  c = (*src);
  while (count > 0) {
    if ((int )c == 92) {
      (*dst) = Tcl_Backslash(src, & numRead);
      dst ++;
      src += numRead - 1;
      count -= numRead - 1;
    } else {
      (*dst) = c;
      dst ++;
    }
    src ++;
    c = (*src);
    count --;
  }
  (*dst) = (char)0;
  return;
}
}
static Ns_Mutex lock___29  ;
static int debugMode___0  ;
static int Pipe___0(int *fds , int sockpair ) 
{ int err ;

  {
  if (sockpair) {
    err = socketpair(1, 1, 0, fds);
  } else {
    err = pipe(fds);
  }
  if (! err) {
    fcntl((*(fds + 0)), 2, 1);
    fcntl((*(fds + 1)), 2, 1);
  }
  return (err);
}
}
static Tcl_Encoding GetUrlEncoding___0(char *charset ) ;
static int EncodeObjCmd___0(Tcl_Interp *interp , int objc , Tcl_Obj **objv , int encode ) 
{ Tcl_DString ds ;
  char *charset ;
  char *data ;
  char *tmp ;
  char *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___31 ;
  size_t tmp___32 ;
  char *tmp___33 ;
  char *tmp___54 ;
  int tmp___55 ;
  char *tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;
  int tmp___60 ;

  {
  if (objc == 2) {
    charset = (char *)((void *)0);
    data = Tcl_GetString((*(objv + 1)));
  } else {
    if (objc == 4) {
      tmp___0 = Tcl_GetString((*(objv + 1)));
      if ((int )(*tmp___0) == (int )(*"-charset")) {
        if (0) {
          tmp___57 = Tcl_GetString((*(objv + 1)));
          __s1_len = strlen((char const   *)tmp___57);
          __s2_len = strlen("-charset");
          tmp___58 = Tcl_GetString((*(objv + 1)));
          tmp___59 = Tcl_GetString((*(objv + 1)));
          if ((unsigned int )((void const   *)(tmp___58 + 1)) - (unsigned int )((void const   *)tmp___59) ==
              1U) {
            if (__s1_len >= 4U) {
              _L___0: 
              if (! ((unsigned int )((void const   *)("-charset" + 1)) - (unsigned int )((void const   *)"-charset") ==
                     1U)) {
                tmp___60 = 1;
              } else {
                if (__s2_len >= 4U) {
                  tmp___60 = 1;
                } else {
                  tmp___60 = 0;
                }
              }
            } else {
              tmp___60 = 0;
            }
          } else {
            goto _L___0;
          }
          if (tmp___60) {
            if (__s1_len < __s2_len) {
              tmp___32 = __s1_len;
            } else {
              tmp___32 = __s2_len;
            }
            tmp___33 = Tcl_GetString((*(objv + 1)));
            tmp___31 = memcmp((void const   *)((char const   *)tmp___33), (void const   *)"-charset",
                              tmp___32 + 1U);
          } else {
            tmp___54 = Tcl_GetString((*(objv + 1)));
            tmp___55 = strcmp((char const   *)tmp___54, "-charset");
            tmp___31 = tmp___55;
          }
        } else {
          tmp___54 = Tcl_GetString((*(objv + 1)));
          tmp___55 = strcmp((char const   *)tmp___54, "-charset");
          tmp___31 = tmp___55;
        }
        if (tmp___31 == 0) {
          charset = Tcl_GetString((*(objv + 2)));
          data = Tcl_GetString((*(objv + 3)));
        } else {
          tmp = Tcl_GetString((*(objv + 0)));
          Tcl_AppendResult(interp, "bad usage: should be \"", tmp, " ?-charset charset? data\"",
                           (void *)0);
          return (1);
        }
      } else {
        tmp = Tcl_GetString((*(objv + 0)));
        Tcl_AppendResult(interp, "bad usage: should be \"", tmp, " ?-charset charset? data\"",
                         (void *)0);
        return (1);
      }
    } else {
      tmp = Tcl_GetString((*(objv + 0)));
      Tcl_AppendResult(interp, "bad usage: should be \"", tmp, " ?-charset charset? data\"",
                       (void *)0);
      return (1);
    }
  }
  Tcl_DStringInit(& ds);
  if (encode) {
    Ns_EncodeUrlCharset(& ds, data, charset);
  } else {
    Ns_DecodeUrlCharset(& ds, data, charset);
  }
  Tcl_DStringResult(interp, & ds);
  Tcl_DStringFree(& ds);
  return (0);
}
}
static Tcl_Encoding GetUrlEncoding___0(char *charset ) 
{ Tcl_Encoding encoding ;
  Conn *connPtr ;
  Conn *tmp ;

  {
  encoding = (struct Tcl_Encoding_ *)((void *)0);
  if ((unsigned int )charset != (unsigned int )((void *)0)) {
    encoding = Ns_GetCharsetEncoding(charset);
    if ((unsigned int )encoding == (unsigned int )((void *)0)) {
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )1, (char *)"no encoding found for charset \"%s\"",
             charset);
    }
  }
  if ((unsigned int )encoding == (unsigned int )((void *)0)) {
    tmp = (Conn *)Ns_GetConn();
    connPtr = tmp;
    if ((unsigned int )connPtr != (unsigned int )((void *)0)) {
      encoding = connPtr->urlEncoding;
    }
  }
  return (encoding);
}
}
static int GetLine___0(Stream *sPtr , Tcl_DString *dsPtr ) ;
static int FillBuf___0(Stream *sPtr ) ;
static int FillBuf___0(Stream *sPtr ) 
{ int n ;
  int *tmp ;
  char *tmp___0 ;

  {
  n = recv(sPtr->sock, (void *)(sPtr->buf), 2048U, 0);
  if (n <= 0) {
    if (n < 0) {
      tmp = __errno_location();
      tmp___0 = strerror((*tmp));
      Ns_Log((enum __anonenum_Ns_LogSeverity_67 )2, (char *)"urlopen: failed to fill socket stream buffer: \'%s\'",
             tmp___0);
      sPtr->error = 1;
    }
    return (0);
  }
  sPtr->buf[n] = (char )'\000';
  sPtr->ptr = sPtr->buf;
  sPtr->cnt = n;
  return (1);
}
}
static int GetLine___0(Stream *sPtr , Tcl_DString *dsPtr ) 
{ char *eol ;
  int n ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  Tcl_DStringSetLength(dsPtr, 0);
  while (1) {
    if (sPtr->cnt > 0) {
      tmp___0 = strchr((char const   *)sPtr->ptr, '\n');
      eol = tmp___0;
      if ((unsigned int )eol == (unsigned int )((void *)0)) {
        n = sPtr->cnt;
      } else {
        tmp___1 = eol;
        eol ++;
        (*tmp___1) = (char )'\000';
        n = eol - sPtr->ptr;
      }
      Tcl_DStringAppend(dsPtr, sPtr->ptr, n - 1);
      sPtr->ptr = sPtr->ptr + n;
      sPtr->cnt = sPtr->cnt - n;
      if ((unsigned int )eol != (unsigned int )((void *)0)) {
        n = dsPtr->length;
        if (n > 0) {
          if ((int )(*(dsPtr->string + (n - 1))) == 13) {
            Tcl_DStringSetLength(dsPtr, n - 1);
          }
        }
        return (1);
      }
    }
    tmp___2 = FillBuf___0(sPtr);
    if (! tmp___2) {
      break;
    }
  }
  return (0);
}
}
static void NodeDestroy___0(Node *nodePtr ) ;
static int CmpNodes___0(Node **leftPtrPtr , Node **rightPtrPtr ) ;
static int CmpIdWithNode___0(int id , Node **nodePtrPtr ) ;
static Ns_Index *IndexNodeCreate___0(void) ;
static void IndexNodeDestroy___0(Ns_Index *indexPtr ) ;
static int CmpBranches___0(Branch **leftPtrPtr , Branch **rightPtrPtr ) ;
static int CmpKeyWithBranch___0(char *key___1 , Branch **branchPtrPtr ) ;
static void MkSeq___0(Tcl_DString *dsPtr , char *server , char *method , char *url ) ;
static void TrieInit___0(Trie *triePtr ) ;
static void TrieAdd___0(Trie *triePtr , char *seq , int id , void *data , int flags ,
                        void (*deletefunc)(void * ) ) ;
static void TrieTrunc___0(Trie *triePtr , int id ) ;
static int TrieBranchTrunc___0(Trie *triePtr , char *seq , int id ) ;
static void *TrieFind___0(Trie *triePtr , char *seq , int id , int *depthPtr ) ;
static void *TrieFindExact___0(Trie *triePtr , char *seq , int id , int flags ) ;
static void *TrieDelete___0(Trie *triePtr , char *seq , int id , int flags ) ;
static int CmpChannels___0(Channel **leftPtrPtr , Channel **rightPtrPtr ) ;
static int CmpKeyWithChannel___0(char *key___1 , Channel **channelPtrPtr ) ;
static int CmpChannelsAsStrings___0(Channel **leftPtrPtr , Channel **rightPtrPtr ) ;
static int CmpKeyWithChannelAsStrings___0(char *key___1 , Channel **channelPtrPtr ) ;
static void JunctionInit___0(Junction *juncPtr ) ;
static void JunctionAdd___0(Junction *juncPtr , char *seq , int id , void *data ,
                            int flags , void (*deletefunc)(void * ) ) ;
static void JunctionBranchTrunc___0(Junction *juncPtr , char *seq , int id ) ;
static void *JunctionFind___0(Junction *juncPtr , char *seq , int id , int fast ) ;
static void *JunctionFindExact___0(Junction *juncPtr , char *seq , int id , int flags ,
                                   int fast ) ;
static void *JunctionDelete___0(Junction *juncPtr , char *seq , int id , int flags ) ;
static Junction urlspace___0  ;
static Ns_Mutex lock___30  ;
static int nextid___4  =    0;
static void NodeDestroy___0(Node *nodePtr ) 
{ 

  {
  if ((unsigned int )nodePtr == (unsigned int )((void *)0)) {
    goto done;
  }
  if ((unsigned int )nodePtr->deletefuncNoInherit != (unsigned int )((void *)0)) {
    ((*(nodePtr->deletefuncNoInherit)))(nodePtr->dataNoInherit);
  }
  if ((unsigned int )nodePtr->deletefuncInherit != (unsigned int )((void *)0)) {
    ((*(nodePtr->deletefuncInherit)))(nodePtr->dataInherit);
  }
  ns_free((void *)nodePtr);
  done: 
  return;
}
}
static int CmpNodes___0(Node **leftPtrPtr , Node **rightPtrPtr ) 
{ int tmp ;

  {
  if (((*leftPtrPtr))->id != ((*rightPtrPtr))->id) {
    if (((*leftPtrPtr))->id > ((*rightPtrPtr))->id) {
      tmp = 1;
    } else {
      tmp = -1;
    }
    return (tmp);
  } else {
    return (0);
  }
}
}
static int CmpIdWithNode___0(int id , Node **nodePtrPtr ) 
{ int tmp ;

  {
  if (id != ((*nodePtrPtr))->id) {
    if (id > ((*nodePtrPtr))->id) {
      tmp = 1;
    } else {
      tmp = -1;
    }
    return (tmp);
  } else {
    return (0);
  }
}
}
static Ns_Index *IndexNodeCreate___0(void) 
{ Ns_Index *indexPtr ;

  {
  indexPtr = (Ns_Index *)ns_malloc(sizeof(Ns_Index ));
  Ns_IndexInit(indexPtr, 5, (int (*)(void const   * , void const   * ))(& CmpNodes___0),
               (int (*)(void const   * , void const   * ))(& CmpIdWithNode___0));
  return (indexPtr);
}
}
static void IndexNodeDestroy___0(Ns_Index *indexPtr ) 
{ int i ;
  void *tmp ;
  int tmp___0 ;

  {
  i = indexPtr->n;
  while (1) {
    tmp___0 = i;
    i --;
    if (! tmp___0) {
      break;
    }
    tmp = Ns_IndexEl(indexPtr, i);
    NodeDestroy___0((Node *)tmp);
  }
  Ns_IndexDestroy(indexPtr);
  ns_free((void *)indexPtr);
  return;
}
}
static int CmpBranches___0(Branch **leftPtrPtr , Branch **rightPtrPtr ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if (0) {
    __s1_len = strlen((char const   *)((*leftPtrPtr))->word);
    __s2_len = strlen((char const   *)((*rightPtrPtr))->word);
    if (! ((unsigned int )((void const   *)(((*leftPtrPtr))->word + 1)) - (unsigned int )((void const   *)((*leftPtrPtr))->word) ==
           1U)) {
      goto _L___0;
    } else {
      if (__s1_len >= 4U) {
        _L___0: 
        if (! ((unsigned int )((void const   *)(((*rightPtrPtr))->word + 1)) - (unsigned int )((void const   *)((*rightPtrPtr))->word) ==
               1U)) {
          tmp___6 = 1;
        } else {
          if (__s2_len >= 4U) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        }
      } else {
        tmp___6 = 0;
      }
    }
    if (tmp___6) {
      if (__s1_len < __s2_len) {
        tmp___4 = __s1_len;
      } else {
        tmp___4 = __s2_len;
      }
      tmp___3 = memcmp((void const   *)((char const   *)((*leftPtrPtr))->word), (void const   *)((char const   *)((*rightPtrPtr))->word),
                       tmp___4 + 1U);
    } else {
      tmp___5 = strcmp((char const   *)((*leftPtrPtr))->word, (char const   *)((*rightPtrPtr))->word);
      tmp___3 = tmp___5;
    }
  } else {
    tmp___5 = strcmp((char const   *)((*leftPtrPtr))->word, (char const   *)((*rightPtrPtr))->word);
    tmp___3 = tmp___5;
  }
  return (tmp___3);
}
}
static int CmpKeyWithBranch___0(char *key___1 , Branch **branchPtrPtr ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if (0) {
    __s1_len = strlen((char const   *)key___1);
    __s2_len = strlen((char const   *)((*branchPtrPtr))->word);
    if (! ((unsigned int )((void const   *)(key___1 + 1)) - (unsigned int )((void const   *)key___1) ==
           1U)) {
      goto _L___0;
    } else {
      if (__s1_len >= 4U) {
        _L___0: 
        if (! ((unsigned int )((void const   *)(((*branchPtrPtr))->word + 1)) - (unsigned int )((void const   *)((*branchPtrPtr))->word) ==
               1U)) {
          tmp___6 = 1;
        } else {
          if (__s2_len >= 4U) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        }
      } else {
        tmp___6 = 0;
      }
    }
    if (tmp___6) {
      if (__s1_len < __s2_len) {
        tmp___4 = __s1_len;
      } else {
        tmp___4 = __s2_len;
      }
      tmp___3 = memcmp((void const   *)((char const   *)key___1), (void const   *)((char const   *)((*branchPtrPtr))->word),
                       tmp___4 + 1U);
    } else {
      tmp___5 = strcmp((char const   *)key___1, (char const   *)((*branchPtrPtr))->word);
      tmp___3 = tmp___5;
    }
  } else {
    tmp___5 = strcmp((char const   *)key___1, (char const   *)((*branchPtrPtr))->word);
    tmp___3 = tmp___5;
  }
  return (tmp___3);
}
}
static void TrieInit___0(Trie *triePtr ) 
{ 

  {
  Ns_IndexInit(& triePtr->branches, 25, (int (*)(void const   * , void const   * ))(& CmpBranches___0),
               (int (*)(void const   * , void const   * ))(& CmpKeyWithBranch___0));
  triePtr->indexnode = (Ns_Index *)((void *)0);
  return;
}
}
static void TrieAdd___0(Trie *triePtr , char *seq , int id , void *data , int flags ,
                        void (*deletefunc)(void * ) ) 
{ Node *nodePtr ;
  Branch *branchPtr ;
  size_t tmp ;

  {
  if ((int )(*seq) == 0) {
    if ((unsigned int )triePtr->indexnode == (unsigned int )((void *)0)) {
      triePtr->indexnode = IndexNodeCreate___0();
      nodePtr = (Node *)((void *)0);
    } else {
      nodePtr = (Node *)Ns_IndexFind(triePtr->indexnode, (void *)id);
    }
    if ((unsigned int )nodePtr == (unsigned int )((void *)0)) {
      nodePtr = (Node *)ns_malloc(sizeof(Node ));
      nodePtr->id = id;
      Ns_IndexAdd(triePtr->indexnode, (void *)nodePtr);
      nodePtr->dataInherit = (void *)0;
      nodePtr->dataNoInherit = (void *)0;
      nodePtr->deletefuncInherit = (void (*)(void * ))((void *)0);
      nodePtr->deletefuncNoInherit = (void (*)(void * ))((void *)0);
    } else {
      if ((flags & 4) == 0) {
        if ((flags & 2) != 0) {
          if ((unsigned int )nodePtr->deletefuncNoInherit != (unsigned int )((void *)0)) {
            ((*(nodePtr->deletefuncNoInherit)))(nodePtr->dataNoInherit);
          }
        } else {
          if ((unsigned int )nodePtr->deletefuncInherit != (unsigned int )((void *)0)) {
            ((*(nodePtr->deletefuncInherit)))(nodePtr->dataInherit);
          }
        }
      }
    }
    if (flags & 2) {
      nodePtr->dataNoInherit = data;
      nodePtr->deletefuncNoInherit = deletefunc;
    } else {
      nodePtr->dataInherit = data;
      nodePtr->deletefuncInherit = deletefunc;
    }
  } else {
    branchPtr = (Branch *)Ns_IndexFind(& triePtr->branches, (void *)seq);
    if ((unsigned int )branchPtr == (unsigned int )((void *)0)) {
      branchPtr = (Branch *)ns_malloc(sizeof(Branch ));
      branchPtr->word = ns_strdup((char const   *)seq);
      TrieInit___0(& branchPtr->node);
      Ns_IndexAdd(& triePtr->branches, (void *)branchPtr);
    }
    tmp = strlen((char const   *)seq);
    TrieAdd___0(& branchPtr->node, (seq + tmp) + 1, id, data, flags, deletefunc);
  }
  return;
}
}
static void TrieTrunc___0(Trie *triePtr , int id ) 
{ int n ;
  int i ;
  Branch *branchPtr ;
  Node *nodePtr ;

  {
  n = triePtr->branches.n;
  if (n > 0) {
    i = 0;
    while (i < n) {
      branchPtr = (Branch *)Ns_IndexEl(& triePtr->branches, i);
      TrieTrunc___0(& branchPtr->node, id);
      i ++;
    }
  }
  if ((unsigned int )triePtr->indexnode != (unsigned int )((void *)0)) {
    if (id != -1) {
      nodePtr = (Node *)Ns_IndexFind(triePtr->indexnode, (void *)id);
      if ((unsigned int )nodePtr != (unsigned int )((void *)0)) {
        NodeDestroy___0(nodePtr);
        Ns_IndexDel(triePtr->indexnode, (void *)nodePtr);
      }
    } else {
      IndexNodeDestroy___0(triePtr->indexnode);
      triePtr->indexnode = (Ns_Index *)((void *)0);
    }
  }
  return;
}
}
static int TrieBranchTrunc___0(Trie *triePtr , char *seq , int id ) 
{ Branch *branchPtr ;
  size_t tmp ;
  int tmp___0 ;

  {
  if ((int )(*seq) != 0) {
    branchPtr = (Branch *)Ns_IndexFind(& triePtr->branches, (void *)seq);
    if ((unsigned int )branchPtr != (unsigned int )((void *)0)) {
      tmp = strlen((char const   *)seq);
      tmp___0 = TrieBranchTrunc___0(& branchPtr->node, (seq + tmp) + 1, id);
      return (tmp___0);
    } else {
      return (-1);
    }
  } else {
    TrieTrunc___0(triePtr, id);
    return (0);
  }
}
}
static void *TrieFind___0(Trie *triePtr , char *seq , int id , int *depthPtr ) 
{ void *data ;
  int ldepth ;
  Node *nodePtr ;
  Branch *branchPtr ;
  void *p ;
  size_t tmp ;
  void *tmp___0 ;

  {
  data = (void *)0;
  ldepth = (*depthPtr);
  if ((unsigned int )triePtr->indexnode != (unsigned int )((void *)0)) {
    nodePtr = (Node *)Ns_IndexFind(triePtr->indexnode, (void *)id);
    if ((unsigned int )nodePtr != (unsigned int )((void *)0)) {
      if ((int )(*seq) == 0) {
        if ((unsigned int )nodePtr->dataNoInherit != (unsigned int )((void *)0)) {
          data = nodePtr->dataNoInherit;
        } else {
          data = nodePtr->dataInherit;
        }
      } else {
        data = nodePtr->dataInherit;
      }
    }
  }
  if ((int )(*seq) != 0) {
    branchPtr = (Branch *)Ns_IndexFind(& triePtr->branches, (void *)seq);
    ldepth ++;
    if ((unsigned int )branchPtr != (unsigned int )((void *)0)) {
      tmp = strlen((char const   *)seq);
      tmp___0 = TrieFind___0(& branchPtr->node, (seq + tmp) + 1, id, & ldepth);
      p = tmp___0;
      if ((unsigned int )p != (unsigned int )((void *)0)) {
        data = p;
        (*depthPtr) = ldepth;
      }
    }
  }
  return (data);
}
}
static void *TrieFindExact___0(Trie *triePtr , char *seq , int id , int flags ) 
{ void *data ;
  Branch *branchPtr ;
  size_t tmp ;
  Node *nodePtr ;

  {
  data = (void *)0;
  if ((int )(*seq) != 0) {
    branchPtr = (Branch *)Ns_IndexFind(& triePtr->branches, (void *)seq);
    if ((unsigned int )branchPtr != (unsigned int )((void *)0)) {
      tmp = strlen((char const   *)seq);
      data = TrieFindExact___0(& branchPtr->node, (seq + tmp) + 1, id, flags);
    }
  } else {
    if ((unsigned int )triePtr->indexnode != (unsigned int )((void *)0)) {
      nodePtr = (Node *)Ns_IndexFind(triePtr->indexnode, (void *)id);
      if ((unsigned int )nodePtr != (unsigned int )((void *)0)) {
        if (flags & 2) {
          data = nodePtr->dataNoInherit;
        } else {
          data = nodePtr->dataInherit;
        }
      }
    }
  }
  return (data);
}
}
static void *TrieDelete___0(Trie *triePtr , char *seq , int id , int flags ) 
{ void *data ;
  Branch *branchPtr ;
  size_t tmp ;
  Node *nodePtr ;

  {
  data = (void *)0;
  if ((int )(*seq) != 0) {
    branchPtr = (Branch *)Ns_IndexFind(& triePtr->branches, (void *)seq);
    if ((unsigned int )branchPtr != (unsigned int )((void *)0)) {
      tmp = strlen((char const   *)seq);
      data = TrieDelete___0(& branchPtr->node, (seq + tmp) + 1, id, flags);
    }
  } else {
    if ((unsigned int )triePtr->indexnode != (unsigned int )((void *)0)) {
      nodePtr = (Node *)Ns_IndexFind(triePtr->indexnode, (void *)id);
      if ((unsigned int )nodePtr != (unsigned int )((void *)0)) {
        if (flags & 2) {
          data = nodePtr->dataNoInherit;
          nodePtr->dataNoInherit = (void *)0;
          if ((unsigned int )nodePtr->deletefuncNoInherit != (unsigned int )((void *)0)) {
            if (! (flags & 4)) {
              ((*(nodePtr->deletefuncNoInherit)))(data);
            }
            nodePtr->deletefuncNoInherit = (void (*)(void * ))((void *)0);
          }
        } else {
          data = nodePtr->dataInherit;
          nodePtr->dataInherit = (void *)0;
          if ((unsigned int )nodePtr->deletefuncInherit != (unsigned int )((void *)0)) {
            if (! (flags & 4)) {
              ((*(nodePtr->deletefuncInherit)))(data);
            }
            nodePtr->deletefuncInherit = (void (*)(void * ))((void *)0);
          }
        }
      }
    }
  }
  return (data);
}
}
static int CmpChannels___0(Channel **leftPtrPtr , Channel **rightPtrPtr ) 
{ int lcontainsr ;
  int rcontainsl ;

  {
  lcontainsr = Tcl_StringMatch(((*rightPtrPtr))->filter, ((*leftPtrPtr))->filter);
  rcontainsl = Tcl_StringMatch(((*leftPtrPtr))->filter, ((*rightPtrPtr))->filter);
  if (lcontainsr) {
    if (rcontainsl) {
      return (0);
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (lcontainsr) {
      return (1);
    } else {
      if (rcontainsl) {
        return (-1);
      } else {
        return (0);
      }
    }
  }
}
}
static int CmpKeyWithChannel___0(char *key___1 , Channel **channelPtrPtr ) 
{ int lcontainsr ;
  int rcontainsl ;

  {
  lcontainsr = Tcl_StringMatch(((*channelPtrPtr))->filter, key___1);
  rcontainsl = Tcl_StringMatch(key___1, ((*channelPtrPtr))->filter);
  if (lcontainsr) {
    if (rcontainsl) {
      return (0);
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (lcontainsr) {
      return (1);
    } else {
      if (rcontainsl) {
        return (-1);
      } else {
        return (0);
      }
    }
  }
}
}
static int CmpChannelsAsStrings___0(Channel **leftPtrPtr , Channel **rightPtrPtr ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if (0) {
    __s1_len = strlen((char const   *)((*leftPtrPtr))->filter);
    __s2_len = strlen((char const   *)((*rightPtrPtr))->filter);
    if (! ((unsigned int )((void const   *)(((*leftPtrPtr))->filter + 1)) - (unsigned int )((void const   *)((*leftPtrPtr))->filter) ==
           1U)) {
      goto _L___0;
    } else {
      if (__s1_len >= 4U) {
        _L___0: 
        if (! ((unsigned int )((void const   *)(((*rightPtrPtr))->filter + 1)) - (unsigned int )((void const   *)((*rightPtrPtr))->filter) ==
               1U)) {
          tmp___6 = 1;
        } else {
          if (__s2_len >= 4U) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        }
      } else {
        tmp___6 = 0;
      }
    }
    if (tmp___6) {
      if (__s1_len < __s2_len) {
        tmp___4 = __s1_len;
      } else {
        tmp___4 = __s2_len;
      }
      tmp___3 = memcmp((void const   *)((char const   *)((*leftPtrPtr))->filter),
                       (void const   *)((char const   *)((*rightPtrPtr))->filter),
                       tmp___4 + 1U);
    } else {
      tmp___5 = strcmp((char const   *)((*leftPtrPtr))->filter, (char const   *)((*rightPtrPtr))->filter);
      tmp___3 = tmp___5;
    }
  } else {
    tmp___5 = strcmp((char const   *)((*leftPtrPtr))->filter, (char const   *)((*rightPtrPtr))->filter);
    tmp___3 = tmp___5;
  }
  return (tmp___3);
}
}
static int CmpKeyWithChannelAsStrings___0(char *key___1 , Channel **channelPtrPtr ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if (0) {
    __s1_len = strlen((char const   *)key___1);
    __s2_len = strlen((char const   *)((*channelPtrPtr))->filter);
    if (! ((unsigned int )((void const   *)(key___1 + 1)) - (unsigned int )((void const   *)key___1) ==
           1U)) {
      goto _L___0;
    } else {
      if (__s1_len >= 4U) {
        _L___0: 
        if (! ((unsigned int )((void const   *)(((*channelPtrPtr))->filter + 1)) -
               (unsigned int )((void const   *)((*channelPtrPtr))->filter) == 1U)) {
          tmp___6 = 1;
        } else {
          if (__s2_len >= 4U) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        }
      } else {
        tmp___6 = 0;
      }
    }
    if (tmp___6) {
      if (__s1_len < __s2_len) {
        tmp___4 = __s1_len;
      } else {
        tmp___4 = __s2_len;
      }
      tmp___3 = memcmp((void const   *)((char const   *)key___1), (void const   *)((char const   *)((*channelPtrPtr))->filter),
                       tmp___4 + 1U);
    } else {
      tmp___5 = strcmp((char const   *)key___1, (char const   *)((*channelPtrPtr))->filter);
      tmp___3 = tmp___5;
    }
  } else {
    tmp___5 = strcmp((char const   *)key___1, (char const   *)((*channelPtrPtr))->filter);
    tmp___3 = tmp___5;
  }
  return (tmp___3);
}
}
static void JunctionInit___0(Junction *juncPtr ) 
{ 

  {
  Ns_IndexInit(& juncPtr->byuse, 5, (int (*)(void const   * , void const   * ))(& CmpChannels___0),
               (int (*)(void const   * , void const   * ))(& CmpKeyWithChannel___0));
  Ns_IndexInit(& juncPtr->byname, 5, (int (*)(void const   * , void const   * ))(& CmpChannelsAsStrings___0),
               (int (*)(void const   * , void const   * ))(& CmpKeyWithChannelAsStrings___0));
  return;
}
}
static void JunctionBranchTrunc___0(Junction *juncPtr , char *seq , int id ) 
{ int i ;
  int n ;
  Channel *channelPtr ;
  Channel *tmp ;

  {
  n = juncPtr->byuse.n;
  i = 0;
  while (i < n) {
    tmp = (Channel *)Ns_IndexEl(& juncPtr->byuse, i);
    channelPtr = tmp;
    TrieBranchTrunc___0(& channelPtr->trie, seq, id);
    i ++;
  }
  return;
}
}
static void JunctionAdd___0(Junction *juncPtr , char *seq , int id , void *data ,
                            int flags , void (*deletefunc)(void * ) ) 
{ Channel *channelPtr ;
  Tcl_DString dsWord ;
  char *p ;
  int l ;
  int depth ;
  size_t tmp ;
  char *tmp___1 ;
  char *tmp___3 ;

  {
  depth = 0;
  p = seq;
  while (1) {
    tmp = strlen((char const   *)p);
    l = (int )(tmp + 1U);
    if (! ((int )(*(p + l)) != 0)) {
      break;
    }
    depth ++;
    p += l;
  }
  Tcl_DStringInit(& dsWord);
  if ((unsigned int )p != (unsigned int )((void *)0)) {
    if (depth > 1) {
      tmp___1 = strchr((char const   *)p, '*');
      if (tmp___1) {
        Tcl_DStringAppend(& dsWord, p, -1);
        (*p) = (char )'\000';
      } else {
        tmp___3 = strchr((char const   *)p, '?');
        if (tmp___3) {
          Tcl_DStringAppend(& dsWord, p, -1);
          (*p) = (char )'\000';
        } else {
          Tcl_DStringAppend(& dsWord, (char *)"*", -1);
        }
      }
    } else {
      Tcl_DStringAppend(& dsWord, (char *)"*", -1);
    }
  } else {
    Tcl_DStringAppend(& dsWord, (char *)"*", -1);
  }
  channelPtr = (Channel *)Ns_IndexFind(& juncPtr->byname, (void *)dsWord.string);
  if ((unsigned int )channelPtr == (unsigned int )((void *)0)) {
    channelPtr = (Channel *)ns_malloc(sizeof(Channel ));
    channelPtr->filter = ns_strdup((char const   *)dsWord.string);
    TrieInit___0(& channelPtr->trie);
    Ns_IndexAdd(& juncPtr->byuse, (void *)channelPtr);
    Ns_IndexAdd(& juncPtr->byname, (void *)channelPtr);
  }
  TrieAdd___0(& channelPtr->trie, seq, id, data, flags, deletefunc);
  Tcl_DStringFree(& dsWord);
  return;
}
}
static void *JunctionFind___0(Junction *juncPtr , char *seq , int id , int fast ) 
{ char *p ;
  int l ;
  int i ;
  int n ;
  void *data ;
  int depth ;
  size_t tmp ;
  size_t tmp___0 ;
  Channel *channelPtr ;
  Channel *tmp___1 ;
  int doit ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *candidate ;
  int cdepth ;

  {
  n = 0;
  p = seq;
  while (1) {
    tmp = strlen((char const   *)p);
    l = (int )(tmp + 1U);
    if (! ((int )(*(p + l)) != 0)) {
      break;
    }
    n ++;
    p += l;
  }
  if (n < 2) {
    tmp___0 = strlen((char const   *)p);
    p += tmp___0 + 1U;
  }
  data = (void *)0;
  l = juncPtr->byuse.n;
  i = 0;
  while (i < l) {
    tmp___1 = (Channel *)Ns_IndexEl(& juncPtr->byuse, i);
    channelPtr = tmp___1;
    if (fast) {
      if (0) {
        __s1_len = strlen((char const   *)p);
        __s2_len = strlen((char const   *)channelPtr->filter);
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) ==
               1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)(channelPtr->filter + 1)) - (unsigned int )((void const   *)channelPtr->filter) ==
                   1U)) {
              tmp___9 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___9 = 1;
              } else {
                tmp___9 = 0;
              }
            }
          } else {
            tmp___9 = 0;
          }
        }
        if (tmp___9) {
          if (__s1_len < __s2_len) {
            tmp___7 = __s1_len;
          } else {
            tmp___7 = __s2_len;
          }
          tmp___6 = memcmp((void const   *)((char const   *)p), (void const   *)((char const   *)channelPtr->filter),
                           tmp___7 + 1U);
        } else {
          tmp___8 = strcmp((char const   *)p, (char const   *)channelPtr->filter);
          tmp___6 = tmp___8;
        }
      } else {
        tmp___8 = strcmp((char const   *)p, (char const   *)channelPtr->filter);
        tmp___6 = tmp___8;
      }
      if (tmp___6) {
        tmp___10 = 0;
      } else {
        tmp___10 = 1;
      }
      doit = tmp___10;
    } else {
      doit = Tcl_StringMatch(p, channelPtr->filter);
    }
    if (doit) {
      if ((unsigned int )data == (unsigned int )((void *)0)) {
        depth = 0;
        data = TrieFind___0(& channelPtr->trie, seq, id, & depth);
      } else {
        cdepth = 0;
        candidate = TrieFind___0(& channelPtr->trie, seq, id, & cdepth);
        if ((unsigned int )candidate != (unsigned int )((void *)0)) {
          if (cdepth > depth) {
            data = candidate;
            depth = cdepth;
          }
        }
      }
    }
    i ++;
  }
  return (data);
}
}
static void *JunctionFindExact___0(Junction *juncPtr , char *seq , int id , int flags ,
                                   int fast ) 
{ char *p ;
  int l ;
  int i ;
  int depth ;
  void *data ;
  size_t tmp ;
  Channel *channelPtr ;
  Channel *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  Channel *channelPtr___0 ;
  Channel *tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  depth = 0;
  p = seq;
  while (1) {
    tmp = strlen((char const   *)p);
    l = (int )(tmp + 1U);
    if (! ((int )(*(p + l)) != 0)) {
      break;
    }
    depth ++;
    p += l;
  }
  data = (void *)0;
  l = juncPtr->byuse.n;
  i = 0;
  while (i < l) {
    tmp___0 = (Channel *)Ns_IndexEl(& juncPtr->byuse, i);
    channelPtr = tmp___0;
    if (0) {
      __s1_len = strlen((char const   *)p);
      __s2_len = strlen((char const   *)channelPtr->filter);
      if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) ==
             1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: 
          if (! ((unsigned int )((void const   *)(channelPtr->filter + 1)) - (unsigned int )((void const   *)channelPtr->filter) ==
                 1U)) {
            tmp___8 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___8 = 1;
            } else {
              tmp___8 = 0;
            }
          }
        } else {
          tmp___8 = 0;
        }
      }
      if (tmp___8) {
        if (__s1_len < __s2_len) {
          tmp___6 = __s1_len;
        } else {
          tmp___6 = __s2_len;
        }
        tmp___5 = memcmp((void const   *)((char const   *)p), (void const   *)((char const   *)channelPtr->filter),
                         tmp___6 + 1U);
      } else {
        tmp___7 = strcmp((char const   *)p, (char const   *)channelPtr->filter);
        tmp___5 = tmp___7;
      }
    } else {
      tmp___7 = strcmp((char const   *)p, (char const   *)channelPtr->filter);
      tmp___5 = tmp___7;
    }
    if (tmp___5 == 0) {
      (*p) = (char )'\000';
      data = TrieFindExact___0(& channelPtr->trie, seq, id, flags);
      goto done;
    }
    i ++;
  }
  i = 0;
  while (i < l) {
    tmp___9 = (Channel *)Ns_IndexEl(& juncPtr->byuse, i);
    channelPtr___0 = tmp___9;
    if (0) {
      __s1_len___0 = strlen("*");
      __s2_len___0 = strlen((char const   *)channelPtr___0->filter);
      if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
             1U)) {
        goto _L___2;
      } else {
        if (__s1_len___0 >= 4U) {
          _L___2: 
          if (! ((unsigned int )((void const   *)(channelPtr___0->filter + 1)) - (unsigned int )((void const   *)channelPtr___0->filter) ==
                 1U)) {
            tmp___17 = 1;
          } else {
            if (__s2_len___0 >= 4U) {
              tmp___17 = 1;
            } else {
              tmp___17 = 0;
            }
          }
        } else {
          tmp___17 = 0;
        }
      }
      if (tmp___17) {
        if (__s1_len___0 < __s2_len___0) {
          tmp___15 = __s1_len___0;
        } else {
          tmp___15 = __s2_len___0;
        }
        tmp___14 = memcmp((void const   *)"*", (void const   *)((char const   *)channelPtr___0->filter),
                          tmp___15 + 1U);
      } else {
        tmp___16 = strcmp("*", (char const   *)channelPtr___0->filter);
        tmp___14 = tmp___16;
      }
    } else {
      tmp___16 = strcmp("*", (char const   *)channelPtr___0->filter);
      tmp___14 = tmp___16;
    }
    if (tmp___14 == 0) {
      data = TrieFindExact___0(& channelPtr___0->trie, seq, id, flags);
      break;
    }
    i ++;
  }
  done: 
  return (data);
}
}
static void *JunctionDelete___0(Junction *juncPtr , char *seq , int id , int flags ) 
{ char *p ;
  int l ;
  int i ;
  int depth ;
  void *data ;
  size_t tmp ;
  Channel *channelPtr ;
  Channel *tmp___0 ;
  int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  depth = 0;
  p = seq;
  while (1) {
    tmp = strlen((char const   *)p);
    l = (int )(tmp + 1U);
    if (! ((int )(*(p + l)) != 0)) {
      break;
    }
    depth ++;
    p += l;
  }
  data = (void *)0;
  l = juncPtr->byuse.n;
  i = 0;
  while (1) {
    if (i < l) {
      if (! ((unsigned int )data == (unsigned int )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    tmp___0 = (Channel *)Ns_IndexEl(& juncPtr->byuse, i);
    channelPtr = tmp___0;
    if (depth == 2) {
      if (0) {
        __s1_len = strlen((char const   *)p);
        __s2_len = strlen((char const   *)channelPtr->filter);
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) ==
               1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)(channelPtr->filter + 1)) - (unsigned int )((void const   *)channelPtr->filter) ==
                   1U)) {
              tmp___9 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___9 = 1;
              } else {
                tmp___9 = 0;
              }
            }
          } else {
            tmp___9 = 0;
          }
        }
        if (tmp___9) {
          if (__s1_len < __s2_len) {
            tmp___7 = __s1_len;
          } else {
            tmp___7 = __s2_len;
          }
          tmp___6 = memcmp((void const   *)((char const   *)p), (void const   *)((char const   *)channelPtr->filter),
                           tmp___7 + 1U);
        } else {
          tmp___8 = strcmp((char const   *)p, (char const   *)channelPtr->filter);
          tmp___6 = tmp___8;
        }
      } else {
        tmp___8 = strcmp((char const   *)p, (char const   *)channelPtr->filter);
        tmp___6 = tmp___8;
      }
      if (tmp___6 == 0) {
        (*p) = (char )'\000';
        data = TrieFindExact___0(& channelPtr->trie, seq, id, flags);
        if ((unsigned int )data != (unsigned int )((void *)0)) {
          TrieDelete___0(& channelPtr->trie, seq, id, flags);
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      tmp___1 = Tcl_StringMatch(p, channelPtr->filter);
      if (tmp___1) {
        data = TrieFindExact___0(& channelPtr->trie, seq, id, flags);
        if ((unsigned int )data != (unsigned int )((void *)0)) {
          TrieDelete___0(& channelPtr->trie, seq, id, flags);
        }
      }
    }
    i ++;
  }
  return (data);
}
}
static void MkSeq___0(Tcl_DString *dsPtr , char *server , char *method , char *url ) 
{ char *p ;
  int done ;
  size_t tmp ;
  size_t tmp___0 ;
  int l ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
  if ((unsigned int )method != (unsigned int )((void *)0)) {
    if ((unsigned int )url != (unsigned int )((void *)0)) {
      tmp = strlen((char const   *)server);
      Tcl_DStringAppend(dsPtr, server, (int )(tmp + 1U));
      tmp___0 = strlen((char const   *)method);
      Tcl_DStringAppend(dsPtr, method, (int )(tmp___0 + 1U));
      done = 0;
      while (1) {
        if (! done) {
          if (! ((int )(*url) != 0)) {
            break;
          }
        } else {
          break;
        }
        if ((int )(*url) != 47) {
          tmp___2 = strchr((char const   *)url, '/');
          p = tmp___2;
          if ((unsigned int )p != (unsigned int )((void *)0)) {
            l = p - url;
          } else {
            l = (int )strlen((char const   *)url);
            done = 1;
          }
          tmp___3 = l;
          l ++;
          Tcl_DStringAppend(dsPtr, url, tmp___3);
          Tcl_DStringAppend(dsPtr, (char *)"\000", 1);
          url += l;
        } else {
          url ++;
        }
      }
      Tcl_DStringAppend(dsPtr, (char *)"\000", 1);
    } else {
      tmp___4 = strlen((char const   *)server);
      Tcl_DStringAppend(dsPtr, server, (int )(tmp___4 + 1U));
      Tcl_DStringAppend(dsPtr, (char *)"\000", 1);
    }
  } else {
    tmp___4 = strlen((char const   *)server);
    Tcl_DStringAppend(dsPtr, server, (int )(tmp___4 + 1U));
    Tcl_DStringAppend(dsPtr, (char *)"\000", 1);
  }
  return;
}
}
static char six2pr___0[64]  = 
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'+',      (char )'/'};
static int pr2six___0[256]  = 
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      62, 
        -1,      -1,      -1,      63, 
        52,      53,      54,      55, 
        56,      57,      58,      59, 
        60,      61,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      0,      1,      2, 
        3,      4,      5,      6, 
        7,      8,      9,      10, 
        11,      12,      13,      14, 
        15,      16,      17,      18, 
        19,      20,      21,      22, 
        23,      24,      25,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      26,      27,      28, 
        29,      30,      31,      32, 
        33,      34,      35,      36, 
        37,      38,      39,      40, 
        41,      42,      43,      44, 
        45,      46,      47,      48, 
        49,      50,      51,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
