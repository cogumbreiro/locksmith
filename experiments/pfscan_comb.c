/* Generated by CIL v. 1.3.2 */
/* print_CIL_Input is true */

typedef unsigned int size_t;
typedef unsigned long long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef long __off_t;
typedef long long __off64_t;
typedef unsigned long __rlim_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[(int )(15U * sizeof(int ) - 2U * sizeof(void *))] ;
};
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
struct __sched_param {
   int __sched_priority ;
};
struct _pthread_fastlock {
   long __status ;
   int __spinlock ;
};
struct _pthread_descr_struct;
typedef struct _pthread_descr_struct *_pthread_descr;
struct __pthread_attr_s {
   int __detachstate ;
   int __schedpolicy ;
   struct __sched_param __schedparam ;
   int __inheritsched ;
   int __scope ;
   size_t __guardsize ;
   int __stackaddr_set ;
   void *__stackaddr ;
   size_t __stacksize ;
};
typedef struct __pthread_attr_s pthread_attr_t;
typedef long long __pthread_cond_align_t;
struct __anonstruct_pthread_cond_t_14 {
   struct _pthread_fastlock __c_lock ;
   _pthread_descr __c_waiting ;
   char __padding[(int )(((48U - sizeof(struct _pthread_fastlock )) - sizeof(_pthread_descr )) -
                         sizeof(__pthread_cond_align_t ))] ;
   __pthread_cond_align_t __align ;
};
typedef struct __anonstruct_pthread_cond_t_14 pthread_cond_t;
struct __anonstruct_pthread_mutex_t_16 {
   int __m_reserved ;
   int __m_count ;
   _pthread_descr __m_owner ;
   int __m_kind ;
   struct _pthread_fastlock __m_lock ;
};
typedef struct __anonstruct_pthread_mutex_t_16 pthread_mutex_t;
struct __anonstruct_pthread_mutexattr_t_17 {
   int __mutexkind ;
};
typedef struct __anonstruct_pthread_mutexattr_t_17 pthread_mutexattr_t;
typedef unsigned long pthread_t;
typedef void (*__sighandler_t)(int  );
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
typedef __rlim_t rlim_t;
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
typedef int __rlimit_resource_t;
/* #pragma existential(SPQ, "SPQ.mtx", "&SPQ.closed", "&SPQ.nextout", "&SPQ.occupied") */
struct SPQ {
   void **buf ;
   int qsize ;
   int occupied ;
   int nextin ;
   int nextout ;
   int closed ;
   pthread_mutex_t mtx ;
   pthread_cond_t more ;
   pthread_cond_t less ;
};
typedef struct SPQ PQUEUE;
struct __anonstruct_BM_53 {
   int *bmGs ;
   int bmBc[256] ;
   unsigned char *saved_x ;
   int saved_m ;
   int icase ;
};
typedef struct __anonstruct_BM_53 BM;
typedef int __ssize_t;
typedef __ssize_t ssize_t;
struct __anonstruct_pthread_condattr_t_7 {
   int __dummy ;
};
typedef struct __anonstruct_pthread_condattr_t_7 pthread_condattr_t;
#pragma merger(0,"/tmp/cil-hVI9wxXe.i","")
extern struct _IO_FILE *stdout ;
extern struct _IO_FILE *stderr ;
extern int fflush(FILE *__stream ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                  , ...) ;
extern int putchar(int __c ) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern void free(void *__ptr ) ;
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
extern int *__errno_location(void)  __attribute__((__const__)) ;
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern int toupper(int __c ) ;
extern char *strdup(char const   *__s )  __attribute__((__malloc__)) ;
extern char *strerror(int __errnum ) ;
extern __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
extern int open(char const   *__file , int __oflag  , ...) ;
extern int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
__inline static int fstat__extinline(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
  tmp = __fxstat(3, __fd, __statbuf);
  return (tmp);
}
}
extern int ftw(char const   *__dir , int (*__func)(char const   *__filename , struct stat  const  *__status ,
                                                   int __flag ) , int __descriptors ) ;
extern char *setlocale(int __category , char const   *__locale ) ;
extern void *mmap(void *__addr , size_t __len , int __prot , int __flags , int __fd ,
                  __off_t __offset ) ;
extern int munmap(void *__addr , size_t __len ) ;
extern int getrlimit(__rlimit_resource_t __resource , struct rlimit *__rlimits ) ;
extern int setrlimit(__rlimit_resource_t __resource , struct rlimit  const  *__rlimits ) ;
extern int close(int __fd ) ;
extern int pthread_create(pthread_t * __restrict  __threadp , pthread_attr_t const   * __restrict  __attr ,
                          void *(*__start_routine)(void * ) , void * __restrict  __arg ) ;
extern int pthread_attr_init(pthread_attr_t *__attr ) ;
extern int pthread_attr_setscope(pthread_attr_t *__attr , int __scope ) ;
extern int pthread_mutex_init(pthread_mutex_t * __restrict  __mutex , pthread_mutexattr_t const   * __restrict  __mutex_attr ) ;
extern int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
extern int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
extern int pthread_cond_signal(pthread_cond_t *__cond ) ;
extern int pthread_cond_wait(pthread_cond_t * __restrict  __cond , pthread_mutex_t * __restrict  __mutex ) ;
int pqueue_init(PQUEUE *qp , int qsize ) ;
/* int pqueue_init(PQUEUE __attribute__((packed))*qp , int qsize ); */
int pqueue_put(PQUEUE *qp , void *item ) ;
int pqueue_get(PQUEUE *qp , void **item ) ;
void pqueue_close(PQUEUE *qp ) ;
int bm_init(BM *bmp , unsigned char *x , int m , int icase ) ;
int bm_search(BM *bmp , unsigned char *y , size_t n , int (*mfun)(unsigned char *buf ,
                                                                  size_t n , size_t pos ,
                                                                  void *misc ) , void *misc ) ;
char version[4] ;
char *argv0  =    (char *)"pfscan";
int max_depth  =    64;
unsigned char *rstr  =    (unsigned char *)((void *)0);
int rlen  =    0;
int debug  =    0;
int verbose  =    0;
int nworkers  =    0;
int aworkers  =    0;
pthread_mutex_t aworker_lock  ;
pthread_cond_t aworker_cv  ;
int line_f  =    0;
int maxlen  =    64;
int ignore_case  =    0;
int n_matches  =    0;
int n_files  =    0;
unsigned int n_bytes  =    (size_t )0;
pthread_mutex_t matches_lock  ;
PQUEUE gqb  ;
PQUEUE *pqb  ;
pthread_mutex_t print_lock  ;
BM bmb  ;
void print_version(FILE *fp ) 
{ 

  {
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"[PFScan, version %s - %s %s]\n",
          version, "Mar 10 2006", "23:26:13");
  return;
}
}
int get_char_code(unsigned char **cp , int base ) 
{ int val ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  val = 0;
  len = 0;
  while (1) {
    if (base == 16) {
      tmp___3 = 2;
    } else {
      tmp___3 = 3;
    }
    if (len < tmp___3) {
      if ((int )(*((*cp))) >= 48) {
        if (base > 10) {
          tmp___4 = 10;
        } else {
          tmp___4 = base;
        }
        if ((int )(*((*cp))) < 48 + tmp___4) {
          goto _L___3;
        } else {
          goto _L___6;
        }
      } else {
        _L___6: /* CIL Label */ 
        if (base >= 10) {
          tmp___5 = toupper((int )(*((*cp))));
          if (tmp___5 >= 65) {
            tmp___6 = toupper((int )(*((*cp))));
            if (tmp___6 < (65 + base) - 10) {
              _L___3: /* CIL Label */ ;
            } else {
              goto _L___5;
            }
          } else {
            goto _L___5;
          }
        } else {
          _L___5: /* CIL Label */ 
          goto _L___2;
        }
      }
    } else {
      _L___2: /* CIL Label */ 
      break;
    }
    val *= base;
    if ((int )(*((*cp))) >= 48) {
      if (base > 10) {
        tmp___2 = 10;
      } else {
        tmp___2 = base;
      }
      if ((int )(*((*cp))) < 48 + tmp___2) {
        val += (int )(*((*cp))) - 48;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      if (base >= 10) {
        tmp___0 = toupper((int )(*((*cp))));
        if (tmp___0 >= 65) {
          tmp___1 = toupper((int )(*((*cp))));
          if (tmp___1 < (65 + base) - 10) {
            tmp = toupper((int )(*((*cp))));
            val += (tmp - 65) + 10;
          } else {
            goto _L___0;
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ ;
      }
    }
    (*cp) ++;
    len ++;
  }
  return (val & 255);
}
}
int dehex(unsigned char *str ) 
{ unsigned char *wp ;
  unsigned char *rp ;
  int val ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned char *tmp___1 ;

  {
  wp = str;
  rp = wp;
  while ((*rp)) {
    while (1) {
      if ((*rp)) {
        tmp = __ctype_b_loc();
        if (! ((int const   )(*((*tmp) + (int )(*rp))) & 8192)) {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        break;
      }
      rp ++;
    }
    if ((int )(*rp) == 0) {
      break;
    }
    tmp___0 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___0) + (int )(*rp))) & 4096)) {
      return (-1);
    }
    val = get_char_code(& rp, 16);
    tmp___1 = wp;
    wp ++;
    (*tmp___1) = (unsigned char )val;
  }
  (*wp) = (unsigned char )'\000';
  return (wp - str);
}
}
int deslash(unsigned char *str ) 
{ unsigned char *wp ;
  unsigned char *rp ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;

  {
  wp = str;
  rp = wp;
  while ((*rp)) {
    if ((int )(*rp) != 92) {
      tmp = wp;
      wp ++;
      tmp___0 = rp;
      rp ++;
      (*tmp) = (*tmp___0);
    } else {
      rp ++;
      switch ((int )(*rp)) {
      case 110: 
      tmp___1 = wp;
      wp ++;
      (*tmp___1) = (unsigned char)10;
      rp ++;
      break;
      case 114: 
      tmp___2 = wp;
      wp ++;
      (*tmp___2) = (unsigned char)13;
      rp ++;
      break;
      case 116: 
      tmp___3 = wp;
      wp ++;
      (*tmp___3) = (unsigned char)9;
      rp ++;
      break;
      case 98: 
      tmp___4 = wp;
      wp ++;
      (*tmp___4) = (unsigned char)8;
      rp ++;
      break;
      case 120: 
      rp ++;
      tmp___5 = wp;
      wp ++;
      (*tmp___5) = (unsigned char )get_char_code(& rp, 16);
      break;
      case 48: 
      tmp___6 = wp;
      wp ++;
      (*tmp___6) = (unsigned char )get_char_code(& rp, 8);
      break;
      case 49: ;
      case 50: ;
      case 51: ;
      case 52: ;
      case 53: ;
      case 54: ;
      case 55: ;
      case 56: ;
      case 57: 
      tmp___7 = wp;
      wp ++;
      (*tmp___7) = (unsigned char )get_char_code(& rp, 10);
      break;
      default: 
      tmp___8 = wp;
      wp ++;
      tmp___9 = rp;
      rp ++;
      (*tmp___8) = (*tmp___9);
      break;
      }
    }
  }
  (*wp) = (unsigned char )'\000';
  return (wp - str);
}
}
int is_text(unsigned char *cp , int slen ) 
{ unsigned short const   **tmp ;

  {
  while (1) {
    if (slen > 0) {
      tmp = __ctype_b_loc();
      if ((int const   )(*((*tmp) + (int )(*cp))) & 16384) {
        goto _L___3;
      } else {
        if ((int )(*cp) == 0) {
          _L___3: /* CIL Label */ 
          goto _L___2;
        } else {
          if ((int )(*cp) == 9) {
            _L___2: /* CIL Label */ 
            goto _L___1;
          } else {
            if ((int )(*cp) == 10) {
              _L___1: /* CIL Label */ 
              goto _L___0;
            } else {
              if ((int )(*cp) == 13) {
                _L___0: /* CIL Label */ ;
              } else {
                goto _L;
              }
            }
          }
        }
      }
    } else {
      _L: /* CIL Label */ 
      break;
    }
    slen --;
    cp ++;
  }
  return (slen == 0);
}
}
size_t print_output(unsigned char *str , size_t slen ) 
{ size_t len ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  len = 0U;
  if ((unsigned int )str == (unsigned int )((void *)0)) {
    printf((char const   * __restrict  )"NULL");
    return (len);
  }
  tmp___0 = is_text(str, (int )slen);
  if (tmp___0) {
    printf((char const   * __restrict  )"TXT : ");
    while (1) {
      if (len < slen) {
        if (! (len < (size_t )maxlen)) {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        break;
      }
      tmp = __ctype_b_loc();
      if ((int const   )(*((*tmp) + (int )(*str))) & 16384) {
        putchar((int )(*str));
      } else {
        switch ((int )(*str)) {
        case 0: 
        printf((char const   * __restrict  )"\\0");
        break;
        case 10: ;
        if (line_f) {
          return (len);
        }
        printf((char const   * __restrict  )"\\n");
        break;
        case 13: ;
        if (line_f) {
          return (len);
        }
        printf((char const   * __restrict  )"\\r");
        break;
        case 9: 
        printf((char const   * __restrict  )"\\t");
        break;
        default: 
        printf((char const   * __restrict  )"\\x%02x", (*str));
        }
      }
      len ++;
      str ++;
    }
  } else {
    printf((char const   * __restrict  )"HEX :");
    while (1) {
      if (len < slen) {
        if (! (len < (size_t )maxlen)) {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        break;
      }
      printf((char const   * __restrict  )" %02x", (*str));
      len ++;
      str ++;
    }
  }
  return (len);
}
}
int matchfun(unsigned char *buf , size_t len , size_t pos , void *misc ) 
{ char *pathname ;

  {
  pathname = (char *)misc;
  pthread_mutex_lock(& matches_lock);
  n_matches ++;
  pthread_mutex_unlock(& matches_lock);
  if (line_f) {
    while (1) {
      if (pos > 0U) {
        if ((int )(*(buf + (pos - 1U))) == 10) {
          goto _L___0;
        } else {
          if ((int )(*(buf + (pos - 1U))) == 13) {
            _L___0: /* CIL Label */ 
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
        break;
      }
      pos --;
    }
  }
  pthread_mutex_lock(& print_lock);
  printf((char const   * __restrict  )"%s : %lu : ", pathname, (unsigned long )pos);
  print_output(buf + pos, len - pos);
  putchar('\n');
  pthread_mutex_unlock(& print_lock);
  return (0);
}
}
int scan_file(char *pathname ) 
{ int fd ;
  size_t len ;
  unsigned char *buf ;
  struct stat sb ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int code ;

  {
  fd = open((char const   *)pathname, 0);
  if (fd < 0) {
    if (verbose) {
      pthread_mutex_lock(& print_lock);
      tmp = __errno_location();
      tmp___0 = strerror((*tmp));
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s : ERR : open() failed: %s\n",
              pathname, tmp___0);
      pthread_mutex_unlock(& print_lock);
    }
    return (-1);
  }
  tmp___3 = fstat__extinline(fd, & sb);
  if (tmp___3 < 0) {
    if (verbose) {
      pthread_mutex_lock(& print_lock);
      tmp___1 = __errno_location();
      tmp___2 = strerror((*tmp___1));
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s : ERR : fstat() failed: %s\n",
              pathname, tmp___2);
      pthread_mutex_unlock(& print_lock);
    }
    close(fd);
    return (-1);
  }
  len = (unsigned int )sb.st_size;
  if (debug > 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"*** Scanning file %s (%u Mbytes)\n",
            pathname, len / 1000000U);
  }
  buf = (unsigned char *)mmap((void *)0, len, 1, 16386, fd, 0L);
  if ((unsigned int )buf == (unsigned int )((void *)-1)) {
    if (verbose) {
      pthread_mutex_lock(& print_lock);
      tmp___5 = __errno_location();
      tmp___6 = strerror((*tmp___5));
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s : ERR : mmap() failed: %s\n",
              pathname, tmp___6);
      pthread_mutex_unlock(& print_lock);
    }
    close(fd);
    return (-1);
  }
  if (rstr) {
    code = bm_search(& bmb, buf, len, & matchfun, (void *)pathname);
  } else {
    pthread_mutex_lock(& print_lock);
    printf((char const   * __restrict  )"%s : 0 : ", pathname);
    print_output(buf, len);
    putchar('\n');
    pthread_mutex_unlock(& print_lock);
  }
  munmap((void *)((char *)buf), len);
  close(fd);
  return (1);
}
}
int foreach_path(char const   *path , struct stat  const  *sp , int f ) 
{ void *tmp ;

  {
  n_files ++;
  n_bytes = (unsigned int )((unsigned long )n_bytes + (unsigned long )sp->st_size);
  switch (f) {
  case 0: 
  tmp = (void *)strdup(path);
  pqueue_put(pqb, tmp);
  return (0);
  case 1: ;
  return (0);
  case 2: 
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Can\'t read directory.\n",
          argv0, path);
  return (1);
  case 3: 
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Can\'t stat object.\n",
          argv0, path);
  return (1);
  default: 
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Internal error (invalid ftw code)\n",
          argv0, path);
  }
  return (1);
}
}
int do_ftw(char *path ) 
{ int code ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  tmp = ftw((char const   *)path, & foreach_path, max_depth);
  code = tmp;
  if (code < 0) {
    tmp___0 = __errno_location();
    tmp___1 = strerror((*tmp___0));
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ftw: %s\n",
            argv0, tmp___1);
    return (1);
  }
  return (code);
}
}
void *worker(void *arg ) 
{ char *path ;
  int tmp ;

  {
  while (1) {
    tmp = pqueue_get(pqb, (void **)(& path));
    if (! (tmp == 1)) {
      break;
    }
    scan_file(path);
    free((void *)path);
  }
  fflush(stdout);
  pthread_mutex_lock(& aworker_lock);
  aworkers --;
  pthread_mutex_unlock(& aworker_lock);
  pthread_cond_signal(& aworker_cv);
  return ((void *)0);
}
}
void usage(FILE *out ) 
{ 

  {
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"Usage: %s [<options>] <search-string> <pathname> [... <pathname-N>]\n",
          argv0);
  fputs((char const   * __restrict  )"\nThis program implements a multithreaded file scanner.\nMore information may be found at:\n\thttp://www.lysator.liu.se/~pen/pfscan\n\nCommand line options:\n",
        (FILE * __restrict  )out);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-h             Display this information.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-V             Print version.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-v             Be verbose.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-d             Print debugging info.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-i             Ignore case when scanning.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-l             Line oriented output.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-n<workers>    Concurrent worker threads limit.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-L<length>     Max length of bytes to print.\n");
  return;
}
}
int main(int argc , char **argv ) 
{ int i ;
  int j ;
  struct rlimit rlb ;
  char *arg ;
  pthread_t tid ;
  pthread_attr_t pab ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
/*   PQUEUE __attribute__((packed)) *unpacked_pqb; */
/*   unpacked_pqb =  (PQUEUE __attribute__((packed)) *) malloc(1); */
  pqb =  &gqb;

  aworkers = nworkers;
  {
  argv0 = (*(argv + 0));
  setlocale(0, "");
  getrlimit(7, & rlb);
  rlb.rlim_cur = rlb.rlim_max;
  setrlimit(7, (struct rlimit  const  *)(& rlb));
  signal(13, (void (*)(int  ))1);
  nworkers = 2;
  pthread_mutex_init((pthread_mutex_t * __restrict  )(& print_lock), (pthread_mutexattr_t const   * __restrict  )((void *)0));
  pthread_mutex_init((pthread_mutex_t * __restrict  )(& aworker_lock), (pthread_mutexattr_t const   * __restrict  )((void *)0));
  pthread_mutex_init((pthread_mutex_t * __restrict  )(& matches_lock), (pthread_mutexattr_t const   * __restrict  )((void *)0));
  i = 1;
  while (1) {
    if (i < argc) {
      if (! ((int )(*((*(argv + i)) + 0)) == 45)) {
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      break;
    }
    j = 1;
    while (1) {
      if (j > 0) {
        if (! (*((*(argv + i)) + j))) {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        break;
      }
      switch ((int )(*((*(argv + i)) + j))) {
      case 45: 
      i ++;
      goto EndOptions;
      case 86: 
      print_version(stdout);
      break;
      case 100: 
      debug ++;
      break;
      case 105: 
      ignore_case = 1;
      break;
      case 118: 
      verbose ++;
      break;
      case 104: 
      usage(stdout);
      exit(0);
      case 108: 
      line_f ++;
      break;
      case 76: ;
      if ((*((*(argv + i)) + 2))) {
        arg = (*(argv + i)) + 2;
      } else {
        i ++;
        arg = (*(argv + i));
      }
      if (! arg) {
        goto _L;
      } else {
        tmp___0 = sscanf((char const   * __restrict  )arg, (char const   * __restrict  )"%u",
                         & maxlen);
        if (tmp___0 != 1) {
          _L: /* CIL Label */ 
          if (arg) {
            tmp = (char const   *)arg;
          } else {
            tmp = "<null>";
          }
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Invalid length specification: %s\n",
                  (*(argv + 0)), tmp);
          exit(1);
        }
      }
      j = -2;
      break;
      case 110: ;
      if ((*((*(argv + i)) + 2))) {
        arg = (*(argv + i)) + 2;
      } else {
        i ++;
        arg = (*(argv + i));
      }
      if (! arg) {
        goto _L___0;
      } else {
        tmp___2 = sscanf((char const   * __restrict  )arg, (char const   * __restrict  )"%u",
                         & nworkers);
        if (tmp___2 != 1) {
          _L___0: /* CIL Label */ 
          if (arg) {
            tmp___1 = (char const   *)arg;
          } else {
            tmp___1 = "<null>";
          }
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Invalid workers specification: %s\n",
                  (*(argv + 0)), tmp___1);
          exit(1);
        }
      }
      j = -2;
      break;
      default: 
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: unknown command line switch: -%c\n",
              (*(argv + 0)), (*((*(argv + i)) + j)));
      exit(1);
      }
      j ++;
    }
    i ++;
  }
  EndOptions: 
  tmp___3 = i;
  i ++;
  rstr = (unsigned char *)strdup((char const   *)(*(argv + tmp___3)));
  rlen = deslash(rstr);
  tmp___5 = bm_init(& bmb, rstr, rlen, ignore_case);
  if (tmp___5 < 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Failed search string setup: %s\n",
            (*(argv + 0)), rstr);
    exit(1);
  }
  max_depth = (int )((rlb.rlim_max - (rlim_t )nworkers) - 16UL);
  if (debug) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"max_depth = %d, nworkers = %d\n",
            max_depth, nworkers);
  }
      pqueue_init(pqb, nworkers + 8);    
/*   pqb = pack(unpacked_pqb); */
  pthread_attr_init(& pab);
  pthread_attr_setscope(& pab, 0);
  j = 0;
  while (j < nworkers) {
    tmp___6 = pthread_create((pthread_t * __restrict  )(& tid), (pthread_attr_t const   * __restrict  )(& pab),
                             & worker, (void * __restrict  )((void *)0));
    if (tmp___6 != 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: pthread_create: failed to create worker thread\n",
              (*(argv + 0)));
      exit(1);
    }
    j ++;
  }
  while (1) {
    if (i < argc) {
      tmp___7 = i;
      i ++;
      tmp___8 = do_ftw((*(argv + tmp___7)));
      if (! (tmp___8 == 0)) {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      break;
    }
  }
  pqueue_close(pqb);
  if (debug) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Waiting for workers to finish...\n");
  }
  pthread_mutex_lock(& aworker_lock);
  while (aworkers > 0) {
    pthread_cond_wait((pthread_cond_t * __restrict  )(& aworker_cv), (pthread_mutex_t * __restrict  )(& aworker_lock));
  }
  pthread_mutex_unlock(& aworker_lock);
  if (debug) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"n_files = %d, n_matches = %d, n_workers = %d, n_Mbytes = %d\n",
            n_files, n_matches, nworkers, (int )(n_bytes / 1000000U));
  }
  return (n_matches);
}
}
#pragma merger(0,"/tmp/cil-lV6D3BG1.i","")
extern void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern int tolower(int __c ) ;
extern void *memset(void *__s , int __c , size_t __n ) ;
void bm_destroy(BM *bmp ) ;
static void preBmBc(unsigned char *x , int m , int *bmBc ) 
{ int i ;

  {
  i = 0;
  while (i < 256) {
    (*(bmBc + i)) = m;
    i ++;
  }
  i = 0;
  while (i < m - 1) {
    (*(bmBc + (*(x + i)))) = (m - i) - 1;
    i ++;
  }
  return;
}
}
static void suffixes(unsigned char *x , int m , int *suff ) 
{ int f ;
  int g ;
  int i ;

  {
  f = 0;
  (*(suff + (m - 1))) = m;
  g = m - 1;
  i = m - 2;
  while (i >= 0) {
    if (i > g) {
      if ((*(suff + (((i + m) - 1) - f))) < i - g) {
        (*(suff + i)) = (*(suff + (((i + m) - 1) - f)));
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      if (i < g) {
        g = i;
      }
      f = i;
      while (1) {
        if (g >= 0) {
          if (! ((int )(*(x + g)) == (int )(*(x + (((g + m) - 1) - f))))) {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          break;
        }
        g --;
      }
      (*(suff + i)) = f - g;
    }
    i --;
  }
  return;
}
}
static int preBmGs(unsigned char *x , int m , int *bmGs ) 
{ int *suff ;
  int i ;
  int j ;

  {
  suff = (int *)calloc(sizeof(int ), (unsigned int )m);
  if ((unsigned int )suff == (unsigned int )((void *)0)) {
    return (-1);
  }
  suffixes(x, m, suff);
  i = 0;
  while (i < m) {
    (*(bmGs + i)) = m;
    i ++;
  }
  j = 0;
  i = m - 1;
  while (i >= -1) {
    if (i == -1) {
      goto _L;
    } else {
      if ((*(suff + i)) == i + 1) {
        _L: /* CIL Label */ 
        while (j < (m - 1) - i) {
          if ((*(bmGs + j)) == m) {
            (*(bmGs + j)) = (m - 1) - i;
          }
          j ++;
        }
      }
    }
    i --;
  }
  i = 0;
  while (i <= m - 2) {
    (*(bmGs + ((m - 1) - (*(suff + i))))) = (m - 1) - i;
    i ++;
  }
  free((void *)suff);
  return (0);
}
}
int bm_init(BM *bmp , unsigned char *x , int m , int icase ) 
{ int i ;
  int tmp___2 ;

  {
  memset((void *)bmp, 0, sizeof(bmp));
  bmp->icase = icase;
  bmp->bmGs = (int *)calloc(sizeof(int ), (unsigned int )m);
  if ((unsigned int )bmp->bmGs == (unsigned int )((void *)0)) {
    return (-1);
  }
  bmp->saved_m = m;
  bmp->saved_x = (unsigned char *)malloc((unsigned int )m);
  if ((unsigned int )bmp->saved_x == (unsigned int )((void *)0)) {
    return (-2);
  }
  i = 0;
  while (i < m) {
    if (icase) {
      (*(bmp->saved_x + i)) = (unsigned char )tolower((int )(*(x + i)));
    } else {
      (*(bmp->saved_x + i)) = (*(x + i));
    }
    i ++;
  }
  tmp___2 = preBmGs(bmp->saved_x, m, bmp->bmGs);
  if (tmp___2 < 0) {
    return (-3);
  }
  preBmBc(bmp->saved_x, m, bmp->bmBc);
  return (0);
}
}
void bm_destroy(BM *bmp ) 
{ 

  {
  if (bmp->bmGs) {
    free((void *)bmp->bmGs);
  }
  if (bmp->saved_x) {
    free((void *)bmp->saved_x);
  }
  return;
}
}
int bm_search(BM *bmp , unsigned char *y , size_t n , int (*mfun)(unsigned char *buf ,
                                                                  size_t n , size_t pos ,
                                                                  void *misc ) , void *misc ) 
{ ssize_t i ;
  ssize_t j ;
  int c ;
  int nm ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned char c___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  nm = 0;
  j = 0;
  while ((size_t )j <= n - (size_t )bmp->saved_m) {
    i = bmp->saved_m - 1;
    while (1) {
      if (i >= 0) {
        if (bmp->icase) {
          tmp___0 = tolower((int )(*(y + (i + j))));
        } else {
          tmp___0 = (int )(*(y + (i + j)));
        }
        if (! ((int )(*(bmp->saved_x + i)) == tmp___0)) {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        break;
      }
      i --;
    }
    if (i < 0) {
      if (mfun) {
        nm ++;
        c = ((*mfun))(y, n, (unsigned int )j, misc);
        if (c) {
          if (c < 0) {
            tmp___1 = c;
          } else {
            tmp___1 = nm;
          }
          return (tmp___1);
        }
        j += (*(bmp->bmGs + 0));
      } else {
        return (j);
      }
    } else {
      if (bmp->icase) {
        tmp___3 = tolower((int )(*(y + (i + j))));
      } else {
        tmp___3 = (int )(*(y + (i + j)));
      }
      c___0 = (unsigned char )tmp___3;
      if ((*(bmp->bmGs + i)) < ((bmp->bmBc[c___0] - bmp->saved_m) + 1) + i) {
        tmp___4 = ((bmp->bmBc[c___0] - bmp->saved_m) + 1) + i;
      } else {
        tmp___4 = (*(bmp->bmGs + i));
      }
      j += tmp___4;
    }
  }
  if ((unsigned int )mfun == (unsigned int )((void *)0)) {
    tmp___5 = -1;
  } else {
    tmp___5 = nm;
  }
  return (tmp___5);
}
}
#pragma merger(0,"/tmp/cil-8OboAvU2.i","")
char version[4]  = {      (char )'1',      (char )'.',      (char )'0',      (char )'\000'};
#pragma merger(0,"/tmp/cil-j4ZQRbBQ.i","")
extern int pthread_mutex_destroy(pthread_mutex_t *__mutex ) ;
extern int pthread_cond_init(pthread_cond_t * __restrict  __cond , pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern int pthread_cond_destroy(pthread_cond_t *__cond ) ;
extern int pthread_cond_broadcast(pthread_cond_t *__cond ) ;
void pqueue_destroy(PQUEUE *qp ) ;
int pqueue_init(PQUEUE *qp , int qsize ) 
/* int pqueue_init(PQUEUE __attribute__((packed))*qp , int qsize ) */
{ 

  {
  qp->buf = (void **)calloc(sizeof(void *), (unsigned int )qsize);
  if ((unsigned int )qp->buf == (unsigned int )((void *)0)) {
    return ((int )((void *)0));
  }
  qp->qsize = qsize;
  qp->occupied = 0;
  qp->nextin = 0;
  qp->nextout = 0;
  qp->closed = 0;
  pthread_mutex_init((pthread_mutex_t * __restrict  )(& qp->mtx), (pthread_mutexattr_t const   * __restrict  )((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& qp->more), (pthread_condattr_t const   * __restrict  )((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& qp->less), (pthread_condattr_t const   * __restrict  )((void *)0));
  return (0);
}
}
void pqueue_close(PQUEUE *qp ) 
{ 

  {
/*   start_unpack(qp); */
  pthread_mutex_lock(& qp->mtx);
  qp->closed = 1;
  pthread_mutex_unlock(& qp->mtx);
  pthread_cond_broadcast(& qp->more);
/*   end_unpack(qp); */
  return;
}
}
int pqueue_put(PQUEUE *qp , void *item ) 
{ int tmp ;

  {
/*   start_unpack(qp); */
  pthread_mutex_lock(& qp->mtx);
  if (qp->closed) {
    return (0);
  }
  while (qp->occupied >= qp->qsize) {
    pthread_cond_wait((pthread_cond_t * __restrict  )(& qp->less), (pthread_mutex_t * __restrict  )(& qp->mtx));
  }
  tmp = qp->nextin;
  qp->nextin = qp->nextin + 1;
  (*(qp->buf + tmp)) = item;
  qp->nextin = qp->nextin % qp->qsize;
  qp->occupied = qp->occupied + 1;
  pthread_mutex_unlock(& qp->mtx);
  pthread_cond_signal(& qp->more);
/*   end_unpack(qp); */
  return (1);
}
}
int pqueue_get(PQUEUE *qp , void **item ) 
{ int got ;
  int tmp ;

  {
  got = 0;
/*   start_unpack(qp); */
  pthread_mutex_lock(& qp->mtx);
  while (1) {
    if (qp->occupied <= 0) {
      if (! (! qp->closed)) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      break;
    }
    pthread_cond_wait((pthread_cond_t * __restrict  )(& qp->more), (pthread_mutex_t * __restrict  )(& qp->mtx));
  }
  if (qp->occupied > 0) {
    tmp = qp->nextout;
    qp->nextout = qp->nextout + 1;
    (*item) = (*(qp->buf + tmp));
    qp->nextout = qp->nextout % qp->qsize;
    qp->occupied = qp->occupied - 1;
    got = 1;
    pthread_mutex_unlock(& qp->mtx);
    pthread_cond_signal(& qp->less);
  } else {
    pthread_mutex_unlock(& qp->mtx);
  }
/*   end_unpack(qp); */
  return (got);
}
}
void pqueue_destroy(PQUEUE *qp ) 
{ 

  {
/*     start_unpack(qp); */
  pthread_mutex_destroy(& qp->mtx);
  pthread_cond_destroy(& qp->more);
  pthread_cond_destroy(& qp->less);
  free((void *)qp->buf);
/*     end_unpack(qp); */
  return;
}
}
